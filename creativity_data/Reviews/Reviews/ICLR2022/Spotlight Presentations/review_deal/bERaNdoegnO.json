{
    "Decision": {
        "title": "Paper Decision",
        "decision": "Accept (Spotlight)",
        "comment": "The paper presents improvements to AlphaZero and MuZero for settings where one is restricted in the number of rollouts. The initial response from reviewers was generally favorable  but the reviewers wanted more details and clarifications of multiple parts of the paper, and further intuition about the Gumbel distribution.  The authors’ responses were detailed and convinced or maintained strong positive support of most reviewers. The authors also stated that they plan to provide a release of the code and also provided a policy improvement proof. Overall this is an interesting approach that is likely to be of significant interest to many."
    },
    "Reviews": [
        {
            "summary_of_the_paper": "The paper proposes a number of principled algorithmic modifications to state-of-the-art planning algorithms (AlphaZero, MuZero) for improving performance in settings with many actions and a relatively small computation and / or sample budget. The main contributions are algorithmic and empirical. The key ideas include the use of the Gumbel-max and top-k tricks along with the use of sequential halving to improve online planning. The paper also proposes a planning-learning loop wherein a policy using the estimated (completed) Q values is learned as well as a different selection policy at non-root nodes. The experiments show that the Gumbel variants of AlphaZero and MuZero perform well in low search budget settings in the domains of Go, Chess and Atari.",
            "main_review": "- The paper proposes a series of principled improvements to state-of-the-art MCTS planning algorithms. The proposed improvements are particularly effective in low simulation budget settings. The proposed improvements (Gumbel tricks to incorporate the policy network into the tree search, simple regret minimization at the root, planning-learning loop and action selection at non-root nodes) are intuitively clear.\n- The details on the planning-learning loop are somewhat sparse. Some of my questions were: What exactly is the update mechanism? Which nodes in the tree search are used to generate training data? These details about the learned policy network seems particularly important given the target setting of very small simulation budgets implying limited lookahead.\n- At the smaller simulation budgets, I'd expect the impact of planning to performance is likely limited compared to the learned policy. Is this correct? I'd be curious to better understand how much benefit there is to planning versus simply using the reactive policy without lookahead at the smaller simulation budgets. Please consider including the learned reactive policy as a baseline in the experiments. Some timing information (per decision) would be nice as well to better understand the overhead involved in each method. This might help improve the motivation for planning in small-budget settings, which is currently not described in much detail.\n- Overall, the paper contains a number of intuitively clear, principled algorithmic improvements to AlphaZero (and MCTS in general) when used in low budget settings. The learning-planning portion of the paper can be improved with additional detail. The paper is well written and I enjoyed reading it. I think this will make a nice contribution to the literature on anytime planning algorithms with learned components.\n\nUPDATE: I thank the authors for their feedback. After reading it along with the other reviews, I continue to remain positive about the paper.",
            "summary_of_the_review": "Improves anytime planning with a learned component in low simulation budget settings. Could be improved with a bit more detail on the learning-planning loop and additional baselines. Overall, seems like a solid paper to me. ",
            "correctness": "4: All of the claims and statements are well-supported and correct.",
            "technical_novelty_and_significance": "3: The contributions are significant and somewhat new. Aspects of the contributions exist in prior work.",
            "empirical_novelty_and_significance": "3: The contributions are significant and somewhat new. Aspects of the contributions exist in prior work.",
            "flag_for_ethics_review": [
                "NO."
            ],
            "recommendation": "8: accept, good paper",
            "confidence": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
        },
        {
            "summary_of_the_paper": "This paper proposes several adjustments to how actions are selected at various stages of the tree searches in AlphaZero/MuZero, with a particular focus on modifications that can significantly improve training performance in training regimes with extremely low iteration budgets per move (even successful training with only 2 iterations per step). Experiments are run using Go, Chess, and two Atari games.",
            "main_review": "**Primary Strengths**:\n1) Several interesting adjustments of how the MCTS operates in AlphaZero/MuZero.\n2) Strong results (including interesting ablations in appendices).\n3) Majority of paper well-written and clear.\n\n**Primary Weaknesses**:\n1) While the majority of the paper is clear, some technical details are (in my opinion) sometimes not clear / only become clear much later on --- including sometimes really important details. See detailed comments below.\n2) No mention of whether source code will be made available.\n\n---\n\n**Detailed Comments**:\n- At end of page 1, for **Selecting actions to search**, should probably explicitly mention that this Dirichlet noise in AlphaZero is only used in the root (for consistency with some of the subsequent points where you also explicitly make the distinction of root vs. non-root).\n- Top of page 2: \"We instead propose to select the singular action resulting from the Sequential Halving search procedure.\" --> I interpreted this as saying that you do not do any exploration at all, purely \"greedy\" playing, even during the training phase. Only all the way down in Appendix E did it become clear that you do in fact using exploration during training, which contradicts this, so then I assume this actually only refers to evaluation games. This should be clarified.\n- In Introduction, the phrase \"We instead propose a policy improvement based upon a completion of the root action vales\" did not at all paint a picture in my head resembling what actually happens in Section 4. Especially it's difficult to imagine, without reading the entire paper, what *completion of values* would mean. I think I would simplify it and simply say that it's a policy improvement operator based on estimated action values (or advantages). The completion of values (or really, completion of *vectors of values*, i.e. filling in \"missing entries\") is more of an \"annoying\" detail necessary to handle situations where some actions didn't get any values, but I don't get the impression that it's actually the core idea; the policy improvement operator still works when there are enough visits to visit every action!\n- Under Figure 1, I assume that the $b$ actions in $\\max_b N(b)$ that the max iterates over are children / successors / actions of the root node, but this should be made explicit.\n- The main paper summarises the proposed policy improvement operator as Eq. (11), and states that a proof for it being a policy improvement operator can be found in Appendix B. However, in Appendix B, I instead find a proof for Algorithm 3, and Algorithm 3 looks very different to Eq. (11). I can... sort of imagine that they might end up working out to the same / a similar thing after the softmax normalises everything into a probability distribution again, but this really doesn't seem obvious. Is it possible to elaborate on this? \n- Related to the previous point, I also don't find the intuition suggested by \"Intuitively, the completed $Q$-values give zero advantage to the unvisited actions.\" particularly intuitive. What if all the $q(a)$ values for the visited actions end up being \"disappointing\", all lower than the expected value for the root based on value network? Surely then the $v_{\\pi}$ values would exceed the $q(a)$ values and actually give a positive advantage to unvisited actions? Algorithm 3 in Appendix B does match this intuition much more closely, because only actions that have $q(a)$ values get updated explicitly... although, of course, the subsequent normalisation of the softmax will implicitly then also update unvisited actions again.\n- Eq. (14) uses $\\pi'(a)$, computed according to Eq. (11), every time the node for which $a$ is an action gets visited. But in between different such visits, its $q(a')$ values (for actions $a'$ that may or may not equal $a$) get updated, so I assume $\\pi'(a)$ also gets re-computed to take into account the latest $q$ values? Would be good to explicitly mention this.\n- \"We cannot use a deterministic action selection at the root node, because we do not remember the visit counts from the same (or similar) state visited in previous episodes.\" --> I do not understand what this is trying to say. I can certainly understanding a preference for a different action selection method (for example, because we care about simple regret in root, but cumulative regret in non-roots)... but this seems to be saying something else?\n- Which agent do you evaluate against in Chess experiments? For Go it was Pachi, but I think that agent doesn't play Chess?\n- Appendix C, Eq. (30): please use larger brackets for the big expression after the first fraction. It's rather difficult to read like this, at first I thought there was a missing closing bracket somewhere.\n\n**Other Remarks**:\n- I am *very* curious if it would be possible to make this approach work even without a value network $\\hat{v}_{\\pi}$. It appears to play a relatively \"small\" role, and already gets mixed with a value estimate based on the children visited so far. What would happen if the value of the policy were estimated solely based on the values backpropagated from previous visits to (other) children? I suppose in practice you would need the value network also to produce the \"bandit rewards\", but those could be replaced with rollouts... I'm by no means expecting/demanding that large extra experiments get added for this, just curious if the authors happen to already have some insights into this.",
            "summary_of_the_review": "Overall a strong paper, with at this point unfortunately slightly too many places where technical details are not entirely clear or only become clear much later than they should be. Based on the strength of the rest of the paper, I do expect that the authors should be able to clear things up (either in the paper or in comments to my review explaining why I'm wrong) without too much trouble, but I do think it is important to do this before it can be published!",
            "correctness": "3: Some of the paper’s claims have minor issues. A few statements are not well-supported, or require small changes to be made correct.",
            "technical_novelty_and_significance": "3: The contributions are significant and somewhat new. Aspects of the contributions exist in prior work.",
            "empirical_novelty_and_significance": "4: The contributions are significant, and do not exist in prior works.",
            "flag_for_ethics_review": [
                "NO."
            ],
            "recommendation": "6: marginally above the acceptance threshold",
            "confidence": "4: You are confident in your assessment, but not absolutely certain. It is unlikely, but not impossible, that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work."
        },
        {
            "summary_of_the_paper": "This paper redesigns AlphaZero and MuZero with the principle of policy improvement and claims the following. By using the Gumbel-Top-k trick, the completed Q-values, and some other mechanisms, this paper shows the proposed solutions, Gumbel MuZero and Gumbel AlphaZero, learn reliably even with only two simulations, and the experiments in this paper show that the proposed methods match the performance of the original MuZero and AlphaZero.\n",
            "main_review": "This paper proposes to improve AlphaZero and MuZero with the principle of policy improvement by using Gumbel. This paper presents empirical results as well as a theoretical proof. While the method looks interesting especially for the case of using only 2 simulations, some concerns and comments are listed as follows. \n\nFirst, the intuition of applying Gumbel to AlphaZero/MuZero is not well described. Why would Gumbel distribution outperform the current popular UCT (or PUCT) for AlphaZero/MuZero in some cases? \n\nThe authors need to clarify why Equation (7) only needs to consider actions in $A_{topn}$ instead of all actions, while still maintaining policy improvement and satisfying its proof in Appendix. As in (6), the authors state that $E[q(A_{n+1})] \\geq \\sum_a(\\pi(a) * q(a))$ produces a policy improvement, and give Example 1 of Section 3.2, showing that AlphaZero may fail for policy improvement. However, the proposed Algorithm 1 (or 2) may also fail for policy improvement, since in the proposed algorithm the Gumbel method with n = 2 may encounter the same case (even for a simple case g = (1,1,1)). In the current presentation, it is not convincing. \n\nIn Algorithm 2, the statement is unclear “Use Sequential Halving with n simulations ...”. Do you mean by recursively using Sequential Halving? Anyway, a lot of messages are missing in “Sequential Halving”, particularly related to any subtree searches (MCTS?) or rollouts (or MuZero) (as in Figure 1). Without knowing this, it is hard to clarify the algorithm. Maybe, the authors should provide the pseudo code for better understanding and comparison, particularly for the whole learning process for both Full Gumbel MuZero and Gumbel MuZero methods.\n\nIn the experiments of Go in Section 7.1 and 7.2, the authors anchored to Pachi at 1000 Elo. However, the variance would become high for more than 400 Elo difference, and hence makes Figure 3 and Figure 4 unconvincing. The authors should also evaluate confidence intervals as well, and may consider to use other strong Go programs, e.g., KataGo.\n\nAlthough Figures 2 and 4 show Elo strength growth, it is more interesting to see if there is any limitation about the strength, i.e., whether the strength will be limited to a certain level (e.g., up to which level when compared with kataGo?). After all, we want to know the limit we can push to, especially for AlphaZero-like methods. Note that I know it would take a huge amount of time for 19x19 Go, however, I think it should work for 9x9. \n\nThis paper proposes to redesign the selection for the non-root nodes in Section 5, named “Full Gumbel MuZero”. However, in Figures 4 and 7, Full Gumbel MuZero does not seem to have a clear advantage over Gumbel MuZero. That is, it seems that Gumbel MuZero already worked well without this additional improvement. The authors should give more discussion. \n\nIn experiments, more information needs to be shown. For example, the training times, training steps, inferencing times, and the computing resources of the experiments. This is important when using fewer simulations that may significantly reduce these.  \n\nSome minor presentation issues are listed as follows.\n* In Section 3.1 and in Equation (7), q(a) in [0, 1] should be explicitly defined.\n* In Equation (8), is action b the sibling or the children of action a?\n* In Equation (11), is sigma the same as the definition in Equation (8)?\n* In Section 7.1, for the 9x9 Go, when n is small, is the Sequential Halving applied? Note that the authors state that “Gumbel MuZero with n <= 18 selects without Sequential Halving” only for Atari games (in Section 7.3), but not for Go and Chess.\n* In Figure 7 of Appendix C, how does the “Stochastic non-root” select actions?\n",
            "summary_of_the_review": "This paper proposes to improve AlphaZero and MuZero with the principle of policy improvement by using Gumbel. This paper presents empirical results as well as a theoretical proof. While the method looks interesting especially for using only 2 simulations, some comments are concerned as described above. \n",
            "correctness": "4: All of the claims and statements are well-supported and correct.",
            "technical_novelty_and_significance": "4: The contributions are significant, and do not exist in prior works.",
            "empirical_novelty_and_significance": "4: The contributions are significant, and do not exist in prior works.",
            "flag_for_ethics_review": [
                "NO."
            ],
            "recommendation": "8: accept, good paper",
            "confidence": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
        },
        {
            "summary_of_the_paper": "This paper considers MCTS with learned search guidance, as in AlphaZero, MuZero, etc. The work proposes several adjustments to the prior works, particularly regarding the way in which actions are selected at the root and non-root nodes, at training and during evaluation; and also the way in which the policy is updated after search. In a simplified bandits setting, the authors point out that the previous method of performing policy updates is not guaranteed to result in a policy improvement, and they propose using a Gumbel reparameterization trick to overcome this limitation. Experiments in Go, Chess, and Atari show that the adjustments are beneficial in the regime of low simulation count.",
            "main_review": "## Strengths\n\n* This paper was a breath of fresh air in terms of clarity! Very well written overall. I very much liked the progression from deterministic bandit to stochastic bandit to MCTS.\n* I like that the paper emphasizes simple regret instead of cumulative. I completely agree that this is the regret that we should care about in a planning setting.\n* The related work is thorough and seems to hit on all the main relevant areas. The authors demonstrate a deep and comprehensive understanding of the literature.\n* Though code was not provided, the experimental details look sufficient to reproduce the main results (hardware permitting…)\n\n\n## Weaknesses/Questions\n\n* I want to better understand what it is about Gumbel specifically that is important here. The paper makes clear that differentiability is not a factor. Instead, Gumbel is used in Algorithm 1 to satisfy Inequality 6. But it seems that the Gumbel distribution itself is not really important -- what’s important to achieve the inequality is that the same $g$ is used both for action selection during search, and for policy improvement after search. Would the same result be achieved in practice by “re-seeding” a random number generator and sampling from the categorical distribution of actions, for example?\n* Using completed Q-values to train an improved policy, as described in section 4, makes sense. But if we can do that, don’t we automatically avoid the policy improvement issues exemplified by Example 1, without needing to “plan with Gumbel” as in Algorithm 1? In other words, why can’t we just use Equation 11 (which has nothing to do with Gumbel) instead of using Algorithm 1 to define the improved policy?\n* I understand that high variance in action selection could be problematic, and determinism seems like a reasonable hack. But is there any theoretical basis for this?\n* I did not understand this sentence: “We cannot use a deterministic action selection at the root node, because we do not remember the visit counts from the same (or similar) state visited in previous episodes.” Could you explain/elaborate?\n* The results in Figure 2 use only two random seeds. I know these experiments are very expensive, but two random seeds is just not enough for us to draw meaningful conclusions about statistical significance, so I am interpreting these results with a huge grain of salt. I am glad that 10 seeds were used in Atari.\n* The motivation for learning more efficiently from fewer simulations is presumably that with fewer simulations, the overall algorithm runs faster. To what extent is this the case in practice? Approximately how much faster is it to train MuZero with 2 simulations vs 200? Are the simulations the speed bottleneck?\n* It is good to see some ablation results, but it would be most ideal if each of the improvements claimed over the original Alpha/MuZero had an associated ablation. \n\nThe improvements claimed in the introduction are:\n   1. Selecting actions to search (using Algorithm 1 instead of Dirichlet noise)\n   2. Selecting actions at the root (using Sequential Halving instead of PUCB)\n   3. Selecting actions in the environment (using the Sequential Halving result directly instead of sampling from softmax)\n   4. Policy network update (Q-value completion instead of softmax visit count)\n   5. Selecting actions (improved policy instead of PUCT)\n        \n        The ablations in the paper are:\n   * Figure 3a and 6: (d) policy network update\n   * Figure 7: (e) selecting actions\n   * Figure 8:  (none of the above) other ablations on hyperparameters\n        \n        So it would be good to also include ablations for (a), (b), and (c). Let me know if I’ve misaligned anything.\n \n## Minor\n\n   * “we will focus at the action selection” → “we will focus *on* the action selection”\n   * In Algorithm 2, is the “Remaining” in the argmax just a singleton set of the best action found by sequential halving? If so, it might be clearer to just say that $A_{n+1}$ is equal to that best action.\n   * I happened to already know about Sequential Halving, but it’s likely that a more general audience would not. Maybe add a few sentences explaining it -- the caption in Figure 1 does this to some degree, so just including that description in the main text and saying a bit more would be good.\n   * In that spirit, it would be good to give a little more background overall -- for example, clearly stating all of the different subproblems that must be solved in Alpha/MuZero. These subproblems are implicit in the contribution bullet points in the introduction, but they are also not exhaustive.",
            "summary_of_the_review": "This paper is likely to be of theoretical and practical interest to many in the ICLR community. My recommendation is not yet higher because I am not convinced of the framing around “planning with Gumbel” and because of the concerns surrounding experiments that I mentioned above.",
            "correctness": "4: All of the claims and statements are well-supported and correct.",
            "technical_novelty_and_significance": "3: The contributions are significant and somewhat new. Aspects of the contributions exist in prior work.",
            "empirical_novelty_and_significance": "3: The contributions are significant and somewhat new. Aspects of the contributions exist in prior work.",
            "flag_for_ethics_review": [
                "NO."
            ],
            "recommendation": "8: accept, good paper",
            "confidence": "3: You are fairly confident in your assessment. It is possible that you did not understand some parts of the submission or that you are unfamiliar with some pieces of related work. Math/other details were not carefully checked."
        }
    ]
}