Published as a conference paper at ICLR 2017
An Actor-Critic Algorithm
for Sequence Prediction
Dzmitry Bahdanau Philemon Brakel
Kelvin Xu Anirudh Goyal
Universite de Montreal
Aaron CourviHet
Universite de Montreal
Ryan LoWe Joelle Pineau*
McGill University
Yoshua Bengio*
Universite de Montreal
Ab stract
We present an approach to training neural networks to generate sequences using
actor-critic methods from reinforcement learning (RL). Current log-likelihood
training methods are limited by the discrepancy between their training and testing
modes, as models must generate tokens conditioned on their previous guesses
rather than the ground-truth tokens. We address this problem by introducing a critic
network that is trained to predict the value of an output token, given the policy
of an actor network. This results in a training procedure that is much closer to
the test phase, and allows us to directly optimize for a task-specific score such as
BLEU. Crucially, since we leverage these techniques in the supervised learning
setting rather than the traditional RL setting, we condition the critic network on the
ground-truth output. We show that our method leads to improved performance on
both a synthetic task, and for German-English machine translation. Our analysis
paves the way for such methods to be applied in natural language generation tasks,
such as machine translation, caption generation, and dialogue modelling.
1	Introduction
In many important applications of machine learning, the task is to develop a system that produces a
sequence of discrete tokens given an input. Recent work has shown that recurrent neural networks
(RNNs) can deliver excellent performance in many such tasks when trained to predict the next output
token given the input and previous tokens. This approach has been applied successfully in machine
translation (Sutskever et al., 2014; Bahdanau et al., 2015), caption generation (Kiros et al., 2014;
Donahue et al., 2015; Vinyals et al., 2015; Xu et al., 2015; Karpathy & Fei-Fei, 2015), and speech
recognition (Chorowski et al., 2015; Chan et al., 2015).
The standard way to train RNNs to generate sequences is to maximize the log-likelihood of the
“correct” token given a history of the previous “correct” ones, an approach often called teacher forcing.
At evaluation time, the output sequence is often produced by an approximate search for the most
likely candidate according to the learned distribution. During this search, the model is conditioned
on its own guesses, which may be incorrect and thus lead to a compounding of errors (Bengio
et al., 2015). This can become especially problematic for longer sequences. Due to this discrepancy
between training and testing conditions, it has been shown that maximum likelihood training can
be suboptimal (Bengio et al., 2015; Ranzato et al., 2015). In these works, the authors argue that
the network should be trained to continue generating correctly given the outputs already produced
by the model, rather than the ground-truth reference outputs from the data. This gives rise to the
challenging problem of determining the target for the next network output. Bengio et al. (2015) use
the token k from the ground-truth answer as the target for the network at step k, whereas Ranzato
et al. (2015) rely on the REINFORCE algorithm (Williams, 1992) to decide whether or not the tokens
* CIFAR Senior Fellow
Ffar Fellow
1
Published as a conference paper at ICLR 2017
from a sampled prediction lead to a high task-specific score, such as BLEU (Papineni et al., 2002) or
ROUGE (Lin & Hovy, 2003).
In this work, we propose and study an alternative procedure for training sequence prediction networks
that aims to directly improve their test time metrics (which are typically not the log-likelihood). In
particular, we train an additional network called the critic to output the value of each token, which
we define as the expected task-specific score that the network will receive if it outputs the token and
continues to sample outputs according to its probability distribution. Furthermore, we show how the
predicted values can be used to train the main sequence prediction network, which we refer to as the
actor. The theoretical foundation of our method is that, under the assumption that the critic computes
exact values, the expression that we use to train the actor is an unbiased estimate of the gradient of
the expected task-specific score.
Our approach draws inspiration and borrows the terminology from the field of reinforcement learning
(RL) (Sutton & Barto, 1998), in particular from the actor-critic approach (Sutton, 1984; Sutton et al.,
1999; Barto et al., 1983). RL studies the problem of acting efficiently based only on weak supervision
in the form of a reward given for some of the agent’s actions. In our case, the reward is analogous
to the task-specific score associated with a prediction. However, the tasks we consider are those
of supervised learning, and we make use of this crucial difference by allowing the critic to use the
ground-truth answer as an input. In other words, the critic has access to a sequence of expert actions
that are known to lead to high (or even optimal) returns. To train the critic, we adapt the temporal
difference methods from the RL literature (Sutton, 1988) to our setup. While RL methods with
non-linear function approximators are not new (Tesauro, 1994; Miller et al., 1995), they have recently
surged in popularity, giving rise to the field of ‘deep RL’ (Mnih et al., 2015). We show that some of
the techniques recently developed in deep RL, such as having a target network, may also be beneficial
for sequence prediction.
The contributions of the paper can be summarized as follows: 1) we describe how RL methodology
like the actor-critic approach can be applied to supervised learning problems with structured outputs;
and 2) we investigate the performance and behavior of the new method on both a synthetic task and a
real-world task of machine translation, demonstrating the improvements over maximum-likelihood
and REINFORCE brought by the actor-critic training.
2	Background
We consider the problem of learning to produce an output sequence Y = (y1, . . . , yT), yt ∈ A
given an input X, where A is the alphabet of output tokens. We will often use notation Yf...l to
refer to subsequences of the form (yf, . . . , yl). Two sets of input-output pairs (X, Y ) are assumed
to be available for both training and testing. The trained predictor h is evaluated by computing the
average task-specific score R(Y , Y ) on the test set, where Y = h(X) is the prediction. To simplify
the formulas we always use T to denote the length of an output sequence, ignoring the fact that the
output sequences may have different length.
Recurrent neural networks A recurrent neural network (RNN) produces a sequence of state
vectors (s1, . . . , sT) given a sequence of input vectors (e1, . . . , eT) by starting from an initial s0 state
and applying T times the transition function f: st = f(st-1, et). Popular choices for the mapping f
are the Long Short-Term Memory (Hochreiter & Schmidhuber, 1997) and the Gated Recurrent Units
(Cho et al., 2014), the latter of which we use for our models.
To build a probabilistic model for sequence generation with an RNN, one adds a stochastic output
layer g (typically a softmax for discrete outputs) that generates outputs yt ∈ A and can feed these
outputs back by replacing them with their embedding e(yt):
yt 〜g(st-ι)
st = f(st-1, e(yt)).
(1)
(2)
Thus, the RNN defines a probability distribution p(yt|y1, . . . , yt-1) of the next output token yt
given the previous tokens (yι,..., yt-ι). UPon adding a special end-of-SeqUence token 0 to the
alphabet A, the RNN can define the distribution p(Y ) over all possible sequences as p(Y ) =
p(y1)p(y2|y1) . . .p(yT|y1, . . . , yT-1)p(0|y1, . . . ,yT).
2
Published as a conference paper at ICLR 2017
RNNs for sequence prediction To use RNNs for sequence prediction, they must be augmented
to generate Y conditioned on an input X . The simplest way to do this is to start with an initial
state s0 = s0 (X) (Sutskever et al., 2014; Cho et al., 2014). Alternatively, one can encode X as a
variable-length sequence of vectors (h1, . . . , hL) and condition the RNN on this sequence using an
attention mechanism. In our models, the sequence of vectors is produced by either a bidirectional
RNN (Schuster & Paliwal, 1997) or a convolutional encoder (Rush et al., 2015).
We use a soft attention mechanism (Bahdanau et al., 2015) that computes a weighted sum of a
sequence of vectors. The attention weights determine the relative importance of each vector. More
formally, we consider the following equations for RNNs with attention:
yt 〜g(st-ι,ct-ι)
st = f(st-1, ct-1, e(yt))
αt = β(st, (h1, . . . , hL))
L
ct =	αt,jhj
j=1
(3)
(4)
(5)
(6)
where β is the attention mechanism that produces the attention weights αt and ct is the context vector,
or ‘glimpse’, for time step t. The attention weights are computed by an MLP that takes as input the
current RNN state and each individual vector to focus on. The weights are typically (as in our work)
constrained to be positive and sum to 1 by using the softmax function.
A conditioned RNN can be trained for sequence prediction by gradient ascent on the log-likelihood
log P(Y X) for the input-output pairs (X, Y) from the training set. To produce a prediction Y for a
test input sequence X, an approximate beam search for the maximum of p(∙∣X) is usually conducted.
During this search the probabilities p(∙∣yι,..., yt-ι) are considered, where the previous tokens
yι,..., yt-ι comprise a candidate beginning of the prediction Y.
Value functions We view the conditioned RNN as a stochastic policy that generates actions and
receives the task score (e.g., BLEU score) as the return. We furthermore consider the case when
.1	.	TΛ ∙	. ∙	11	1∙	.	∙	.1 i'	i'	1	C ∕<y ，广、
the return R is partially received at the intermediate steps in the form of rewards rt: R(Y, Y) =
T
∑2t=ι rt(yt； Y1...t-1,Y). This is more general than the case of receiving the full return at the end of
the sequence, as we can simply define all rewards other than rT to be zero. Receiving intermediate
rewards may ease the learning for the critic, and we use reward shaping as explained in Section 3.
Given the policy, possible actions and reward function, the value represents the expected future return
as a function of the current state of the system, which in our case is uniquely defined by the sequence
of actions taken so far, Y! .1.
We define the value of an unfinished prediction Yl...t as follows:
T
V(Y" X，Y )= Yt+ι...τ ~E.*..,,X) T Ni"; YL/T,Y ).
We define the value of a candidate next token a for an unfinished prediction Yi…t-ι as the expected
future return after generating token a:
ʌ
Q (a; Y1...t-1,X,Y )=.	E
Yt十ι...τ 〜p(.| Yl …t-ιa,X)
T
,	__ x__, .	ʌ	_
t (a; Yi...t-i ,Y)+ E TTeT; Y1...t-iaYt+ι…T, Y)
T =t+i
We will refer to the candidate next tokens as actions. For notational simplicity, we henceforth drop X
and Y from the signature ofp, V, Q, R and rt, assuming it is clear from the context which of X and
Y is meant. We will also use V without arguments for the expected reward of a random prediction.
3
Published as a conference paper at ICLR 2017
Algorithm 1 Actor-Critic Training for Sequence Prediction
Require: A critic Q(a; Y1...t, Y ) and an actor p(a|Y1...t, X) with weights φ and θ respectively.
1:	Initialize delayed actor p and target critic Q0 with same weights: θ0 = θ, φ0 = φ.
2:	while Not Converged do
3:	Receive a random example (X, Y ).
4:	Generate a sequence of actions Y from p .
5:	Compute targets for the critic
qt = rt(yt；Yi …t-i,Y) + X p0(a∣Y1 …t,X )Q0(a; Y⅛...t,Y)
a∈A
6:	Update the critic weights φ using the gradient
dφ (X (Q(Ot; YI…t-ι,Y) - q) + λcCt)
where Ct = X (Q(a; Y1...t-1) - |A| X Q(b； Y1...t-1)!
7:	Update actor weights θ using the following gradient estimate
T
dV (X, Y)	XX dp(a£ …t-1,X )A∕ ,ʌ V、
=工工---------------dθ--------Q(a； γ1...t-1 ,γ)
t=1 a∈A
G dp(yt|Yi...t-i,X)
+入1 LL工 dθ
t=1
8:	Update delayed actor and target critic, with constants γθ	1, γφ	1
θ0 = γθθ + (1 - γθ)θ0, φ0 = γφφ + (1 - γφ)φ0
9:	end while
Algorithm 2 Complete Actor-Critic Algorithm for Sequence Prediction
1: Initialize critic Q(a; Y1...t, Y) and actorp(a|Y1...t, X) with random weights φ and θ respectively.
2: Pre-train the actor to predict yt+1 given Y1...t by maximizing log p(yt+1 |Y1...t, X).
3: Pre-train the critic to estimate Q by running Algorithm 1 with fixed actor.
4: Run Algorithm 1.
4
Published as a conference paper at ICLR 2017
3 Actor-Critic for Sequence Prediction
Let θ be the parameters of the conditioned RNN, which we will also refer to as the actor. Our training
algorithm is based on the following way of rewriting the gradient of the expected return 端:
T
dV
^dθ
E
Y 〜P(Y∣X)
ΣΣ
t=1 a∈A
dp(a∣Y1 …t-i)
dθ
Q(a; Y1...t-1).
(7)
This equality is known in RL under the names policy gradient theorem (Sutton et al., 1999) and
stochastic actor-critic (Sutton, 1984). 1 Note that we use the probability rather than the log probability
in this formula (which is more typical in RL applications) as we are summing over actions rather
than taking an expectation. Intuitively, this equality corresponds to increasing the probability of
actions that give high values, and decreasing the probability of actions that give low values. Since
this gradient expression is an expectation, it is trivial to build an unbiased estimate for it:
d
^dθ
MT	k
XXX dp"...1) Q(a; Y1k.t-1)
k=1 t=1 a∈A
(8)
1	WL	Tl ʃ	1	IC	∕W∖ 1 ʌ	1	ʌʌ ∙ ,1	,	, ∙	, ʌ
where Y k are M random samples from p(Y ). By replacing Q with a parameteric estimate Q one can
obtain a biased estimate with relatively low variance. The parameteric estimate Q is called the critic.
The above formula is similar in spirit to the REINFORCE learning rule that Ranzato et al. (2015) use
in the same context:
d
^dθ
MT
kX=1Xt=1
d log P(yIYk.t-ι)
dθ
T
X rτ(yτ ； Yk.τ-i)-bt(X)
τ=t
(9)
where the scalar bt (X) is called baseline or control variate. The difference is that in
REINFORCE the inner sum over all actions is replaced by its 1-sample estimate, namely
dlogp(鹤…t-1) Q(yt； Y1...t-1), where the log probability dlogp(ytl…)=pɪɔ (Id%)is intro-
duced to correct for the sampling of yt. Furthermore, instead of the value Q(yt； Y1...t-1), REIN-
T
FORCE uses the cumulative reward ET=t rτ(yτ； Yι...τ-ι) following the action yt, which again can
be seen as a 1-sample estimate of Q. Due to these simplifications and the potential high variance
in the cumulative reward, the REINFORCE gradient estimator has very high variance. In order to
improve upon it, we consider the actor-critic estimate from Equation 8, which has a lower variance at
the cost of significant bias, since the critic is not perfect and trained simultaneously with the actor.
The success depends on our ability to control the bias by designing the critic network and using an
appropriate training criterion for it.
To implement the critic, we propose to use a separate RNN parameterized by φ. The critic RNN is
run in parallel with the actor, consumes the tokens y that the actor outputs and produces the estimates
Q(a； Y1...t) for all a ∈ A. A key difference between the critic and the actor is that the correct answer
Y is given to the critic as an input, similarly to how the actor is conditioned on X . Indeed, the return
R(Y, Y) is a deterministic function of Y, and we argue that using Yto compute Q should be of great
help. We can do this because the values are only required during training and we do not use the critic
at test time. We also experimented with providing the actor states st as additional inputs to the critic.
See Figure 1 for a visual representation of our actor-critic architecture.
Temporal-difference learning A crucial component of our approach is policy evaluation, that
is the training of the critic to produce useful estimates of Q. With a naive Monte-Carlo method,
T
one could use the future return ET=t r (yi； Yι...τ-ι) as a target to Q(yt； Y1...t-1), and use the
critic parameters φ to minimize the square error between these two values. However, like with
REINFORCE, using such a target yields to very high variance which quickly grows with the number
of steps T. We use a temporal difference (TD) method for policy evaluation (Sutton, 1988). Namely,
∙ -t . -t	1	1	/ ʌ √>	∖
we use the right-hand side qt = rt(yt； Yι...t-ι) + EaeA
equation as the target for the left-hand Q(yt； Y1 …t-ι).
p(a∣Y1 …t)Q(a； Yl..t) of the Bellman
1We also provide a simple self-contained proof of Equation (7) in Supplementary Material.
5
Published as a conference paper at ICLR 2017
Actor pθ
(Decoder
QLQ2,…)Qt
Critic Qφ
Decoder
、、、、、初,方2,T./
k Encoder
Encoder
% % ' " ->^L
actor states λ, 0, rtf
^ι,z∕2√∙∙ ,yτ
Figure 1: Both the actor and the critic are encoder-decoder networks. The actor receives an input
sequence X and produces samples Y which are evaluated by the critic. The critic takes in the
ground-truth sequence Y as input to the encoder, and takes the input summary (calculated using
an attention mechanism) and the actor's prediction yt as input at time step t of the decoder. The
values Q1,Q2,…，QT computed by the critic are used to approximate the gradient of the expected
returns with respect to the parameters of the actor. This gradient is used to train the actor to optimize
these expected task specific returns (e.g., BLEU score). The critic may also receive the hidden state
activations of the actor as input.
A	■ *	1	lɪɪ W ， 1 ♦	τ. 1	1	1	∙ .1 I-AT 1∙ .	.1 . ∙ /` ʌ ∙	1 ∙	/1 ∙-l
Applying deep RL techniques It has been shown in the RL literature that if Q is non-linear (like
in our case), the TD policy evaluation might diverge (Tsitsiklis & Van Roy, 1997). Previous work
has shown that this problem can be alleviated by using an additional target network Q0 to compute
qt, which is updated less often and/or more slowly than Q. Similarly to (Lillicrap et al., 2015), we
update the parameters φ0 of the target critic by linearly interpolating them with the parameters of the
trained one. Attempts to remove the target network by propagating the gradient through qt resulted
in a lower square error (Q(yt; Yi...t) - qt)2, but the resulting Q values proved very unreliable as
training signals for the actor.
The fact that both actor and critic use outputs of each other for training creates a potentially dangerous
feedback loop. To address this, we sample predictions from a delayed actor (Lillicrap et al., 2015),
whose weights are slowly updated to follow the actor that is actually trained.
Dealing with large action spaces One of the challenges of our work is that the action space is very
large (as is typically the case in NLP tasks with large vocabularies). This can be alleviated by putting
constraints on the critic values for actions that are rarely sampled. We found experimentally that
shrinking the values of these rare actions is necessary for the algorithm to converge. Specifically, we
add a term Ct for every step t to the critic’s optimization objective which drives all value predictions
of the critic closer to their mean:
Ct = X(Q(a； H...t-1)-占 X Q(b; H...")	(10)
This corresponds to penalizing the variance of the outputs of the critic. Without this penalty the values
of rare actions can be severely overestimated, which biases the gradient estimates and can cause
divergence. A similar trick was used in the context of learning simple algorithms with Q-learning
(Zaremba et al., 2015).
Reward shaping While we are ultimately interested in the maximization of the score of a complete
prediction, simply awarding this score at the last step provides a very sparse training signal for the
critic. For this reason we use potential-based reward shaping with potentials Φ(Y1...t) = R(Y1...t)
for incomplete sequences and Φ(Y) = 0 for complete ones (Ng et al., 1999). Namely, for a
predicted sequence Y we compute score values for all prefixes to obtain the sequence of scores
(R(Y1 …1),R(Y1…2),...,R(Y1...τ)).
1	.1	1	1	/ ʌ W	∖
used as the reward at each step: rt(yt; H…t-ι)
The difference between the consecutive pairs of scores is then
R(Y^ι...t) - R("Y1...t-ι). Using the shaped reward
rt instead of awarding the whole score R at the last step does not change the optimal policy (Ng et al.,
1999).
Putting it all together Algorithm 1 describes the proposed method in detail. We consider adding
the weighted log-likelihood gradient to the actor’s gradient estimate. This is in line with the prior work
6
Published as a conference paper at ICLR 2017
by (Ranzato et al., 2015) and (Shen et al., 2015). It is also motivated by our preliminary experiments
that showed that using the actor-critic estimate alone can lead to an early determinization of the policy
and vanishing gradients (also discussed in Section 6). Starting training with a randomly initialized
actor and critic would be problematic, because neither the actor nor the critic would provide adequate
training signals for one another. The actor would sample completely random predictions that receive
very little reward, thus providing a very weak training signal for the critic. A random critic would
be similarly useless for training the actor. Motivated by these considerations, we pre-train the actor
using standard log-likelihood training. Furthermore, we pre-train the critic by feeding it samples
from the pre-trained actor, while the actor’s parameters are frozen. The complete training procedure
including pre-training is described by Algorithm 2.
4	Related Work
In other recent RL-inspired work on sequence prediction, Ranzato et al. (2015) trained a translation
model by gradually transitioning from maximum likelihood learning into optimizing BLEU or
ROUGE scores using the REINFORCE algorithm. However, REINFORCE is known to have very
high variance and does not exploit the availability of the ground-truth like the critic network does.
The approach also relies on a curriculum learning scheme. Standard value-based RL algorithms like
SARSA and OLPOMDP have also been applied to structured prediction (Maes et al., 2009). Again,
these systems do not use the ground-truth for value prediction.
Imitation learning has also been applied to structured prediction (Vlachos, 2012). Methods of
this type include the SEARN (DaUme Iii et al., 2009) and DAGGER (Ross et al., 2010) algorithms.
These methods rely on an expert policy to provide action sequences that the policy learns to imitate.
Unfortunately, it’s not always easy or even possible to construct an expert policy for a task-specific
score. In our approach, the critic plays a role that is similar to the expert policy, but is learned without
requiring prior knowledge about the task-specific score. The recently proposed ‘scheduled sampling’
(Bengio et al., 2015) can also be seen as imitation learning. In this method, ground-truth tokens are
occasionally replaced by samples from the model itself during training. A limitation is that the token
k for the ground-truth answer is used as the target at step k, which might not always be the optimal
strategy.
There are also approaches that aim to approximate the gradient of the expected score. One such
approach is ‘Direct Loss Minimization’ (Hazan et al., 2010) in which the inference procedure is
adapted to take both the model likelihood and task-specific score into account. Another popular
approach is to replace the domain over which the task score expectation is defined with a small subset
of it, as is done in Minimum (Bayes) Risk Training (Goel & Byrne, 2000; Shen et al., 2015; Och,
2003). This small subset is typically an n-best list or a sample (like in REINFORCE) that may or
may not include the ground-truth as well. None of these methods provide intermediate targets for the
actor during training, and Shen et al. (2015) report that as many as 100 samples were required for the
best results.
Another recently proposed method is to optimize a global sequence cost with respect to the selection
and pruning behavior of the beam search procedure itself (Wiseman & Rush, 2016). This method
follows the more general strategy called 'learning as search optimization, (Daume III & Marcu, 2005).
This is an interesting alternative to our approach; however, it is designed specifically for the precise
inference procedure involved.
5	Experiments
To validate our approach, we performed two sets of experiments 2. First, we trained the proposed
model to recover strings of natural text from their corrupted versions. Specifically, we consider each
character in a natural language corpus and with some probability replace it with a random character.
We call this synthetic task spelling correction. A desirable property of this synthetic task is that data
is essentially infinite and overfitting is no concern. Our second series of experiments is done on the
task of automatic machine translation using different models and datasets.
2 The source code is available at https://github.com/rizar/actor-critic-public
7
Published as a conference paper at ICLR 2017
In addition to maximum likelihood and actor-critic training we implemented two versions of the
REINFORCE gradient estimator. In the first version, we use a linear baseline network that takes
the actor states as input, exactly as in (Ranzato et al., 2015). We also propose a novel extension of
REINFORCE that leverages the extra information available in the ground-truth output Y . Specifically,
we use the Q estimates produced by the critic network as the baseline for the REINFORCE algorithm.
The motivation behind this approach is that using the ground-truth output should produce a better
baseline that lowers the variance of REINFORCE, resulting in higher task-specific scores. We refer
to this method as REINFORCE-critic.
5.1	Spelling Correction
We use text from the One Billion Word dataset for the spelling correction task (Chelba et al., 2013),
which has pre-defined training and testing sets. The training data was abundant, and we never used
any example twice. We evaluate trained models on a section of the test data that comprises 6075
sentences. To speed up experiments, we clipped all sentences to the first 10 or 30 characters.
For the spelling correction actor network, we use an RNN with 100 Gated Recurrent Units (GRU)
and a bidirectional GRU network for the encoder. We use the same attention mechanism as proposed
in (Bahdanau et al., 2015), which effectively makes our actor network a smaller version of the model
used in that work. For the critic network, we employed a model with the same architecture as the
actor.
We use character error rate (CER) to measure performance on the spelling task, which we define as
the ratio between the total of Levenshtein distances between predictions and ground-truth outputs
and the total length of the ground-truth outputs. This is a corpus-level metric for which a lower value
is better. We use it as the return by negating per-sentence ratios. At the evaluation time greedy search
is used to extract predictions from the model.
We use the ADAM optimizer (Kingma & Ba,
2015) to train all the networks with the parame-
ters recommended in the original paper, with the
exception of the scale parameter α. The latter
is first set to 10-3 and then annealed to 10-4
for log-likelihood training. For the pre-training
stage of the actor-critic, we use α = 10-3 and
decrease itto 10-4 for the joint actor-critic train-
ing. We pretrain the actor until its score on the
development set stops improving. We pretrain
the critic until its TD error stabilizes3. We used
M = 1 sample for both actor-critic and REIN-
FORCE. For exact hyperparameter settings we
refer the reader to Appendix A.
We start REINFORCE training from a pretrained
actor, but we do not use the curriculum learning
employed in MIXER. The critic is trained in
the same way for both REINFORCE and actor-
critic, including the pretraining stage. We re-
port results obtained with the reward shaping de-
scribed in Section 3, as we found that it slightly
improves REINFORCE performance.
Table 1 presents our results on the spelling cor-
rection task. We observe an improvement in
CER over log-likelihood training for all four
settings considered. Without simultaneous log-
likelihood training, actor-critic training results
in a better CER than REINFORCE-critic in three
15 L
10
20
30
40
50
60
70
LL valid
LL* 严 lid-
KeValid
RF valid
RF-C valid
LL train
LL* train -
AC train
RF train
RF-C valid
Epochs



80
Figure 2: Progress of log-likelihood (LL), RE-
INFORCE (RF) and actor-critic (AC) training in
terms of BLEU score on the training (train) and val-
idation (valid) datasets. LL* stands for the anneal-
ing phase of log-likelihood training. The curves
start from the epoch of log-likelihood pretraining
from which the parameters were initialized.
3A typical behaviour for TD error was to grow at first and then start decreasing slowly. We found that
stopping pretraining shortly after TD error stops growing leads to good results.
8
Published as a conference paper at ICLR 2017
Table 1: Character error rate of different methods on the spelling correction task. In the table L is the
length of input strings, η is the probability of replacing a character with a random one. LL stands
for the log-likelihood training, AC and RF-C and for the actor-critic and the REINFORCE-critic
respectively, AC+LL and RF-C+LL for the combinations of AC and RF-C with LL.
Setup	Character Error Rate				
	LL	AC	RF-C	AC+LL	RF-C+LL
L = 10, η = 0.3	17.81	17.24	17.82	16.65	16.97
L=30,η=0.3	18.4	17.31	18.16	17.1	17.47
L=10,η=0.5	38.12	35.89	35.84	34.6	35
L = 30, η = 0.5	40.87	37.0	37.6	36.36	36.6
Table 2: Our IWSLT 2014 machine translation results with a convolutional encoder compared to
the previous work by Ranzato et al. Please see 1 for an explanation of abbreviations. The asterisk
identifies results from (Ranzato et al., 2015). The numbers reported with ≤ were approximately read
from Figure 6 of (Ranzato et al., 2015)
Decoding method
greedy search
beam search
17.74
≤ 20.3
LL*
Model
MIXER*	LL	RF	RF-C	AC
20.73	19.33	20.92	22.24	21.66
≤ 21.9	21.46	21.35	22.58	22.45
out of four settings. In the fourth case, actor-critic and REINFORCE-critic have similar performance.
Adding the log-likelihood gradient with a cofficient λLL = 0.1 helps both of the methods, but
actor-critic still retains a margin of improvement over REINFORCE-critic.
5.2	Machine Translation
For our first translation experiment, we use data from the German-English machine translation track
of the IWSLT 2014 evaluation campaign (Cettolo et al., 2014), as used in Ranzato et al. (2015), and
closely follow the pre-processing described in that work. The training data comprises about 153,000
German-English sentence pairs. In addition we considered a larger WMT14 English-French dataset
Cho et al. (2014) with more than 12 million examples. For further information about the data we
refer the reader to Appendix B.
The return is defined as a smoothed and rescaled version of the BLEU score. Specifically, we start all
n-gram counts from 1 instead of 0, and multiply the resulting score by the length of the ground-truth
translation. Smoothing is a common practice when sentence-level BLEU score is considered, and it
has been used to apply REINFORCE in similar settings (Ranzato et al., 2015).
IWSLT 2014 with a convolutional encoder In our first experiment we use a convolutional encoder
in the actor to make our results more comparable with Ranzato et al. (2015). For the same reason, we
use 256 hidden units in the networks. For the critic, we replaced the convolutional network with a
bidirectional GRU network. For training this model we mostly used the same hyperparameter values
as in the spelling correction experiments, with a few differences highlighted in Appendix A. For
decoding we used greedy search and beam search with a beam size of 10. We found that penalizing
candidate sentences that are too short was required to obtain the best results. Similarly to (Hannun
et al., 2014), we subtracted ρT from the negative log-likelihood of each candidate sentence, where T
is the candidate’s length, and ρ is a hyperparameter tuned on the validation set.
The results are summarized in Table 2. We report a significant improvement of 2.3 BLEU points
over the log-likelihood baseline when greedy search is used for decoding. Surprisingly, the best
performing method is REINFORCE with critic, with an additional 0.6 BLEU point advantage over
the actor-critic. When beam-search is used, the ranking of the compared approaches is the same, but
the margin between the proposed methods and log-likelihood training becomes smaller. The final
performances of the actor-critic and the REINFORCE-critic with greedy search are also 0.7 and 1.3
BLEU points respectively better than what Ranzato et al. (2015) report for their MIXER approach.
This comparison should be treated with caution, because our log-likelihood baseline is 1.6 BLEU
9
Published as a conference paper at ICLR 2017
Table 3: Our IWSLT 2014 machine translation results with a bidirectional recurrent encoder
compared to the previous work. Please see Table 1 for an explanation of abbreviations. The asterisk
identifies results from (Wiseman & Rush, 2016).
Decoding method	LL*	BSO*	M LL	odel RF-C	RF-C+LL	AC	AC+LL
greedy search	22.53	23.83	25.82	27.42	27.7	27.27	27.49
beam search	23.87	25.48	27.56	27.75	28.3	27.75	28.53
Table 4: Our WMT 14 machine translation results compared to the previous work. Please see Table 1
for an explanation of abbreviations. The apostrophy and the asterisk identify results from (Bahdanau
et al., 2015) and (Shen et al., 2015) respectively.
Decoding method	LL’	LL*	MRT*	odel LL	AC+LL	RF-C+LL
greedy search	n/a	n/a	n/a	29.33	30.85	29.83
beam search	28.45	29.88	31.3	30.71	31.13	30.37
points stronger than its equivalent from (Ranzato et al., 2015). The performance of REINFORCE
with a simple baseline matches the score reported for MIXER in Ranzato et al. (2015).
To better understand the IWSLT 2014 results we provide the learning curves for the considered
approaches in Figure 2. We can clearly see that the training methods that use generated predictions
have a strong regularization effect — that is, better progress on the validation set in exchange for
slower or negative progress on the training set. The effect is stronger for both REINFORCE varieties,
especially for the one without a critic. The actor-critic training does a much better job of fitting
the training set than REINFORCE and is the only method except log-likelihood that shows a clear
overfitting, which is a healthy behaviour for such a small dataset.
In addition, we performed an ablation study. We found that using a target network was crucial; while
the joint actor-critic training was still progressing with γθ = 0.1, with γθ = 1.0 it did not work at all.
Similarly important was the value penalty described in Equation (10). We found that good values
of the λ coefficient were in the range [10-3, 10-6]. Other techniques, such as reward shaping and a
delayed actor, brought moderate performance gains. We refer the reader to Appendix A for more
details.
IWSLT 2014 with a bidirectional GRU encoder In order to compare our results with those
reported by Wiseman & Rush (2016) we repeated our IWSLT 2014 investigation with a different
encoder, a bidirectional RNN with 256 GRU units. In this round of experiments we also tried to used
combined training objectives in the same way as in our spelling correction experiments. The results
are summarized in Table 3. One can see that the actor-critic training, especially its AC+LL version,
yields significant improvements (1.7 with greedy search and 1.0 with beam search) upon the pure
log-likelihood training, which are comparable to those brought by Beam Search Optimization (BSO),
even though our log-likelihood baseline is much stronger. In this round of experiments actor-critic
and REINFORCE-critic performed on par.
WMT 14 Finally we report our results on a very popular large WMT14 English-French dataset
(Cho et al., 2014) in Table 4. Our model closely follows the achitecture from (Bahdanau et al., 2015),
however we achieved a higher baseline performance by annealing the learning rate α and penalizing
output sequences that were too short during beam search. The actor-critic training brings a significant
1.5 BLEU improvement with greedy search and a noticeable 0.4 BLEU improvement with beam
search. In previous work Shen et al. (2015) report a higher improvement of 1.4 BLEU with beam
search, however they use 100 samples for each training example, whereas we use just one. We note
that in this experiment, which is perhaps the most realistic settings, the actor-critic enjoys a significant
advantage over the REINFORCE-critic.
10
Published as a conference paper at ICLR 2017
6	Discussion
We proposed an actor-critic approach to sequence prediction. Our method takes the task objective
into account during training and uses the ground-truth output to aid the critic in its prediction of
intermediate targets for the actor. We showed that our method leads to significant improvements
over maximum likelihood training on both a synthetic task and a machine translation benchmark.
Compared to REINFORCE training on machine translation, actor-critic fits the training data much
faster, although in some of our experiments we were able to significantly reduce the gap in the training
speed and achieve a better test error using our critic network as the baseline for REINFORCE.
One interesting observation we made from the machine translation results is that the training methods
that use generated predictions have a strong regularization effect. Our understanding is that condi-
tioning on the sampled outputs effectively increases the diversity of training data. This phenomenon
makes it harder to judge whether the actor-critic training meets our expectations, because a noisier
gradient estimate yielded a better test set performance. We argue that the spelling correction results
obtained on a virtually infinite dataset in conjuction with better machine translation performance on
the large WMT 14 dataset provide convincing evidence that the actor-training can be effective. In
future work we will consider larger machine translation datasets.
We ran into several optimization issues. The critic would sometimes assign very high values to
actions with a very low probability according to the actor. We were able to resolve this by penalizing
the critic’s variance. Additionally, the actor would sometimes have trouble to adapt to the demands of
the critic. We noticed that the action distribution tends to saturate and become deterministic, causing
the gradient to vanish. We found that combining an RL training objective with log-likelihood can
help, but in general we think this issue deserves further investigation. For example, one can look
for suitable training criteria that have a well-behaved gradient even when the policy has little or no
stochasticity.
In a concurrent work Wu et al. (2016) show that a version of REINFORCE with the baseline computed
using multiple samples can improve performance of a very strong machine translation system. This
result, and our REINFORCE-critic experiments, suggest that often the variance of REINFORCE
can be reduced enough to make its application practical. That said, we would like to emphasize
that this paper attacks the problem of gradient estimation from a very different angle as it aims for
low-variance but potentially high-bias estimates. The idea of using the ground-truth output that we
proposed is an absolutely necessary first step in this direction. Future work could focus on further
reducing the bias of the actor-critic estimate, for example, by using a multi-sample training criterion
for the critic.
Acknowledgments
We thank the developers of Theano (Theano Development Team, 2016) and Blocks (van Merrienboer
et al., 2015) for their great work. We thank NSERC, Compute Canada, Calcul Quebec, Canada
Research Chairs, CIFAR, CHISTERA project M2CR (PCIN-2015-226) and Samsung Institute of
Advanced Techonology for their financial support.
References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. In Proceedings of the ICLR 2015, 2015.
Andrew G Barto, Richard S Sutton, and Charles W Anderson. Neuronlike adaptive elements that can
solve difficult learning control problems. Systems, Man and Cybernetics, IEEE Transactions on,
(5):834-846,1983.
Samy Bengio, Oriol Vinyals, Navdeep Jaitly, and Noam Shazeer. Scheduled sampling for sequence
prediction with recurrent neural networks. arXiv preprint arXiv:1506.03099, 2015.
Mauro Cettolo, Jan Niehues, Sebastian Stuker, Luisa Bentivogli, and Marcello Federico. Report on
the 11th iwslt evaluation campaign. In Proc. of IWSLT, 2014.
William Chan, Navdeep Jaitly, Quoc V Le, and Oriol Vinyals. Listen, attend and spell. arXiv preprint
arXiv:1508.01211, 2015.
11
Published as a conference paper at ICLR 2017
Ciprian Chelba, Tomas Mikolov, Mike Schuster, Qi Ge, Thorsten Brants, Phillipp Koehn, and Tony
Robinson. One billion word benchmark for measuring progress in statistical language modeling.
arXiv preprint arXiv:1312.3005, 2013.
Kyunghyun Cho, Bart Van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for
statistical machine translation. arXiv preprint arXiv:1406.1078, 2014.
Jan Chorowski, Dzmitry Bahdanau, Dmitriy Serdyuk, KyungHyun Cho, and Yoshua Bengio.
Attention-based models for speech recognition. CoRR, abs/1506.07503, 2015. URL http:
//arxiv.org/abs/1506.07503.
Hal Daume In and Daniel Marcu. Learning as search optimization: Approximate large margin
methods for structured prediction. In Proceedings of the 22nd international conference on Machine
learning,pp.169-176. ACM, 2005.
Hal Daume Iii, John Langford, and Daniel Marcu. Search-based structured prediction. Machine
learning,75(3):297-325, 2009.
Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama, Marcus Rohrbach, Subhashini Venu-
gopalan, Kate Saenko, and Trevor Darrell. Long-term recurrent convolutional networks for visual
recognition and description. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pp. 2625-2634, 2015.
Vaibhava Goel and William J Byrne. Minimum bayes-risk automatic speech recognition. Computer
Speech & Language, 14(2):115-135, 2000.
Awni Y Hannun, Andrew L Maas, Daniel Jurafsky, and Andrew Y Ng. First-pass large vocabulary
continuous speech recognition using bi-directional recurrent dnns. arXiv preprint arXiv:1408.2873,
2014.
Tamir Hazan, Joseph Keshet, and David A McAllester. Direct loss minimization for structured
prediction. In Advances in Neural Information Processing Systems, pp. 1594-1602, 2010.
Sepp Hochreiter and JUrgen Schmidhuber. Long short-term memory. Neural computation, 9(8):
1735-1780, 1997.
Andrej Karpathy and Li Fei-Fei. Deep visual-semantic alignments for generating image descriptions.
In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 3128-
3137, 2015.
Diederik P Kingma and Jimmy Ba. A method for stochastic optimization. In International Conference
on Learning Representation, 2015.
Ryan Kiros, Ruslan Salakhutdinov, and Richard S Zemel. Unifying visual-semantic embeddings with
multimodal neural language models. arXiv preprint arXiv:1411.2539, 2014.
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint arXiv:1509.02971, 2015.
Chin-Yew Lin and Eduard Hovy. Automatic evaluation of summaries using n-gram co-occurrence
statistics. In Proceedings of the 2003 Conference of the North American Chapter of the Association
for Computational Linguistics on Human Language Technology-Volume 1, pp. 71-78. Association
for Computational Linguistics, 2003.
Francis Maes, Ludovic Denoyer, and Patrick Gallinari. Structured prediction with reinforcement
learning. Machine learning, 77(2-3):271-301, 2009.
W Thomas Miller, Paul J Werbos, and Richard S Sutton. Neural networks for control. MIT press,
1995.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control
through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
12
Published as a conference paper at ICLR 2017
Andrew Y Ng, Daishi Harada, and Stuart Russell. Policy invariance under reward transformations:
Theory and application to reward shaping. In ICML, volume 99, pp. 278-287, 1999.
Franz Josef Och. Minimum error rate training in statistical machine translation. In Proceedings of
the 41st Annual Meeting on Association for Computational Linguistics-Volume 1, pp. 160-167.
Association for Computational Linguistics, 2003.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic
evaluation of machine translation. In Proceedings of the 40th annual meeting on association for
computational linguistics, pp. 311-318. Association for Computational Linguistics, 2002.
Marc’Aurelio Ranzato, Sumit Chopra, Michael Auli, and Wojciech Zaremba. Sequence level training
with recurrent neural networks. arXiv preprint arXiv:1511.06732, 2015.
Stephane Ross, Geoffrey J Gordon, and J Andrew Bagnell. A reduction of imitation learning and
structured prediction to no-regret online learning. arXiv preprint arXiv:1011.0686, 2010.
Alexander M Rush, Sumit Chopra, and Jason Weston. A neural attention model for abstractive
sentence summarization. arXiv preprint arXiv:1509.00685, 2015.
Mike Schuster and Kuldip K Paliwal. Bidirectional recurrent neural networks. Signal Processing,
IEEE Transactions on, 45(11):2673-2681, 1997.
Shiqi Shen, Yong Cheng, Zhongjun He, Wei He, Hua Wu, Maosong Sun, and Yang Liu. Minimum
risk training for neural machine translation. arXiv preprint arXiv:1512.02433, 2015.
Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks. In
Advances in Neural Information Processing Systems 27: Annual Conference on Neural Information
Processing Systems 2014, December 8-13 2014, Montreal, Quebec, Canada, pp. 3104-3112, 2014.
Richard S Sutton. Learning to predict by the methods of temporal differences. Machine learning, 3
(1):9-44, 1988.
Richard S Sutton and Andrew G Barto. Introduction to reinforcement learning, volume 135. MIT
Press Cambridge, 1998.
Richard S Sutton, David A McAllester, Satinder P Singh, Yishay Mansour, et al. Policy gradient
methods for reinforcement learning with function approximation. In NIPS, volume 99, pp. 1057-
1063, 1999.
Richard Stuart Sutton. Temporal credit assignment in reinforcement learning. 1984.
Gerald Tesauro. Td-gammon, a self-teaching backgammon program, achieves master-level play.
Neural computation, 6(2):215-219, 1994.
Theano Development Team. Theano: A Python framework for fast computation of mathematical
expressions. arXiv e-prints, abs/1605.02688, May 2016. URL http://arxiv.org/abs/
1605.02688.
John N Tsitsiklis and Benjamin Van Roy. An analysis of temporal-difference learning with function
approximation. Automatic Control, IEEE Transactions on, 42(5):674-690, 1997.
Bart van Merrienboer, Dzmitry Bahdanau, Vincent Dumoulin, Dmitriy Serdyuk, David Warde-
Farley, Jan Chorowski, and Yoshua Bengio. Blocks and fuel: Frameworks for deep learning.
arXiv:1506.00619 [cs, stat], June 2015.
Oriol Vinyals, Alexander Toshev, Samy Bengio, and Dumitru Erhan. Show and tell: A neural
image caption generator. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 3156-3164, 2015.
Andreas Vlachos. An investigation of imitation learning algorithms for structured prediction. In
EWRL, pp. 143-154. Citeseer, 2012.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine learning, 8(3-4):229-256, 1992.
13
Published as a conference paper at ICLR 2017
Sam Wiseman and Alexander M Rush. Sequence-to-sequence learning as beam-search optimization.
arXiv preprint arXiv:1606.02960, 2016.
Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. Google’s neural machine translation sys-
tem: Bridging the gap between human and machine translation. arXiv preprint arXiv:1609.08144,
2016.
Kelvin Xu, Jimmy Ba, Ryan Kiros, Kyunghyun Cho, Aaron C. Courville, Ruslan Salakhutdinov,
Richard S. Zemel, and Yoshua Bengio. Show, attend and tell: Neural image caption generation
with visual attention. In Proceedings of the 32nd International Conference on Machine Learning,
ICML2015, Lille, France, 6-11 July2015,pp. 2048-2057, 2015.
Wojciech Zaremba, Tomas Mikolov, Armand Joulin, and Rob Fergus. Learning simple algorithms
from examples. arXiv preprint arXiv:1511.07275, 2015.
14
Published as a conference paper at ICLR 2017
Table 5: Results of an ablation study. We tried varying the actor update speed γθ, the critic update
speed γφ, the value penalty coefficient λ, whether or not reward shaping is used, whether or not
temporal difference (TD) learning is used for the critic. Reported are the best training and validation
BLEU score obtained in the course of the first 10 training epochs. Some of the validation scores
would still improve with longer training. Greedy search was used for decoding.
γθ	γφ		λ	reward shaping TD	train BLEU	valid BLEU
0.001	0.001	10-3	baseline yes	yes	33.73	23.16
0.001	0.01	10-3	with different γφ yes	yes	33.52	23.03
0.001	0.1	10-3	yes	yes	32.63	22.80
0.001	1	10-3	yes	yes	9.59	8.14
1	0.001	10-3	with different γθ yes	yes	32.9	22.88
0.001	0.001	10-3	without reward shaping no	yes	32.74	22.61
0.001	0.001	without temporal difference learning 10-3	yes	no	23.2			16.36
0.001	0.001	3 *10-3	with different λ yes	yes	32.4	22.48
0.001	0.001	10-4	yes	yes	34.10	23.15
0.001	0.001	10-6	yes	yes	35.00	23.10
0.001	0.001	10-8	yes	yes	33.6	22.72
0.001	0.001	0	yes	yes	27.41	20.55
A Hyperparameters
For machine translation experiments the variance penalty coefficient λ was set to 10-4, and the delay
coefficients γθ and γφ were both set to 10-4. For REINFORCE with the critic we did not use a
delayed actor, i.e. γθ was set to 1. For the spelling correction task we used the same γθ and γφ but a
different λ = 10-3. When we used a combined training criterion, the weight of the log-likelihood
gradient λLL was always 0.1. All initial weights were sampled from a centered uniform distribution
with width 0.1.
In some of our experiments we provided the actor states as additional inputs to the critic. Specifically,
we did so in our spelling correction experiments and in our WMT 14 machine translation study. All
the other results were obtained without this technique.
For decoding with beam search we substracted the length of a candidate times ρ from the log-
likelihood cost. The exact value of ρ was selected on the validation set and was equal to 0.8 for
models trained by log-likelihood and REINFORCE and to 1.0 for models trained by actor-critic and
REINFORCE-critic.
For some of the hyperparameters we performed an ablation study. The results are reported in Table 5.
B DATA
For the IWSLT 2014 data the sizes of validation and tests set were 6,969 and 6,750, respectively.
We limited the number of words in the English and German vocabularies to the 22,822 and 32,009
most frequent words, respectively, and replaced all other words with a special token. The maximum
sentence length in our dataset was 50. For WMT14 we used vocabularies of 30,000 words for both
English and French, and the maximum sentence length was also 50.
15
Published as a conference paper at ICLR 2017
C Generated Q-values
In Table C we provide an example of value predictions that the critic outputs for candidate next words.
One can see that the critic has indeed learnt to assign larger values for the appropriate next words.
While the critic does not always produce sensible estimates and can often predict a high return for
irrelevant rare words, this is greatly reduced using the variance penalty term from Equation (10).
Figure 3: The best 3 words according to the critic at intermediate steps of generating a translation.
The numbers m parentheses are the value predictions Q. The German original is Uber eme davon
will ich hier erzahlen ." The reference translation is “and there,s one I want to talk about”.
Word	Words with largest Q
one	-and(6.623) there(6.200) but(5.967)-
of	that(6.197) one(5.668) &apos;s(5.467)
them	that(5.408) one(5.118) i(5.002)
i	that(4.796) i(4.629) ,(4.139)
want	want(5.008) i(4.160) &apos;t(3.361)
to	to(4.729) want(3.497) going(3.396)
tell	talk(3.717) you(2.407) to(2.133)
you	about(1.209) that(0.989) talk(0.924)
about	about(0.706) .(0.660) right(0.653)
here	.(0.498) ?(0.291)-(0.285)
.	.(0.195) there(0.175) know(0.087)
0	.(0.168) 0 (-0.093) ?(-0.173)
16
Published as a conference paper at ICLR 2017
D Proof of Equation (7)
dV d
—=— E
dθ	dθ Y〜P(Y)
R(Y) = X dθ [p(yι)p(y2lyι) ...p(yT 1y1... yT-I)IR(Y)
^
T
XX p(Yι...t-ι)
t=1 Yl...t
Y
T
XX p(Y1...t-1)
t=1 Y
.ʌ 、
, ,,, .
dp(yt∣Yι …t-ι)
dθ
T
XX p(Yι...t-ι)
t=1 Yl...t
.7.. / .ʌ IS	、
p(ytdθ …T) p(Yt+1..T IYL...t)R(Y)
T
E p(Yt+ι..T ∣Yι...t)E rτ (yτ ； Y1...τ-1)
Yt+ 1...T
. ʌ .
dp(yt∣Yι …t-ι)
dθ
τ=1
T
rt(yt; Yι...t-i)+	X	p(Yt+ι..T∣Yι...t)	X rτ(yτ； Yι...τ-1)
.	Yt+1...T	τ = t+1	一
T
X .	E,.	、X 刎或…"Q(a； Y1...t-1)
M y1...t-1^P(Y1...t-1) a∈A	dθ
T
Y 舄)X XA d^ Q(a； Y-)
17