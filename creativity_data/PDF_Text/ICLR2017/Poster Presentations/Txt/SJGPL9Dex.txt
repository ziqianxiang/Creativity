Published as a conference paper at ICLR 2017
Understanding Trainable Sparse Coding
via matrix factorization
Thomas Moreau	Joan Bruna
CMLA, ENS Cachan, CNRS,	Courant Institute of Mathematical Sciences,*
Universite Paris-Saclay,	New York University ,
94235 Cachan, France	New York, NY 10012, USA
thomas.moreau@cmla.ens-cachan.fr joan.bruna@berkeley.edu
Abstract
Sparse coding is a core building block in many data analysis and machine
learning pipelines. Typically it is solved by relying on generic optimization
techniques, such as the Iterative Soft Thresholding Algorithm and its ac-
celerated version (ISTA, FISTA). These methods are optimal in the class
of first-order methods for non-smooth, convex functions. However, they do
not exploit the particular structure of the problem at hand nor the input
data distribution. An acceleration using neural networks, coined LISTA,
was proposed in Gregor & Le Cun (2010), which showed empirically that
one could achieve high quality estimates with few iterations by modifying
the parameters of the proximal splitting appropriately.
In this paper we study the reasons for such acceleration. Our mathematical
analysis reveals that it is related to a specific matrix factorization of the
Gram kernel of the dictionary, which attempts to nearly diagonalise the
kernel with a basis that produces a small perturbation of the `1 ball. When
this factorization succeeds, we prove that the resulting splitting algorithm
enjoys an improved convergence bound with respect to the non-adaptive
version. Moreover, our analysis also shows that conditions for acceleration
occur mostly at the beginning of the iterative process, consistent with nu-
merical experiments. We further validate our analysis by showing that on
dictionaries where this factorization does not exist, adaptive acceleration
fails.
1 Introduction
Feature selection is a crucial point in high dimensional data analysis. Different techniques
have been developed to tackle this problem efficiently, and amongst them sparsity has
emerged as a leading paradigm. In statistics, the LASSO estimator (Tibshirani, 1996)
provides a reliable way to select features and has been extensively studied in the last two
decades (Hastie et al. (2015) and references therein). In machine learning and signal process-
ing, sparse coding has made its way into several modern architectures, including large scale
computer vision (Coates & Ng, 2011) and biologically inspired models (Cadieu & Olshausen,
2012). Also, Dictionary learning is a generic unsupervised learning method to perform non-
linear dimensionality reduction with efficient computational complexity (Mairal et al., 2009).
All these techniques heavily rely on the resolution of '「regularized least squares.
The '「sparse coding problem is defined as solving, for a given input X ∈ Rn and dictionary
D ∈ Rn×m, the following problem:
z*(x) = arg min Fx(Z) = 1∣∣x - Dz『+ λ∣∣zkι .	(1)
This problem is convex and can therefore be solved using convex optimization machinery.
Proximal splitting methods (Beck & Teboulle, 2009) alternate between the minimization of
the smooth and differentiable part using the gradient information and the minimization of
the non-differentiable part using a proximal operator (Combettes & Bauschke, 2011). These
methods can also be accelerated by considering a momentum term, as it is done in FISTA
*Work done while appointed at UC Berkeley, Statistics Department (currently on leave)
1
Published as a conference paper at ICLR 2017
(Beck & Teboulle, 2009; Nesterov, 2005). Coordinate descent (Friedman et al., 2007; Osher
& Li, 2009) leverages the closed formula that can be derived for optimizing the problem (1)
for one coordinate zi given that all the other are fixed. At each step of the algorithm, one
coordinate is updated to its optimal value, which yields an inexpensive scheme to perform
each step. The choice of the coordinate to update at each step is critical for the performance
of the optimization procedure. Least Angle Regression (LARS) (Hesterberg et al., 2008) is
another method that computes the whole LASSO regularization path. These algorithms all
provide an optimization procedure that leverages the local properties of the cost function
iteratively. They can be shown to be optimal among the class of first-order methods for
generic convex, non-smooth functions (Bubeck, 2014).
But all these results are given in the worst case and do not use the distribution of the
considered problem. One can thus wonder whether a more efficient algorithm to solve
(1) exists for a fixed dictionary D and generic input x drawn from a certain input data
distribution. In Gregor & Le Cun (2010), the authors introduced LISTA, a trained version
of ISTA that adapts the parameters of the proximal splitting algorithm to approximate the
solution of the LASSO using a finite number of steps. This method exploits the common
structure of the problem to learn a better transform than the generic ISTA step. As ISTA
is composed of a succession of linear operations and piecewise non linearities, the authors
use the neural network framework and the backpropagation to derive an efficient procedure
solving the LASSO problem. In Sprechmann et al. (2012), the authors extended LISTA
to more generic sparse coding scenarios and showed that adaptive acceleration is possible
under general input distributions and sparsity conditions.
In this paper, we are interested in the following question: Given a finite computational
budget, what is the optimum estimator of the sparse coding? This question belongs to
the general topic of computational tradeoffs in statistical inference. Randomized sketches
(Alaoui & Mahoney, 2015; Yang et al., 2015) reduce the size of convex problems by projecting
expensive kernel operators into random subspaces, and reveal a tradeoff between computa-
tional efficiency and statistical accuracy. Agarwal (2012) provides several theoretical results
on perfoming inference under various computational constraints, and Chandrasekaran &
Jordan (2013) considers a hierarchy of convex relaxations that provide practical tradeoffs
between accuracy and computational cost. More recently, Oymak et al. (2015) provides
sharp time-data tradeoffs in the context of linear inverse problems, showing the existence
of a phase transition between the number of measurements and the convergence rate of
the resulting recovery optimization algorithm. Giryes et al. (2016) builds on this result to
produce an analysis of LISTA that describes acceleration in conditions where the iterative
procedure has linear convergence rate. Finally, Xin et al. (2016) also studies the capabilities
of Deep Neural networks at approximating sparse inference. The authors show that unrolled
iterations lead to better approximation if one allows the weights to vary at each layer, con-
trary to standard splitting algorithms. Whereas their focus is on relaxing the convergence
hypothesis of iterative thresholding algorithms, we study a complementary question, namely
when is speedup possible, without assuming strongly convex optimization. Their results are
consistent with ours, since our analysis also shows that learning shared layer weights is less
effective.
Inspired by the LISTA architecture, our mathematical analysis reveals that adaptive accel-
eration is related to a specific matrix factorization of the Gram matrix of the dictionary
B = DTD as B = ATSA - R ,where A is unitary, S is diagonal and the residual is positive
semidefinite: R 0. Our factorization balances between near diagonalization by asking
that kRk is small and small perturbation of the `1 norm, i.e. kAzk1 - kzk1 is small. When
this factorization succeeds, we prove that the resulting splitting algorithm enjoys a conver-
gence rate with improved constants with respect to the non-adaptive version. Moreover,
our analysis also shows that acceleration is mostly possible at the beginning of the iterative
process, when the current estimate is far from the optimal solution, which is consistent with
numerical experiments. We also show that the existence of this factorization is not only
sufficient for acceleration, but also necessary. This is shown by constructing dictionaries
whose Gram matrix diagonalizes in a basis that is incoherent with the canonical basis, and
verifying that LISTA fails in that case to accelerate with respect to ISTA.
In our numerical experiments, we design a specialized version of LISTA called FacNet, with
more constrained parameters, which is then used as a tool to show that our theoretical anal-
ysis captures the acceleration mechanism of LISTA. Our theoretical results can be applied
to FacNet and as LISTA is a generalization of this model, it always performs at least as well,
showing that the existence of the factorization is a sufficient certificate for acceleration by
2
Published as a conference paper at ICLR 2017
LISTA. Reciprocally, we show that for cases where no acceleration is possible with FacNet,
the LISTA model also fail to provide acceleration, linking the two speedup mechanisms.
This numerical evidence suggest that the existence of our proposed factorization is sufficient
and somewhat necessary for LISTA to show good results.
The rest of the paper is structured as follows. Section 2 presents our mathematical analysis
and proves the convergence of the adaptive algorithm as a function of the quality of the
matrix factorization. Finally, Section 3 presents the generic architectures that will enable
the usage of such schemes and the numerical experiments, which validate our analysis over
a range of different scenarios.
2 Accelerating Sparse Coding with Sparse Matrix
Factorizations
2.1	Unitary Proximal Splitting
In this section we describe our setup for accelerating sparse coding based on the Proximal
Splitting method. Let Ω ⊂ Rn be the set describing our input data, and D ∈ Rn×m be a
dictionary, with m > n. We wish to find fast and accurate approximations of the sparse
coding z*(x) of any X ∈ Ω, defined in (1) For simplicity, We denote B = DTD and y = Dtx
to rewrite (1) as
z*(x) = arg min Fx(Z) = -(y - z)TB(y - z) + λ∣∣zkι
(2)
X------------------------------------}
z
E(z)
G(z)
For clarity, we will refer to Fx as F and to z*(x) as z*. The classic proximal splitting
technique finds z* as the limit of sequence (zk)k, obtained by successively constructing a
surrogate loss Fk (z ) of the form
Fk(z) = E(zk) + (zk - y)TB(z - zk) + Lk kz - zk k22 + λkzk1 ,
(3)
satisfying Fk (z) ≥ F(z) for all z ∈ Rm . Since Fk is separable in each coordinate of z,
zk+1 = arg minz Fk (z) can be computed efficiently. This scheme is based on a majoration
of the quadratic form (y - z)TB (y - z) with an isotropic quadratic form Lk kzk - zk22 . The
convergence rate of the splitting algorithm is optimized by choosing Lk as the smallest
constant satisfying Fk (z) ≥ F(z), which corresponds to the largest singular value of B.
The computation of zk+1 remains separable by replacing the quadratic form LkI by any
diagonal form. However, the Gram matrix B = DTD might be poorly approximated via
diagonal forms for general dictionaries. Our objective is to accelerate the convergence of
this algorithm by finding appropriate factorizations of the matrix B such that
B ≈ ATSA , and kAz k1 ≈ kz k1
where A is unitary and S is diagonal positive definite. Given a point zk at iteration k, we
can rewrite F(z) as
F(z) = E(zk) + (zk - y)TB(z - zk) + QB (z, zk) ,
=	-(v - W)TB(V - w) + λ∣∣vkι .
(4)
with QB(v, w)
For any diago-
nal positive definite matrix S and unitary matrix A, the surrogate loss
Fe(z, zk) := E(zk) + (zk - y)TB(z - zk) + QS(Az, Azk) can be explicitly minimized,
since
zu
arg min Fe(z, zk) = AT arg min (zk - y)TBAT(u - Azk) + QS(u, Azk)
u
AT arg min QS u, Azk - S-1AB(zk -
(5)
where we use the variable change u = Az. As S is diagonal positive definite, (5) is separable
and can be computed easily, using a linear operation followed by a point-wise non linear
soft-thresholding. Thus, any couple (A, S) ensures an computationally cheap scheme. The
question is then how to factorize B using S and A in an optimal manner, that is, such that
the resulting proximal splitting sequence converges as fast as possible to the sparse coding
solution.
3
Published as a conference paper at ICLR 2017
2.2	Non-asymptotic Analysis
We will now establish convergence results based on the previous factorization. These bounds
will inform us on how to best choose the factors Ak and Sk in each iteration.
For that purpose, let us define
δA(z) = λ kAzk1 - kzk1	, and R=ATSA-B .	(6)
The quantity δA (z) thus measures how invariant the `1 norm is to the unitary operator A,
whereas R corresponds to the residual of approximating the original Gram matrix B by our
factorization ATSA . Given a current estimate zk , we can rewrite
1
F(Z,zk ) = F(Z) + 2(Z - Zk) R(Z - Zk) + δA(z) .	⑺
By imposing that R is a positive semidefinite residual one immediately obtains the following
bound.
Proposition 2.1. Suppose that R = ATSA - B is positive definite, and define
Zk+1 = argminF(Z,Zk) .	(8)
z
Then	F(Zk+ 1)- F(z*) ≤ 2 IlRlIllZk - z* k2+δA(Z*) - δA(zk+1) .	⑼
Proof. By definition of Zk+1 and using the fact that R 0 we have
一， . 一 .. 一， . 二， . 二，， . 一 ,.
F (Zk+1) - F(Z ) ≤ F (Zk+1) - Fe(Zk+1, Zk) + Fe(Z , Zk) - F(Z )
= -2(Zk+1 - Zk )TR(Zk+ 1 - Zk) - δA(zk + 1) + ](Z* - Zk )TR(Z* - Zk ) + δA(Z*)
≤ 1(z* - Zk )tR(z* - Zk)+ Ga(z* ) - δA(Zk+ι)).
where the first line results from the definition of Zk+1 and the third line makes use of R
positiveness.	口
This simple bound reveals that to obtain fast approximations to the sparse coding it is
sufficient to find S and A such that lRl is small and that the `1 commutation term δA
is small. These two conditions will be often in tension: one can always obtain R ≡ 0 by
using the Singular Value Decomposition of B = A0T S0A0 and setting A = A0 and S = S0 .
However, the resulting A0 might introduce large commutation error δA0 . Similarly, as the
absolute value is non-expansive, i.e. |a| - |b| ≤ a - b, we have that
∣δA(z)∣ = λ∣∣Az∣ι -kz∣ι∣ ≤ λ∣(A - I)ZkI	(10)
≤ λP2max(kAz∣∣0,kzko) ∙ kA - Ik ∙ kz∣2 ,
where We have used the Cauchy-SchWartz inequality ∣∣x∣ι ≤ ∙χ∕kxkokxk2 in the last equation.
In particular, (10) shows that unitary matrices in the neighborhood of I with kA - Ik small
have small `1 commutation error δA but can be inappropriate to approximate general B
matrix.
The commutation error also depends upon the sparsity of Z and AZ . If both Z and AZ are
sparse then the commutation error is reduced, Which can be achieved if A is itself a sparse
unitary matrix. Moreover, since
∣δA(z) - δA(z0)∣ ≤ λ∣kzkι -kz0kι∣ + λ∣kAzkι - kAz0kι∣
and lkzk1 - kz0k1| ≤ kz - z1∣1 ≤ PkZ-Z0k0 kz - z1∣2
it results that δA is Lipschitz With respect to the Euclidean norm; let us denote by LA(Z)
its local Lipschitz constant in z, Which can be computed using the norm of the subgradient
4
Published as a conference paper at ICLR 2017
in z1. An uniform upper bound for this constant is (1 + k Ak ι)λ√m, but it is typically much
smaller when z and Az are both sparse.
Equation (8) defines an iterative procedure determined by the pairs {(Ak, Sk)}k. The fol-
lowing theorem uses the previous results to compute an upper bound of the resulting sparse
coding estimator.
Theorem 2.2. Let Ak, Sk be the pair of unitary and diagonal matrices corresponding to
iteration k, chosen such that Rk = AkT Sk Ak - B 0. It results that
F(Zk) — F(z*) ≤
(z* — zo)τRo(z* — zo) + 2Lao (zι) ∣∣z* — zι ∣∣2
2k
α-β
+ ^Γ
(11)
with
k-1
α = X(2LAi(zi+i)kz* - Zi+11∣2 + (z* - Zi)T(Ri-ι - Ri)(z* - Zi))
i=1
k-1
β = X(i + 1) (Zi+1 - Zi ) Ri (Zi+1 - Zi) + 2δAi (Zi+1 ) - 2δAi (Zi )
i=0
where LA(z) denote the local lipschitz constant of δA at z.
Remarks: If one sets Ak = I and Sk = kBkI for all k ≥ 0, (11) corresponds to the bound
of the ISTA algorithm (Beck & Teboulle, 2009).
We can specialize the theorem in the case when A0 , S0 are chosen to minimize the bound
(9) and Ak = I, Sk = kBkI for k ≥ 1.
Corollary 2.3. If Ak = I, Sk = kB kI for k ≥ 1 then
F(Zk)-F(z*) ≤
(z* — zo)τRo(z* — zo) + 2Lao (zi)(∣∣z* — zιk + ∣∣zι — zo∣∣) + (z* — zι)τRo(z* — ZI)T
2k
(12)
This corollary shows that by simply replacing the first step of ISTA by the modified proximal
step detailed in (5), one can obtain an improved bound at fixed k as soon as
2∣∣Rok max(∣∣z*-zok2, ∣∣z*-zιk2)+4LA0(zι)max(kz*-z0k2, ∣∣z*-z1k2) ≤ ∣∣Bkkz*-zok2 ,
which, assuming ∣∣z* — z0∣∣2 ≥ ∣∣z* — zι∣∣2, translates into
kRok +2 LA0(z1) ≤ 粤.	(13)
∣∣z* 一 Z0∣∣2	2
More generally, given a current estimate zk, searching for a factorization (Ak, Sk) will im-
prove the upper bound when
∣Rkk+2 LAk (Zk+1) ≤kB.	(14)
∣z - zk ∣2	2
We emphasize that this is not a guarantee of acceleration, since it is based on improving
an upper bound. However, it provides a simple picture on the mechanism that makes
non-asymptotic acceleration possible.
2.3 Interpretation
In this section we analyze the consequences of Theorem 2.2 in the design of fast sparse coding
approximations, and provide a possible explanation for the behavior observed numerically.
2	.3.1 ‘Phase Transition” and Law of Diminishing Returns
(1	4) reveals that the optimum matrix factorization in terms of minimizing the upper bound
depends upon the current scale of the problem, that is, of the distance ∣∣z* — Zk∣. At the
beginning of the optimization, when ∣∣z* — Zk ∣∣ is large, the bound (14) makes it easier to
explore the space of factorizations (A, S) with A further away from the identity. Indeed,
the bound tolerates larger increases in LA(Zk+1), which is dominated by
LA(Zk+1) ≤ λ(Λ∕∣∣zk+1∣∣0 + ʌ/llAZk+ 1 IIO),
1 This quantity exists as δA is a difference of convex. See proof of ?? in appendices for precisions.
5
Published as a conference paper at ICLR 2017
Figure 1: Network architecture for ISTA/LISTA. The unfolded version (b) is trainable
through backpropagation and permits to approximate the sparse coding solution efficiently.
i.e. the sparsity of both z1 and A0(z1). On the other hand, when we reach intermediate
solutions Zk such that ∣∣z* — Zk ∣∣ is small with respect to LA(Zk+i), the upper bound is
minimized by choosing factorizations where A is closer and closer to the identity, leading to
the non-adaptive regime of standard ISTA (A = Id).
This is consistent with the numerical experiments, which show that the gains provided by
learned sparse coding methods are mostly concentrated in the first iterations. Once the
estimates reach a certain energy level, section 3 shows that LISTA enters a steady state in
which the convergence rate matches that of standard ISTA.
The natural follow-up question is to determine how many layers of adaptive splitting are
sufficient before entering the steady regime of convergence. A conservative estimate of this
quantity would require an upper bound of ∣∣z* — Zk ∣∣ from the energy bound F(Zk) — F(z*).
Since in general F is convex but not strongly convex, such bound does not exist unless one
can assume that F is locally strongly convex (for instance for sufficiently small values of F).
2.3.2 Improving the factorization to particular input distributions
Given an input dataset D = (xi, z(0), z"≤n, containing examples Xi ∈ Rn, initial estimates
z(0) and sparse coding solutions zi, the factorization adapted to D is defined as
min
A,S; ATA=I,ATSA-B
(0)
i
—Zi)T(ATSA - B)(z(0) — Zi) + δA(zi) — δA(zι,i).
(15)
Therefore, adapting the factorization to a particular dataset, as opposed to enforcing it
uniformly over a given ball B(Zi ; R) (where the radius R ensures that the initial value
Z0 ∈ B(Zi; R)), will always improve the upper bound (9). Studying the gains resulting from
the adaptation to the input distribution will be let for future work.
3 Numerical Experiments
This section provides numerical arguments to analyse adaptive optimization algorithms and
their performances, and relates them to the theoretical properties developed in the previous
section. All the experiments were run using Python and Tensorflow. For all the experiments,
the training is performed using Adagrad (Duchi et al., 2011). The code to reproduce the
figures is available online2 .
3.1	Adaptive Optimization Networks Architectures
LISTA/LFISTA In Gregor & Le Cun (2010), the authors introduced LISTA, a neural
network constructed by considering ISTA as a recurrent neural net. At each step, ISTA
performs the following 2-step procedure :
1.	uk+1 = Zk — LDT(DZk — X) = (I — LDTD) Zk + LDT X J
'~W_}	Y y step k OfISTA (16)
2.	Zk+ι	= hλ	(uk+ι)	where	hθ(U)	= Sign(U)(|u|	—	θ)+	,
2The code can be found at https://github.com/tomMoral/AdaptiveOptim
6
Published as a conference paper at ICLR 2017
This procedure combines a linear operation to compute uk+1 with an element-wise non
linearity. It can be summarized as a recurrent neural network, presented in Figure 1a.,
with tied weights. The autors in Gregor & Le Cun (2010) considered the architecture ΦΘK
with parameters Θ = (Wg(k) , We(k) , θ(k))k=1,...K obtained by unfolding K times the recurrent
network, as presented in Figure 1b. The layers φkΘ are defined as
zk+1 = φkΘ (zk) := hθ (Wgzk + Wex) .	(17)
If W(k) = I 一 DLD, W(k) = DT and θ(k) = L are fixed for all the K layers, the out-
put of this neural net is exactly the vector zK resulting from K steps of ISTA. With
LISTA, the parameters Θ are learned using back propagation to minimize the cost function:
f(Θ) = Ex hFx(ΦΘK(x))i .
A similar algorithm can be derived from FISTA, the accelerated version of ISTA to obtain
LFISTA (see Figure 5 in Appendix A ). The architecture is very similar to LISTA, now
with two memory tapes:
zk+1 = hθ(Wgzk + Wmzk-1 + Wex) .
Factorization network Our analysis in Section 2 suggests a refactorization of LISTA in
more a structured class of parameters. Following the same basic architecture, and using (5),
the network FacNet, ΨΘK is formed using layers such that:
zk+ι = Ψθ(Zk) ：= AThis- (Azk 一 STA(DTDzk - DTx)) ,	(18)
with S diagonal and A unitary, the parameters of the k-th layer. The parameters obtained
after training such a network with back-propagation can be used with the theory devel-
oped in Section 2. Up to the last linear operation AT of the network, this network is a
re-parametrization of LISTA in a more constrained parameter space. Thus, LISTA is a
generalization of this proposed network and should have performances at least as good as
FacNet, for a fixed number of layers.
The optimization can also be performed using backpropagation. To enforce the unitary
constraints on A(k), the cost function is modified with a penalty:
K	2
f(⑼=Ex [Fχ(ΨK (x))i + K XI-(A(k)] A(k)	,	(19)
k=1	2
with Θ = (A(k), S(k))k=ι...κ the parameters of the K layers and μ a scaling factor for the
regularization. The resulting matrix A(k) is then projected on the Stiefel Manifold using a
SVD to obtain final parameters, coherent with the network structure.
Linear model Finally, it is important to distinguish the performance gain resulting from
choosing a suitable starting point and the acceleration from our model. To highlights the
gain obtain by changing the starting point, we considered a linear model with one layer
such that zout = A(0)x. This model is learned using SGD with the convex cost function
f (A(O)) = Il(I 一 DA(O))x∣∣2 + λ∣∣A⑼xk1 . It computes a tradeoff between starting from the
sparsest point 0 and a point with minimal reconstruction error y . Then, we observe the
performance of the classical iteration of ISTA using zout as a stating point instead of 0 .
3.2 Synthetic problems with known distributions
Gaussian dictionary In order to disentangle the role of dictionary structure from the
role of data distribution structure, the minimization problem is tested using a synthetic
generative model with no structure in the weights distribution. First, m atoms di ∈ Rn are
drawn iid from a multivariate Gaussian with mean 0 and covariance In and the dictionary
D is defined as di/kdi k2	. The data points are generated from its sparse codes
i=1...m
following a Bernoulli-Gaussian model. The coefficients z = (z1, . . . , zm) are constructed
with zi = bi,aji, where b 〜B(P) and ai 〜N(0,σIm) , where P controls the sparsity of the
data. The values are set to m=100, n=64 for the dictionary dimension, ρ = 5/m for the
sparsity level and σ=10 for the activation coefficient generation parameters. The sparsity
7
Published as a conference paper at ICLR 2017
1°,1°,1°∙°j°j°jL°i°^
(*zsl(zsUonOUESOU
IO0	IO1	10a
# iteration/layers k
1°,1°,1°,1°∙°j°j°jl°∙5i
∙zsl(zsUOnOUrUlSOU
一	ISTA	•—∙	L-ISTA
―Linear	♦~♦	FacNet
I	FISTA	—	L-FISTA
IO0
IO1
# iteration/layers k
10j
Figure 2:	Evolution of the cost function F(Zk) — F(z*) with the number of layers or the
number of iteration k for different sparsity level. (left) ρ = 1/20 and (right)ρ = 1/4 .
!二FL...........................................
lo≡lo1lo0o-1o-2o-3o-∙o-5o-βl
c⅛l? uotjum⅞o□
一 ISTA	•—∙ L-ISTA
I FISTA	I FacNet
IO1	10j	10:
# iteration/layers k
Figure 3:	Evolution of the cost function F(Zk) — F(z*) With the number of layers or the
number of iteration k for a problem generated with an adversarial dictionary.
regularization is set to λ=0.01. The batches used for the training are generated With the
model at each step and the cost function is evaluated over a fixed test set, not used in the
training.
Figure 2 displays the cost performance for methods ISTA/FISTA/Linear relatively to their
iterations and for methods LISTA/LFISTA/FacNet relatively to the number of layers used
to solve our generated problem. Linear has performances comparable to learned methods
With the first iteration but a gap appears as the number of layers increases, until a point
Where it achieves the same performances as non adaptive methods. This highlights that the
adaptation is possible in the subsequent layers of the netWorks, going farther than choosing
a suitable starting point for iterative methods. The first layers permit to achieve a large
gain over the classical optimization strategy, by leveraging the structure of the problem.
This appears even With no structure in the sparsity patterns of input data, in accordance
With the results in the previous section. We also observe diminishing returns as the number
of layers increases. This results from the phase transition described in Subsubsection 2.3.1,
as the last layers behave as ISTA steps and do not speed up the convergence. The 3 learned
algorithms are alWays performing at least as Well as their classical counterpart, as it Was
stated in Theorem 2.2. We also explored the effect of the sparsity level in the training and
learning of adaptive networks. In the denser setting, the arbitrage between the 'ι-norm and
the squared error is easier as the solution has a lot of non zero coefficients. Thus in this
setting, the approximate method is more precise than in the very sparse setting where the
approximation must perform a fine selection of the coefficients. But it also yield lower gain
at the beggining as the sparser solution can move faster.
There is a small gap between LISTA and FacNet in this setup. This can be explained
from the extra constraints on the weights that we impose in the FacNet, which effectively
reduce the parameter space by half. Also, we implement the unitary constraints on the
matrix A by a soft regularization (see (19)), involving an extra hyper-parameter μ that also
contributes to the small performance gap. In any case, these experiments show that our
analysis accounts for most of the acceleration provided by LISTA, as the performance of
both methods are similar, up to optimization errors.
Adversarial dictionary The results from Section 2 show that problems with a gram matrix
composed of large eigenvalues associated to non sparse eigenvectors are harder to accelerate.
Indeed, it is not possible in this case to find a quasi diagonalization of the matrix B that
8
Published as a conference paper at ICLR 2017
广-1-,j∙,6*
lOOOOOO
(*zsl(zsUOnOUrUlSOU
“8765432101'
Dnununununununununur^
∙zsl(zsUOnOUrUlSOU
IO0	IO1	10j	IO0	IO1	10j
# iteration/layers k	# iteration/layers k
(a) Pascal VOC 2008	(b) MNIST
Figure 4: Evolution of the cost function F(Zk) — F(z*) with the number of layers or the
number of iteration k for two image datasets.
does not distort the `1 norm. It is possible to generate such a dictionary using Harmonic
Analysis. The Discrete Fourier Transform (DFT) distorts a lot the `1 ball, since a very
sparse vector in the temporal space is transformed in widely spread spectrum in the Fourier
domain. We can thus design a dictionary for which LISTA and FacNet performances should
be degraded. D
(di∕kdik2)	is constructed such that dj,k = e-2πijζk, with (Zk)左＜匹
randomly selected from 1/m, . . . , m/2/m without replacement.
The resulting performances are reported in Figure 3. The first layer provides a big gain by
changing the starting point of the iterative methods. It realizes an arbitrage of the tradeoff
between starting from 0 and starting from y . But the next layers do not yield any extra
gain compared to the original ISTA algorithm. After 4 layers, the cost performance of both
adaptive methods and ISTA are equivalent. It is clear that in this case, FacNet does not
accelerate efficiently the sparse coding, in accordance with our result from Section 2. LISTA
also displays poor performances in this setting. This provides further evidence that FacNet
and LISTA share the same acceleration mechanism as adversarial dictionaries for FacNet
are also adversarial for LISTA.
3.3 Sparse coding with over complete dictionary on images
Wavelet encoding for natural images A highly structured dictionary composed of trans-
lation invariant Haar wavelets is used to encode 8x8 patches of images from the PASCAL
VOC 2008 dataset. The network is used to learn an efficient sparse coder for natural im-
ages over this family. 500 images are sampled from dataset to train the encoder. Training
batches are obtained by uniformly sampling patches from the training image set to feed
the stochastic optimization of the network. The encoder is then tested with 10000 patches
sampled from 100 new images from the same dataset.
Learned dictionary for MNIST To evaluate the performance of LISTA for dictionary
learning, LISTA was used to encode MNIST images over an unconstrained dictionary,
learned a priori using classical dictionary learning techniques. The dictionary of 100 atoms
was learned from 10000 MNIST images in grayscale rescaled to 17x17 using the implemen-
tation of Mairal et al. (2009) proposed in scikit-learn, with λ = 0.05. Then, the networks
were trained through backpropagation using all the 60000 images from the training set of
MNIST. Finally, the perfornance of these encoders were evaluated with the 10000 images of
the training set of MNIST.
The Figure 4 displays the cost performance of the adaptive procedures compared to non-
adaptive algorithms. In both scenario, FacNet has performances comparable to the one of
LISTA and their behavior are in accordance with the theory developed in Section 2. The
gains become smaller for each added layer and the initial gain is achieved for dictionary
either structured or unstructured. The MNIST case presents a much larger gain compare
to the experiment with natural images. This results from the difference of structure of
the input distribution, as the MNIST digits are much more constrained than patches from
natural images and the network is able to leverage it to find a better encoder. In the MNIST
case, a network composed of 12 layers is sufficient to achieve performance comparable to
ISTA with more than 1000 iterations.
9
Published as a conference paper at ICLR 2017
4 Conclusions
In this paper we studied the problem of finite computational budget approximation of sparse
coding. Inspired by the ability of neural networks to accelerate over splitting methods on the
first few iterations, we have studied which properties of the dictionary matrix and the data
distribution lead to such acceleration. Our analysis reveals that one can obtain acceleration
by finding approximate matrix factorizations of the dictionary which nearly diagonalize its
Gram matrix, but whose orthogonal transformations leave approximately invariant the `1
ball. By appropriately balancing these two conditions, we show that the resulting rotated
proximal splitting scheme has an upper bound which improves over the ISTA upper bound
under appropriate sparsity.
In order to relate this specific factorization property to the actual LISTA algorithm, we have
introduced a reparametrization of the neural network that specifically computes the factor-
ization, and incidentally provides reduced learning complexity (less parameters) from the
original LISTA. Numerical experiments of Section 3 show that such reparametrization re-
covers the same gains as the original neural network, providing evidence that our theoretical
analysis is partially explaining the behavior of the LISTA neural network. Our acceleration
scheme is inherently transient, in the sense that once the iterates are sufficiently close to
the optimum, the factorization is not effective anymore. This transient effect is also consis-
tent with the performance observed numerically, although the possibility remains open to
find alternative models that further exploit the particular structure of the sparse coding.
Finally, we provide evidence that successful matrix factorization is not only sufficient but
also necessary for acceleration, by showing that Fourier dictionaries are not accelerated.
Despite these initial results, a lot remains to be understood on the general question of
optimal tradeoffs between computational budget and statistical accuracy. Our analysis so
far did not take into account any probabilistic consideration (e.g. obtain approximations that
hold with high probability or in expectation). Another area of further study is the extension
of our analysis to the FISTA case, and more generally to other inference tasks that are
currently solved via iterative procedures compatible with neural network parametrizations,
such as inference in Graphical Models using Belief Propagation or other ill-posed inverse
problems.
References
Alekh Agarwal. Computational Trade-offs in Statistical Learning. PhD thesis, University of
California, Berkeley, 2012.
Ahmed Alaoui and Michael W Mahoney. Fast randomized kernel ridge regression with
statistical guarantees. In Advances in Neural Information Processing Systems (NIPS),
pp. 775-783, 2015.
Amir Beck and Marc Teboulle. A Fast Iterative Shrinkage-Thresholding Algorithm for
Linear Inverse Problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009.
SebaStien Bubeck. Theory of convex optimization for machine learning. preprint, arXiv:1405
(4980), 2014.
CharleS F Cadieu and Bruno A OlShauSen. Learning intermediate-level repreSentationS of
form and motion from natural movieS. Neural computation, 24(4):827-866, 2012.
Venkat ChandraSekaran and Michael I Jordan. Computational and StatiStical tradeoffS
via convex relaxation. Proceedings of the National Academy of Sciences, 110(13):E1181-
E1190, 2013.
Adam CoateS and Andrew Y Ng. The importance of encoding verSuS training with SparSe
coding and vector quantization. In Proceedings of the 28th International Conference on
Machine Learning (ICML-11), pp. 921-928, 2011.
Patrick L CombetteS and Heinz H. BauSchke. Convex Analysis and Monotone Operator
Theory in Hilbert Spaces, volume 1. 2011.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive Subgradient methodS for online
learning and StochaStic optimization. The Journal of Machine Learning Research, 12:
2121-2159, 2011.
10
Published as a conference paper at ICLR 2017
Jerome Friedman, Trevor Hastie, Holger Hofling, and Robert Tibshirani. PathWise coordi-
nate optimization. The Annals of Applied Statistics, 1(2):302-332, 2007.
Raja Giryes, Yonina C Eldar, Alex M Bronstein, and Guillermo Sapiro. Tradeoffs betWeen
convergence speed and reconstruction accuracy in inverse problems. preprint, arXiv:1605
(09232), 2016.
Karol Gregor and Yann Le Cun. Learning Fast Approximations of Sparse Coding. In
International Conference on Machine Learning (ICML), pp. 399-406, 2010.
Trevor Hastie, Robert Tibshirani, and Martin J. WainWright. Statistical Learning with
Sparsity. CRC Press, 2015.
Tim Hesterberg, Nam Hee Choi, Lukas Meier, and Chris Fraley. Least angle and 1 penalized
regression: A revieW. Statistics Surveys, 2:61-93, 2008.
J. B. Hiriart-Urruty. HoW to regularize a difference of convex functions. Journal of Mathe-
matical Analysis and Applications, 162(1):196-209, 1991.
Julien Mairal, Francis Bach, Jean Ponce, and Guillermo Sapiro. Online Learning for Matrix
Factorization and Sparse Coding. Journal of Machine Learning Research, 11(1):19-60,
2009.
Yu Nesterov. Smooth minimization of non-smooth functions. Mathematical Programming,
103(1):127-152, 2005.
Stanley Osher and Yingying Li. Coordinate descent optimization for l1 minimization With
application to compressed sensing; a greedy algorithm. Inverse Problems and Imaging, 3
(3):487-503, 2009.
Samet Oymak, Benjamin Recht, and Mahdi Soltanolkotabi. Sharp time-data tradeoffs for
linear inverse problems. preprint, arXiv:1507(04793), 2015.
Pablo Sprechmann, Alex Bronstein, and Guillermo Sapiro. Learning Efficient Structured
Sparse Models. In International Conference on Machine Learning (ICML), pp. 615-622,
2012.
Robert Tibshirani. Regression Shrinkage and Selection via the Lasso. Journal of the royal
statistical society. Series B (methodological), 58(1):267-288, 1996.
Bo Xin, Yizhou Wang, Wen Gao, and David Wipf. Maximal sparsity With deep netWorks?
preprint, arXiv:1605(01636), 2016.
Yun Yang, Mert Pilanci, and Martin J WainWright. Randomized sketches for kernels: Fast
and optimal non-parametric regression. preprint, arXiv:1501(06195), 2015.
A Learned Fista
A similar algorithm can be derived from FISTA, the accelerated version of ISTA to obtain
LFISTA (see Figure 5 ). The architecture is very similar to LISTA, noW With tWo memory
taps: It introduces a momentum term to improve the convergence rate of ISTA as folloWs:
1.
2.
yk = Zk + tk-1一1 (Zk - zk-ι),
tk *
zk+ι = hλ ( yk - L VE(yk) ) = hλ ( (I - LB)yk + LDTx
3.
tk+1
2
By substituting the expression for yk into the first equation, We obtain a generic recurrent
architecture very similar to LISTA, noW With tWo memory taps, that We denote by LFISTA:
Zk+1 = hθ(Wg(k)Zk + Wm(k)Zk-1 + We(k)x) .
11
Published as a conference paper at ICLR 2017
Z
Figure 5: Network architecture for LFISTA. This network is trainable through backpropa-
gation and permits to approximate the sparse coding solution efficiently.
This model is equivalent to running K -steps of FISTA when its parameters are initialized
with
Wg(k)
Wm(k)
We(k)
The parameters of this new architecture, presented in Figure 5 , are trained analogously as
in the LISTA case.
B Proofs
Lemma B.1. Suppose that R = ATSA - B is positive definite, and define
Zk+1 = argminF(Z, Zk) , and
z
(20)
δA(z) = kAzk1 - kzk1. Then we have
F(Zk+I)-F(z*) ≤ 2 ((Z* - Zk)TR(Z* - Zk)-(Z* - zk+I)TR(Z* - zk+1)^+hdδA(zk+1),zk+1-z*i .
(21)
Proof. We define
f(t)=F(tZk+1+(1-t)Z*	, t∈ [0, 1] .
Since F is convex, f is also convex in [0, 1]. Since f(0) = F(Z*) is the global minimum, it
results that f0(t) is increasing in (0, 1], and hence
F(Zk+1) - F(Z*) = f(1) - f(0) =	f0(t)dt ≤ f0(1) ,
where f0(1) is any element of ∂f(1). Since δA(Z) is a difference of convex functions, its
subgradient can be defined as a limit of infimal convolutions Hiriart-Urruty (1991). We
have
∂f(1) = h∂F (Zk+1), Zk+1 - Z*i ,
and since
∂F(Z) = ∂Fe(Z, Zk) - R(Z - Zk) - ∂δA(Z) and 0 ∈ ∂Fe(Zk+1, Zk)
it results that
∂F (Zk+1) = -R(Zk+1 - Zk) - ∂δA(Zk+1) ,
and thus
F(Zk+1) - F(Z*) ≤ (Z* - Zk+1)TR(Zk+1 - Zk) + h∂δA(Zk+1), (Z* - Zk+1)i .	(22)
(21) is obtained by observing that
(Z* — Zk+1)TR(Zk+1 - Zk) ≤ 2 ((Z* - Zk )TR(Z* - Zk ) - (z* - Zk+1)TR(Z* - Zk+1)) , (23)
thanks to the fact that R A 0.	□
12
Published as a conference paper at ICLR 2017
Theorem B.2. Let Ak,Sk be the pair of unitary and diagonal matrices corresponding to
iteration k, chosen such that Rk = ATSkAk — B A 0. It results that
F(Zk) — F(z*) ≤ © - ZO)TR°(z* - z0)+2"δA。⑵),(z* - zi)〉十 α-β , With (24)
k-1
α = X (2"δAn (Zn+1), (z* — Zn+1 )〉+ (z* — Zn )T(Rn-1 - Rn)(z* -，n)),
n=1
k-1
β = X(n + I) ((Zn+1 — Zn)TRn(Zn+1 — Zn) + 2δAn (Zn+1)- 2δAn (Zn)).
n=O
Proof: The proof is adapted from (Beck & Teboulle, 2009), Theorem 3.1. From Lemma B.1,
we start by using (21) to bound terms of the form F(Zn) — F(z*):
F (Zn)-F (z*) ≤ B δ An (/n+1) , (z* —，九+1)〉+2 ((，* — Zn ), Rn(Z* — Zn) — (z* — 2九十1), Rn (，* — Zn⅛1)
Adding these inequalities for n = 0 ...k — 1 we obtain
k-1	∖	k-1
X F (Zn) I — kF (Z*) ≤ X"δAn (Zn+1), (，*- Zn+1)〉+	(25)
n=O	n=O
+ 2 ((z* — ZO)TRo(z* — ZO) — (z* — Zk)TRk-1(z* — Zk)) +
1 k-1
+ 5 X(Z* — Zn)T(Rn-1 — Rn)(Z* — Zn) ∙
n=1
On the other hand, we also have
F(Zn) — F(Zn+1) ≥ F(Zn) — F(ZnIZn) + F(Zn+1, Zn) — F(Zn+1)
= —δAn (Zn) + δAn (Zn+1) + ](Zn+1 — Zn )TRn(Zn+1 — Zn),
which results in
k-1	1 k-1
X(n + 1)(F(Zn) — F(Zn+1)) ≥ 2 X(n + I)(Zn+1 — Zn)TRn(Zn+1 — Zn) +	(26)
n=O	n=O
k-1
+ X(n + I) (δAn (Zn+1) - δAn (Zn))
n=O
k-1
X F(Zn)	— kF(Zk)	≥
n=O
k-1	1
y^(n + I)(2(Zn+1 — Zn)TRn(Zn+1 — Zn)+ δAn (Zn+1) — δAn (Zn)
Combining (25) and (26) we obtain
F (Zk) — F (z*)	≤
(Z* - ZO)TRO(Z* - Z0) + 2"δA0 (ZI), (Z* - Z1))
2k
Q — β
+ ^Γ
(27)
with
k-1
Q = X (2"δAn (Zn+1), (Z* — Zn+1)〉+ (z* — Zn)T(Rn-1 — Rn)(z* — Zn)
n=1
k-1
β = X(n +1)((zn+1 — Zn)TRn (Zn+1 — Zn) + 2δAn (Zn+1) — 2δAn (Zn)
n=O
口
Corollary B.3. If Ak = I, Sk = IIBllI for k > 0 then
F(Zk)—F(z*) ≤
(z* - ZO)TRO(z* — zO) + 2LAo (ZI)(I∣z* — z1k + ∣∣z1 — ZOIl) + (z* — ZI)TRO(z* — ZI)T
2k
(28)
Proof: We verify that in that case, Rn-1 — Rn ≡ 0 and for n > 1 and δAn ≡ 0 for n > 0 □.
13