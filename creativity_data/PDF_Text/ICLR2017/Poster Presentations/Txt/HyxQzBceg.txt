Published as a conference paper at ICLR 2017
Deep Variational information bottleneck
Alexander A. Alemi, Ian Fischer, Joshua V. Dillon, Kevin Murphy
Google Research
{alemi,iansf,jvdillon,kpmurphy}@google.com
Ab stract
We present a variational approximation to the information bottleneck of Tishby
et al. (1999). This variational approach allows us to parameterize the informa-
tion bottleneck model using a neural network and leverage the reparameterization
trick for efficient training. We call this method “Deep Variational Information
Bottleneck”, or Deep VIB. We show that models trained with the VIB objective
outperform those that are trained with other forms of regularization, in terms of
generalization performance and robustness to adversarial attack.
1	Introduction
We adopt an information theoretic view of deep networks. We regard the internal representation of
some intermediate layer as a stochastic encoding Z of the input source X , defined by a parametric
encoder p(z|x; θ).1 2 Our goal is to learn an encoding that is maximally informative about our target
Y , measured by the mutual information between our encoding and the target I(Z, Y ; θ), where
I (Z,Y; θ)= ZdXdyPEn 网k>g p(p∣z)p∣y)θ) .2	⑴
Given the data processing inequality, and the invariance of the mutual information to reparameteriza-
tions, if this was our only objective we could always ensure a maximally informative representation
by taking the identity encoding of our data (Z = X), but this is not a useful representation of our
data. Instead we would like to find the best representation we can obtain subject to a constraint on
its complexity. A natural and useful constraint to apply is on the mutual information between our
encoding and the original data, I(X, Z) ≤ Ic, where Ic is the information constraint. This suggests
the objective:
max I(Z, Y; θ) StI(X, Z; θ) ≤ Ic .	(2)
θ
Equivalently, with the introduction of a Lagrange multiplier β , we can maximize the objective func-
tion
RIB (θ)= I(Z,Y; θ) - βI(Z,X； θ)∙	(3)
Here our goal is to learn an encoding Z that is maximally expressive about Y while being maximally
compressive about X, where β ≥ 0 controls the tradeoff.3 This approach is known as the informa-
tion bottleneck (IB), and was first proposed in Tishby et al. (1999). Intuitively, the first term in RIB
encourages Z to be predictive of Y ; the second term encourages Z to “forget” X . Essentially it
forces Z to act like a minimal sufficient statistic of X for predicting Y .
The IB principle is appealing, since it defines what we mean by a good representation, in terms of the
fundamental tradeoff between having a concise representation and one with good predictive power
(Tishby & Zaslavsky, 2015a). The main drawback of the IB principle is that computing mutual
information is, in general, computationally challenging. There are two notable exceptions: the first
1 In this work, X, Y, Z are random variables, x, y, z and x, y, z are instances of random variables, and
F(∙; θ) and f (∙; θ) are functionals or functions parameterized by θ.
2 Note that in the present discussion, Y is the ground truth label which is independent of our parameters so
p(y∣θ) = p(y).
3 Note that, in our notation, large β results in a highly compressed representation. In some works, the IB
principle is formulated as the minimization of I(Z, X) - βI(Z, Y ), in which case large β corresponds to high
mutual information between Z and Y , and hence low compression.
1
Published as a conference paper at ICLR 2017
is when X, Y and Z are all discrete, as in Tishby et al. (1999); this can be used to cluster discrete
data, such as words. The second case is when X, Y and Z are all jointly Gaussian (Chechik et al.,
2005). However, these assumptions both severely constrain the class of learnable models.
In this paper, we propose to use variational inference to construct a lower bound on the IB objective
in Equation 3. We call the resulting method VIB (variational information bottleneck). By using the
reparameterization trick (Kingma & Welling, 2014), we can use Monte Carlo sampling to get an
unbiased estimate of the gradient, and hence we can optimize the objective using stochastic gradient
descent. This allows us to use deep neural networks to parameterize our distributions, and thus to
handle high-dimensional, continuous data, such as images, avoiding the previous restrictions to the
discrete or Gaussian cases.
We also show, by a series of experiments, that stochastic neural networks, fit using our VIB method,
are robust to overfitting, since VIB finds a representation Z which ignores as many details of the
input X as possible. In addition, they are more robust to adversarial inputs than deterministic models
which are fit using (penalized) maximum likelihood estimation. Intuitively this is because each input
image gets mapped to a distribution rather than a unique Z, so it is more difficult to pass small,
idiosyncratic perturbations through the latent bottleneck.
2	Related work
The idea of using information theoretic objectives for deep neural networks was pointed out in
Tishby & Zaslavsky (2015b). However, they did not include any experimental results, since their
approach for optimizing the IB objective relied on the iterative Blahut Arimoto algorithm, which is
infeasible to apply to deep neural networks.
Variational inference is a natural way to approximate the problem. Variational bounds on mutual
information have previously been explored in Agakov (2004), though not in conjunction with the
information bottleneck objective. Mohamed & Rezende (2015) also explore variational bounds on
mutual information, and apply them to deep neural networks, but in the context of reinforcement
learning. We recently discovered Chalk et al. (2016), who independently developed the same varia-
tional lower bound on the IB objective as us. However, they apply it to sparse coding problems, and
use the kernel trick to achieve nonlinear mappings, whereas we apply it to deep neural networks,
which are computationally more efficient. In addition, we are able to handle large datasets by using
stochastic gradient descent, whereas they use batch variational EM.
In the supervised learning literature, our work is related to the recently proposed confidence penalty
(entropy regularization) method of (Pereyra et al., 2016). In this work, they fit a deterministic
network by optimizing an objective that combines the usual cross entropy loss with an extra term
which penalizes models for having low entropy predictive distributions. In more detail, their cost
function has the form
1N
JCP = N E [H(P(ylyn),P(ylxn)) - βH(P⑶Xn))]	⑷
n=1
where H(p, q) = - Py p(y) log q(y) is the cross entropy, H(p) = H(p, p) is the entropy,
p(y|yn) = δyn (y) is a one-hot encoding of the label yn, and N is the number of training exam-
ples. (Note that setting β = 0 corresponds to the usual maximum likelihood estimate.) In (Pereyra
et al., 2016) they show that CP performs better than the simpler technique of label smoothing, in
which we replace the zeros in the one-hot encoding of the labels by > 0, and then renormalize
so that the distribution still sums to one. We will compare our VIB method to both the confidence
penalty method and label smoothing in Section 4.1.
In the unsupervised learning literature, our work is closely related to the work in Kingma & Welling
(2014) on variational autoencoders. In fact, their method is a special case of an unsupervised version
of the VIB, but with the β parameter fixed at 1.0, as we explain in Appendix B. The VAE objective,
but with different values of β , was also explored in Higgins et al. (2016), but from a different
perspective.
The method of Wang et al. (2016b) proposes a latent variable generative model of both x and y;
their variational lower bound is closely related to ours, with the following differences. First, we do
2
Published as a conference paper at ICLR 2017
not have a likelihood term for x, since we are in the discriminative setting. Second, they fix β = 1,
since they do not consider compression.
Finally, the variational fair autoencoder of Louizos et al. (2016) shares with our paper the idea of
ignoring parts of the input. However, in their approach, the user must specify which aspects of the
input (the so-called “sensitive” parts) to ignore, whereas in our method, we can discover irrelevant
parts of the input automatically.
3	Method
Following standard practice in the IB literature, we assume that the joint distribution p(X, Y, Z)
factors as follows:
p(X, Y, Z) = p(Z|X, Y)p(Y |X)p(X) = p(Z|X)p(Y |X)p(X)	(5)
i.e., We assume P(Z|X, Y) = P(Z|X), corresponding to the Markov chain Y 什 X 什 Z. This
restriction means that our representation Z cannot depend directly on the labels Y . (This opens
the door to unsupervised representation learning, Which We Will discuss in Appendix B.) Besides
the structure in the joint data distribution P(X, Y), the only content at this point is our model for
the stochastic encoderP(Z|X), all other distributions are fully determined by these and the Markov
chain constraint.
Recall that the IB objective has the form I(Z, Y) - βI(Z, X). We Will examine each of these
expressions in turn. Let us start With I(Z, Y). Writing it out in full, this becomes
I(Z,y )= Z dydzP(y,z)∖og p(y,z∖ = Z dydzp(y,z)log p(ylz) .
P(y)P(z)	P(y)
Where P(y |z ) is fully defined by our encoder and Markov Chain as folloWs:
p(y∣z) = / dxp(x,y∣z) = / dxp(y∣x)p(x∣z) = / dx 汉")：(：)X)P(X)
(6)
(7)
Since this is intractable in our case, let q(y|z) be a variational approximation to P(y|z). This is our
decoder, Which We Will take to be another neural netWork With its oWn set of parameters. Using the
fact that the Kullback Leibler divergence is alWays positive, We have
KL[P(Y |Z), q(Y |Z)] ≥0
=⇒	dyP(y|z) log P(y|z) ≥
dy P(y|z) log q(y|z) ,
(8)
and hence	I(Z,Y) ≥ d dy dzp(y,z)log q(ylz)	(9) P(y) =	dy dz P(y, z) log q(y|z) — dy P(y) logP(y)	(10) =	dy dz P(y, z) log q(y|z) + H(Y) .	(11)
Notice that the entropy of our labels H(Y) is independent of our optimization procedure and so can
be ignored.
Focusing on the first term in Equation 11, We can reWrite P(y, z) as P(y, z) =	dX P(X, y, z) =
dXP(X)P(y|X)P(z|X) (leveraging our Markov assumption), Which gives us a neW loWer bound on
the first term of our objective:
I(Z,Y) ≥
dX dy dz P(X)P(y|X)P(z|X) log q(y|z) .
(12)
This only requires samples from both our joint data distribution as Well as samples from our stochas-
tic encoder, While it requires We have access to a tractable variational approximation in q(y|z).
We noW consider the term βI(Z, X):
P(z |X)
I(Z, X) =	dz dxp(x, z) log—=	dz dxp(x, z) logp(z∣x) —	dzp(z) logP(Z) . (13)
P(z)
3
Published as a conference paper at ICLR 2017
In general, while it is fully defined, computing the marginal distribution of Z, p(z) =
dx p(z|x)p(x), might be difficult. So let r(z) be a variational approximation to this marginal.
Since KL[p(Z), r(Z)] ≥ 0 =⇒	dz p(z) logp(z) ≥	dz p(z) log r(z), we have the following
upper bound:
I(Z,X)≤
dx dz p(x)p(z|x)
log p(zlχ).
r(z)
(14)
Combining both of these bounds we have that
I(Z,Y)-βI(Z,X)≥
dxdy dz p(x)p(y|x)p(z|x) log q(y|z)
一β d dx dzp(x)p(z∖x) log，尸：，=L .
r(z)
(15)
We now discuss how to compute the lower bound L in practice. We can approximate p(x, y) =
p(x)p(y∖x) using the empirical data distribution p(x, y)= 得 PN=I δχn (x)δyn(y), and hence We
can write
L≈
dz p(z∖xn) log q(yn ∖z) - β p(z∖xn) log
p(z∖xn)
r(z)
(16)
Suppose we use an encoder of the form p(z∖x) = N(z∖fμ(x),借此))，where fe is an MLP which
outputs both the K-dimensional mean μ of Z as well as the K X K covariance matrix Σ. Then we
can use the reparameterization trick (Kingma & Welling, 2014) to write p(z∖x)dz = p()d, where
Z = f(x, ) is a deterministic function of x and the Gaussian random variable . This formulation
has the important advantage that the noise term is independent of the parameters of the model, so it
is easy to take gradients.
Assuming our choice of p(Z∖x) and r(Z) allows computation of an analytic Kullback-Leibler di-
vergence, we can put everything together to get the following objective function, which we try to
minimize:
1N
JIB = N EEe~p(e) [-logq(yn∖f (xn,e))] + βKL [p(Z∖xn),r(Z)] .	(17)
n=1
As in Kingma & Welling (2014), this formulation allows us to directly backpropagate through a
single sample of our stochastic code and ensure that our gradient is an unbiased estimate of the true
expected gradient.4
4 Experimental results
In this section, we present various experimental results, comparing the behavior of standard deter-
ministic networks to stochastic neural networks trained by optimizing the VIB objective.
4.1	Behavior on MNIS T
We start with experiments on unmodified MNIST (i.e. no data augmentation). In order to pick a
model with some “headroom” to improve, we decided to use the same architecture as in the (Pereyra
et al., 2016) paper, namely an MLP with fully connected layers of the form 784 - 1024 - 1024
- 10, and ReLu activations. (Since we are not exploiting spatial information, this correpsonds to
the “permutation invariant” version of MNIST.) The performance of this baseline is 1.38% error.
(Pereyra et al., 2016) were able to improve this to 1.17% using their regularization technique. We
were able to improve this to 1.13% using our technique, as we explain below.
In our method, the stochastic encoder has the form p(z∖x) = N (z∖fμ(x), ff(x)), where fe is an
MLP of the form 784 - 1024 - 1024 - 2K, where K is the size of the bottleneck. The first K
outputs from fe encode μ, the remaining K outputs encode σ (after a softplus transform).
4 Even if our choice of encoding distribution and variational prior do not admit an analytic KL, we could
similarly reparameterize through a sample of the divergence (Kingma & Welling, 2014; Blundell et al., 2015).
4
Published as a conference paper at ICLR 2017
	Model	error
Baseline	1.38%
Dropout	1.34%
Dropout (Pereyra et al., 2016)	1.40%
Confidence Penalty	1.36%
Confidence Penalty (Pereyra et al., 2016)	1.17%
Label Smoothing	1.40%
Label Smoothing (Pereyra et al., 2016)	1.23%
	VIB (β = 10-3)	1.13%
Table 1: Test set misclassification rate on permutation-invariant MNIST using K = 256. We com-
pare our method (VIB) to an equivalent deterministic model using various forms of regularization.
The discrepancy between our results for confidence penalty and label smoothing and the numbers
reported in (Pereyra et al., 2016) are due to slightly different hyperparameters.
The decoder is a simple logistic regression model of the form q(y|z) = S(y|fd(z)), where S(a) =
[exp(ac)/ PcC0=1 exp(ac0)] is the softmax function, and fd (z) = Wz + b maps the K dimensional
latent code to the logits of the C = 10 classes. (In later sections, we consider more complex
decoders, but here we wanted to show the benefits of VIB in a simple setting.)
Finally, we treat r(z) as a fixed K-dimensional spherical Gaussian, r(z) = N (z|0, I).
We compare our method to the baseline MLP. We calso consider the following deterministic limit
of our model, when β = 0. In this case, we obtain the following objective function:
1N
JIBO = - N £ Ez〜N(fμ(xn),f∑(xn)) [log S(yn Ifd(Z)]	(18)
n=1
When β → 0, we observe the VIB optimization process tends to make feΣ (x) → 0, so the network
becomes nearly deterministic. In our experiments we also train an explicitly deterministic model
that has the same form as the stochastic model, except that We just use Z = fμ(χ) as the hidden
encoding, and drop the Gaussian layer.
4.1.1	Higher dimensional embedding
To demonstrate that our VIB method can achieve competitive classification results, We compared
against a deterministic MLP trained With various forms of regularization. We use a K = 256
dimensional bottleneck and a diagonal Gaussian for p(Z|x). The netWorks Were trained using Ten-
sorFloW for 200 epochs using the Adam optimizer (Kingma & Ba, 2015) With a learning rate of
0.0001. Full hyperparameter details can be found in Appendix A.
The results are shoWn in Table 1. We see that We can slightly outperform other forms of regulariza-
tion that have been proposed in the literature While using the same netWork for each. Of course, the
performance varies depending on β . These results are not state of the art, nor is our main focus of
our Work to suggest that VIB is the best regularization method by itself, Which Would require much
more experimentation. HoWever, using the same architecture for each experiment and comparing
to VIB as the only source of regularization suggests VIB Works as a decent regularizer in and of
itself. Figure 1(a) plots the train and test error vs β, averaged over 5 trials (With error bars) for the
case Where We use a single Monte Carlo sample of Z When predicting, and also for the case Where
we average over 12 posterior samples (i.e., we use p(y∣χ) = 1 PS=I q(y∣zs) for ZS 〜p(z|x),
Where S = 12). In our oWn investigations, a dozen samples seemed to be sufficient to capture any
additional benefit the stochastic evaluations had to offer in this experiment5.
We see several interesting properties in Figure 1(a). First, we notice that the error rate shoots up
once β rises above the critical value of β 〜10-2. This corresponds to a setting where the mutual
information between X and Z is less than log2 (10) bits, so the model can no longer represent the
fact that there are 10 different classes. Second, we notice that, for small values of β, the test error
5 A dozen samples wasn’t chosen for any particular reason, except the old addage that a dozen samples are
sufficient, as mirrored in David MacKay’s book (MacKay, 2003). They proved sufficient in this case.
5
Published as a conference paper at ICLR 2017
is higher than the training error, which indicates that we are overfitting. This is because the network
learns to be more deterministic, forcing σ ≈ 0, thus reducing the benefits of regularization. Third,
we notice that for intermediate values of β, Monte Carlo averaging helps. Interestingly, the region
with the best performance roughly corresponds to where the added benefit from stochastic averaging
goes away, suggesting an avenue by which one could try to optimize β using purely statistics on the
training set without a validation set. We have not extensively studied this possibility yet.
In Figure 1(c), we plot the IB curve, i.e., we plot I(Z, Y ) vs I(Z, X) as we vary β. As we allow
more information from the input through to the bottleneck (by lowering β), We increase the mutual
information between our embedding and the label on the training set, but not necessarily on the test
set, as is evident from the plot.
In Figure 1(d) we plot the second term in our objective, the upper bound on the mutual information
between the images X and our stochastic encoding Z, which in our case is simply the relative
entropy between our encoding and the fixed isotropic unit Gaussian prior. Notice that the y-axis is a
logarithmic one. This demonstrates that our best results (when β is between 10-3 and 10-2) occur
where the mutual information between the stochastic encoding and the images is on the order of 10
to 100 bits.
10-9	10-8	10-7	10-6	10-5	10-4	10-3	10-2	10-1	100	101
β
β
101
(a)
(c)
Figure 1: Results of VIB model on MNIST. (a) Error rate vs β for K = 256 on train and test set.
“1 shot eval” means a single posterior sample of z, “avg eval” means 12 Monte Carlo samples. The
spike in the error rate at β 〜10-2 corresponds to a model that is too highly regularized. Plotted
values are the average over 5 independent training runs at each β. Error bars show the standard
deviation in the results. (b) Same as (a), but for K = 2. Performance is much worse, since we pass
through a very narrow bottleneck. (c) I(Z, Y ) vs I(Z, X) as we vary β for K = 256. We see that
increasing I(Z, X) helps training set performance, but can result in overfitting. (d) I(Z, X) vs β
for K = 256. We see that for a good value of β, such as 10-2, we only need to store about 10 bits
of information about the input.
(b)
β
(d)
4.1.2	Two dimensional embedding
To better understand the behavior of our method, we refit our model to MNIST using a K = 2
dimensional bottleneck, but using a full covariance Gaussian. (The neural net predicts the mean and
the Cholesky decomposition of the covariance matrix.) Figure 1(b) shows that, not surprisingly, the
classification performance is worse (note the different scaled axes), but the overall trends are the
6
Published as a conference paper at ICLR 2017
same as in the K = 256 dimensional case. The IB curve (not shown) also has a similar shape to
before, except now the gap between training and testing is even larger.
Figure 2 provides a visualization of what the network is doing. We plot the posteriors p(z|x) as a 2d
Gaussian ellipse (representing the 95% confidence region) for 1000 images from the test set. Colors
correspond to the true class labels. In the background of each plot is the entropy of the variational
classifier q(y|z) evaluated at that point.
(a) β = 10-3, errmc = 3.18%, (b) β = 10-1, errmc = 3.44%, (c) β = 100, errmc = 33.82%,
err1 = 3.24%	err1 = 4.32%	err1 = 62.81%.
Figure 2: Visualizing embeddings of 1000 test images in two dimensions. We plot the 95% confi-
dence interval of the Gaussian embedding p(z|x) = N(μ, Σ) as an ellipse. The images are colored
according to their true class label. The background greyscale image denotes the entropy of the vari-
ational classifier evaluated at each two dimensional location. As β becomes larger, we forget more
about the input and the embeddings start to overlap to such a degree that the classes become indis-
tinguishable. We also report the test error using a single sample, err1, and using 12 Monte Carlo
samples, errmc. For “good” values of β, a single sample suffices.
We see several interesting properties. First, as β increases (so we pass less information through),
the embedding covariances increase in relation to the distance between samples, and the classes
start to overlap. Second, once β passes a critical value, the encoding “collapses”, and essentially
all the class information is lost. Third, there is a fair amount of uncertainty in the class preditions
(q(y|z)) in the areas between the class embeddings. Fourth, for intermediate values of β (say 10-1
in Figure 2(b)), predictive performance is still good, even though there is a lot of uncertainty about
where any individual image will map to in comparison to other images in the same class. This means
it would be difficult for an outside agent to infer which particular instance the model is representing,
a property which we will explore more in the following sections.
4.2	Behavior on adversarial examples
Szegedy et al. (2013) was the first work to show that deep neural networks (and other kinds of
classifiers) can be easily “fooled” into making mistakes by changing their inputs by imperceptibly
small amounts. In this section, we will show how training with the VIB objective makes models
significantly more robust to such adversarial examples.
4.2.1	Types of Adversaries
Since the initial work by Szegedy et al. (2013) and Goodfellow et al. (2014), many different adver-
saries have been proposed. Most attacks fall into three broad categories: optimization-based attacks
(Szegedy et al., 2013; Carlini & Wagner, 2016; Moosavi-Dezfooli et al., 2016; Papernot et al., 2015;
Robinson & Graham, 2015; Sabour et al., 2016), which directly run an optimizer such as L-BFGS
or ADAM (Kingma & Ba, 2015) on image pixels to find a minimal perturbation that changes the
model’s classification; single-step gradient-based attacks (Goodfellow et al., 2014; Kurakin et al.,
2016; Huang et al., 2015), which choose a gradient direction of the image pixels at some loss and
then take a single step in that direction; and iterative gradient-based attacks (Kurakin et al., 2016),
7
Published as a conference paper at ICLR 2017
which take multiple small steps along the gradient direction of the image pixels at some loss, recom-
puting the gradient direction after each step.6
Many adversaries can be formalized as either untargeted or targeted variants. An untargeted ad-
versary can be defined as A(X, M) → X0, where A(.) is the adversarial function, X is the input
image, X0 is the adversarial example, and M is the target model. A is considered successful if
M(X) 6= M(X0). Recently, Moosavi-Dezfooli et al. (2016) showed how to create a “universal”
adversarial perturbation δ that can be added to any image X in order to make M (X + δ) 6= M (X)
for a particular target model.
A targeted adversary can be defined as A(X, M, l) → X0, where l is an additional target label, and
A is only considered successful if M (X0) = l.7 Targeted attacks usually require larger magnitude
perturbations, since the adversary cannot just “nudge” the input across the nearest decision boundary,
but instead must force it into a desired decision region.
In this work, we focus on the Fast Gradient Sign (FGS) method proposed in Goodfellow et al.
(2014) and the L2 optimization method proposed in Carlini & Wagner (2016). FGS is a standard
baseline attack that takes a single step in the gradient direction to generate the adversarial example.
As originally described, FGS generates untargeted adversarial examples. On MNIST, Goodfellow
et al. (2014) reported that FGS could generate adversarial examples that fooled a maxout network
approximately 90% of the time with = 0.25, where is the magnitude of the perturbation at each
pixel. The L2 optimization method has been shown to generate adversarial examples with smaller
perturbations than any other method published to date, which were capable of fooling the target
network 100% of the time. We consider both targeted attacks and untargeted attacks for the L2
optimization method.8
4.2.2	Adversarial Robustness
There are multiple definitions of adversarial robustness in the literature. The most basic, which we
shall use, is accuracy on adversarially perturbed versions of the test set, called adversarial examples.
It is also important to have a measure of the magnitude of the adversarial perturbation. Since ad-
versaries are defined relative to human perception, the ideal measure would explicitly correspond to
how easily a human observer would notice the perturbation. In lieu of such a measure, it is common
to compute the size of the perturbation using L0, L1, L2, and L∞ norms (Szegedy et al., 2013;
Goodfellow et al., 2014; Carlini & Wagner, 2016; Sabour et al., 2016). In particular, the L0 norm
measures the number of perturbed pixels, the L2 norm measures the Euclidean distance between X
and X0 , and the L∞ norm measures the largest single change to any pixel.
4.2.3	Experimental Setup
We used the same model architectures as in Section 4.1, using a K = 256 bottleneck. The archi-
tectures included a deterministic (base) model trained by MLE; a deterministic model trained with
dropout (the dropout rate was chosen on the validation set); and a stochastic model trained with VIB
for various values of β .
For the VIB models, we use 12 posterior samples of Z to compute the class label distribution p(y|x).
This helps ensure that the adversaries can get a consistent gradient when constructing the perturba-
tion, and that they can get a consistent evaluation when checking if the perturbation was successful
6 There are also other adversaries that don’t fall as cleanly into those categories, such as “fooling im-
ages” from Nguyen et al. (2014), which remove the human perceptual constraint, generating regular geometric
patterns or noise patterns that networks confidently classify as natural images; and the idea of generating ad-
versaries by stochastic search for images near the decision boundary of multiple networks from Baluja et al.
(2015).
7 Sabour et al. (2016) proposes a variant of the targeted attack, A(XS , M, XT , k) → XS0 , where XS is the
source image, XT is a target image, and k is a target layer in the model M. A produces XS0 by minimizing the
difference in activations of M at layer k between XT and XS0 . The end result of this attack for a classification
network is still that M (XS0 ) yields a target label implicitly specified by XT in a successful attack.
8 Carlini & Wagner (2016) shared their code with us, which allowed us to perform the attack with exactly
the same parameters they used for their paper, including the maximum number of iterations and maximum C
value (see their paper for details).
8
Published as a conference paper at ICLR 2017
(i.e., it reduces the chance that the adversary “gets lucky” in its perturbation due to an untypical
sample). We also ran the VIB models in “mean mode”, where the σs are forced to be 0. This had no
noticeable impact on the results, so all reported results are for stochastic evaluation with 12 samples.
4.2.4	MNIST Results and Discussion
We selected the first 10 zeros in the MNIST test set, and use the L2 optimization adversary of Carlini
& Wagner (2016) to try to perturb those zeros into ones.9 Some sample results are shown in Figure
3. We see that the deterministic models are easily fooled by making small perturbations, but for the
VIB models with reasonably large β, the adversary often fails to find an attack (indicated by the
green borders) within the permitted number of iterations. Furthermore, when an attack is succesful,
it needs to be much larger for the VIB models. To quantify this, Figure 4 plots the magnitude of the
perturbation (relative to that of the deterministic and dropout models) needed for a successful attack
as a function of β . As β increases, the L0 norm of the perturbation decreases, but both L2 and L∞
norms increase, indicating that the adversary is being forced to put larger modifications into fewer
pixels while searching for an adversarial perturbation.
Figure 5 plots the accuracy on FGS adversarial examples of the first 1000 images from the MNIST
test set as a function of β . Each point in the plot corresponds to 3 separate executions of three
different models trained with the same value ofβ. All models tested achieve over 98.4% accuracy on
the unperturbed MNIST test set, so there is no appreciable measurement distortion due to underlying
model accuracy.
Figure 6 plots the accuracy on L2 optimization adversarial examples of the first 1000 images from
the MNIST test set as a function of β. The same sets of three models per β were tested three times,
as with the FGS adversarial examples.
We generated both untargeted and targeted adversarial examples for Figure 6. For targeting, we
generate a random target label different from the source label in order to avoid biasing the results
with unevenly explored source/target pairs. We see that for a reasonably broad range of β values,
the VIB models have significantly better accuracy on the adversarial examples than the deterministic
models, which have an accuracy of 0% (the L2 optimization attack is very effective on traditional
model architectures).
Figure 6 also reveals a surprising level of adversarial robustness even when β → 0. This can be
explained by the theoretical framework of Fawzi et al. (2016). Their work proves that quadratic
classifiers (e.g., xT Ax, symmetric A) have a greater capacity for adversarial robustness than linear
classifiers. As we show in Appendix C, our Gaussian/softmax encoder/decoder is approximately
quadratic for all β < ∞.
4.2.5	ImageNet Results and Discussion
VIB improved classification accuracy and adversarial robustness for toy datasets like MNIST. We
now investigate if VIB offers similar advantages for ImageNet, a more challenging natural image
classification. Recall that ImageNet has approximately 1M images spanning 1K classes. We pre-
process images such that they are 299x299 pixels.
Architecture
We make use of publicly available, pretrained checkpoints10 of Inception Resnet V2 (Szegedy et al.,
2016) on ImageNet (Deng et al., 2009). The checkpoint obtains 80.4% classification accuracy on the
ImageNet validation set. Using the checkpoint, we transformed the original training set by applying
the pretrained network to each image and extracting the representation at the penultimate layer.
This new image representation has 1536 dimensions. The higher layers of the network continue to
classify this representation with 80.4% accuracy; conditioned on this extraction the classification
9 We chose this pair of labels since intuitively zeros and ones are the digits that are least similar in terms of
human perception, so if the adversary can change a zero into a one without much human-noticeable perturba-
tion, it is unlikely that the model has learned a representation similar to what humans learn.
10Available at the Tensorflow Models repository in the Slim directory: https://github.com/
tensorflow/models/tree/master/slim
9
Published as a conference paper at ICLR 2017
β = 10-10 β = 10-8 β = 10-6β= 10-4 β = 10-3β= 10-2
0
O
O


-⅛
Q
Q
O
O
O
D
O
O
O
O
O
Figure 3:	The adversary is trying to force each 0 to be classified as a 1. Successful attacks have a red
background. Unsuccessful attacks have a green background. In the case that the label is changed
to an incorrect label different from the target label (i.e., the classifier outputs something other than
0 or 1), the background is purple. The first column is the original image. The second column is
adversarial examples targeting our deterministic baseline model. The third column is adversarial
examples targeting our dropout model. The remaining columns are adversarial examples targeting
our VIB models for different β .
IO11 IO10 10^9	10^e IO7 10^6	10^5	10^4	10^3	10^2
β
(a)
Dropout Model L*
IO11 10^w	10^9	10^e IO7 10^6	10^5	10^4	10^3	10^2
β
(b)
Figure 4:	(a) Relative magnitude of the adversarial perturbation, measured using L0, L2 , and L∞
norms, for the images in Figure 3 as a function of β. (We normalize all values by the corresponding
norm of the perturbation against the base model.) As β increases, L0 decreases, but both L2 and L∞
increase, indicating that the adversary is being forced to put larger modifications into fewer pixels
while searching for an adversarial perturbation. (b) Same as (a), but with the dropout model as the
baseline. Dropout is more robust to the adversarial perturbations than the base deterministic model,
but still performs much worse than the VIB model as β increases.
10
Published as a conference paper at ICLR 2017
s3-dujex 山-OTɪOTeφ⅞< UO AUeJrOUqφ>4eφa:
10
Deterministic Model
FGS, epsilon=O.35O
FGS, epsilon=0.4OO
FGS, epsilon =0.450
FGS, epsilon =0.500
IO-7
IOY
β
sφ-dtuex 山m∙cesJφAP4 co φ>4eφα:
IO-7
IO-3 10^2 IO1
IO1
(a)	(b)
Figure 5:	Classification accuracy of VIB classifiers, divided by accuracy of baseline classifiers, on
FGS-generated adversarial examples as a function of β. Higher is better, and the baseline is always
at 1.0. For the FGS adversarial examples, when β = 0 (not shown), the VIB model’s performance is
almost identical to when β = 10-8. (a) FGS accuracy normalized by the base deterministic model
performance. The base deterministic model’s accuracy on the adversarial examples ranges from
about 1% when = 0.5 to about 5% when = 0.35. (b) Same as (a), but with the dropout model
as the baseline. The dropout model is more robust than the base model, but less robust than VIB,
particularly for stronger adversaries (i.e., larger values of ). The dropout model’s accuracy on the
adversarial examples ranges from about 5% when = 0.5 to about 16% when = 0.35. As in
the other results, relative performance is more dramatic as β increases, which seems to indicate that
the VIB models are learning to ignore more of the perturbations caused by the FGS method, even
though they were not trained on any adversarial examples.
Figure 6: Classification accuracy (from 0 to 1) on L2 adversarial examples (of all classes) as a
function of β. The blue line is for targeted attacks, and the green line is for untargeted attacks
(which are easier to resist). In this case, β = 10-11 has performance indistinguishable from β = 0.
The deterministic model and dropout model both have a classification accuracy of 0% in both the
targeted and untargeted attack scenarios, indicated by the horizontal red dashed line at the bottom of
the plot. This is the same accuracy on adversarial examples from this adversary reported in Carlini
& Wagner (2016) on a convolutional network trained on MNIST.
11
Published as a conference paper at ICLR 2017
(a)	(b)
(c)	(d)
Figure 7: The results of our ImageNet targeted L2 optimization attack. In all cases we target a
new label of 222 (“soccer ball”). Figure (a) shows the 30 images from the first 40 images in the
ImageNet validation set that the VIB network classifies correctly. The class label is shown in green
on each image. The predicted label and targeted label are shown in red. Figure (b) shows adversarial
examples of the same images generated by attacking our VIB network with β = 0.01. While all
of the attacks change the classification of the image, in 13 out of 30 examples the attack fails to
hit the intended target class (“soccer ball”). Pink crosses denote cases where the attack failed to
force the model to misclassify the image as a soccer ball. Figure (c) shows the same result but
for our deterministic baseline operating on the whitened precomputed features. The attack always
succceeds. Figure (d) is the same but for the original full Inception ResNet V2 network without
modification. The attack always succceeds. There are slight variations in the set of adversarial
examples shown for each network because we limited the adversarial search to correctly classified
images. In the case of the deterministic baseline and original Inception ResNet V2 network, the
perturbations are hardly noticable in the perturbed images, but in many instances, the perturbations
for the VIB network can be percieved.
12
Published as a conference paper at ICLR 2017
Figure 8: Shown are the absolute differences between the original and final perturbed images for
all three networks. The left block shows the perturbations created while targeting the VIB network.
The middle block shows the perturbations needed for the deterministic baseline using precomputed
whitened features. The right block shows the perturbations created for the unmodified Inception
ResNet V2 network. The contrast has been increased by the same amount in all three columns to
emphasize the difference in the magnitude of the perturbations. The VIB network required much
larger perturbations to confuse the classifier, and even then did not achieve the targeted class in 13
of those cases.
model is simply logistic regression. To further speed training, we whitened the 1536 dimensional
representation.
Under this transformation, the experiment regime is identical to the permutation invariant MNIST
task. We therefore used a similar model architecture. Inputs are passed through two fully connected
layers, each with 1024 units. Next, data is fed to a stochastic encoding layer; this layer is charac-
terized by a spherical Gaussian with 1024 learned means and standard deviations. The output of
the stochastic layer is fed to the variational Classifier-itself a logistic regression, for simplicity. An
other hyperparameters and training choices are identical to those used in MNIST, more details in
Appendix A.
Classification
We see the same favorable VIB classification performance in ImageNet as in MNIST. By varying
β, the estimated mutual information between encoding and image (I (Z, X)) varies as well. At large
values of β accuracy suffers, but at intermediate values we obtain improved performance over both
a deterministic baseline and a β = 0 regime. In all cases our accuracy is somewhat lower than
the original 80.4% accuracy. This may be a consequence of inadequate training time or suboptimal
hyperparameters.
Overall the best accuracy we achieved was using β = 0.01. Under this setting we saw an accu-
racy of 80.12%-nearly the same as the state-of-the-art unmodified network- but with substantially
smaller information footprint, only I(X, Z)〜45 bits. This is a surprisingly small amount of infor-
mation; β = 0 implies over 10,000 bits yet only reaches an accuracy of 78.87%. The deterministic
baseline, which was the same network, but without the VIB loss and a 1024 fully connected lin-
ear layer instead of the stochastic embedding similarly only achieved 78.75% accuracy. We stress
that regressions from the achievable 80.4% are likely due to suboptimal hyperparameters settings or
inadequate training.
Considering a continuum of β and a deterministic baseline, the best classification accuracy was
achieved with a β = 0.01 ∈ (0, 1). In other words, VIB offered accuracy benefit yet using a mere
〜45 bits of information from each image.
13
Published as a conference paper at ICLR 2017
Adversarial Robustness
We next show that the VIB-trained network improves resistance to adversarial attack.
We focus on the Carlini targeted L2 attack (see Section 4.2.1). We show results for the VIB-trained
network and a deterministic baseline (both on top of precomputed features), as well as for the origi-
nal pretrained Inception ResNet V2 network itself. The VIB network is more robust to the targeted
L2 optimization attack in both magnitude of perturbation and frequency of successful attack.
Figure 7 shows some example images which were all misclassified as “soccer balls” by the deter-
ministic models; by contrast, with the VIB model, only 17 out of 30 of the attacks succeeded in
being mislabeled as the target label.11 We find that the VIB model can resist about 43.3% of the
attacks, but the deterministic models always fail (i.e., always misclassify into the targeted label).
Figure 8 shows the absolute pixel differences between the perturbed and unperturbed images for the
examples in Figure 7. We see that the VIB network requires much larger perturbations in order to
fool the classifier, as quantified in Table 2.
Metric	Determ	IRv2	VIB(0.01)
Sucessful target	ɪθ	ɪθ-	0.567
L2	6.45	14.43	43.27
L∞	0.18	0.44	0.92
Table 2: Quantitative results showing how the different Inception Resnet V2-based architectures
(described in Section 4.2.5) respond to targeted L2 adversarial examples. Determ is the deterministic
architecture, IRv2 is the unmodified Inception Resnet V2 architecture, and VIB(0.01) is the VIB
architecture with β = 0.01. Successful target is the fraction of adversarial examples that caused
the architecture to classify as the target class (soccer ball). Lower is better. L2 and L∞ are the
average L distances between the original images and the adversarial examples. Larger values mean
the adversary had to make a larger perturbation to change the class.
5 Future Directions
There are many possible directions for future work, including: putting the VIB objective at multiple
or every layer of a network; testing on real images; using richer parametric marginal approxima-
tions, rather than assuming r(z) = N(0, I); exploring the connections to differential privacy (see
e.g., Wang et al. (2016a); Cuff & Yu (2016)); and investigating open universe classification problems
(see e.g., Bendale & Boult (2015)). In addition, we would like to explore applications to sequence
prediction, where X denotes the past of the sequence and Y the future, while Z is the current repre-
sentation of the network. This form of the information bottleneck is known as predictive information
(Bialek et al., 2001; Palmer et al., 2015).
References
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S
Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, et al. Tensorflow: Large-scale machine
learning on heterogeneous distributed systems. arXiv preprint arXiv:1603.04467, 2016.
David Barber Felix Agakov. The IM algorithm: a variational approach to information maximization.
In NIPS, volume 16, 2004.
Shumeet Baluja, Michele Covell, and Rahul Sukthankar. The virtues of peer pressure: A simple
method for discovering high-value mistakes. In Intl. Conf. Computer Analysis of Images and
Patterns, 2015.
Abhijit Bendale and Terrance Boult. Towards open world recognition. In CVPR, 2015.
11 The attacks still often cause the VIB model to misclassify the image, but not to the targeted label. This is
a form of “partial” robustness, in that an attacker will have a harder time hitting the target class, but can still
disrupt correct function of the network.
14
Published as a conference paper at ICLR 2017
William Bialek, Ilya Nemenman, and Naftali Tishby. Predictability, complexity, and learning. Neu-
ral computation, 13(11):2409-2463, 2001.
Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in
neural networks. In ICML, 2015.
Ryan P. Browne and Paul D. McNicholas. Multivariate sharp quadratic bounds via Σ-strong con-
vexity and the fenchel connection. Electronic Journal of Statistics, 9, 2015.
Nicholas Carlini and David Wagner. Towards evaluating the robustness of neural networks. Arxiv,
2016.
Matthew Chalk, Olivier Marre, and Gasper Tkacik. Relevant sparse codes with variational informa-
tion bottleneck. In NIPS, 2016.
G. Chechik, A Globersonand N. Tishby, and Y. Weiss. Information bottleneck for gaussian variables.
J. of Machine Learning Research, 6:165188, 2005.
Paul Cuff and Lanqing Yu. Differential privacy as a mutual information constraint. In ACM Confer-
ence on Computer and Communications Security (CCS), 2016.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale
hierarchical image database. In Computer Vision and Pattern Recognition, 2009. CVPR 2009.
IEEE Conference on, pp. 248-255. IEEE, 2009.
Alhussein Fawzi, Seyed-Mohsen Moosavi-Dezfooli, and Pascal Frossard. Robustness of classifiers:
from adversarial to random noise. In NIPS, 2016.
Xavier Glorot and Yoshua Bengio. Understanding the difficulty of training deep feedforward neural
networks. In AI/Statistics, volume 9, pp. 249-256, 2010.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. In ICLR, 2015.
Irina Higgins, Loic Matthey, Arka Pal, Christopher Burgess, Xavier Glorot, Matthew Botvinick,
Shakir Mohamed, and Alexander Lerchner. beta-VAE: Learning basic visual concepts with a
constrained variational framework. In ICLR, 2017. URL https://openreview.net/pdf?
id=Sy2fzU9gl.
RUitong Huang, Bing Xu, Dale Schuurmans, and Csaba Szepesvari. Learning with a strong adver-
sary. CoRR, abs/1511.03034, 2015.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.
Diederik P Kingma and Max Welling. Auto-encoding variational Bayes. In ICLR, 2014.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial examples in the physical world. In
ICLR Workshop, 2017. URL https://openreview.net/pdf?id=S1OufnIlx.
Christos Louizos, Kevin Swersky, Yujia Li, Max Welling, and Richard Zemel. The variational fair
autoencoder. In ICLR, 2016. URL http://arxiv.org/abs/1511.00830.
David JC MacKay. Information theory, inference and learning algorithms. Cambridge university
press, 2003.
Shakir Mohamed and Danilo Jimenez Rezende. Variational information maximisation for intrinsi-
cally motivated reinforcement learning. In NIPS, pp. 2125-2133, 2015.
Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, Omar Fawzi, and Pascal Frossard. Universal
adversarial perturbations. Arxiv, 2016.
Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, and Pascal Frossard. Deepfool: a simple and
accurate method to fool deep neural networks. In CVPR, 2016.
15
Published as a conference paper at ICLR 2017
Anh Nguyen, Jason Yosinski, and Jeff Clune. Deep neural networks are easily fooled: High con-
fidence predictions for unrecognizable images. In CVPR, 2015. URL http://arxiv.org/
abs/1412.1897.
Stephanie E Palmer, Olivier Marre, Michael J Berry, and William Bialek. Predictive information in
a sensory population. PNAS, 112(22):6908-6913, 2015.
Nicolas Papernot, Patrick McDaniel, Somesh Jha, Matt Fredrikson, Z Berkay Celik, and Ananthram
Swami. The limitations of deep learning in adversarial settings. In Proceedings of the 1st IEEE
European Symposium on Security and Privacy, 2015.
Gabriel Pereyra, George Tuckery, Jan Chorowski, and Lukasz Kaiser. Regularizing neural net-
works by penalizing confident output predictions. In ICLR Workshop, 2017. URL https:
//openreview.net/pdf?id=HyhbYrGYe.
Boris T Polyak and Anatoli B Juditsky. Acceleration of stochastic approximation by averaging.
SIAM Journal on Control and Optimization, 30(4):838-855, 1992.
Leigh Robinson and Benjamin Graham. Confusing deep convolution networks by relabelling. arXiv
preprint 1510.06925, 2015.
Sara Sabour, Yanshuai Cao, Fartash Faghri, and David J Fleet. Adversarial manipulation of deep
representations. In ICLR, 2016.
Noam Slonim, GUrinder Singh AtWaL GasPer Tkacik, and William Bialek. Information-based ClUs-
tering. PNAS, 102(51):18297-18302, 2005.
Christian Szegedy, Wojciech Zaremba, Ilya SUtskever, Joan BrUna, DUmitrU Erhan, Ian GoodfelloW,
and Rob FergUs. IntrigUing properties of neUral netWorks. In ICLR, 2014. URL http://
arxiv.org/abs/1312.6199.
Christian Szegedy, Sergey Ioffe, Vincent VanhoUcke, and Alex Alemi. Inception-v4, inception-
resnet and the impact of residUal connections on learning. arXiv preprint arXiv:1602.07261,
2016.
N Tishby and N Zaslavsky. Deep learning and the information bottleneck principle. In IEEE Infor-
mation Theory Workshop, pp. 1-5, April 2015a.
N. Tishby, F.C. Pereira, and W. Biale. The information bottleneck method. In The 37th annual
Allerton Conf. on Communication, Control, and Computing, pp. 368-377, 1999.
Naftali Tishby and Noga Zaslavsky. Deep learning and the information bottleneck principle. In
Information Theory Workshop (ITW), 2015 IEEE, pp. 1-5. IEEE, 2015b.
Weina Wang, Lei Ying, and JUnshan Zhang. On the relation betWeen identifiability, differential
privacy and MUtUal-Information privacy. IEEE Trans. Inf. Theory, 62:5018-5029, 2016a.
Weiran Wang, Honglak Lee, and Karen LivescU. Deep variational canonical correlation analysis.
arXiv [cs.LG], 11 October 2016b. URL https://arxiv.org/abs/1610.03454.
16
Published as a conference paper at ICLR 2017
A Hyperparameters and Architecture Details for Experiments
All of the networks for this paper were trained using TensorFlow (Abadi et al., 2016). All weights
were initialized using the default TensorFlow Xavier initialization scheme (Glorot & Bengio, 2010)
using the averaging fan scaling factor on uniform noise. All biases were initialized to zero. The
Adam optimizer (Kingma & Ba, 2015) was used with initial learning rate of 10-4, (β1 = 0.5, β2 =
0.999) and exponential decay, decaying the learning rate by a factor of 0.97 every 2 epochs. The
networks were all trained for 200 epochs total. For the MNIST experiments, a batch size of 100
was used, and the full 60,000 training and validation set was used for training, and the 10,000 test
images for test results. The input images were scaled to have values between -1 and 1 before fed to
the network.
All runs maintained an exponential weighted average of the parameters during the training run;
these averaged parameters were used at test time. This is in the style of Polyak averaging Polyak &
Juditsky (1992), with a decay constant of 0.999. Our estimate of mutual informations were measured
in bits. For the VIB experiments in all sections, no other form of regularization was used.
For the 256 dimensional gaussian embeddings of Section 4.1.1, a linear layer of size 512 was used
to create the 256 mean values and standard deviations for the embedding. The standard deviations
were made to be positive by a softplus transformation with a bias of -5.0 to have them initially be
small.
σ = log (1 + exp(x - 5.0))
(19)
For the 1024 dimensional Imagenet embeddings of Section 4.2.5, a sigma bias of 0.57 was used to
keep the initial standard deviations near 1 originally, and a batch size of 200 was used.
For the 2 dimensional gaussian embeddings of Section 4.1.2, a linear layer was used with 2+4 = 6
outputs, the first two of which were used for the means, and the other 4 were reshaped to a 2 × 2
matrix, the center was transformed according to a softplus with a bias of -5.0, and the off diagonal
components were multiplied by 10-2, while the upper triangular element was dropped to form the
Cholesky decomposition of the covariance matrix.
B Connection to Variational Autoencoders
We can also consider unsupervised versions of the information bottleneck objective. Consider the
objective:
maxI(Z,X) -βI(Z,i),	(20)
similar to the information theoretic objective for clustering introduced in Slonim et al. (2005).
Here the aim is to take our data X and maximize the mutual information contained in some encoding
Z , while restricting how much information we allow our representation to contain about the identity
of each data element in our sample (i). We will form a bound much like we did in the main text.
For the first term, we form a variational decoder q(x|z) and take a bound:
I(Z, X) = d dx dzp(x, z) log p(xlz)
p(x)
=H(x)+Zdzp(x)Zdxp(x|z)logp(x|z)
≥	dz p(x)	dxp(x|z) log q(x|z)
=	dx p(x) dzp(x|z) log q(x|z).
(21)
(22)
(23)
(24)
Here we have dropped the entropy in our data H(X) because it is out of our control and we have
used the nonnegativity of the Kullbach-Leibler divergence to replace our intractable p(x|z) with a
variational decoder q(x|z).
17
Published as a conference paper at ICLR 2017
Turning our attention to the second term, note that:
p(z∣i) = J dxp(z∣x)p(x∣i) = J dxp(z∣x)δ(x — Xi)= p(z∣Xi),
and that We will take p(i) = N.
So that we can bound our second term from above
I (Zi)=X Z dzp(ZIi)P⑶log ⅛f
=NN X Z dzp(z ιxi)log ρ(zχ)
≤ N XZ dzp(z ιxi)log ρ(zxi),
(25)
(26)
(27)
(28)
Where we have replaced the intractable marginalp(z) with a variational marginal (z).
Putting these two bounds together we have that our unsupervised information bottleneck objective
takes the form
I(Z, X) — βI(Z, i) ≤	dx p(x) / dz p(z |x) log q(x|z) — βNN XKL[p(Z∣Xi),r(Z)]. (29)
And this takes the form of a variational autoencoder (Kingma & Welling, 2014), except with the
second KL divergence term having an arbitrary weight β.
It is interesting that while this objective takes the same mathematical form as that of a Variational
Autoencoder, the interpretation of the objective is very different. In the VAE, the model starts life as
a generative model with a defined priorp(z) and stochastic decoder p(x|z) as part of the model, and
the encoder q(z|x) is created to serve as a variational approximation to the true posterior p(z|x) =
p(x|z)p(z)/p(x). In the VIB approach, the model is originally just the stochastic encoder p(z|x),
and the decoder q(x|z) is the variational approximation to the true p(x|z) = p(z|x)p(x)/p(z) and
r(z) is the variational approximation to the marginal p(z) = dx p(x)p(z|x). This difference in
interpretation makes natural suggestions for novel directions for improvement.
This precise setup, albeit with a different motivation was recently explored in Higgins et al. (2016),
where they demonstrated that by changing the weight of the variational autoencoders regularization
term, there were able to achieve latent representations that were more capable when it came ot zero-
shot learning and understanding ”objectness”. In that work, they motivated their choice to change
the relative weightings of the terms in the objective by appealing to notions in neuroscience. Here
we demonstrate that appealing to the information bottleneck objective gives a principled motivation
and could open the door to better understanding the optimal choice of β and more tools for accessing
the importance and tradeoff of both terms.
Beyond the connection to existing variational autoencoder techniques, we note that the unsupervised
information bottleneck objective suggests new directions to explore, including targetting the exact
marginal p(z) in the regularization term, as well as the opportunity to explore tighter bounds on the
first I(Z, X) term that may not require explicit variational reconstruction.
C Quadratic bounds for stochastic logistic regression decoder
Consider the special case when the bottleneck Z is a multivariate Normal, i.e., z∣χ 〜 N(μχ, Σχ)
where Σχ is a K X K positive definite matrix. The parameters μχ, Σχ can be constructed from a
deep neural network, e.g.,
μx = γ1:K (X)
chol(Σχ) = diag(log(1+exp(γκ+L2κ))) +subtril(γ2κ+土κ(κ+3)∕2),
where γ(X) ∈ RK(K+3)/2 is the network output of input X.
18
Published as a conference paper at ICLR 2017
Suppose that the prediction is a categorical distribution computed as S(Wz) where W is a
C × K weight matrix and log S (x) = x - lse(x) is the log-soft-max function with lse(x) =
log PkK=1 exp(xk ) being the log-sum-exp function.
This setup (which is identical to our experiments) induces a classifier which is bounded by a
quadratic function, which is interesting because the theoretical framework Fawzi et al. (2016) proves
that quadratic classifiers have greater capacity for adversarial robustness than linear functions.
We now derive an approximate bound using second order Taylor series expansion (TSE). The bound
can be made proper via Browne & McNicholas (2015). However, using the TSE is sufficient to
sketch the derivation.
Jensen’s inequality implies that the negative log-likelihood soft-max is upper bounded by:
-log E [S(WZ)∣μχ, Σχ] ≤ - E [logS(WZ)∣μχ, Σχ]
=-Wμx + E [lse(WZ)∣μχ, Σχ]
=-Wμx + E [lse(Z)∣Wμχ,WΣχ].
The second order Taylor series expansion (TSE) of lse is given by,
lse(x + δ) ≈ lse(x) + δτ S(x) + 1 δτ [diag(S(x)) — S(X)S(X)Ti δ.
Taking the expectation of the TSE at the mean yields,
EN (0,W ΣχWT )[ lse(Wμx + δ)] ≈ lse(WμX) + EN (0,W ∑χWT )[δT]S (Wμx) +
+ 1 EN(0,WΣxWT)[δThdiag(S(WμX))- S(Wμx)S(WμX)Ti δ]
=lse(Wμχ) + 2 tr(WΣχWThdiag(S(Wμχ)) - S(Wμχ)S(Wμχ)T ])
=lse(Wμχ) + 2 tr(WΣχWT diag(S(Wμχ))) - 1S(Wμχ)T WΣχWT S(Wμχ)
=lse(Wμχ) + 2 PS(Wμχ)T WΣχWT PS(W〃x) - 2S(Wμχ)T WΣχWT S(Wμχ)
The second-moment was calculated by noting,
E[XT BX] = E tr(XXT B) =tr(E[XXT]B) = tr(ΣB).
Putting this altogether, we conclude,
E [S(WZ)∣μχ, Σχ] ' S(Wμχ)exp (-2 √S(WμjT W∑χWT PS(W〃x) + ɪS(Wμχ)T WΣχWT S(W〃x)).
As indicated, rather than approximate the lse via TSE, we can make a sharp, quadratic upper bound
via BroWne & McNicholas (2015). However this merely changes the S(Wμχ) scaling in the expo-
nential; the result is still log-quadratic.
19