Published as a conference paper at ICLR 2017
Sample Efficient Actor-Critic with
Experience Replay
Ziyu Wang
DeepMind
ziyu@google.com
Volodymyr Mnih
DeepMind
vmnih@google.com
Victor Bapst
DeepMind
vbapst@google.com
Remi Munos
DeepMind
Munos@google.com
Nicolas Heess
DeepMind
heess@google.com
Koray Kavukcuoglu
DeepMind
korayk@google.com
Nando de Freitas
DeepMind, CIFAR, Oxford University
nandodefreitas@google.com
Ab stract
This paper presents an actor-critic deep reinforcement learning agent with ex-
perience replay that is stable, sample efficient, and performs remarkably well on
challenging environments, including the discrete 57-game Atari domain and several
continuous control problems. To achieve this, the paper introduces several inno-
vations, including truncated importance sampling with bias correction, stochastic
dueling network architectures, and a new trust region policy optimization method.
1	Introduction
Realistic simulated environments, where agents can be trained to learn a large repertoire of cognitive
skills, are at the core of recent breakthroughs in AI (Bellemare et al., 2013; Mnih et al., 2015;
Schulman et al., 2015a; Narasimhan et al., 2015; Mnih et al., 2016; Brockman et al., 2016; Oh
et al., 2016). With richer realistic environments, the capabilities of our agents have increased and
improved. Unfortunately, these advances have been accompanied by a substantial increase in the cost
of simulation. In particular, every time an agent acts upon the environment, an expensive simulation
step is conducted. Thus to reduce the cost of simulation, we need to reduce the number of simulation
steps (i.e. samples of the environment). This need for sample efficiency is even more compelling
when agents are deployed in the real world.
Experience replay (Lin, 1992) has gained popularity in deep Q-learning (Mnih et al., 2015; Schaul
et al., 2016; Wang et al., 2016; Narasimhan et al., 2015), where it is often motivated as a technique
for reducing sample correlation. Replay is actually a valuable tool for improving sample efficiency
and, as we will see in our experiments, state-of-the-art deep Q-learning methods (Schaul et al., 2016;
Wang et al., 2016) have been up to this point the most sample efficient techniques on Atari by a
significant margin. However, we need to do better than deep Q-learning, because it has two important
limitations. First, the deterministic nature of the optimal policy limits its use in adversarial domains.
Second, finding the greedy action with respect to the Q function is costly for large action spaces.
Policy gradient methods have been at the heart of significant advances in AI and robotics (Silver et al.,
2014; Lillicrap et al., 2015; Silver et al., 2016; Levine et al., 2015; Mnih et al., 2016; Schulman et al.,
2015a; Heess et al., 2015). Many of these methods are restricted to continuous domains or to very
specific tasks such as playing Go. The existing variants applicable to both continuous and discrete
domains, such as the on-policy asynchronous advantage actor critic (A3C) of Mnih et al. (2016), are
sample inefficient.
The design of stable, sample efficient actor critic methods that apply to both continuous and discrete
action spaces has been a long-standing hurdle of reinforcement learning (RL). We believe this paper
1
Published as a conference paper at ICLR 2017
is the first to address this challenge successfully at scale. More specifically, we introduce an actor
critic with experience replay (ACER) that nearly matches the state-of-the-art performance of deep
Q-networks with prioritized replay on Atari, and substantially outperforms A3C in terms of sample
efficiency on both Atari and continuous control domains.
ACER capitalizes on recent advances in deep neural networks, variance reduction techniques, the
off-policy Retrace algorithm (Munos et al., 2016) and parallel training of RL agents (Mnih et al.,
2016). Yet, crucially, its success hinges on innovations advanced in this paper: truncated importance
sampling with bias correction, stochastic dueling network architectures, and efficient trust region
policy optimization.
On the theoretical front, the paper proves that the Retrace operator can be rewritten from our proposed
truncated importance sampling with bias correction technique.
2	Background and Problem Setup
Consider an agent interacting with its environment over discrete time steps. At time step t, the agent
observes the nx-dimensional state vector xt ∈ X ⊆ Rnx, chooses an action at according to a policy
∏(a∣χt) and observes a reward signal r ∈ R produced by the environment. We will consider discrete
actions at ∈ {1, 2, . . . , Na} in Sections 3 and 4, and continuous actions at ∈ A ⊆ Rna in Section 5.
The goal of the agent is to maximize the discounted return Rt = Pi≥0 γirt+i in expectation. The
discount factor γ ∈ [0, 1) trades-off the importance of immediate and future rewards. For an agent
following policy π, we use the standard definitions of the state-action and state only value functions:
Qn (Xt, at) = Ext+L∞,at+L∞ [ RtI xt, at]	and	V ∏ (Xt)= Eat [Q∏ (xt, at)|xt] .
Here, the expectations are with respect to the observed environment states xt and the actions generated
by the policy ∏, where χt+1：∞ denotes a state trajectory starting at time t + 1.
We also need to define the advantage function Aπ(Xt, at) = Qπ(Xt, at) - Vπ(Xt), which provides a
relative measure of value of each action since Eat [Aπ (Xt, at)] = 0.
The parameters θ of the differentiable policy ∏θ(at|xt) can be updated using the discounted approxi-
mation to the policy gradient (Sutton et al., 2000), which borrowing notation from Schulman et al.
(2015b), is defined as:
g = Exo：8,ao：8
EAn (Xt ,at )Vθ log ∏θ (at∣xt)
t≥0
(1)
Following Proposition 1 of Schulman et al. (2015b), we can replace Aπ(Xt, at) in the above expression
with the state-action value Qπ(Xt, at), the discounted return Rt, or the temporal difference residual
rt + γVπ(Xt+1) - Vπ(Xt), without introducing bias. These choices will however have different
variance. Moreover, in practice we will approximate these quantities with neural networks thus
introducing additional approximation errors and biases. Typically, the policy gradient estimator using
Rt will have higher variance and lower bias whereas the estimators using function approximation will
have higher bias and lower variance. Combining Rt with the current value function approximation
to minimize bias while maintaining bounded variance is one of the central design principles behind
ACER.
To trade-off bias and variance, the asynchronous advantage actor critic (A3C) of Mnih et al. (2016)
uses a single trajectory sample to obtain the following gradient approximation:
1
gba3c =
Yirt+i + YkVn (xt+k) - Vn (xt) Vθ log∏θ(at∣Xt).
(2)
t≥0
A3C combines both k-step returns and function approximation to trade-off variance and bias. We
may think of Vθnv (Xt) as a policy gradient baseline used to reduce variance.
In the following section, we will introduce the discrete-action version of ACER. ACER may be
understood as the off-policy counterpart of the A3C method of Mnih et al. (2016). As such, ACER
builds on all the engineering innovations of A3C, including efficient parallel CPU computation.
2
Published as a conference paper at ICLR 2017
ACER uses a single deep neural network to estimate the policy ∏θ(at∣χt) and the value function
Vθπv (xt). (For clarity and generality, we are using two different symbols to denote the parameters of
the policy and value function, θ and θv , but most of these parameters are shared in the single neural
network.) Our neural networks, though building on the networks used in A3C, will introduce several
modifications and new modules.
3	Discrete Actor Critic with Experience Replay
Off-policy learning with experience replay may appear to be an obvious strategy for improving
the sample efficiency of actor-critics. However, controlling the variance and stability of off-policy
estimators is notoriously hard. Importance sampling is one of the most popular approaches for off-
policy learning (Meuleau et al., 2000; Jie & Abbeel, 2010; Levine & Koltun, 2013). In our context, it
proceeds as follows. Suppose we retrieve a trajectory {xo, ao, ro, μ(∙∣x0),…，Xk ,a*, rk, μ(∙∣xk)},
where the actions have been sampled according to the behavior policy μ, from our memory of
experiences. Then, the importance weighted policy gradient is given by:
k	kk
YPt) X I Xγirt+i ) Vθlog∏θ(αt∣Xt),	⑶
t=0 t=0 i=0
where Pt = ；(：；||：；) denotes the importance weight. This estimator is unbiased, but it suffers from
very high variance as it involves a product of many potentially unbounded importance weights. To
prevent the product of importance weights from exploding, WaWrzynSki (2009) truncates this product.
Truncated importance sampling over entire trajectories, although bounded in variance, could suffer
from significant bias.
Recently, Degris et al. (2012) attacked this problem by using marginal value functions over the
limiting distribution of the process to yield the following approximation of the gradient:
gmarg = Ext〜β,at〜μ [ρtVθ log∏θ(αt∣xt)Qπ(xt,αt)],	(4)
where Ext〜e&〜μ[∙] is the expectation with respect to the limiting distribution β(x) =
limt→∞ P(Xt = x∣xo,μ) with behavior policy μ. To keep the notation succinct, we will replace
Ext〜β,at〜μ[∙] with ExtatH and ensure we remind readers of this when necessary.
Two important facts about equation (4) must be highlighted. First, note that it depends on Qπ and
not on Qμ, consequently we must be able to estimate Qπ. Second, we no longer have a product of
importance weights, but instead only need to estimate the marginal importance weight Pt . Importance
sampling in this lower dimensional space (over marginals as opposed to trajectories) is expected to
exhibit lower variance.
Degris et al. (2012) estimate Qπ in equation (4) using lambda returns: Rtλ = rt + (1 - λ)γV (Xt+1) +
λγPt+1Rtλ+1. This estimator requires that we know how to choose λ ahead of time to trade off
bias and variance. Moreover, when using small values of λ to reduce variance, occasional large
importance weights can still cause instability.
In the following subsection, we adopt the Retrace algorithm of Munos et al. (2016) to estimate Qπ .
Subsequently, we propose an importance weight truncation technique to improve the stability of the
off-policy actor critic of Degris et al. (2012), and introduce a computationally efficient trust region
scheme for policy optimization. The formulation of ACER for continuous action spaces will require
further innovations that are advanced in Section 5.
3.1	Multi-Step Estimation of the State-Action Value Function
In this paper, we estimate Qπ(Xt, at) using Retrace (Munos et al., 2016). (We also experimented
with the related tree backup method of Precup et al. (2000) but found Retrace to perform better in
practice.) Given a trajectory generated under the behavior policy μ, the Retrace estimator can be
expressed recursively as follows1:
Qret(Xt,at)=rt + Yρt+ι[Qret(Xt+ι, at+1)- Q(Xt+1, at+1)]+ YV(Xt+1),	(5)
1For ease of presentation, we consider only λ = 1 for Retrace.
3
Published as a conference paper at ICLR 2017
where Pt is the truncated importance weight, Pt = min {c,ρt} with Pt = 1(：；||：；), Q is the current
value estimate of Qn, and V(x) = Ea〜∏Q(χ, a). Retrace is an off-policy, return-based algorithm
which has low variance and is proven to converge (in the tabular case) to the value function of the
target policy for any behavior policy, see Munos et al. (2016).
The recursive Retrace equation depends on the estimate Q. To compute it, in discrete action spaces,
we adopt a convolutional neural network with “two heads” that outputs the estimate Qθv (xt, at), as
well as the policy ∏θ(at∣χt). This neural representation is the same as in (Mnih et al., 2016), with the
exception that we output the vector Qθv (xt, at) instead of the scalar Vθv (xt). The estimate Vθv (xt)
can be easily derived by taking the expectation of Qθv under πθ .
To approximate the policy gradient gmarg, ACER uses Qret to estimate Qπ . As Retrace uses multi-
step returns, it can significantly reduce bias in the estimation of the policy gradient 2.
To learn the critic Qθv (xt, at), we again use Qret(xt, at) as a target in a mean squared error loss and
update its parameters θv with the following standard gradient:
(Q	(Xt, at) - Qθv (Xt, at))^θv Qθv (xt, at))∙	(6)
Because Retrace is return-based, it also enables faster learning of the critic. Thus the purpose of the
multi-step estimator Qret in our setting is twofold: to reduce bias in the policy gradient, and to enable
faster learning of the critic, hence further reducing bias.
3.2	Importance Weight Truncation with Bias Correction
The marginal importance weights in Equation (4) can become large, thus causing instability. To
safe-guard against high variance, we propose to truncate the importance weights and introduce a
correction term via the following decomposition of gmarg:
gmarg
=Extat [ρt Vθlog ∏θ (at∣Xt)Qπ (xt,at)]
=Ext Eat[ptVθlog∏θ(at∣xt)Qπ(xt,at)]+ E
a〜π
(Pt(a) - C^
U Pt(a) _
Vθlog ∏θ (a|xt )Qπ (xt, a)
,(7)
where Pt = min {c,Pt} with Pt
∏(at∣xt)
μ(at∣xt)
as before.
We have also introduced the notation
Pt (a) = [(al：；), and [x]+ = X if x > 0 and it is zero otherwise. We remind readers that the above
expectations are with respect to the limiting state distribution under the behavior policy: Xt 〜β and
at 〜μ.
The clipping of the importance weight in the first term of equation (7) ensures that the variance of
the gradient estimate is bounded. The correction term (second term in equation (7)) ensures that our
estimate is unbiased. Note that the correction term is only active for actions such that Pt(a) > c.
In particular, if we choose a large value for c, the correction term only comes into effect when the
variance of the original off-policy estimator of equation (4) is very high. When this happens, our
decomposition has the nice property that the truncated weight in the first term is at most c while the
∣^ PMa)-Cl
[Pt(a) + +
correction weight
in the second term is at most 1.
We model Qπ(xt, a) in the correction term with our neural network approximation Qθv (xt, at). This
modification results in what we call the truncation with bias correction trick, in this case applied to
the function Vθ log∏θ(at∣xt)Qπ(xt, at):
bmarg = Ext Ea；[PtVθlog∏θ(at∣xt)Qret(xt, at)〕+En
([Pt(a) - C-
U Pt(a) .
V ©log ∏θ (a∣χt)Qθv (xt, a)
∙(8)
Equation (8) involves an expectation over the stationary distribution of the Markov process. We
can however approximate it by sampling trajectories {xo, ao, ro, μ(∙∣xo), .…，Xk,ak,rk, μ(∙∣xk)}
2An alternative to Retrace here is Q(λ) with off-policy corrections (Harutyunyan et al., 2016) which we
discuss in more detail in Appendix B.
4
Published as a conference paper at ICLR 2017
generated from the behavior policy μ. Here the terms μ(∙∣χt) are the policy vectors. Given these
trajectories, we can compute the off-policy ACER gradient:
gacer = PNe log ∏θ(at∣Xt)[Qret(xt,at) - %v(xt)]
+ E I [Pt(a) - c Ve log ∏θ (a|xt )[Qθv (xt,a)-¾ (xt)] ) .	(9)
a 〜叭 L Pt(G J+	)
In the above expression, we have subtracted the classical baseline Vev (xt) to reduce variance.
It is interesting to note that, when c = ∞, (9) recovers (off-policy) policy gradient up to the use
of Retrace. When c = 0, (9) recovers an actor critic update that depends entirely on Q estimates.
In the continuous control domain, (9) also generalizes Stochastic Value Gradients if c = 0 and the
reparametrization trick is used to estimate its second term (Heess et al., 2015).
3.3	Efficient Trust Region Policy Optimization
The policy updates of actor-critic methods do often exhibit high variance. Hence, to ensure stability,
we must limit the per-step changes to the policy. Simply using smaller learning rates is insufficient
as they cannot guard against the occasional large updates while maintaining a desired learning
speed. Trust Region Policy Optimization (TRPO) (Schulman et al., 2015a) provides a more adequate
solution.
Schulman et al. (2015a) approximately limit the difference between the updated policy and the
current policy to ensure safety. Despite the effectiveness of their TRPO method, it requires repeated
computation of Fisher-vector products for each update. This can prove to be prohibitively expensive
in large domains.
In this section we introduce a new trust region policy optimization method that scales well to large
problems. Instead of constraining the updated policy to be close to the current policy (as in TRPO),
we propose to maintain an average policy network that represents a running average of past policies
and forces the updated policy to not deviate far from this average.
We decompose our policy network in two parts: a distribution f , and a deep neural network that gen-
erates the statistics φe(x) of this distribution. That is, given f, the policy is completely characterized
by the network φe: ∏(∙∣x) = f (∙∣φe(x)). For example, in the discrete domain, We choose f to be the
categorical distribution with a probability vector φe(x) as its statistics. The probability vector is of
course parameterised by θ.
We denote the average policy network as φea and update its parameters θa “softly” after each update
to the policy parameter θ: θ° J aθo + (1 - α)θ.
Consider, for example, the ACER policy gradient as defined in Equation (9), but with respect to φ:
bacer = PtVφθ(χt) log f(at∖φe(x))[Qret(xt,at) - ¾, (xt)]
+ E ( ∣-ρt(aλ-c Vφθ(χj logf(at∣φe(x))[Qθv (xt,a) - ⅜, (xt)] ) .	(10)
a 〜π ∖ L Pt(a) J+	J
Given the averaged policy network, our proposed trust region update involves two stages. In the first
stage, we solve the following optimization problem with a linearized KL divergence constraint:
minimize	1 llgacer - zk2	....
z	2	(11)
subject to Vφθ (χt)DκL [f(∙∣Φθa (Xt ))kf (∙∣Φθ (χt))]T z ≤ δ
Since the constraint is linear, the overall optimization problem reduces to a simple quadratic program-
ming problem, the solution of which can be easily derived in closed form using the KKT conditions.
Letting k = Vφθ(χt)Dkl [f(∙∣Φθa(xt)kf (∙∣Φθ(xt)], the solution is:
z*= gacer - maχ {0[ }左	⑪
This transformation of the gradient has a very natural form. If the constraint is satisfied, there is no
change to the gradient with respect to φe (xt). Otherwise, the update is scaled down in the direction
5
Published as a conference paper at ICLR 2017
(UdEnH UD ujŋp ① W
0.0
0 IOO 200	300	«0	500 MO
Million Steps
700	800	9«
(UdEnH UD U.2P ① W
20	«	60	80	1∞	120
Hours
Figure 1: ACER improvements in sample (left) and computation (right) complexity on Atari.
On each plot, the median of the human-normalized score across all 57 Atari games is presented for 4
ratios of replay with 0 replay corresponding to on-policy A3C. The colored solid and dashed lines
represent ACER with and without trust region updating respectively. The environment steps are
counted over all threads. The gray curve is the original DQN agent (Mnih et al., 2015) and the black
curve is one of the Prioritized Double DQN agents from Schaul et al. (2016).
of k, thus effectively lowering rate of change between the activations of the current policy and the
average policy network.
In the second stage, we take advantage of back-propagation. Specifically, the updated gradient with
respect to φθ, that is z*, is back-propagated through the network to compute the derivatives with
respect to the parameters. The parameter updates for the policy network follow from the chain rule:
dφθ(X) `*
∂θ Z .
The trust region step is carried out in the space of the statistics of the distribution f, and not in the
space of the policy parameters. This is done deliberately so as to avoid an additional back-propagation
step through the policy network.
We would like to remark that the algorithm advanced in this section can be thought of as a general
strategy for modifying the backward messages in back-propagation so as to stabilize the activations.
Instead of a trust region update, one could alternatively add an appropriately scaled KL cost to the
objective function as proposed by Heess et al. (2015). This approach, however, is less robust to the
choice of hyper-parameters in our experience.
The ACER algorithm results from a combination of the above ideas, with the precise pseudo-code
appearing in Appendix A. A master algorithm (Algorithm 1) calls ACER on-policy to perform
updates and propose trajectories. It then calls ACER off-policy component to conduct several replay
steps. When on-policy, ACER effectively becomes a modified version of A3C where Q instead of V
baselines are employed and trust region optimization is used.
4 Results on Atari
We use the Arcade Learning Environment of Bellemare et al. (2013) to conduct an extensive evaluation.
We deploy one single algorithm and network architecture, with fixed hyper-parameters, to learn
to play 57 Atari games given only raw pixel observations and game rewards. This task is highly
demanding because of the diversity of games, and high-dimensional pixel-level observations.
Our experimental setup uses 16 actor-learner threads running on a single machine with no GPUs. We
adopt the same input pre-processing and network architecture as Mnih et al. (2015). Specifically,
the network consists of a convolutional layer with 32 8 × 8 filters with stride 4 followed by another
convolutional layer with 64 4 × 4 filters with stride 2, followed by a final convolutional layer with 64
3 × 3 filters with stride 1, followed by a fully-connected layer of size 512. Each of the hidden layers
is followed by a rectifier nonlinearity. The network outputs a softmax policy and Q values.
6
Published as a conference paper at ICLR 2017
When using replay, we add to each thread a replay memory that is up to 50 000 frames in size. The
total amount of memory used across all threads is thus similar in size to that of DQN (Mnih et al.,
2015). For all Atari experiments, we use a single learning rate adopted from an earlier implementation
of A3C without further tuning. We do not anneal the learning rates over the course of training as
in Mnih et al. (2016). We otherwise adopt the same optimization procedure as in Mnih et al. (2016).
Specifically, we adopt entropy regularization with weight 0.001, discount the rewards with γ = 0.99,
and perform updates every 20 steps (k = 20 in the notation of Section 2). In all our experiments with
experience replay, we use importance weight truncation with c = 10. We consider training ACER
both with and without trust region updating as described in Section 3.3. When trust region updating
is used, we use δ = 1 and α = 0.99 for all experiments.
To compare different agents, we adopt as our metric the median of the human normalized score over
all 57 games. The normalization is calculated such that, for each game, human scores and random
scores are evaluated to 1, and 0 respectively. The normalized score for a given game at time t is
computed as the average normalized score over the past 1 million consecutive frames encountered
until time t. For each agent, we plot its cumulative maximum median score over time. The result is
summarized in Figure 1.
The four colors in Figure 1 correspond to four replay ratios (0, 1, 4 and 8) with a ratio of 4 meaning
that we use the off-policy component of ACER 4 times after using the on-policy component (A3C).
That is, a replay ratio of 0 means that we are using A3C. The solid and dashed lines represent ACER
with and without trust region updating respectively. The gray and black curves are the original
DQN (Mnih et al., 2015) and Prioritized Replay agent of Schaul et al. (2016) agents respectively.
As shown on the left panel of Figure 1, replay significantly increases data efficiency. We observe that
when using the trust region optimizer, the average reward as a function of the number of environmental
steps increases with the ratio of replay. This increase has diminishing returns, but with enough replay,
ACER can match the performance of the best DQN agents. Moreover, it is clear that the off-policy
actor critics (ACER) are much more sample efficient than their on-policy counterpart (A3C).
The right panel of Figure 1 shows that ACER agents perform similarly to A3C when measured by
wall clock time. Thus, in this case, it is possible to achieve better data-efficiency without necessarily
compromising on computation time. In particular, ACER with a replay ratio of 4 is an appealing
alternative to either the prioritized DQN agent or A3C.
5 Continuous Actor Critic with Experience Replay
Retrace requires estimates of both Q and V , but we cannot easily integrate over Q to derive V in
continuous action spaces. In this section, we propose a solution to this problem in the form of a novel
representation for RL, as well as modifications necessary for trust region updating.
5.1	Policy Evaluation
Retrace provides a target for learning Qθv , but not for learning Vθv . We could use importance
sampling to compute Vθv given Qθv, but this estimator has high variance.
We propose a new architecture which we call Stochastic Dueling Networks (SDNs), inspired by the
Dueling networks of Wang et al. (2016), which is designed to estimate both V π and Qπ off-policy
while maintaining consistency between the two estimates. At each time step, an SDN outputs a
stochastic estimate Qθv of Qπ and a deterministic estimate Vθv of V π , such that
1n
1
Qθv(xt,at)〜Vθv (xt) + Aθv(xt,at)——Z^Aθv (xt,Ui), and Ui 〜∏θ (∙∣xt)	(13)
i=1
where n is a parameter, see Figure 2. The two estimates are consistent in the sense that
Ea〜∏(∙∣xt) [Eui：n〜∏(∙∣xt) (Qθv (Xt,a))] = Vθv (xt). Furthermore, we can learn about Vπ by learn-
ing Qθv. To see this, assume We have learned Qn perfectly such that EuLn〜∏(∙∣χt) (Qθv (xt, at)) =
Q	(Xt, at),	then	Vθv (Xt)	=	Ea〜π(∙∣xt)	[Eui：n〜π(∙∣xt)	(Qθv(xt,α))]	=	Ea〜π(∙∣xt) [Q	(Xt,a)]=
Vπ(xt). Therefore, a target on Qθv (xt, at) also provides an error signal for updating Vθv .
7
Published as a conference paper at ICLR 2017
Figure 2: A schematic of the Stochastic Dueling Network. In the drawing, [u1,…，Un] are assumed
to be samples from πθ (∙∣xt). This schematic illustrates the concept of SDNS but does not reflect the
real sizes of the networks used.
In addition to SDNs, however, we also construct the following novel target for estimating V π :
V target (Xt) = min {]，^^/ } (Qret (Xt，生)- 口牝(勺，生))+ ¾ (xt )∙	(")
The above target is also derived via the truncation and bias correction trick; for more details, see
Appendix D.
Finally, when estimating Qret in continuous domains, we implement a slightly different formulation
of the truncated importance weights ρt = min {l, ( [(at,；)) d }, where d is the dimensionality of
the action space. Although not essential, we have found this formulation to lead to faster learning.
5.2	Trust Region Updating
To adopt the trust region updating scheme (Section 3.3) in the continuous control domain, one simply
has to choose a distribution f and a gradient specification gtacer suitable for continuous action spaces.
For the distribution f, we choose Gaussian distributions with fixed diagonal covariance and mean
φθ(X).
To derive gtacer in continuous action spaces, consider the ACER policy gradient for the stochastic
dueling network, but with respect to φ:
gtacer
=ExtEatMt Vφθ (xt)log f (at iφθ (Xt»(QOPC (Xt ,at) - Vθv (Xt))
+ E [刨aF
a~π U Pt (a)
(Qθv (Xt ,a) - Vθv (Xt ))Vφθ (xt ) log f (a∖φθ (Xt ))
+
)1
(15)
In the above definition, we are using Qopc instead of Qret. Here, Qopc (Xt , at) is the same as Retrace
with the exception that the truncated importance ratio is replaced with 1 (Harutyunyan et al., 2016).
Please refer to Appendix B an expanded discussion on this design choice. Given an observation Xt ,
we can sample at 〜πθ(∙∣Xt) to obtain the following Monte Carlo approximation
gacer = PtVφθ(xt)log f(at∖φθ(Xt))(Qopc(Xt,at) - Vθv (Xt))
+ Pt(a：) 0- C (Qeθv (Xt ,at) — Vθv (Xt ))Vφθ (xt) log f (at ∖φθ (Xt)).	(16)
ρt(at)	+
Given f and gtιcer, we apply the same steps as detailed in Section 3.3 to complete the update.
The precise pseudo-code of ACER algorithm for continuous spaces results is presented in Appendix A.
8
Published as a conference paper at ICLR 2017
WaIker2d
SP.IeW.30 3po-dw
50	100	150	200	250
Million Steps
Fish
20	40	60	80	100	120	140	160
Million Steps
0
10	20	30	40	50
Million Steps
Cheetah
HUmanOid
ReaCher3 (3-DoF∕3-dim.
—45 --------------------------------------- 0	.
0	20	40	6 0	80	100	120	140	160	5	10	15	0	20	40	60	80	100	120	140	160
Million Steps	Million Steps	Million Steps
Figure 3: [Top] Screen shots of the continuous control tasks. [Bottom] Performance of different
methods on these tasks. ACER outperforms all other methods and shows clear gains for the higher-
dimensionality tasks (humanoid, cheetah, walker and fish). The proposed trust region method by
itself improves the two baselines (truncated importance sampling and A3C) significantly.
6 Results on MuJoCo
We evaluate our algorithms on 6 continuous control tasks, all of which are simulated using the
MuJoCo physics engine (Todorov et al., 2012). For descriptions of the tasks, please refer to Appendix
E.1. Briefly, the tasks with action dimensionality in brackets are: cartpole (1D), reacher (3D), cheetah
(6D), fish (5D), walker (6D) and humanoid (21D). These tasks are illustrated in Figure 3.
To benchmark ACER for continuous control, we compare it to its on-policy counterpart both with and
without trust region updating. We refer to these two baselines as A3C and Trust-A3C. Additionally,
we also compare to a baseline with replay where we truncate the importance weights over trajectories
as in (Wawrzynski, 2009). For a detailed description of this baseline, please refer to Appendix E.
Again, we run this baseline both with and without trust region updating, and refer to these choices as
Trust-TIS and TIS respectively. Last but not least, we refer to our proposed approach with SDN and
trust region updating as simply ACER. All five setups are implemented in the asynchronous A3C
framework.
All the aforementioned setups share the same network architecture that computes the policy and state
values. We maintain an additional small network that computes the stochastic A values in the case of
ACER. We use n = 5 (using the notation in Equation (13)) in all SDNs. Instead of mixing on-policy
and replay learning as done in the Atari domain, ACER for continuous actions is entirely off-policy,
with experiences generated from the simulator (4 times on average). When using replay, we add to
each thread a replay memory that is 5, 000 frames in size and perform updates every 50 steps (k = 50
in the notation of Section 2). The rate of the soft updating (α as in Section 3.3) is set to 0.995 in all
setups involving trust region updating. The truncation threshold c is set to 5 for ACER.
9
Published as a conference paper at ICLR 2017
We use diagonal Gaussian policies with fixed diagonal covariances where the diagonal standard
deviation is set to 0.3. For all setups, we sample the learning rates log-uniformly in the range
[10-4, 10-3.3]. For setups involving trust region updating, we also sample δ uniformly in the range
[0.1, 2]. With all setups, we use 30 sampled hyper-parameter settings.
The empirical results for all continuous control tasks are shown Figure 3, where we show the mean
and standard deviation of the best 5 out of 30 hyper-parameter settings over which we searched 3.
For sensitivity analyses with respect to the hyper-parameters, please refer to Figures 5 and 6 in the
Appendix.
In continuous control, ACER outperforms the A3C and truncated importance sampling baselines by a
very significant margin.
Here, we also find that the proposed trust region optimization method can result in huge improvements
over the baselines. The high-dimensional continuous action policies are much harder to optimize
than the small discrete action policies in Atari, and hence we observe much higher gains for trust
region optimization in the continuous control domains. In spite of the improvements brought in by
trust region optimization, ACER still outperforms all other methods, specially in higher dimensions.
6.1 Ablations
To further tease apart the contributions of the different components of ACER, we conduct an ablation
analysis where we individually remove Retrace / Q(λ) off-policy correction, SDNs, trust region,
and truncation with bias correction from the algorithm. As shown in Figure 4, Retrace and off-
policy correction, SDNs, and trust region are critical: removing any one of them leads to a clear
deterioration of the performance. Truncation with bias correction did not alter the results in the Fish
and Walker2d tasks. However, in Humanoid, where the dimensionality of the action space is much
higher, including truncation and bias correction brings a significant boost which makes the originally
kneeling humanoid stand. Presumably, the high dimensionality of the action space increases the
variance of the importance weights which makes truncation with bias correction important. For more
details on the experimental setup please see Appendix E.4.
7 Theoretical Analysis
Retrace is a very recent development in reinforcement learning. In fact, this work is the first to
consider Retrace in the policy gradients setting. For this reason, and given the core role that Retrace
plays in ACER, it is valuable to shed more light on this technique. In this section, we will prove that
Retrace can be interpreted as an application of the importance weight truncation and bias correction
trick advanced in this paper.
Consider the following equation:
Qπ(xt, at)
= Ext+1at+1 [rt + γρt+1Qπ (xt+1, at+1)] .	(17)
If we apply the weight truncation and bias correction trick to the above equation we obtain
Qπ(xt, at)
= Ext+1 at+1
r + YPt+ιQπ(xt+ι,at+ι) + Y E
a〜π
(ΓPt+1(Ia) - C
V Pt+ι(a) .
By recursively expanding Qπ as in Equation (18), we can represent Qπ(x, a) as:
Qπ(xt+1,a)
))
(18)
+
Qn (x,a) = Eμ X Yt(Y PW + YbEn ([ EWC ] Qn (χt+ι,b)) .	(19)
The expectation Eμ is taken over trajectories starting from X with actions generated with respect to
μ. When Qn is not available, we can replace it with our current estimate Q to get a return-based
3 For videos of the policies learned with ACER, please see: https://www.youtube.com/watch?v=
NmbeQYoVv5g&list=PLkmHIkhlFjiTlvwxEnsJMs3v7seR5HSP-.
10
Published as a conference paper at ICLR 2017
s"eM"3po-d山
noigeR tsurT oN
Walker2d
Humanoid
SNclS ON
.rroC yciloP-ffO
ron ecarteR oN
.⅛0u s∙sm赵
noitacnurT oN
0	10	a	”4050607080	0
Million Steps
20	40	3	80	18	1a	0
Million Steps
10	2J3J405J6J708J
Million Steps
Figure 4: Ablation analysis evaluating the effect of different components of ACER. Each row
compares ACER with and without one component. The columns represents three control tasks. Red
lines, in all plots, represent ACER whereas green lines ACER with missing components. This study
indicates that all 4 components studied improve performance where 3 are critical to success. Note
that the ACER curve is of course the same in all rows.
esitmate of Qπ . This operation also defines an operator:
BQ(x,a) = Eμ XXYt(Yρ)0 + γbEπ QP；+(I-C +Q(Xt+ι㈤)).QO)
In the following proposition, we show that B is a contraction operator with a unique fixed point Qπ
and that it is equivalent to the Retrace operator.
Proposition 1. The operator B is a contraction operator such that kBQ - Qπ k∞ ≤ γ kQ - Qπ k∞
and B is equivalent to Retrace.
The above proposition not only shows an alternative way of arriving at the same operator, but also
provides a different proof of contraction for Retrace. Please refer to Appendix C for the regularization
conditions and proof of the above proposition.
Finally, B, and therefore Retrace, generalizes both the Bellman operator Tπ and importance sampling.
Specifically, when c = 0, B = Tπ and when c = ∞, B recovers importance sampling; see
Appendix C.
11
Published as a conference paper at ICLR 2017
8 Concluding Remarks
We have introduced a stable off-policy actor critic that scales to both continuous and discrete action
spaces. This approach integrates several recent advances in RL in a principle manner. In addition,
it integrates three innovations advanced in this paper: truncated importance sampling with bias
correction, stochastic dueling networks and an efficient trust region policy optimization method.
We showed that the method not only matches the performance of the best known methods on Atari,
but that it also outperforms popular techniques on several continuous control problems.
The efficient trust region optimization method advanced in this paper performs remarkably well in
continuous domains. It could prove very useful in other deep learning domains, where it is hard to
stabilize the training process.
Acknowledgments
We are very thankful to Marc Bellemare, Jascha Sohl-Dickstein, and Sebastien Racaniere for Proof-
reading and valuable suggestions.
References
M.	G. Bellemare, Y. Naddaf, J. Veness, and M. Bowling. The arcade learning environment: An evaluation
Platform for general agents. JAIR, 47:253-279, 2013.
G. Brockman, V. Cheung, L. Pettersson, J. Schneider, J. Schulman, J. Tang, and W. Zaremba. OPenAI Gym.
arXiv preprint 1606.01540, 2016.
T. Degris, M. White, and R. S. Sutton. Off-Policy actor-critic. In ICML, PP. 457-464, 2012.
Anna Harutyunyan, Marc G Bellemare, Tom StePleton, and Remi Munos. Q (λ) with off-Policy corrections.
arXiv preprint arXiv:1602.04951, 2016.
N.	Heess, G. Wayne, D. Silver, T. LillicraP, T. Erez, and Y. Tassa. Learning continuous control Policies by
stochastic value gradients. In NIPS, 2015.
T. Jie and P. Abbeel. On a connection between imPortance samPling and the likelihood ratio Policy gradient. In
NIPS, PP. 1000-1008, 2010.
S. Levine and V. Koltun. Guided Policy search. In ICML, 2013.
S.	Levine, C. Finn, T. Darrell, and P. Abbeel. End-to-end training of deeP visuomotor Policies. arXiv preprint
arXiv:1504.00702, 2015.
T.	LillicraP, J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra. Continuous control with
deeP reinforcement learning. arXiv:1509.02971, 2015.
L.J. Lin. Self-imProving reactive agents based on reinforcement learning, Planning and teaching. Machine
learning, 8(3):293-321, 1992.
N. Meuleau, L. Peshkin, L. P. Kaelbling, and K. Kim. Off-Policy Policy search. Technical rePort, MIT AI Lab,
2000.
V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K.
Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran, D. Wierstra,
S. Legg, and D. Hassabis. Human-level control through deeP reinforcement learning. Nature, 518(7540):
529-533, 2015.
V. Mnih, A. PUigdomeneCh Badia, M. Mirza, A. Graves, T. P. Lillicrap, T. Harley, D. Silver, and K. Kavukcuoglu.
Asynchronous methods for deeP reinforcement learning. arXiv:1602.01783, 2016.
R. Munos, T. StePleton, A. Harutyunyan, and M. G. Bellemare. Safe and efficient off-Policy reinforcement
learning. arXiv preprint arXiv:1606.02647, 2016.
K. Narasimhan, T. Kulkarni, and R. Barzilay. Language understanding for text-based games using deeP
reinforcement learning. In EMNLP, 2015.
12
Published as a conference paper at ICLR 2017
J. Oh, V. Chockalingam, S. P. Singh, and H. Lee. Control of memory, active perception, and action in Minecraft.
In ICML, 2016.
D. Precup, R. S. Sutton, and S. Singh. Eligibility traces for off-policy policy evaluation. In ICML, pp. 759-766,
2000.
T. Schaul, J. Quan, I. Antonoglou, and D. Silver. Prioritized experience replay. In ICLR, 2016.
J. Schulman, S. Levine, P. Abbeel, M. I. Jordan, and P. Moritz. Trust region policy optimization. In ICML,
2015a.
J. Schulman, P. Moritz, S. Levine, M. I. Jordan, and P. Abbeel. High-dimensional continuous control using
generalized advantage estimation. arXiv:1506.02438, 2015b.
D. Silver, G. Lever, N. Heess, T. Degris, D. Wierstra, and M. Riedmiller. Deterministic policy gradient algorithms.
In ICML, 2014.
D.	Silver, A. Huang, C.J. Maddison, A. Guez, L. Sifre, G. van den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, S. Dieleman, D. Grewe, J. Nham, N. Kalchbrenner, I. Sutskever, T. Lillicrap,
M. Leach, K. Kavukcuoglu, T. Graepel, and D. Hassabis. Mastering the game of Go with deep neural
networks and tree search. Nature, 529(7587):484-489, 2016.
R. S. Sutton, D. Mcallester, S. Singh, and Y. Mansour. Policy gradient methods for reinforcement learning with
function approximation. In NIPS, pp. 1057-1063, 2000.
E.	Todorov, T. Erez, and Y. Tassa. MuJoCo: A physics engine for model-based control. In International
Conference on Intelligent Robots and Systems, pp. 5026-5033, 2012.
Z. Wang, T. Schaul, M. Hessel, H. van Hasselt, M. Lanctot, and N. de Freitas. Dueling network architectures for
deep reinforcement learning. In ICML, 2016.
P. Wawrzynski. Real-time reinforcement learning by sequential actor-critics and experience replay. Neural
Networks, 22(10):1484-1497, 2009.
13
Published as a conference paper at ICLR 2017
A ACER Pseudo-Code for Discrete Actions
Algorithm 1 ACER for discrete actions (master algorithm)
// Assume global shared parameter vectors θ and θv.
// Assume ratio of replay r.
repeat
Call ACER on-policy, Algorithm 2.
n — Possion(r)
for i ∈ {1, ∙∙∙ ,n} do
Call ACER off-policy, Algorithm 2.
end for
until Max iteration or time reached.
Algorithm 2 ACER for discrete actions
Reset gradients dθ - 0 and dθv — 0.
Initialize parameters θ0 — θ and θV — θv.
if not On-Policy then
Sample the trajectory {x0,a0,r0,μ(∙∣x0), ∙…,xk,ak ,rk,μ(∙∖xk)} from the replay memory.
else
Get state x0
end if
for i ∈ {0, ∙∙∙ ,k} do
Compute f(∙∖φθo(xi)), QS，v (xi, ∙) and f(∙∖φθa (xi)).
if On-Policy then
Perform ai according to f (∙∖Φθo (xi))
Receive reward ri and new state xi+1
μ(∙∖χi) - f (∙∖Φθο (χi))
end if
Pi - min {l, f(a⅞(Xi)) }.
[	μ(aiIxi) J
end for
Qret _ f 0	for terminal Xk
Pa Qθv0 (xk, a)f (a∖φθ0 (xk)) otherwise
for i ∈ {k — 1,…，0} do
Qret - ri + YQret
Vi - Pa QθV (Xi,a)f (a∖φθ0 (Xi))
Computing quantities needed for trust region updating:
g - min {c,Pi(ai)}Vφθ0(Xi) log f (ai∖Φθθ(xi))(Qret — Vi)
+ X 卜—Pcay] f (a∖φθ0 (xi))Vφθ0 (Xi) log f(a∖φθθ(xi))(Qθv (xi,ai) - ¼)
k 一 Vφθ0(Xi)DKL [f(∙∖φθa(Xi)kf(∙∖φθ0(Xi)]
Accumulate gradients wrt θ0: dθ0 — dθ0 + "∂θ(OXi) (g - max {。, kTg-δ 0 B
Accumulate gradients wrt θV: dθv — dθv + V@v (Qret — Q@v (xi, a))2
Update Retrace target: QTet - Pi (Qret — Q@v (Xi,αi)) + Vi
end for
Perform asynchronous update of θ using dθ and of θv using dθv .
Updating the average policy network: θα — αθa + (1 — α)θ
B Q(λ) WITH OFF-POLICY CORRECTIONS
Given a trajectory generated under the behavior policy μ, the Q(λ) with off-policy corrections
estimator (Harutyunyan et al., 2016) can be expressed recursively as follows:
Qopc(xt, at) = rt + γ[Qopc(xt+1, at+1) - Q(xt+1, at+1)] + γV (xt+1).	(21)
Notice that Qopc(xt, at) is the same as Retrace with the exception that the truncated importance ratio
is replaced with 1.
14
Published as a conference paper at ICLR 2017
Algorithm 3 ACER for Continuous Actions
Reset gradients dθ - 0 and dθv — 0.
Initialize parameters θ0 — θ and θV — θv.
Sample the trajectory {xo, ao,ro,μ(∙∣xo), ∙…,Xk,ak,rk,μ(∙∣Xk)} from the replay memory.
for i ∈ {0, ∙∙∙ ,k} do
Compute f (∙∣φθθ(xi)), %v (xi), Qθ>v (xi, a/ and f (∙∣Φθa (xi)).
Sample ai 〜f(∙∣Φθθ(xi))
Pi —
f (ai|0®0 (Xi))	0 0 , f (Wφθ0 (Xi))
μ(aiIxi)	Pi	μ(ai∣Xi)
Ci — min {l, (ρi)d }.
end for
Qret _ f 0	for terminal Xk
Vθv0 (xk) otherwise
QOPc — Qret
for i ∈ {k — 1,…，0} do
QTet - n + YQret
Qopc - ri + γQopc
Computing quantities needed for trust region updating:
g - min {c,Pi}Nφθ0(Xi) log f (ai∣φθo(xi)) (Qopc(xi,ai) — ⅞v (Xi))
+	1 —3	(QθV (xi,ai) — ⅞v (xi))Vφθ/(Xi) log f(ai∣Φθ0(xi))
Pi +
k 一 Vφθ0(Xi)DKL [f(∙∣φθa (Xi)kf (∙∣Φθ0(Xi)]
Accumulate gradients wrt θ: dθ — dθ + "∂θ(Xi) (g - max {。，kTg-δ} B
0	ret
Accumulate gradients wrt θV: dθv - dθv + (Q t — Qe；, (xi,ai))VθvQ@v (xi,ai)
dθv — dθv + min {1,ρi}(Qret(xt,ai) — Qev (xt,ai)) Vev%V (Xi)
Update Retrace target: QTet - Ci (Qret — Qev (Xi,ai)) + Vθv (Xi)
Update Retrace target: Qopc —(Qopc — Qev (Xi,ai)) + Vevυ (Xi)
end for
Perform asynchronous update of θ using dθ and of θv using dθv .
Updating the average policy network: θα — αθα + (1 — α)θ
Because of the lack of the truncated importance ratio, the operator defined by Qopc is only a
contraction if the target and behavior policies are close to each other (Harutyunyan et al., 2016).
Q(λ) with off-policy corrections is therefore less stable compared to Retrace and unsafe for policy
evaluation.
Qopc, however, could better utilize the returns as the traces are not cut by the truncated importance
weights. As a result, Qopc could be used efficiently to estimate Qπ in policy gradient (e.g. in Equation
(16)). In our continuous control experiments, we have found that Qopc leads to faster learning.
C Retrace as Truncated Importance Sampling with Bias
Correction
For the purpose of proving proposition 1, we assume our environment to be a Markov Decision
Process (X, A, γ, P, r). We restrict X to be a finite state space. For notational simplicity, we also
restrict A to be a finite action space. P : X , A → X defines the state transition probabilities and
r : X, A → [-RMAX, RMAX] defines a reward function. Finally, γ ∈ [0, 1) is the discount factor.
15
Published as a conference paper at ICLR 2017
Proof of proposition 1. First We show that B is a contraction operator.
∣BQ(x, O)- Qπ(x, a)|
跖 X7'(YP)QEn ([p++b-[(Q(…b)-Q"(…⑼))
X (Y Pi
Eμ
≤
7 E	[ρt+1㈤-C
b~π ∖ L Pt+ι(b)
∣Q(xt+ι,b) - Qn(xt+ι,b)∣)
Eμ
X γt (YPi) (γ(1 - Pt+ι)subp ∣Q(xt+ι,b) - Qπ(xt+ι,b)∣
(22)
Where Pt+ι = 1 - E [hpt+1(b)-c]
t+1	b〜π |_L pt+i(b)」+
due to Holder,s inequality.
(22)
E [pt+ι (b)]. The last inequality in the above equation is
b〜μ
sup ∣Q(x,b) - Qπ(x,b)∣ Eμ
x,b
X 寸(Y Pi
t≥0	∖i=1
sup ∣Q(x,b) - Qπ(x,b)∣ Eμ
x,b
sup ∣Q(x,b) - Qπ(x,b)∣ Eμ
x,b
Y X Yt (Y P) - X Yt (Y P) (TPt+1)
t≥0	∖i=1	) t≥0	∖i=1	)
Y X Yt (Y P) - X Yt+1 (Y P)
t≥0	i=1	t≥0	i=1
sup ∣Q(x,b)- Qn(x,b)∣ (yC - (C - 1))
x,b
where C = ∑t≥0 Yt (Qt=I Pi) ∙ SinCe C ≥ P0=0Yt(Q；=1 Pi) = 1, we have that YC - (C-1) ≤
Y. Therefore, we have shown that B is a contraction operator.
Now we show that B is the same as Retrace. By apply the trunction and bias correction trick, we have
E [Q(xt+1,b)]
b〜π
E [Pt+1(b)Q(xt+1,b)]+ E
b〜μ	b〜π
Pt+1(b) - C
Pt+1(b)
Q(xt+1,b) I .	(23)
≤
≤
By adding and subtracting the two sides of Equation (23) inside the summand of Equation (20), we
have
BQ(x,o)
Eμ IXY t(Y Pi)卜 t+Yb "h+⅜F "t+1,bWbEJQ(Xt+1,知
-Y E [Pt+1(b)Q(xt+1,b)]-
b〜μ
Pt+1(b) - C'
Pt+1(b).
Q(xt+1, b)
+
Eμ
Eμ
XYt(YPi) Q + YbEJQ(Xt+1，b)] - YbEμ[Pt+1(b)Q(Xt+1，b)]
Yt	Pi)卜t + YbE[Q(xt+1,b)] - YPt+1Q(xt+1,0t+1)
t≥0	∖i=1 ) ×	~π
X Yt(Y Pi) }t + YbEn[Q(xt+1,b)] - Q(xt,0t))∣ + Q(x,α)= RQ(x,α)
16
Published as a conference paper at ICLR 2017
□
In the remainder of this appendix, we show that B generalizes both the Bellman operator and
importance sampling. First, we reproduce the definition of B:
BQ(XM = Eμ XXYt(Yρ) (t+ YbEn Q*+[；— + Q(Xt+ι㈤)).
When C = 0,we have that Pi = 0 ∀i. Therefore only the first summand of the sum remains:
BQ(x,a) = Eμ rt + Y E (Q(Xt+ι,b))
In this case B = T. When C = ∞, the compensation term disappears and Pi = Pi ∀i:
BQ(x,a)= Eμ
XX Yt (Y Pi)卜t + YbEπ(0 × Q(Xt+1,b)))| = Eμ
X	Y t	Yt Pi	rt
t≥0	i=1
In this case B is the same operator defined by importance sampling.
D DERIVATION OF V target
By using the truncation and bias correction trick, we can derive the following:
Vπ (Xt) = aEμ [min {1,μS⅛ } Qn (XtT + aE∏ ([ L ] + Qn (…
We, however, cannot use the above equation as a target as we do not have access to Qn . To derive a
target, we can take a Monte Carlo approximation of the first expectation in the RHS of the above
equation and replace the first occurrence of Qn with Qret and the second with our current neural net
approximation Qθv (Xt, ∙):
"(Xt)=min+』
Qret (Xt , at ) + E
a〜n
[Pt(O) - 1
[Pt(a).
+Qθv (Xt, a)
(24)
Through the truncation and bias correction trick again, we have the following identity:
E [Qθv (Xt,a)]= E min ( 1, n(ajXt) ] Qθv (Xt,a) + E ( [Pt(a) - 1	Qθv (Xt,a)).(25)
a~n	a~μ	I	μ(a∣Xt) J	」a〜n ∖ L Pt(a)」十	I
Adding and subtracting both sides of Equation (25) to the RHS of (24) while taking a Monte Carlo
approximation, we arrive at V target(Xt):
Vtarget(Xt) := min{l,μa∣Xtj} (Qret(Xt,at)- Qθv (Xt,at)) + %。(Xt).
E Continuous Control Experiments
E.1	Description of the continuous control problems
Our continuous control tasks were simulated using the MuJoCo physics engine (Todorov et al. (2012)).
For all experiments we considered an episodic setup with an episode length of T = 500 steps and a
discount factor of 0.99.
Cartpole swingup This is an instance of the classic cart-pole swing-up task. It consists of a pole
attached to a cart running on a finite track. The agent is required to balance the pole near the center
of the track by applying a force to the cart only. An episode starts with the pole at a random angle
and zero velocity. A reward zero is given except when the pole is approximately upright (within
±5 deg) and the track approximately in the center of the track (±0.05) for a track length of 2.4.
The observations include position and velocity of the cart, angle and angular velocity of the pole. a
sine/cosine of the angle, the position of the tip of the pole, and Cartesian velocities of the pole. The
dimension of the action space is 1.
17
Published as a conference paper at ICLR 2017
Reacher3 The agent needs to control a planar 3-link robotic arm in order to minimize the distance
between the end effector of the arm and a target. Both arm and target position are chosen randomly
at the beginning of each episode. The reward is zero except when the tip of the arm is within 0.05
of the target, where it is one. The 8-dimensional observation consists of the angles and angular
velocity of all joints as well as the displacement between target and the end effector of the arm. The
3-dimensional action are the torques applied to the joints.
Cheetah The Half-Cheetah (WaWrzynski (2009); Heess et al. (2015)) is a planar locomotion task
where the agent is required to control a 9-DoF cheetah-like body (in the vertical plane) to move in the
direction of the x-axis as quickly as possible. The reWard is given by the velocity along the x-axis
and a control cost: r = vx + 0.1kak2. The observation vector consists of the z-position of the torso
and its x, z velocities as Well as the joint angles and angular velocities. The action dimension is 6.
Fish The goal of this task is to control a 13-DoF fish-like body to sWim to a random target in 3D
space. The reWard is given by the distance betWeen the head of the fish and the target, a small penalty
for the body not being upright, and a control cost. At the beginning of an episode the fish is initialized
facing in a random direction relative to the target. The 24-dimensional observation is given by the
displacement betWeen the fish and the target projected onto the torso coordinate frame, the joint
angles and velocities, the cosine of the angle betWeen the z-axis of the torso and the World z-axis,
and the velocities of the torso in the torso coordinate frame. The 5-dimensional actions control the
position of the side fins and the tail.
Walker The 9-DoF planar Walker is inspired by (Schulman et al. (2015a)) and is required to move
forWard along the x-axis as quickly as possible Without falling. The reWard consists of the x-velocity
of the torso, a quadratic control cost, and terms that penalize deviations of the torso from the preferred
height and orientation (i.e. terms that encourage the Walker to stay standing and upright). The
24-dimensional observation includes the torso height, velocities of all DoFs, as Well as sines and
cosines of all body orientations in the x-z plane. The 6-dimensional action controls the torques
applied at the joints. Episodes are terminated early With a negative reWard When the torso exceeds
upper and loWer limits on its height and orientation.
Humanoid The humanoid is a 27 degrees-of-freedom body With 21 actuators (21 action dimen-
sions). It is initialized lying on the ground in a random configuration and the task requires it to
achieve a standing position. The reWard function penalizes deviations from the height of the head
When standing, and includes additional terms that encourage upright standing, as Well as a quadratic
action penalty. The 94 dimensional observation contains information about joint angles and velocities
and several derived features reflecting the body’s pose.
E.2 Update Equations of the Baseline TIS
The baseline TIS folloWs the folloWing update equations,
updates to the policy: min
5,	iY=-0ρt+i
k-1
γirt+i + γkVθv (xk+t) - Vθv (xt)
i=0
Vθ log∏θ(at∣xt),
updates to the value: min
5,	iY=-0ρt+i
k-1
i=0
γirt+i + γkVθv (xk+t) - Vθv (xt)
VθvVθv(xt).
The baseline Trust-TIS is appropriately modified according to the trust region update described in
Section 3.3.
E.3 Sensitivity Analysis
In this section, We assess the sensitivity of ACER to hyper-parameters. In Figures 5 and 6, We shoW,
for each game, the final performance of our ACER agent versus the choice of learning rates, and the
trust region constraint δ respectively.
Note, as We are doing random hyper-parameter search, each learning rate is associated With a random
δ and vice versa. It is therefore difficult to tease out the effect of either hyper-parameter independently.
18
Published as a conference paper at ICLR 2017
We observe, however, that ACER is not very sensitive to the hyper-parameters overall. In addition,
smaller δ's do not Seem to adversely affect the final performance while larger δ's do in domains of
higher action dimensionality. Similarly, smaller learning rates perform well while bigger learning
rates tend to hurt final performance in domains of higher action dimensionality.
Cheetah	.	Fish
PJBMe= φ>≡ffl3E30
-4β -aβ -»B	-3-7	-*e	**6	**4 -M
Log Learning Rate
Cartpole
-co -aβ -*b	-3-7 -ae -*6	-a4	**»
Log Learning Rate
S	Reacher3
PJBMətt:ΘΛ=B-nluno
Walker2D
26却1610β
PJBMe= φ>≡ffl3E30
-40 -aβ -*b	-3.7	-*e -as -*«	-»»
Log Learning Rate
n	Humanoid
-4β -aβ -»B	-3-7	-*e	**6	**4 -M
Log Learning Rate
Figure 5: Log learning rate vs. cumulative rewards in all the continuous control tasks for ACER. The
plots show the final performance after training for all 30 log learning rates considered. Note that each
learning rate is associated with a different δ as a consequence of random search over hyper-parameters.
-4.0	-»»	-*B	-3-7	-*e	**6 -M -*»
Log Learning Rate
PJBMea φ>≡ffl-3E30
-co -aβ -*b	-3.7	-*e -as -*«	**»
Log Learning Rate
Cheetah
Fish
PJBMe= φ>≡ffl-3E30
as	to	1.5	Zo
Trust Region Constraint (i)
Cartpole
as	to	1.5	Zo
Trust Region Constraint (i)
Reacher3
PJBMe= φ>≡ffl-3E30
PJBMQB QAgSnLU no
Walker2D
as	to	1.5	Zo
Trust Region Constraint (i)
Figure 6: Trust region constraint (δ) vs. cumulative rewards in all the continuous control tasks for
ACER. The plots show the final performance after training for all 30 trust region constraints (δ)
searched over. Note that each δ is associated with a different learning rate as a consequence of random
search over hyper-parameters.
E.4 Experimental setup of ablation analysis
For the ablation analysis, we use the same experimental setup as in the continuous control experiments
while removing one component at a time.
as	to	1.5	Zo
Trust Region Constraint (i)
PJBMeB φ>≡ffl-3E30
0β	1.0	1,5	20
Trust Region Constraint (5)
Humanoid
Oe	1.0	1.5	Zo
Trust Region Constraint (¢)
19
Published as a conference paper at ICLR 2017
To evaluate the effectiveness of Retrace/Q(λ) with off-policy correction, We replace both with
importance sampling based estimates (following Degris et al. (2012)) which can be expressed
recursively: Rt = rt + ρt+1Rt+1.
To evaluate the Stochastic Dueling Networks, we replace it with two separate networks: one comput-
ing the state values and the other Q values. Given Qret (xt, at), the naive way of estimating the state
values is to use the following update rule:
(PtQret(xt, at) - Vθv (Xt)) Vθv Vθv (xt).
The above update rule, however, suffers from high variance. We consider instead the following update
rule:
Pt (Qret(xt,at) - Vθv (Xt)) Vθv Vθv (Xt)
which has markedly lower variance. We update our Q estimates as before.
To evaluate the effects of the truncation and bias correction trick, we change our c parameter (see
Equation (16)) to ∞ so as to use pure importance sampling.
20