Under review as a conference paper at ICLR 2017
Hierarchical compositional feature learning
Miguel Lazaro-Gredilla, Yi Liu, D. Scott Phoenix, Dileep George
Vicarious
San Francisco, CA, USA
{miguel,yiliu,scott,dileep}@vicarious.com
Abstract
We introduce the hierarchical compositional network (HCN), a directed generative
model able to discover and disentangle, without supervision, the building blocks
of a set of binary images. The building blocks are binary features defined hierar-
chically as a composition of some of the features in the layer immediately below,
arranged in a particular manner. At a high level, HCN is similar to a sigmoid belief
network with pooling. Inference and learning in HCN are very challenging and
existing variational approximations do not work satisfactorily. A main contribution
of this work is to show that both can be addressed using max-product message
passing (MPMP) with a particular schedule (no EM required). Also, using MPMP
as an inference engine for HCN makes new tasks simple: adding supervision infor-
mation, classifying images, or performing inpainting all correspond to clamping
some variables of the model to their known values and running MPMP on the
rest. When used for classification, fast inference with HCN has exactly the same
functional form as a convolutional neural network (CNN) with linear activations
and binary weights. However, HCN’s features are qualitatively very different.
1 Introduction
Deep neural networks coupled with the availability of vast amounts of data have proved very
successful over the last few years at visual discrimination (Goodfellow et al., 2014; Kingma &
Welling, 2013; LeCun et al., 1998; Mnih & Gregor, 2014). A basic desire of deep architectures is to
discover the blocks -or features- that compose an image (or in general, a sensory input) at different
levels of abstraction. Tasks that require some degree of image understanding can be performed more
easily when using representations based on these building blocks.
It would make intuitive sense that if we were to train one of the above models (particularly, those
that are generative, such as variational autoencoders or generative adversarial networks) on images
containing, e.g. text, the learned features would be individual letters, since those are the building
blocks of the provided images. In addition to matching our intuition, a model that realizes (from noisy
raw pixels) that the building blocks of text are letters, and is able to extract a representation based
on those, has found meaningful structure in the data, and can prove it by being able to efficiently
compress text images.
Figure 1: Features extracted by HCN. Left: from multiple images. Right: from a single image.
1
Under review as a conference paper at ICLR 2017
However, this is not the case with existing incarnations of the above models1. We can see in Fig. 1
the features recovered by the hierarchical compositional network (HCN) from a single image with no
supervision. They appear to be reasonable building blocks and are easy to find for a human. Yet we
are not aware of any model that can perform such apparently simple recovery with no supervision.
The HCN is a multilayer generative model with features defined at each layer. A feature (at a given
position) is defined as the composition of features of the layer immediately below (by specifying their
relative positions). To increase flexibility, the positions of the composing features can be perturbed
slightly with respect to their default values (pooling). This results in a latent variable model, with
some of the latent variables (the features) being shared for all images while others (the pool states)
are specific for each image.
Comparing HCN with other generative models for images, we note that existing models tend to
have at least one of the following limitations: a) priors are not rich enough; typically, the sources of
variation are not distributed among the layers of the network, and instead the generative model is
expressed as X = f(Y ) +ε where Y and ε are two set of random variables, X is the generated image
and f (∙) is the network, i.e.,the entire network behaves as a sophisticated deterministic function, b)
the inference method (usually a separate recognition network) considers all the latent variables as
independent and does not solve explaining away, which leads to c) the learned features being not
directly interpretable as reusable parts of the learned images.
Although directed models enjoy important advantages such as the ability to represent causal semantics
and easy sampling mechanics, it is known that the “explaining away” phenomenon makes inference
difficult in these models (Hinton et al., 2006). For this reason, representation learning efforts have
largely focused on undirected models (Salakhutdinov & Hinton, 2009), or have tried to avoid the
problem of explaining away by using complementary priors (Hinton et al., 2006).
An important contribution of this work is to show that approximate inference using max-product mes-
sage passing (MPMP) can learn features that are composable, interpretable and causally meaningful.
It is also noteworthy that unlike previous works, we consider the weights (a.k.a. features) to be latent
variables and not parameters. Thus, we do not use separate expectation-maximization (EM) stages.
Instead, we perform feature learning and pool state inference jointly as part of the same message
passing loop.
When augmented with supervision information, HCN can be used for classification, with inference
and learning still being taken care of by a largely unmodified MPMP procedure. After training,
discrimination can be achieved via a fast forward pass which turns out to have the same functional
form as a convolutional neural network (CNN).
The rest of the paper is organized as follows: we describe the HCN model in Section 2; Section 3
describes learning and inference in the single layer and multilayer HCNs; Section 4 tests the HCN
experimentally and we conclude with a brief discussion in Section 5.
2 The Hierarchical Compositional Network
The HCN model is a discrete latent variable model that generates binary images by composing parts
with different levels of abstraction. These parts are shared across all images. Training the model
involves learning such parts from data as well as how to combine them to create each concrete image.
The HCN model can be expressed as a factor graph consisting only of three types of factors: AND,
OR and POOL. These perform the obvious binary operations and will be defined more precisely
later in this section. The flexibility of the model allows training in supervised, semisupervised
and unsupervised settings, including missing image data. Once trained, the HCN can be used for
classification, missing value completion (pixel inference), sparsification, denoising, etc. See Fig. 2
for a factor graph of the complete model. Additional details of each layer type are given in Fig. 4.
At a high level, the HCN consists of a class layer at the top followed by alternating convolutional
layers and pooling layers. Inside each layer there is a sparsification, a representation and weights
1Discriminative models find features that are good for classification, but not for generation (the training
objective is not constrained enough). Existing generative models also fail at recovering the building blocks of an
image because they either a) mix positive and negative weights (which turns out to be critical for them being
trainable via backpropagation) or b) lack inference mechanisms able to perform explaining away.
2
Under review as a conference paper at ICLR 2017
Figure 2: Factor graph of the HCN model when connected to multiple images Xn . The weights are
the only variables that entangle multiple images. The top variables are clamped to 1 and the bottom
variables are clamped to Xn. Additional details of each layer type are given in Fig. 4.
(a.k.a. features), each of which is a multidimensional array of latent variables. The class layer selects
a category, and within it, which template is going to be used, producing the top-level sparsification. A
sparsification is simply an encoding of the representation. A sparsification encodes a representation
by specifying which features compose it and where they should be placed. The features are in turn
stored in the form of weights. Convolutional layers deterministically combine the sparsification and
the weights of a layer to create its representation. Pooling layers randomly perturb the position of the
active elements (within a local neighborhood), introducing small variations in the process.
2.1 Binary convolutional feature layer (single-layer HCN)
This layer can perform non-trivial feature learning on its own. We refer to it as a single-layer HCN.
See Section 4.1 for the corresponding experiments.
In this case, since there is no additional top-down structure, a binary image is created by placing
features at random locations of an image. Wherever two features overlap, they are ORed, i.e., if a
pixel of the binary image is activated due to two features, it is simply kept active. We will call W to
the features, S to the sparsification of the image (locations at which features are placed in that image)
and X to the image. All of these variables are multidimensional binary arrays.
The values of each of the involved arrays for a concrete example with a single-channel image is given
in Fig. 3 (to display S we maximize over f). The corresponding diagram is shown in Fig. 4.
In practice, each image X is possibly multichannel, so it will have size FX × HX × WX, where the
first dimension is the number of channels in the image and the other two are its height and width. S
has size FS × HS × WS, where the first dimension is the number of features and the other two are
its height and width. We refer to an entry of Sn as Sfrc . Setting an entry Sfrc = 1 corresponds to
placing feature f at position (r, c) in the final image X. The features themselves are stored in W,
which has size FbWelow × FW × HW × WW , where FW = FS and FW = FX . I.e., each feature is a
3
Under review as a conference paper at ICLR 2017
(a) Image X (b) Sparsification S (c) Features W (d) Reconstruction R
Figure 3: Unsupervised analysis of image X by a standalone convolutional feature layer of HCN.
small 3D array containing one of the building blocks of the image. Those are placed in the positions
specified by S, and the same block can be used many times at different positions, hence calling this
layer convolutional2 .
We can fully specify a probabilistic model for a binary images by adding independent priors over
the entries of S and W and connecting those to X through a binary convolution and a noisy channel.
The complete model is
p(S)=Yp(Sfrc)=YpSSfrc(1-pS)1-Sfrc
frc	frc
p(W) = Y p(Wafrc) = Y pWWafrc(1-pW)1-Wafrc	(1)
afrc	afrc
p(X|R) =	pnoisy(Xarc|Rarc) with R = bconv(S, W) and pnoisy(1|0) = p10,pnoisy(0|1) = p01,
arc
which depends on four scalar parameters pS, pW , p01, p10, controlling the density of features in the
image, of pixels in each feature, and the noise of the channel, respectively. The indexes a, f, r, c run
over channels, features, rows and columns, respectively.
We have used the binary convolution operator R = bconv(S, W). A binary convolution performs
the same operation as a normal convolution, but operates on binary inputs and truncates outputs
above 1. Our latent variables are arranged as three- and four-dimensional arrays, so we define
R = bconv(S, W) to mean Ra,:,: = min(1, Ef conv2D(Sf,:,:, Wa,f,:,:)) where conv2D(∙, ∙) is the
usual 2D convolution operator, R and S are binary 3D arrays and W is a binary 4D arrays. The
operator min(1, ∙) truncates values above 1 to 1, performing the ORing of two overlapping features
previously mentioned.
The binary convolution (and hence model (1)) can be expressed as a factor graph, as seen in Fig. 4.
The AND factor can be written as AND(b|t1, t2) and takes value 0 when the bottom variable b is the
logical AND of the two top variables t1 and t2. It takes value -∞ in any other case. The OR factor,
OR(b|t1 . . . , tM) takes value 0 when the bottom variable b is the logical OR of the M top variables
t1 . . . , tM. It takes value -∞ in any other case.
When this layer is not used in standalone mode, but inside a multilayer HCN, the variables R are
connected to the pooling layer immediately below (instead of being connected to the image X through
the noisy channel) and the variables S are connected to the pooling layer immediately above (instead
of being connected to the prior).
2.2	The class layer
We assume for now that a single class is present in each image. We can then write
log p(c1, . . . ,cK) = POOL(c1, . . . ,cK|1)
where ck are mutually exclusive binary variables representing which of the K categories is present.
In general, we define POOL(b1, . . . , bM |t = 1) = - log M when exactly one of the bottom variables
b1, . . . , bm takes value 1 (we say that the pool is active), and POOL(b1, . . . , bM |t = 0) = 0 when
bm = 0 ∀m (the pool is off). It takes value -∞ in any other case.
2Additionally, the convolution implies the relations HX = HW + HS - 1 and WX = WW + WS - 1
4
Under review as a conference paper at ICLR 2017
(a) Binary convolution
Figure 4: Diagrams of binary convolution and factor graph connectivity for 1D image.
(C) Pooling layer
Within eaCh Category, we might have multiple templates. EaCh template Corresponds to a different
visual expression of the same conceptual category. For instance, if one category is furniture, we
could have a template for chair and another template for table. Each category has binary variables
representing each of the J templates, sjk with j ∈ [1 . . . J]. If a category is active, exactly one of its
templates will be active. The joint probability of the templates is then
logp(SL|c1, . . . , cK) =	log p(s1k, . . . , sJk|ck) =	POOL(s1k, . . . , sJk|ck)
kk
where these JK variables are arranged as a 3D array of size 1 × 1 × JK called SL which forms
the top-level sparsification of the template. A sample from SL will always have exactly one element
set to 1 and the rest set to 0. Superscript L is used to identify the layer to which a variable belongs.
Since there are L layers, SL is the top layer sparsification.
2.3	The pooling layer
In a multilayer HCN, feature layers and pooling layers appear in pairs. Inside layer `, the pooling
layer ` is placed below the feature layer `.
Since the convolutional feature layer is deterministic, any variation in the generated image must
come from the pooling layers (and the final noisy channel). Each pooling layer shifts the position
of the active units in R to produce the SParSifiCatiOn S'-1 in the layer below. This shifting is local,
constrained to a region of size3 HP × WP × 1, the pooling window. When two or more active units
in R' are shifted towards the same position in S`-1, they result in a single activation, so the number
of active units in S'-1 is equal or smaller than the number of activations in R'.
The above description should be enough to know how to sample S'-1 from R', but to provide a
rigorous probabilistic description, we need to introduce the intermediate binary variables U∆r,∆c,f,r,c,,
which are associated to a shift ∆r, ∆c of the element Rf' rc. The HPWP intermediate variables
associated to the same element R'frc are noted as U:',:,f rc. Since an element can be shifted to a single
position per realization and only when it is active, the elements in U:',:,f rc are grouped into a pool
logp(U'|R') =X log p(U:',:,frc|R'frc) =XPOOL(U:',:,frc|R'frc)
frc	frc
and then S'-1 can be obtained deterministically from U' by ORing the HPWP vari-
ables of U that can potentially turn it on, log p(S'-1 |U') = Pfr0c0 log p(Sf'-r01c0 |U') =
Pfr0c0 OR(Sf-，C，∣{U∆r,∆c,f,r,c}r0+∆r,c0=c+∆c). i.e., the above expression evaluates to 0 if the
above OR relations are satisfied and to -∞ if they are not.
3The described pooling window only allows for spatial perturbations, i.e., translational pooling. A more
general pooling layer would also pool in the third dimension (Goodfellow et al., 2013), across features, which
would introduce richer variation and also impose a meaningful order in the feature indices. Though we do
not pursue that option in this work, we note that this type of pooling is required for a rich hierarchical visual
model. In fact, the pooling over templates that we special-cased in the description of the class layer would fit as
a particular case of this third-dimension pooling.
5
Under review as a conference paper at ICLR 2017
2.4	Joint probability with multiple images
The observed binary image X corresponds to the bottommost sparsification4 S0 after it has traversed,
element by element, a noisy channel with bit flip probabilities p(Xfrc = 1|Sf0rc = 0) = p10 < 0.5
andp(Xfrc = 0|Sf0rc = 1) = p01 < 0.5. This defines p(X|S0).
Finally, if we consider the weight variables to be independent Bernoulli variables with a fixed per-
layer sparse prior PW that are drawn once and shared for the generation of all images, We can write
the joint probability of multiple images, latent variables and weights as
LN
log p({Xn,Hn,Cn}N=ι,{W'}L=ι) = X log p(W') + X log p(Xn∣SM ) + log p(SL∣Cn) +log P(Cn)
'=1	n=1
NL
+xx log P(SnTIUn )+log P(Un 阀)+^ P(Rn ∣sn ,w `)
n=1'=1
where we have collected all the category variables {ck} of each image in Cn and the remaining latent
variables in Hn and for convenience. Each image uses its own copy of the latent variables, but the
weights are shared across all images, which is the only coupling between the latent variables.
The above expression shows how, in addition to factorizing over observations (conditionally on the
weights), there is a factorization across layers. Furthermore, the previous description of each of these
layers implies that the entire model can be further reduced to small factors of type AND, OR and
POOL, involving only a few local variables each.
Since we are interested in a point estimate of the features, given the images {Xn}nN=1 and a (possibly
empty)5 subset of the labels {Cn}nN=1, we will attempt to recover the maximum a posteriori6 (MAP)
configuration over features, sparsifications, and unknown labels. Note that for classification, selecting
{W'}L=ι by maximizing the joint probability is very different from selecting it by maximizing a
discriminative loss of the type logP({Cn}N=ι∣{Xn}N=ι, {W'}L=ι), since in this case, all the prior
information P(X ) about the structure of the images is lost. This results in more samples being
required to achieve the same performance, and less invariance to new test data.
Once learning is complete, we can fix {W'}L=「thus decoupling the model for every image, and use
approximate MAP inference to classify new test images, or to complete them if they include missing
data (while benefiting from the class label if it is available).
Even though we only consider the single-class-per-image setting, the compositional property of this
model means that we can train it on single-class images and then, without retraining, change the class
layer to make it generate (and therefore, recognize) combinations of classes in the same image.
3 Learning and inference
We will consider first the simpler case of a single-layer HCN, as described in Section 2.1. Then we
will tackle inference in the multilayer HCN.
3.1	Learning in single-layer HCN
In this case, for model (1), we want to find
S *,W * = arg max P(X ∣S,W )p(S)p(W ).
S,W
(2)
This is a challenging problem even in simple cases. In fact, it can be easily shown that boolean matrix
factorization (BMF), a.k.a. boolean factor analysis, arises as a particular case of (2) in which the
4Alternatively, one could introduce the noisy channel between R0 and X , but that would be equivalent to our
formulation using a pooling window of size 1 × 1 × 1 at the bottommost layer.
5The model was described as unsupervised, but the class is represented in latent variable Cn, which can be
clamped to its observed value, if it is available.
6Note that we are performing MAP inference over discrete variables, where concerns about the arbitrariness
of MAP estimators (see e.g., (Beal, 2003) Chapter 1.3) do not apply.
6
Under review as a conference paper at ICLR 2017
heights and widths of all the involved arrays are set to one. BMF is a decades-old problem proved to
be NP-complete in (Stockmeyer, 1975) and with applications in machine learning, communications
and combinatorial optimization. Another related problem is non-negative matrix factorization (NMF)
(Lee & Seung, 1999), but NMF is additive instead of ORing the contributions of multiple features,
which is not desired here.
One of the best-known heuristics to address BMF is the Asso (Miettinen et al., 2006). Unfortunately,
it is not clear how to extend it to solve (2) because it relies on assumptions that no longer hold in
the present case. The variational bound of (Jaakkola & Jordan, 1999) addresses inference in the
presence of a noisy-OR gate and was successfully used in by (Singliar & Hauskrecht, 2006) to obtain
the noisy-OR component analysis (NOCA) algorithm. NOCA addresses a very similar problem to
(2), the two differences being that a) the weight values are continuous between 0 and 1 (instead of
binary) and b) there is no convolutional weight sharing among the features. NOCA can be modified
to include the convolutional weight sharing, but it is not an entirely satisfactory solution to the feature
learning problem as we will show. We observed that the obtained local maxima, even after significant
tweaking of parameters and learning schedule, are poor for problems of small to moderate size.
We are not aware of other existing algorithms that can solve (2) for medium image sizes. The model
(1) is directly amenable to mean-field inference without requiring the additional lower-bounding used
in NOCA, but we experimented with several optimization strategies (both based in mean field updates
and gradient-based) and the obtained local maxima were consistently worse than those of NOCA.
In (Ravanbakhsh et al., 2015) it is shown that max-product message passing (MPMP) produces state-
of-the-art results for the BMF problem, improving even on the performance of the Asso heuristic.
We also address problem (2) using MPMP. Even though MPMP is not guaranteed to converge, we
found that with the right schedule, even with very slight or no damping, good solutions are found
consistently.
Model (1) can be expressed both as a directed Bayesian network or as a factor graph using only
AND and OR factors, each involving a small number of local binary variables. Finding features and
sparsifications can be cast as MAP inference7 in this factor graph.
MPMP is a local message passing technique to perform MAP inference in factor graphs. MPMP is
exact on factor graphs without loops (trees). In loopy models, such as (1), it is an approximation with
no convergence guarantees8, although convergence can be often attained by using some damping
0 < α ≤ 1. See Appendix C for a quick review on MPMP and Appendix D for the message update
equations required for the factors used in this work. Unlike Ravanbakhsh et al. (2015) which uses
parallel updates and damping, we update each AND-OR factor9 in turn, following a random in a
sequential schedule. This results in faster convergence with less or no damping.
3.2	Learning in multilayer HCN (unsupervised, semisupervised, supervised)
Despite its loopiness, we can also apply MPMP inference to the full, multilayer model and obtain
good results. The learning procedure iterates forward and backward passes (a precise description can
be found in Algorithm 1 below). In a forward pass, we proceed updating the bottom-up messages to
variables, starting from the bottom of the hierarchy (closer to the image) and going up to the class
layer. In a backward pass, we update the top-down messages visiting the variables in top-down order.
Messages to the weight variables are updated only in the forward pass. We use damping only in
the update of the bottom-up messages from a pooling layer during the forward pass. The AND-OR
factors in the binary convolutional layer form trees, so we treat each of these trees as a single factor,
since closed form message updates for them can be obtained. Those factors are updated once in
random order inside each layer, i.e., sequentially. The pools at the class layer also from a tree, so
we also treat them as a single factor. The message updates for AND, OR and POOL factors follow
trivially from their definition and are provided in Appendix D.
7Note that we do not marginalize the latent variables (or the weights), but find their MAP configuration given
a set of images. The sparse priors on the weights and the sparsification act as regularizers and prevent overfitting.
8MPMP works by iterating fixed point equations of the dual of the Bethe free energy in the zero-temperature
limit. Convexified dual variants (see Appendix C) are guaranteed to converge, but much slower.
9Each OR factor is connected to several AND factors which together form a tree. We update the incoming
and outgoing messages of the entire tree, since they can be computed exactly.
7
Under review as a conference paper at ICLR 2017
After enough iterations, weights are set to 1 if their max-marginal difference is positive and to 0
otherwise. This hard assignment converts some of the AND factors into a pass-through and the rest
in disconnections. Thus the weight assignments define the connectivity between S' and R on a new
graph without ANDs. This is the learned model, that we can use to perform inference with with on
new test images.
3.3	Inference in multilayer HCN
Typical inference tasks are classification and missing value imputation. For classification, we find
that a single forward pass seems good enough and further forward and backward passes are not
needed (see Algorithm 1 for the description of the forward and backward passes). For missing
value imputation a single forward and top-down pass is enough. In order to achieve higher quality
explaining-away10, we use a top-down pass instead of a backward pass. A top-down pass differs from
a backward pass in that we replace step 5) with multiple alternating executions of steps 5) and 2).
Therefore, it is not strictly a backward pass, but it proceeds top-down in the sense that once a layer
has been fully processed, it is never visited again.
Interestingly, the functional form of the forward pass of an HCN is the same as that of a standard
CNN, see Section 3.4, and therefore, an actual CNN can be used to perform a fast forward pass.
Algorithm 1 Learning in Hierarchical Compositional Networks
Input: Hyperparameters p01 ,p10, {pW}L=ι, data {Xn, Cn}N=ι and network structure (pool and weight
sizes for each layer)
Init Initialize bottom-up messages and messages to {W'} to zero. Initialize the top-down messages to -∞.
Initialize messages to W from its prior uniformly at random in (0.9pW, pW) to break symmetry. Set constant
bottom-up messages to S0: Im(Sfrc) = (kι — ko)Xfrc + ko with kι = log 1-p01 and ko = log ι-p1θ
repeat
Forward pass:
for ` in 1, . . . , L do
1)	Update messages from OR to U' in parallel
2)	Update messages from POOL to R in parallel with damping ɑ
3)	Update messages from AND-OR to W' and S' sequentially in random order
end for
Update message from all class layer POOLs to SL . Hard assign Cn if label is available.
Backward pass:
for ` in L, . . . , 1 do
4)	Update messages from AND-OR to R sequentially in random order
5)	Update messages from POOL to U' in parallel
6)	Update messages from OR to S'-1 in parallel
end for
Compute max-marginals by summing incoming messages to each variable
until Fixed point or iteration limit
return Max-marginal differences of S', W' and R
3.4	About the HCN forward pass
3.4.1	Functional correspondence with CNN
After a single forward pass in an HCN (considering that the weights are known, after training), we
get an estimate of the MAP assignment over categories. In practice, this assignment seems good
enough for classification and further forward and backward passes are not needed.
The functional form of the first forward pass can be simplified because of the initial strongly negative
top-down messages. Under these conditions, the message update rules applied to the pooling layers
of the HCN have exactly the same functional form11 as the max-pooling layer in a standard CNN.
Similarly, applying the message update rule to the convolutional layers of the HCN —when the
10 To avoid symmetry problems, instead of making the distribution of each POOL perfectly uniform, we
can introduce slight random perturbations while keeping the highest probability value at the center of the pool.
Doing so speeds up learning and favors centered backward pass reconstructions in the case of ties.
11See the Appendix D for the update rules of the messages of each type factor.
8
Under review as a conference paper at ICLR 2017
weights are known— has the same functional form as performing a standard (not binary) convolution
of the bottom-up messages with the weights, just like in a standard CNN. At the top, the max-marginal
over categories will select the one with the template with the largest bottom-up message. This can be
realized with max-pooling over the feature dimension as done in (Goodfellow et al., 2013), or closely
approximated using a fully connected layer and a softmax, as in more standard CNNs.
Simply put, the binary weights learned by an HCN can be copied to a standard CNN with linear
activations and they will both produce the same classification results when we applied to the bottom-up
messages (which are a positive scaling of the input data X plus a constant).
3.4.2	Invariance to noise level
Consider we generate two data sets with the HCN model using the same weights but different bit-flip
probabilities. If those probabilities are known, would we use different classifiers for each dataset? If
we use a single forward pass, changing p01 and p10 produces a different monotonic transformation of
all the bottom-up messages at every layer of the hierarchy, but the selected category, which depends
only on which variable has the largest value, will not change. So, with a single-pass classifier, our
class estimation does not change with the noise level. This has the important implication that an HCN
does not need to be trained with noisy data to classify noisy data. It can be trained with clean data
(where there is more signal and learning parts is easier) and used on noisy data without retraining.
4	Experiments
In the following, we experimentally characterize both the single-layer and multilayer HCN.
4.1	Single-layer HCN
We create several synthetic (both noisy and noiseless) images in which the building blocks -or
features- are obvious to a human observer and check the ability of HCN to recover the them. The
task is deceptively simple, and the existing the state of the art at this task, NOCA, is unable to solve
several of our examples. Since the number of free parameters of the model is so small (3 in the case
of a symmetric noisy channel), these can be easily explored using grid search and selected using
maximum likelihood. The sensitivity of the results to these parameters is small.
HCN only requires straightforward MPMP with random order over the factors. For NOCA, initializing
the variational posterior over the latent sources and choosing how to interleave the updates of this
posterior with the update of the additional variational parameters (Singliar & Hauskrecht, 2006) is
tricky. For best results, during each E step we repeated the following 10 times: update the variational
parameters for 20 iterations and then update the variational posterior (which is a single closed form
update). The M update also required an inner loop of variational parameter updating.
The performance of HCN and NOCA can be assessed visually in Fig. 5. Column (a) shows each
input image (these are single-image datasets) and the remaining columns show the features and
reconstructions obtained by HCN and NOCA. In some of the input images we have added noise
that flips pixels with 3% probability. For HCN (respectively NOCA), we binarize all the beliefs
(respectively, variational posteriors) from the [0, 1] range by thresholding at 0.5 and then perform a
binary convolution to obtain the reconstruction. Because noise is not included in this reconstruction,
a cleaner image may be obtained, resulting in unsupervised denoising (rows 1 and 4 of Fig. 5).
For a quantitative comparison, refer to Tab. 1. One algorithm-independent way to measure perfor-
mance in the feature learning problem is to measure compression. It is known that to transmit a long
sequence of N bits which are 1 with probability p, we only need to transmit NH(p) bits with an
optimal encoding, where H is the entropy. Thus sparse sequences compress well. In order to transmit
these images without loss, we need to transmit either one sequence of bits (encoding the image
itself) or three sequences of bits, one encoding the features, another encoding the sparsification and a
last one encoding the errors between the reconstruction and the original image. Ideally, the second
method is more efficient, because the features are only sent once and the sparsification and errors
sequences are much sparser than the original image. The ratio between the two is shown together
with running time on a single CPU. Unused features are discarded prior to computing compression.
9
Under review as a conference paper at ICLR 2017
(a) Input image X (b) HCN W
(c) HCN R (d) NOCA W (e) NOCA R
Figure 5: Features extracted by HCN and NOCA and image reconstructions for several datasets. Best
viewed on screen with zoom.
Figure 6: Online learning. (a) and (b) show two sample input images; (c) and (d) show the features
learned by batch and online HCN using 30 input images and 100 epochs; (e) shows the features
learned by online HCN using 3000 input images and 1 epoch.
10
Under review as a conference paper at ICLR 2017
Two bars	Symbols Clean letters Noisy letters	Text
	comp.	time	comp.	time	comp.	time	comp.	time	comp.	time
NOCA	84%	0.67 m	85%	92 m	98%	662 m	102%	716m	84%	1222 m
HCN	83%	0.07 m	11%	0.42 m	38%	25 m	73%	24 m	28%	31 m
Table 1: Comp.: E(X)/(E(S) +E(W) +E(X - R)), where E is the encoding cost. Time: minutes.
4.2	Online learning
The above experiments use a batch formulation, i.e., consider simultaneously all the available training
data {Xn}1N. Since the amount of memory required to store the messages for MPMP scales linearly
with the training data, this imposes a practical limit in the number of images that can be processed.
In order to overcome this limit, we also consider a particular message update schedule in which
the messages outgoing from factors connected to each image and sparsification Xn , Sn are updated
only once and therefore, after an image has been processed, can be discarded, since they are never
reused. This effectively allows for online processing of images without memory scaling issues. Two
modifications are needed in practice for this to work well: first, instead of processing only one
image at a time, better results are obtained if the factors of multiple images (forming a minibatch) are
processed in random order. Second, a forgetting mechanism must be introduced to avoid accumulating
an unbounded amount of evidence from the processed minibatches.
In detail, the beliefs of the variables W are initialized uniformly at random in the interval (0.9pW, pW)
(we call these initial beliefs b(p0ri)or(Wafrc)) and the beliefs of the variables {Sn}1N are initialized to
pS . The initial outgoing messages from all the AND-OR factors are set to 0. Since each factor
is only processed once, this allows implementing MPMP without ever having to store messages
and only requiring to store beliefs. After processing the first minibatch using MPMP (with no
damping), we call the resulting belief over each of the weights b(p0os)t(Waf rc) (as it standard for MPMP
of binary variables, beliefs are represented using max-marginal differences in log space). Instead
of processing the second minibatch using b(p0os)t(Wafrc) as the initial belief, we use b(p1ri)or(Wafrc) =
λb(p0os)t(Wafrc) + (1 - λ)b(p0ri)or(Waf rc), i.e., we “forget” part of the observed evidence, substituting it
with the prior. This introduces an exponential weighing in the contribution of each minibatch. The
forgetting factor is λ ∈ (0, 1] specifies the amount of forgetting. When λ = 1 this reduces to normal
MPMP (no forgetting), when λ = 0, we completely forget the previous minibatch and process the
new one from scratch.
Fig. 6 illustrates online learning. HCN is shown 30 small images containing 5 randomly chosen and
randomly placed characters with 3% flipping noise (see Fig. 5.(a) and (b) for two examples). They
are learned in different manners. Fig. 5.(c): as a single batch with damping α = 0.8 and using 100
epochs (each factor is updated 100 times); Fig. 6.(d): with minibatches of 5 images, no damping,
λ = 0.95 and using 100 epochs; Fig. 6.(e): with minibatches of 5 images, no damping, λ = 0.95,
using a single epoch, but using 3000 images, so that running time is the same.
4.3	Multi-layer HCN: synthetic data
We create a dataset by combining two traits: a) either a square (with four holes) or a circle and b)
either a forward or a backward diagonal line. This results in four patterns, which we group in two
categories, see Fig. 7.(a). Categories are chosen such that we cannot decide the label of an image
based only on one of the traits. The position of the traits is jittered within a 3 × 3 window, and after
combining them, the position of the individual pixels is also jittered by the same amount. Finally,
each pixel is flipped with probability 10-3. This sampling procedure corresponds a 2-layer HCN
sampling for some parameterization. We generate 100 training samples and 10000 test samples.
4.3.1	Unsupervised learning
We train the HCN as described in Section C on the 100 training data samples, not using any label
information. We do set the architecture of the network to match the architecture generating the data.
There are four hyperparameters in this model, p01,p10,p1W,p2W. Their selection is not critical. We
11
Under review as a conference paper at ICLR 2017
will choose them to match the generation process. MAP inference does discover and disentangle
almost perfectly the compositional parts at the first and second layers of the hierarchy, see Figs. 7.(b)
and 8.(a). In 8.(a), rows correspond with templates and columns correspond to each of the features
of the first layer. We can see that the model has “understood” the data and can be used to generate
more samples from it. Performing inference on this model is very challenging. We are not aware of
any previous method that can learn the features of this simple dataset with so few samples. In other
experiments we verified that, using local message passing as opposed to gradient descent was critical
to successfully minimize our objective function. Results with the quality of Figs. 7.(b) and 8.(a) were
obtained in every run of the algorithm. Running time is 7 min on a single CPU.
We can now clamp the discovered weights on both layers and use the fast forward pass to classify
each training image as belonging to one of the four discovered templates (i.e., cluster them). We
can even classify the test images as belonging to one of the four templates. When doing this, all the
images in the training set get assigned to the right template and only 60 out of 10000 images in the
test set do not get classified in the right cluster. This means that if we had just 4 labeled images, one
from each cluster, we could perform 4-class minimally-supervised classification with just 0.6% error.
Finally, we run a single forward-backward pass of the inference algorithm on a test image with
missing pixels. We show the inferred missing pixels in Fig. 7.(c). See also footnote 10.
4.3.2	Supervised learning
Now we retrain the model using label information. This results in the same weights being found, but
this time the templates are properly grouped in two classes, as shown in Fig. 8.(a). Classification error
on the test set is very low, 0.07%. We now compare the HCN classification performance with that of
a CNN with the same functional form but trained discriminatively and with a standard CNN with
ReLU activations, a densely connected layer and softmax activation. We minimize the crossentropy
loss function with L2 regularization on the weights. The test errors are respectively 0.5% and 2.5%,
much larger than those of HCN. We then consider versions of our training set with different levels of
pixel-flipping noise. The evolution of the test error is shown in Fig. 8.(c). For the competing methods
we needed many random restarts to obtain good results. Their regularization parameter was chosen
based on the test set performance.
4.4	Multi-layer HCN: MNIST data
We turn now to a problem with real data, the MNIST database (LeCun et al., 1998), which contains
60000/10000 training/testing images of size 28 × 28. We want to generalize from very few samples,
so we only use the first 40 digits of each category to train. We pre-process each image with a
fixed set of 16 oriented filters, so that the inputs are a 16-channel image. We use a 2-layer HCN
with 32 templates per class and 64 lower level features of size 26 × 26 and two layers of 3 × 3
pooling, p1W = 0.001, p2W = 0.05. These values are set a priori, not optimized. Then we test on
both the regular MNIST training set and different corrupted versions12 of it (same preprocessing
12See Appendix E for examples of each corruption type.
(a) 16 training samples and labels (b) W1, no supervision (c) Missing value imputation
Figure 7: Samples from synthetic data and results from unsupervised learning tasks.
12
Under review as a conference paper at ICLR 2017
(c) Effect of increased noise level
Figure 8: Discriminative vs. generative training and supervised vs. unsupervised generative training.
(a) Supervised, unsupervised (b) W1, discriminative training
(top, bottom) W2
Figure 9: First layer of weights learned by HCN and CNN on the preprocessed MNIST dataset.
Corruption	HCN	CNN
None	11.15%	9.53%
Noise	20.69%	39.28%
Border	16.97%	17.78%
Patches	14.52%	16.27%
Grid	68.52%	82.69%
Line clutter	37.22%	55.77%
Deletion	22.03%	25.05%
(c) Test error with different cor-
ruptions
and no retraining). We follow the same preprocessing and procedure using a regular CNN with
discriminative training and explore different regularizations, architectures and activation types, only
fixing the pooling sizes and number of layers to match the HCN. We select the parameterization that
minimizes the error on the clean test set. This CNN uses 96 low level features. Results for all test
sets are reported on Fig. 9.(c). It can be seen that HCN generalizes better. The weights of the first
layer of the HCN after training are shown in Fig. 9.(a). Notice how HCN is able to discover reusable
parts of digits.
The training time of HCN scales exactly as that of a CNN. It is linear in each of its architectural
parameters: Number of images, number of pixels per image, features at each layer, size of those
features, etc. However, the forward and backward passes of an HCN are more complex and optimized
code for them is not readily available as it is for a CNN, so a significant constant factor separates
the running times of both. Training time for MNIST is around 17 hours on a single CPU. The RAM
required to store all the messages for 400 training images in MNIST goes up to around 150GB. To
scale to bigger training sets, an online extension (see Section 4.2) needs to be used.
5 Conclusions and future work
We have described the HCN, a hierarchical feature model with a rich prior and provided a novel
method to solve the challenging learning problem it poses. The model effectively learns convolutional
features and is interpretable and flexible. The learned weights are binary, which is advantageous for
storage and computation purposes (Courbariaux et al., 2015; Han et al., 2015). Future work entails
adding more structure to the prior, leveraging more refined MAP inference techniques, exploring
other update schedules and further exploiting the generalization-without-retraining capabilities of
this model.
13
Under review as a conference paper at ICLR 2017
References
Matthew James Beal. Variational algorithms for approximate Bayesian inference. University of
London London, 2003.
Matthieu Courbariaux, Yoshua Bengio, and Jean-Pierre David. Binaryconnect: Training deep neural
networks with binary weights during propagations. In Advances in Neural Information Processing
Systems,pp. 3105-3113, 2015.
Sanja Fidler, Marko Boben, and Ales Leonardis. Learning a hierarchical compositional shape
vocabulary for multi-class object representation. arXiv preprint arXiv:1408.5516, 2014.
Amir Globerson and Tommi S Jaakkola. Fixing max-product: Convergent message passing algorithms
for MAP LP-relaxations. In Advances in Neural Information Processing Systems, pp. 553-560,
2008.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in Neural
Information Processing Systems, pp. 2672-2680, 2014.
Ian J Goodfellow, David Warde-Farley, Mehdi Mirza, Aaron Courville, and Yoshua Bengio. Maxout
networks. arXiv preprint arXiv:1302.4389, 2013.
Song Han, Huizi Mao, and William J Dally. Deep compression: Compressing deep neural networks
with pruning, trained quantization and huffman coding. arXiv preprint arXiv:1510.00149, 2015.
Tom Heskes. Stable fixed points of loopy belief propagation are local minima of the bethe free energy.
In Advances in neural information processing systems, pp. 343-350, 2002.
Geoffrey E Hinton, Simon Osindero, and Yee-Whye Teh. A fast learning algorithm for deep belief
nets. Neural computation, 18(7):1527-1554, 2006.
Tommi S Jaakkola and Michael I Jordan. Variational probabilistic inference and the qmr-dt network.
Journal of artificial intelligence research, 10:291-322, 1999.
Ya Jin and Stuart Geman. Context and hierarchy in a probabilistic image model. In 2006 IEEE
Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’06), volume 2,
pp. 2145-2152. IEEE, 2006.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint
arXiv:1312.6114, 2013.
Daphne Koller and Nir Friedman. Probabilistic graphical models: principles and techniques. MIT
press, 2009.
Vladimir Kolmogorov. Convergent tree-reweighted message passing for energy minimization. Pattern
Analysis and Machine Intelligence, IEEE Transactions on, 28(10):1568-1583, 2006.
Yann LeCun, Leon Bottou, YoshUa Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
Daniel D Lee and H Sebastian Seung. Learning the parts of objects by non-negative matrix factoriza-
tion. Nature, 401(6755):788-791, 1999.
Talya Meltzer, Amir Globerson, and Yair Weiss. Convergent message passing algorithms - a unifying
view. In Jeff A. Bilmes and Andrew Y. Ng (eds.), UAI, pp. 393-401, 2009.
Pauli Miettinen, Taneli Mielikainen, Aristides Gionis, Gautam Das, and Heikki Mannila. The discrete
basis problem. In European Conference on Principles of Data Mining and Knowledge Discovery,
pp. 335-346. Springer, 2006.
Tom Minka et al. Divergence measures and message passing. Technical report, 2005.
Andriy Mnih and Karol Gregor. Neural variational inference and learning in belief networks. arXiv
preprint arXiv:1402.0030, 2014.
14
Under review as a conference paper at ICLR 2017
Ankit B Patel, Tan Nguyen, and Richard G Baraniuk. A probabilistic theory of deep learning. arXiv
preprint arXiv:1504.00641, 2015.
Judea Pearl. Probabilistic reasoning in intelligent systems: networks of plausible inference. 1988.
Hoifung Poon and Pedro Domingos. Sum-product networks: A new deep architecture. In Computer
Vision Workshops (ICCVWorkshoPs),2011 IEEE International Conference on,pp. 689-690. IEEE,
2011.
Siamak Ravanbakhsh, Barnabas Poczos, and Russell Greiner. Boolean matrix factorization and noisy
completion via message passing. 2015.
Ruslan Salakhutdinov and Geoffrey E Hinton. Deep boltzmann machines. In AISTATS, volume 1, pp.
3, 2009.
Shimony. Finding MAPs for belief networks is NP-hard. AIJ: Artificial Intelligence, 68, 1994.
Zhangzhang Si and Song-Chun Zhu. Learning and-or templates for object recognition and detection.
IEEE transactions on pattern analysis and machine intelligence, 35(9):2189-2205, 2013.
Tomas Singliar and Milos Hauskrecht. Noιsy-or component analysis and its application to link
analysis. Journal of Machine Learning Research, 7(Oct):2189-2213, 2006.
Larry J Stockmeyer. The set basis problem is NP-complete. IBM Thomas J. Watson Research
Division, 1975.
Huayan Wang and Koller Daphne. Subproblem-tree calibration: A unified approach to max-product
message passing. In Proceedings of the 30th International Conference on Machine Learning
(ICML-13), pp. 190-198, 2013.
Tomas Werner. A linear programming approach to max-sum problem: A review. IEEE Trans. Pattern
Analysis and Machine Intelligence, 29(7):1165-1179, July 2007.
Christopher KI Williams and Nicholas J Adams. Dts: dynamic trees. Advances in neural information
processing systems, pp. 634-640, 1999.
Ying Nian Wu, Zhangzhang Si, Haifeng Gong, and Song-Chun Zhu. Learning active basis model for
object detection and recognition. International journal of computer vision, 90(2):198-235, 2010.
Long Zhu, Yuanhao Chen, Yifei Lu, Chenxi Lin, and Alan Yuille. Max margin and/or graph learning
for parsing the human body. In Computer Vision and Pattern Recognition, 2008. CVPR 2008.
IEEE Conference on, pp. 1-8. IEEE, 2008.
Long Zhu, Yuanhao Chen, Alan Yuille, and William Freeman. Latent hierarchical structural learning
for object detection. In Computer Vision and Pattern Recognition (CVPR), 2010 IEEE Conference
on, pp. 1062-1069. IEEE, 2010.
15
Under review as a conference paper at ICLR 2017
A Related work
There is a plethora of previous works that address hierarchical feature learning, usually in the setting
or real-valued images, as opposed to binary ones: Fidler et al. (2014); Zhu et al. (2008; 2010);
Wu et al. (2010); Si & Zhu (2013); Poon & Domingos (2011). Many of those works explicitly
use AND-OR graphs, in the same spirit as our work. The most outstanding difference, however,
between previous works and HCN is that HCN allows multiple features to overlap, thus creating
new compositions. For instance, if feature H is a centered horizontal line and feature V is a centered
vertical line, HCN can create a new feature “cross” that combines both, and the fact that both are
overlapping and sharing a common active pixel (and many common inactive pixels) is properly
handled. In contrast, previously cited models cannot overlap features, so they partition the input space
and dedicate separate subtrees to each of them, and do so recursively. We can see in Figure 5, top row,
how we can generate 25 different cross variations using only two features. This would not be possible
with any of the cited models, which would need to span each combination as a separate feature. This
fundamental difference makes HCN combinatorially more powerful, but also less tractable. Both
learning and inference become harder because feature reuse introduces the well-known “explaining
away” phenomenon (Hinton et al., 2006).
As a side, note the difference between the meaning of “OR” as used in the present work and in
previous works on AND-OR graphs: what they call “OR”, is what we term POOL (an exclusive
bottom-up OR of elements), whereas HCN has a novel third type of gate, the “OR” connection (a
non-exclusive, top-down OR of elements) to be able to handle explaining away. Standard AND-OR
(or more clearly, AND-POOL) graphs lack the top-down ORing and therefore are not able to handle
explaining away.
In the compositional hierarchies of Fidler et al. (2014), the lack of feature reuse allows for inference
to be exact, since the graphical model is tree-like. Features are learned using a heuristic that relies
on the exact inference, similar in spirit to EM. The AND-OR template learning methods of (Zhu
et al., 2008; 2010) use respectively max-margin and incremental concave-convex procedures to
optimize a discriminative score. Therefore they require supervision (unlike HCN) and a tractable
inference procedure (to make the discriminative score easy to optimize), which again is achieved
by not allowing overlapping features. The sum-product networks (SPNs) of (Poon & Domingos,
2011) express features as product nodes. In order to achieve feature overlapping, two product nodes
spanning the same set of pixels (but with possibly different activation patterns) should be active
simultaneously. This would violate the consistency requirement of SPNs, making HCN a more
compact way to express feature overlap13 (with the price to be paid being lack of exact inference).
The AND-OR template (AOT) learning of (Wu et al., 2010) again cannot deal properly with the
generation of superimposed features, having to create new features to handle every combination. In
Section B we will compare AOT feature learning and HCN feature learning and check how these
limitations make AOT unable to disentangle the generative features.
Grammars exclude the sharing of sub-parts among multiple objects or object parts in a parse of the
scene (Jin & Geman, 2006), and they limit interpretations to single trees even if those are dynamic
(Williams & Adams, 1999). Our graphical model formulation makes the sharing of lower-level
features explicit by using local conditional probability distributions for multi-parent interactions, and
allows for MAP configurations (i.e, the parse graphs) that are not trees.
The deep rendering model (DRM) of Patel et al. (2015) is, to some extent, a continuous counterpart
of the present work. Although DRMs allow for feature overlap, the semantics are different: in HCN
the amount of activation of a given pixel is the same whether there are one or many features (causes)
activating it, whereas in DRM the activation is proportional to the number of causes. This means that
the difference between DRM and HCN is analogous to the difference between principal component
analysis and binary matrix factorization: while the first can be solved analytically, the second is hard
and not analytically tractable. This results in DRM being more tractable, but less appropriate to
handle problems with binary events with multiple causes, such as the ones posed in this paper.
Two popular approaches to handle learning in generative models, largely independent of the model
itself, are variational autoencoders (VAEs) and generative adversarial networks (GANs). We are not
13An exponentially big SPN could indeed encode an HCN.
16
Under review as a conference paper at ICLR 2017
Figure 10: Results of training a modified HCN on a grayscale image. A filter bank is convolved with
the input image to provide the bottom up messages to each channel of HCN. The filter bank sizes in
this simple example are adapted to match those of generation. As a benchmark, Wu et al. (2010) is
used on the same data and is also given knowledge of the filter bank in use. Top row: 3 × 3 filter size.
Bottom row: 7 × 7 filter size.
aware of any work that uses a VAE or GAN with a generative model like HCN and such an option is
unlikely to be straightforward.
Most common VAEs rely on the reparameterization trick for variance reduction. However, this
trick cannot be applied to HCN due to the discrete nature of its variables, and alternative methods
would suffer from high variance. Another limitation of VAEs wrt HCN is that they perform a single
bottom-up pass and lack of explaining away: HCN combines top-down and bottom-up information in
multiple passes, isolating the parent cause of a given activation, instead of activating every possible
cause.
GANS need to compute VWD(GW(ε)) where D(∙) is the discriminative network and GW(ε) is a
generative network parameterized by the features W. In this case, not only W is binary, but also the
generated reconstructions at every layer, so the GAN formulation cannot be applied to HCN as-is.
One could in principle relax the binary assumption of features and reconstructions and use the GAN
paradigm to train a neural network with sigmoidal activations, but it is unclear that the lack of binary
variables will still produce proper disentangling (the convolutional extension of NOCA also has this
problem due to the use of non-binary features and produces results that are inferior to HCN).
B Combining with grayscale preprocessing
The HCN is a binary model. However, to process real-valued data, it can be coupled with an
initial grayscale-to-binary preprocessing step to do feature detection. We tested this by generating a
grayscale version of our toy data and then computing the bottom-up messages to S0 by convolving
the input image with a filter bank. This is roughly equivalent to replacing the noisy binary channel
of HCN with a Gaussian channel. We used 16 preprocessing filters, which means that S0 has 16
channels. 200 training images (unsupervised) were used. Two filter sizes, 3 × 3 and 7 × 7 were tested.
We also run the AOT feature learning method of Wu et al. (2010) on the same data for comparison.
The results of training on 200 training images (unsupervised) is provided in Figure 10. When the
larger filter is used, the diagonal bars are harder to identify so their disentangling is poorer.
C Max-product message passing (MPMP)
The HCN model can be expressed both as a directed Bayesian network or as a factor graph using
only POOL, AND, and OR factors, each involving a small number of local binary variables. Both
17
Under review as a conference paper at ICLR 2017
learning and ulterior classification can be cast as MAP inference in this factor graph. Other tasks,
such as filling in unknown image data can also be performed by MAP inference.
MAP inference can be performed exactly on factor graphs without loops (trees) in linear time, but it
is an NP-hard problem for arbitrary graphs (Shimony, 1994). The factor graph describing our model
is highly structured, but also very loopy.
There is large body of works (Wang & Daphne, 2013; Meltzer et al., 2009; Globerson & Jaakkola,
2008; Kolmogorov, 2006; Werner, 2007), addressing the problem of MAP inference in loopy factor
graphs. Perhaps the simplest of these methods is the max-product algorithm, a variant of dynamic
programming proposed in (Pearl, 1988) to find the MAP configuration in trees.
The max-product algorithm defines a set of messages ma→i(yi) going from each factor a to each of
its variables y%. The sum of the messages incoming to a variable μ(yi) = P,ayi ∈ya ma―i(yi) defines
its approximate max-marginal14 μ(yi). The max-product algorithm then proceeds by updating the
outgoing messages from each factor in turn so as to make the approximate max-marginals consistent
with that factor. This algorithm is not guaranteed to converge if there are loops in the graph, and if it
does, it is not guaranteed to find the MAP configuration. Damping the updates of the factors has been
shown to improve convergence in loopy belief propagation (Heskes, 2002) and was justified as local
divergence minimization in (Minka et al., 2005). Using a damping factor 0 < α ≤ 1 for max-product,
the update rule is
ma→i(yi) = (I-O)ma→i (yi) + α maχlog φa(yi,ya∖i) +
mta→j (yj ) + κ
yj ∈ya∖i
(3)
and the original update rule is recovered for α = 1. The value κ is arbitrary and does not affect the
algorithm. We select it to make mta+→1i(yi = 0) = 0, so that messages can be stored as a single scalar.
When storing messages in this way, their sum provides the max-marginal difference, which is enough
for our purposes.
Eq. (3) can be computed exactly for the three type of factors appearing in our graph, so message
updating can be performed in closed form. Despite the graph of our model being very loopy, it
turns out that a careful choice of message initialization, damping and parallel and sequential updates
produces satisfactory results in our experiments. For further details about max-product inference and
MAP inference via message passing in discrete graphical models we refer the reader to (Koller &
Friedman, 2009).
D	Max-product mes sage updates for AND, OR and POOL factors
In the following we provide the message update equations for the different types of factors used in the
main paper. The messages are in normalized form: each message is a single scalar and corresponds
to the difference between the unnormalized message value evaluated at 1 and the unnormalized
message value evaluated at 0. For each update We assume that the incoming messages mIN(∙) for all
the variables of the factor are available. The incoming messages are the sum of all messages going to
that variable except for the one from the factor under consideration.
The outgoing messages are Well-defined even for ±∞ incoming messages, by taking the correspond-
ing limit in the expressions beloW.
D. 1 AND factor
Bottom-up messages
mOUT(t1) = max(0, mIN(t2) + mIN(b)) - max(0,mIN(t2))
mOUT(t2) = max(0,mIN(t1) + mIN(b)) - max(0,mIN(t1))
Top-doWn message
m°UT(b) = min(mIN(tι) + m]√t2), mz(tι), mIN(t2))
14The max-marginal of a variable in a factor graph gives the maximum value attainable in that factor graph
for each value of that variable.
18
Under review as a conference paper at ICLR 2017
(a) AND factor	(b) POOL factor	(c) OR factor
Figure 11:	Factors and variable labeling used in the message update equations.
D.2 POOL FACTOR
Bottom-up message
mOUT(t) = max(mIN(bι),…,mIN(bM)) - log M
Top-down messages
mOUT(bm) = min(mIN(t) - log M, - maxmIN(bj))
j=m
D.3 OR FACTOR
Bottom-up messages
mOUT(tm) = min(mIN(b) + E max(0, mIN(tj)), max(0, mjw(ti)) - mw(ti)) With i = argmaxmIN(ti)
./	i=m
j=m
Top-down message
mOUT(b) = mIN(ti) + £max(0, mw(tj)) with i = argmaxmIN(tm)
• /.	m
j=i
19
Under review as a conference paper at ICLR 2017
E Image corruption type illustration
The different types of image corruption used in Section 4.4 are shown in the following Figure:
grid line clutter deletion
Figure 12:	Different types of noise corruption used in Section 4.4.
20