Under review as a conference paper at ICLR 2017
Nonparametrically Learning Activation
Functions in Deep Neural Nets
Carson Eisenach
Princeton University
eisenach@princeton.edu
Han Liu
Princeton University
hanliu@princeton.edu
Zhaoran Wang
Princeton University
zhaoran@princeton.edu
Ab stract
We provide a principled framework for nonparametrically learning activation
functions in deep neural networks. Currently, state-of-the-art deep networks treat
choice of activation function as a hyper-parameter before training. By allowing
activation functions to be estimated as part of the training procedure, we expand
the class of functions that each node in the network can learn. We also provide a
theoretical justification for our choice of nonparametric activation functions and
demonstrate that networks with our nonparametric activation functions generalize
well. To demonstrate the power of our novel techniques, we test them on image
recognition datasets and achieve up to a 15% relative increase in test performance
compared to the baseline.
1	Introduction
Deep learning techniques have proven particularly useful in the classification setting, recently sur-
passing even human performance on some image-classification tasks. We seek to advance the state
of the art by learning not only weights between neurons in the network but also part of the net-
work structure itself - the activation functions. Current deep learning literature largely focuses on
improving architectures and adding regularization to the training process.
By contrast, the realm of learning the network structure itself is relatively unexplored. Current best
practice often treats network size, shape and choice of activation function as a hyper-parameter to
be chosen empirically. Instead, we propose to learn the activation functions through nonparametric
estimation. We introduce a class of nonparametric models for activation functions. Importantly,
we ensure that our technique can be incorporated into the back-propagation framework. This is
crucial because it means our method can be easily added to current practice. To this end, we propose
learning functions via basis expansion. In particular, we find that using a Fourier basis works well
in practice and offers improved performance over the baseline on several benchmark datasets. We
see relative improvements in test error rates of up to 15%. Nonparametric activation functions in
dropout nets are especially successful.
We also introduce a two-stage training process. First, a network without nonparametric activation
functions is trained. Then, the learned network is used as an initialization for an identical network
with nonparametric activation functions. This method of initializing the network yields considerable
improvements in performance for convolution neural networks on image classification tasks.
Lastly, we consider the algorithmic stability approach to accessing generalization bounds. We use
this to demonstrate that feed-forward networks with our method of nonparametrically estimating
activation functions generalize well.
To summarize, our contributions are the following:
•	A theoretically justified framework for learning activation functions in a neural network,
1
Under review as a conference paper at ICLR 2017
•	Provable bounds on the generalization error of networks where the activation functions are
learned, and
•	An optional two-stage training process that can greatly improve results for certain network
architectures, specifically those with convolution layers.
2	Related Works
Recent work from Agostinelli et al. (2015) describes piecewise linear activation functions. Theoret-
ically speaking, our approach improves upon this by fully exploring the space of possible activation
functions - not merely considering those which are piecewise linear.
Learning activation functions, in conjunction with the weights in the layer transformations, allows
for the fitting ofan arbitrary function of the output of the previous layer. A similar idea is Network in
Network, due to Lin et al. (2013). There the authors propose to replace standard convolution layers
with what they call mlpconv layers. Traditional convolution layers, if using a sigmoid activation,
are essentially learning a generalized linear model of the previous layer’s output. Their innovation
is to use a more general nonlinear function estimator as the filter - a multilayer perceptron. Thus,
their scheme fits in the back-propagation framework and so is easy to implement. Our approach
is different because though we are learning arbitrary functions of the previous layer, our activation
function approach can be used in any layer of the network and in networks without convolution
layers, which theirs cannot.
Maclaurin et al. (2015) propose to learn the hyper-parameters of a neural net through reverse gradient
descent. This is similar to the work we present here in that they also provide a method for learning
parameters of the network.
3	Nonparametric Activation Functions
Here we describe our main contribution: the nonparametric activation function model. We also
provide justification for a weight tying scheme to use nonparametric activations in conjunction with
convolution layers, a regularization which proves powerful empirically (see Section 5).
3.1	Fourier Basis Expansion for Activation Functions
For the nonparametric estimation we use a Fourier series basis expansion. One concern, however,
with Fourier basis expansion is that function approximation over a fixed interval often exhibits poor
tail behavior. To combat that, we fit the approximation over an interval [-L, L] and then use it over
truncation of the interval, [-L+T, L+T]. The designation NPF stands for Nonparametric Fourier
Basis Expansion for Activation Functions.
Definition 3.1. Given some sample size n, an interval [-L, L] and tail truncation T where 0 ≤ T ≤
L, the activation function NPF(L, T) is parametrized by (a0, . . . , ak) and (b1, . . . , bk) given by
{ao + Pk=I a% cos((-L + T)iπx∕L) + bi sin((-L + T)iπx∕L) x < -L + T
ao + Pk=I a，i cos(iπx∕L) + b sin(iπx∕L)	-L + T ≤ X ≤ L — T
ao + Pk=I ai Cos((L — T)iπx∕L) + b sin((L — T)iπx∕L) x > L — T
k grows with sample size n and is given by k = dn1/7e.
We choose to present basis expansion of arbitrary functions on the interval [-L, L] because it is
thought to be advantageous in practice to train neural networks with activation functions that are anti-
symmetric through the origin (LeCun et al., 1998). Though the nonparametric activation functions
learned may not be symmetric about the origin, this approach will hopefully result in them being as
close to symmetric as possible.
Each node in the fully connected layers estimates a potentially different activation function. How-
ever, in the convolution layers one activation function is learned per filter. The power of a convolu-
tion net is the weight tying scheme in the convolution layer, and we preserve that by only estimat-
ing one activation function per filter. In Section 5 the effectiveness of this approach can be seen.
2
Under review as a conference paper at ICLR 2017
NPFC(L, T) is the notation for the nonparametrically estimated activation functions in convolution
layers. Figure 1 shows some examples of activation functions learned on the CIFAR-10 dataset.
Figure 1: Examples of activation functions learned for convolution layers on CIFAR-10. Specifically
these are of the type NPFC(4, 1). k = 5
3.2	Training with Learned Activation Units
A practical difficulty is that training nonparametric deep nets often proved unstable, specifically for
networks with convolution layers. To remedy this our two-stage procedure is given as a generic
description in Algorithm 1.
Algorithm 1 Generic TWo Stage Training for Deep Convolutional Neural Networks
Input: A network architecture, hyper parameters T ,L
1:	Instantiate a network with ReLU activations in convolution layers and NPF(T, L) in all others.
2:	Run training algorithm of choice.
3:	Instantiate anew network with NPFC(T, L) activations in convolution layers and NPF(T, L) in
all others. Instantiate all weights from the trained network. Instantiate NPFC(T, L) as desired.
4:	Run training algorithm of choice.
5:	return Network weights resulting from the second training.
One point that is not immediately clear is how to initialize NPF(L, T) activation functions. A good
initialization, of any parameter in the network, is crucial to the success of fitting the model. We
choose to initialize them to the Fourier series approximation of the tanh function. This works quite
well as will be seen in Section 5.
Also left to choice is how to perform both stages of training. Of particular interest is the training
method used for the second stage. We explored the following two approaches:
•	In stage 2, train only the nonparametric activation functions, holding the remainder of the
network constant.
•	In stage 2, train all weights in the network together.
We discovered that both methods are successful, but allowing for the activations and weights in the
network to be trained together gave slightly better results empirically, so it is those that are reported
in Section 5.
Figure 2a shows the training path for a convolution network on the CIFAR-10 dataset. The network
has three convolution layers followed by two fully connected layers. It is initially trained with recti-
fied linear units as activations in the convolution layers and with NPF(4, 1) activations in the fully
connected layers. The stage two network, instead, has NPFC(4, 1) activations in the convolution
layer.
3
Under review as a conference paper at ICLR 2017
(a)	The training and testing error paths during training. Notice the jump in error rate after stage two
begins, but that ultimately it settles into better generalization performance. This is for a convolu-
tional neural net with three convolution and two fully connected layers trained on CIFAR-10.
Number of Weight Updates
(b)	Test errors for a convolution neural net trained on CIFAR-10. Each line represents one network
trained with random initialization. Five random initializations and training paths for each network
type are shown.
4
Under review as a conference paper at ICLR 2017
4 Algorithmic Stability Approach to Generalization Bounds
For our model to be theoretically sound, its generalization error should vanish with a sufficiently
large sample size. This is true for standard neural networks, and such generalization bounds are well
known (for example via VC bounds (Bartlett & Anthony, 1999)). However, because we expand the
function class, we can not naively apply the traditional results. Instead of the VC bound route, we
take the algorithmic stability approach.
In recent work from Hardt et al. (2015) the authors explore a class of bounds for stochastic gradient
methods. They build on the definition of stability given in Bousquet & Elisseeff (2002). Denote by
f (w, z) some loss function of the output of a model, where w indicates the parameters of the learned
model and z is an example from X × Y , the space of data and labels. A is an algorithm and D is the
training data. Denote w = A(D) as the parameters of the model learned by the algorithm A. We
take the following definition from Hardt et al. (2015).
Definition 4.1. An algorithm is -uniformly stable if for all data sets D, D0 ∈ (X × Y )n such that
D, D0 differ in at most one example, we have
supEA[f(A(D),z)-f(A(D0),z)]≤.
z
The expectation is taken with respect to any randomness present in the algorithm itself. By
stab(A, n) be the infimum over all for which the statement holds.
Both Bousquet & Elisseeff (2002); Hardt et al. (2015) present Theorem 4.2 regarding the general-
ization ability of -uniformly stable algorithms is given
Theorem 4.2. Take some algorithm -uniformly stable algorithm A. Then
|ED,A[RD[A(D)] - R[A(D)]]| ≤.
The notation RD [w] signifies the empirical risk when the loss function depends on w in addition to
z. Likewise for the notation RD[A(D)]. Lastly, we have Theorem 4.5 also from Hardt et al. (2015)
that will allow us to derive a generalization bound for our model trained with stochastic gradient
descent.
Definition 4.3. A function f is L-Lipschitz if for all points u, v ∈ dom(f),
|f(u) -f(v)| ≤ L||u - v||.
Definition 4.4. A function f : Ω → R is β-smooth if for all u, v ∈ Ω,
IVf(U)-▽/(v)ll≤ βl∣u - v||.
Theorem 4.5. Assume that f (；Z) ∈ [0,1] is an L-LiPschitz and β-smooth loss function for every
z. Suppose that we run SGM for T steps with monotonically non increasing step sizes αt ≤ c/t.
Then SGM has uniform stability with
estab ≤ 1 + 11βc(2cL2)βc+τT舟.
n-1
In Particular, uP to some constant factors, the following relationshiP aPProximately holds
T 1-1∕(βc+1)
estab ≤	.
n
(Hardt et al., 2015)
In order to aPPly the theorem, we demonstrate our network architecture and choice of loss function
meets this requirement. Once e-stability is established, generalization follows by Theorem 4.2.
4.1 FEED -FORWARD NETWORKS WITH NPF(T, L) ACTIVATIONS
For the full Proofs of results in this section, see APPendix A. Assume a network architecture of Q
fully connected hidden layers (affine transformation layers) fed into a softmax layer which classifies
into one of c classes. The weight vector for the network w should be viewed as the all Parameters of
the affine transformations and activation functions.
The loss function is the negative log-likelihood of the network outPut, which is a softmax over c
classes. We treat the softmax layer as two layers for the PurPoses of demonstrating the generalization
5
Under review as a conference paper at ICLR 2017
bound. One layer is an affine transformation of the output of the lower layers in the network to c
nodes. We will denote the result of this computation at each node i in the affine transformation layer
within the softmax layer as gQ+1(w, x)i. The second layer maps the outputs at these c nodes to c
nodes - this will be the network output. It computes at the the ith node
…=Pcexp gQ+1(w,；)\ .
i=1 exp gQ+1(w, x)i
Thus, on some training example (x, y), the negative log-likelihood of the network output is
f(w, (x, y)) = - log(oi(w, x)) = -gQ+1(w, x)y + log XexpgQ+1(w,x)c
If we can demonstrate that this f has the desired properties, then the generalization bound given in
Section 4 will apply.
One point to note is that in order to control the gradients of the various transformations in the
layers in the network, we need to control the norm of the weight matrices W and biases b in the
affine layers and the coefficients of the activations NPF(L, T ). This is a common technique and is
compatible with the framework in Hardt et al. (2015), as it only makes updates less expansive. Note
that though f does not have range [0, 1], it is bounded due to the max-norm constraints and can be
rescaled. Some smoothing is assumed in order achieve the bound, but in practice the smoothing is
not a concern as it can be assumed to take place in an -neighborhood of the transition from one
piece of the activation function to another. The smoothed nonparametric activation functions are
denoted NPF(L, T). Recall that k = dn1/7e.
Theorem 4.6.	Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network. Then
there exists some K such that the loss function as given in Section 4.1 is K-Lipschitz. Specifically,
for any such network where the number of hidden layers Q ≥ 1 and there are p nodes per layer,
K = max no (√Q(PQ+1k3Q+p尸1)/2k3QTL))
,O
代(pQ+1k3Q+p(2Q+1)/2k3QTL)
eQLQ
.
Proof. The full proof is in Appendix A. The proof idea is to bound the first partial derivatives of
the loss function f with respect to each parameter in the network. Then we can proceed recursively
down through the network to obtain a bound. From there the gradient can be bounded, implying the
loss function f is Lipschitz.	□
Theorem 4.7.	Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network. Then
there exists some K such that the loss function as given in Section 4.1 is β-smooth. Specifically, for
any such network where the number of hidden layers Q ≥ 1 and there are p nodes per layer,
β = max (O(Qp3LI)，O V"'" + 1!).
Proof. The full proof is in Appendix A. The proof idea is to bound the second partial derivatives of
f with respect to each of the parameters in the network. Then We can bound ∣λmaχ(V2f) | and thus
the largest singular value. This gives an upper bound of β on ∣∣V2f l∣2, implying f is β-smooth. □
Theorem 4.8. Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network.
Then, for all practical values of L,T ,,Q and p, the resulting Lipschitz constant K and smoothness
constant β are sufficiently large that
Cstab ≤	7.
n-1
Thus if T = O(√n), Estab → 0 as sample size n → ∞.
Proof. By Theorems 4.5, 4.6, and 4.7 the result is immediate.
□
6
Under review as a conference paper at ICLR 2017
5	Experimental Results
In this section we provide empirical results for our novel nonparametric deep learning model. The
goal of these experiments is to demonstrate its efficacy when used with several different architectures
and on several different datasets, not to beat the current best result on either dataset. Crucially, our
experiments provide an apples to apples comparison between networks with identical architectures
and employing the same regularization techniques where the only difference is choice of activation
function. The generalization results from the Section 4 are directly relevant to the experimental
results here. In all experiments listed in this section, the reported testing error is an estimation of the
generalization error because the final training error was zero in all cases.
5.1	Implementation, Regularization and Architectures
To implement the various deep architectures, we use the Python CPU and GPU computing library
Theano (Bergstra et al., 2010). We use Theano as an interface to the powerful CUDA and CuDNN
libraries (John Nickolls, 2008; Chetlur et al., 2014) enabling fast training for our neural networks.
We ran our simulations on Princeton’s SMILE server and TIGER computing cluster. The SMILE
server was equipped with a single Tesla K40c GPU, while the TIGER cluster has 200 K20 GPUs.
We use early stopping and dropout as regularization techniques (Srivastava et al., 2014; Hardt et al.,
2015). The error rate reported for each experiment is the lowest testing error seen during training.
A common deep network architecture consists 3 stacked convolutional layers with 2 fully connected
layers on top (Srivastava et al., 2014; Agostinelli et al., 2015). The convolutional layers have 96,
128, and 256 filters each and each layer has a 5 × 5 filter size that is applied with stride 1 in both
directions. The max pooling layers pool 3 × 3 fields and are applied with a stride of 2 in both
directions. We use this architecture for the more challenging CIFAR-10 dataset.
5.2	MNIST
This dataset consists of 60,000 training and 10,000 testing images. Images are 28 × 28 rasterized
grayscale images - that is they have one channel. All data points are normalized before training by
taking the entire combined dataset, finding the maximum and minimum entry, then centering and
rescaling. The dataset is from Lecun & Cortes (1999).
The experiments investigate the effects of our techniques on standard multilayer neural networks
as well as convolutional neural networks. Specifically, for the standard neural networks we use
networks with three fully connected hidden layers with 2048 units in each layer fed into a 10-way
softmax.
The convolutional neural networks in these experiments have two convolutional layers with 32 and
64 filters respectively. Filters are 5 × 5 and these layers are followed by a max pooling layer with
2 × 2 pool size. The feed-forward networks consist of3 fully connected layers with 2048 units each.
A mini-batch size of 250 was used for all experiments.
Table 1 contains the results from the MNIST baseline experiments.
Table 1: MNIST baseline comparisons
Name	Layers (Units)	Activation	Best Error	Mean Error
Baseline Neural Net	3 (2048)=	tanh	1.66%	1.79%	,
Baseline Neural Net	3 (2048)	ReLU	1.65%	1.76%
Baseline NN with Dropout	3 (2048)	ReLU	1.35%	1.42%
Baseline CNN	N/A	ReLU	0.88%	0.96%
Baseline CNN with Dropout	N/A	ReLU	0.78%	0.84%
For the experiments with NPF(L, T) activations, we use the same fully connected and convolutional
architectures as in the MNIST baseline experiments. Table 2 contains the results of the experiments.
Learning activation functions via Fourier basis expansion offers sizable improvements on the
MNIST dataset as can be seen in Table 2. No experiments were done using our two-stage tech-
7
Under review as a conference paper at ICLR 2017
Table 2: MNIST experiments with Fourier basis expansion. Conv. Act. is the activation function
in the convolutional layers (if present). F.C. Act. is the activation function in the fully connected
layers. Epochs is the mean number of epochs in training. Results of note appear in bold.
Architecture	Dropout	Conv. Act.	FC Act.	Best Error	Mean Error	Epochs
NN 二	No	N/A 二	NPF(4,1)	1.60%	1.64%	35
NN	Yes	N/A	NPF(4,1)	1.10%	-120%-	-∏9-
CNN	No	ReLU	NPF(4,1)	0.82%	-087%-	-39-
CNN	Yes	ReLU	NPF(4,1)	0.66%	-074%-	-72-
CNN	No	NPF(4,1)	NPF(4,1)	0.78%	-086%-	-40-
CNN	Yes	NPF(4,1)	NPF(4,1)	0.77%	-095%-	-80-
CNN	No	NPFC(4,1)	NPF(4,1)	0.77%	-0.84%-	-37-
CNN 一	Yes	NPFC（4,1）一	NPF(4,1)	0.64%	0.69%	81
nique, as it proved unnecessary on this comparatively easy to learn dataset. Notice that the weight
tying in the NPFC activation makes a considerable difference for the convolution nets, especially
when dropout is used in conjunction with learning the activation functions. The biggest improve-
ment is in learning activations for both convolution and fully connected layers and using dropout
-a relative 15% improvement over the baseline. Using ReLU activations in the convolution lay-
ers with nonparametric activations in the fully connected layers also offered sizable performance
improvements over the baseline.
In feedforward networks with three fully connected layers there also is an improvement in the test
error rate. Here again the improvement is more pronounced with dropout, from 1.35% to 1.10%
versus 1.66% to 1.60%.
5.3	CIFAR-10
The CIFAR-10 dataset is due to Krizhevsky (2009). This dataset consists of 50,000 training and
10,000 test images. The images are three channel color images with dimension 32 × 32. Thus each
image can be viewed either as a 3 × 32 × 32 tensor or a vector of length 3072. These images belong
to one of ten classes. We apply ZCA whitening and global contrast normalization to the dataset
as in Srivastava et al. (2014). The architecture described at the beginning of Section 5 is used for
all experiments. For dropout nets we follow Srivastava et al. (2014) and use a dropout of 0.9 on
the input, 0.75 in the convolution layers and 0.5 in the fully connected layers. The baseline results
can be found in Table 3. Mini-batch sizes between 125 and 250 are used, depending upon memory
constraints.
Table 3: CIFAR-10 baseline results. Epochs is average number of epochs trained. There were five
runs of each experiment.
Name	Activation	Best Error	Mean Error	Epochs
Baseline CNN	ReLU	19.23%	19.46%	64
Baseline CNN + Dropout	ReLU	14.52%	15.20%	147
Table 4: CIFAR10 experiments with Fourier basis. Conv. Act. is the activation function in the
convolutional layers. F.C. Act. is the activation function in the fully connected layers. In both cases
it is the activation in the final stage of training (if two stages are used). For two stage training, error
rates and epochs for both first and second stages are given. Results of note appear in bold.
Training	Dropout	Conv. Act.	F.C. Act.	Best Error	Mean Error	Epochs
One Stage	No	NPFC(4,1)二	NPF(4,1)	20.09%	20.35%	:	36
One Stage	-No-	ReLU	NPF(4,1)	18.58%	-19.00%-	68
One Stage	-Yes-	ReLU	NPF(4,1)	14.04 %	-14.77%-	124
Two Stage	-No-	NPFC(4,1)	NPF(4,1)	18.26%	-18.79%-	60/61
Two Stage	YeS	NPFC(4,1)—	NPF(4,1)	13.22%	13.56%	140/64
8
Under review as a conference paper at ICLR 2017
In Table 4, one-stage training corresponds to standard back-propagation as in the baseline exper-
iments. The two-stage procedure is the one we introduce to train convolution nets with learned
activation functions described in Section 3.2. As can be seen in Table 4, one stage training does not
work when learning nonparametric activations in convolution layers - test error is worse than the
baseline result. However, by using the two-stage process we see a relative 5% boost in performance
without dropout and a relative 9% boost with dropout! In absolute terms we achieve up to a 1.3%
improvement in generalization performance using learned activations.
Also in Table 4, we can see that we achieved improved performance both with and without dropout
when using ReLU activations for convolution layers and NPF(4, 1) for fully connected layers. Fur-
thermore, Figure 2b shows that in terms of number of weight updates required, adding nonparametric
activations did not slow training.
6	Discussion and Conclusions
As can be seen in Section 5, nonparametric activation functions offer a meaningful improvement in
the generalization performance of deep neural nets in practice. We achieve relative improvements
in performance of up to 15% and absolute improvements of up to 1.3% on two benchmark datasets.
Equally importantly, networks with the activation functions NPF(L, T) and NPFC(L, T) can be
trained as fast as their baseline comparison. To realize these improvements on more challenging
datasets such as CIFAR-10 we introduced a two-stage training procedure. Our nonparametric ac-
tivation functions are principled in that they have the necessary properties to guarantee vanishing
generalization error in the sense of Bousquet & Elisseeff (2002). Specifically, it was shown in
Theorem 4.8, from Section 4.1, that for any feed-forward network architecture using NPF(L, T)
activation functions, we achieve vanishing generalization error as sample size increases.
One interesting direction for future work is to investigate why Fourier basis expansion is successful
where other methods, such as polynomial basis expansion (which we also explored), were not. Both
can be theoretically justified, yet only one works well in practice. Further study of how to eliminate
the two-stage process is needed.
Ultimately, we improve upon other approaches of expanding the function class which can be learned
by deep neural networks. An important previous work on learning more general function approxi-
mations at each node is that of Lin et al. (2013). Their result offers a new type of convolution filter
that can learn a broader function class, and in practice their technique also works well. It is limited
however in that its use is restricted to convolution layers in convolution neural networks. Ours is
applicable to any network architecture and, in Section 5, we demonstrate its success on multiple
datasets.
9
Under review as a conference paper at ICLR 2017
References
Agostinelli, Hoffman, Sadowski, and Baldi. Learning activation functions to improve deep neural
networks. In ICLR, 2015.
Francis Bach and Eric Moulines. Non-asymptotic analysis of stochastic approximation algorithms
for machine learning. In Advances in Neural Information Processing Systems (NIPS). 2011.
Peter Bartlett and Martin. Anthony. Neural Network Learning: Theoretical Foundations. Cambridge
University Press, The Edinburgh Building, Cambridge CB2 8RU, UK, 1999.
James Bergstra, Olivier Breuleux, Frederic Bastien, Pascal Lamblin, Razvan Pascanu, Guillaume
Desjardins, Joseph Turian, David Warde-Farley, and Yoshua Bengio. Theano: a CPU and GPU
math expression compiler. In Proceedings of the Python for Scientific Computing Conference
(SciPy), June 2010. Oral Presentation.
Olivier Bousquet and Andre Elisseeff. Stability and generalization. Journal of Machine Learning
Research, 2, 2002.
Sharan Chetlur, Cliff Woolley, Philippe Vandermersch, Jonathan Cohen, John Tran, Bryan Catan-
zaro, and Evan Shelhamer. cudnn: Efficient primitives for deep learning, 2014.
Moritz Hardt, Benjamin Recht, and Yoram Singer. Train faster, generalize better: Stability of
stochastic gradient descent. CoRR, abs/1509.01240, 2015. URL http://arxiv.org/abs/
1509.01240.
Michael Garland Kevin Skadron John Nickolls, Ian Buck. Scalable parallel programming with cuda.
ACM Queue, 6, 2008.
Alex Krizhevsky. Learning multiple layers of features from tiny images. Technical report, 2009.
Y. LeCun, L. Bottou, G. Orr, and K. Muller. Efficient backprop. In G. Orr and Muller K. (eds.),
Neural Networks: Tricks of the trade. Springer, 1998.
Yann Lecun and Corinna Cortes. The MNIST database of handwritten digits. 1999. URL http:
//yann.lecun.com/exdb/mnist/.
Min Lin, Qiang Chen, and Shuicheng Yan. Network in network, 2013.
D. Maclaurin, D. Duvenaud, and R. Adams. Gradient-based hyperparameter optimization through
reversible learning. In JMLR, volume 37, 2015.
Srivastava, Hinton, Krizhevsky, Sutskever, and Salakhutdinov. Dropout: A simple way to prevent
neural networks from ovefitting. Journal ofMachine Learning Research, 15:1929-1958, 2014.
10
Under review as a conference paper at ICLR 2017
A Generalization B ound For Fully Connected Networks with
Fourier Basis Activation Functions
This is an extension of Section 4.1. For the purposes of this section assume that all data x are vec-
tors in [-1, 1]m, which is permissible because we classify input that is bounded. Furthermore, we
assume that the network architecture is a series of Q fully connected hidden layers (affine transfor-
mation layers) fed into a softmax layer which classifies into one of c classes. The weight vector for
the network w should be viewed as the all parameters of the affine transformations and activation
functions.
The loss function is the negative log-likelihood of the network output, which is a softmax over c
classes. The softmax layer in our framework should be treated as two layers for the purposes of
demonstrating the generalization bound. One layer is an affine transformation of the output of the
lower layers in the network to c nodes. We will denote the result of this computation at each node i
in the affine transformation layer within the softmax layer as gQ+1 (w, x)i. The second layer maps
the outputs at these C nodes to C nodes - this will be the network output. It computes at the the ith
node
o	eχp gQ+1(w,x)
oi(w,x)	v-''C	.	..
i=1 eχp gQ+1(w, x)i
Thus, on some training example (x, y), the negative log-likelihood of the network output is
f(w, (x, y)) = - log(oi(w, x)) = -gQ+1(w, x)y + log XeχpgQ+1(w,x)c
If we can demonstrate that this f has the desired properties, then the generalization bound given in
Section 4 will apply.
For clarity, we refer to network of stacked affine transformation layers as a fully connected network.
These layers compute Wx + b, where x is either the input layer (so x ∈ Rm) or it is the output of
the previous layer in the network (in which case x ∈ Rp , p being the number of nodes in that layer).
Regarding notation:
•	w is a vector denoting all the parameters in the network, so it consists of all parameters
noted below.
•	Wi denotes a portion of the parameter vector, corresponding to the affine transformation
of the pi-1 -dimensional output of the (i - 1)th layer to the pi-dimensional input to the ith
layer in the network.
•	Wi,j denotes the jth row of the matrix Wi .
•	Wi,j,k refers to the weight of the edge from node j in the (i - 1)th layer to edge C in the
ith layer.
•	bi denotes the constant term in the affine transformation from the (i - 1)th layer to the ith
layer.
•	bi,j denotes the jth component of the vector bi.
•	ai0,j, (ai1,j,. . .	, aik,j) and (bi1,j,. . .	, bik,j) denote the parameters of activation function of the
j th node in the ith layer.
The 0th layer is the input layer. Let Q be the number of layers in the network; if i = Q + 1, it refers
to weights on edges in the affine transformation contained within the softmax layer.
Intuitively, our choice of network topology and use of NPF(L, T ) activation function should have
the necessary properties to apply Theorem 4.5. The definition of NPF(L, T ) is repeated below for
clarity.
Definition A.1. Given some sample size n, an interval [-L, L] and tail truncation T where 0 ≤
T ≤ L, the activation function NPF(L, T) is parametrized by (a0,. . .	, ak) and (b1,. . .	, bk) given
11
Under review as a conference paper at ICLR 2017
by
f ao +	pi=ι a，i	cos((-L + T)iπ∕L) + b sin((-L + T)iπ∕L)	X	<	-L	+ T
f (x)	=	( a。+	Pk=I ai	cos(i∏x∕L) + bi sin(iπx∕L)	-L	+ T	≤ X ≤ L — T
[a。+	Pk=I ai	Cos((L — T)i∏∕L) + bi sin((L —	T)iπ∕L)	x	>	L —	T
k grows	with sample size	n and is given by k = dn1/7e.
We need to control the norm of the weight matrices W and biases b in the affine transformations.
In addition, we also need to control the magnitude of the coefficients in the basis expansion. This
does not affect the applicability of the results from Hardt et al. (2015), as it at most reduces the
expansivity of the updates.
Furthermore, for the analysis of their properties we assume a slightly modified version of the activa-
tion functions -inan epsilon neighborhood about the points where the pieces of the function connect
we smooth their joint by taking a convex combination of the two pieces to smoothly transition from
one to the other. To this end define the following functions
k
L(X) = a。 + X ai cos((—L + T)iπ∕L) + bi sin((—L + T)iπ∕L),
i=1
k
M(X) = a。 +	ai cos(iπX∕L) + bi sin(iπX∕L),
i=1
k
U(X) = a。 + X ai cos((L — T)iπ∕L) + bi sin((L — T)iπ∕L).
i=1
for given L, T, k, (a。, . . . , ak), and (b1, . . . , bk). Then the -neighborhood smoothed nonparametric
activation functions are given by Definition A.2.
Definition A.2. Given some sample size n, an interval [—L, L] and tail truncation T where 0 ≤
T ≤ L, the activation function NPF(L, T) is parametrized by (a。, . . . , ak) and (b1, . . . , bk) given
by
L(x)	x < —L + T — € [Case 1]
x+L-τ+'M(x)	+	-L+T+-x L(χ)	—L + T — € ≤ x ≤ —L + T	+ € [Case 2]
f(x) = M(x)	—L + T + € ≤ x ≤ L — T —	€ [Case 3]
L-T+e-x M(x)	+	x-L+T+e U(x)	L — T — € ≤ X ≤ L — T + €	[Case 4]
U(x)	x > L — T + € [Case 5]
k grows with sample size n and is given by k = dn1/7e.
Since We are concerned with behavior as € is made small - because We are approximating
NPF(T, L) with NPFe (T, L) 一 assume without loss of generality that € ≤ 1.
A. 1 Lipschitz Constant
We proceed layer by layer to obtain bounds on the first partial derivatives of the loss function 一
which will allow us to bound the gradient. Lemma A.3 gives bounds for the first layer. The notation
a(w, x) denotes the output of a layer-wide activation transformation. g(w, x) denotes the output of
a layer-wide affine transformation.
Lemma A.3. Assume x ∈ [—a, a]m. Now, consider the affine transformation g1 (w) = W1x + b1
from Rm → Rp, thus W1 ∈ Rm×p and b ∈ Rp. Denoting by g1 (w, x)i = W1,ix + b1,i, it follows
that g1 has first partial derivatives bounded by max{1, a}.
Proof. Clearly, Vgι(w,x)i = [1,..., 1; x;0,..., 0]. Thus it has first partial derivatives bounded by
max{1, a}.	□
What if we have instead as input to the affine transformation a function of x rather than x itself?
Then we have the Lemma A.4.
12
Under review as a conference paper at ICLR 2017
Lemma A.4. Let ai-1(w, x) ∈ [-a, a]pi-1, the output of the (i - 1)th layer in the network. Now,
consider the affine transformation
gi(w, x) = Wiai-1(w, x) + bi.
from Rpi-1 → Rpi. bi ∈ Rd. If we have the following assumptions:
•	ai(w, x)q has first partial derivatives bounded by B, and
•	l∣Wi,jl∣2 ≤ N.
Denoting by gi(w,xj = Wij ai-ι(w,x) + bi,j, it follows that gi(w,xj has first partial derivatives
bounded by max{1, a, √nNL}.
Proof. We need to first examine
∂gi(w,x)j
dbi,j
dbi,j +
∂bi,j +
Wi,j,q ai-1 (w, x)q
1+0= 1.
Next we have for any m,
∂gi(w, x)j	∂bi,j	∂
∂Wi,j,m = ∂Wi,j,m + ∂Wi,j,m
Wi,j,q ai-1 (w, x)q
0+ ai-1(w,x)m + qXm Wi,j,q —
ai-1(w, x)m.
Partial derivatives with respect to all other parameters from the ith layer are clearly 0. If l > i,
partial derivatives with respect to all parameters from the lt h layer are clearly 0. If l < i,
∂gi (w,x)j
∂Wl,m,q
∂WWj+∂Wmq (X Wi,j,r ai-1(W,X)) I
n,pi-1W	dai-1(w,x)r
0+r Wi,j,r ∂Wim
r=1	l,m,q
2
≤ N t
X (∂ai-i(w,x)r
⅛k dWl,m,q
(Cauchy-Schwartz)
≤ √Pi-TNB∙
Likewise,
ιd¾F≤kNB
and for the partial derivatives with respect to activation function parameters. It follows that the
transformations g% (w, xj have first partial derivatives bounded by max{1, a, √Pi-ιNB}.	□
Lemma A.5 provides a bound on the range of affine transformations of outputs of NPF(T, L)
activations.
Lemma A.5. Consider the affine transformation in layer i, gi(w, x). Assume
•	All layers in the network have NPF(L, T ) activations and that coefficients in these acti-
vations are bounded by M,
•	For all i and j, ||Wi,j||2 ≤ N, and
•	For all i and j, |bi,j | ≤ O.
Then,forall j, ∣gi(w, xj | ≤ √p- (2k + DNM + O = O(√pi-Tk).
13
Under review as a conference paper at ICLR 2017
Proof. Recall that gi(w, x)j = Wi,j ai-1(w, x) +bi,j, thus by Cauchy-Schwartz and that im(sin) =
im(cos) = [-1, 1],
∣gi(w,x)j | ≤ √Pi-i(2k + 1)NM + O = O(√Pi-ik).
□
Next, we bound the component functions of NPF(L, T). In addition, to derive asymptotic bounds,
we assume N,M, and O are constants as they are part of the training procedure and not the network
structure. We are more concerned with how the smoothness and continuity properties change as
n,k,L,T,Q and pi change. Also note that for the activation function NPF(L, T) to be well defined,
it must be that ≤ L. We also assume ≤ 1.
Lemma A.6. Assume gi (w, x) ∈ [-a, a]pi and that gi (w, x)j has first partial derivatives bounded
by B. Further assume that |ad| ≤ M and define f (w, x) = a& cos CKgMW,xj. Then f (w, x) has
first partial derivatives bounded by max{ dπMB, 1}.
Proof. Taking the derivative of f with respect to ad yields
∂ad
cos
d∏gi (w,x)j
L
Next if We take the derivative of f with respect to any weight from elsewhere in the network - some
Z - we get
∂f	dπad ∂gi(w, x)j	dπgi(w, x)j
∂Z = --L	∂Z- Sm V	L )
and therefore that
∂f	dπad ∂gi(w, x)j	dπMB
≤ ≤	…J 'j ≤ —-—
∂z —	L ∂z — L
and so the partial derivatives of f are bounded by max{ dπMB, 1}.
□
Immediately from the proof to Lemma A.6 we see that an identical result holds if we replaced cos
with sin.
Lemma A.7. Let gi(w, x) ∈ [-a, a]pi-1 and assume
•	gi(w, x)j has first partial derivatives bounded by B,
•	All layers in the network have NPF(L, T ) activations and that coefficients in these acti-
vations are bounded by M,
•	For all i and j , ||Wi,j ||2 ≤ N, and
•	For all i and j , |bi,j | ≤ O.
Consider the layer-wide activation transformation ai (w, x) where ai (w, x)j is given by a function
of the type NPF(L, T). ai(w, x)j then has first partial derivatives with bound
Bo — O (πlaχ J √P-1k3B + k2L √P^k3B + k2L lʌ
JB — k-ʃ I ιmax、	,	. I .
L
Proof. To bound the partial derivatives, first consider Cases 1 and 5, clearly the derivative with
respect to some parameter z is 0. For Case 3, by Lemma A.6,
∂M (gi(w,x)j)
∂Z
≤ (k2 + k)MBπ + (k2 + k) = (k2 + k)(MB + L)π = O 卜2 + k2B
14
Under review as a conference paper at ICLR 2017
Next consider Case 2, we have
∂
∂z
(giUj+L - T + eM(g(w,xj) + -L + T + 2Jg(W,xj L(g(w,xj))
∂Z (ggj+) - T + eM(g(w,xj)) - ^zxj WL(g(w,理)
1 %苧曲 M(g(w,xj)+ (g(w,xj +L - T + e ]
2e ∂z “' ''J 2 2	2	J
∂M(g(w) Xj)
∂Z
-d⅛4"(W, Xj)
M(gi(w, Xj) - L(gi(w, Xj)
2e
∂gi(w, Xj
∂z
(gi(w, Xj + L - T + e
+1 丞
∂M (gi (w)X j)
∂z
Both M(x) and L(X) are trivially bounded above by (k2 + k + 1)M. Therefore
(g(w,Xj+L - T + eM(gi(w,X)) + -L+ T +；J %^㈤? L(mw,X j)) |
^Γ^
M(gi(w, Xj) - L(gi(w, Xj) ʌ ∂gi(w, Xj
gi(w, Xj + L - T + e∖ ∂M(gi(w, Xj)
+
2€
V (k2 + k + 1)BM +
∂z
2e
√Pi-ι(2k + 1)NM + O + L +
2€	∂z
+ k)(MB + L)π∖
c( ∫√P口k3B + k2L √p~1k3B + k2L
O max < ---------,-----------
eL
By symmetry, we have the same bound for Case 4. Thus overall, the bound on the first partial
derivatives of a (w, Xj is
O (max
√p-1k3B + k2L √p-1k3B + k2L
eL
),
as for all values of k,B,L,e and Pi_1 the bound for Cases 2 and 4 dominates the bound for Case
3.	□
Finally, we turn to the top layer of the network.
Lemma A.8. With the notation established in Section A, assume there are C classes, the network
has Q layers of affine transformations, and each gL(w, Xj has first partial derivatives bounded by
B. Then the loss function f is 2B
，(PI + I)C + PQ=I Pi(Pi-I
+ 1)-Lipschitz. If all layers have
P nodes, then f is 2B，(Q - 1)p2 + (c + m + Q)P + C-Lipschitz. In asymptotic notation, it is
K-Lipschitz with K = O(Bp√Q).
Proof. Consider the partial derivative of f with respect to an arbitrary parameter Z
∂f	^L(W,X)y ,	1	G 的L(W,X)j	((
枳=+ j exp("(w,Xj)	呻①L(W, Xj).
By the assumption |dgLdzMy | ≤ Q. Therefore the following holds
f
∂z
∂"(w,X)y
∂Z
1
Pj=ι exP(gL(w,Xj)
X ”产 exp(%)
j=i
∂"(w,X)y
∂Z
1
PC=ι exP(gL(w,X)j)
k c /	、
Σ∂gL(w,X j
∂z
j = 1
exp(gL(w,X j)
€
≤
€
€
L
+
≤ B + max 彻L(WXj
j ∂z
≤ 2B.
If layer i has Pi nodes there are Pi × Pi-1 + Pi = Pi(Pi-I + 1) parameters corresponding to the
affine transformation from layer i - 1 to layer i. Recall layer 0 is the input layer, so p0 = m.
15
Under review as a conference paper at ICLR 2017
Furthermore, the affine transformation in the softmax has pl × c + c parameters. Thus the total
number of parameters in the network is
Q
(pl + 1)c+	pi(pi-1 + 1),
i=1
which implies that f is 2B	(pl + 1)c+ PiQ=1pi(pi-1
+ 1)-Lipschitz. If all layers have the same
number of nodes, then the total number of parameters in the network is
(Q - 1)p2 + (c + m + Q)p + c
and so in this case f is 2B a∕(Q-Γ)p2+7c+m^+^Q)P^+^c-Lipschitz. In asymptotic notation, it
is K-Lipschitz with K = O(Bp√Q).	□
Combining all the results above we have Theorem A.9.
Theorem A.9. Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network. Then
there exists some K such that the loss function as given in Section A is K-Lipschitz. Specifically,
for any such network, where the number of hidden layers Q ≥ 1 and there are p nodes per layer,
“	√q( √Q(pQ+1k3Q + p(2Q+1)/2k3Q-1L) ∖
K = max IO (---------------Q---------------)
,O
√Q(pQ+1k3Q + p(2Q+1)∕2k3Q-1L)
IQLQ
Proof. By Lemmas A.3, A.4, A.7 and A.8 such an K must exist. Note that the output of a
NPF(T, L) activation is in [-(k2 + k + 1)N, (k2 + k + 1)N]. Then, the computation is as follows,
using the aforementioned theorems:
•	gι - B = 1
•	aι - B = max {O (”户+户力),O (回"kL)}
•	g2 - B = max nO (P-k2L) , O (pk3+√pk2L)}
•	a2 - B = max nO (p3/2k：+pk5L ) , O (W/MLpkL )}
•	g3 - B = max nO ( P"""'L ) , O ((PkF2 k5L )}
•	a3 - B = max nO (P5/19+FkkL ) , O (P5∕2¾p2k8L )}
Above the transformations are listed with the bounds on their first partial derivatives. A simple
inductive argument yields for i ≥ 2
gi -
pi-1k3(i-1) + p(2i-3)∕2k3i-4L
B = max V O ------------------------------
I 卜	ei-1
,O
pi-1k3(i-1) + p(2i-3)∕2k3i-4L
EiT Li-I
• ai
B
max
p(2i-1)∕2k3i + pi-1k3i-1
Ei
,O
p(2i-1)∕2k3i + pi-1k3i-1
EiLi
Using Lemma A.8 gives
“	√q( √Q(pQ+1k3Q + p(2Q+1)∕2k3QTL) ∖
K = max IO (---------------EQ---------------)
concluding the proof.
√Q(pQ + 1k3Q + p(2Q + 1)∕2k3Q-1L)
EqLq
□
16
Under review as a conference paper at ICLR 2017
A.2 β-SMOOTHNESS
To derive the smoothness constant, we begin at the top of the network and work down, bounding
partial second derivatives of transformations in the network.
Lemma A.10. With the notation established in Section A, assume there are c classes and each gj
has first partial derivatives bounded by B1 and second partial derivatives bounded by B2 . Then the
loss function f is 2((pl + 1)c + PiQ=1 pi(pi-1 + 1))(B12 + B2)-smooth. If all layers have p nodes,
then f is 2((Q - 1)p2 + (c + m + Q)p + c)(B12 + B2)-smooth.
Proof. We begin by recalling from the proof of Lemma A.8 that for some arbitrary parameter z,
∂f = dgL(W,X)y
∂z
∂z
+ Pc=I eχp(gj)
X agLdw'x" exp(gL(w,x)ι)
l=1	z
1
Therefore differentiating again with respect to another parameter x yields
∂2f
∂z∂x
∂2gL (w,x)y
∂z∂x
c
exp(gL (w, x)l)
l=1
c
X agLdw'x" exp(gL(w, x)ι)
l=1	z
-2
+
-1
X Wdw X)l exp(gL(w, x)ι)
l=1	x
∑c (∂2gL(w,x)ι +
∖ ∂z∂x
l=1
∂gL(w, x)l ∂gL(w, x)l
∂z
∂x
exp(gL (w, x)l)
exp(gL (w, x)l)	.
l=1
If we take the absolute value of both sides we can see that
∂ 2f
∂z∂x
≤ 2B12 + 2B2 .
—
×
×
And therefore by Theorem C.2 it follows that
Q
lλmax(V2f)| ≤ 2((Pl + 1)c + XPi(Pi-I + I))(BI + B2).
i=1
Because V2f is symmetric, its singular values arejust the absolute values of its eigenvalues. There-
fore ∣∣V2f ∣∣2 ≤ 2n(B2 + B2). By LemmaD.2, We have that f is 2(2(pl + 1)c + PQ=IPi(Pi-I +
1))(B12 + B2)-smooth. If all layers have the same number of nodes, then
∣λmax(v2f)| ≤ 2((Q - I)P2 + (c + m + Q)P + C)(B2 + B2)
and so f is 2((Q - 1)p2 + (c + m + Q)P + c)(B2 + B2)-smooth.	口
Next, it is necessary to control the second partial derivatives of the affine transformations as the first
derivatives are bounded in Lemma A.4. This leads to Lemma A.11.
Lemma A.11. Let ai-1 (w, x) ∈ [-a, a]pi-1, the output of the (i - 1)th layer in the netWork. NoW,
consider the affine transformation
gi(w, x) = Wiai-1(w, x) + bi,
from Rpi-1 → Rpi. bi ∈ Rd. IfWe have the folloWing assumptions:
•	ai(w, x)q has first partial derivatives bounded by B1,
•	ai(w, x)q has second partial derivatives bounded by B2, and
•	l∣Wi,j 112 ≤ N.
Denoting by gi(w, x)j = Wi,jai-1(w, x) + bi,j, it folloWs that gi(w, x)j has second partial deriva-
tives bounded by max{Bι, N√Pi-1B2}.
Proof. From the proof of Lemma A.4 We have that
∂gi (w,x)j _ ι
∂bi,j	=
17
Under review as a conference paper at ICLR 2017
and for any m
dgi(W,xj = a. (w x)
∂Wi,j,m = ai-1(w,x)m.
For some m 6= j and any q,
dgi(w,x) = 0
∂Wi,m,q	.
And, lastly, that the partial derivatives with respect to any parameter z in layer l < i
∂gi(w, x)j	pi-1
—∂Z- = 2^wi,j,q
q=1
∂ai-i(w,x)q
∂z
We see then that for the first and third cases the second partial derivatives are zero. For the second
case above, the second partial derivatives are either 0 or bounded by B1 . What remains then is to
check the fourth case. If we differentiate with respect to bi,j ,
a2gi(w,χ)j = 0
∂z∂bi,j	.
If we differentiate with respect to Wi,m,q, for m 6= j,
d^2gi(∙w, X)j = 0
∂z∂Wi,m,q =.
If we differentiate with respect to Wi,j,q,
∂2gi(w,x)j _ ∂ai-i(w,x)q
∂z∂Wi,j,q =	∂	.
Thus the only remaining case is if we differentiate with respect to some parameter z0 from a layer
l < i:
∂2gi(w,x)j
∂z∂z0
∂ai-i(w,x)q
∂
pi-1	∂2ai-1 (w, x)q
=上 Wij,q 一百Z一
q=1
If we take the absolute value of both sides we get that
∂2gi(w,x)j
∂z∂z0
pi-1 W	∂ 2ai-1(W,x)q
jq i,j,q ∂z∂z0
q=1
≤N
X (∂2ai-i(w,x)qλ2
∂z∂(	∂z∂z0	)
q=1
(Cauchy-Schwartz)
≤ N√pi-1B2
And therefore gi(w, xj has second partial derivatives bounded by max{B1,N √pi-1B2}.
□
We also consider affine transformations on the input - although this is covered by Lemma A.11, we
can obtain a better bound directly.
Lemma A.12. Assume x ∈ [-a, a]m. Now, consider the affine transformation g1(w) = W1x + b1
from Rm → Rp, thus W1 ∈ Rm×p and b ∈ Rp. Denoting by g1 (w, x)i = W1,ix + b1,i, it follows
that g1 has second partial derivatives bounded by 0.
Proof. Recall that from the proof of Lemma A.3 kgι(w,x) = [1,..., 1;x;0,...,0]. Thus its
second derivatives are all 0.	□
Finally, a bound is needed for the second partial derivatives of the NPF (L, T ) activations.
18
Under review as a conference paper at ICLR 2017
Lemma A.13. Assume gi(w, x) ∈ [-a, a]pi and that gi(w, x)j has first partial derivatives bounded
by B1 and second partial derivatives bounded by B2. Further assume that |ad| ≤ M and de-
fine f (w, x) = ad cos
dπMLB2 +d2 π2 MB12
max j	L2
Then f(w, x) has second partial derivatives bounded by
dπgi(w,x)
L
Proof. Recall from the proof of Lemma A.6 that taking the derivative of f(w, x) with respect to ad
yields
∂f(w,x) =	(dπgi(w,x) ∖
∂ad	V L ;
and that if we take the derivative off(w, x) with respect to any weight from elsewhere in the network
-some Z -We get
∂f(w, x)	dπad ∂gi (w, x)j	dπgi (w, x)j
-∂Z- = --L	∂Z- Sm V	L )
Now, if We take the derivative of df⅞x, with respect to a& We get 0. If We take the derivative of
df∂W,x) with respect to some Z we get
∂2f(w, x)	dπgi(w, x)j	dπ ∂gi(w, x)j
∂ad∂z	Sm ( L J(L ∂z
and we can bound this as
∂2f (w, x)	dπBι
∂ad∂z	≤ L .
Next if we take the derivative of fdzx with respect to ad we get the same as above. Lastly we
take the derivative of df(W,x with respect to some z0 which gives
∂2f(w,x) _ dπad ∂2gi(w,x)j	(dπgi(w,x%∖ d2π2ad ∂gi(w,xj ∂gi(w,x)j	「(dπgi(w,x)
∂z∂z0	=--L	∂z∂z0	Sm V	L - --L2	∂Z	∂Z- CoS V L
which we can bound as
∂2f(w,x)	dπMB2	d2π2MB1	dπMLB2 + d2π2MB1
∂z∂z0	≤ L+	L2=	L2	.
Therefore the second partial derivatives of f are bounded by max { dbMLBgfRMBF, dL1 0. □
Lemma A.14. Let gi(w, x) ∈ [-a, a]pi-1 and assume
•	gi(w, x)j has first partial derivatives bounded by B1,
•	gi(w, x)j has first partial derivatives bounded by B2,
•	All layers in the network have NPF(L, T ) activations and that coefficients in these acti-
vations are bounded by M,
•	For all i and j, ||Wi,j||2 ≤ N, and
•	For all i and j, |bi,j | ≤ O.
Consider the layer-wide activation transformation ai (w, x) where ai (w, x)j is given by a function
of the type NPF(L, T). ai(w, x)j then has second partial derivatives bounded by
Bik2
√P-lk3(B1 + B2)	k4Bl	k3 B2∖
+	L	+ L2 e + Le ) .
Proof. Without loss of generality we can assume that if Bi 6= 0 that Bi ≥ 1, as these are upper
bounds. To bound the second partial derivatives, first note that Cases 1 and 5 have partial second
19
Under review as a conference paper at ICLR 2017
derivatives of 0 with respect to all parameters in the network. Next, in Case 3 we see from Lemma
A.13 that
∂2M (gi(w,x)j)
∂z∂z0
k
≤2X
d=i
dπM LB2 + d2π2MB12
L2
dπBi
L
(k2 + k)πMLB2
2
O (k2(B1 + B2)
+ lτ + τ + 6;∣ F
k3	k2
k π2MB
(k2 + k)πB1
for any two parameters z and z0 . Denote
+
+
2
L
ci = L - T + and c2 = -L+T +.
In Case 5 then, we can compute
∂2 ai(w, x)j
∂z∂z0
∂ ∂∂gi(w,x)j M(gi(w,x)j) + ∂M(gi(w,x)j) gi(w, x)j + Ci
∂z0
∂z0
∂z0
2
2
∂gi(w, x)j L(gi(w, x)j)
—
∂z0
2
∂2gi (w, x)j M (gi(w, x)j)
∂gi(w, x)j ∂M(gi(w, x)j) 1
2
+
2
∂z∂z0
∂z0
∂z
∂gi(w, x)j ∂M (gi(w, x)j)
∂z
∂z0
1
2Z
∂2M (gi(w, x)j) gi(w, x)j + ci
∂z∂z0
∂2gi (w, x)j L(gi(w, x)j)
∂z∂z0
and then bound it, using B3 and B4 as bounds on the first and second partial derivatives of M,
respectively,
∂2ai(w, x)j
∂z∂z0
≤ B2(k2 + k + 1)M + BB + B4a+c1
O
+
O
+
+
Bik2 + √pi-1k3(Bι + B2)
Bik2 + √p-Γk3(Bι + B2)
k4Bi k3Bi	k2(B1 + B2)
+ F + R +
k4B12
+ F +
Since this bound dominates the one for Case 3, we are done.
Combining all the results above we have Theorem A.15.
Theorem A.15. Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network.
Then there exists some K such that the loss function as given in Section A is β-smooth. Specifically,
for any such network where the number of hidden layers Q ≥ 1 and and there are p nodes per layer,
p3Q+5/2k9Q-2
β = max OD (Qp 刀2电邛-1 )O O (Q
p2Q+Q+2k5×2Q+3QL2Q-1+1
e2Q+Q
Proof. By Lemmas A.3, A.4, A.7, A.10, A.11, A.14 and A.12 such a β must exist.
To compute this β , the aforementioned results can be used as well as the computations from the
proof of Theorem A.9. The computation is as follows, using the aforementioned results,
• gι - B = 0
• ai - B = max {θ
+金),o (k+陪+先)}
+
+
2
—
2


L
L
.
L
□
20
Under review as a conference paper at ICLR 2017
•	g2 - B = max {O (Pk3 + *)，O(半 + 等 + 唯 + 答)}
•	a2 - B = max {θ (谊),O (p2⅛0L2)}
•	g3 - B = max {θ (⅛⅛6) , O (p5/2^)}
Above, next to each transformation, is the bound B on its second partial derivatives. The bounds are
computed with respect to L ≤ 1 and L > 1, and then the maximum is taken over both cases. By a
simple inductive argument for i ≥ 2,
•	gi -
• Qi -
max O
B = max
p2i-3/2 k 6i-8
L2i-2 e2i-3
p2i-2 k6i-2
L2ie2i-1
B
O
Using the bounds derived above, the bounds from Theorem A.9 and Lemma A.10 gives
β = max (O(Qp3L+QSg-2)，O V"'" + 1!).
□
A.3 Generalizability
With the necessary properties demonstrated, we arrive at Theorem A.16. Byp denote the number of
nodes per layer and Q the number of hidden layers.
Theorem A.16. Consider a fully connected network with a softmax output layer and NPF (L, T )
activation functions. Assume we use SGD with a max-norm constraint on the weight matrix and
biases in the affine layers and on the coefficients of the activation functions to train the network.
Then, for all practical values of L,T ,,Q and p, the resulting Lipschitz constant K and smoothness
constant β are sufficiently large that
Cstab ≤	..
n-1
ThUs if T = O(√n), Estab → 0 as sample size n → ∞.
Proof. By Theorems 4.5, A.9, and A.15 the result is immediate.
□
B	RESULTS FOR FUNCTIONS OVER Rn
WithoUt proof we give the mean valUe ineqUality for vector valUed fUnction in Theorem B.1.
Theorem B.1. Let f be a differentiable vector valUed fUnction, that is f : A ⊂ Rn → Rm . Then
for x, y ∈ A, we have that
llf(χ)-f (y)ll≤l∣Df (Z)(X-y)ll,
where z is some point on the line segment connecting x, y. Here Df represents the Frechet derivative
of f, which can be represented in matrix form by the Jacobian.
21
Under review as a conference paper at ICLR 2017
C Results for Matrices
When we want to bound the largest eigenvalue of the matrix, we can get a loose bound by the sum
of the entries of the matrix as in Theorems C.1 and C.2.
Theorem C.1. For some matrix norm ∣∣∙∣∣,the spectral radius of the matrix A is upper bounded by
||A||.
Proof. Take the eigenvector corresponding to the largest eigenvalue in magnitude ofA. Denote this
pair by x, λ. Next define the matrix X = [χ∣∙∙∙ |x]. It follows then that AX = λX. Therefore
∣λ∣∣∣X∣∣ = ∣∣λX∣∣ = ∣∣AX∣∣≤∣∣A∣川 X||
because matrix norms are sub-multiplicative, demonstrating | λ | ≤ || A ||.	□
Theorem C.2. Let A be a symmetric n × n matrix. Let the entries of the matrix be bounded above
by some constant k. It follows then that maxk ∣λk (A) | ≤ nk.
Proof. By Theorem C.1 we can see that
max ∣λk (A)| ≤ ∕X(Aij)2 ≤ √n2k2 = nk.
k	i,j
□
D Results for Lipschitz and Smooth Functions
First note that if Vf (x) is well defined everywhere and if ||Vf (x)|| ≤ L over the entire domain,
it is L-Lipschitz by the mean value theorem and an application of Cauchy-Schwartz. In the convex
case, the reverse is also true.
Lemma D.1. Take g to be a function from Rn → Rd. If g is L-Lipschitz in each of its components,
g is √nL-Lipschitz.
Proof. Consider any x, y ∈ Rn. By the assumption we know that for i = 1, . . . , n |gi (x) -gi (y)|2 ≤
L2 ||x - y||22. Therefore
n
X |gi(x) - gi (y)|2 ≤ nL2||x - y||22,
i=1
and, thus, the desired result that
un
||g(x) - g(y)ll2 =、£|gi(X) - gi(y)|2 ≤ √nL∖∖x — y∣∣2.
i=1
□
Directly from the definition it is difficult to prove a gradient to be Lipschitz continuous. However
we can utilize Lemma D.2.
Lemma D.2. For some twice differentiable function f : A ⊂ Rn → R, f is β-smooth if its Hessian
is bounded by β with respect to the euclidean norm.
Proof. Take the gradient Vf which is a mapping A ⊂ Rn → Rn . We can apply the mean value
inequality for vector valued functions, Theorem B.1, which gives us
∖∖Vf(x) —Vf(y)∖∖2 ≤ ∖∖V2f(z)(x — y)∖∖2,
where z is on the line segment connecting x and y. Because of how the induced euclidean norm on
a matrix is defined it follows that
∖∖V2f(z)(x — y)∖∖2 ≤ ∖∖V2f (z)∖∖2∖∖x — y∖∖2 ≤ β∖∖x — y∖∖2.
Combining the two equations above gives the desired result,
∖∖Vf(x) — Vf(y)∖∖2 ≤ β∖∖χ — y∖∖2.
□
22
Under review as a conference paper at ICLR 2017
The insight to take this approach to demonstrating β-smoothness is from Bach & Moulines (2011).
23