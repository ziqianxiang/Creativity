Published as a conference paper at ICLR 2020
A Closer Look at Deep Policy Gradients
Andrew Ilyas*, Logan Engstromy Shibani Santurkar1, Dimitris Tsipras1,
Firdaus Janoos2, Larry Rudolph1,2, and Aleksander MadryI
1MIT 2Two Sigma
{ailyas,engstrom,shibani,tsipras,madry}@mit.edu
rudolph@csail.mit.edu, firdaus.janoos@twosigma.com
Ab stract
We study how the behavior of deep policy gradient algorithms reflects the con-
ceptual framework motivating their development. To this end, we propose a fine-
grained analysis of state-of-the-art methods based on key elements of this frame-
work: gradient estimation, value prediction, and optimization landscapes. Our re-
sults show that the behavior of deep policy gradient algorithms often deviates from
what their motivating framework would predict: the surrogate objective does not
match the true reward landscape, learned value estimators fail to fit the true value
function, and gradient estimates poorly correlate with the “true” gradient. The
mismatch between predicted and empirical behavior we uncover highlights our
poor understanding of current methods, and indicates the need to move beyond
current benchmark-centric evaluation methods.
1	Introduction
Deep reinforcement learning (RL) is behind some of the most publicized achievements of modern
machine learning (Silver et al., 2017; OpenAI, 2018; Dayarathna et al., 2016; OpenAI et al., 2018).
In fact, to many, this framework embodies the promise of the real-world impact of machine learning.
However, the deep RL toolkit has not yet attained the same level of engineering stability as, for
example, the current deep (supervised) learning framework. Indeed, recent studies demonstrate that
state-of-the-art deep RL algorithms suffer from oversensitivity to hyperparameter choices, lack of
consistency, and poor reproducibility (Henderson et al., 2017).
This state of affairs suggests that it might be necessary to re-examine the conceptual underpinnings
of deep RL methodology. More precisely, the overarching question that motivates this work is:
To what degree does current practice in deep RL reflect the principles informing its development?
Our specific focus is on deep policy gradient methods, a widely used class of deep RL algorithms.
Our goal is to explore the extent to which state-of-the-art implementations of these methods succeed
at realizing the key primitives of the general policy gradient framework.
Our contributions. We take a broader look at policy gradient algorithms and their relation to their
underlying framework. With this perspective in mind, we perform a fine-grained examination of key
RL primitives as they manifest in practice. Concretely, we study:
•	Gradient Estimation: we find that even when agents improve in reward, their gradient
estimates used in parameter updates poorly correlate with the “true” gradient. We addition-
ally show that gradient estimate quality decays with training progress and task complexity.
Finally, we demonstrate that varying the sample regime yields training dynamics that are
unexplained by the motivating framework and run contrary to supervised learning intuition.
•	Value Prediction: our experiments indicate that value networks successfully solve the
supervised learning task they are trained on, but do not fit the true value function. Addi-
tionally, employing a value network as a baseline function only marginally decreases the
* Equal contribution. Work done in part as an intern at Two Sigma.
1
Published as a conference paper at ICLR 2020
Variance of gradient estimates compared to using true Value as a baseline (but still dramat-
ically increases agent’s performance compared to using no baseline at all).
•	Optimization Landscapes: we show that the optimization landscape induced by modern
policy gradient algorithms is often not reflectiVe of the underlying true reward landscape,
and that the latter is frequently poorly behaVed in the releVant sample regime.
OVerall, our results demonstrate that the motiVating theoretical framework for deep RL algorithms
is often unpredictiVe of phenomena arising in practice. This suggests that building reliable deep RL
algorithms requires moVing past benchmark-centric eValuations to a multi-faceted understanding of
their often unintuitiVe behaVior. We conclude (in Section 3) by discussing seVeral areas where such
understanding is most critically needed.
2	Examining the Primitives of Deep Policy Gradient Algorithms
In this section, we inVestigate the degree to which our theoretical understanding of RL applies to
modern methods. We consider key primitiVes of policy gradient algorithms: gradient estimation,
Value prediction and reward fitting. In what follows, we perform a fine-grained analysis of state-of-
the-art policy gradient algorithms (PPO and TRPO) through the lens of these primitiVes—detailed
preliminaries, background, and notation can be found in Appendix A.1.
2.1	Gradient estimate quality
A central premise of policy gradient methods is that stochastic gradient ascent on a suitable objectiVe
function yields a good policy. These algorithms use as a primitiVe the gradient of that objectiVe
function:
g = Vθ E(st,at)〜∏o [「LUA∏o(st，at)] = E(st,at)〜∏o [ ：	∣!/A∏o(st，at)]，	(I)
π0(at |st) π0(at |st)
where in the aboVe we use standard RL notation (see Appendix A.1 for more details). An underlying
assumption behind these methods is that we haVe access to a reasonable estimate of this quantity.
This assumption effectiVely translates into an assumption that we can accurately estimate the expec-
tation above using an empirical mean of finite (typically 〜103) samples. Evidently (since the agent
attains a high reward) these estimates are sufficient to consistently improVe reward—we are thus
interested in the relative quality of these gradient estimates in practice, and the effect of gradient
quality on optimization.
E-SS8(υs-ΛUrad ⅛><
E-OT OTOU SMJrad ⅛><
S8 3SΛΛUrad ⅛><
0.5
0.0
# Iteration: 300
IO2 IO3 IO4 10s IO6
# State-Action Pairs
S8 3SΛΛUrad ⅛><
1.0
0.5
0.0
# Iteration： 450
IO2 IO3 IO4 10s IO6
# State-Action Pairs
Figure 1:	Empirical variance of the estimated gradient (c.f. (1)) as a function of the number of state-
action pairs used in estimation in the MuJoCo Humanoid task. We measure the average pairwise
cosine similarity between ten repeated gradient measurements taken from the same policy, with the
95% confidence intervals (shaded). For each algorithm, we perform multiple trials with the same
hyperparameter configurations but different random seeds, shown as repeated lines in the figure.
The vertical line (at x = 2K) indicates the sample regime used for gradient estimation in standard
implementations of policy gradient methods. In general, it seems that obtaining tightly concentrated
gradient estimates would require significantly more samples than are used in practice, particularly
after the first few timesteps. For other tasks - such as Walker2d-v2 and HoPPer-V2 - the plots (seen
in Appendix Figure 9) have similar trends, except that gradient variance is slightly lower. Confidence
interVals calculated with 500 sample bootstrapping.
2
Published as a conference paper at ICLR 2020
...
ptu」6(υnJ4 f-M E-ω SoU
# Iteration： 0
IO9 10* IO5 IO6
# State-Action Pairs
...
ptu」6(υnJ4 f-M E-ω SoU
IO2 IO3 IO4 10s IO6
# State-Action Pairs
1.00.50.0
ptu」6(υnJ4 f-M E-ω SoU
-CT><
# State-Action Pairs
# Iteration： 450
ptu」6(υnJ4 f-M E-ω SoU
IO3 IO4 10s IO6
# State-Action Pairs
Figure 2:	Convergence of gradient estimates (c.f. (1)) to the “true” expected gradient in the MuJoCo
Humanoid task. We measure the mean cosine similarity between the “true” gradient approximated
using ten million state-action pairs, and ten gradient estimates which use increasing numbers of
state-action pairs (with 95% confidence intervals). For each algorithm, we perform multiple trials
with the same hyperparameter configurations but different random seeds. The vertical line (at x =
2K) indicates the sample regime used for gradient estimation in standard implementations of policy
gradient methods. Observe that although it is possible to empirically estimate the true gradient,
this requires several-fold more samples than are used commonly in practical applications of these
algorithms. See additionally that the estimation task becomes more difficult further into training.
For other tasks - such as Walker2d-v2 and HoPPer-V2 - the plots (seen in Appendix Figure 10) have
similar trends, except that gradient estimation is slightly better. Confidence intervals calculated with
500 sample bootstrapping.
How accurate are the gradient estimates we compute? To answer this question, we examine two
of the most natural measures of estimate quality: the empirical variance and the convergence to the
“true” gradient. To evaluate the former, we measure the average pairwise cosine similarity between
estimates of the gradient computed from the same policy with independent rollouts (Figure 1). We
evaluate the latter by first forming an estimate of the true gradient with a large number of state-action
pairs. We then examine the convergence of gradient estimates to this “true” gradient (which we once
again measure using cosine similarity) as we increase the number of samples (Figure 2).
We observe that deep policy gradient methods operate with relatively poor estimates of the gradient,
especially as task complexity increases and as training progresses (contrast Humanoid-v2, a “hard”
task, to other tasks and contrast successive checkpoints in Figures 1 and 2). This is in spite of the
fact that our agents continually improve throughout training, and attain nowhere near the maximum
reward possible on each task. In fact, we sometimes observe a zero or even negative correlation in
the relevant sample regime1.
While these results might be reminiscent of the well-studied “noisy gradients” problem in supervised
learning (Robbins & Monro, 1951; d’Aspremont, 2008; Kawaguchi, 2016; Safran & Shamir, 2018;
Livni et al., 2014; Keskar et al., 2016; Hochreiter & Schmidhuber, 1997), we have very little un-
derstanding of how gradient quality affects optimization in the substantially different reinforcement
learning setting. For example:
•	The sample regime in which RL algorithms operate seems to have a profound impact on
the robustness and stability of agent training—in particular, many of the sensitivity issues
reported by Henderson et al. (2017) are claimed to disappear (Sutskever, 2018) in higher-
sample regimes. Understanding the implications of working in this sample regime, and
more generally the impact of sample complexity on training stability remains to be pre-
cisely understood.
•	Agent policy networks are trained concurrently with value networks (discussed more in the
following section) meant to reduce the variance of gradient estimates. Under our conceptual
framework, we might expect these networks to help gradient estimates more as training
progresses, contrary to what we observe in Figure 1. The value network also makes the
now two-player optimization landscape and training dynamics even more difficult to grasp,
as such interactions are poorly understood.
1Deep policy gradient algorithms use gradients indirectly to compute steps—in Appendix A.4 we show that
our results also hold true for these computed steps.
3
Published as a conference paper at ICLR 2020
•	The relevant measure of sample complexity for many settings (number of state-action pairs)
can differ drastically from the number of independent samples used at each training itera-
tion (the number of complete trajectories). The latter quantity (a) tends to be much lower
than the number of state-action pairs, and (b) decreases across iterations during training.
All the above factors make it unclear to what degree our intuition from classical settings transfer to
the deep RL regime. And the policy gradient framework, as of now, provides little predictive power
regarding the variance of gradient estimates and its impact on reward optimization.
Our results indicate that despite having a rigorous theoretical framework for RL, we lack a precise
understanding of the structure of the reward landscape and optimization process.
2.2 Value prediction
Our findings from the previous section motivate a deeper look into gradient estimation. After all,
the policy gradient in its original formulation (Sutton et al., 1999) is known to be hard to estimate,
and thus algorithms employ a variety of variance reduction methods. The most popular of these
techniques is a baseline function. Concretely, an equivalent form of the policy gradient is given by:
gθ = ET 〜∏θ	〉:	▽ θ log πθ (at I st) ∙ (Q∏θ (st, at) ― b(st))	(2)
(st,at)∈τ
where b(st ) is some fixed function of the state st. A canonical choice of baseline function is the
value function Vπ(s), the expected return from a given state (more details and motivation in A.1):
Vπθ(st) = Eπθ [RtIst] .	(3)
Indeed, fitting a value-estimating function (Schulman et al., 2015c; Sutton & Barto, 2018) (a neural
network, in the deep RL setting) and using it as a baseline function is precisely the approach taken
by most deep policy gradient methods. Concretely, one trains a value network Vθπ such that:
θt = mθin E	Vθπ(st)-(Vθπt-1(st)+At)2	(4)
where Vθπ (st) are estimates given by the last value function, and At is the advantage of the policy,
i.e. the returns minus the estimated values. (Typically, At is estimated using generalized advantage
estimation, as described in (Schulman et al., 2015c).) Our findings in the previous section prompt
us to take a closer look at the value network and its impact on the variance of gradient estimates.
13 5 7
- - - -
2 2 2 2
⅛Σ ⅛0
山l±∑SEn4①ɑ:
O IOO 200	300	400	500	O IOO 200	300	400	500
# Iterations	# Iterations
(a)
Figure 3: Quality of value prediction in terms of mean relative error (MRE) on heldout state-action
pairs for agents trained to solve the MuJoCo Walker2d-v2 task. We observe in (left) that the agents
do indeed succeed at solving the supervised learning task they are trained for—the MRE on the
GAE-based value loss (Vold + AGAE)2 (c.f. (4)) is small. On the other hand, in (right) we see that
the returns MRE is still quite high—the learned value function is off by about 50% with respect to
the underlying true value function. Similar plots for other MuJoCo tasks are in Appendix A.5.
4
Published as a conference paper at ICLR 2020
(a) Walker2d-v2
(b) Hopper-v2
Figure 4: Efficacy of the value network as a variance reducing baseline for Walker2d-v2 (top) and
Hopper-v2 (bottom) agents. We measure the empirical variance of the gradient (c.f. (1)) as a function
of the number of state-action pairs used in estimation, for different choices of baseline functions:
the value network (used by the agent in training), the “true” value function (fit to the returns us-
ing 5 ∙ 106 state-action pairs sampled from the current policy) and the “zero” value function (i.e.
replacing advantages with returns). We observe that using the true value function leads to a signif-
icantly lower-variance estimate of the gradient compared to the value network. In turn, employing
the value network yields a noticeable variance reduction compared to the zero baseline function,
even though this difference may appear rather small in the small-sample regime (2K). Confidence
intervals calculated with 10 sample bootstrapping.
Value prediction as a supervised learning problem. We first analyze the value network through
the lens of the supervised learning problem it solves. After all, (4) describes an empirical risk
minimization, where a loss is minimized over a set of sampled (st, at). So, how does Vθπ perform as
a solution to (4)? And in turn, how does (4) perform as a proxy for learning the true value function?
Our results (Figure 3a) show that the value network does succeed at both fitting the given loss func-
tion and generalizing to unseen data, showing low and stable mean relative error (MRE). However,
the significant drop in performance as shown in Figure 3 indicates that the supervised learning prob-
lem induced by (4) does not lead to Vθπ learning the underlying true value function.
Does the value network lead to a reduction in variance? Though evaluating the Vθπ baseline
function as a value predictor as we did above is informative, in the end the sole purpose of the
value function is to reduce variance. So: how does using our value function actually impact the
variance of our gradient estimates? To answer this question, we compare the variance reduction
that results from employing our value network against both a “true” value function and a trivial
“zero” baseline function (i.e. simply replacing advantages with returns). Our results, captured in
Figure 4, show that the “true” value function yields a much lower-variance estimate of the gradient.
This is especially true in the sample regime in which we operate. We note, however, that despite
not effectively predicting the true value function or inducing the same degree of variance reduction,
the value network does help to some degree (compared to the “zero” baseline). Additionally, the
seemingly marginal increase in gradient correlation provided by the value network (compared to
the “true” baseline function) turns out to result in a significant improvement in agent performance.
(Indeed, agents trained without a baseline reach almost an order of magnitude worse reward.)
Our findings suggest that we still need a better understanding of the role of the value network in
agent training, and raise several questions that we discuss in Section 3.
5
Published as a conference paper at ICLR 2020
2.3 Exploring the optimization landscape
Another key assumption of policy gradient algorithms is that first-order updates (w.r.t. policy pa-
rameters) actually yield better policies. It is thus natural to examine how valid this assumption is.
The true rewards landscape. We begin by examining the landscape of agent reward with respect
to the policy parameters. Indeed, even if deep policy gradient methods do not optimize for the true
reward directly (e.g. if they use a surrogate objective), the ultimate goal of any policy gradient al-
gorithm is to navigate this landscape. First, Figure 5 shows that while estimating the true reward
landscape with a high number of samples yields a relatively smooth reward landscape (perhaps sug-
gesting viability of direct reward optimization), estimating the true reward landscape in the typical,
low sample regime results in a landscape that appears jagged and poorly-behaved. The low-sample
regime thus gives rise to a certain kind of barrier to direct reward optimization. Indeed, applying
our algorithms in this regime makes it impossible to distinguish between good and bad points in the
landscape, even though the true underlying landscape is fairly well-behaved.
The surrogate objective landscape. The untamed nature of the rewards landscape has led to the
development of alternate approaches to reward maximization. Recall that an important element of
many modern policy gradient methods is the maximization of a surrogate objective function in place
of the true rewards (the exact mechanism behind the surrogate objective is detailed in Appendix A.1,
and particularly in (14)). The surrogate objective, based on relaxing the policy improvement theorem
of Kakade and Langford (Kakade & Langford, 2002), can be viewed as a simplification of the reward
maximization objective.
As a purported approximation of the true returns, one would expect that the surrogate objective
landscape approximates the true reward landscape fairly well. That is, parameters corresponding to
good surrogate objective will also correspond to good true reward.
Figure 6 shows that in the early stages of training, the optimization landscapes of the true reward
and surrogate objective are indeed approximately aligned. However, as training progresses, the
surrogate objective becomes much less predictive of the true reward in the relevant sample regime. In
particular, we often observe that directions that increase the surrogate objective lead to a decrease of
the true reward (see Figures 6, 7). In a higher-sample regime (using several orders of magnitude more
samples), we find that PPO and TRPO turn out to behave rather differently. In the case of TRPO,
the update direction following the surrogate objective matches the true reward much more closely.
However, for PPO we consistently observe landscapes where the step direction leads to lower true
reward, even in the high-sample regime. This suggests that even when estimated accurately enough,
100,000 state-action pairs
2,000 state-action pairs
(-21 trajectories)
20,000 state-action pairs
(~1187 trajectories)
Figure 5:	True reward landscape concentration for TRPO on Humanoid-v2. We visualize the land-
scape at a training iteration 150 while varying the number of trajectories used in reward estimation
(each subplot), both in the direction of the step taken and a random direction. Moving one unit along
the “step direction” axis corresponds to moving one full step in parameter space. In the random di-
rection one unit corresponds to moving along a random norm 2 Gaussian vector in the parameter
space. In practice, the norm of the step is typically an order of magnitude lower than the random
direction. While the landscape is very noisy in the low-sample regime, large numbers of samples
reveal a well-behaved underlying landscape. See Figures 20, 19 of the Appendix for additional plots.
6
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate True reward
Many state-action pairs (106)
Surrogate True reward
Figure 6:	True reward and surrogate objective landscapes for TRPO on the Humanoid-v2 MuJoCo
task. We visualize the landscapes in the direction of the update step and a random direction (as in
Figure 5). The surrogate objective corresponds to the actual function optimized by the algorithm at
each step. We estimate true reward with 106 state-action pairs per point. We compare the landscapes
at different points in training and with varying numbers of state-action pairs used in the update step.
Early in training the true and surrogate landscapes align fairly well in both sample regimes, but later
become misaligned in the low-sample regime. More landscapes in Appendix Figures 13-18.
the surrogate objective might not be an accurate proxy for the true reward. (Recall from Section 2.1
that this is a sample regime where we are able to estimate the true gradient of the reward fairly well.)
3	Towards Stronger Foundations for Deep RL
Deep reinforcement learning (RL) algorithms have shown great practical promise, and are rooted
in a well-grounded theoretical framework. However, our results indicate that this framework often
fails to provide insight into the practical performance of these algorithms. This disconnect impedes
our understanding of why these algorithms succeed (or fail), and is a major barrier to addressing key
challenges facing deep RL such as brittleness and poor reproducibility.
To close this gap, we need to either develop methods that adhere more closely to theory, or build
theory that can capture what makes existing policy gradient methods successful. In both cases, the
first step is to precisely pinpoint where theory and practice diverge. To this end, we analyze and
consolidate our findings from the previous section.
Gradient estimation. Our analysis in Section 2.1 shows that the quality of gradient estimates that
deep policy gradient algorithms use is rather poor. Indeed, even when agents improve, such gradient
estimates often poorly correlate with the true gradient (c.f. Figure 2). We also note that gradient cor-
relation decreases as training progresses and task complexity increases. While this certainly does not
preclude the estimates from conveying useful signal, the exact underpinnings of this phenomenon
in deep RL still elude us. In particular, in Section 2.1 we outline a few keys ways in which the
deep RL setting is quite unique and difficult to understand from an optimization perspective, both
theoretically and in practice Overall, understanding the impact of gradient estimate quality on deep
RL algorithms is challenging and largely unexplored.
Value prediction. The findings presented in Section 2.2 identify two key issues. First, while the
value network successfully solves the supervised learning task it is trained on, it does not accurately
model the “true” value function. Second, employing the value network as a baseline does decrease
the gradient variance (compared to the trivial (“zero”) baseline). However, this decrease is rather
marginal compared to the variance reduction offered by the “true” value function.
It is natural to wonder whether this failure in modeling the value function is inevitable. For example,
how does the loss function used to train the value network impact value prediction and variance
reduction? More broadly, we lack an understanding of the precise role of the value network in
7
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate True reward
Many state-action pairs (106)
Surrogate True reward
Figure 7:	True reward and surrogate objective landscapes for PPO on the Humanoid-v2 MuJoCo
task. See Figure 6 for a description. We observe that early in training the true and surrogate land-
scapes align well. However, later increasing the surrogate objective leads to lower true reward.
training. Can we empirically quantify the relationship between variance reduction and performance?
And does the value network play a broader role than just variance reduction?
Optimization landscape. We have also seen, in Section 2.3, that the optimization landscape in-
duced by modern policy gradient algorithms, the surrogate objective, is often not reflective of the
underlying true reward landscape. We thus need a deeper understanding of why current methods
succeed despite these issues, and, more broadly, how to better navigate the true reward landscape.
4	Related Work
The idea of using gradient estimates to update neural network-based RL agents dates back at least
to the REINFORCE (Williams, 1992) algorithm. Later, Sutton (Sutton et al., 1999) established a
unifying framework casting these algorithms as instances of the policy gradient class of algorithms.
Our work focuses on proximal policy optimization (PPO) (Schulman et al., 2017) and trust region
policy optimization (TRPO) (Schulman et al., 2015a), which are two of the most prominent policy
gradient algorithms used in deep RL, drawing inspiration from works on related algorithms, such
as (Peters et al., 2010) and Kakade (2001).
Many recent works document the brittleness of deep RL algorithms (Henderson et al., 2018; 2017;
Islam et al., 2017). (Rajeswaran et al., 2017) and (Mania et al., 2018) demonstrate that on many
benchmark tasks, state-of-the-art performance can be attained by augmented randomized search
approaches. McCandlish et al. (2018) investigates gradient noise in large-batch settings, and Ahmed
et al. (2018) investigates the role of entropy regularization (which we do not study) on optimization.
5	Conclusion
In this work, we analyze the degree to which key primitives of deep policy gradient algorithms
follow their conceptual underpinnings. Our experiments show that these primitives often do not
conform to the expected behavior: gradient estimates poorly correlate with the true gradient, better
gradient estimates can require lower learning rates and can induce degenerate agent behavior, value
networks reduce gradient estimation variance to a significantly smaller extent than the true value,
and the underlying optimization landscape can be misleading.
This demonstrates that there is a significant gap between the theory inspiring current algorithms and
the actual mechanisms driving their performance. Overall, our findings suggest that developing a
deep RL toolkit that is truly robust and reliable will require moving beyond the current benchmark-
driven evaluation model to a more fine-grained understanding of deep RL algorithms.
8
Published as a conference paper at ICLR 2020
References
Zafarali Ahmed, Nicolas Le Roux, Mohammad Norouzi, and Dale Schuurmans. Understanding the
impact of entropy on policy optimization, 2018.
Alexandre d’Aspremont. Smooth optimization with approximate gradient. SIAM Journal on Opti-
mization,19:1171-1183, 2008.
Miyuru Dayarathna, Yonggang Wen, and Rui Fan. Data center energy consumption modeling: A
survey. IEEE Communications Surveys & Tutorials, 18(1):732-794, 2016.
Peter Henderson, Riashat Islam, Philip Bachman, Joelle Pineau, Doina Precup, and David Meger.
Deep reinforcement learning that matters. arXiv preprint arXiv:1709.06560, 2017.
Peter Henderson, Joshua Romoff, and Joelle Pineau. Where did my optimum go?: An empirical
analysis of gradient descent optimization in policy gradient methods, 2018.
SePP Hochreiter and Jurgen Schmidhuber. Flat minima. Neural Computation, 9:1T2, 1997.
Riashat Islam, Peter Henderson, Maziar Gomrokchi, and Doina Precup. Reproducibility of bench-
marked deeP reinforcement learning tasks for continuous control. In ICML Reproducibility in
Machine Learning Workshop, 2017.
Sham M. Kakade. A natural Policy gradient. In NIPS, 2001.
Sham M. Kakade and John Langford. APProximately oPtimal aPProximate reinforcement learning.
In ICML, 2002.
Kenji Kawaguchi. DeeP learning without Poor local minima. In NIPS, 2016.
Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Pe-
ter Tang. On large-batch training for deeP learning: Generalization gaP and sharP minima. CoRR,
abs/1609.04836, 2016.
Roi Livni, Shai Shalev-Shwartz, and Ohad Shamir. On the comPutational efficiency of training
neural networks. In NIPS, 2014.
Horia Mania, Aurelia Guy, and Benjamin Recht. SimPle random search Provides a comPetitive
aPProach to reinforcement learning. CoRR, abs/1803.07055, 2018.
Sam McCandlish, Jared KaPlan, Dario Amodei, and OPenAI Dota Team. An emPirical model of
large-batch training, 2018.
OPenAI. OPenai five. https://blog.openai.com/openai-five/, 2018.
OPenAI, :, Marcin Andrychowicz, Bowen Baker, Maciek Chociej, Rafal Jozefowicz, Bob McGrew,
Jakub Pachocki, Arthur Petron, Matthias PlaPPert, Glenn Powell, Alex Ray, Jonas Schneider, Szy-
mon Sidor, Josh Tobin, Peter Welinder, Lilian Weng, and Wojciech Zaremba. Learning dexterous
in-hand maniPulation, 2018.
Jan Peters, Katharina Mulling, and Yasemin Altun. Relative entroPy Policy search. In AAAI, 2010.
Aravind Rajeswaran, Kendall Lowrey, Emanuel Todorov, and Sham M. Kakade. Towards general-
ization and simPlicity in continuous control. In NIPS, 2017.
Herbert Robbins and Sutton Monro. A stochastic aPProximation method. Ann. Math. Statist., 22(3):
400-407, 09 1951. doi: 10.1214/aoms/1177729586. URL https://doi.org/10.1214/
aoms/1177729586.
Itay Safran and Ohad Shamir. SPurious local minima are common in two-layer relu neural networks.
In ICML, 2018.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and PhiliPP Moritz. Trust region
Policy oPtimization. In International Conference on Machine Learning, PP. 1889-1897, 2015a.
9
Published as a conference paper at ICLR 2020
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-
dimensional continuous control using generalized advantage estimation. arXiv preprint
arXiv:1506.02438, 2015b.
John Schulman, Philipp Moritz, Sergey Levine, Michael I. Jordan, and Pieter Abbeel. High-
dimensional continuous control using generalized advantage estimation. CoRR, abs/1506.02438,
2015c.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy
optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez,
Thomas Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of go
without human knowledge. Nature, 550(7676):354, 2017.
Ilya Sutskever. Keynote talk. NVIDIA NTECH, 2018. URL https://www.youtube.com/
watch?v=w3ues-NayAs&t=467s.
Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction. MIT press, 2018.
Richard S. Sutton, David A. McAllester, Satinder P. Singh, and Yishay Mansour. Policy gradient
methods for reinforcement learning with function approximation. In NIPS, 1999.
Ronald J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine Learning, 8:229-256, 1992.
10
Published as a conference paper at ICLR 2020
A	Appendix
A.1 Background
In the reinforcement learning (RL) setting, an agent interacts with a stateful environment with the
goal of maximizing cumulative reward. Formally, we model the environment as a (possibly random-
ized) function mapping its current state s and an action a supplied by the agent to a new state s0 and
a resulting reward r. The choice of actions of the agent is governed by the its policy π. This policy
is a function mapping environment states to a distribution over the actions to take. The objective of
an RL algorithm is to find a policy π which maximizes the expected cumulative reward, where the
expectation is taken over both environment randomness and the (randomized) action choices.
Preliminaries and notation. For a given policy ∏, We denote by ∏(a∣s) the probability that this
policy assigns to taking action a when the environment is in the state s. We use r(s, a) to denote
the reWard that the agent earns for playing action a in response to the state s. A trajectory τ =
{(at, st) : t ∈ {1 . . . T}} is a sequence of state-action pairs that constitutes a valid transcript of
interactions of the agent With the environment. (Here, at (resp. st) corresponds to the action taken
by the agent (resp. state of the environment) in the t-th round of interaction.) We then define π(τ)
to be the probability that the trajectory τ is executed if the agent folloWs policy π (provided the
initial state of the environment is s1). Similarly, r(τ) = Pt r(st, at) denotes the cumulative reWard
earned by the agent When folloWing this trajectory, Where st (resp. at) denote the t-th state (resp.
action) in the trajectory τ . In the RL setting, hoWever, We often choose to maximize the discounted
cumulative reWard of a policy R := R1 , Where Rt is defined as
∞
Rt(τ)=Xγ(t0-t)rt0.
t0=t
and 0 < γ < 1 is a “discount factor”. The discount factor ensures that the cumulative reWard of
a policy is Well-defined even for an infinite time horizon, and it also incentivizes achieving reWard
earlier.
Policy gradient methods. A Widely used class of RL algorithms that Will be the focus of our
analysis is the class of so-called policy gradient methods. The central idea behind these algorithms
is to first parameterize the policy πθ using a parameter vector θ. (In the deep RL context, πθ is
expressed by a neural netWork With Weights θ.) Then, We perform stochastic gradient ascent on the
cumulative reWard With respect to θ . In other Words, We Want to apply the stochastic ascent approach
to our problem:
max ET〜∏θ[r(τ)] ,	(5)
θ
where T 〜∏ represents trajectories (rollouts) sampled from the distribution induced by the policy
πθ. This approach relies on the key observation (Sutton et al., 1999) that under mild conditions, the
gradient of our objective can be written as:
▽sE「〜∏θ[r(τ)] = ET〜∏θVθ log(∏θ(τ)) r(τ)],	(6)
and the latter quantity can be estimated directly by sampling trajectories according to the policy πθ .
When we use the discounted variant of the cumulative reward and note that the action of the policy
at time t cannot affect its performance at earlier times, we can express our gradient estimate as:
gθ = ET〜∏θ	〉:	▽ θ log πθ (at | St) ∙ Q∏θ (st, at)	,	⑺
(st,at)∈T
where Qπθ (st, at) represents the expected returns after taking action at from state st:
Qπθ (st, at) = Eπθ [Rt|at, st] .
(8)
11
Published as a conference paper at ICLR 2020
Value estimation and advantage. Unfortunately, the variance of the expectation in (7) can be (and
often is) very large, which makes getting an accurate estimate of this expectation quite challenging.
To alleviate this issue, a number of variance reduction techniques have been developed. One of the
most popular such techniques is the use of a so-called baseline function, wherein a state-dependent
value is subtracted from Qπθ . Thus, instead of estimating (7) directly, we use:
gθ = ET 〜∏θ	E	Vθ log ∏θ (at∣st) ∙ (Q∏θ (St ,at) - b(st)) ,	(9)
(st,at)∈τ
where b(∙) is a baseline function of our choice.
A natural choice of the baseline function is the value function, i.e.
Vπθ(st) = Eπθ [Rt|st] .	(10)
When we use the value function as our baseline, the resulting gradient estimation problem becomes:
gθ = ET 〜∏θ	〉: V θ log πθ (at | St) ∙ A∏θ (st, at) ,	(II)
(st,at)∈τ
where
Aπθ (St, at) = Qπθ (St, at) - Vπθ (St)	(12)
is referred to as the advantage of performing action at . Different methods of estimating Vπθ have
been proposed, with techniques ranging from moving averages to the use of neural network predic-
tors Schulman et al. (2015b).
Surrogate Objective. So far, our focus has been on extracting a good estimate of the gradient
with respect to the policy parameters θ. However, it turns out that directly optimizing the cumula-
tive rewards can be challenging. Thus, a modification used by modern policy gradient algorithms
is to optimize a “surrogate objective” instead. We will focus on maximizing the following local
approximation of the true reward Schulman et al. (2015a):
max
θ
at
∏θ (at∣St)
∏(at∣St)
Aπ (St , at )
Eπθ [Aπ] ,
or the normalized advantage variant proposed to reduce variance Schulman et al. (2017):
max
θ
E(st,at)~π
∏θ (at ∣St)
∏(at∣St)
7/一 一、
Aπ (St, at)
where
An - μ(A∏)
σ(A∏)
(13)
(14)
(15)
and π is the current policy.
Trust region methods. The surrogate objective function, although easier to optimize, comes at a
cost: the gradient of the surrogate objective is only predictive of the policy gradient locally (at the
current policy). Thus, to ensure that our update steps we derive based on the surrogate objective are
predictive, they need to be confined to a “trust region” around the current policy. The resulting trust
region methods (Kakade, 2001; Schulman et al., 2015a; 2017) try to constrain the local variation of
the parameters in policy-space by restricting the distributional distance between successive policies.
A popular method in this class is trust region policy optimization (TRPO) Schulman et al. (2015a),
which constrains the KL divergence between successive policies on the optimization trajectory, lead-
ing to the following problem:
max
θ
at
∏θ (at∣St)
.∏(at∣St)
T ( . . ∖
Aπ (St , at )
s.t. DKLg(∙ | s)∣∣∏(∙∣ s)) ≤ δ, ∀s.
(16)
In practice, this objective is maximized using a second-order approximation of the KL divergence
and natural gradient descent, while replacing the worst-case KL constraints over all possible states
with an approximation of the mean KL based on the states observed in the current trajectory.
12
Published as a conference paper at ICLR 2020
Proximal policy optimization. In practice, the TRPO algorithm can be computationally costly—
the step direction is estimated with nonlinear conjugate gradients, which requires the computation
of multiple Hessian-vector products. To address this issue, Schulman et al. Schulman et al. (2017)
propose proximal policy optimization (PPO), which utilizes a different objective and does not com-
pute a projection. Concretely, PPO proposes replacing the KL-constrained objective (16) of TRPO
by clipping the objective function directly as:
max E(st,at)〜∏
θ
min clip (ρt, 1 - ε, 1 + ε) Abπ(st, at), ρtAbπ(st, at)
(17)
where
∏ (at∣st)
∏(at∣st)
(18)
In addition to being simpler, PPO is intended to be faster and more sample-efficient than
TRPO (Schulman et al., 2017).
13
Published as a conference paper at ICLR 2020
A.2 Experimental Setup
We use the following parameters for PPO and TRPO based on a hyperparameter grid search:
Table 1: Hyperparameters for PPO and TRPO algorithms.
	Humanoid-v2		Walker2d-v2		Hopper-v2	
	PPO	TRPO	PPO	TRPO	PPO	TRPO
Timesteps per iteration	2048	2048	2048	2048	2048	2048
Discount factor (γ)	0.99	0.99	0.99	0.99	0.99	0.99
GAE discount (λ)	0.95	0.95	0.95	0.95	0.95	0.95
Value network LR	0.0001	0.0003	0.0003	0.0003	0.0002	0.0002
Value net num. epochs	10	10	10	10	10	10
Policy net hidden layers	[64, 64]	[64, 64]	[64, 64]	[64, 64]	[64, 64]	[64, 64]
Value net hidden layers	[64, 64]	[64, 64]	[64, 64]	[64, 64]	[64, 64]	[64, 64]
KL constraint (δ)	N/A	0.07	N/A	0.04	N/A	0.13
Fisher est. fraction	N/A	0.1	N/A	0.1	N/A	0.1
Conjugate grad. steps	N/A	10	N/A	10	N/A	10
CG damping	N/A	0.1	N/A	0.1	N/A	0.1
Backtracking steps	N/A	10	N/A	10	N/A	10
Policy LR (Adam)	0.00025	N/A	0.0004	N/A	0.00045	N/A
Policy epochs	10	N/A	10	N/A	10	N/A
PPO Clipping ε	0.2	N/A	0.2	N/A	0.2	N/A
Entropy coeff.	0.0	0.0	0.0	0.0	0.0	0.0
Reward clipping	[-10, 10]	—	[-10, 10]	—	[-10, 10]	—
Reward normalization	On	Off	On	Off	On	Off
State clipping	[-10, 10]	—	[-10, 10]	—	[-10, 10]	—
All error bars we plot are 95% confidence intervals, obtained via bootstrapped sampling.
14
Published as a conference paper at ICLR 2020
A.3 S tandard Reward Plots
# Iteration
# Iteration
(b) Walker2d-v2
PJeM①工Ue①W
# Iteration
(c) Humanoid-v2
Figure 8:	Mean reward for the studied policy gradient algorithms on standard MuJoCo benchmark
tasks. For each algorithm, we perform 24 random trials using the best performing hyperparameter
configuration, with 10 of the random agents shown here.
15
Published as a conference paper at ICLR 2020
A.4 Quality of Gradient Estimation
# Iteration: 0
UJ 一 S SoU(υs 一 MJ-Pd ⅛><
ιo3 ιo4 ιos
# State-Action Pairs
# Iteration： 150
...
E-OT Wou SMJrad ⅛><
IO2 IO3 IO4 10s	10«
# State-Action Pairs
E-OT Wou SMJrad
-0.5
# Iteration： 300
IO2 IO3 IO4 10s	10«
# State-Action Pairs
E-OT Wou SMJrad
# Iteration： 450
IO2 IO3 IO4 10s IO6
# State-Action Pairs
(a) Walker2d-v2
E-S SoU BS-MJ-Pd ⅛><
E-OT Wou SMJrad .6AV
# Iteration: 150
IO2 IO9 IO4 IO5 IO6
# State-Action Pairs
SoU 3s-MJ-tud ⅛><
# Iteration: 300
E-ω SoU BS-MJ-Pd
# Iteration： 450
IO2 IO3 IO4 10s IO6
# State-Action Pairs
(b) Hopper-v2
Figure 9:	Empirical variance of the gradient (c.f. (1)) as a function of the number of state-action
pairs used in estimation for policy gradient methods. We obtain multiple gradient estimates using
a given number of state-action pairs from the policy at a particular iteration. We then measure the
average pairwise cosine similarity between these repeated gradient measurements, along with the
95% confidence intervals (shaded). Each of the colored lines (for a specific algorithm) represents
a particular trained agent (we perform multiple trials with the same hyperparameter configurations
but different random seeds). The dotted vertical black line (at 2K) indicates the sample regime used
for gradient estimation in standard practical implementations of policy gradient methods.
16
Published as a conference paper at ICLR 2020
ptu」6(υnJ4 q⅛M UJ-S ωou ⅛><
ι.o
0.0
# Iteration： 0
TKPO
PPO
# Iteration： 150
# Iteration: 300
0.5
0 5 0 5
. . . ■
Ptu.I6(υΓU4q⅛M UJ 一 S ωou ⅛><
ιo3 ιo4 ιos
# State-Action Pairs
Q.5Q.5
Ioo-O
Ptu.I6(υΓU4q⅛M UJ 一 S ωou ⅛><
ιo3 ιo4 ιos
# State-Action Pairs
O6
(a) Walker2d-v2
IO2 IO3 IO4 10s IO6
# State-Action Pairs
Ptu.I6(urluf-M E-ω ωou ⅛><
# Iteration： 150
0 5 0 5
. . . ■
Ptu.I6(υnJ4lμ-M E-ω S8⅛>v
IO3 IO4 10s
# State-Action Pairs
ptu」6(υnJ4 七-M E-ω
# Iteration： 300
1.0
0.5
0.0
IO2 IO3 IO4 10s IO6
# State-Action Pairs
Ptu.I6(υΓU4q⅛M UJ 一 S ωou ⅛>< Ptu.I6(υnJ4lμ-M E-ω
(b)	Hopper-v2
Figure 10: Convergence of gradient estimates to the “true” expected gradient (c.f. (1)). We measure
the cosine similarity between the true gradient (approximated using around 1M samples) and gradi-
ent estimates, as a function of number of state-action pairs used to obtain the later. For a particular
policy and state-action pair count, we obtain multiple estimates of this cosine similarity and then
report the average, along with the 95% confidence intervals (shaded). Each of the colored lines (for
a specific algorithm) represents a particular trained agent (we perform multiple trials with the same
hyperparameter configurations but different random seeds). The dotted vertical black line (at 2K)
indicates the sample regime used for gradient estimation in standard practical implementations of
policy gradient methods.
17
Published as a conference paper at ICLR 2020
A.5 Value Prediction
——TRPO
0	100	200	300
# Iterations
400	500
(a) Hopper-v2
# Iterations
s∑ m<0
2 2 2
s∑ m<0
400	500
0	100	200	300
* I I * I * ■
- - - -
2 2 2 2
山aw su」n:Pa
# Iterations
(b) Walker2d-v2
# Iterations
0	100	200	300	400	500
# Iterations
s∑ SEmaU
0	100	200	300	400	500
# Iterations

(c)	Humanoid-v2
Figure 11:	Quality of value prediction in terms of mean relative error (MRE) on train state-action
pairs for agents trained to solve the MuJoCo tasks. We see in that the agents do indeed succeed at
solving the supervised learning task they are trained for - the train MRE on the GAE-based value
loss (Vold + AGAE)2 (c.f. (4)) is small (left column). We observe that the returns MRE is quite small
as well (right column).
18
Published as a conference paper at ICLR 2020
2-2	\	——TRPO
0	100	200	300	400	500
# Iterations
0	100	200	300	400	500
# Iterations
山l±∑SEna ①ɑ:
(a) Hopper-v2
——TRPO
0	100	200	300	400	500
# Iterations
山l±∑SEn3
——TRPO
——PPO
0	100	200	300	400	500
# Iterations
(b) Humanoid-v2
Figure 12:	Quality of value prediction in terms of mean relative error (MRE) on heldout state-action
pairs for agents trained to solve MuJoCo tasks. We see in that the agents do indeed succeed at
solving the supervised learning task they are trained for - the validation MRE on the GAE-based
value loss (Vold + AGAE)2 (c.f. (4)) is small (left column). On the other hand, we see that the
returns MRE is still quite high - the learned value function is off by about 50% with respect to the
underlying true value function (right column).
19
Published as a conference paper at ICLR 2020
A.6 0 petS 051 petS 003 petS 054 pet
Optimization Landscape
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action pairs (106)
Surrogate	True reward
Figure 13: HUmanoid-v2 - PPO reward landscapes.
20
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action pairs (106)
Surrogate	True reward
Step 450	Step 300	Step 150	Step 0
Figure 14: HUmanoid-v2 - TRPO reward landscapes.
21
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action pairs (106)
Surrogate	True reward
Step 450	Step 300	Step 150	Step 0
Figure 15: Walker2d-v2-
PPO reward landscapes.
22
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action pairs (106)
Surrogate	True reward
Step 450	Step 300	Step 150	Step 0
Figure 16: Walker2d-v2 - TRPO reward landscapes.
23
Published as a conference PaPer at ICLR 2020
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action pairs (106)
Surrogate	True reward
0d°IS
号 d°IS
Figure 17: HoPPer-V2 - PPO reward landscapes.
OoS es 。泮 dRS
24
Published as a conference paper at ICLR 2020
Few state-action pairs (2,000)
Surrogate	True reward
Many state-action Pairs (106)
Surrogate	True reward
Step 450	Step 300	Step 150	Step 0
Figure 18: HoPPer-V2 - TRPO reward landscapes.
25
Published as a conference paper at ICLR 2020
Step 450	Step 300	Step 150	Step 0
2,000 state-action pairs
20,000 state-action pairs
100,000 state-action pairs
(~1102 trajectories)
475 ʌ
470 ʌ
465 i
460-∣
455-
3.0
Λ5∖
V-O ∖
¾ 1.5 ∖
11.0
⅞0∙5∖^________一一,I25 30
oo 0 5 1-0 1Atrectton
0.0 05 erad^td're
Figure 19: Humanoid-v2 TRPO landscape concentration (see Figure 5 for a description).
26
Published as a conference paper at ICLR 2020
2,000 state-action pairs
20,000 state-action pairs
100,000 state-action pairs
Step 450	Step 300	Step 150	Step 0
(~16 trajectories)
(~735 trajectories)
640
620
600
580
5«
⅛W
520
500
H'
√∙5
V1.5
Vo
% 0.5
0.0
17θi
164)1
1504
IWL
130-!
120-
110∙⅞
3.0
∕5∖,
¾2-θ∖
¾1.5∖
*1.0
¾0∙5∖^^^^^L 2.5 3.。
00 0.0 o≡
(~209 trajectories)
(~1062 trajectories)
480.
477.
475.
472.
470.
467.
465.
4β2.
460.
3.0
(~990 trajectories)
610
600 ʌ
590 ʌ
5β04
570-I
5«-I
550 4
5«-
530-
3.0
Λ5∖
V-O ∖
θ 1.5
V-0	L
⅞0∙5∖→^^一「7 25 30
00	05 1-0 1Λwsctt<*1
0.0	05 GEdtefdga
(~182 trajectories)
570-
5«
550」
5«
3.0 ∖VF
√∙A
¾2-θ∖
¾1.5∖
vʌ
% 0.5
25 30
2.0 "Q
(~938 trajectories)
5704-
565-I
560 i
555-1
550 j
5454
540」
535-
3.0
CoWW≡≡≡W
V∙5∖
v-o∖	一 W士壬*
”52匚田匚一2.5 3∙0
OQ 0 5 1.0 1Λltectton
0.0 05 GedMUtde
Figure 20: Humanoid-v2 PPO landscape concentration (see Figure 5 for a description).
27