Published as a conference paper at ICLR 2020
BackPACK: Packing more into Backprop
Felix Dangel*
University of Tuebingen
fdangel@tue.mpg.de
Frederik Kunstner*
University of Tuebingen
kunstner@cs.ubc.ca
Philipp Hennig
University of Tuebingen and MPI for Intelligent Systems, Tuebingen
ph@tue.mpg.de
Ab stract
Automatic differentiation frameworks are optimized for exactly one thing: com-
puting the average mini-batch gradient. Yet, other quantities such as the variance
of the mini-batch gradients or many approximations to the Hessian can, in theory,
be computed efficiently, and at the same time as the gradient. While these quan-
tities are of great interest to researchers and practitioners, current deep-learning
software does not support their automatic calculation. Manually implementing
them is burdensome, inefficient if done naively, and the resulting code is rarely
shared. This hampers progress in deep learning, and unnecessarily narrows re-
search to focus on gradient descent and its variants; it also complicates repli-
cation studies and comparisons between newly developed methods that require
those quantities, to the point of impossibility. To address this problem, we intro-
duce BackPACK* 1, an efficient framework built on top of PyTorch, that extends
the backpropagation algorithm to extract additional information from first- and
second-order derivatives. Its capabilities are illustrated by benchmark reports for
computing additional quantities on deep neural networks, and an example appli-
cation by testing several recent curvature approximations for optimization.
1	Introduction
The success of deep learning and the applications it fuels can be traced to the populariza-
tion of automatic differentiation frameworks. Packages like TensorFlow (Abadi et al., 2016),
CHAINER (Tokui et al., 2015), MXNET (Chen et al., 2015), and PYTORCH (Paszke et al., 2019)
provide efficient implementations of parallel, GPU-based gradient computations to a wide range of
users, with elegant syntactic sugar.
However, this specialization also has its shortcomings: it assumes the user only wants to compute
gradients or, more precisely, the average of gradients across a mini-batch of examples. Other quan-
tities can also be computed with automatic differentiation at a comparable cost or minimal overhead
to the gradient backpropagation pass; for example, approximate second-order information or the
variance of gradients within the batch. These quantities are valuable to understand the geometry of
deep neural networks, for the identification of free parameters, and to push the development of more
efficient optimization algorithms. But researchers who want to investigate their use face a chicken-
and-egg problem: automatic differentiation tools required to go beyond standard gradient methods
are not available, but there is no incentive for their implementation in existing deep-learning software
as long as no large portion of the users need it.
Second-order methods for deep learning have been continuously investigated for decades (e.g.,
Becker & Le Cun, 1989; Amari, 1998; Bordes et al., 2009; Martens & Grosse, 2015). But still,
the standard optimizers used in deep learning remain some variant of stochastic gradient descent
(sgd); more complex methods have not found wide-spread, practical use. This is in stark contrast to
domains like convex optimization and generalized linear models, where second-order methods are
* Equal contributions
1https://f-dangel.github.io/backpack/
1
Published as a conference paper at ICLR 2020
the default. There may of course be good scientific reasons for this difference; maybe second-order
methods do not work well in the (non-convex, stochastic) setting of deep learning. And the computa-
tional cost associated with the high dimensionality of deep models may offset their benefits. Whether
these are the case remains somewhat unclear though, because a much more direct road-block is that
these methods are so complex to implement that few practitioners ever try them out.
Recent approximate second-order methods such as kfac (Martens & Grosse, 2015) show promising
results, even on hard deep learning problems (Tsuji et al., 2019). Their approach, based on the earlier
work of Schraudolph (2002), uses the structure of the network to compute approximate second-
order information in a way that is similar to gradient backpropagation. This work sparked a new
line of research to improve the second-order approximation (Grosse & Martens, 2016; Botev et al.,
2017; Martens et al., 2018; George et al., 2018). However, all of these methods require low-level
applications of automatic differentiation to compute quantities other than the averaged gradient. It
is a daunting task to implement them from scratch. Unless users spend significant time familiarizing
themselves with the internals of their software tools, the resulting implementation is often inefficient,
which also puts the original usability advantage of those packages into question. Even motivated
researchers trying to develop new methods, who need not be expert software developers, face this
problem. They often end up with methods that cannot compete in runtime, not necessarily because
the method is inherently bad, but because the implementation is not efficient. New methods are also
frequently not compared to their predecessors and competitors because they are so hard to reproduce.
Authors do not want to represent the competition in an unfair light caused by a bad implementation.
Another example is offered by a recent string of research to adapt to the stochasticity induced by
mini-batch sampling. An empirical estimate of the (marginal) variance of the gradients within the
batch has been found to be theoretically and practically useful for adapting hyperparameters like
learning rates (Mahsereci & Hennig, 2017) and batch sizes (Balles et al., 2017), or regularize first-
order optimization (Le Roux et al., 2007; Balles & Hennig, 2018; Katharopoulos & Fleuret, 2018).
To get such a variance estimate, one simply has to square, then sum, the individual gradients after
the backpropagation, but before they are aggregated to form the average gradient. Doing so should
have negligible cost in principle, but is programmatically challenging in the standard packages.
Members of the community have repeatedly asked for such features2 but the established automatic
differentiation frameworks have yet to address such requests, as their focus has been—rightly—on
improving their technical backbone. Features like those outlined above are not generally defined for
arbitrary functions, but rather emerge from the specific structure of machine learning applications.
General automatic differentiation frameworks can not be expected to serve such specialist needs.
This does not mean, however, that it is impossible to efficiently realize such features within these
frameworks: In essence, backpropagation is a technique to compute multiplications with Jacobians.
Methods to extract second-order information (Mizutani & Dreyfus, 2008) or individual gradients
from a mini-batch (Goodfellow, 2015) have been known to a small group of specialists; they are just
rarely discussed or implemented.
1.1	Our contribution
To address this need for a specialized framework focused on machine learning, we propose a
framework for the implementation of generalized backpropagation to compute additional quantities.
The structure is based on the conceptual work of Dangel et al. (2019) for modular backpropagation.
This framework can be built on top of existing graph-based backpropagation modules; we provide
an implementation on top of PyTorch, coined BackPACK, available at
https://f-dangel.github.io/backpack/.
The initial release supports efficient computation of individual gradients from a mini-batch, their `2
norm, an estimate of the variance, as well as diagonal and Kronecker factorizations of the generalized
Gauss-Newton (ggn) matrix (see Tab. 1 for a feature overview). The library was designed to be
minimally verbose to the user, easy to use (see Fig. 1), and to have low overhead (see §3). While
other researchers are aiming to improve the flexibility of automatic differentiation systems (Innes,
2018a;b; Bradbury et al., 2018), our goal with this package is to provide access to quantities that are
only byproducts of the backpropagation pass, rather than gradients themselves.
2 See, e.g., the Github issues github.com/pytorch/pytorch/issues/1407, 7786, 8897
and forum discussions discuss.pytorch.org/t/1433, 8405, 15270, 17204, 19350, 24955.
2
Published as a conference paper at ICLR 2020
Computing the gradient with PyTorch ...	...and the variance with BackPACK
X, y	=	load_mnist_data()	X, y	=	load_mnist_data()
model	=	Linear(784, 10)	model	=	extend(Linear(784,	10))
lossfunc =	CrossEntropyLoss()	lossfunc =	extend(CrossEntropyLoss())
loss	=	lossfunc(model(X), y)	loss	=	lossfunc(model(X),	y)
with backpack(Variance()):
loss.backward()	loss.backward()
for param in model.parameters():	for param in model.parameters():
print(param.grad)	print(param.grad)
print(param.var)
Figure 1: BackPACK integrates with PyTorch to seamlessly extract more information from the
backward pass. Instead of the variance (or alongside it, in the same pass), BackPACK can compute
individual gradients in the mini-batch, their `2 norm and 2nd moment. It can also compute curvature
approximations like diagonal or Kronecker factorizations of the ggn such as kfac, kflr & kfra.
To illustrate the capabilities of BackPACK, we use itto implement preconditioned gradient descent
optimizers with diagonal approximations of the ggn and recent Kronecker factorizations kfac
(Martens & Grosse, 2015), kflr, and kfra (Botev et al., 2017). Our results show that the curvature
approximations based on Monte-Carlo (mc) estimates of the ggn, the approach used by kfac,
give similar progress per iteration to their more accurate counterparts, but being much cheaper to
compute. While the naive update rule We implement does not surpass first-order baselines such as
sgd with momentum and Adam (Kingma & Ba, 2015), its implementation with various curvature
approximations is made straightforWard.
2 Theory and Implementation
We will distiguish between quantities that can be computed from information already present during
a traditional backward pass (which we suggestively call first-order extensions), and quantities that
need additional information (termed second-order extensions). The former group contains additional
statistics such as the variance of the gradients within the mini-batch or the `2 norm of the gradient
for each sample. Those can be computed with minimal overhead during the backprop pass. The
latter class contains approximations of second-order information, like the diagonal or Kronecker
factorization of the generalized Gauss-Newton (ggn) matrix, which require the propagation of
additional information through the graph. We will present those two classes separately:
First-order extensions
Extract more from the standard backWard pass.
Second-order extensions
Propagate neW information along the graph.
一 Individual gradients from a mini-batch
一 '2 norm of the individual gradients
一 Diagonal covariance and 2nd moment
一 Diagonal of the GGN and the Hessian
一 KFAC (Martens & Grosse, 2015)
一 KFRA and KFLR (Botev et al., 2017)
These quantities are only defined, or reasonable to compute, for a subset of models: The concept
of individual gradients for each sample in a mini-batch or the estimate of the variance requires the
loss for each sample to be independent. While such functions are common in machine learning,
not all neural netWorks fit into this category. For example, if the netWork uses Batch Normalization
(Ioffe & Szegedy, 2015), the individual gradients in a mini-batch are correlated. Then, the variance
is not meaningful anymore, and computing the individual contribution of a sample to the mini-batch
gradient or the ggn becomes prohibitive. For those reasons, and to limit the scope of the project
for version 1.0, BackPACK currently restricts the type of models it accepts. The supported models
are traditional feed-forWard netWorks that can be expressed as a sequence of modules, for example
a sequence of convolutional, pooling, linear and activation layers. Recurrent netWorks like lstms
(Hochreiter & Schmidhuber, 1997) or residual netWorks (He et al., 2016) are not yet supported, but
the frameWork can be extended to cover them.
We assume a sequential model f : Θ × X → Y and a dataset ofN samples (xn, yn) ∈ X × Y With
n = 1,...,N. The model maps each sample Xn to a prediction y^n using some parameters θ ∈ Θ.
The predictions are evaluated With a loss function ` : Y × Y → R, for example the cross-entropy,
3
Published as a conference paper at ICLR 2020
Figure 2: Schematic rep-
resentation of the standard
backpropagation pass for
module i with N samples.
which compares them to the ground truth yn . This leads to the objective function L : Θ → R,
L(θ) = NN PL '(f(θ, Xn), yn) .	(1)
As a shorthand, we will use `n(θ) = `(f (θ, xn), yn) for the loss and fn(θ) = f(θ, xn) for the
model output of individual samples. Our goal is to provide more information about the derivatives
of {'n}N=ι with respect to the parameters θ of the model f.
2.1	Primer on backpropagation
Machine learning libraries with integrated automatic differentiation use the modular structure of
fn(θ) to compute derivatives (see Baydin et al. (2018) for an overview). If fn is a sequence of L
transformations, it can be expressed as
fn(θ) = Tθ(L(L)) ◦ ... ◦ Tθ(1(1))(xn),	(2)
where Tθ(i(i)) is the ith transformation with parameters θ(i), such that θ = [θ(1) , . . . , θ(L)]. The
loss function can also be seen as another transformation, appended to the network. Let zn(i-1) , zn(i)
denote the input and output of the operation Tθ(i(i)) for sample n, such that zn(0) is the original data
andZnI),…,ZnL)represent the transformed output of each layer, leading to the computation graph
Zn(0)--T-θ(-1-)(-z-n-→) Zn(1)
Tθ((22)) (zn(1))	Tθ(L(L)) (zn(L-1))
..
,r, `(ZnL)M)
(L) ---------→ `n(θ) .
Z
To compute the gradient of`n with respect to the θ(i), one can repeatedly apply the chain rule,
Ve(i)'(θ) = jθ(i) Zni))T (J” zni+ι))>... (Jz(L-1)ZnL))nV一金⑹)
zn	zn	zn
= (Jθ(i) zni))> (Vz(i) 'n(θ)),
(3)
where Jab is the Jacobian of b with respect to a, [Jab]j = ∂ [b]i∕∂[aj. A similar expression exists
for the module inputs Zn(i-1): V (i-1) `n(θ) = (J (i-1)Zn(i))>(V (i) `n(θ)). This recursive structure
zn	zn	zn
makes it possible to extract the gradient by propagating the gradient of the loss. In the backprop-
agation algorithm, a module i receives the loss gradient with respect to its output, V (i) `n(θ). It
zn
then extracts the gradient with respect to its parameters and inputs, Vθ(i) `n(θ) and V (i-1) `n(θ),
zn
according to Eq. 3. The gradient with respect to its input is sent further down the graph. This pro-
cess, illustrated in Fig. 2, is repeated for each transformation until all gradients are computed. To
implement backpropagation, each module only needs to know how to multiply with its Jacobians.
For second-order quantities, we rely on the work of Mizutani & Dreyfus (2008) and Dangel et al.
(2019), who showed that a scheme similar to Eq. 3 exists for the block-diagonal of the Hessian. A
block with respect to the parameters ofa module, V2θ(i) `n (θ), can be obtained by the recursion
Vθ(i) 'n(θ) = (Jθ(i) Zni))>(Vzni) 'n(θ))(Jθ(i) Zni) ) + Pj (Vθ(i)[ζni)]j) [Vzni) 'n(θ)[∙,	(4)
and a similar relation holds for the Hessian with respect to each module’s output, V2n(i) `n(θ).
Both backpropagation schemes of Eq. 3 and Eq. 4 hinge on the multiplication by Jacobians to both
vectors and matrices. However, the design of automatic differentiation limits the application of Ja-
cobians to vectors only. This prohibits the exploitation of vectorization in the matrix case, which
is needed for second-order information. The lacking flexibility of Jacobians is one motivation for
our work. Since all quantities needed to compute statistics of the derivatives are already computed
during the backward pass, another motivation is to provide access to them at minor overhead.
4
Published as a conference paper at ICLR 2020
Figure 3:	Computing individual gradients in a batch using
a for-loop (i.e. one individual forward and backward pass
per sample) or using vectorized operations with Back-
PACK. The plot shows computation time, comparing to
a traditional gradient computation, on the 3c3d network
(See §4) for the CIFAR- 1 0 dataset (Schneider et al., 2019).
Figure 4:	Schematic representa-
tion of the individual gradients’
extraction in addition to the stan-
dard backward pass at the ith
module for N samples.
2.2	First order extensions
As the principal first-order extension, consider the computation of the individual gradients in a batch
of size N . These individual gradients are implicitly computed during a traditional backward pass
because the batch gradient is their sum, but they are not directly accessible. The naive way to Com-
pute N individual gradients is to do N separate forward and backward passes, This (inefficiently)
replaces every matrix-matrix multiplications by N matrix-vector multiplications. BACKPACK’s ap-
proach batches computations to obtain large efficiency gains, as illustrated by Fig. 3.
As the quantities necessary to compute the individual gradients are already propagated through the
computation graph, we can reuse them by inserting code in the standard backward pass. With access
to this information, before it is cleared for memory efficiency, BackPACK computes the Jacobian-
multiplications for each sample
{Vθ(i) 'n(θ)}N=ι = {[Jθ(i) Zni) ]>Vz(i) 'n(θ)}N=ι ,	(5)
zn
without summing the result—see Fig. 4 for a schematic representation. This duplicates some of
the computation performed by the backpropagation, as the Jacobian is applied twice (once by Py-
Torch and BackPACK with and without summation over the samples, respectively). However,
the associated overhead is small compared to the for-loop approach: The major computational cost
arises from the propagation of information required for each layer, rather than the formation of the
gradient within each layer.
This scheme for individual gradient computation is the basis for all first-order extensions. In this
direct form, however, it is expensive in memory: if the model is D-dimensional, storing O(N D)
elements is prohibitive for large batches. For the variance, 2nd moment and `2 norm, BACKPACK
takes advantage of the Jacobian’s structure to directly compute them without forming the individual
gradient, reducing memory overhead. See Appendix A.1 for details.
2.3	Second-order extensions
Second-order extensions require propagation of more information through the graph. As an example,
we will focus on the generalized Gauss-Newton (ggn) matrix (Schraudolph, 2002). It is guaranteed
to be positive semi-definite and is a reasonable approximation of the Hessian near the minimum,
which motivates its use in approximate second-order methods. For popular loss functions, it coin-
cides with the Fisher information matrix used in natural gradient methods (Amari, 1998); for a more
in depth discussion of the equivalence, see the reviews of Martens (2014) and Kunstner et al. (2019).
For an objective function that can be written as the composition of a loss function ` and a model f,
such as Eq. 1, the ggn ofN Pn '(f(θ, Xn), =n)is
G(θ) = N Pn [Jθ f (θ, Xn)]> Vf '(f (θ, Xn), yn)[Jθ f(θ, Xn)] .	(6)
The full matrix is too large to compute and store. Current approaches focus on its diagonal blocks,
where each block corresponds to a layer in the network. Every block itself is further approximated,
5
Published as a conference paper at ICLR 2020
T {%T) ∙MN=1 ]—
*{{ [J Zn-I) fn] T Sn }N=I]—
Figure 5:	Schematic of the addi-
tional backward pass to compute a
symmetric factorization of the ggn,
G(θ) = Pn [Jθfn]>SnSn> [Jθfn]
alongside the gradient at the ith
module, for N samples.
for example using a Kronecker factorization. The approach used by BackPACK for their com-
putation is a refinement of the Hessian Backpropagation equations of Dangel et al. (2019). It re-
lies on two insights: Firstly, the computational bottleneck in the computation of the ggn is the
multiplication with the Jacobian of the network, Jθ fn, while the Hessian of the loss with respect
to the output of the network is easy to compute for most popular loss functions. Secondly, it is
not necessary to compute and store each of the N [D × D] matrices for a network with D pa-
rameters, as Eq. 6 is a quadratic expression. Given a symmetric factorization Sn of the Hessian,
SnS> = Vf '(f (θ, Xn), yn), it is sufficient to compute [Jθfn]>Sn and square the result. A net-
work output is typically small compared to its inner layers; networks on CIFAR- 1 00 need C = 100
class outputs but could use convolutional layers with more than 100,000 parameters.
The factorization leads to a [D×C] matrix, which makes it possible to efficiently compute GGN block
diagonals. Also, the computation is very similar to that of a gradient, which computes [Jθ f ]> Vfn'n.
A module Tθ((ii)) receives the symmetric factorization of the GGN with respect to its output, zn(i), and
multiplies it with the Jacobians with respect to the parameters θ(i) and inputs zn(i-1) to produce a
symmetric factorization of the ggn with respect to the parameters and inputs, as shown in Fig. 5.
This propagation serves as the basis of the second-order extensions. If the full symmetric factoriza-
tion is not wanted, for memory reasons, it is possible to extract more specific information such as
the diagonal. If B is the symmetric factorization for a GGN block, the diagonal can be computed as
[BB>]ii = Pj[B]2j, where Hij denotes the element in the ith row and jth column.
This framework can be used to extract the main Kronecker factorizations of the ggn, kfac and
kflr, which we extend to convolution using the approach of Grosse & Martens (2016). The im-
portant difference between the two methods is the initial matrix factorization Sn . Using a full sym-
metric factorization of the initial Hessian, SnSn = V2n'n, yields the KFLR approximation. KFAC
uses an MC-approximation by sampling a vector Sn such that Esn [sns> ] = Vfn'n KFLR is there-
fore more precise but more expensive than kfac, especially for networks with high-dimensional
outputs, which is reflected in our benchmark on cifar- 1 00 in Section 3. The technical details on
how Kronecker factors are extracted and information is propagated for second-order BackPACK
extensions are documented in Appendix A.2.
3	Evaluation and benchmarks
We benchmark the overhead of BackPACK on the cifar- 1 0 and cifar- 1 00 datasets, using the
3c3d network3 provided by DeepOB S (Schneider et al., 2019) and the All-CNN-C4 network of
Springenberg et al. (2015). The results are shown in Fig. 6.
For first-order extensions, the computation of individual gradients from a mini-batch adds noticeable
overhead due to the additional memory requirements of storing them. But more specific quantities
such as the `2 norm, 2nd moment and variance can be extracted efficiently. Regarding second-order
extensions, the computation of the ggn can be expensive for networks with large outputs like cifar-
100, regardless of the approximation being diagonal of Kronecker-factored. Thankfully, the mc
approximation used by kfac, which we also implement for a diagonal approximation, can be com-
puted at minimal overhead—much less than two backward passes. This last point is encouraging, as
our optimization experiment in Section 4 suggest that this approximation is reasonably accurate.
33C3D is a sequence of 3 convolutions and 3 dense linear layers with 895,210 parameters.
4ALL-CNN-C is a sequence of 9 convolutions with 1,387,108 parameters.
6
Published as a conference paper at ICLR 2020
Figure 6: Overhead benchmark for computing the gradient and first- or second-order extensions on
real networks, compared to just the gradient. Most quantities add little overhead. kflr and Diagggn
propagate 100× more information than KFAC and DiagGGN-MC on CIFAR- 1 00 and are two orders
of magnitude slower. We report benchmarks on those, and the Hessian’s diagonal, in Appendix B.
4	Experiments
To illustrate the utility of BackPACK, we implement preconditioned gradient descent optimizers
using diagonal and Kronecker approximations of the ggn. To our knowledge, and despite their
apparent simplicity, results using diagonal approximations or the naive damping update rule We
chose have not been reported in publications so far. However, this section is not meant to introduce a
bona-fide neW optimizer. Our goal is to shoW that BackPACK can enable research of this kind. The
update rule We implement uses a curvature matrix G(θt(i)), Which could be a diagonal or Kronecker
factorization of the GGN blocks, and a damping parameter λ to precondition the gradient:
Θ(+)1 = θ(i) - α(G(θ(i)) + λI)-1VL(θ(i)), i = 1,...,L.	(7)
We run the update rule With the folloWing approximations of the generalized Gauss-NeWton: the
exact diagonal (Diagggn) and an mc estimate (Diagggn-mc), and the Kronecker factorizations
kfac (Martens & Grosse, 2015), kflr and kfra5 (Botev et al., 2017). The inversion required by
the update rule is straightforWard for the diagonal curvature. For the Kronecker-factored quantities,
We use the approximation introduced by Martens & Grosse (2015) (see Appendix C.3).
These curvature estimates are tested for the training of deep neural netWorks by running the cor-
responding optimizers on the main test problems of the benchmarking suite DeepOB S (Schneider
et al., 2019).6 We use the setup (batch size, number of training epochs) of DeepOB S’ baselines,
and tune the learning rate α and damping parameter λ With a grid search for each optimizer (details
in Appendix C.2). The best hyperparameter settings is chosen according to the final accuracy on a
validation set. We report the median and quartiles of the performance for ten random seeds.
Fig. 7a shoWs the results for the 3c3d netWork trained on cifar- 1 0. The optimizers that leverage
Kronecker-factored curvature approximations beat the baseline performance in terms of per-iteration
progress on the training loss, training and test accuracy. Using the same hyperparameters, there is
little difference betWeen kfac and kflr, or Diagggn and Diagggn-mc. Given that the quantities
based on mc-sampling are considerably cheaper, this experiment suggests it being an important
technique for reducing the computational burden of curvature approximations.
Fig. 7b shoWs benchmarks for the All-CNN-C netWork trained on cifar- 1 00. Due to the high-
dimensional output, the curvatures using a full matrix propagation rather than an mc sample cannot
be run on this problem due to memory issues. Both Diagggn-mc and kfac can compete With the
baselines in terms of progress per iteration. As the update rule We implemented is simplistic on
purpose, this is promising for future applications of second-order methods that can more efficiently
use the additional information given by curvature approximations.
5 kfra Was not originally designed for convolutions; We extend it using the Kronecker factorization of
Grosse & Martens (2016). While it can be computed for small netWorks on mnist, Which We report in Ap-
pendix C.4, the approximate backWard pass of kfra does not seem to scale to large convolution layers.
6https://deepobs.github.io/. We cannot run BackPACK on all test problems in this bench-
mark due to the limitations outlined in Section 2. Despite this limitation, We still run on models spanning a
representative range of image classification problems.
7
Published as a conference paper at ICLR 2020
SSol u-s∙IH
5
.
11
(a)	CIFAR-10: 3c3d
ss-lsəj
ycarucca niarT
9 87
...
000
ycarucca tseT
0	20	40	60	80	100 0	20	40	60	80	100
Epoch	Epoch
(b)	CIFAR-100: ALL-CNN-C
Ss-u-sJH
32
----DiagGGN-MC-------KFAC
Adam	Momentum
32
ssol tseT
ycarucca niarT
864
...
000
864
...
000
ycarucca tseT
Figure 7: Median performance with shaded quartiles of the DEEPOBS benchmark for (a) 3c3d
network (895,210 parameters) on CIFAR-10 and (b) ALL-CNN-C network (1,387,108 parameters)
on cifar-100. Solid lines show baselines of momentum sgd and Adam provided by DeepOB S.
5 Conclusion
Machine learning’s coming-of-age has been accompanied, and in part driven, by a maturing of the
software ecosystem. This has drastically simplified the lives of developers and researchers alike, but
has also crystallized parts of the algorithmic landscape. This has dampened research in cutting-edge
areas that are far from mature, like second-order optimization for deep neural networks. To ensure
that good ideas can bear fruit, researchers must be able to compute new quantities without an over-
whelming software development burden. To support research and development in optimization for
deep learning, we have introduced Bac kPAC K, an efficient implementation in PyTorch of recent
conceptual advances and extensions to backpropagation (Tab. 1 lists all features). BackPACK en-
riches the syntax of automatic differentiation packages to offer additional observables to optimizers
beyond the batch-averaged gradient. Our experiments demonstrate that BackPACK’s implementa-
tion offers drastic efficiency gains over the kind of naive implementation within reach of the typical
researcher. As a demonstrative example, we “invented” a few optimization routines that, without
BackPACK, would require demanding implementation work and can now be tested with ease. We
hope that studies like this allow BackPACK to help mature the ML software ecosystem further.
Acknowledgments
The authors would like to thank Aaron Bahde, Ludwig Bald, and Frank Schneider for their help with
DeepOBS and Lukas Balles, Simon Bartels, Filip de Roos, Tim Fischer, Nicolas Kramer, Agustinus
Kristiadi, Frank Schneider, Jonathan Wenger, and Matthias Werner for constructive feedback.
The authors gratefully acknowledge financial support by the European Research Council through
ERC StG Action 757275 / PANAMA; the DFG Cluster of Excellence “Machine Learning - New
8
Published as a conference paper at ICLR 2020
Table 1: Overview of the features supported in the first release of BackPACK.
Feature	Details
Individual gradients	需储⑸'n(θ),	n = 1,...,N
Batch variance	N Pn=I "⑸'n(θ)]2 -%⑸ L(θ)]2
2nd moment	N PN=I "⑸'n(θ)]2 , j = 1,...,d⑴.
Indiv. gradient '2 norm	∣∣ NR§(*'n(θ)∣b , n = 1,...,N
DiagGGN	diag (G(θ(i)))
DiagGGN-MC	diag (G(θ(i)))
Hessian diagonal	diag(R；(i)L(θ))
KFAC	G(θ⑴)≈ A⑴ 0 BKiAC
KFLR	G(θ(i))	≈	A(i)	0	BKi)LR
KFRA	G(θ(i))	≈	A(i)	0	BK(iF)RA
Perspectives for Science”, EXC 2064/1, project number 390727645; the German Federal Ministry
OfEducation and Research (BMBF) through the Tubingen AI Center (FKZ: 01IS18039A); and funds
from the Ministry of Science, Research and Arts of the State of Baden-Wurttemberg. F. D. is grateful
to the International Max Planck Research School for Intelligent Systems (IMPRS-IS) for support.
References
Martin Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay
Ghemawat, Geoffrey Irving, Michael Isard, Manjunath Kudlur, Josh Levenberg, Rajat Monga, Sherry Moore,
Derek Gordon Murray, Benoit Steiner, Paul A. Tucker, Vijay Vasudevan, Pete Warden, Martin Wicke, Yuan
Yu, and Xiaoqiang Zheng. Tensorflow: A system for large-scale machine learning. In 12th USENIX Sympo-
sium on Operating Systems Design and Implementation, 2016.
Shun-ichi Amari. Natural gradient works efficiently in learning. Neural Computation, 10(2), 1998.
Lukas Balles and Philipp Hennig. Dissecting Adam: The sign, magnitude and variance of stochastic gradients.
In Proceedings of the 35th International Conference on Machine Learning, 2018.
Lukas Balles, Javier Romero, and Philipp Hennig. Coupling adaptive batch sizes with learning rates. In
Proceedings of the 33rd Conference on Uncertainty in Artificial Intelligence, 2017.
Atilim Gunes Baydin, Barak A. Pearlmutter, Alexey Andreyevich Radul, and Jeffrey Mark Siskind. Automatic
differentiation in machine learning: A survey. Journal of Machine Learning Research, 18(153), 2018.
Sue Becker and Yann Le Cun. Improving the convergence of back-propagation learning with second order
methods. In Proceedings of the 1988 Connectionist Models Summer School, 1989.
Antoine Bordes, Leon Bottou, and Patrick Gallinari. SGD-QN: careful quasi-Newton stochastic gradient de-
scent. J. Mach. Learn. Res., 10, 2009.
Aleksandar Botev, Hippolyt Ritter, and David Barber. Practical Gauss-Newton optimisation for deep learning.
In Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of
Machine Learning Research, 2017.
James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, and
Skye Wanderman-Milne. JAX: Composable transformations of Python+NumPy programs, 2018.
Tianqi Chen, Mu Li, Yutian Li, Min Lin, Naiyan Wang, Minjie Wang, Tianjun Xiao, Bing Xu, Chiyuan Zhang,
and Zheng Zhang. MXNet: A flexible and efficient machine learning library for heterogeneous distributed
systems. In 31st Conference on Neural Information Processing Systems, Workshop on Machine Learning
Systems, 2015.
Felix Dangel, Stefan Harmeling, and Philipp Hennig. A modular approach to block-diagonal Hessian approxi-
mations for second-order optimization methods. CoRR, abs/1902.01813, 2019.
9
Published as a conference paper at ICLR 2020
Thomas George, Cesar Laurent, Xavier Bouthillier, NiColas Ballas, and Pascal Vincent. Fast approximate
natural gradient descent in a Kronecker-factored eigenbasis. 2018.
Ian J. Goodfellow. Efficient per-example gradient computations. CoRR, abs/1510.01799, 2015.
Roger B. Grosse and James Martens. A Kronecker-factored approximate Fisher matrix for convolution layers.
In Proceedings of the 33rd International Conference on Machine Learning, volume 48 of JMLR Workshop
and Conference Proceedings, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In
2016 IEEE Conference on Computer Vision and Pattern Recognition, 2016.
SePP Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural Computation, 9(8), 1997.
Michael Innes. Flux: Elegant machine learning with Julia. Journal of Open Source Software, 3(25), 2018a.
Michael Innes. Don’t unroll adjoint: Differentiating SSA-form programs. CoRR, abs/1810.07951, 2018b.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing in-
ternal covariate shift. In Proceedings of the 32nd International Conference on Machine Learning, volume 37
of JMLR Workshop and Conference Proceedings, 2015.
Angelos Katharopoulos and Francois Fleuret. Not all samples are created equal: Deep learning with importance
sampling. In Proceedings of the 35th International Conference on Machine Learning, 2018.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In 3rd International Confer-
ence on Learning Representations, 2015.
Frederik Kunstner, Lukas Balles, and Philipp Hennig. Limitations of the empirical Fisher approximatiom. In
Advances in Neural Information Processing Systems 32, 2019.
Nicolas Le Roux, Pierre-Antoine Manzagol, and Yoshua Bengio. Topmoumoute online natural gradient algo-
rithm. In Advances in Neural Information Processing Systems 20, 2007.
Maren Mahsereci and Philipp Hennig. Probabilistic line searches for stochastic optimization. Journal of
Machine Learning Research, 18, 2017.
James Martens. New perspectives on the natural gradient method. CoRR, abs/1412.1193, 2014.
James Martens and Roger B. Grosse. Optimizing neural networks with Kronecker-factored approximate cur-
vature. In Proceedings of the 32nd International Conference on Machine Learning, volume 37 of JMLR
Workshop and Conference Proceedings, 2015.
James Martens, Jimmy Ba, and Matt Johnson. Kronecker-factored curvature approximations for recurrent
neural networks. In 6th International Conference on Learning Representations, 2018.
Eiji Mizutani and Stuart E. Dreyfus. Second-order stagewise backpropagation for Hessian-matrix analyses and
investigation of negative curvature. Neural Networks, 21(2-3), 2008.
Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen,
Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward Yang, Zachary
DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu Fang, Junjie Bai, and
Soumith Chintala. PyTorch: An imperative style, high-performance deep learning library. In Advances in
Neural Information Processing Systems 32. 2019.
Frank Schneider, Lukas Balles, and Philipp Hennig. DeepOBS: A deep learning optimizer benchmark suite. In
7th International Conference on Learning Representations, 2019.
Nicol N. Schraudolph. Fast curvature matrix-vector products for second-order gradient descent. Neural Com-
putation, 14(7), 2002.
Jost Tobias Springenberg, Alexey Dosovitskiy, Thomas Brox, and Martin A. Riedmiller. Striving for simplicity:
The all convolutional net. In 3rd International Conference on Learning Representations, 2015.
Seiya Tokui, Kenta Oono, Shohei Hido, and Justin Clayton. Chainer: A next-generation open source framework
for deep learning. In 29th Conference on Neural Information Processing Systems, Workshop on Machine
Learning Systems, 2015.
Yohei Tsuji, Kazuki Osawa, Yuichiro Ueno, Akira Naruse, Rio Yokota, and Satoshi Matsuoka. Performance op-
timizations and analysis of distributed deep learning with approximated second-order optimization method.
In 48th International Conference on Parallel Processing, Workshop Proceedings, 2019.
10
Published as a conference paper at ICLR 2020
BackPACK: Packing more into Backprop
Supplementary material
Table of Content
-§A: BACKPACK extensions
-	§A.1: First-order quantities
-	§ A.2: Second-order quantities based on the generalized GaUss-NeWton
-	§A.3: The exact Hessian diagonal
-	§B: Additional details on benchmarks
-	§C: Additional details on experiments
-	§D: BACKPACK cheat sheet
A BackPACK extensions
This section provides more technical details on the additional quantities extracted by BackPACK.
Notation: Consider an arbitrary module Tθ(i(i)) of a netWork i = 1, . . . , L, parameterized by θ(i). It
transforms the output of its parent layer for sample n, zn(i-1), to its output zn(i), i.e.
zn(i) =Tθ(i(i))(zn(i-1)), n= 1,...,N,	(8)
Where N is the number of samples. In particular, zn(0) = xn and zn(L) (θ) = f(xn, θ), Where f
(i)
is the transformation of the Whole netWork. The dimension of the hidden layer i’s output zn is
Written h(i) and θ(i) is of dimension d(i). The dimension of the netWork output, the prediction z(L),
is h(L) = C. For an image classification task, C corresponds to the number of classes.
All quantities are assumed to be vector-shaped. For image-processing transformations that usually
act on tensor-shaped inputs, We can reduce to the vector scenario by vectorizing all quantities; this
discussion does not rely on a specific flattening scheme. HoWever, for an efficient implementation,
vectorization should match the layout of the memory of the underlying arrays.
Jacobian: The Jacobian matrix Jab of an arbitrary vector b ∈ RB With respect to another vector
a ∈ RA is an [A × B] matrix of partial derivatives, [Jab]ij = ∂ [b]i /∂ [a]j.
A. 1 First-order quantities
The basis for the extraction of additional information about first-order derivatives is given by Eq. 3,
Which We state again for multiple samples,
1N	1N
Vθ(i) L(θ) = nn NVθ(i) 'n(θ) = NFN(Jθ(i) Zni))>(%ni) 'n(θ)).
During the backpropagation step of module i, we have access to V ⑸ '(θ), i = 1,...,N .To extract
zn
more quantities involving the gradient, we use additional information about the transformation Tθ(i()i)
within our custom implementation of the Jacobian Jθ(i) zn(i) and transposed Jacobian (Jθ(i) zn(i))>.
Individual gradients: The contribution of each sample to the overall gradient,得 V8(i)'n(θ), is
computed by application of the transposed Jacobian,
ɪ Vθ(i) 'n(θ) = ɪ(jθ(i) z^)τ(Vz (i) 'n(θ)) , n =1,...,N.	(9)
N	N n	zn
For each parameter θ(i) the individual gradients are of size [N × d(i)].
11
Published as a conference paper at ICLR 2020
Individual gradient '2 norm: The quantity ∣∣得Vθ(i)'n(θ)∣∣2, for n = 1,…,N, could be ex-
tracted from the individual gradients (Eq. 9) as
1	2	1	>1
耳vθ(i)'n⑹ 2= [n(Jθ(i)Zni))T(Vzni)金(叫	卜(Jθ(i)Zni))T(Vzni)`n⑹)
which is an N -dimensional object for each parameter θ(i). However, this is not memory efficient as
the individual gradients are an [N × d(i)] tensor. To circumvent this problem, BACKPACK uses the
structure of the Jacobian whenever possible.
For a specific example, take a linear layer with parameters θ as an [A × B] matrix. The layer trans-
forms the inputs Zn(i-1), an [N × A] matrix which we will now refer to as A. During the backward
pass, it receives the gradient of the individual losses with respect to its output, {得 Vz(i)'n}N=1, as
an [N × B] matrix which we will refer to as B. The overall gradient, an [A × B] matrix, can be com-
puted as ATB, and the individual gradients are a set ofN [A × B] matrices, {A[n, :]B[n, :]T}nN=1.
We want to avoid storing that information. To reduce the memory requirement, note that the indi-
vidual gradient norm can be written as
∣1	∣2
NVθ'n	=EE(A[n,i]B[n,j])2 ,
ij
and that the summation can be done independently for each matrix, as Pi Pj(A[n, i]B[n, j])2 =
(Pi A[n, i])2 (Pj B [n, j ]2 ). Therefore, we can square each matrix (element-wise) and sum over
non-batch dimensions. This yields vectors a, b of N elements, where a[n] = Pi A[n, i]2. The
individual gradients’ '2 norm is then given by a ◦ b where ◦ is element-wise multiplication.
Second moment: The gradient second moment (or more specifically, the diagonal of the second
moment) is the sum of the squared elements of the individual gradients in a mini-batch, i.e.
1N
NFE [Vθ(i) 'n(θ)]2 ,	j = 1,...,d ⑴.	(10)
n=1
It can be used to evaluate the variance of individual elements of the gradient (see below). The second
moment is of dimension d(i), the same dimension as the layer parameter θ(i). Similarly to the '2
norm, it can be computed from individual gradients, but is more efficiently computed implicitly.
Revisiting the example of the linear layer from the individual '2 norm computation, the second
moment of the parameters θ[i,j] is given by Pn(A[n, i]B[n,j])2, which can be directly computed
by taking the element-wise square of A and B element-wise, A2, B2, and computing A2TB2 .
Variance: Gradient variances over a mini-batch (or more precisely, the diagonal of the covariance)
can be computed using the second moment and the gradient itself,
1N
NE [Vθ(i) 'n(θ)]2 -[Vθ(i) L(θ)]j , j = 1,...,d ⑻.	(11)
n=1
The element-wise gradient variance of same dimension as the layer parameter θ(i), i.e. d(i).
A.2 Second-order quantities based on the generalized Gauss-Newton
The computation of quantities that originate from the approximations of the Hessian require an
additional backward pass (see Dangel et al. (2019)). Most curvature approximations supported by
BackPACK rely on the generalized Gauss-Newton (ggn) matrix (Schraudolph, 2002)
1N
G(θ) = N E(Jθ f(Xn, θ))>Vf '(f(Xn, θ), yn )Jθ f (Xn, θ)) ∙	(12)
n=1
One interpretation of the ggn is that it corresponds to the empirical risk Hessian when the model
f is approximated with its first-order Taylor expansion, i.e. by linearizing the network and ignoring
12
Published as a conference paper at ICLR 2020
second-order effects. Hence, the effect of module curvature in the recursive scheme of Eq. 4 can be
ignored to obtain the simpler expression
1N
G(θ(i)) = NFE(Jθ(i" )>Vf '(f(Xn，θ), yn)Jθ(i)f)
1N
=NN ∑(Jθ(i) zni))>G(zni))(Jθ(i) Zni))
n=1
(13)
for the exact block diagonal of the full GGN. In analogy to G(θ(i)) we have introduced the [d(i) ×
d(i)]-dimensional quantity
G(Zni)) = (Jji) f )>Vf '(f(xn, θ), yn)(Jz (i) f )
zn	zn
that needs to be backpropagated. The curvature backpropagation also follows from Eq. 4 as
G(Zn(i-1)) = (Jz(i-1)Zn(i))>G(Zn(i))(Jz(i-1)Zn(i)),	i= 1,...,L,	(14a)
zn	zn
and is initialized with the Hessian of the loss function with respect to the network prediction, i.e.
G(ZnL)) = Vf '(f(xn, θ), yn).	(14b)
Although this scheme is exact, it is computationally infeasible as it requires the backpropagation
ofN [h(i) × h(i)] matrices between module i + 1 and i. Even for small N , this is not possible for
networks containing large convolutions.
As an example, the first layer of the ALL-CNN-C network outputs 29 × 29 images with 96 channels,
which already gives h(i) = 80,736, which leads to half a Gigabyte per sample. Moreover, storing
all the [d(i) × d(i)]-dimensional blocks G(θ(i)) is not possible. BACKPACK implements different
approximation strategies, developed by Martens & Grosse (2015) and Botev et al. (2017) that address
both of these complexity issues from different perspectives.
Symmetric factorization scheme: One way to improve the memory footprint of the backpropa-
gated matrices in the case where the model prediction’s dimension C (the number of classes in an
image classification task) is small compared to all hidden features h(i) is to propagate a symmetric
factorization of the ggn instead. It relies on the observation that if the loss function itself is convex,
even though its composition with the network might not be, its Hessian with respect to the network
output can be decomposed as
V2f `(f (xn, θ), yn) = S(Zn(L))S(Zn(L))>	(15)
with the [C × C]-dimensional matrix factorization of the loss Hessian, S(Zn(L)), for sample n. Con-
sequently, the ggn in Eq. 12 reduces to an outer product,
1N	>
G(θ) = NN X [(Jθf )>S(znL))] [(Jθf )>S(znL))]	.	(16)
n=1
The analogue for diagonal blocks follows from Eq. 13 and reads
N>
G(θ(i)) = nn X [(Jθ(i)Zni))>s(Zni))] Me®Zni))>s(Zni))],	(。)
n=1
where we defined the [h(i) × C]-dimensional matrix square root S(Zn(i)) = (Jzn(i) f)>S(Zn(L)).
Instead of having layer i backpropagate N objects of shape [h(i) × h(i)] according to Eq. 14, we
instead backpropagate the matrix square root via
S(Zn(i-1)) = (Jz(i-1)Zn(i))>S(Zn(i))(Jz(i-1)Zn(i)),	i= 1,...,L,	(18)
zn	zn
starting with Eq. 15. This reduces the backpropagated matrix of layer i to [h(i) × C] for each sample.
13
Published as a conference paper at ICLR 2020
A.2.1 Diagonal curvature approximations
Diagonal of the ggn (Diagggn): The factorization trick for the loss Hessian reduces the size
of the backpropagated quantities, but does not address the intractable size of the ggn diagonal
blocks G(θ(i)). In BACKPACK, we can extract diag G(θ(i)) given the backpropagated quantities
S(zn(i)), i = 1, . . . , N, without building up the matrix representation of Eq. 17. In particular, we
compute
diag (G(θ⑺))=N X diag ([(Jθ(i)zni))>S(zni))i [(Jθ(i)zni))>S(zni))i>^ .	(19)
n=1
Diagonal of the ggn with mc sampled loss Hessian (Diagggn-mc): We use the same back-
propagation strategy of Eq. 18, replacing the symmetric factorization of Eq. 15 with an approxima-
tion by a smaller matrix S(ZnL)) of size [C X C] and C < C,
Vf '(f(Xn, θ), yn) ≈ S(ZnL)) (S(ZnL)))> .	(20)
This further reduces the size of backpropagated curvature quantities. Martens & Grosse (2015) in-
troduced such a sampling scheme with kfac based on the connection between the ggn and the
Fisher. Most loss functions used in machine learning have a probabilistic interpretation as negative
log-likelihood of a probabilistic model. The squarred error of regression is equivalent to a Gaussian
noise assumption and the cross-entropy is linked to the categorical distribution. In this case, the loss
Hessian with respect to the network output is equal, in expectation, to the outer products of gradients
if the output of the network is sampled according to a particular distribution, pf (x), defined by the
network output f (x). Sampling outputs y 〜p, we have that
Ey〜Pf(X) [Vθ'(f (x, θ), y)Vθ'(f(x, θ), y)>] = Vθ'(f(x, θ), y).	(21)
Sampling one such gradient leads to a rank-1 mc approximation of the loss Hessian. With the sub-
stitution S 什 S, we compute an MC approximation of the GGN diagonal in BACKPACK as
diag (G(θ⑺))≈ N X diag (n⑸zny)τS(Zni))][n⑸zny)τS(Zni))]>) .	(22)
n=1
A.2.2 Kronecker-factored curvature approximations
A different approach to reduce memory complexity of the GGN blocks G(θ(i)), apart from diagonal
curvature approximations, is representing them as Kronecker products (kfac for linear and con-
volution layers by Martens & Grosse (2015); Grosse & Martens (2016) kflr and kfra for linear
layers by Botev et al. (2017)),
G(θ(i)) = A(i) 0 B(i).	(23)
For both linear and convolution layers, the first Kronecker factor A(i) is obtained from the inputs
Zn(i-1) to layer i. Instead of repeating the technical details of the aforementioned references, we will
focus on how they differ in (i) the backpropagated quantities and (ii) the backpropagation strategy.
As a result, we will be able to extend kflr and kfra to convolutional neural networks7.
kfac and kflr: KFAC uses an MC-sampled estimate of the loss Hessian with a square root fac-
torization S(ZnL)) like in Eq. 20. The backpropagation is equivalent to the computation of the GGN
diagonal. For the GGN of the weights of a linear layer i, the second Kronecker term is given by
Nτ
BKiFAC=N X S(Zni)) (S(Zni))),
n=1
7We keep the PyTorch convention that weights and bias are treated as separate parameters. For the bias
terms, we can store the full matrix representation of the ggn. This factor reappears in the Kronecker factoriza-
tion of the ggn with respect to the weights.
14
Published as a conference paper at ICLR 2020
which at the same time corresponds to the ggn of the layer’s bias8.
In contrast to kfac, the kflr approximation backpropagates the exact square root factorization
S(zn(L)), i.e. for the weights of a linear layer8 (see Botev et al. (2017) for more details)
N>
BKFLR=N X S(Zni))(S(Zni))).
n=1
kfra: The backpropagation strategy for KFRA eliminates the scaling of the backpropagated cur-
vature quantities with the batch size N in Eq. 14. Instead of having layer i receive the N exact
[h(i) X h(i)] matrices G(Zni)), n = 1,...,N, only a single averaged object, denoted G(i), is used
as an approximation. In particular, the recursion changes to
1 N
G(i-1) = - X(J∕-i) Zni))>G(i)(Jz(i-i) Zni)),	i = 1,...,L,	(24a)
N	zn	zn
n=1
and is initialized with the batch-averaged loss Hessian
1 N
G(L) = N X Vf'(f (Xn，°)，yn).
n=1
For a linear layer, kfra uses8 (see Botev et al. (2017) for more details)
R⑴	一广⑴
BKFRA = G .
(24b)
A.3 The exact Hessian diagonal
For neural networks consisting only of piecewise linear activation functions, computing the diagonal
of the Hessian is equivalent to computing the ggn diagonal. This is because for these activations
the second term in the Hessian backpropagation recursion (Eq. 4) vanishes.
However, for activation functions with non-vanishing second derivative, these residual terms have
to be accounted for in the backpropagation. The Hessian backpropagation for module i reads
Vθ(i)'(θ) = (Jθ(i)Zni))>(V2(i)'(θ))(Jθ(i)Zni)) + R(i)(θ(i)),	(25a)
zn
V2z
n(i-1) `(θ) = (Jzn(i-1)Zni))> (V; (i) '(θ))(Jz(i-i) Zni))+Rni)(ZniT)),	05»
zn	zn	zn	zn
for n = 1, . . . , N. Those [h(i) × h(i)]-dimensional residual terms are defined as
R(i)(θ(i))=X (vθ(ijZni)]j) [Vzni) '(θ)i,,
jj
Rni)(ZniT))=X (Vzni-"Zr)” [Vzni)，⑹].,
jj
For common parameterized layers, such as linear and convolution transformations, R(ni) (θ(i)) = 0.
If the activation function is applied element-wise, R(ni)(Zn(i-1)) are diagonal matrices.
Storing these quantities becomes very memory-intensive for high-dimensional nonlinear activation
layers. In BackPACK, this complexity is reduced by application of the aforementioned matrix
square root factorization trick. To do so, we express the symmetric factorization of R(ni) (Zn(i-1)) as
R(ni)(Zn(i-1))=Pn(i)(Zn(i-1))(Pn(i)(Zn(i-1))>-Nn(i)(Zn(i-1))(Nn(i)(Zn(i-1))> ,	(26)
where Pn(i)(Zn(i-1)), Nn(i)(Zn(i-1)) represent the matrix square root of R(ni)(Zn(i-1)) projected on its
positive and negative eigenspace, respectively.
8In the case of convolutions, one has to sum over the spatial indices of a single channel of zn(i) as the bias is
added to an entire channel, see Grosse & Martens (2016) for details.
15
Published as a conference paper at ICLR 2020
This composition allows for the extension of the GGN backpropagation: In addition to S(zn(i)), the
decompositions Pn(i) (zn(i-1)), Nn(i) (zn(i-1)) for the residual parts also have to be backpropagated
according to Eq. 18. All diagonals are extracted from the backpropagated matrix square roots (see
Eq. 19). All diagonals stemming from decompositions in the negative residual eigenspace have to
be weighted by a factor of -1 before summation.
In terms of complexity, one backpropagation for R(ni) (z(i-1)) changes the dimensionality as follows
R(ni)(z(i-1)) :	[h(i) × h(i)] → [h(i-1) × h(i-1)] → [h(i-2) × h(i-2)] → .....
With the square root factorization, one instead obtains
Pn(i)(zn(i-1)) :	[h(i)	× h(i)]	→	[h(i-1) × h(i)]	→	[h(i-2)	×	h(i)]	→	. . . ,
Nn(i)(zn(i-1)) :	[h(i)	× h(i)]	→	[h(i-1) × h(i)]	→	[h(i-2)	×	h(i)]	→	...
Roughly speaking, this scheme is more efficient whenever the hidden dimension of a nonlinear
activation layer deceeds the largest hidden dimension of the network.
Example: Consider one backpropagation step of module i. Assume R(ni) (θ(i)) = 0, i.e. a linear,
convolution, or non-parameterized layer. Then the following computations are performed in the
protocol for the diagonal Hessian:
• Receive the following quantities from the child module i + 1 (for n = 1, . . . , N)
Φ = n S(zn(i)) ,
P (i+1) (z (i) )
n	zn ,
Nn(i+1)(zn(i)),
(Jz(i)zn(i+1))>Pn(i+2)(zn(i+1)),
zn
(Jz(i)zn(i+1))>Nn(i+2)(zn(i+1)),
zn
...
(Jzn(i)zn(i+1))>(Jz
n(i+1)zn(i+2))>... (Jzn(L-3) zn(L-2))>Pn(L-1)(zn(L-2)),
zn	zn	zn
(Jz(i)zn(i+1))>(Jz(i+1)zn(i+2))>... (Jz(L-3)zn(L-2))>Nn(L-1)(zn(L-2)) o
zn	zn	zn
• Extract the module parameter Hessian diagonal, diag (喝⑸ L(θ))
-For each quantity A ∈ Φ extract the diagonal from the square root factorization and
sum over the samples, i.e. compute
N X diag (h(Jθ(i) Zni) )>Ani h(Jθ(i) Zni) )>Ani ).
n=1
Multiply the expression by -1if A stems from backpropagation of a residual’s nega-
tive eigenspace’s factorization.
-Sum all expressions to obtain the block Hessian,s diagonal diag 旧常⑸ L(θ))
• Backpropagate the received quantities to the parent module i - 1
-	For each quantity An ∈ Φ, apply (J (i-1) Zn(i))>An
zn
-	Append Pn(i+1)(Zn(i)) and Nn(i+1)(Zn(i)) to Φ
B Additional details on benchmarks
kfac vs. kflr: As the KFLR of Botev et al. (2017) is orders of magnitude more expensive to
compute than the kfac of Martens & Grosse (2015) on cifar- 1 00, it was not included in the
16
Published as a conference paper at ICLR 2020
main plot. This is not an implementation error; it follows from the definition of those methods. To
approximate the GGN, G(θ) = PnJθ fn]>Vfn 'n [Jθ fn], KFAC uses a rank-1 approximation for
each of the inner Hessian Vfn 'n = SnS>, and needs to propagate a vector through the computation
graph for each sample. kflr uses the complete inner Hessian instead. For cifar- 100, the network
has 100 output nodes—one for each class—and the inner Hessians are [100 × 100] matrices. KFLR
needs to propagate a matrix through the computation graph for each sample, which is 100× more
expensive as shown in Fig. 8.
Figure 8: kflr and Diagggn are more expensive to run on large networks. The gradient takes less
than 20ms to compute, but KFLR and DiagGGN are approximately 100× more expensive.
Diagonal of the ggn vs. Diagonal of the Hessian: Most networks used in deep learning use
ReLU activation functions. ReLU functions have no curvature as they are piecewise linear. Be-
cause of this, the diagonal of the ggn is equivalent to the diagonal of the Hessian (Martens, 2014).
However, for networks that use non piecewise linear activation functions like sigmoids or tanh, com-
puting the Hessian diagonal can be much more expensive than the ggn diagonal. To illustrate this
point, we modify the smaller network used in our benchmarks to include a single sigmoid activation
function before the last classification layer. The results in Fig. 9 show that the computation of the
diagonal of the Hessian is already an order of magnitude more expensive than for the ggn.
CIFAR10 on 3C3D with one sigmoid
2 1
O O
1 1
IS且 Φ8p
Figure 9: Diagonal of the Hessian vs. the ggn.
If the network contains a single sigmoid activation
function, the diagonal of the Hessian is an order of
magnitude more computationally intensive than the
diagonal of the ggn.
C	Additional details on experiments
C.1 Protocol
The optimizer experiments are performed according to the protocol suggested by DEEPOBS:
•	Train the neural network with the investigated optimizer and vary its hyperparameters on a
specified grid. This training is performed for a single random seed only.
•	DeepOB S evaluates metrics during the training procedure. From all runs of the grid search,
it selects the best run automatically. The results shown in this work were obtained with the
default strategy, favoring highest final accuracy on the validation set.
•	For a better understanding of the optimizer performance with respect to randomized rou-
tines in the training process, DeepObS reruns the best hyperparameter setting for ten dif-
ferent random seeds. The results show mean values over these repeated runs, with standard
deviations as uncertainty indicators.
•	Along with the benchmarked optimizers, we show the DeepOBS base line performances
for Adam and momentum SGD (Momentum). They are provided by DeepOBS.
17
Published as a conference paper at ICLR 2020
The optimizers built upon BackPACK’s curvature estimates were benchmarked on the DeepOB S
image classification problems summarized in Table 2.
Table 2: Test problems considered from the DeepOB S library (Schneider et al., 2019).
Codename	Description	Dataset	# Parameters
LogReg	Linear model	MNIST	7,850
2c2d	2 convolutional and 2 dense linear layers	fashion-mnist	3,274,634
3c3d	3 convolutional and 3 dense linear layers	cifar-1 0	895,210
ALL-CNN-C	9 convolutional layers (Springenberg et al., 2015)	cifar-1 00	1,387,108
C.2 Grid search and best hyperparameter setting
Both the learning rate α and damping λ are tuned over the grid
α ∈ {l0-4,10-3,10-2,10-1,1} , λ ∈ {l0-4,10-3,10-2,10-1,1,10}.
We use the same batch size (N = 128 for all problems, except N = 256 for ALL-CNN-C on
cifar- 1 00) as the base lines and the optimizers run for the identical number of epochs.
The best hyperparameter settings are summarized in Table 3.
C.3 Update rule
We use a simple update rule with a constant damping parameter λ. Consider the parameters θ of
a single module in a neural network with '2-regularization of strength η. Let G(θt) denote the
curvature matrix and VθL(θt) the gradient at step t. One iteration of the optimizer applies
θt+1 - θt + [G(θt) + (λ + η)I)]-1 [VθL(θt) + ηθt] .	(27)
The inverse cannot be computed exactly (in reasonable time) for the Kronecker-factored curvatures
kfac, kflr, and kfra. We use the scheme of Martens & Grosse (2015) to approximately invert
G(θt)+(λ+η)I if G(θt) is Kronecker-factored; G(θt) = A(θt)0B(θt). Itreplaces the expression
(λ + θ)I by diagonal terms added to each Kronecker factor. In summary, this replaces
[A(θt)㊈ B(θt) + (λ + η)I]-1 by [A(θt) + ∏tPλ + ηI] -1
B(θt) + ɪ pλ + η I
πt
-1
. (28)
A principled choice for the parameter ∏ is given by ∏t = J kA^BθBk for an arbitrary matrix
norm |卜||. We follow Martens & Grosse (2015) and choose the trace norm,

πt
tr(A(θt))dim(B)
dim(A) 0 tr(B(θt))
(29)
Table 3: Best hyperparameter settings for optimizers and baselines shown in this work. In the Mo-
mentum baselines, the momentum was fixed to 0.9. Parameters for computation of the running aver-
ages in Adam use the default values (β1, β2) = (0.9,0.999). The symbols ✓ and X denote whether
the hyperparameter setting is an interior point of the grid or not, respectively.
Curvature	mnist_logreg	fmnist_2c2d	cifar10_3c3d	cifar100_allcnnc
	α	λ	int	α	λ	int	α	λ	int	α	λ	int
Diagggn	10-3	10-3	1Γ~	10-4	10-4	X~	10-3	10-2	~J~	-	--
Diagggn-mc	10-3	10-3	✓	10-4	10-4	X	10-3	10-2	✓	10-3	10-3	✓
KFAC	10-2	10-2	✓	10-3	10-3	✓	1	10	X	1	1	✓
KFLR	10-2	10-2	✓	10-2	10-3	j	1	10	X	-	--
KFRA	10-2	10-2	J	-	--	-	--	-	--
Baseline	α	ɑ	α	α
Momentum	≈ 2.07 ∙ 10-2	≈ 2.07 ∙ 10-2	≈ 3.79 ∙ 10-3	≈ 4.83 ∙ 10T
Adam	≈ 2.98 ∙ 10-4	≈ 1.27 ∙ 10-4	≈ 2.98 ∙ 10-4	≈ 6.95 ∙ 10-4
18
Published as a conference paper at ICLR 2020
C.4 Additional results
This section presents the results for MNIST using a logistic regression in Fig. 10 and fashion-
MNIST using the 2c2d network, composed of two convolution and two linear layers, in Fig. 11.
MNIST： LOGREG
ss-lsəj
432
999
...
000
ycarucca tseT
453
0. .3 0.
0
...
000
5
433
...
000
SSol u-s∙IH
ycarucca niarT
0	10	20	30	40	50 0	10	20	30	40	50
Epoch	Epoch
Figure 10:	Median performance with shaded quartiles of the best hyperparameter settings chosen
by DeepOBS for logistic regression (7,850 parameters) on mnist. Solid lines show well-tuned
baselines of momentum SGD and Adam that are provided by DeepOBS.
FASHION-MNIST： 2c2D
0.4
0.2
0
SSos9h
----KFAC --------KFLR
Adam	Momentum
ycarucca tseT
SSol u-s∙IH
42
..
00
ycarucca niarT
0	20	40	60	80	100 0	20	40	60	80	100
Epoch	Epoch
Figure 11:	Median performance with shaded quartiles of the best hyperparameter settings chosen
by DEEPOBS for the 2c2d network (3,274,634 parameters) on FASHION-MNIST. Solid lines show
well-tuned baselines of momentum SGD and Adam that are provided by DeepOBS.
19
Published as a conference paper at ICLR 2020
D BackPACK cheat sheet
• Assumptions
-	Feedforward network
z(0)
zn
Tθ(1(1)) (zn(0))	(1)
---------------→ zn
Tθ(2(2)) (zn(1))
-------------------→ . .
Tθ(L(L)) (zn(L-1))
--θ --------→ z(L)
'(znL),y)
`(θ)
-	d(i) : Dimension of parameter θ(i)
-	Empirical risk
L(θ)= N Pn=1 '(f(θ, Xn), yn)
•	Shorthands
'n(θ)= '(f(θ, Xn), yn) ,	n =1,...,N,
fn(θ) = f(θ, xn) = zn(L) (θ) ,	n = 1, . . . , N
•	Generalized Gauss-Newton matrix
1N
G(θ) = N7∑(Jθ fn)>Vfn 'n(θ)(Jθ fn)
•	Approximative GGN via MC sampling
1N
G(θ)=而 E(Jθfn)> [Vθ'(fn(θ), y)Vθ'(fn(θ), 9n)>] ^ 〜…,Jθfn)
N z--」yn〜Pfn (Xn)
n=1
Table 4: Overview of the features supported in the first release of BackPACK. The quantities are
computed separately for all module parameters, i.e. i = 1, . . . , L.
Feature	Details
Individual gradients Batch variance 2nd moment Indiv. gradient `2 norm Diagggn Diagggn-mc Hessian diagonal KFAC KFLR KFRA	NN Vθ(i) 'n(θ),	n = 1,...,N N PL [Vθ(i) 'n(θ)]2 — [Ve(i) L(θ)]2 ,	j = 1,..∙, d(i) N Pn=I [vθ(i) 'n(θ)j , j = 1,...,d(i). Il N Vθ(i) 'n(θ)∣∣2 ,	n =1,...,N diag (G(θ⑴)) diag (G(θ⑴)) diag (Vθ(i) L(θ)) G (θ⑺)≈ A⑴㊈ BKiAC G(θ⑺)≈ A⑴㊈ BKiLR G(θ⑺)≈ A⑴区 BKi)RA
20