Figure 1: Overview of ciphertext generation. We pass the source code and a character set as inputs toinitialize both character sets for the encoder-decoder model, then randomly assign weights to generatethe ciphertext, an obfuscated version of the source code.
Figure 2: Overview of key generation. With the known ciphertext and original source code, thedeveloper of the source code would pass them as inputs into another encoder-decoder model and trainover a number of iterations such that the model weights obtained can translate the obfuscated codeinto executable code, with validation of executability at the end.
Figure 3: Overview of live execution. To run the obfuscated code on any server or system, one wouldpass in the obfuscated code into an execution engine that takes the ciphertext and the lodged modelfiles as inputs to execute the withheld code.
Figure 4:	Plots of time properties against plaintext lengthThe plot of ciphertext generation time requirement against length of the source code shows no distinctpattern, while the plot of key generation time requirement against length of the source code showsa linear pattern. This infers that ciphertext generation is not length-dependent and can be executedwithout significant incremental cost. Since the length of the source code affects the training timerequired for the same number of iterations (higher length would increase training time per epoch),longer source code would require more time to generate a key, so this obfuscation method may bemore suitable for smaller code bases or systems with sufficient computing resources. We can alsoinfer the key generation takes linear time, i.e. time complexity is O(n).
Figure 5:	Plot of similarity metric against plaintext lengthFigure 5 adds onto prior Stealth results in section 4.1 to reveal that the larger the code base, thegreater the dissimilarity between the obfuscated code and the original code base.
Figure 6:	Plots of ciphertext properties against plaintext lengthPlotting ciphertext character variation and ciphertext length against plaintext length reveals: (i) thecharacter variation is widely distributed regardless of the length of the plaintext input, which furthersupports the notion of randomness of ciphertext generation, as the ciphertext is based purely onthe randomness in the model weight generation; (ii) the ciphertext length is kept low (on average72 character length) regardless of the plaintext length, which reduces obfuscated code storagerequirements. The notion that the cipher generation algorithm produces short random ciphertextsfurther implies it would be difficult for malicious actors to reverse-engineer the ciphertext by settingrandom weights or training a model without a known output text. For the model used in the experiment,the model file consists of 3 layers of arrays: the main layer contains 8 arrays, of which each array hasan array-length as represented in [39, 256, 1024, 72, 256, 1024, 256, 72], of which each sub-array(except the third and sixth array) contains an array of 1024 values. One would have to randomlygenerate 32-bit floats for 975,872 values, at least to a proximate range to the actual values before theycan generate readable de-obfuscated code, but even then they would need to further generate valuesto the 8th decimal place if they intend to obtain scrambled text without any lapse in meaning.
Figure 7:	Correlation matrix of propertiesobfuscation methods, it is at least on par in terms of stealth and is expected to outperform for largercode bases in terms of obscurity and readability, and though key generation may take a significantamount of time for larger code bases or require more computational resources, it would be lesstime-intensive than to manually obfuscate the source code. This would be a good use case applicationfor services that have confidential source code in plaintext but would prefer ciphertext yet require theability to execute.
