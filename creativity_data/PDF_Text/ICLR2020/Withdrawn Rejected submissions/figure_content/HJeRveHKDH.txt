Figure 1: Sample programming puzzles with valid answers n = 111111111 (Python: int("1"*9)),S =   1, 4, 6, 7  , s = a concatenation of 1000 copies of "AB" (Python: s="AB"*1000), x =[True,True, False], and m = 7. Problems range from easy to hard to unsolvable.
Figure 2: An excerpt from our Probabilistic Context Free Grammar (PCFG) that defines a family ofpuzzles with floating-point solutions. Each production rule is  annotated  with a weight, automaticallylearned by the generator (see main text).
Figure 3: Tree rewrite rules for float puzzles. Here p is also term from the grammar in Figure 2.
Figure 4: For the static solvers (Grid Solver, Enumerative and Sympy respectively), note that thereward achieved by both the probabilistic the neural-guided approach increases over time. Owing toits better expressivity and ability to model context, the guided approach latches on to the weakenessesof the solver faster than the probabilistic approach.
Figure 5: Number of unsolved and valid puzzles generatedfor each of the static solvers (Grid Solver, Enumerative, andSympy respectively). While both the pCFG based and neural-guided generators find more “hard” puzzles over time, theguided solver saturates at a much higher value.
Figure 6: (Left) This figure shows the number of problems solved by the solver at each iteration – forevery “iteration” of TM, both the generator and solver are updated. (Right) This figure shows thenumber of puzzles unsolved per 1000 generations. Critically, note that this and the previous plot are“offset” by an iteration i.e. the generator produces hard problems for the previously updated solver.
Figure 7: Qualitative examples of puzzles that achieve a high reward (sampled from top-100 of 1000generations) for each static solver. In each of these cases, a neural-guided generator has been usedto produce the puzzles. Each solver, has its specific weakness as can be seen from the examples –for example, excessive use of non-linear functions such as log, sin, and cos, make a problem hardfor the grid solver. Similarly, simple exponentiation (here, via rewrite rules that simply exponentiateboth sides) as the ability to compute the square root, etc. of a number is not provided in the grammar.
Figure 8: Grammars that define programming puzzles with (a) float and (b) int-set solutions.
Figure 9:  ICPC Problem 2019A in English (left) and programming puzzle (right).  In the PSAT,p1, p2 are arrays of n prices, h1, h2 are arrays of n heights. The goal is to find s, t, requiredto be lists of integers in the function specification.  They are further tested to be permutations bychecking if sorting them yields list(range(n)), the list of numbers from 1 to n.
