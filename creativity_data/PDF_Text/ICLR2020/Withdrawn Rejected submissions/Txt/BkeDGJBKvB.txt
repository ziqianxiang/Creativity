Under review as a conference paper at ICLR 2020
Multitask Soft Option Learning
Anonymous authors
Paper under double-blind review
Ab stract
We present Multitask Soft Option Learning (msol), a hierarchical multitask
framework based on Planning as Inference. msol extends the concept of options,
using separate variational posteriors for each task, regularized by a shared prior.
This allows fine-tuning of options for new tasks without forgetting their learned
policies, leading to faster training without reducing the expressiveness of the hi-
erarchical policy. msol avoids several instabilities during training in a multitask
setting and provides a natural way to learn both intra-option policies and their ter-
minations. We demonstrate empirically that msol significantly outperforms both
hierarchical and flat transfer-learning baselines in challenging multi-task environ-
ments.
1	Introduction
A key challenge in Reinforcement Learning (rl) is to scale current approaches to higher complexity
tasks without requiring a prohibitive number of environmental interactions. However, for many
tasks, it is possible to construct or learn efficient exploration priors that allow to focus on more
relevant parts of the state-action space, reducing the number of required interactions. These include,
for example, reward shaping (Ng et al., 1999; Konidaris & Barto, 2006), curriculum learning (Bengio
et al., 2009), some meta-learning algorithms (Wang et al., 2016; Duan et al., 2016; Gupta et al., 2018;
Houthooft et al., 2018; Xu et al., 2018), and transfer learning (Caruana, 1997; Taylor & Stone, 2011;
Bengio, 2012; Parisotto et al., 2015; Rusu et al., 2015; Teh et al., 2017).
One promising way to capture prior knowledge is to decompose policies into a hierarchy of sub-
policies (or skills) that can be reused and combined in novel ways to solve new tasks (Dayan &
Hinton, 1993; Thrun & Schwartz, 1995; Parr & Russell, 1998; Sutton et al., 1999; Barto & Mahade-
van, 2003). The idea of Hierarchical RL (hrl) is also supported by findings that humans appear to
employ a hierarchical mental structure when solving tasks (Botvinick et al., 2009; Collins & Frank,
2016). In such a hierarchical RL policy, lower-level, temporally extended skills yield directed behav-
ior over multiple time steps. This has two advantages: i) it allows efficient exploration, as the target
states of skills can be reached without having to explore much of the state space in between, and
ii) directed behavior also reduces the variance of the future reward, which accelerates convergence
of estimates thereof. On the other hand, while a hierarchical approach can therefore significantly
speed up exploration and training, it can also severely limit the expressiveness of the final policy
and lead to suboptimal performance when the temporally extended skills are not able to express the
required policy for the task at hand (Mankowitz et al., 2014).
Many methods exist for constructing and/or learning skills for particular tasks (Dayan & Hinton,
1993; SUtton et al., 1999; McGovern & Barto, 2001; Menache et al., 2002; SimSek & Barto, 2009;
Gregor et al., 2016; Kulkarni et al., 2016; Bacon et al., 2017; Nachum et al., 2018a). Training on
mUltiple tasks simUltaneoUsly is one promising approach to learn skills that are both relevant and
generalise across tasks (ThrUn & Schwartz, 1995; Pickett & Barto, 2002; Fox et al., 2016; Andreas
et al., 2017; Frans et al., 2018). Ideally, the entire hierarchy can be trained end-to-end on the obtained
retUrn, obviating the need to specify proxy rewards for skills (Frans et al., 2018).
However, learning hierarchical policies end-to-end in a mUltitask setting poses two major challenges:
i) becaUse skills optimize environmental rewards directly, correctly Updating them relies on already
(nearly) converged master policies that Use them similarly across all tasks, reqUiring complex train-
ing schedUles (Frans et al., 2018), and ii) the end-to-end optimization is prone to local minima in
1
Under review as a conference paper at ICLR 2020
which multiple skills have learned similar behavior. This second points is explained in more detail
in Appendix A.
In this paper, we propose Multitask Soft Option Learning (msol), a novel approach to learning
hierarchical policies in a multi-task setting that extends Options (Sutton et al., 1999), a common
definition for skills, and casts the concept into the Planning as Inference (pai) framework (see, e.g.,
Levine, 2018, for a review). msol brings multiple advantages: i) it stabilizes end-to-end multitask
training, removing the need for complex training schedules like in Frans et al. (2018), ii) it gives rise
to coordination between master policies, avoiding local minima of the type described in Appendix A,
iii) it allows fine-tuning of options, i.e. adapting them to new tasks at test-time without the risk of
unlearning previously acquired useful behavior, thereby avoiding suboptimal performance due to
restricted expressiveness, iv) and lastly, we show how the soft option framework gives rise to a
natural solution to the challenging task of learning option-termination policies.
msol differentiates between a prior policy for each option, shared across all tasks, and a flexible
task-specific posterior policy. The option prior can be fixed once it is fully trained, preventing un-
learning of useful behavior even when the posteriors are updated. On new tasks, the option posteriors
are initialized to the priors and regularized towards them, but are still adaptable to the specific task.
This allows the same accelerated training as with ‘hard’ options, but can solve more tasks due to the
adjustable posteriors. Furthermore, during option learning, we can train prior and posterior policies
simultaneously (Teh et al., 2017), all without the need for complex training schedules (Frans et al.,
2018): training is stabilized because only the priors are shared across tasks.
Our experiments demonstrate that msol outperforms previous hierarchical and transfer learning
algorithms during transfer tasks in a multitask setting. Msol only modifies the regularized reward
and loss function, but does not require any specialized architecture. In particular, it also does not
require artificial restrictions on the expressiveness of either the higher-level or intra-option policies.
2	Preliminaries
An agent’s task is formalized as a MDP (S, A, ρ, P, r), consisting of the state space S, the action
space A, the initial state distribution ρ, the transition probability P (st+1 |st, at) of reaching state
st+1 by executing action at in state st, and the reward r(st, at) an agent receives for this transition.
2.1	Planning as inference
Planning as inference (pai) (Todorov, 2008; Toussaint, 2009; Kappen et al., 2012) frames rl as a
probabilistic-inference problem (Levine, 2018). The agent learns a distribution qφ(a∣s) over actions
a given states s, i.e., a policy, parameterized by φ, which induces a distribution over trajectories τ
of length T, i.e., τ = (s1, a1, s2, . . . , aT, sT+1):
T
qφ(τ)	=	ρ(sι) ∏qφ(at∣st) P(st+ι∣St,at).	⑴
t=1
This can be seen as a structured variational approximation of the optimal trajectory distribution.
Note that the true initial state probability ρ(s1) and transition probability P (st+1 |st, at) are used in
the variational posterior, as we can only control the policy, not the environment.
An advantage of this formulation is that we can incorporate information both from prior knowledge,
in the form of a prior policy distribution, and the task at hand through a likelihood function that is
defined in terms of the achieved reward. The prior policy p(at|st) can be specified by hand or, as
in our case, learned (see Section 3). To incorporate the reward, we introduce a binary optimality
variable Ot (Levine, 2018), whose likelihood is highest along the optimal trajectory that maximizes
return: P(Ot = 1∣st,at) = exp W(St,at)/β). The constraint r ∈ (-∞, 0] can be relaxed without
changing the inference procedure (Levine, 2018). For brevity, we denote Ot = 1 as Ot ≡ (Ot = 1).
If a given prior policy p(at|st) explores the state-action space sufficiently, then p(τ, O1:T) is the
distribution of desirable trajectories. pai aims to find a policy such that the variational posterior in
(1) approximates this distribution by minimizing the Kullback-Leibler (kl) divergence
T
L(φ) = DKL(qφ(τ) k p(τ, O1:T)) , with p(τ, O1:T) = ρ(s1) Q p(at |st)P (st+1|st, at)p(Ot|st, at). (2)
2
Under review as a conference paper at ICLR 2020
2.2	Multi-task learning
In a multi-task setting, we have a set of different tasks i ∈ T, drawn from a task distribution with
probability ξ(i). All tasks share state space S and action space A, but each task has its own initial-
state distribution ρi, transition probability Pi(st+1 |st, at), and reward function ri. Our goal is to
learn n tasks concurrently, distilling common information that can be leveraged to learn faster on
new tasks from T. In this setting, the prior policy pθ(at∣st) can be learned jointly with the task-
specific posterior policies qφi (at|st) (Teh et al., 2017). To do so, we simply extend (2) to
1T
L({φi},θ)	=	Ei 〜ξ [ DKL(qφi (T) Il Pθ (T,O1:T )) ]	=	- β Ei 〜ξ,τ 〜q	Rreg ,	⑶
where Rieg := ri(st,at) 一 βln 器,占, is the regularised reward. Minimizing
the loss in (3) is equivalent to maximizing the regularized reward Rire,tg. Moreover,
minimizing the term ET〜q[ln 除焉*] implicitly minimizes the expected KL-divergence
Est〜q [Dkl[qφi (∙∣st)∣∣Pθ(∙∣st)]]. In practise (see Appendix C.1) we will also make use of a discount
factor γ ∈ [0, 1]. For details on how γ arises in the PAI framework we refer to Levine (2018).
2.3	Options
Options (Sutton et al., 1999) are skills that generalize primitive actions and consist of three com-
ponents: i) an intra-option policy p(at|st, zt) selecting primitive actions according to the currently
active option zt, ii) a probability p(bt |st, zt-1) of terminating the previously active option zt-1, and
iii) an initiation set I ⊆ S, which we simply assume to be S . Note that by construction, the higher-
level (or master-) policyp(zt|zt-1, st, bt) can only select a new option zt if the previous option zt-1
has terminated.
3	Method
We aim to learn a reusable set of options that allow for
faster training on new tasks from a given distribution. We
learn both intra-option and termination policies, while
preventing multiple options from learning the same be-
havior.
To differentiate ourselves from classical ‘hard’ options,
which, once learned, do not change during new tasks, we
call our novel approach soft-options (this is further dis-
cussed in Appendix B). Each soft-option consists of an
option prior, which is shared across all tasks, and a task-
specific option posterior. The priors of both the intra-
option policy and the termination policy capture how an
option typically behaves and remain fixed once they are
fully learned. At the beginning of training on a new task,
they are used to initialize the task-specific posterior dis-
tribution. During training, the posterior is then regular-
ized against the prior to prevent inadvertent unlearning.
However, if maximizing the reward on certain tasks is not
achievable with the prior policy, the posterior is free to
deviate from it. We can thus speed up training using op-
tions, while remaining flexible enough to solve any task.
Additionally, this soft option framework also allows for
learning good priors in a multitask setting while avoiding
local minima in which several options learn the same be-
havior. See Figure 1 for an overview over the hierarchical
prior-posterior architecture that we explain further below.
Figure 1: Two hierarchical posterior poli-
cies (left and right) with common priors
(middle). For each task i, the policy con-
ditions on the current state sti and the last
selected option zti-1. It samples, in order,
whether to terminate the last option (bit),
which option to execute next (zti) and what
primitive action (ait) to execute in the envi-
ronment.
3
Under review as a conference paper at ICLR 2020
3.1	Hierarchical posterior policies
To express options in the PAI framework, we introduce two additional variables at each time step t:
option selections zt, representing the currently selected option, and decisions bt to terminate them
and allow the higher-level (master) policy to choose a new option. The agent’s behavior depends
on the currently selected option zt , by drawing actions at from the intra-option posterior policy
qφL (at|st, zt). The selection zt itself is drawn from a master policy qφH (zt|st, zt-1, bt) = (1 -
bt) δ(zt	-	zt-1)	+	bt qφH (zt|st),	which conditions on	bt	∈	{0, 1},	drawn by the termination
posterior policy qφT (bt|st, zt-1). The master policy either continues with the previous zt-1 or draws
a new option, where we set b1 = 1 at the beginning of each episode. We slightly abuse notation by
referring by δ(zt - zt-1) to the Kronecker delta δzt,zt-1 for discrete and the Dirac delta distribution
for continuous zt . The joint posterior policy is
qφi(at,zt,bt∖st,zt-i)	=	qφi (btlst,zt-i) qφH (ztlst,zt-i,bt) qφi (at|st,zt) .	(4)
While zt can be a continuous variable, we consider only zt ∈ {1 . . . m}, where m is the
number of available options. The induced distribution qφi (τ) over trajectories of task i, τ =
(s1, b1, z1, a1, s2, . . . , sT, bT, zT, aT, sT+1), is then
T
qφi(τ)	=	ρi(s1) qφi(at, zt, bt|st, zt-1)Pi(st+1|st, at).	(5)
t=1
3.2	Hierarchical prior policy
Our framework transfers knowledge between tasks by a shared prior pθ(at, zt, bt|st, zt-1) over all
joint policies (4): pθ(at,zt,bt ∣st,zt-ι) = PT(bt∣st,zt-ι) PH(Zt∖zt-ι,bt) PLat ∖st,zt). By choosing
pθT , pH , and pθL correctly, we can learn useful temporally extended options. The parameterized
priors PT(bt∣st, zt-ι) and pθL(αt|st, Zt) are structurally equivalent to the posterior policies qφ, and
qφL so that they can be used as initialization for the latter. Optimizing the regularized return (see
next section) w.r.t. θ distills the common behavior into the prior policy and softly enforces similarity
across posterior distributions of each option amongst all tasks i.
The priorpH(zt∣zt-ι,bt) = (1 -瓦)δ(zt - zt-ι) + b$ selects the previous option z— if bt = 0,
and otherwise draws options uniformly to ensure exploration. Because the posterior master policy
is different on each task, there is no need to distill common behavior into a joint prior.
3.3	Objective
We extend the multitask objective in (3) by substituting Pθ (τ, O1:T) andPφi(τ) with those induced
by our hierarchical posterior policy in (4) and the corresponding prior. The resulting objective has
the same form but with a new regularized reward that is maximized:
Rreg	( (ς	))	_ β in	qHi(Zt|st,Zt-1,bt)	_	βin qLi(atlst,Zt)	_	β ι qTi(bt|st,Zt-1)	(6)
Ri,t	:= ri(st,at)	— β ln	pH(zt ∣zt-ι,bt)	-	β ln pL(at∣st,zt)	—	β ln pT(bt∣st,zt-ι)	.	(6)
、--------{z-------} 、---------{z-----} 、--------V------}
① ② ③
As we maximize Eq [Rire,tg], this corresponds to maximizing the expectation over ri (st,at) -
βDKL(qφHikPH)+DKL(qφLikPθL)+DKL(qφTikPθT), along the on-policy trajectories drawnfromqφi(τ).
Term ① of the regularization encourages exploration in the space of options. It can also be seen as a
form of deliberation cost (Harb et al., 2017) as it is only nonzero whenever we terminate an option
and the master policy needs to select another to execute.
Term ② softly enforces similarity between option posteriors across tasks and updates the prior to-
wards the ‘average’ posterior. It also encourages the master policy to pick the most specialized
option whose posteriors across all tasks are most similar. In other words, the master policy qφH is
encouraged to pick option Zt which maximizes r, but minimizes term ② by picking the option Zt for
which prior PθL and posterior qφL are the most similar. Because the prior is the average posterior, this
rewards the master policy to pick the most specialized option (that still achieves high reward). As
discussed in more detail in Appendix A, this allows us to escape the local optimization minima that
hard options face in multitask learning, while still having fully specialized options after training.
4
Under review as a conference paper at ICLR 2020
Lastly, We can use ③ to also encourage temporal abstraction of options. To do so, during option
learning, we fix the termination prior pT to a Bernoulli distribution pT (b) = (1-α)bα1-b. Choosing
a large α encourages prolonged execution of one option, but alloWs sWitching Whenever necessary.
This is also similar to deliberation costs (Harb et al., 2017) but With a more flexible cost model.
Additionally, We can still distill a termination prior pθT Which can be used on future tasks. Instead
of learning pθT by minimizing the KL against the posterior termination policies, We can get more
decisive terminations by minimizing
n
min P ET 〜qi[Dm (qφi (∙∣st,zt-i)k PT (∙∣st,zt-i))],	⑺
θ i=1
and ^φi(b = 1|st, zt-ι) = Pzt=Zt-I qφH(zt∣st, zt-ι,b = 1) i.e., the learned termination prior dis-
tills the probability that the tasks’ master policies Would change the active option if they had the
opportunity. Details on hoW We optimized the MSOL objective are given in Appendix C.
4	Related Work
Most hierarchical approaches rely on proxy reWards to train the loWer level components and their
terminations. Some of them aim to reach pre-specified subgoals (Sutton et al., 1999; Kulkarni et al.,
2016), Which are often found by analyzing the structure of the MDP (McGovern & Barto, 2001;
Menache et al., 2002; SimSek et al., 2005; SimSek & Barto, 2009), previously learned policies (Goel
& Huber, 2003; Tessler et al., 2017) or predictability (Harutyunyan et al., 2019). Those methods
typically require knoWledge, or a sufficient approximation, of the transition model, both of Which
are often infeasible.
Recently, several authors have proposed unsupervised training objectives for learning diverse skills
based on their distinctiveness (Gregor et al., 2016; Florensa et al., 2017; Achiam et al., 2018; Ey-
senbach et al., 2019). HoWever, those approaches don’t learn termination functions and cannot
guarantee that the required behavior on the doWnstream task is included in the set of learned skills.
Hausman et al. (2018) also incorporate reWard information, but do not learn termination policies
and are therefore restricted to learning multiple solutions to the provided task instead of learning a
decomposition of the task solutions Which can be re-composed to solve neW tasks.
A third usage of proxy reWards is by training loWer level policies to move toWards goals defined by
the higher levels. When those goals are set in the original state space (Nachum et al., 2018a), this
approach has difficulty scaling to high dimensional state spaces like images. Setting the goals in a
learned embedding space (Dayan & Hinton, 1993; Vezhnevets et al., 2017; Nachum et al., 2018b)
can be difficult to train, though. In both cases, the temporal extension of the learned skills are set
manually. On the other hand, Goyal et al. (2019) also learn a hierarchical agent, but not to transfer
skills, but to find decisions states based on hoW much information is encoded in the latent layer.
HiREPS Daniel et al. (2012) also take an inference motivated approach to learning options. In
particular Daniel et al. (2016) propose a similarly structured hierarchical policy, albeit in a single
task setting. HoWever, they do not utilize learned prior and posterior distributions, but instead use
expectation maximization to iteratively infer a hierarchical policy to explain the current reWard-
Weighted trajectory distribution.
Several previous Works try to overcome the restrictive nature of options that can lead to sub-optimal
solutions by alloWing the higher-level actions to modulate the behavior of the loWer-level policies
Schaul et al. (2015); Heess et al. (2016); Haarnoja et al. (2018). HoWever, this significantly increases
the required complexity of the higher-level policy and therefore the learning time.
The multitask- and transfer-learning setup used in this Work is inspired by Thrun & SchWartz (1995)
and Pickett & Barto (2002) Who suggest extracting options by using commonalities betWeen so-
lutions to multiple tasks. Prior multitask approaches often rely on additional human supervision
like policy sketches (Andreas et al., 2017) or desirable sub-goals (Tessler et al., 2017; Konidaris
& Barto, 2007; Mann et al., 2015) in order to learn skills Which transfer Well betWeen tasks. In
contrast, our Work aims at finding good termination states Without such supervision. Tirumala et al.
(2019) investigate the use of different priors for the higher-level policy While We are focussing on
learning transferrable option priors. Closest to our Work is Meta Learning of Shared Hierarchies
(mlsh) (Frans et al., 2018) Which, hoWever, shares the loWer-level policies across all tasks Without
5
Under review as a conference paper at ICLR 2020
distinguishing between prior and posterior and does not learn termination policies. As discussed,
this leads to local minima and insufficient diversity in the learned options. Similarly to us, Fox
et al. (2016) differentiate between prior and posterior policies on multiple tasks and utilize a KL-
divergence between them for training. However, they do not consider termination probabilities and
instead only choose one option per task. Instead of transferring option policies between tasks, Am-
mar et al. (2014) aim to share behavior through a latent embedding. Another interesting approach
to multitask learning is (Mankowitz et al., 2016) which learns decision regions that are linear in the
state instead of learning nonlinear master- and termination policies.
Our approach is closely related to distral (Teh et al., 2017) with which we share the multitask
learning of prior and posterior policies. However, distral has no hierarchical structure and applies
the same prior distribution over primitive actions, independent of the task. As a necessary hierar-
chical heuristic, the authors propose to also condition on the last primitive action taken. This works
well when the last action is indicative of future behavior; however, in Section 5 we show several
failure cases where a learned hierarchy is needed.
5	Experiments
We conduct a series of experiments to show: i) when learning hierarchies in a multitask setting,
msol successfully overcomes the local minimum of insufficient option diversity, as described in
Appendix A; ii) msol can learn useful termination policies; iii) msol is equally applicable to
discrete as well as continuous domains; and iv) using soft options yields fast transfer learning while
still reaching optimal performance, even on new, out-of-distribution tasks.
All architectural details and hyper-parameters can be found in the appendix. For all experiments,
we first train the exploration priors and options on n tasks from the available task distribution T
(training phase is plotted in Appendix E). Subsequently, we test how quickly we can learn new tasks
from T (or another distribution T0).
We compare the following algorithms: msol is our proposed method that utilizes soft options both
during option learning and transfer. m s ol(frozen) uses the soft options framework during learning
to find more diverse skills, but does not allow fine-tuning the posterior sub-policies after transfer.
distral (Teh et al., 2017) is a strong non-hierarchical transfer learning algorithm that also utilizes
prior and posterior distributions. distral(+action) utilizes the last action as option-heuristic which
works well in some tasks but fails when the last action is not sufficiently informative. mlsh (Frans
et al., 2018) is a multitask option learning algorithm like msol, but utilizes ‘hard’ options for both
learning and transfer, i.e., sub-policies that are shared exactly across tasks. It also relies on fixed
option durations and requires a complex training schedule between master and intra-option policies
to stabilize training. We use the author’s mlsh implementation. Lastly, we compare against Option
Critic (oc) (Bacon et al., 2017), which takes the task-id as additional input in order to apply it to a
multitask setting.
5.1	Moving Bandits
We start with the 2D Moving Bandits environment proposed and implemented by Frans et al. (2018),
which is similar to the example in Appendix A. In each episode, the agent receives a reward of 1
for each time step it is sufficiently close to one of two randomly sampled, distinguishable, marked
positions in the environment. The agent can take actions that move it in one of the four cardinal
directions. Which position is not signaled in the observation. Each episode lasts 50 time steps.
We compare against mlsh and distral to highlight challenges that arise in multitask training.
We allow mlsh and msol to learn two options. During transfer, optimal performance can only
be achieved when both options successfully learned to reach different marked locations, i.e., when
they are diverse. In Figure 2(a) we can see that msol is able to do so but the options learned by
mlsh are not sufficiently diverse, for the reason explain in Appendix A. distral, even with the last
action provided as additional input, is not able to quickly utilize the prior knowledge. The last action
only conveys meaningful information when taking the goal locations into account: distral agents
need to infer the intention based on the last action and the relative goal positions. While this is
possible, in practice the agent was not able to do so, even with a much larger network. However,
longer training allows distral to perform as well as msol, since its posterior is flexible, denoted
6
Under review as a conference paper at ICLR 2020
ROOO
4 3 2 1
UJnpωdx
0
0.5	1.0	1.5
Steps
2.0
×103
12 3 4
- - - -
Uln七 podx
(b) Taxi
Ulnsrtp2oφdχH
(C) Directional Taxi
(a) Moving Bandits
UJnsH PeaOedXg
---- soft option transfer
--- hard option transfer
---- hard option transfer + primitive options
---- flat trained from scratch
- - - - - -1 1
5 0 5 0 5 0
2 0 7 5 2
1χ 1X
UinM PeaOedX
O
(d) Taxi: Generalization	(e) Taxi: Adaptation	(f) Swimmer
Figure 2: Performance during testing of the learned options and exploration priors. Each line is the median
over 5 random seeds (2 for MLSH) and shaded areas indicate standard deviations. More details in text.
by “distral(+action) limit”. Lastly, m s ol(frozen) also outperforms distral(+action) and mlsh,
but performs worse that msol. This highlights the utility of making options soft, i.e. adaptable.
5.2	Taxi
Next, we use a slightly modified version of the original Taxi domain (Dietterich, 1998) to show
learning of termination functions as well as transfer- and generalization capabilities. To solve the
task, the agent must pick up a passenger on one of four possible locations by moving to their location
and executing a special ‘pickup/drop-off’ action. Then, the passenger must be dropped off at one
of the other three locations, again using the same action executed at the corresponding location.
The domain has a discrete state space with 30 locations arranged on a grid and a flag indicating
whether the passenger was already picked up. The observation is a one-hot encoding of the discrete
state, excluding passenger- and goal location. This introduces an information-asymmetry between
the task-specific master policy, and the shared options, allowing them to generalize well (Galashov
et al., 2018). Walls (see Figure 3) limit the movement of the agent and invalid actions.
We investigate two versions of Taxi. In the original (Dietterich, 1998, just called Taxi), the action
space consists of one no-op, one ‘pickup/drop-off’ action and four actions to move in all cardinal
directions. In Directional Taxi, we extend this setup: the agent faces in one of the cardinal directions
and the available movements are to move forward or rotate either clockwise or counter-clockwise.
In both environments the set of tasks T are the 12 different combinations of pickup/drop-off loca-
tions. Episodes last at most 50 steps and there is a reward of 2 for delivering the passenger to its
goal and a penalty of -0.1 for each time step. During training, the agent is initialized to any valid
state. During testing, the agent is always initialized without the passenger on board.
We allow four learnable options in mlsh and msol. This necessitates the options to be diverse,
i.e., one option to reach each of the four pickup/drop-off locations. Importantly, it also requires the
options to learn to terminate when a passenger is picked up. As one can see in Figure 2(b), mlsh
struggles both with option-diversity and due to its fixed option duration which is not flexible enough
for this environment. DISTRAL(+action) performs well in the original Taxi environment, as seen
in Figure 2(b), since here the last action is a good indicator for the agent’s intention. However, in
the directional case shown in Figure 2(c), the actions are less informative and make it much harder
7
Under review as a conference paper at ICLR 2020
∣≡∣I 圄□□□□
Figure 3: Options learned with MSOL on the taxi domain, before (top) and after pickup (bottom). The light
gray area indicates walls. The left plots show the intra-option policies: arrows and colors indicated direction
of most likely action, the size indicates its probability. A square indicates the pickup/dropoff action. The right
plots show the termination policies: intensity and size of the circles indicate termination probability.
for distral to use prior knowledge. By contrast, msol performs well in both taxi environments.
Comparing its performance with msol(frozen) shows the utility of adaptable soft options during
transfer.
Figure 3, which visualizes the options learned by msol, shows that it successfully learns useful
movement primitives and termination functions. The same soft option represents different behavior
depending on whether it already picked up the passenger. This is expected as this behavior does not
need to terminate the current option on three of the 12 tasks.
Next we show how learning information-asymmetric soft options can help with transfer to unseen
tasks. In Figure 2(d) we show learning on four tasks from T using options that were trained on
the remaining eight, comparing against A2C and oc. Note that in oc, there is no information-
asymmetry: We share the same networks across all tasks and provide the task-id as additional input,
including to the option-policies. This prevents them from generalizing well to unseen tasks. On
the other hand, withholding the task-information from them would be similar to mlsh, which we
already showed to struggle with local minima. The strong performance of msol on this task shows
that we need soft options to be able to train information-asymmetric options that generalize well.
We also investigate the utility of flexible soft options: In Figure 2(e) we show learning performance
on twelve changed tasks in which the pickup/dropoff locations where moved by one cell while the
options were trained with the original locations. As expected, hard options are not able to solve this
tasks. Even with additional access to primitive actions, exploration is inefficient (Jong et al., 2008).
On the other hand, msol is able to quickly learn this new task by adapting the previously learned
options, outperforming hard options and flat policies learned from scratch.
5.3	Swimmer
Lastly, we show that msol can also be applied to continuous multitask domains. In particular,
we investigate the MuJoCo environment ‘Swimmer’ (Todorov et al., 2012; Brockman et al., 2016).
Instead of rewarding forward movement as in the original implementation, now the rewarded move-
ment direction depends on the task from T = {up, down, lef t, right}. We also include a small
amount of additive action noise (details in the Appendix). We show that msol performs competi-
tive even in the absence of known failure cases of distral (see Figure 2(f)).
6	Discussion
Multitask Soft Option Learning (msol) proposes reformulating options using the perspective of
prior and posterior distributions. This offers several key advantages.
First, during transfer, it allows us to distinguish between fixed, and therefore knowledge-preserving
option priors, and flexible option posteriors that can adjust to the reward structure of the task at
hand. This effects a similar speed-up in learning as the original options framework, while avoiding
sub-optimal performance when the available options are not perfectly aligned to the task. Second,
utilizing this ‘soft’ version of options in a multitask learning setup increases optimization stability
and removes the need for complex training schedules between master and lower level policies. Fur-
thermore, this framework naturally allows master policies to coordinate across tasks and avoid local
minima of insufficient option diversity. It also allows for autonomously learning option-termination
policies, a very challenging task which is often avoided by fixing option durations manually.
8
Under review as a conference paper at ICLR 2020
Lastly, using this formulation also allows inclusion of prior information in a principled manner with-
out imposing too rigid a structure on the resulting hierarchy. We utilize this advantage to explicitly
incorporate the bias that good options should be temporally extended. In future research, other
types of information can be explored. As an example, one could investigate sets of tasks which
would benefit from a learned master prior, like walking on different types of terrain.
References
Joshua Achiam, Harrison Edwards, Dario Amodei, and Pieter Abbeel. Variational option discovery
algorithms. arXiv preprint arXiv:1807.10299, 2018.
Haitham Bou Ammar, Eric Eaton, Paul Ruvolo, and Matthew Taylor. Online multi-task learning
for policy gradient methods. In International Conference on Machine Learning, pp. 1206-1214,
2014.
Jacob Andreas, Dan Klein, and Sergey Levine. Modular multitask reinforcement learning with
policy sketches. In International Conference on Machine Learning, pp. 166-175, 2017.
Pierre-Luc Bacon, Jean Harb, and Doina Precup. The option-critic architecture. In AAAI, pp. 1726-
1734, 2017.
Andrew G Barto and Sridhar Mahadevan. Recent advances in hierarchical reinforcement learning.
Discrete event dynamic systems, 13(1-2):41-77, 2003.
Yoshua Bengio. Deep learning of representations for unsupervised and transfer learning. In Pro-
ceedings of ICML Workshop on Unsupervised and Transfer Learning, pp. 17-36, 2012.
Yoshua Bengio, Jerome Louradour, Ronan Collobert, and Jason Weston. Curriculum learning. In
Proceedings of the 26th annual international conference on machine learning, pp. 41-48. ACM,
2009.
Matthew M Botvinick, Yael Niv, and Andrew C Barto. Hierarchically organized behavior and its
neural foundations: a reinforcement learning perspective. Cognition, 113(3):262-280, 2009.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym. arXiv preprint arXiv:1606.01540, 2016.
Rich Caruana. Multitask learning. Machine learning, 28(1):41-75, 1997.
Anne Gabrielle Eva Collins and Michael Joshua Frank. Neural signature of hierarchically structured
expectations predicts clustering and transfer of rule sets in reinforcement learning. Cognition,
152:160-169, 2016.
Christian Daniel, Gerhard Neumann, and Jan Peters. Hierarchical relative entropy policy search. In
Artificial Intelligence and Statistics, pp. 273-281, 2012.
Christian Daniel, Herke Van Hoof, Jan Peters, and Gerhard Neumann. Probabilistic inference for
determining options in reinforcement learning. Machine Learning, 104(2-3):337-357, 2016.
Peter Dayan and Geoffrey E Hinton. Feudal reinforcement learning. In Advances in neural infor-
mation processing systems, pp. 271-278, 1993.
Thomas G Dietterich. The maxq method for hierarchical reinforcement learning. In ICML, vol-
ume 98, pp. 118-126. Citeseer, 1998.
Yan Duan, John Schulman, Xi Chen, Peter L Bartlett, Ilya Sutskever, and Pieter Abbeel. Rl2: Fast
reinforcement learning via slow reinforcement learning. arXiv preprint arXiv:1611.02779, 2016.
Benjamin Eysenbach, Abhishek Gupta, Julian Ibarz, and Sergey Levine. Diversity is all you need:
Learning skills without a reward function. In International Conference on Learning Representa-
tions, 2019. URL https://openreview.net/forum?id=SJx63jRqFm.
Carlos Florensa, Yan Duan, and Pieter Abbeel. Stochastic neural networks for hierarchical rein-
forcement learning. arXiv preprint arXiv:1704.03012, 2017.
9
Under review as a conference paper at ICLR 2020
Roy Fox, Michal Moshkovitz, and Naftali Tishby. Principled option learning in markov decision
processes. arXiv preprint arXiv:1609.05524, 2016.
Kevin Frans, Jonathan Ho, Xi Chen, Pieter Abbeel, and John Schulman. META LEARNING
SHARED HIERARCHIES. In International Conference on Learning Representations, 2018.
URL https://openreview.net/forum?id=SyX0IeWAW.
Alexandre Galashov, Siddhant Jayakumar, Leonard Hasenclever, Dhruva Tirumala, Jonathan
Schwarz, Guillaume Desjardins, Wojtek M Czarnecki, Yee Whye Teh, Razvan Pascanu, and Nico-
las Heess. Information asymmetry in kl-regularized rl. 2018.
Sandeep Goel and Manfred Huber. Subgoal discovery for hierarchical reinforcement learning using
learned policies. In FLAIRS conference,pp. 346-350, 2003.
Anirudh Goyal, Riashat Islam, DJ Strouse, Zafarali Ahmed, Hugo Larochelle, Matthew Botvinick,
Sergey Levine, and Yoshua Bengio. Transfer and exploration via the information bottleneck. In
International Conference on Learning Representations, 2019. URL https://openreview.
net/forum?id=rJg8yhAqKm.
Karol Gregor, Danilo Jimenez Rezende, and Daan Wierstra. Variational intrinsic control. arXiv
preprint arXiv:1611.07507, 2016.
Abhishek Gupta, Russell Mendonca, YuXuan Liu, Pieter Abbeel, and Sergey Levine. Meta-
reinforcement learning of structured exploration strategies. arXiv preprint arXiv:1802.07245,
2018.
Tuomas Haarnoja, Kristian Hartikainen, Pieter Abbeel, and Sergey Levine. Latent space policies for
hierarchical reinforcement learning. arXiv preprint arXiv:1804.02808, 2018.
Jean Harb, Pierre-Luc Bacon, Martin Klissarov, and Doina Precup. When waiting is not an option:
Learning options with a deliberation cost. arXiv preprint arXiv:1709.04571, 2017.
Anna Harutyunyan, Will Dabney, Diana Borsa, Nicolas Heess, Remi Munos, and Doina Precup.
The termination critic. arXiv preprint arXiv:1902.09996, 2019.
Karol Hausman, Jost Tobias Springenberg, Ziyu Wang, Nicolas Heess, and Martin Riedmiller.
Learning an embedding space for transferable robot skills. In International Conference on Learn-
ing Representations, 2018.
Nicolas Heess, Greg Wayne, Yuval Tassa, Timothy Lillicrap, Martin Riedmiller, and David Silver.
Learning and transfer of modulated locomotor controllers. arXiv preprint arXiv:1610.05182,
2016.
Rein Houthooft, Richard Y Chen, Phillip Isola, Bradly C Stadie, Filip Wolski, Jonathan Ho, and
Pieter Abbeel. Evolved policy gradients. arXiv preprint arXiv:1802.04821, 2018.
Nicholas K Jong, Todd Hester, and Peter Stone. The utility of temporal abstraction in reinforcement
learning. In Proceedings of the 7th international joint conference on Autonomous agents and
multiagent systems-Volume 1, pp. 299-306. International Foundation for Autonomous Agents
and Multiagent Systems, 2008.
Hilbert J Kappen, Vicenc Gomez, and Manfred Opper. Optimal control as a graphical model infer-
ence problem. Machine learning, 87(2):159-182, 2012.
George Konidaris and Andrew Barto. Autonomous shaping: Knowledge transfer in reinforcement
learning. In Proceedings of the 23rd international conference on Machine learning, pp. 489-496.
ACM, 2006.
George Konidaris and Andrew G Barto. Building portable options: Skill transfer in reinforcement
learning. In IJCAI, volume 7, pp. 895-900, 2007.
Ilya Kostrikov. Pytorch implementations of reinforcement learning algorithms. https://
github.com/ikostrikov/pytorch-a2c-ppo-acktr, 2018.
10
Under review as a conference paper at ICLR 2020
Tejas D Kulkarni, Karthik Narasimhan, Ardavan Saeedi, and Josh Tenenbaum. Hierarchical deep
reinforcement learning: Integrating temporal abstraction and intrinsic motivation. In Advances in
neural information processing Systems, pp. 3675-3683, 2016.
Sergey Levine. Reinforcement learning and control as probabilistic inference: Tutorial and review.
arXiv preprint arXiv:1805.00909, 2018.
Daniel J Mankowitz, Timothy A Mann, and Shie Mannor. Time regularized interrupting options. In
Internation Conference on Machine Learning, 2014.
Daniel J Mankowitz, Timothy A Mann, and Shie Mannor. Adaptive skills adaptive partitions (asap).
In Advances in Neural Information Processing Systems, pp. 1588-1596, 2016.
Timothy A Mann, Shie Mannor, and Doina Precup. Approximate value iteration with temporally
extended actions. Journal of Artificial Intelligence Research, 53:375-438, 2015.
Amy McGovern and Andrew G. Barto. Automatic discovery of subgoals in reinforcement learning
using diverse density. In Proceedings of the Eighteenth International Conference on Machine
Learning, ICML ’01, pp. 361-368, San Francisco, CA, USA, 2001. Morgan Kaufmann Publishers
Inc. ISBN 1-55860-778-1. URL http://dl.acm.org/citation.cfm?id=645530.
655681.
Ishai Menache, Shie Mannor, and Nahum Shimkin. Q-cut—dynamic discovery of sub-goals in
reinforcement learning. In European Conference on Machine Learning, pp. 295-306. Springer,
2002.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. In International conference on machine learning, pp. 1928-1937, 2016.
Ofir Nachum, Shane Gu, Honglak Lee, and Sergey Levine. Data-efficient hierarchical reinforcement
learning. arXiv preprint arXiv:1805.08296, 2018a.
Ofir Nachum, Shixiang Gu, Honglak Lee, and Sergey Levine. Near-optimal representation learning
for hierarchical reinforcement learning. arXiv preprint arXiv:1810.01257, 2018b.
Andrew Y Ng, Daishi Harada, and Stuart Russell. Policy invariance under reward transformations:
Theory and application to reward shaping. In ICML, volume 99, pp. 278-287, 1999.
Emilio Parisotto, Jimmy Lei Ba, and Ruslan Salakhutdinov. Actor-mimic: Deep multitask and
transfer reinforcement learning. arXiv preprint arXiv:1511.06342, 2015.
Ronald Parr and Stuart J Russell. Reinforcement learning with hierarchies of machines. In Advances
in neural information processing systems, pp. 1043-1049, 1998.
Marc Pickett and Andrew G Barto. Policyblocks: An algorithm for creating useful macro-actions in
reinforcement learning. In ICML, pp. 506-513, 2002.
Andrei A. Rusu, Sergio Gomez Colmenarejo, Caglar Gulcehre, Guillaume Desjardins, James Kirk-
patrick, Razvan Pascanu, Volodymyr Mnih, Koray Kavukcuoglu, and Raia Hadsell. Policy distil-
lation. arXiv preprint arXiv:1511.06295, 2015.
Tom Schaul, Daniel Horgan, Karol Gregor, and David Silver. Universal value function approxima-
tors. In International Conference on Machine Learning, pp. 1312-1320, 2015.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-
dimensional continuous control using generalized advantage estimation. arXiv preprint
arXiv:1506.02438, 2015.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy
optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
Ozgur SimSek and Andrew G Barto. Skill characterization based on betweenness. In Advances in
neural information processing systems, pp. 1497-1504, 2009.
11
Under review as a conference paper at ICLR 2020
K ∙∙ 1-t ∙	1 * -I ∙	1 ʌ -J-V T -t i'	1 I 1	y- -I 1 ʌ .	τl .∙i'∙	Γ∙1F	1	∙ Γ∙	.
Ozgur Simyek, Alicia P Wolfe, and Andrew G Barto. Identifying useful subgoals in reinforcement
learning by local graph partitioning. In Proceedings of the 22nd international conference on
Machine learning,pp. 816-823. ACM, 2005.
Richard S Sutton, Doina Precup, and Satinder Singh. Between mdps and semi-mdps: A frame-
work for temporal abstraction in reinforcement learning. Artificial intelligence, 112(1-2):181-
211, 1999.
Matthew E Taylor and Peter Stone. An introduction to intertask transfer for reinforcement learning.
Ai Magazine, 32(1):15, 2011.
Yee Teh, Victor Bapst, Wojciech M Czarnecki, John Quan, James Kirkpatrick, Raia Hadsell, Nicolas
Heess, and Razvan Pascanu. Distral: Robust multitask reinforcement learning. In Advances in
Neural Information Processing Systems, pp. 4499-4509, 2017.
Chen Tessler, Shahar Givony, Tom Zahavy, Daniel J Mankowitz, and Shie Mannor. A deep hierar-
chical approach to lifelong learning in minecraft. In Thirty-First AAAI Conference on Artificial
Intelligence, 2017.
Sebastian Thrun and Anton Schwartz. Finding structure in reinforcement learning. In Advances in
neural information processing systems, pp. 385-392, 1995.
Dhruva Tirumala, Hyeonwoo Noh, Alexandre Galashov, Leonard Hasenclever, Arun Ahuja, Greg
Wayne, Razvan Pascanu, Yee Whye Teh, and Nicolas Heess. Exploiting hierarchy for learning
and transfer in kl-regularized rl. arXiv preprint arXiv:1903.07438, 2019.
Emanuel Todorov. General duality between optimal control and estimation. In Decision and Control,
2008. CDC 2008. 47th IEEE Conference on, pp. 4286-4292. IEEE, 2008.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026-
5033. IEEE, 2012.
Marc Toussaint. Robot trajectory optimization using approximate inference. In Proceedings of the
26th annual international conference on machine learning, pp. 1049-1056. ACM, 2009.
Alexander Sasha Vezhnevets, Simon Osindero, Tom Schaul, Nicolas Heess, Max Jaderberg, David
Silver, and Koray Kavukcuoglu. Feudal networks for hierarchical reinforcement learning. In
International Conference on Machine Learning, pp. 3540-3549, 2017.
Jane X Wang, Zeb Kurth-Nelson, Dhruva Tirumala, Hubert Soyer, Joel Z Leibo, Remi Munos,
Charles Blundell, Dharshan Kumaran, and Matt Botvinick. Learning to reinforcement learn.
arXiv preprint arXiv:1611.05763, 2016.
Tianbing Xu, Qiang Liu, Liang Zhao, and Jian Peng. Learning to explore via meta-policy gradient.
In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International Conference on
Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp. 5463-5472,
Stockholmsmassan, Stockholm Sweden, 10-15 Jul 2018. PMLR.
12
Under review as a conference paper at ICLR 2020
(a) Local minimum
(b) Using skill priors
(c) After training
Figure 4: Hierarchical learning of two concurrent tasks (a and b) using two options (z1 and z2) to reach two
relevant targets (A and B). a) Local minimum when simply sharing options across tasks. b) Escaping the local
minimum by using prior (Wi) and posterior (z(j)) policies. C) Learned options after training. Details are given
in the text in Appendix A.
Appendix
A Local Minima in Multitas k Option Learning
Here our aim is to provide an intuitive explanation of why learning hard options in a multitask setting
can lead to local minima. In this local minimum, multiple options have learned the same behavior
and are unable to change it, even if doing so would ultimately lead to a higher reward. We use the
Moving Bandits experiment schematically depicted in Figure 4 as example: The agent (black dot)
observes two target locations A and B but does not know which one is the correct one that has to be
reached in order to generate a reward.
The state- and action-spaces are continuous, requiring multiple actions to reach either A or B from
the starting position. Consequently, having access to two options, one for each location, can accel-
erate learning. We denote the options by z1 and z2 .
Assume that due to random initialization or later discovery of target B , both skills currently reach
A. Furthermore, assume that we are training on multiple task simultaneously as often the case in RL.
In this situation, the master policies on tasks in which the correct goal is A are indifferent between
using z1 and z2 and will consequently use both with high probability.
Now, changing one skill, e.g. z2, towards B in order to solve tasks in which B is the correct target,
decreases the performance on all tasks that currently use z2 to reach target A because for hard
options the skills are shared exactly across tasks. Due to small, stochastic gradient updates changing
z2 towards B only slightly increases the probability of reaching B but significantly decreases the
probability of reaching A (because now the option z2 will at first point to neither A or B). Averaged
across all tasks, this would at first decrease the average reward, consequently preventing any option
from changing away from A, leaving B unreachable.
To “free up” z2 (or any other option) and learn a new skill, all master policies would need to coor-
dinate and refrain from using it to reach A and instead use the equally useful skill z1 exclusively.
Importantly, using soft options makes this possible.
In Figures 4(b) and 4(c) we depict this schematically: The key difference is that in msol we have
separate task-specific posteriors zi(a) and zi(b) for tasks a and b and soft options i ∈ {1, 2} (for
simplicity, we assume that the correct target is A for task a and B for task b). This allows us,
in a first step, to solve all tasks (Figure 4(b)). Later, as discussed in Section 3.3, maximizing the
regularized reward (6) will lead to specialized skills, i.e. option priors (Figure 4(c)).
The corresponding shared priors Zi (one per option) are updated to effectively yield the ,average'
(as measured by the KL-divergence) between the task-specific posteriors zi(a) and zi(b) . Allowing
the posteriors ofan option, for example z2(a) and z2(b), to deviate from the prior zZ2 allows that option,
in a first step, to solve both tasks, irrespective of the misaligned priors. This is shown in Figure 4(b)
13
Under review as a conference paper at ICLR 2020
where all posteriors of z1 are moving to A, but for z2 , the posteriors on different tasks a and b move
to different targets.
Crucially, to maximize the regularized reward (6), the KL-divergences between priors and posteriors
should be minimized along they trajectories, i.e. weighted by how likely they are to occur. Conse-
quently, the higher Dκjz(a) k 的]> 0 Can be avoided on task a by picking the more specialized option
zι for which DKJz(a) |[为]=0. This, in turn, “frees up" z2 to now also specialize to B as shown in
Figure 4(c). After this implicit coordination, z1(a) is always used to reach A and z2 (b) is always used
to reach B, allowing both 为 and 为 to also lead to A and B respectively.
B Relationship between MSOL and classical options
Assume we are faced with a new task and are given some prior knowledge in the form of a set of
skills that we can use. Using those skills and their termination probabilities as prior policies pT
and pL in the soft option framework, we can see β as a temperature parameter determining how
closely we are restricted to following them. For β → ∞ we recover the classical ‘hard’ option case
and our posterior option policies are restricted to the prior.1 For β = 0 the priors only initialize
the otherwise unconstrained policy, quickly unlearning behavior that may be useful down the line.
Lastly, for0 < β < ∞ we use the prior information to guide exploration but are only softly restricted
to the given skills and can also explore and use policies ‘close’ to them.
C MSOL training details
C.1 Optimization
Even though Rrieg depends on φi , its gradient w.r.t. φi vanishes.2 Consequently, we can treat the
regularized reward as a classical rl reward and use any rl algorithm to find the optimal hierarchical
policy parameters φi. In the following, we explain how to adapt A2C (Mnih et al., 2016) to soft
options. The extension to PPO (Schulman et al., 2017) is straightforward.3
The joint posterior policy in (4) depends on the current state st and the previously selected option
zt-1. The expected sum of regularized future rewards of task i, the value function Vi, must therefore
also condition on this pair:
Vi(st,zt-l) := ET〜q h PP γt0-tRreg0 卜t,zt-l].
(8)
As Vi(st, zt-1) cannot be directly observed, we approximate it with a parametrized model
Vφi (st, zt-1). The k-step advantage estimation at time t of trajectory τ is given by
k-1
Aφi(Tt：(t+k))	:=	ΣYjRt+j+ YkV-(st+k,zt+k-I)- Vφi(st,zt-ι),	⑼
j=0
where the superscript ‘-’ indicates treating the term as a constant. The approximate value func-
tion Vφi can be optimized towards its bootstrapped k-step target by minimizing LV(φi,τi:T):=
P=I(Aφi(τt∙∙(t+k)))2. As per A2C, k ∈ [1 ...ns] depending on the state (Mnih et al., 2016). The
corresponding policy gradient loss is
T
LA(φi,τi:T)：= ∑1A-i(Tt：(t+k“lnqφi(at,zt,bt∖st,zt-ι).
The gradient w.r.t. the prior parameters θ is4
VθLp(θ,τi:T, bi：T)	:=	-PI (Vθ lnPL(at∣st,zt)+ V© lnPT(bt|st, zt-1
(10)
1However, in this limiting case optimization using the regularized reward is not possible.
2R p(x) ▽ lnp(x) dx = R Vp(x) dx = ▽ R p(x) dx = 0.
3However, for pai frameworks like ours, unlike in the original PPO implementation, the advantage function
must be updated after each epoch.
4Here we ignore β as it is folded into λP later.
14
Under review as a conference paper at ICLR 2020
where bt =方%j(Zt) and z0 〜qH(z0∣st, zt-ι, bt = 1). To encourage exploration in all policies of
the hierarchy, we also include an entropy maximization loss:
T
LH (Φi,τi:T)	：=	X(ln qHi(zt∣St, zt-i, bt) +ln qLi (at∣st, Zt) + ln qTi (bt∣st, Zt-i)) . (11)
t=1
Note that term ① in (6) already encourages maximizing LH(φi, T) for the master policy, since we
chose a uniform prior pH (Zt |bt = 1). As both terms serve the same purpose, we are free to drop
either one of them. In our experiments, we chose to drop the term for qH in Rrteg, which proved
slightly more stable to optimize that the alternative.
We can optimize all parameters jointly with a combined loss over all tasks i, based on sampled
trajectories Ti := TiT 〜qψ. and corresponding sampled values of bi :=仄.1:
n
L({φi},θ, {τi}, {bi}) = X (LA(φi,τi) + λvLV(φi,τi) + λpLp(θ,τi, bi) + λHLH(φi,τi)).
i=1
C.2 Training schedule
For faster training, it is important to prevent the master policies qH from converging too quickly to
allow sufficient updating of all options. On the other hand, a lower exploration rate leads to more
clearly defined options. We consequently anneal the exploration bonus λH with a linear schedule
during training.
Similarly, a high value of β leads to better options but can prevent finding the extrinsic reward
ri(st, at) early on in training. Consequently, we increase β over the course of training, also using a
linear schedule.
D Architecture
All policies and value functions share the same encoder network with two fully connected hidden
layers of size 64 for the Moving Bandits environment and three hidden layers of sizes 512, 256, and
512 for the Taxi environments. Distral was tested with both model sizes on the Moving Bandits task
to make sure that limited capacity is not the problem. Both models resulted in similar performance,
the results shown in the paper are for the larger model. On swimmer the encoder model size is 1024×
256 × 512. Master-policies, as well as all prior- and posterior policies and value functions consist of
only one layer which takes the latent embedding produced by the encoder as input. Furthermore, the
encoder is shared across tasks, allowing for much faster training since observations can be batched
together.
Options are specified as an additional one-hot encoded input to the corresponding network that is
passed through a single 128 dimensional fully connected layer and concatenated to the state em-
bedding before the last hidden layer. We implement the single-column architecture of Distral as a
hierarchical policy with just one option and with a modified loss function that does not include terms
for the master and termination policies. Our implementation builds on the A2C/PPO implementa-
tion by Kostrikov (2018), and we use the implementation for mlsh that is provided by the authors
(https://github.com/openai/mlsh).
E	Hyper-parameters and additional environment details
We use 2λV = λA = λP = 1 in all experiments. Furthermore, we train on all tasks from
the task distribution, regularly resetting individual tasks by resetting the corresponding master
and re-initializing the posterior policies. Optimizing β for MSOL and Distral was done over
{0.01, 0.02, 0.04, 0.1, 0.2, 0.4}. We use γ = 0.95 for Moving Bandits and Taxi and γ = 0.995
for Swimmer.
E.1 Moving Bandits
For mlsh, we use the original hyper-parameters (Frans et al., 2018). The duration of each option
is fixed to 10. The required warm-up duration is set to 9 and the training duration set to 1. We also
15
Under review as a conference paper at ICLR 2020
use 30 parallel environments split between 10 tasks. This and the training duration are the main
differences to the original paper. Originally, mlsh was trained on 120 parallel environments which
we were unable to do due to hardware constraints. Training is done over 6 million frames per task.
For msol and Distral we use the same number of 10 tasks and 30 processes. The duration of options
are learned and we do not require a warm-up period. We set the learning rate to 0.01 and β = 0.2,
α = 0.95, λH = 0.05. Training is done over 0.6 million frames per task. For Distral we use
β = 0.04, λH = 0.05 and also 0.6 million frames per task.
E.2 TAXI
For MSOL we anneal β from 0.02 to 0.1 and λH from 0.1 to 0.05. For Distral we use β = 0.04. We
use 3 processes per task to collect experience for a batch size of 15 per task. Training is done over
1.4 million frames per task for Taxi and 4 million frames per task for Directional Taxi. MLSH was
trained on 0.6 million frames for Taxi as due to it’s long runtime of several days, using more frames
was infeasible. Training was already converged.
E.3 Taxi: Adaptation to changed tasks
As shown in the main experiments, soft options can still be useful, even when the task distribution
changes. It is unsurprising that hard options are not able to solve the task. However, interestingly,
providing hard options and primitive actions to the master policy performs much worse than just
learning from scratch. This phenomenon was investigated previously by Jong et al. (2008) and
further justifies using soft options for transfer to out-of-distribution tasks.
Whether training from scratch or re-using misspecified options that were trained on a different set
of tasks is learning faster mainly depends on i) how strongly the options are misspecified and ii)
how difficult the exploration problem is in the environment. This tradeoff is shown in Figure 6:
On a smaller 8x8 grid (left), learning from scratch performs competitively because exploration is
sufficiently simple. On the other hand, on a 10x10 grid (right, results from the main paper), explo-
ration is harder and soft options allow for significantly faster learning because they can guide the
exploration in a helpful way.
E.4 Swimmer
For training Distral and msol we use PPO instead of A2C as it generally achieves better perfor-
mance on continuous tasks. We have λH = 0.0004 for both MSOL and Distral for primitive actions
and λ0H = 0.1 for the master- and termination policies in MSOL. We use a learning rate of 0.0002,
GAE (Schulman et al., 2015) with τ = 0.98. We collect 2000 steps in parallel on 6 processes per
task, resulting in a batchsize of 12, 000 per task. Training is done over 6 million frames with a
linearly scheduled increase of β from 0 to 0.04 for MSOL and 0.01 for Distral. We set α = 0.98.
(a) Moving Bandits
Figure 5: Performance during training phase. Note that msol and msol(frozen) share the same
training as they only differ during testing. Further, note that the highest achievable performance for
Taxi and Directional Taxi is higher during training as they can be initialized closer to the final goal
(i.e. with the passenger on board).
Ujn2盒 pesedxκ
(b) Taxi	(c) Directional Taxi	(d) Swimmer


16
Under review as a conference paper at ICLR 2020
UJn23rtpe83dxg
-5 -
0.0
UJnaQH P3s3dxq
(a) Grid of size 8x8
0.2	0.4	0.6	0.8	1.0
Steps	×106
(b) Grid of size 10x10
Figure 6: Tradeoff between exploration and misspecification: For smaller grid sizes, exploration is easier and
learning from scratch performs competitively. For larger grid sizes, soft options can accelerate training through
faster exploration, even if they are misspecified because they were trained on a different set of tasks.
17