Under review as a conference paper at ICLR 2020
Multi-objective Neural Architecture Search
via Predictive Network Performance Opti-
MIZATION
Anonymous authors
Paper under double-blind review
Ab stract
Neural Architecture Search (NAS) has shown great potentials in finding a better
neural network design than human design. Sample-based NAS is the most fun-
damental method aiming at exploring the search space and evaluating the most
promising architecture. However, few works have focused on improving the sam-
pling efficiency for a multi-objective NAS. Inspired by the nature of the graph
structure of a neural network, we propose BOGCN-NAS, a NAS algorithm us-
ing Bayesian Optimization with Graph Convolutional Network (GCN) predictor.
Specifically, we apply GCN as a surrogate model to adaptively discover and in-
corporate nodes structure to approximate the performance of the architecture. For
NAS-oriented tasks, we also design a weighted loss focusing on architectures
with high performance. Our method further considers an efficient multi-objective
search which can be flexibly injected into any sample-based NAS pipelines to
efficiently find the best speed/accuracy trade-off. Extensive experiments are con-
ducted to verify the effectiveness of our method over many competing methods,
e.g. 128.4× more efficient than Random Search and 7.8× more efficient than pre-
vious SOTA LaNAS for finding the best architecture on the largest NAS dataset
NASBench-101.
1	Introduction
Recently Neural Architecture Search (NAS) has aroused a surge of interest by its potentials of free-
ing the researchers from tedious and time-consuming architecture tuning for each new task and
dataset. Specifically, NAS has already shown some competitive results comparing with hand-crafted
architectures in computer vision: classification (Real et al., 2019b), detection, segmentation (Ghiasi
et al., 2019; Chen et al., 2019; Liu et al., 2019a) and super-resolution (Chu et al., 2019). Meanwhile,
NAS has also achieved remarkable results in natural language processing tasks (Luong et al., 2018;
So et al., 2019).
A variety of search strategies have been proposed, which may be categorized into two groups: one-
shot NAS algorithms (Liu et al., 2019b; Pham et al., 2018; Luo et al., 2018), and sample-based
algorithms (Zoph & Le, 2017; Liu et al., 2018a; Real et al., 2019b). One-shot NAS algorithms em-
bed the architecture searching process into the training stage by using weight sharing, continuous
relaxation or network morphisms. However, those methods cannot guarantee the optimal perfor-
mance of the final model due to those approximation tricks and is usually sensitive to the initial
seeds (Sciuto et al., 2019). On the other hand, sample-based algorithms are relatively slower but
reliable. They explore and exploit the search space using some general search algorithms by provid-
ing potential candidates with higher accuracy. However, it requires fully training of huge amounts
of candidate models.
Typically, the focus of most existing NAS methods has been on the accuracy of the final searched
model alone, ignoring the cost spent in the search phase. Thus, the comparison between existing
search algorithms for NAS is very difficult. (Wang et al., 2019b) gives us an example of evaluating
the NAS algorithms from this view. They compare the number of training architectures sampled until
finding the global optimal architecture with the top accuracy in the NAS datasets. Besides accuracy,
in real applications, there are many other objectives we should concern, such as speed/accuracy
1
Under review as a conference paper at ICLR 2020
trade-off. Hence, in this paper, we aim at designing an efficient multi-objective NAS algorithm to
adaptively explore the search space and capture the structural information of architectures related to
the performance.
The common issue faced by this problem is that optimizing objective functions is computationally
expensive and the search space always contains billions of architectures. To tackle this problem,
we present BOGCN-NAS, a NAS algorithm that utilizes Bayesian Optimization (BO) together with
Graph Convolutional Network (GCN). BO is an efficient algorithm for finding the global optimum
of costly black-box function (Mockus et al., 1978). In our method, we replace the popular Gaus-
sian Processes model with a proposed GCN model as the surrogate function for BO (Jones, 2001).
We have found that GCN can generalize fairly well with just a few architecture-accuracy pairs as
its training set. As BO balances exploration and exploitation during searching and GCN extracts
embeddings that can well represent model architectures, BOGCN-NAS is able to obtain the opti-
mal model architecture with only a few samples from the search space. Thus, our method is more
resource-efficient than the previous ones. Graph neural network has been proposed in previous work
for predicting the parameters of the architecture using a graph hypernetwork (Zhang et al., 2019).
However, it’s still a one-shot NAS method and thus cannot ensure the performance of the final found
model. In contrast, we use graph embedding to predict the performance directly and can guarantee
performance as well.
The proposed BOGCN-NAS outperforms current state-of-the-art searching methods, including Evo-
lution (Real et al., 2019b), MCTS (Wang et al., 2019b), LaNAS (Wang et al., 2019a). We observe
consistent gains on multiple search space for CV and NLP tasks, i.e., NASBench-101 (denoted NAS-
Bench) (Ying et al., 2019) and LSTM-12K (toy dataset). In particular, our method BOGCN-NAS is
128.4× more efficient than Random Search and 7.8× more efficient than previous SOTA LaNAS on
NASBench (Wang et al., 2019a). We apply our method to multi-objective NAS further, considering
adding more search objectives including accuracy and number of parameters. Our method can find
more superior Pareto front on NASBench. Our algorithm is applied on open domain search with
NASNet search space and ResNet Style search space, which finds competitive models in both sce-
narios. The results of experiment demonstrate our proposed algorithm can find a more competitive
Pareto front compared with other sample-based methods.
2	Related Work
2.1	Bayesian Optimization
Bayesian Optimization aims to find the global optimal over a compact subset X (here we consider
maximization problem):
x* = arg max f (x).	(1)
x∈X
Bayesian Optimization considers prior belief about objective function and updates posterior prob-
ability with online sampling. Gaussian Processes (GPs) is widely used as a surrogate model to
approximate the objective function (Jones, 2001). And Expected Improvement acquisition function
is often adopted (Mockus et al., 1978). For the hyperparameters of the surrogate model Θ, we define
μ(x; D, Θ) - f (Xbest)
Y(X) = 一σxκ—
(2)
where μ(χ; D, Θ) is the predictive mean, σ2(x; D, Θ) is the predictive variance and f (Xbest) is the
maximal value observed. The Expected Improvement (EI) criterion is defined as follows.
aEI (X; D, Θ) = σ(X; D, Θ)[γ(X)Φ(γ(X); 0, 1) + N (γ(X); 0, 1)],	(3)
where N(∙; 0,1) is the probability density function of a standard normal and Φ(∙; 0,1) is its CUmU-
lative distribution.
2.2	Multi-objective Optimization
WithoUt loss of generality aboUt maX or min, given a search space X and m ≥ 1 objectives f1 :
X → R, . . ., fm : X → R, variable X1 ∈ X dominates variable X2 ∈ X (denoted X1 X2) if (i)
fi(X1) ≥ fi(X2),∀i ∈ {1, . . . , m}; and (ii) fj(X1) > fj(X2) for at least one j ∈ {1, . . . ,m}. X*
2
Under review as a conference paper at ICLR 2020
Embeddings
'>
J
GCN Predictor
Obtain Embeddingswith GCN
Bayesian
Regression
Estimated f
values
Calculate estimated f
values with BO
;Randomlysample models
ɪ from Search Space
Figure 1: The overview of our proposed algorithm. BOGCN-NAS is integrated by GCN and
Bayesian Linear Regression, including two iterative phases: 1) Sampling and Training; 2) Update
GCN predictor. During phase-one, we randomly sample a group of architectures from the search
space as candidate pool and calculate a predicted objective f. Then an estimated Pareto front is
constructed by f and Pareto optimal points are selected as proposed architectures. Then we fully
train them and add into trained architecture set (U). The Bayesian regression is updated with U.
During phase-two, we further retrain the GCN predictor with U. When there is only one objective,
the Pareto front reduces to one optimal architecture.
Retrain GCN UsingTrained Archs
Update Bayesian Regressor	ProposeArchsfrom estimated Pareto front.	Estimate Pareto Frontofsampled
with Trained Archs	train them and update Trained Archs	models based on

is Pareto optimal if there is no X ∈ X that domaines X *. The set of all Pareto optimal architectures
consitutes the Pareto front Pf. A multi-objective optimization problem (MOP) aims at finding such
input X ∈ X that X cannot be dominated by any variable in X (Marler & Arora, 2004).
2.3	Graph Convolutional Network
Let the graph be G = (V, E), where V is a set of N nodes, and E is the set of edges. Let its
adjacency matrix be A and feature matrix be X . The graph convolutional network (GCN) is a
learning model for graph-structure data (Kipf & Welling, 2016). For a L-layer GCN, the layer-wise
propagation rule is given by:
H(I+1) = f (H (l),A) = ReLU(D 2 AD - 1 H (I)W(I)),	(4)
N	(l)
where A = A + I, I is the identity matrix, D is a diagonal matrix with Dii = j=1 Aij , H(l)
and W(I) are the feature map and weight at the l-th layer respectively, and ReLU(∙) is the ReLU
activation function. H(0) is the original feature matrix X, and H(L) is the graph embedding matrix.
3	BOGCN-NAS
To search for the optimal architecture more efficiently, we proposed BOGCN-NAS by using pre-
dictive network performance Optimization with the GCN (Section 3.2) while utilizing the Bayesian
Optimization. Figure 1 shows the overview of the proposed algorithm.
3.1	Multi-objective NAS
We formulate NAS problem as a multi-objective optimization problem over the architecture search
space A where objective functions can be accuracy, latency, number of parameters, etc. We aim to
find architectures on the Pareto front of A. Specifically, when m = 1, it reduces to single-objective
(usually accuracy) NAS and the corresponding Pareto front reduces to one optimal architecture.
3
Under review as a conference paper at ICLR 2020
3.2	GCN Predictor
GCN predictor predicts the performance (like accuracy) of an architecture. Compared with MLP and
LSTM predictors proposed before (Wang et al., 2019b), GCN can preserve the context of graph data
better. Another important characteristic of GCN is its ability to handle variable number of nodes,
while an MLP cannot take a larger architecture as the input. Even though the LSTM can handle
variable-length sequences, its performance is not competitive because of the flat string encoding.
A neural network can be viewed as a directed attributed graph, in which each node represents an
operation (such as convolution operation) and each edge represents a data flow. As a concrete
illustration, we use the architectures in the NASBench dataset (Ying et al., 2019) as an example. The
idea can be easily extended to other architectures. In NASBench, each architecture is constituted by
stacking multiple repeated cells. Thus, we will focus on searching the cell architecture. An example
cell in NASBench is illustrated on the left side of Figure 1, where “input” represents the input of the
cell, “output” represents the output of the cell, “1 × 1 Conv, 3 × 3 Conv, Max Pooling” are three
different operations (5 operations totally).
We propose to encode the cell into an adjacency matrix A (asymmetric) and a feature matrix X ,
as the input of our GCN predictor. Note that the vanilla GCN only extracts the node embeddings,
while we want to obtain graph embedding. Following (Scarselli et al., 2008), we add a global node
to the original graph of the cell and let every node point at the global node. The adjacency matrix
can be obtained directly from the graph structure. For the feature matrix, we use the one-hot coding
scheme for each operation. Besides the original 5 different operations defined in NASBench, we
add another operation (global node) into coding scheme.
We feed A and X to a multi-layer GCN model to obtain the embedding of every node H(L) by (Eq.
4). For high-level prediction, we leave original nodes out and take the embedding of global node
solely because it already has the overall context of the architecture. Followed by one fully-connected
layer with sigmoid activation function, we can get the predicted accuracy. In training phase, we use
MSE loss for regression optimization.
3.3	Incorporating BO into GCN
Bayesian Optimization is an efficient model for search and optimization problems, which considers
balancing both exploitation and exploration balanced. It depends on updating the posterior distribu-
tion with the samples drawn from the search space based on one cheap surrogate model.
GPs is one of the most popular choices because Gaussian distribution is self-conjugate such that a
posterior distribution is also the same form as the prior. (Kandasamy et al., 2018) and (Jin et al.,
2019) both define the heuristic distance between neural architectures and use GPs with defined
distence for searching. However, since the computation increases cubically with the number of
samples (Snoek et al., 2015), GPs is so costly for NAS problem, whose search space is always huge.
Another drawback for GPs is that it cannot handle graph-data directly without a special encoding
scheme. In this work, we replace the popular surrogate model with our GCN predictor and take the
uncertainty into consideration.
Inspired by previous work (Snoek et al., 2015), we train the GCN predictor first with the trained
architecture set D containing architectures {(Ai, Xi)}in=1 with their actual performances {ti}in=1, ,
then during searching, we replace the last fully connected layer with Bayesian Linear Regressor
(BLR) for Bayesian estimation and retain GCN related layers for point estimation. We only consider
the uncertainty of the weights on the last fully-connected layer. We denote the embedding function
of global node by φ(∙, ∙) = [φι(∙, ∙),φ2(∙, ∙),…,φd(∙, ∙)]T. We can get the embedding of every
architecture φ(Ai, Xi ) from the trained architecture set D and treat them as the basis functions for
BO. For clarifying, we define Φ to be the design matrix where Φij = φj(Ai, Xi).
Different from typical Bayesian Linear Regression (BLR) (Bishop, 2006), the final layer of our GCN
predictor contains non-linear activation function. Here we use the inverse function trick to avoid
the non-trivial variant. Without fitting the true accuracy t, we prefer to estimate the value before
the activation function logit(t) such that we can convert non-linear regression to linear regression
problem. The key of BO is the order of the acquisition function over all sampled architectures
rather than true values. Due to the monotonicity of sigmoid function, the order property still holds.
4
Under review as a conference paper at ICLR 2020
The predicted mean and variance given by our model without the last activation function are shown
below.
μ(A,X; D,α,β) = mNφ(A,X),	(5)
σ2(A, X； D,α,β) = 1 + φ(A, X)tSNφ(A, X),	(6)
β
where
mN = βSNΦT logit(t), SN = αI + βΦT Φ.	(7)
Here, α, β are precisions of the prior, which are hyperparameters of the Bayesian Optimization
model. We can estimate them by maximizing the log marginal likelihood as following (Snoek et al.,
2012).
logp(logit(t)∣α, β) = M^lOg α + N^logβ - 2∣∣logit(t) - ΦmN||2
-2 mN mN - 2 log|S-1| —2 log 2π.	⑻
3.4	Search with Alternate Learning
NAS is a process of online learning during which we can utilize new fully-trained architectures
sampled from the search space. Therefore, the GCN model and BLR in BOGCN-NAS should be
updated with the increasing number of samples for better generalization. In this work, for the reason
that GCN retraining is more expensive than BLR updating, we update BLR more frequently than
GCN predictor.
The algorithm of our proposed BOGCN-NAS is illustrated in Algorithm 1. Given the search space
A, we initialize trained architecture sets U containing architectures (Ai, Xi) with their performance
ti = {f1i, . . . , fmi }. We train GCN predictor firstly with U and replace the last fully-connected
layer with BLR described in Section 3.3. Then we randomly sample a subspace R as following can-
didate pool if A is such huge that we cannot cover every architecture. After obtaining the candidate
pool, we can calculate every candidate model’s Expected Improvement as their estimated objective
values tj = {f1j, . . . , fmj}. Based on tj and multi-objective formulation (Section 3.1), we can
generate a estimated Pareto Front and sample estimated Pareto optimal models as set S and fully-
train them to obtain the true objective values tj . The trained architecture sets is then updated by
U = U ∪ S . Accumulating a certain amount of new data, we update GCN and BLR alternately for
next periodic sampling until satisfying the stop criteria.
3.5	Exponential Weighted Loss
For GCN predictor alone, MSE loss can achieve competitive performance for fitting all data. How-
ever, when it comes to the surrogate function for finding the top-performance model, we should pay
more attention to architectures with high performance compared to others.
In the search phase of BO, we select samples with top values of acquisition function. Specifically,
we expect to predict architectures with high performance as accurately as possible, while distin-
guishing low-performance architecture is sufficient for our purpose. For adapting NAS task, we
propose Exponential Weighted Loss for the surrogate GCN model and replace common MSE loss
with weighted loss completely in Algorithm 1.
1N
Lexp= N(e-1) ∑(eχp(yi) - i)l∣yi - yi∣l2,
(9)
5
Under review as a conference paper at ICLR 2020
Algorithm 1 BOGCN-NAS Search Procedure. A is the given search space, l is the number of
samples every iteration, k is the ratio of GCN/BLR update times, Pf is the optimal Pareto front
and threshold is the criteria for search stopping.
1: Initialize trained architecture sets U = {Ai , Xi , ti }in=1 from A and --一	r-			
current Pareto front Pf ;		function sample(GCN, BLR, l, R)	
2	Train GCN and BLR initially;	145:	embeddings = GCN (A);
3	_ __ . . ,. _ . _ _ _ _ _ while |Pf ∩ Pf |/|Pf | < threshold do	16:	Predict mean and variance of models in
4	for iteration= 1, 2, ..., k do		R with BLR and embeddings by (Eq. 5)
5	R =random _Sample(A);		and (Eq. 6);
6	S = sample(GCN, BLR, l, R);	17:	Calculate corresponding Expected Im-
7	Fully train sampled models S;		provement by (Eq. 3);
8	Update U = U ∪ S;	18:	Sample top l Pareto optimal models
9	Update Pff in set U;		sorted by Expected Improvement into set
10	BLR.update(GCN,U);		S;
11	end for	19:	return S.
12	GCN.retrain(U);	20:	end function
13	end while 一		
return Pf
here yi is the predicted accuracy, yei is the ground truth and e - 1 is normalization factor (e is the
base of the natural logarithm). Thus, our predictor will focus on predicting for those models with
higher accuracy.
4	Experiment
Dataset and Search Space In this section, we validate the performance of the proposed BOGCN-
NAS on NASBench (Ying et al., 2019). This is the largest benchmark NAS dataset for computer
vision task currently, with 420K architectures. To show the generalization of our method, we collect
12K LSTM models trained on PTB dataset (MARCUS et al., 1993) aiming at NLP task. We also
compare our method in open domains with NASNet search space (Zoph et al., 2018) and ResNet
style search space (Li et al., 2019). We will provide the detail of the search space and collection
method in Appendices Section.
Specifically, we prove the performance of single proposed GCN Predictor firstly and then vali-
date the whole framework on single-objective/multi-objective search problems compared with other
baselines (with default settings). The results of the experiment illustrate the efficiency of BOGCN-
NAS.
4.1	Comparison of individual predictors
We use a four-layer GCN, with 64 hidden units in each layer, as the surrogate model for BO. During
training, we use the Adam optimizer (Kingma & Ba, 2014), with a learning rate of 0.001 and a mini-
batch size of 128. The proposed GCN predictor is compared with an MLP predictor and LSTM
predictor (Liu et al., 2018a; Wang et al., 2019b). Here we apply MSE loss because we compare
the stand-alone predictors, while we replace with Exponential Weighted Loss for subsequent NAS
problems. For the evaluation metric, we follow (Wang et al., 2019b) and use the correlation between
the predicted accuracy and true accuracy. One difference between our evaluation method and (Wang
et al., 2019b) is that we compare predictor’s performance training on fewer architectures rather than
whole search space, because NAS start with little training data and we cannot train such a large
number of architectures in practice. We used 1000 architectures in NASBench for training, 100
architectures for validation, and 10000 architectures for testing.
Table 1	shows the correlation result of various predictors and the number of predictors’ parameters.
The prediction result of three predictors is also illustrated in Figure 2 and the value means the
6
Under review as a conference paper at ICLR 2020
(b) MLP.	(c) LSTM.
Figure 2	: Correlation of predicted accuracy versus ground truth for various predictors on NASBench.
It can be found that our GCN predictor has better correlation performance than the competing pre-
dictors.
Gaussian kernel-density estimation. As can be seen, the GCN predictor can predict the performance
of architectures more accurately than the other two predictors. In addition, the GCN predictor has
fewer parameters compared with them.
Table 1: Performance of predictors training on
small dataset. Our method has much better cor-
relation with less predictor parameters.
	Correlation	No. of parameters
MLP	0.400	6326K
LSTM	0.460	92K
GCN	0.607	14K
Table 2: Comparison of samples required to
find the global optimal over 50 rounds.
	NASBenCh	LSTM-12K
Random	188139.8	6182.6
Reg Evolution	87402.7	5670.9
MCTS	73977.2	4687.4
LaNAS	11390.7	2464.4
BOGCN-NAS	1465.4	558.8
4.2	Single-objective Search
Single-objective (accuracy) search is a special case of multi-objective search. For the proposed
BOGCN-NAS, we randomly sample 50 architectures to fully train and use them as the initial trained
architecture sets, which is counted into the total sample numbers. Since the whole NASBench and
LSTM datasets can be inferred easily (less than 0.01s), we set R = A in the experiment, which
means we take total search space as the candidate pool. During the search phase, we use GCN to
obtain embeddings and use the Bayesian regressor to compute EI scores for all architectures in the
search domain, rank them based on the score and select the top ten models to fully train, obtain
the accuracies and add them to trained architecture sets, update the best accuracy observed. The
process is repeated for k = 10 times. The GCN predictor is then retrained with our updated trained
architecture sets. This is repeated until the target model is found over 50 rounds. Note that GCN
model is trained using Exponential Weighted Loss instead in NAS procedure.
BOGCN-NAS is compared with the following state-of-the-art sample-based NAS baselines: (i) Ran-
dom Search, which explores the search space without performing exploitation; (ii) Regularized
Evolution (Real et al., 2019b), which uses heuristic evolution process for exploitation but is still
constrained by the available human prior knowledge; (iii) Monte Carlo tree search (MCTS) (Wang
et al., 2019b); and (iv) LaNAS (Wang et al., 2019a). Both MCTS and LaNAS only estimate the
performance of models in a coarse subspace, and then select models randomly in that subspace.
In contrast, Bayesian optimization conducts a more fine-grained search and predicts the expected
improvement of candidate pool.
Figure 3 and Table 2 show the number of samples until finding the global optimal architecture
using different methods. The proposed algorithm outperforms the other baselines consistently on
the two different datasets. On NASBench, BOGCN-NAS is 128.4×, 59.6×, 50.5×, 7.8× more
sample-efficient than Random Search, Regularized Evolution, MCTS and LaNAS respectively. On
the smaller NLP dataset, BOGCN-NAS can still search and find the optimal architecture with fewer
samples.
7
Under review as a conference paper at ICLR 2020
12500
10000
400000
300000
200000
0
(a) NASBench dataset
(b) LSTM dataset
LaNAS BOGCN
Random Reg MCTS LaNAS BOGCN
Evolution
Random Reg MCTS
Evolution
100000
Figure 3: Comparison of number of architecture samples truly evaluated to find the globally optimal
architecture over 50 rounds. On NASBench, BOGCN-NAS is 128.4×, 59.6×, 50.5×, 7.8× more
sample-efficient than Random Search, Regularized Evolution, MCTS and LaNAS.
We predict all architectures (420K; 12K) together on NASBench and LSTM dataset because the
cost of inference all once is negligible. For larger search space, we can use sampling methods as
mentioned in Section 3.4 instead. In every iteration, we randomly sample a subset architectures R
as candidate pool from the search space A for performance prediction and select top models among
this pool. The performance of BOGCN versus the pool sampling ratio (|R|/|A| ) is shown in Table
3. As can be seen, the overall performance of our BOGCN can still find the optimal model with
less samples compared with other baselines. Even though random sampling is good enough, an
alternative sampling method can be Evolutionary Algorithm.
Table 3: The performance with different pool sampling ratio.
Sampling ratio	NASBench dataset	LSTM dataset
1	1465.4	558.8
0.1	1564.6	1483.2
0.01	2078.8	1952.4
0.001	4004.4	2984.0
4.3	Multi-objective Search
In this section, we focus on multi-objective (accuracy and number of parameters) search. As the
same settings of BOGCN-NAS with Section 4.2, the only difference is the criteria for updating the
best architecture observed. Here we extend baselines in Section 4.2 to multi-objective form for
comparison. In detail, we sample 2, 000 architectures in total and compare the found Pareto front
Pff with the optimal Pareto front Pf on NASBench dataset.
As shown in Figure 4a, the grey dots are the overall architectures of NASBench, the red dots are sam-
ples selected by BOGCN and the blue dots are architectures undominated by our selected samples.
Based on them, we can make sure the respective Pareto fronts - the green dashed line is the opti-
mal Pareto front and the red dashed line is the estimated Pareto front. Figure 4b shows the Pareto
fronts estimated by different algorithms, which demonstrates the superiority of BOGCN mothod.
Compared with other baselines, the models sampled by our method are gathered near the optimal
Pareto front, and the found Pareto front is also closer to the optimal Pareto front. This validates the
efficiency of our algorithm on this multi-objective search task.
4.4	Open domain Search
In this section, we validate the propose method on the open domains - NASNet search space and
ResNet style search space (described in Appendices Section). Since the size of open domain is
8
Under review as a conference paper at ICLR 2020
4
8
6
2
9
6
4
9
0 8 6
9 8 8
6 6 CS
2 O
8 8
6 6
(a) BOGAN-NAS
0.86
0.84
4
9
0.
2
.9
9088
O O
(b) Comparison with other baselines

Figure 4: The result of multi-objective search with 2000 architecture samples. BOGAN-NAS can
find more competitive Pareto optimal architectures.
enormous, we set the size of R equals to 1M every iteration for both search spaces. And the found
architectures by BOGCN-NAS can be found in Appendices Section.
4.4	. 1 NASNet search space
For NASNet search space, we consider single-objective (accuracy) search on Cifar-10. For effi-
ciency, we train the sampled architectures by early stopping at 100 epochs rather than fully training.
It’s remarkable that we stop the algorithm after a certain number of samples |S | rather than until
finding the optimal architecture beacuse we don’t know the optimal architecture and the open do-
main contains billions of architectures. And other experiment settings are the same with Section 4.2
as well.
We pick two best performing architectures V1 and V2 within 200 and 400 samples respectively and
fully train them. Table 2 compares our results with other baselines on CIFAR-10. As can be seen,
even though one-shot NAS methods don’t need any architecture evaluated directly, the performance
of the final found models is not as good as sample-based methods averagely. Compared with other
sample-based NAS method, BOGCN outperforms all methods except for AmoebaNet-B, which
costs 67.5× more evaluating samples.
Table 4: Comparison of different methods on CIFAR-10.
Model	Params	Top-1 err	No. of samples truly evaluated
NASNet-A+cutout (Zoph et al., 2018)	3.3 M	2.65	20000
AmoebaNet-B+cutout (Real et al., 2019b)	2.8 M	2.55	27000
PNASNet-5 (Liu et al., 2018a)	3.2M	3.41	1160
NAO (Luo et al., 2018)	10.6 M	3.18	1000
ENAS+cutout (Pham et al., 2018)	4.6 M	2.89	-
DARTS+cutout (Liu et al., 2019b)	3.3 M	2.76	-
BayesNAS+cutout (Zhou et al., 2019)	3.4M	2.81	-
ASNG-NAS+cutout (Akimoto et al., 2019)	3.9 M	2.83	-
BOGCN+cutout (V1)	3.08M	2.74	200
BOGCN+cutout (V2)	3.48M	2.61	400
4.4.2 ResNet style search space
For ResNet style search space, we validate the proposed method for multi-objective search on Ima-
geNet (Deng et al., 2009). Here we consider classification accuracy and the number of parameters
of the model at the same time. Due to the large volume of the dataset, we train the sampled archi-
tectures by early stopping at 40 epochs rather than fully training. And other experiment settings are
the same with Section 4.3 as well.
9
Under review as a conference paper at ICLR 2020

No. of Parameters (M)
BOGCN
Pareto
Random
Pareto
BOGCN
Samples
Random
Samples
10 15 20 25 30 35 40 45 50
No. of Parameters (M)
Ml
(10.18M,0.758)
M2
(19.59M,0.761)
M3
(36.56M,0.783)
Resnet-18
(11.68M,0.696)
Resnet-34
(21.80M,0.733)
Resnet-50
(25.56M,0.760)
Resnet-IOl
(44.55Mf0.776)
(a) Comparison of BOGCN-NAS and Random Search. (b) Comparison of the found models and ResNets.
Figure 5: Open domain multi-objective search on ResNet style search space with 500 samples.
Compared with Random Sampling, BOGCN-NAS achieves a more competitive Pareto front.
The accuracy and number of parameters of the sampled model are illustrated in Figure 5. Compared
to random sampling, BOGCN-NAS achieves a more competitive Pareto front. We fully train every
model on the estimated Pareto front and pick three models (M1, M2, M3), which can dominate
ResNets. The comparison of our found models and famous ResNet family models are shown in
Figure 5b. It shows that ResNets can be dominated by our found models seriously.
4.5 Search Spcae Extension Transfer
In this section, we discover the ability of our proposed algorithm on search spcae extension transfer.
Most NAS algorithms only focus on static search space. In contrast, how to adapt the methods for
extension of search space is still an open problem. For instance, after searching in one small search
space A1 , how to transfer the obtained knowledge to a larger search space A2 . For validation, we
split NASBench into two sub-datasets: architectures with 6 nodes (62K) and architectures with 7
nodes (359K).
Using the same settings with Section 4.2, we pretrained our GCN model on architectures with 6
nodes and then transfer the GCN predictor to searching on the architecture domain with 7 nodes.
For comparison, we run the same algorithm without pretraining. The search method with pretrained
GCN predictor finds optimal model after 511.9 samples while the method without pretraining needs
1386.4 samples. As can be seen, pretraining can reach the optimal model 2.7× more efficiently
than unpretrained, validating the transfer ability of GCN predictor. Thus, BOGCN-NAS can handle
different-scale architectures as long as their operation choices are the same.
5	Conclusion
In this work, we propose BOGCN-NAS, a multi-objective NAS method using Bayesian Optimiza-
tion with Graph Convolutional Network predictor. We formulate the problem as a multi-objective
optimization problem and utilize the efficiency of BO to search top-performance architectures. In-
stead of using popular Gaussian Processes surrogate model, we replace it with proposed GCN pre-
dictor such that graph-based structure can be preserved better. For NAS-specific tasks, we also
propose weighted loss focusing on top-performance models. Experimental results show that the
proposed algorithm outperforms the SOTA LaNAS on single-objective NAS and validate its effi-
ciency on multi-objective NAS as well.
10
Under review as a conference paper at ICLR 2020
References
Y. Akimoto, S. Shirakawa, N. Yoshinari, K. Uchida, S. Saito, and K. Nishida. Adaptive stochastic
natural gradient method for one-shot neural architecture search. In International Conference on
Machine Learning, 2019. 4
B.	Baker, O. Gupta, N. Naik, and R. Raskar. Designing neural network architectures using rein-
forcement learning. In International Conference on Learning Representations, 2016. D
C.	Bishop. Pattern recognition and machine learning. 2006. 3.3
H. Cai, T. Chen, W. Zhang, Y. Yu, and J. Wang. Efficient architecture search by network transfor-
mation. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018. D
H. Cai, L. Zhu, and S. Han. Proxylessnas: Direct neural architecture search on target task and
hardware. In International Conference on Learning Representations, 2019. D
L. Chen, M. Collins, Y. Zhu, G. Papandreou, B. Zoph, F. Schroff, H. Adam, and J. Shlens. Searching
for efficient multi-scale architectures for dense image prediction. In Advances in Neural Informa-
tion Processing Systems, pp. 8699-8710, 2018. D
Y. Chen, T. Yang, X. Zhang, G. Meng, C. Pan, and J. Sun. Detnas: Neural architecture search on
object detection. In Advances in neural information processing systems, 2019. 1, D
X. Chu, B. Zhang, H. Ma, R. Xu, J. Li, and Q. Li. Fast, accurate and lightweight super-resolution
with neural architecture search. arXiv preprint arXiv:1901.07261, 2019. 1
J. Deng, W. Dong, R. Socher, L. Li, K. Li, and L. Fei-Fei. Imagenet: A large-scale hierarchical
image database. In 2009 IEEE conference on computer vision and pattern recognition, pp. 248-
255, 2009. 4.4.2
G.	Ghiasi, T. Lin, and Q. Le. Nas-fpn: Learning scalable feature pyramid architecture for object
detection. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pp. 7036-7045, 2019. 1
H.	Jin, Q. Song, and X. Hu. Auto-keras: An efficient neural architecture search system. In Pro-
ceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery & Data
Mining, 2019. 3.3, D
D. Jones. A taxonomy of global optimization methods based on response surfaces. Journal of global
optimization, pp. 345-383, 2001. 1, 2.1
K. Kandasamy, W. Neiswanger, J. Schneider, B. Poczos, and E. Xing. Neural architecture search
with bayesian optimisation and optimal transport. In Advances in Neural Information Processing
Systems, 2018. 3.3, D
D. Kingma and J. Ba. Adam: A method for stochastic optimization. In International Conference on
Learning Representations, 2014. 4.1
T. Kipf and M. Welling. Semi-supervised classification with graph convolutional networks. In
International Conference on Learning Representations, 2016. 2.3
X. Li, Y. Zhou, Z. Pan, and J. Feng. Partial order pruning: for best speed/accuracy trade-off in
neural architecture search. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pp. 9145-9153, 2019. 4, C.4
C. Liu, B. Zoph, M. Neumann, J. Shlens, W. Hua, L. Li, L. Fei-Fei, A. Yuille, J. Huang, and
K. Murphy. Progressive neural architecture search. In Proceedings of the European Conference
on Computer Vision (ECCV), pp. 19-34, 2018a. 1, 4.1, 4, C.3
C. Liu, L. Chen, F. Schroff, H. Adam, W. Hua, A. Yuille, and L. Fei-Fei. Auto-deeplab: Hierar-
chical neural architecture search for semantic image segmentation. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition, pp. 82-92, 2019a. 1, D
11
Under review as a conference paper at ICLR 2020
H. Liu, K. Simonyan, O. Vinyals, C. Fernando, and K. Kavukcuoglu. Hierarchical representations
for efficient architecture search. In International Conference on Learning Representations, 2018b.
D
H. Liu, K. Simonyan, and Y. Yang. Darts: Differentiable architecture search. In International
Conference on Learning Representations, 2019b. 1, 4, C.3, D
R. Luo, F. Tian, T. Qin, E. Chen, and T. Liu. Neural architecture optimization. In Advances in neural
information processing systems,pp. 7816-7827, 2018. 1, 4
M. Luong, D. Dohan, A. Yu, Q. Le, B. Zoph, and V. Vasudevan. Exploring neural architecture search
for language tasks. In International Conference on Learning Representations, 2018. 1
M. MARCUS, B. SANTORINI, and M. MARCINKIEWICZ. Building a large annotated corpus of
english: the penn treebank. Computational linguistics-Association for Computational Linguistics,
pp. 313-330, 1993. 4, C.2
R. Marler and J. Arora. Survey of multi-objective optimization methods for engineering. Structural
and multidisciplinary optimization, pp. 369-395, 2004. 2.2
J. Mockus, V. Tiesis, and A. Zilinskas. The application of bayesian methods for seeking the ex-
tremum. Towards global optimization, (117-129), 1978. 1, 2.1
H. Pham, M. Guan, B. Zoph, Q. Le, and J. Dean. Efficient neural architecture search via parameter
sharing. In International Conference on Machine Learning, pp. 4092-4101, 2018. 1, 4, C.2
E. Real, S. Moore, A. Selle, S. Saxena, Y. Suematsu, J. Tan, Q. Le, and A. Kurakin. Large-scale
evolution of image classifiers. In Proceedings of the 34th International Conference on Machine
Learning-Volume 70, pp. 2902-2911, 2017. D
E. Real, A. Aggarwal, Y. Huang, and Q. Le. Regularized evolution for image classifier architecture
search. In Proceedings of the AAAI Conference on Artificial Intelligence, pp. 4780-4789, 2019a.
D
E. Real, A. Aggarwal, Y. Huang, and Q. Le. Regularized evolution for image classifier architecture
search. In Proceedings of the AAAI Conference on Artificial Intelligence, pp. 4780-4789, 2019b.
1, 4.2, 4
F. Scarselli, M. Gori, A. Tsoi, M. Hagenbuchner, and G. Monfardini. The graph neural network
model. IEEE Transactions on Neural Networks, pp. 61-80, 2008. 3.2
C. Sciuto, K. Yu, M. Jaggi, C. Musat, and M. Salzmann. Evaluating the search phase of neural
architecture search. arXiv preprint arXiv:1902.08142, 2019. 1
J. Snoek, H. Larochelle, and R. Adams. Practical bayesian optimization of machine learning algo-
rithms. In Advances in neural information processing systems, pp. 2951-2959, 2012. 3.3
J. Snoek, O. Rippel, K. Swersky, R. Kiros, N. Satish, N. Sundaram, M. Patwary, M. Prabhat, and
R. Adams. Scalable bayesian optimization using deep neural networks. In International confer-
ence on machine learning, pp. 2171-2180, 2015. 3.3
D. So, Q. Le, and C. Liang. The evolved transformer. In International Conference on Machine
Learning, pp. 5877-5886, 2019. 1
L. Wang, S. Xie, T. Li, R. Fonseca, and Y. Tian. Sample-efficient neural architecture search by
learning action space. arXiv preprint arXiv:1906.06832, 2019a. 1, 4.2, B.1
L. Wang, Y. Zhao, Y. Jinnai, Y. Tian, and R. Fonseca. Alphax: exploring neural architectures with
deep neural networks and monte carlo tree search. arXiv preprint arXiv:1903.11059, 2019b. 1,
3.2, 4.1, 4.2, B.1, B.2
S. Xie, H. Zheng, C. Liu, and L. Lin. Snas: stochastic neural architecture search. In International
Conference on Learning Representations, 2019. D
12
Under review as a conference paper at ICLR 2020
C. Ying, A. Klein, E. Christiansen, E. Real, K. Murphy, and F. Hutter. Nas-bench-101: Towards
reproducible neural architecture search. In International Conference on Machine Learning, pp.
7105-7114,2019. 1,3.2,4,B.2
C. Zhang, M. Ren, and R. Urtasun. Graph hypernetworks for neural architecture search. In Interna-
tional Conference on Learning Representations, 2019. 1
H. Zhou, M. Yang, J. Wang, and W. Pan. Bayesnas: A bayesian approach for neural architecture
search. In International Conference on Machine Learning, 2019. 4
B. Zoph and Q. Le. Neural architecture search with reinforcement learning. In International Con-
ference on Learning Representations, 2017. 1, D
B. Zoph, V. Vasudevan, J. Shlens, and Q. Le. Learning transferable architectures for scalable image
recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition,
pp. 8697-8710, 2018. 4,4
13
Under review as a conference paper at ICLR 2020
Appendices
A Ablation Study
A. 1 The advantage of GCN Predictor and Bayesian Optimization
To verify that GCN is a superior choice of predictor against others (e.g. MLP, RNN), we replaced
GCN in the search algorithm with MLP predictor. And for demonstrating that Bayesian Optimiza-
tion indeed improves the performance of our search algorithm, we also remove BLR and use point
estimation only. In other words, we select candidate models based only on GCN’s predictive ac-
curacies of architectures. Therefore, there are four different models correspondingly: (1) MLP;
(2) BOMLP; (3) GCN; (4) BOGCN, where MLP, GCN use predictor only for model selection and
BOMLP, BOGCN apply Bayesian Optimization on the strength of respective predictor.
With other settings same with with Section 4.2, we perform single-objective NAS algorithms over
50 rounds and the results of experiments on NASBench and LSTM datasets are shown in Figure
6. As can be seen, GCN is able to discover the optimal architecture with fewer samples than MLP,
which proves the superiority of GCN predictor and our algorithm is more efficient with Bayesian
Optimization.
Figure 6: Ablation study of Bayesian Optimization and Graph Convolutional Network Predictor.
The comparison shows that the efficiency of the search can be boosted by adding Bayesian opti-
mization and Graph Convolutional Network modules respectively.
A.2 The improvement of Exponential Weighted Loss
To prove the improvement of our proposed weighted loss empirically, we compare it with MSE loss.
We also design other two weighted losses as following to show the influence of the second-order
derivative of added weight. We apply the same settings with Section 4.2 for algorithm performing
and the experiment result of single-objective (accuracy) on NASBench is shown in Figure 7. As
can be seen, exponential weighted loss outperforms other three losses, which is consistent with our
intuition.
(10)
1N
Llog = Nlog2 "og(y + I)IIyi -曲|2,
(11)
14
Under review as a conference paper at ICLR 2020
1⅛ΦM 山,≥⅛a⅛l
(a) The illustration of four losses considered in this
paper.
1824.27	1773.16	16笛,82	1465.4
Oo
10
O
Oo
4
O O
O O
O O
3 2
SqdEeS JOON
(b) The performance of four losses over 50 rounds. It
can be found that our method can reach the highest
efficiency with exponential weighted loss.
Figure 7: Ablation study of Weighted Loss.
B	Supplemental Experiments
B.1	Time course performance comparison
Following (Wang et al., 2019b;a), besides comparing the number of training architectures sampled
until finding the global optimal architecture, we also evaluate the current best models during the
searching process. As shown in Figure 8, our proposed BOGCN-NAS outperform other search
algorithms except for the very beginning on LSTM model searching.
900	1100	1300	1500	1700	1900
Number of Samples
(a) NASBench
300	500	700	900 1100 1300 1500 1700 1900
Number of Samples
(b) LSTM-12K
Figure 8: Current best accuracy during searching. The result demonstrates that our proposed
BOGCN-NAS outperforms other search algorithms significantly.
B.2	Predictor training on whole search space
For comparison with previous work (Wang et al., 2019b), we also train our GCN predictor on whole
NASBench dataset (420K models) (Ying et al., 2019). We use 85% NASBench for training, 10%
for validation and remaining 5% for testing. As shown in Figure 9 (the value also means the density
of architectures around), GCN outperforms others consistently with experiment training on fewer
data (Section 4.1). Even though the correlations of the GCN and MLP are comparable here, the
performance is less important than cases training on fewer data.
15
Under review as a conference paper at ICLR 2020
Figure 9: Correlation of predicted accuaracy versus ground truth for various predictors on whole
dataset. It shows that GCN predictor can predict more accurately than other two predictors on
whole NASBench.
C Dataset and Search Space
C.1 NASBench encoding
Iutput
Global
Node8
Conv
Node2
Conv
Node 3
Conv
Node4
1X1
Conv
Node 6
Input: O; ConvlX 1: 1; Conv3×3: 2; MaxPooIing: 3; Output: 4; Global: 5
Operations and corresponding indices
Input
Node 1
Adjacency Matrix (8X8)
One-Hot Encoded
Feature Matrix (8×6)
Figure 10: The encoding scheme of an example cell in NASBench.
C.2 LSTM- 1 2K dataset
To create LSTM model dataset, we follow the same setting proposed by ENAS (Pham et al., 2018),
we use adjacency matrix and a list of operators to represent an LSTM cell, and randomly sampled
12K cell structures from that domain, because the cells have natural graph structures, it is easy to
feed them directly into GCN and conduct training. Due to the limitation on computational resources,
we only sample architectures with number of nodes less than or equal to 8, and trained each cell for
10 epochs on PTB dataset (MARCUS et al., 1993). We use perplexity as a performance measure for
the cells.
C.3 NASNet search space
We follow the search space setting of DARTS (Liu et al., 2019b), in which the architecture is stacked
by the learned cell. The cell consists of 4 blocks, two inputs (the output of previous cell and the
previous previous cell) and one output. There are 8 types operations allowed: 3 × 3 and 5 × 5
separable convolutions, 3 × 3 and 5 × 5 dilated separable convolutions, 3 × 3 max pooling, 3 × 3
average pooling, identity, and zero. Similar to previous work (Liu et al., 2018a), we apply the same
16
Under review as a conference paper at ICLR 2020
cell architecture for both “normal” and “reduction” layer. For adapting to proposed GCN predictor,
we regard the operation as the node and regard the data flow as the edge. The encoding examples
are illustrated in Appendices E.
C.4 ResNet style search space
We follow the setting of Li et al. (2019) to prepare the ResNet style search space. This search
space aims to find when to perform down-sampling and when to double the channels. The ResNet
style backbone consists of 5 stages with different resolutions from input images. The spatial size
of Stage 1 to 5 is gradually down-sampled by the factor of 2. As suggested in Li et al. (2019), we
fixed one 3 × 3 convolution layer (stride = 2) in Stage-1 and the beginning of Stage-2. We use
the block setting as bottleneck residual block in ResNet. Then, the backbone architecture encoding
string looks like “1211 - 211 - 1111 - 12111”, where “-” separates each stage with different
resolution, “1” means regular block with no change of channels and “2” indicated the number of
base channels is doubled in this block. The base channel size is 64. In Section 4.4, we just take
“-, 1, 2” as three different operations and encode architectures as a series of strings. We train the
model generated from this search space for 40 epochs with a fast convergence learning rate schedule.
Each architecture can be evaluated in 4 hours on one server with 8 V100 GPU machines.
D NAS Related Work
NAS aims at automatically finding a neural network architecture for a certain task such as CV and
NPL (Chen et al., 2018; Liu et al., 2019a; Chen et al., 2019) and different datasets without human’s
labor of designing networks. Particularly, in real applications, the objective of NAS is more preferred
to be obtaining a decent accuracy under a limited computational budget. Thus a multi-objective
NAS is a more practical setting than only focusing on accuracy. There are several approaches in
NAS area: 1) Reinforcement learning-based algorithm. Baker et al. (2016); Zoph & Le (2017); Cai
et al. (2018) train an RNN policy controller to generate a sequence of actions to design cell structure
for a specify CNN architecture; 2) Evolution-based algorithm. Real et al. (2017); Liu et al. (2018b);
Real et al. (2019a) try to evolve architectures or Network Morphism by mutating the current best
architectures and explore new potential models; 3) Gradient-based algorithm Liu et al. (2019b);
Cai et al. (2019); Xie et al. (2019) define an architecture parameter for continuous relaxation of
the discrete search space, thus allowing differentiable optimization of the architecture. 4) Bayesian
Optimization-based algorithm. (Kandasamy et al., 2018) and (Jin et al., 2019) define the heuristic
distances between architectures and apply BO with Gaussian Processes. Among those algorithms,
most existing methods focus on a single objective (accuracy), others adding computation constraints
as a regularization loss in the gradient-based method or as a reward in the RL-based algorithm. In
contrast, our method reformulates the multi-objective NAS as a non-dominate sorting problem and
further enables an efficient search over flexible customized search space.
E Best Found Models
E.1 NASNet search space
Figure 11a and 11c show the found architectures from the open domain search on NASNet search
space by our method.
E.2 ResNet style search space
Figure 12, 13 and 14 show the found architectures from the open domain search on ResNet style
search space by our method.
17
Under review as a conference paper at ICLR 2020
skip-connect
skip_connect
sep_conv_
sep_conv_3x3
sep_conv_
max_pool_
sep_conv_3x3
skip_connect
J{k}
(a) V1 (normal cell and reduction cell)
(b) V1 cell encoding
(c) V2 (normal cell and reduction cell)
Figure 11: The found models in NASNet search space.
(d) V2 cell encoding
Stage3
Stage4
Stage5
篦IU-
Arch code 64	_
2
I
Figure 12: M1 (“1 -
11 - 1111111211 - 1122”)
Stagel	Stage2	Stage3	Stage4
I	i
Stage5
I
1
1
Figure 13: M2 (“1 - 11 - 112 - 11111112211”)
Figure 14: M3 (“1 - 11111111 - 2111121111 - 211111”)
18