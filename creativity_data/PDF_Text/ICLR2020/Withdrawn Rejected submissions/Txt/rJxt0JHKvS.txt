Under review as a conference paper at ICLR 2020
Coloring graph neural networks for node
DISAMBIGUATION
Anonymous authors
Paper under double-blind review
Ab stract
In this paper, we show that a simple coloring scheme can improve, both theoreti-
cally and empirically, the expressive power of Message Passing Neural Networks
(MPNNs). More specifically, we introduce a graph neural network called Colored
Local Iterative Procedure (CLIP) that uses colors to disambiguate identical node at-
tributes, and show that this representation is a universal approximator of continuous
functions on graphs with node attributes. Our method relies on separability, a key
topological characteristic that allows to extend well-chosen neural networks into
universal representations. Finally, we show experimentally that CLIP is capable
of capturing structural characteristics that traditional MPNNs fail to distinguish,
while being state-of-the-art on benchmark graph classification datasets.
1	Introduction
Learning good representations is seen by many machine learning researchers as the main reason
behind the tremendous successes of the field in recent years (Bengio et al., 2013). In image analy-
sis (Krizhevsky et al., 2012), natural language processing (Vaswani et al., 2017) or reinforcement
learning (Mnih et al., 2015), groundbreaking results rely on efficient and flexible deep learning
architectures that are capable of transforming a complex input into a simple vector while retaining
most of its valuable features. The universal approximation theorem (Cybenko, 1989; Hornik et al.,
1989; Hornik, 1991; Pinkus, 1999) provides a theoretical framework to analyze the expressive power
of such architectures by proving that, under mild hypotheses, multi-layer perceptrons (MLPs) can
uniformly approximate any continuous function on a compact set. This result provided a first theoret-
ical justification of the strong approximation capabilities of neural networks, and was the starting
point of more refined analyses providing valuable insights into the generalization capabilities of these
architectures (Baum and Haussler, 1989; Geman et al., 1992; Saxe et al., 2014; Bartlett et al., 2018).
Despite a large literature and state-of-the-art performance on benchmark graph classification datasets,
graph neural networks yet lack a similar theoretical foundation (Xu et al., 2019). Universality for these
architectures is either hinted at via equivalence with approximate graph isomorphism tests (k-WL
tests in Xu et al. 2019; Maron et al. 2019a), or proved under restrictive assumptions (finite node
attribute space in Murphy et al. 2019). In this paper, we introduce Colored Local Iterative Procedure1
(CLIP), which tackles the limitations of current Message Passing Neural Networks (MPNNs) by
showing, both theoretically and experimentally, that adding a simple coloring scheme can improve
the flexibility and power of these graph representations. More specifically, our contributions are: 1)
we provide a precise mathematical definition for universal graph representations, 2) we present a
general mechanism to design universal neural networks using separability, 3) we propose a novel
node coloring scheme leading to CLIP, the first provably universal extension of MPNNs, 4) we show
that CLIP achieves state of the art results on benchmark datasets while significantly outperforming
traditional MPNNs as well as recent methods on graph property testing.
The rest of the paper is organized as follows: Section 2 gives an overview of the graph representation
literature and related works. Section 3 provides a precise definition for universal representations, as
well as a generic method to design them using separable neural networks. In Section 4, we show that
most state-of-the-art representations are not sufficiently expressive to be universal. Then, using the
analysis of Section 3, Section 5 provides CLIP, a provably universal extension of MPNNs. Finally,
1Code will be available at https://github.com/ after the review process.
1
Under review as a conference paper at ICLR 2020
Section 6 shows that CLIP achieves state-of-the-art accuracies on benchmark graph classification
taks, as well as outperforming its competitors on graph property testing problems.
2	Related works
The first works investigating the use of neural networks for graphs used recurrent neural networks to
represent directed acyclic graphs (Sperduti and Starita, 1997; Frasconi et al., 1998). More generic
graph neural networks were later introduced by Gori et al. (2005); Scarselli et al. (2009), and
may be divided into two categories. 1) Spectral methods (Bruna et al., 2014; Henaff et al., 2015;
Defferrard et al., 2016; Kipf and Welling, 2017) that perform convolution on the Fourier domain of
the graph through the spectral decomposition of the graph Laplacian. 2) Message passing neural
networks (Gilmer et al., 2017), sometimes simply referred to as graph neural networks, that are based
on the aggregation of neighborhood information through a local iterative process. This category
contains most state-of-the-art graph representation methods such as (Duvenaud et al., 2015; Grover
and Leskovec, 2016; Lei et al., 2017; Ying et al., 2018; Verma and Zhang, 2019), DeepWalk (Perozzi
et al., 2014), graph attention networks (Velickovic et al., 2018), graphSAGE (Hamilton et al., 2017)
or GIN (Xu et al., 2019).
Recently, (Xu et al., 2019) showed that MPNNs were, at most, as expressive as the Weisfeiler-
Lehman (WL) test for graph isomorphism (Weisfeiler and Lehman, 1968). This suprising result led to
several works proposing MPNN extensions to improve their expressivity, and ultimately tend towards
universality (Maron et al., 2019a;b;c; Murphy et al., 2019; Chen et al., 2019). However, these graph
representations are either as powerful as the k-WL test (Maron et al., 2019a), or provide universal
graph representations under the restrictive assumption of finite node attribute space (Murphy et al.,
2019). Other recent approaches (Maron et al., 2019c) implies quadratic order of tensors in the size of
the considered graphs. Some more powerfull GNNs are studied and benchmarked on real classical
datasets and on graph property testing (Kriege et al., 2018; Murphy et al., 2019; Chen et al., 2019): a
set of problems that classical MPNNs cannot handle. Our work thus provides a more general and
powerful result of universality, matching the original definition of (Cybenko, 1989) for MLPs.
3	Universal representations via separability
In this section we present the theoretical tools used to design our universal graph representation. More
specifically, we show that separable representations are sufficiently flexible to capture all relevant
information about a given object, and may be extended into universal representations.
3.1	Notations and basic assumptions
Let X, Y be two topological spaces, then F(X, Y) (resp. C(X, Y)) denotes the space of all functions
(resp. continuous functions) from X to Y. Moreover, for any group G acting on a set X , X/G
denotes the set of orbits of X under the action of G (see Appendix B for more details). Finally, k∙k is
a norm on Rd, and Pn is the set of all permutation matrices of size n. In what follows, we assume that
all the considered topological spaces are Hausdorff (see e.g. (Bourbaki, 1998) for an in-depth review):
each pair of distinct points can be separated by two disjoint open sets. This assumption is rather
weak (e.g. all metric spaces are Hausdorff) and is verified by most topological spaces commonly
encountered in the field of machine learning.
3.2	Universal representations
Let X be a set of objects (e.g. vectors, images, graphs, or temporal data) to be used as input
information for a machine learning task (e.g. classification, regression or clustering). In what follows,
we denote as vector representation of X a function f : X → Rd that maps each element x ∈ X
to a d-dimensional vector f(x) ∈ Rd. A standard setting for supervised representation learning is
to define a class of vector representations Fd ⊂ F(X, Rd) (e.g. convolutional neural networks for
images) and use the target values (e.g. image classes) to learn a good vector representation in light of
the supervised learning task (i.e. one vector representation f ∈ Fd that leads to a good accuracy on the
learning task). In order to present more general results, we will consider neural network architectures
that can output vectors of any size, i.e. F ⊂ ∪d∈N* F(X, Rd), and will denote Fd = F ∩ F(X, Rd)
2
Under review as a conference paper at ICLR 2020
f
g
input hidden layer output
(f, g)
Figure 1: Concatenation of two MLPs f and g .
Figure 2: Universal representations can eas-
ily be created by combining a separable rep-
resentation with an MLP.
the set of d-dimensional vector representations of F. A natural characteristic to ask from the class
F is to be generic enough to approximate any vector representation, a notion that we will denote as
universal representation (Hornik et al., 1989).
Definition 1. A class of vector representations F ⊂ ∪d∈N* F(X, Rd) is called a universal represen-
tation of X if for any compact subset K ⊂ X and d ∈ N*, F is uniformly dense in C (K, Rd).
In other words, F is a universal representation of a normed space X if and only if, for any continuous
function φ : X → Rd, any compact K ⊂ X and any ε > 0, there exists f ∈ F such that
∀x ∈ K, kφ(x) - f (x)k ≤ ε .	(1)
One of the most fundamental theorems of neural network theory states that one hidden layer MLPs
are universal representations of the m-dimensional vector space Rm .
Theorem 1 (Pinkus, 1999, Theorem 3.1). Let φ : R → R be a continuous non polynomial activation
function. For any compact K ⊂ Rm and d ∈ N*, two layers neural networks with activation φ are
uniformly dense in the set C(K, Rd).
However, for graphs and structured objects, universal representations are hard to obtain due to
their complex structure and invariance to a group of transformations (e.g. permutations of the node
labels). We show in this paper that a key topological property, separability, may lead to universal
representations of those structures.
3.3	Separability is (almost) all you need
Loosely speaking, universal representations can approximate any vector-valued function. It is thus
natural to require that these representations are expressive enough to separate each pair of dissimilar
elements of X .
Definition 2 (Separability). A set of functions F ⊂ F(X, Y) is said to separate points of X if for
every pair of distinct points x and y, there exists f ∈ F such that f (x) 6= f (y).
For a class of vector representations F ⊂ ∪d∈N* F(X, Rd), we will say that F is separable if its
1-dimensional representations F1 separates points of X . Separability is rather weak, as we only
require the existence of different outputs for every pair of inputs. Unsurprisingly, we now show that it
is a necessary condition for universality (see Appendix A for all the detailed proofs).
Proposition 1. Let F be a universal representation of X, then F1 separates points of X.
While separability is necessary for universal representations, it is also key to designing neural network
architectures that can be extended into universal representations. More specifically, under technical
assumptions, separable representations can be composed with a universal representation of Rd (such
as MLPs) to become universal.
Theorem 2. For all d ≥ 0, let Md be a universal approximation of Rd. Let F be a class of vector
representations of X such that:
(i)	Continuity: every f ∈ F is continuous,
(ii)	Stability by concatenation: for all f, g ∈ F, x 7→ (f (x), g(x)) ∈ F,
3
Under review as a conference paper at ICLR 2020
(iii)	Separability: F1 separates points of X.
Then {ψ ◦ f : ∃d ≥ 1 s.t. ψ ∈ Md, f ∈ F} is a universal representation of X.
Stability by concatenation is verified by most neural networks architectures, as illustrated for MLPs
in Figure 1. The proof of Theorem 2 relies on the Stone-Weierstrass theorem (see e.g. Rudin,
1987, Theorem 7.32) whose assumptions are continuity, separability, and the fact that the class of
functions is an algebra. Fortunately, composing a separable and concatenable representation with a
universal representation automatically leads to an algebra, and thus the applicability of the Stone-
Weierstrass theorem and the desired result. A complete derivation is available in Appendix A. Since
MLPs are universal representations of Rd , Theorem 2 implies a convenient way to design universal
representations of more complex object spaces: create a separable representation and compose it with
a simple MLP (see Figure 2).
Corollary 1. A continuous, concatenable and separable representation of X composed with an MLP
is universal.
Note that many neural networks of the deep learning literature have this two steps structure, including
classical image CNNs such as AlexNet (Krizhevsky et al., 2012) or Inception (Szegedy et al., 2016).
In this paper, we use Corollary 1 to design universal graph and neighborhood representations, although
the method is much more generic and may be applied to other objects.
4	Limitations of existing representations
In this section, we first provide a proper definition for graphs with node attributes, and then show that
message passing neural networks are not sufficiently expressive to be universal.
4.1	Graphs with node attributes
Consider a dataset of n interacting objects (e.g. users of a social network) in which each object
i ∈ J1, nK has a vector attribute vi ∈ Rm and is a node in an undirected graph G with adjacency
matrix A ∈ Rn×n .
Definition 3. The space of graphs of size n with m-dimensional node attributes is the quotient space
Graphm,n = (v, A) ∈ Rn×m × Rn×n /Pn,
(2)
where A is the adjacency matrix of the graph, v contains the m-dimensional representation of each
node in the graph and the set of permutations matrices Pn is acting on (v, A) by
∀P ∈ Pn, P ∙ (v,A) = (Pv,PAP>).
(3)
Moreover, we limit ourselves to graphs of maximum size nmax , where nmax is a large integer. This
allows us to consider functions on graphs of different sizes without obtaining infinite dimensional
spaces and infinitely complex functions that would be impossible to learn via a finite number
of samples. We thus define Graphm = Sn≤n Graphm,n. More details on the technical
topological aspects of the definition are available in Appendix B, as well as a proof that Graphm is
Hausdorff.
4.2	Message passing neural networks
A common method for designing graph representations is to rely on local iterative procedures.
Following the notations of Xu et al. (2019), a message passing neural network (MPNN) (Gilmer
et al., 2017) is made of three consecutive phases that will create intermediate node representations
xi,t for each node i ∈ J1, nK and a final graph representation xG as described by the following
procedure: 1) Initialization: All node representations are initialized with their node attributes
xi,0 = vi. 2) Aggregation and combination: T local iterative steps are performed in order to
capture larger and larger structural characteristics of the graph. 3) Readout: This step combines
all final node representations into a single graph representation: xG = READOUT({xi,T }i∈J1,nK ),
where Readout is permutation invariant.
4
Under review as a conference paper at ICLR 2020
Figure 3: Example of two valid colorings of the same attributed graph. Note that each Vk contains
nodes with identical attributes.
Unfortunately, while MPNNs are very efficient in practice and proven to be as expressive as the
Weisfeiler-Lehman algorithm (Weisfeiler and Lehman, 1968; Xu et al., 2019), they are not sufficiently
expressive to construct isomorphism tests or separate all graphs (for example, consider k-regular
graphs without node attributes, for which a small calculation shows that any MPNN representation
will only depend on the number of nodes and degree k (Xu et al., 2019)). As a direct application of
Proposition 1, MPNNs are thus not expressive enough to create universal representations.
5	Extending MPNNs using a simple coloring scheme
In this section, we present Colored Local Iterative Procedure (CLIP), an extension of MPNNs using
colors to differentiate identical node attributes, that is able to capture more complex structural graph
characteristics than traditional MPNNs. This is proved theoretically through a universal approximation
theorem in Section 5.3 and experimentally in Section 6. CLIP is based on three consecutive steps: 1)
graphs are colored with several different colorings, 2) a neighborhood aggregation scheme provides a
vector representation for each colored graph, 3) all vector representations are combined to provide a
final output vector. We now provide more information on the coloring scheme.
5.1	Colors to differentiate nodes
In order to distinguish non-isomorphic graphs, our approach consists in coloring nodes of the graph
with identical attributes. This idea is inspired by classical graph isomorphism algorithms that use
colors to distinguish nodes (McKay, 1981), and may be viewed as an extension of one-hot encodings
used for graphs without node attributes (Xu et al., 2019).
For any k ∈ N, let Ck be a finite set of k colors. These colors may be represented as one-hot encodings
(Ck is the natural basis of Rk) or more generally any finite set of k elements. At initialization, we
first partition the nodes into groups of identical attributes V1, ..., VK ⊂ J1, nK. Then, for a subset Vk
of size |Vk |, we give to each of its nodes a distinct color from Ck (hence a subset of size |Vk |). For
example, Figure 3 shows two colorings of the same graph, which is decomposed in three groups V1 ,
V2 and V3 containing nodes with attributes a, b and c respectively. Since V1 contains only two nodes,
a coloring of the graph will attribute two colors ((1, 0) and (0, 1), depicted as blue and red) to these
nodes. More precisely, the set of colorings C(v, A) of a graph G = (v, A) are defined as
C(v,A) =	(c1,	...,cn)	:	∀k	∈ J1,KK,	(ci)i∈Vk	is a permutation of	C|Vk|	.
(4)
5.2	The CLIP algorithm
In the CLIP algorithm, we add a coloring scheme to an MPNN in order to distinguish identical node
attributes. This is achieved by modifying the initialization and readout phases of MPNNs as follows.
1.	Colored initialization: We first select a set Ck ⊆ C(v, A) of k distinct colorings uniformly
at random (see Eq. (4)). Then, for each coloring c ∈ Ck, node representations are initialized
with their node attributes concatenated with their color: xic,0 = (vi , ci).
2.	Aggregation and combination: This step is performed for all colorings c ∈ Ck using a uni-
versal set representation as the aggregation function: xic,t+1 = ψ⑴(xc,t, Pj∈Ni *(xj,t)),
5
Under review as a conference paper at ICLR 2020
xG = ψ max
c∈Ck
where ψ and 夕 are MLPs with continuous non-Polynomial activation functions and ψ(x, y)
denotes the result of ψ applied to the concatenation of x and y . The aggregation scheme
we ProPose is closely related to DeePSet (Zaheer et al., 2017), and a direct aPPlication of
Corollary 1 Proves the universality of our architecture. More details, as well as the Proof of
universality, are available in APPendix C.
3.	Colored readout: This steP Performs a maximum over all Possible colorings in order to
obtain a final coloring-independent graPh rePresentation. In order to keeP the stability by
concatenation, the maximum is taken coefficient-wise
Xn xic,T	,	(5)
i=1
where ψ is an MLP with continuous non Polynomial activation functions.
We treat k as a hyPer-Parameter of the algorithm and call k-CLIP (resP. ∞-CLIP) the algorithm
using k colorings (resP. all colorings, i.e. k = |C(v, A)|). Note that, while our focus is graPhs with
node attributes, the aPProach used for CLIP is easily extendable to similar data structures such as
directed or weighted graPhs with node attributes, graPhs with node labels, graPhs with edge attributes
or graPhs with additional attributes at the graPh level.
5.3	Universal representation theorem
As the colorings are chosen at random, the CLIP rePresentation is itself random as soon as k <
|C(v, A)|, and the number of colorings k will imPact the variance of the rePresentation. However,
∞-CLIP is deterministic and Permutation invariant, as MPNNs are Permutation invariant. The
seParability is less trivial and is ensured by the coloring scheme.
Theorem 3.	The ∞-CLIP algorithm with one local iteration (T = 1) is a universal representation
of the space Graphm of graphs with node attributes.
The Proof of Theorem 3 relies on showing that ∞-CLIP is seParable and aPPlying Corollary 1. This
is achieved by fixing a coloring on one graPh and identifying all nodes and edges of the second
graPh using the fact that all Pairs (vi, ci) are dissimilar (see APPendix D). Similarly to the case of
MLPs, only one local iteration is necessary to ensure universality of the rePresentation. This rather
counter-intuitive result is due to the fact that all nodes can be identified by their color, and the readout
function can aggregate all the structural information in a comPlex and non-trivial way. However, as
for MLPs, one may exPect Poor generalization caPabilities for CLIP with only one local iteration,
and deePer networks may allow for more comPlex rePresentations and better generalization. This
Point is addressed in the exPeriments of Section 6. Moreover, ∞-CLIP may be slow in Practice due
to a large number of colorings, and reducing k will sPeed-uP the comPutation. Fortunately, while
k-CLIP is random, a similar universality theorem still holds even for k = 1.
Theorem 4.	The 1-CLIP algorithm with one local iteration (T = 1) is a random representation
whose expectation is a universal representation of the space Graphm of graphs with node attributes.
The Proof of Theorem 4 relies on using ∞-CLIP on the augmented node attributes vi0 = (vi, ci). As
all node attributes are, by design, different, the max over all colorings in Eq. (5) disaPPears and, for
any coloring, 1-CLIP returns an ε-aPProximation of the target function (see APPendix D).
Remark 1. Note that the variance of the rePresentation may be reduced by averaging over multiPle
samPles. Moreover, the Proof of Theorem 4 shows that the variance can be reduced to an arbitrary
Precision given enough training ePochs, although this may lead to very large training times in Practice.
5.4 Computational complexity
As the local iterative stePs are Performed T times on each node and the comPlexity of the aggregation
dePends on the number of neighbors of the considered node, the comPlexity is ProPortional to the
number of edges of the graPh E and the number of stePs T . Moreover, CLIP Performs this iterative
aggregation for each coloring, and its comPlexity is also ProPortional to the number of chosen
colorings k = |Ck|. Hence the comPlexity of the algorithm is in O(kET).
6
Under review as a conference paper at ICLR 2020
Note that the number of all possible colorings for a given graph depends exponentially in the size of
the groups V1 , ..., VK,
K
|C(v,A)| = Y|Vk|!,	(6)
k=1
and thus ∞-CLIP is practical only when most node attributes are dissimilar. This worst case
exponential dependency in the number of nodes can hardly be avoided for universal representations.
Indeed, a universal graph representation should also be able to solve the graph isomorphism problem.
Despite the existence of polynomial time algorithms for a broad class of graphs (Luks, 1982;
Bodlaender, 1990), graph isomorphism is still quasi-polynomial in general (Babai, 2016). As a result,
creating a universal graph representation with polynomial complexity for all possible graphs and
functions to approximate is highly unlikely, as it would also induce a graph isomorphism test of
polynomial complexity and thus solve a very hard and long standing open problem of theoretical
computer science.
6 Experiments
In this section we show empirically the practical efficiency of CLIP and its relaxation. We run two
sets of experiments to compare CLIP w.r.t. state-of-the-art methods in supervised learning settings: i)
on 5 real-world graph classification datasets and ii) on 4 synthetic datasets to distinguish structural
graph properties and isomorphism. Both experiments follow the same experimental protocol as
described in Xu et al. (2019): 10-fold cross validation with grid search hyper-parameter optimization.
More details on the experimental setup are provided in Appendix E.
6.1	Classical benchmark datasets
We performed experiments on five benchmark datasets extracted from standard social networks
(IMDBb and IMDBm) and bio-informatics databases (MUTAG, PROTEINS and PTC). All dataset
characteristics (e.g. size, classes), as well as the experimental setup, are available in Appendix E.
Following standard practices for graph classification on these datasets, we use one-hot encodings
of node degrees as node attributes for IMDBb and IMDBm (Xu et al., 2019), and perform single-
label multi-class classification on all datasets. We compared CLIP with six state-of-the-art baseline
algorithms: 1) WL: Weisfeiler-Lehman subtree kernel (Shervashidze et al., 2011), 2) AWL: Anony-
mous Walk Embeddings (Ivanov and Burnaev, 2018), 3) DCNN: Diffusion-convolutional neural
networks (Atwood and Towsley, 2016), 4) PS: PATCHY-SAN (Niepert et al., 2016), 5) DGCNN:
Deep Graph CNN (Zhang et al., 2018) and 6) GIN: Graph Isomorphism Network (Xu et al., 2019).
WL and AWL are representative of unsupervised methods coupled with an SVM classifier, while
DCNN, PS, DGCNN and GIN are four deep learning architectures. As the same experimental
protocol as that of Xu et al. (2019) was used, we present their reported results on Table 1.
Table 1: Classification accuracies of the compared methods on benchmark datasets. The best
performer w.r.t. the mean is highlighted with an asterisk. We perform an unpaired t-test with
asymptotic significance of 0.1 w.r.t. the best performer and highlight with boldface the ones for which
the difference is not statistically significant. 0-CLIP is the CLIP architecture without any colorings.
Dataset	PTC	IMDBb	IMDBm	PROTEINS	MUTAG
WL	59.9±4.3	73.8±3.9	50.9±3.8	75.0±3.1	90.4±5.7
DCNN	56.6	49.1	33.5	61.3	67.0
PS	60.0±4.8	71.0±2.2	45.2±2.8	75.9±2.8	92.6±4.2
DGCNN	58.6	70.0	47.8	75.5	85.8
AWL	-	74.5±5.9	51.5±3.6	-	87.9±9.8
GIN	64.6±7.0	75.1±5.1	52.3±2.8	76.2±2.8	89.4±5.6
0-CLIP	65.9±4.0	75.4±2.0	52.5±2.6*	77.0±3.2	90.0±5.1
CLIP	67.9±7.1*	76.0±2.7*	52.5±3.0*	77.1±4.4*	93.9±4.0*
As Table 1 shows, CLIP can achieve state-of-the-art performance on the five benchmark datasets.
Moreover, CLIP is consistent across all datasets, while all other competitors have at least one weak
7
Under review as a conference paper at ICLR 2020
performance. This is a good indicator of the robustness of the method to multiple classification tasks
and dataset types. Finally, the addition of colors does not improve the accuracy for these graph
classification tasks, except on the MUTAG dataset. This may come from the small dataset sizes
(leading to high variances) or an inherent difficulty of these classification tasks, and contrasts with
the clear improvements of the method for property testing (see Section 6.2). More details on the
performance of CLIP w.r.t. the number of colors k are available in Appendix E.
Remark 2. In three out of five datasets, none of the recent state-of-the-art algorithms have statistically
significantly better results than older methods (e.g. WL). We argue that, considering the high variances
of all classification algorithms on classical graph datasets, graph property testing may be better suited
to measure the expressiveness of graph representation learning algorithms in practice.
6.2	Graph property testing
We now investigate the ability of CLIP to identify structural graph properties, a task which was previ-
ously used to evaluate the expressivity of graph kernels and on which the Weisfeiler-Lehman subtree
kernel has been shown to fail for bounded-degree graphs (Kriege et al., 2018). The performance
of our algorithm is evaluated for the binary classification of four different structural properties: 1)
connectivity, 2) bipartiteness, 3) triangle-freeness, 4) circular skip links (Murphy et al., 2019) (see
Appendix E for precise definitions of these properties) against three competitors: a) GIN, arguably the
most efficient MPNN variant yet published (Xu et al., 2019), b) Ring-GNN, a permutation invariant
network that uses the ring of matrix addition and multiplication (Chen et al., 2019), c) RP-GIN,
the Graph Isomorphism Network combined with Relational Pooling, as described by Murphy et al.
(2019), which is able to distinguish certain cases of non-isomorphic regular graphs. We provide all
experimental details in Appendix E.
Table 2: Classification accuracies of the synthetic datasets. k-RP-GIN refers to a relational pooling
averaged over k random permutations. We report Ring-GNN results from Chen et al. (2019).
Property	Connectivity mean ± std	Bipartiteness mean ± std	Triangle-freeness mean ± std	Circular skip links		
				mean ± std	max	min
GIN	55.2 ± 4.4	53.1 ±4.7	50.7±6.1	10.0 ± 0.0	10.0	10.0
Ring-GNN	-	-	-	(?) ± 15.7	80.0	10.0
1-RP-GIN	66.1±5.2	66.0±5.1	63.0±3.6	20.0 ± 7.0	28.6	10.0
16-RP-GIN	83.3±7.9	64.9±4.1	65.7±3.3	37.6 ± 12.9	53.3	10.0
0-CLIP	56.5 ± 4.0	55.4 ± 5.7	59.6 ± 3.8	10.0 ± 0.0	10.0	10.0
1-CLIP	73.3 ± 2.2	63.3 ±1.9	63.5 ±7.3	61.9 ±11.9	80.7	36.7
16-CLIP	99.7 ± 0.5	99.2 ± 0.9	94.2±3.4	90.8 ± 6.8	98.7	76.0
Table 2 shows that CLIP is able to capture the structural information of connectivity, bipartiteness,
triangle-freeness and circular skip links, while MPNN variants fail to identify these graph properties.
Furthermore, we observe that CLIP outperforms RP-GIN, that was shown to provide very expressive
representations for regular graphs (Murphy et al., 2019), even with a high number of permutations
(the equivalent of colors in their method is set to k = 16). Moreover, both for k-RP-GIN and k-CLIP,
the increase of permutations and colorings respectively lead to higher accuracies. In particular, CLIP
can capture almost perfectly the different graph properties with as little as k = 16 colorings.
7 Conclusion
In this paper, we showed that a simple coloring scheme can improve the expressive power of
MPNNs. Using such a coloring scheme, we extended MPNNs to create CLIP, the first universal
graph representation. Universality was proven using the novel concept of separable neural networks,
and our experiments showed that CLIP is state-of-the-art on both graph classification datasets and
property testing tasks. The coloring scheme is especially well suited to hard classification tasks that
require complex structural information to learn. The framework is general and simple enough to
extend to other data structures such as directed, weighted or labeled graphs. Future work includes
more detailed and quantitative approximation results depending on the parameters of the architecture
such as the number of colors k, or number of hops of the iterative neighborhood aggregation.
8
Under review as a conference paper at ICLR 2020
References
Atwood, J. and Towsley, D. (2016). Diffusion-convolutional neural networks. In Advances in Neural
Information Processing Systems.
Babai, L. (2016). Graph isomorphism in quasipolynomial time. In Proceedings of the forty-eighth
annual ACM symposium on Theory ofComputing, pages 684-697. ACM.
Bartlett, P., Helmbold, D., and Long, P. (2018). Gradient descent with identity initialization efficiently
learns positive definite linear transformations. In International Conference on Machine Learning,
pages 520-529.
Baum, E. B. and Haussler, D. (1989). What size net gives valid generalization? In Advances in
neural information processing systems, pages 81-90.
Bengio, Y., Courville, A., and Vincent, P. (2013). Representation learning: A review and new
perspectives. IEEE transactions on pattern analysis and machine intelligence, 35(8):1798-1828.
Bodlaender, H. L. (1990). Polynomial algorithms for graph isomorphism and chromatic index on
partial k-trees. Journal of Algorithms, 11(4):631-643.
Bourbaki, N. (1998). General Topology: Chapters 1-4. Number vol. 4 in Addison-Wesley series in
mathematics. Springer.
Bruna, J., Zaremba, W., Szlam, A., and Lecun, Y. (2014). Spectral networks and locally connected
networks on graphs. ICLR.
Chen, Z., Villar, S., Chen, L., and Bruna, J. (2019). On the equivalence between graph isomorphism
testing and function approximation with gnns. NeurIPS 2019, abs/1905.12560.
Cybenko, G. (1989). Approximation by superpositions of a sigmoidal function. Mathematics of
control, signals and systems, 2(4):303-314.
Defferrard, M., Bresson, X., and Vandergheynst, P. (2016). Convolutional neural networks on graphs
with fast localized spectral filtering. In Advances in Neural Information Processing Systems, pages
3844-3852.
Duvenaud, D. K., Maclaurin, D., Iparraguirre, J., Bombarell, R., Hirzel, T., Aspuru-Guzik, A., and
Adams, R. P. (2015). Convolutional networks on graphs for learning molecular fingerprints. In
Advances in neural information processing systems, pages 2224-2232.
Erdos, P. and R6nyi, A. (1959). On random graphs i. Publicationes Mathematicae Debrecen, 6:290.
Frasconi, P., Gori, M., and Sperduti, A. (1998). A general framework for adaptive processing of data
structures. IEEE transactions on Neural Networks, 9(5):768-786.
Geman, S., Bienenstock, E., and Doursat, R. (1992). Neural networks and the bias/variance dilemma.
Neural computation, 4(1):1-58.
Gilmer, J., Schoenholz, S. S., Riley, P. F., Vinyals, O., and Dahl, G. E. (2017). Neural message
passing for quantum chemistry. ICML.
Gori, M., Monfardini, G., and Scarselli, F. (2005). A new model for learning in graph domains. In
Neural Networks, 2005. IJCNN’05. Proceedings. 2005 IEEE International Joint Conference on,
volume 2, pages 729-734. IEEE.
Grover, A. and Leskovec, J. (2016). node2vec: Scalable feature learning for networks. In Proceedings
of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining,
pages 855-864. ACM.
Guttenberg, N., Virgo, N., Witkowski, O., Aoki, H., and Kanai, R. (2016). Permutation-equivariant
neural networks applied to dynamics prediction. arXiv preprint arXiv:1612.04530.
Hamilton, W., Ying, Z., and Leskovec, J. (2017). Inductive representation learning on large graphs.
In Advances in Neural Information Processing Systems, pages 1024-1034.
9
Under review as a conference paper at ICLR 2020
Henaff, M., Bruna, J., and LeCun, Y. (2015). Deep convolutional networks on graph-structured data.
arXiv preprint arXiv:1506.05163.
Hornik, K. (1991). Approximation capabilities of multilayer feedforward networks. Neural networks,
4(2):251-257.
Hornik, K., Stinchcombe, M., and White, H. (1989). Multilayer feedforward networks are universal
approximators. Neural networks, 2(5):359-366.
Ivanov, S. and Burnaev, E. (2018). Anonymous walk embeddings. ICML.
Kipf, T. N. and Welling, M. (2017). Semi-supervised classification with graph convolutional networks.
ICLR.
Kriege, N. M., Morris, C., Rey, A., and Sohler, C. (2018). A property testing framework for the
theoretical expressivity of graph kernels. In Proceedings of the Twenty-Seventh International Joint
Conference on Artificial Intelligence, IJCAI-18, pages 2348-2354. International Joint Conferences
on Artificial Intelligence Organization.
Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classification with deep convolu-
tional neural networks. In Advances in Neural Information Processing Systems, pages 1097-1105.
Lei, T., Jin, W., Barzilay, R., and Jaakkola, T. (2017). Deriving neural architectures from sequence
and graph kernels. ICML.
Luks, E. M. (1982). Isomorphism of graphs of bounded valence can be tested in polynomial time.
Journal of Computer and System Sciences, 25(1):42 - 65.
Maron, H., Ben-Hamu, H., Serviansky, H., and Lipman, Y. (2019a). Provably powerful graph
networks. NeurIPS.
Maron, H., Ben-Hamu, H., Shamir, N., and Lipman, Y. (2019b). Invariant and equivariant graph
networks. In International Conference on Learning Representations.
Maron, H., Fetaya, E., Segol, N., and Lipman, Y. (2019c). On the universality of invariant networks.
ICML 2019.
McKay, B. D. (1981). Practical graph isomorphism. Congressus Numerantium, 30:45-87.
Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A.,
Riedmiller, M., Fidjeland, A. K., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou,
I., King, H., Kumaran, D., Wierstra, D., Legg, S., and Hassabis, D. (2015). Human-level control
through deep reinforcement learning. Nature, 518(7540):529-533.
Murphy, R., Srinivasan, B., Rao, V., and Ribeiro, B. (2019). Relational pooling for graph represen-
tations. In Chaudhuri, K. and Salakhutdinov, R., editors, Proceedings of the 36th International
Conference on Machine Learning, volume 97 of Proceedings of Machine Learning Research, pages
4663-4673, Long Beach, California, USA. PMLR.
Niepert, M., Ahmed, M., and Kutzkov, K. (2016). Learning convolutional neural networks for graphs.
In International conference on machine learning.
Perozzi, B., Al-Rfou, R., and Skiena, S. (2014). Deepwalk: Online learning of social representations.
In Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and
data mining, pages 701-710. ACM.
Pinkus, A. (1999). Approximation theory of the mlp model in neural networks. Acta numerica,
8:143-195.
Qi, C. R., Su, H., Mo, K., and Guibas, L. J. (2017). Pointnet: Deep learning on point sets for 3d
classification and segmentation. CVPR.
Rudin, W. (1987). Real and Complex Analysis, 3rd Ed. McGraw-Hill, Inc., New York, NY, USA.
10
Under review as a conference paper at ICLR 2020
Saxe, A. M., McClelland, J. L., and Ganguli, S. (2014). Exact solutions to the nonlinear dynamics of
learning in deep linear neural networks. ICLR.
Scarselli, F., Gori, M., Tsoi, A. C., Hagenbuchner, M., and Monfardini, G. (2009). The graph neural
network model. IEEE Transactions on Neural Networks, 20(1):61-80.
Shervashidze, N., Schweitzer, P., Leeuwen, E. J. v., Mehlhorn, K., and Borgwardt, K. M. (2011).
Weisfeiler-lehman graph kernels. Journal of Machine Learning Research.
Sperduti, A. and Starita, A. (1997). Supervised neural networks for the classification of structures.
IEEE Transactions on Neural Networks, 8(3):714-735.
Szegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., and Wojna, Z. (2016). Rethinking the inception
architecture for computer vision. In Proceedings of the IEEE conference on computer vision and
pattern recognition, pages 2818-2826.
Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser,匕 and
Polosukhin, I. (2017). Attention is all you need. In Advances in Neural Information Processing
Systems, pages 5998-6008. Curran Associates, Inc.
Velickovic, P., Cucurull, G., Casanova, A., Romero, A., Lio, P., and Bengio, Y. (2018). Graph
attention networks. ICLR.
Verma, S. and Zhang, Z.-L. (2019). Graph capsule convolutional neural networks. ICLR.
Weisfeiler, B. and Lehman, A. (1968). A reduction of a graph to a canonical form and an algebra
arising during this reduction. Nauchno-Technicheskaya Informatsia, 2(9):12-16.
Xu, K., Hu, W., Leskovec, J., and Jegelka, S. (2019). How powerful are graph neural networks?
ICLR.
Ying, R., You, J., Morris, C., Ren, X., Hamilton, W. L., and Leskovec, J. (2018). Hierarchical graph
representation learning with differentiable pooling. In Advances in Neural Information Processing
Systems, pages 4805-4815.
Zaheer, M., Kottur, S., Ravanbakhsh, S., P6czos, B., Salakhutdinov, R., and Smola, A. J. (2017).
Deep sets. In Advances in Neural Information Processing Systems.
Zhang, M., Cui, Z., Neumann, M., and Chen, Y. (2018). An end-to-end deep learning architecture for
graph classification. In Proceedings of AAAI Conference on Artificial Inteligence.
11
Under review as a conference paper at ICLR 2020
A	Proofs of the universality of separable neural networks
Proof of Theorem 2. The proof relies on the Stone-Weierstrass theorem we recall below. We refer to
(Rudin, 1987, Theorem 7.32) for a detailed proof of the following classical theorem.
Theorem 5 (Stone-Weierstrass). Let A be an algebra of real functions on a compact Hausdorff set
K. If A separates points of K and contains a non-zero constant function, then A is uniformly dense
in C(K, R).
We verify that under the assumptions of Theorem 2 the Stone-Weierstrass theorem applies. In this
setting, we first prove the theorem for m = 1 and use induction for the general case.
Let K ⊂ X be a compact subset of X. We will denote
Ao = {ψ ◦ f : ∃d ≥ 1 s.t. ψ ∈C(Rd, R),f ∈ F},
and will proceed in two steps: we first show that A0 is uniformly dense in C(K, R), then that A is
dense in A0 , hence proving Theorem 2.
Lemma 1. A0 is a subalgebra of C(K, R).
Proof. The subset A0 contains zero and all constants. Let f, g ∈ A0 so that
f (X) = ψf ◦夕f(X),	g(X) = ψg ◦ Wg(X),
with ψf : Rdf → R and ψg : Rdg → R. Consider ψ : Rdf +dg → R such that ψ(a, b) =
ψf (a) + ψg (b). We define W(X) = (Wf (X), Wg (X)) ∈ Rdf +dg and by assumption W ∈ F. We have
(f+g)(X) = ψ(Wf(X),Wg(X))
= ψ ◦ W(X)
so that f+g ∈ A0 and we conclude that A0 is a vectorial subspace of C(K, R). We proceed similarly
for the product in order to finish the proof of the lemma.	□
Because F1 separates the points of X by assumption, A0 also separates the points of X . Indeed, let
X 6= y two distinct points of X so that ∃f ∈ F such that f(X) 6= f(y). There exists g ∈ C(Rd, R)
such that g(f(X)) 6= g(f (y)). From Theorem 5 we deduce that A0 is uniformly dense in C(K, R)
for all compact subsets K ⊂ X .
Finally we state that:
Lemma 2. For any compact subset K ⊂ X, A is uniformly dense in A0.
Proof. Let > 0 and h = ψ0 ◦ f ∈ A0 with f ∈ F and ψ0 ∈ C(Rd, R). Thanks to the continuity
of f, the image KK = f (K) is a compact of Rd. By Theorem 1 there exists an MLP ψ such that
∣∣ψ - ψokκκ ∞ ≤ e. We have ψ ◦ f ∈ A and ∣∣ψo ◦ f - ψ ◦ f kκ,∞ ≤ E which concludes the proof. □
This last lemma completes the proof in the case m = 1. For m ≥ 2 consider A0 = {ψ ◦ f : ∃d ≥
1 s.t. ψ ∈ C(Rd, Rm), f ∈ F} and proceed in a similar manner than Lemma 2 by decomposing
ψ ∈ C(Rd,Rm) as
/ ψι(X) ∖
ψ2 (X)
ψ(X)=	.	,
.
.
ψm(X)
and applying Lemma 1 for each coefficient function ψi ∈ C(Rd, R).	□
Proof of Proposition 1. Assume that there exists X, y ∈ X s.t. ∀f ∈ F1, f(X) = f(y). Then K =
{X, y} is a compact subset of X and let φ ∈ C(K, R) be such that φ(X) = 1 and φ(y) = 0. Thus, for
all f ∈ Fι, maxz∈{χ,y} ∣∣φ(z) 一 f (z)∣ ≥ 1/2 which contradicts universality (see Definition 1), □
12
Under review as a conference paper at ICLR 2020
B Group action on Hausdorff spaces
In what follows, X is always a topological set and G a group of transformations acting on X . The
orbits of X under the action of G are the sets Gx = {g ∙ X : g ∈ G}. Moreover, We denote as
X/G the quotient space of orbits, also defined by the equivalence relation: X 〜y y⇒ ∃g ∈ G
s.t. x = g ∙ y. As stated in Section 5, graphs with node attributes can be defined using invariance by
permutation of the labels. We prove here that the resulting spaces are Hausdorff.
Definition 4 (Group invariance). Let G a group, a function f : X → Y is G-invariant if
∀x ∈X ,∀g ∈ G,f (X) = f(g ∙ x) .	(7)
Lemma 3 ((Bourbaki, 1998, I, §8.3)). Let X be a Hausdorff space and R an equivalence relation of
X. Then X/R is Hausdorff if and only if any two distinct equivalence classes in X are contained in
disjoints saturated open subsets of X.
Thanks to this lemma we prove the following proposition.
Proposition 2. Let G a finite group acting on an Hausdorff space X, then the orbit space X/G is
Hausdorff.
Proof. Let Gx and Gy two distinct classes with disjoint open neighbourhood U and V . By finiteness
of G, the application π : X → X/G is open, hence the saturated sets U = π-1 [π(U)] and
V = π-1 [π(V )] are open. Suppose that there exists z ∈ U ∩ V , then π(z) ∈ π(U) ∩ π(V ) and we
finally get that Gz ⊂ U ∩ V = 0. Therefore U ∩ VIS empty and X/G IS Hausdorff by Lemma 3. □
Proposition 2 directly implies that the spaces Graphm and Neighborhoodm are Hausdorff.
C Universality of the node aggregation scheme
We now provide more details on the aggregation and combination scheme of CLIP, and show that a
simple application of Corollary 1 is sufficient to prove its universality for node neighborhoods. Each
local aggregation step takes as input a couple (xi, {xj}j∈Ni) where xi ∈ Rm is the representation of
node i, and {xj}j∈Ni is the set of vector representations of the neighbors of node i. In the following,
we show how to use Corollary 1 to design universal representations for node neighborhoods.
Definition 5. The set of node neighborhoods for m-dimensional node attributes is defined as
Neighborhoodm = Rm ×	[	(Rn×m∕Pn ) ,	(8)
n≤nmax
where the set of permutation matrices Pn is acting on Rn×m by P ∙ V = Pv.
The main difficulty to design universal neighborhood representations is that the node neighborhoods
of Definition 5 are permutation invariant w.r.t. neighboring node attributes, and hence require
permutation invariant representations. The graph neural network literature already contains several
deep learning architectures for permutation invariant sets (Guttenberg et al., 2016; Qi et al., 2017;
Zaheer et al., 2017; Xu et al., 2019), among which PointNet and DeepSet have the notable advantage
of being provably universal for sets. Following Corollary 1, we compose a separable permutation
invariant network with an MLP that will aggregate both information from the node itself and its
neighborhood. While our final architecture is similar to Deepset (Zaheer et al., 2017), this section
emphasizes that the general universality theorems of Section 3 are easily applicable in many settings
including permutation invariant networks. The permutation invariant set representation used for the
aggregation step of CLIP is as follows:
NODEAGGREGATION(x, S) = ψ x,	o(y) ,	(9)
y∈S
where ψ and 夕 are MLPs with continuous non-polynomial activation functions and ψ(x, y) denotes
the result of the MLP ψ applied to the concatenation of x and y.
13
Under review as a conference paper at ICLR 2020
Theorem 6. The set representation described in Eq. (9) is a universal representation of
Neighborhoodm.
Proof. By construction, NODEAGGREGATION is a continuous and concatenable representation.
Moreover, its final stage is an MLP, and we thus only have to prove separability in order to use
Corollary 1 and prove universality. Let (x1, S1), (x2, S2) ∈ Neighborhoodm and suppose that
(x1, S1) 6= (x2, S2). First, if x1 6= x2, the final MLP ψ can separate x1 and x2. Otherwise, S1 6= S2,
and let Us assume that S1 \ S2 = 0 (otherwise S2 \ S1 = 0 and the argument is identical). Since
MLPS are universal representations of Rm, there exists an MLP 夕 such that, ∀s ∈ S1 ∪ S2,
中(S) ≥ 1 if S ∈ S1 \ S2 ,
3(s)∣ ≤ ε otherwise,
Taking ψ(x, y) = y and ε = 1/3 max{|S1 |, |S2 |}, we have
NODEAGGREGATION(x1, S1) ≥ 2/3 ,
NODEAGGREGATION(x2, S2) ≤ 1/3 ,
which proves separability and, using Corollary 1, the universality of the representation.	口
D	Proof of the universality of CLIP
Proof of Theorem 3. First of all, as the activation functions of the MLPs are continuous, CLIP is
made of continuous and concatenable functions, and is thus also continuous and concatenable.
Second, as the node aggregation step (denoted NodeAggregation below) is a universal set
representation (see Appendix C), it is capable of approximating any continuous function. We will
thus first replace this function by a continuous function φ, and then show that the result still holds
for NODEAGGREGATION(1) by a simple density argument. Let G1 = (v1, A1) and G2 = (v2, A2)
be two distinct graphs of respective sizes n1 and n2 (up to a permutation). If n1 6= n2 , then
ψ(x) = x and φ(x) = 1 returns the number of nodes, and hence xG1 = n1 6= n2 = xG2. Otherwise,
let V = {vik}i∈J1,n1K,k∈{1,2} be the set of node attributes of G1 and G2, c1 be a coloring of G1,
ψ(x) = x and φ be a continuous function such that, ∀x ∈ V and S ⊂ V ,
n1
φ(x,s) = X 1{x = (vi1,c1)} Y1 {Aj = 1{(vj,c1) ∈ S}}.	(IO)
i=1	j 6=i
The existence of φ ∈ C(Rm, R) is assured by Urysohn’s lemma (see e.g. (Rudin, 1987, lemma 2.12)).
Then, xG counts the number of matching neighborhoods for the best coloring, and we have xG1 = n1
and xG2 ≤ n1 - 1. Finally, taking ε < 1/2n1 in the definition of universal representation leads
to the desired result, as then, using an ε-approximation of φ as NODEAGGREGATION(1), we have
Xgi > n1 — 1/2 > xg2 .	口
Proof of Theorem 4. Consider a continuous function ψ : Graphm → Rd and a compact K0 ⊂
Graphm. Let extend K0 with K = K0 × [0, 1]nmax and we define φ : Graphm+n → Rd with
φ((v, c), A) = ψ(v, A) for all c ∈ C(v, A). Since ∞-CLIP is universal there exists f ∈ ∞-CLIP
such that, for all ((v, c), A) ∈ K,
kφ((v, c), A) — f ((v, c), A)k ≤ε,	(11)
hence
kψ(v, A) — f ((v, c), A)k ≤ε.	(12)
Moreover, observe that for any coloring c ∈ C(v, A), ∞-CLIP and 1-CLIP applied to ((v, c), A)
returns the same result, as all node attributes are dissimilar (by definition of the colorings) and
C((v, c), A) = 0. Finally, 1-CLIP applied to (v, A) is equivalent to applying 1-CLIP to ((v, C), A)
where C is a random coloring in C(v, A), and Eq. (12) thus implies that any random sample of
1-CLIP is within an ε error of the target function ψ. As a result, its expectation is also within an ε
error of the target function ψ, which proves the universality of the expectation of I-CLIP.	口
14
Under review as a conference paper at ICLR 2020
E Experimental details
E.1 Real-world datasets
Table 3	summarizes the characteristics of all benchmark graph classification datasets used in Sec-
tion 6.1. We now provide complementary information on these datasets.
Social Network Datasets (IMDBb, IMDBm): These datasets refer to collaborations between
actors/actresses, where each graph is an ego-graph of every actor and the edges occur when the
connected nodes/actors are playing in the same movie. The task is to classify the genre of the
movie that the graph derives from. IMDBb is a single-class classification dataset, while IMDBm is
multi-class. For both social network datasets, we used one-hot encodings of node degrees as node
attribute vectors.
Bio-informatics Datasets (MUTAG, PROTEINS, PTC): MUTAG consists of mutagenic aromatic
and heteroaromatic nitrocompounds with 7 discrete labels. PROTEINS consists of nodes, which
correspond to secondary structureelements and the edges occur when the connected nodes are
neighbors in the amino-acidsequence or in 3D space. It has 3 discrete labels. PTC consists of
chemical compounds that reports the carcinogenicity for male and female rats and it has 19 discrete
labels. For all bio-informatics datasets we used the node labels as node attribute vectors.
Experimentation protocol: We follow the same experimental protocol as described in Xu et al.
(2019), and thus report the results provided in this paper corresponding to the accuracy of our six
baselines in Table 1. We optimized the CLIP hyperparameters by grid search according to 10-fold
cross-validated accuracy means. We use 2-layer MLPs, an initial learning rate of 0.001 and decreased
the learning rate by 0.5 every 50 epochs for all possible settings. For all datasets the hyperparameters
we tested are: the number of hidden units within {32, 64}, the number of colorings c ∈ {1, 2, 4, 8},
the number of MPNN layers within {1, 3, 5}, the batch size within {32, 64}, and the number of
epochs, that means, we select a single epoch with the best cross-validation accuracy averaged over
the 10 folds. Note that standard deviations are fairly high for all models due to the small size of these
classic datasets.
Table 3: Characteristics of the benchmark graph classification datasets used in Section 6.1.
Dataset	PTC	IMDBb	IMDBm	PROTEINS	MUTAG
# graphs	344	1000	1500	1113	188
# classes	2	2	3	2	2
Avg # nodes	14.29	19.77	13.00	39.06	17.93
Avg degree	2.05	9.76	10.14	3.72	2.21
E.1.1 CLIP PERFORMANCES W.R.T. THE NUMBER OF COLORINGS k
Table 4	summarizes the performances of CLIP while increasing the number of colorings k. Overall
we can see a small increase in performances and a reduction of the variances when k is increasing.
Nevertheless we should not jump to any conclusions since none of the models are statistically
significantly better than the others.
Table 4: Ablation study: classification accuracies of k-CLIP on benchmark datasets w.r.t k.
Dataset	PTC	IMDBb	IMDBm	PROTEINS	MUTAG
0-CLIP	65.9±4.0	75.4±2.0	52.5±2.6	77.0±3.2	90.0±5.1
1-CLIP	65.3±12.8	75.2±3.9	52.2±4.0	75.1±4.5	91.1±7.0
4-CLIP	65.9±5.7	75.8±5.0	51.8±2.9	77.1±4.4	92.2±7.0
8-CLIP	67.9±7.1	75.7±3.8	52.5±3.0	76.8±4.8	93.9±4.1
16-CLIP	66.5±5.4	76.0±2.7	52.5±4.5	76.6±2.8	91.7±6.0
We note that on the IMDBb and PROTEINS datasets the difference between using or not a coloring
scheme does not have a big impact on the performances. However, adding colors increases the
15
Under review as a conference paper at ICLR 2020
performances of the algorithm on three out of five real world datasets. The property testing section
(Section 6.2) shows empirically that the color scheme improves the expressiveness of CLIP.
E.2 Graph property testing
In Section 6.2 we evaluate the expressive power of CLIP on benchmark synthetic datasets. Our goal
is to show that CLIP is able to distinguish basic graph properties, where classical MPNN cannot. We
considered a binary classification task and we constructed balanced synthetic datasets2 for each of
the examined graph properties. The 20-node graphs are generated using ErdOs-Renyi model (Erdos
and Renyi, 1959) (and its bipartite version for the bipartiteness) with different probabilities P for edge
creation. All nodes share the same (scalar) attribute. We thus have uninformative feature vectors.
In particular, we generated datasets for different classical tasks Kriege et al. (2018): 1) connectivity,
2) bipartiteness, 3) triangle-freeness, and 4) circular skip links (Murphy et al., 2019). In the following,
we present the generating protocol of the synthetic datasets and the experimentation setup we used
for the experiments.
Synthetic datasets:
In every case of synthetic dataset we follow the same pattern: we generate a set of random graphs
using Erdos-Renyi model, which contain a specific graph property and belong to the same class and
by proper edge addition we remove this property, thus creating the second class of graphs. By this
way, we assure that we do not change different structural characteristics other than the examined
graph property.
-	Connectivity dataset: this dataset consists of 1000 (20-node) graphs with 500 positive samples
and 500 negative ones. The positive samples correspond to disconnected graphs with two 10-node
connected components selected among randomly generated graphs with an Erdos-Renyi model
probability ofp = 0.5. We constructed negative samples by adding to positive samples a random
edge between the two connected components.
-	Bipartiteness dataset: this dataset consists of 1000 (20-node) graphs with 500 positive samples
and 500 negative ones. The positive samples correspond to bipartite graphs generated with an
Erdos-Renyi (bipartite) model probability of p = 0.5. For the negative samples (non-bipartite
graphs) we chose the positive samples and for each of them we added an edge between randomly
selected nodes from the same partition, in order to form odd cycles 3.
-	Triangle-freeness dataset: this dataset consists of 1000 (20-node) graphs with 500 positive
samples and 500 negative ones. The positive samples correspond to triangle-free graphs selected
among randomly generated graphs with an Erdos-Renyi model probability of p = 0.1. We
constructed negative samples by randomly adding new edges to positive samples until it creates at
least one triangle.
-	Circular skip links: this dataset consists of 150 graphs of 41 nodes as described in (Murphy et al.,
2019; Chen et al., 2019). The Circular Skip Links graphs are undirected regular graphs with node
degree 4. We denote a Circular skip link graph by Gn,k an undirected graph of n nodes, where
(i, j) ∈ E holds if and only if |i - j | ≡ 1 or k( mod n) This is a 10-class multiclass classification
task whose objective is to classify each graph according to its isomorphism class.
Experimentation protocol: We evaluate the different configurations of CLIP and its competitors
GIN and RP-GIN based on their hyper-parameters. For the architecture implementation of the GIN,
we followed the best performing architecture, presented in Xu et al. (2019). In particular, we used
the summation as the aggregation operator, MLPs as the combination level for the node embedding
generation and the sum operator for the readout function along with its refined version of concatenated
graph representations across all iterations/layers of GIN, as described in Xu et al. (2019).
In all the tested configurations for CLIP and its competitors (GIN, RP-GIN) we fixed the number of
layers of the MLPs and the learning rate: we chose 2-layer MLPs and we used the Adam optimizer
with initial learning rate of 0.001 along with a scheduler decaying the learning rate by 0.5 every 50
epochs. Concerning the other hyper-parameters, we optimized: the number of hidden units within
{16, 32, 64} (except for the CSL task where we only use 16 hidden units to be fair w.r.t. RP-GIN
2The datasets are available upon request.
3Having an odd cycle in a graph makes the graph non bipartite.
16
Under review as a conference paper at ICLR 2020
and Ring-GNN benchmarks), the number of MPNN layers within {1, 2, 3, 5}, the batch size within
{32, 64}, and ran the model over 400 epochs. Regarding the RP-GIN architecture (Murphy et al.,
2019) we optimized the one-hot encoding dimension of the first update within {5, 10, 15, 20, 25, 30}
and the number of inference permutations within {1, 5, 16}. Regarding the CLIP algorithm, we
optimized the number of colorings c ∈ {1, 2, 4, 8, 16}. We then performed a 10-fold cross validation
with early stopping for the hyper-parameter optimization and we reported the best 10-fold cross-
validated mean accuracy with its associated standard deviation.
17