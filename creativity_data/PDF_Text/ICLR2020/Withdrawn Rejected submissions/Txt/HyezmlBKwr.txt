Under review as a conference paper at ICLR 2020
Test-Time Training for
Generalization under Distribution Shifts
Anonymous authors
Paper under double-blind review
Ab stract
We introduce a general approach, called test-time training, for improving the per-
formance of predictive models when training and test data come from different
distributions. Test-time training turns a single unlabeled test instance into a self-
supervised learning problem, on which we update the model parameters before
making a prediction on this instance. We show that this simple idea leads to sur-
prising improvements on diverse image classification benchmarks aimed at eval-
uating robustness to distribution shifts. Theoretical investigations on a convex
model reveal helpful intuitions for when we can expect our approach to help.
1	Introduction
Supervised learning remains notoriously weak at generalization under distribution shifts. Unless
training and test data are drawn from the same distribution, even seemingly minor differences turn
out to defeat state-of-the-art models. Transfer learning, domain adaptation and adversarial robust-
ness are but a few existing paradigms that anticipate differences of sorts between the training and
test distribution. In this work, we explore a new take on generalization, without any mathematical
structure or data available at training-time to anticipate the distribution shifts.
We start from a simple observation. The unlabeled test instance x presented at test-time gives us
a hint about the distribution from which it was drawn. Our approach, called test-time training,
allows the model parameters θ to depend on the test instance x, but not its unknown label y . This
variable decision boundary θ(x) is powerful in theory (see Appendix A), and raises new challenges
in practice that we only begin to address here.
Our algorithm creates a self-supervised learning problem based on this single test instance x, updat-
ing θ at test-time before making a prediction. Self-supervised learning uses an auxiliary task that
automatically creates labels from unlabeled inputs. For the visual data we work with, the task rotates
an image x by a multiple of 90 degrees, and assigns the angle as the label (Gidaris et al., 2018).
Our approach can also be easily modified to work outside the standard supervised learning setting.
If several test instances arrive in a batch, we can use the entire batch for test-time training. If test
instances arrive online sequentially, we obtain further improvements by keeping the state of the
parameters. After all, prediction is rarely a single event. The online setting can be the natural mode
of deployment in practice, and shows the strongest improvements.
We experiment with test-time training for generalization under distribution shifts in the context of
object recognition on several benchmarks. These include images with diverse types of corruption
at various levels (Hendrycks & Dietterich, 2019), video frames of moving objects (Shankar et al.,
2019), and a new test set of unknown shifts collected by Recht et al. (2018). Our algorithm does not
hurt on the original distribution, but makes substantial improvements under distribution shifts.
In all our experiments, we compare with a strong baseline (labeled joint training) that uses both
supervised and self-supervised learning at training-time, but keeps the model fixed at test-time. Very
recent work shows that additional training-time self-supervision improves robustness Hendrycks
et al. (2019b). The joint training baseline we use corresponds to an improved implementation of
their work. We are also inspired by Sun et al. (2019), which performs joint training with a self-
supervised task in the context of unsupervised domain adaptation, simultaneously on the source and
target domain. A comprehensive review of related work follows in section 5.
1
Under review as a conference paper at ICLR 2020
We complement the empirical results with theoretical investigations in section 4, of when test-time
training is expected to help on a convex model, and establish an intuitive sufficient condition, which,
roughly speaking, is to have correlated gradients between the loss functions of the two tasks.
2	Method
Next we describe the algorithmic details of our method. To setup notations, consider a standard K-
layer neural network with parameters θk for layer k. The stacked parameter vector θ = (θ1, . . . , θK)
specifies the entire model for a classification task with loss function lm(x, y; θ) on the test instance
(x, y). We call this the main task, as indicated by the subscript of the loss function.
We assume to have training data (x1, y1), . . . , (xn, yn) drawn i.i.d. from a distribution P. Standard
empirical risk minimization corresponds to solving the optimization problem:
1n
mm — > Im(Xi, yi； θ).	(1)
θn
i=1
Our method requires a self-supervised auxiliary task with loss function ls (x). In this paper, we
choose the rotation prediction task (Gidaris et al., 2018), which has been demonstrated to be simple
and effective at feature learning for neural networks. The task simply rotates x on the image plane
by one of 0, 90, 180 and 270 degrees and have the model predict the angle of rotation as a four-way
classification problem. Other self-supervised tasks in section 5 might also be used for our method.
The auxiliary task shares some of the model parameters θe = (θ1, . . . , θκ) up to a certain κ ∈
{1, . . . , K}. We think of those κ layers as a shared feature extractor. The auxiliary task uses its
own task-specific parameters θs = (θκ0 +1, . . . , θK0 ). We call the unshared parameters θs the self-
supervised task branch, and θm = (θκ+1, . . . , θK) the main task branch. Pictorially, the joint
architecture is a Y -structure with a shared bottom and two branches. For our experiments, the self-
supervised task branch has the exact same architecture as the main branch, except for the output
dimensionality of the last layer due to the different number of classes in the two tasks.
Training is done in the fashion of multi-task learning (Caruana, 1997); the model is trained on both
tasks on the same data drawn from P . Losses for both tasks are added together, and gradients are
taken for the collection of all parameters. The joint training problem is therefore
1n
min —〉: Im (Xi, yi ； θm, θe) + ls (Xi ； θs, θe) *	(^2)
θe,θm,θs n
i=1
Now we describe the standard version of test-time training on a single test instance X. Simply put,
test-time training finetunes the shared feature extractor θe by minimizing the auxiliary task loss on
X. This can be formulated as
min ls(X; θs, θe)*	(3)
θe
Denote θ* the (approximate) minimizer ofEquation 3. The model then makes a prediction using the
updated parameters θ(χ) = (θ*, θm,). Empirically, the difference is negligible between minimizing
Equation 3 over θe versus over both θe and θs . Theoretically, there exists a difference only when
optimization is done with more than one step of gradient descent.
In the standard version of our method, the optimization problem in Equation 3 is always initialized
with parameters θ = (θe, θs) obtained by minimizing Equation 2 on data from P. After making
a prediction on x, θ* is discarded. Outside of the standard supervised learning setting, when the
test instances arrive online sequentially, the online version of test-time training solves the same
optimization problem as in Equation 3 to update the shared feature extractor θe . However, on test
instance Xt, θ is instead initialized with θ(Xt-1) updated on the previous instance Xt-1. This allows
θ(Xt) to take advantage of the distributional information available in X1, * * * , Xt-1 as well as Xt.
Test-time training naturally benefits from standard data augmentation techniques. On each test in-
stance X, we perform the exact same set of random transformations as used for data augmentation
during training to form a batch only containing these augmented copies of X for test-time training.
2
Under review as a conference paper at ICLR 2020
Figure 1: Test error (%) on CIFAR-10-C, level 5. See subsection 3.1 for details.
3	Empirical Results
We experiment with both versions of our method (standard and online) on three kinds of benchmarks
for distribution shifts, presented here in the order of visually low to high-level, which is roughly also
the order of easy to hard. Our code will be released once the paper is accepted.
Network details. Our architecture and hyper-parameters are consistent across all experiments. We
use Residual Networks (ResNets) (He et al., 2016b), which are constructed differently for CIFAR-
10 1 (26-layer) and ImageNet 2 (18-layer). ResNets on ImageNet have four groups, each containing
convolutional layers with the same number of channels and size of feature maps; our splitting point
is the end of the third group. ResNets on CIFAR-10 have three groups; our splitting point is the end
of the second group. In addition, Batch Normalization (BN), a popular module in deep networks, is
ineffective when training on small batches, for which the estimated batch statistics are less accurate
(Ioffe & Szegedy, 2015). This technicality hurts test-time training since each batch only contains
(augmented) copies of a single image. Therefore our networks instead use Group Normalization
(GN) (Wu & He, 2018), which achieves similar performance as BN on large batches without hurting
on small ones. Results with BN are shown in Appendix E for completeness.
Optimization details. For Equation 2, optimization hyper-parameters are set to the default 3 in
standard practice (Huang et al., 2016; He et al., 2016a). For Equation 3, we use stochastic gradient
descent (SGD) with the learning rate set to that of the last epoch during training, which is 0.001 in
all our experiments. Following standard practice (He et al., 2018; Liu et al., 2018) known to improve
performance when finetuning, we do not use weight decay or momentum. For the standard version,
we take ten gradient steps, using batches independently generated by the same image. For online
we take only one step. The computational aspects of our method are discussed in Appendix C.
Following standard practice, the transformations used for data augmentation are random crop with
padding and random horizontal flip for CIFAR-10 (Guo et al., 2017a; Huang et al., 2016), and
random resized crop and random horizontal flip for ImageNet (Ioffe & Szegedy, 2015; He et al.,
2016a). Specifically, these transformations do not contain information about the distribution shifts.
In all the tables and figures, baseline refers to the plain ResNet model (using GN, unless otherwise
specified); joint training refers to the model jointly trained on both the main task and the self-
supervised task, fixed at test-time as in Hendrycks et al. (2019b); test-time training refers to the
standard version described section 2; and test-time training online refers to the online version that
does not discard θ(xt) for xt arriving sequentially from the same distribution. Performance for
test-time training online is calculated, just like the others, as the average over the entire test set; we
always shuffle the test set before test-time training online to avoid ordering artifacts.
1CIFAR-10 (Krizhevsky & Hinton, 2009) is a standard object recognition dataset with 10 classes of objects
in natural scenes. The standard train / test split has 50,000 / 10,000 images, each of size 32-by-32 pixels.
2The ImageNet 2012 classification dataset (Russakovsky et al., 2015) for object recognition has images
from 1, 000 classes, 1.2 million for training and 50,000 for validation. Following standard practice (He et al.,
2016a;b; Huang et al., 2016), the validation set is used as the test set.
3Namely, we use stochastic gradient descent (SGD) with weight decay and momentum; learning rate starts
at 0.1 and is dropped by a factor of ten at two scheduled milestones, to 0.01 and 0.001.
3
Under review as a conference paper at ICLR 2020
Number of samples
Numberof samples
Number Ofsamples
Figure 2: Test accuracy (%) on ImageNet-C, level 5. The lower panel shows the accuracy of the online
version as the average over a sliding window of 100 samples; test-time learning online generalizes better as
more samples are tested on, without hurting on the original distribution. We use accuracy instead of error here
because the baseline performance is very poor with most corruptions. See subsection 3.1 for details.
3.1	Common Corruptions
Hendrycks & Dietterich (2019) propose to benchmark robustness of neural networks on 15 types of
corruptions from four broad categories: noise, blur, weather and digital. Each corruption type comes
in five levels of severity, with level 5 the most severe (details and sample images in Appendix D).
The corruptions are algorithmically simulated to mimic real-world corruptions as much as possible
on copies of the test set for both CIFAR-10 and ImageNet. According to the authors, training should
be done on the original training set, and the diversity of corruption types should make it difficult for
any method to work well across the board if it relies too much on corruption specific knowledge.
CIFAR-10-C. Our results on the level 5 corruptions (most severe) are shown in Figure 9. Due
to space constraints, our results on levels 1-4 are shown in Appendix E. Across all five levels and
15 corruption types, both versions of test-time training always improve over the baseline by a large
margin. The standard version of test-time training always improves over joint training, and the
online version often improves very significantly (>10%) over joint training and never hurts by more
than 0.2%. Specifically, test-time training online contributes >24% on the three noise types and
38% on pixelation. For the seemingly unstable setup of a learning problem that abuses a single
image, this kind of consistency is rather surprising.
The baseline ResNet-26 has error 8.9% on the original test set of CIFAR-10. The joint training
baseline actually improves performance on the original to 8.1%. Most surprisingly, unlike many
other methods that tradeoff original performance with robustness, test-time training further improves
on the original test set by 0.2% consistently over many independent trials. This indicates that our
method does not choose between specificity and generality.
Separate from our method, it is interesting to note that joint training consistently improves over
the baseline, as discovered by Hendrycks et al. (2019b). Hendrycks & Dietterich (2019) have also
experimented with various other training methods on this benchmark, and point to Adversarial Logit
Pairing (ALP) (Kannan et al., 2018) as the most effective. Results of this additional baseline on
4
Under review as a conference paper at ICLR 2020
Accuracy (%)	I Airplane	Bird	Car	Dog	Cat	Horse	Ship I	Average
Baseline	I 67.9	35.8	42.6	14.7	52.0	42.0	66.7 I	41.4
Joint training	I 70.2	36.7	42.6	15.5	52.0	44.0	66.7 I	42.4
Test-time training	I 70.2	39.2	42.6	21.6	54.7	46.0	77.8 I	45.2
TTT online	I 70.2	39.2	42.6	22.4	54.7	46.0	77.8 I	45.4
Table 1: Test accuracy (%) on our video classification dataset, adapted from Shankar et al. (2019).
We report accuracy for each class and the average over all samples. See subsection 3.2 for details.
all levels of CIFAR-10-C are shown in Appendix E, along with its implementation details. While
surprisingly robust under some of the most severe corruptions (especially the three noise types), ALP
incurs a much larger error (by a factor of two) on the original distribution and some corruptions (e.g.
all levels of contrast and fog), and hurts performance significantly when the corruptions are not
as severe (especially on levels 1-3); this kind of tradeoff is to be expected for methods based on
adversarial training, but not test-time training.
ImageNet-C. Our results on the level 5 corruptions (most severe) are shown in Figure 2. We use
accuracy instead of error for this dataset because the baseline severely underperforms with most
corruptions. The general trend is roughly the same as on CIFAR-10-C. Test-time training (standard
version) always improves over the baseline and joint training, while the online version only hurts on
the original by 0.1% over the baseline, but dramatically improves (by a factor of more than three)
on many of the corruption types.
In the lower panel of Figure 2, we visualize how the accuracy (averaged over a sliding window) of
the online version changes as more images are tested on. Due to space constraints, we show this
plot on the original test set, as well as every third corruption type, following the same order as in the
original paper. On the original test set, there is no visible change in performance after updating on
the 50,000 samples. With corruptions, accuracy has already risen significantly after 10,000 samples,
but is still rising towards the end of the 50,000 samples, indicating room for additional improvements
if more samples were available. Without looking at a single label, test-time training online behaves
as if we were training on the test set from the appearance of these plots.
3.2	Video Classification
The ImageNet Video Classification (VID) dataset was de-
veloped by Shankar et al. (2019) from the Video Detection
dataset of ILSVRC2015 (Russakovsky et al., 2015), to
demonstrate how deep learning models for object recog-
nition trained on ImageNet (still images) fail to adapt well
to video frames 4. Without any modification for videos,
we apply our method to VID on top of the same ImageNet
model as in the previous subsection. Our results are shown
in Table 2. Again, we use accuracy instead of error be-
cause the baseline performance is poor.
Method	I Accuracy (%)
Baseline	I	62.7
Joint training	I	63.5
Test-time training	I	63.8
TTT online	I	64.3
Table 2: Test accuracy (%) on VID. See
subsection 3.2 for details.
In addition, we take the seven classes in VID that overlap with CIFAR-10, and rescale those video
frames to the size of CIFAR-10 images, as a new test set for the model trained on CIFAR-10 in
the previous subsection. Again, we apply our method to this dataset without any modification. Our
results are shown in Table 1, with a breakdown for each class. Noticing that test-time training does
not improve on the airplane class, we inspect some airplane samples, and observe that most of them
have black margins on the sides, which provide a trivial hint for the rotation prediction task. In
addition, for airplanes captued in the sky, it is often impossible even for humans to tell if an image
is rotated. This shows that our method requires the self-supervised task to be both well defined and
non-trivial on the new domain.
4 The VID dataset contains 1109 sets of video frames; each set forms a short video clip where all the frames
are similar to an anchor frame. Our results are reported on the anchor frames. To map the 1000 ImageNet
classes to the 30 VID classes, we use the max-conversion function in Shankar et al. (2019).
5
Under review as a conference paper at ICLR 2020
3.3	CIFAR-10.1: A New Test Set With Unknown Distribution Shifts
CIFAR-10.1 (Recht et al., 2018) is a new test set of size 2000 modeled after CIFAR-10, with the
exact same classes and image dimensionality, following the dataset creation process documented by
the original CIFAR-10 paper as closely as possible. The purpose is to investigate the distribution
shifts present between the two test sets, and the effect on object recognition. All models tested by
the authors suffer a large performance drop on CIFAR-10.1 comparing to CIFAR-10, even though
there is no human noticable difference, and both have the same human accuracy. This demonstrates
how insidious and ubiquitous distribution shifts are, even when researchers strive to minimize them.
The distribution shifts from CIFAR-10 to CIFAR-10.1 pose an
extremely difficult problem, and nobody has made a success-
ful attempt to improve the performance of an existing model
on this new test set, probably because 1) Researchers cannot
even identify the distribution shifts, let alone describe them
with mathematics. 2) The samples in CIFAR-10.1 are only
revealed at test-time; and even if revealed during training, the
distribution shifts are too subtle, and the sample size is too
small, for domain adaptation algorithms (Recht et al., 2018).
Method	I Error (%)
Baseline	I 17.4
Joint training	I 16.7
Test-time training	I 15.9
Table 3: Test error (%) on CIFAR-
10.1. See subsection 3.3 for details.
On the original CIFAR-10 test set, our baseline has error 8.9%, and with joint training 8.1%; com-
paring to the first two rows of Table 3, both suffer the typical performance drop (by a factor of two).
Test-time training yields an improvement of 0.8% (relative improvement of 4.8%) over joint train-
ing. We recognize that this improvement is still small comparing to the performance drop, but see it
as an encouraging first step for this very difficult problem.
4	Towards Understanding Test-time Training
This section contains our preliminary study of when and why test-time training is expected to work.
For convex models, we prove that positive gradient correlation between the loss functions leads to
better performance on the main task after test-time training. Equipped with this insight, we then
empirically demonstrate that gradient correlation governs the success of test-time training on the
deep learning model discussed in Section 3.
Before stating our main theoretical result, we first illustrate the general intuition with a toy model.
Consider a regression problem where x ∈ Rd denotes the input, y1 ∈ R denotes the label, and the
objective is the square loss (y - yι)2∕2 for a prediction y. Consider a two layer linear network
parametrized by A ∈ Rh×d and v ∈ Rh (where h stands for the hidden dimension). The prediction
according to this model is y = v> Ax, and the main task loss is
lm(χ,yι; A, V) = 1 (yι - v>Aχ)2.	(4)
In addition, consider a self-supervised regression task that also uses the square loss and automatically
generates a label ys for x. Let the self-supervised head be parameterized by w ∈ Rh . Then the self-
supervised task loss is
12
ls(x,y2; A, w) = 2 (y2 - w>Ax) .	(5)
Now we apply test-time training to update the shared feature extractor A by one step of gradient
descent on ls, which we can compute with y2 known. This gives us
A0 J A — η (y2 — w>Ax) (—wx>),	(6)
where A0 is the updated matrix and η is the learning rate. If we set η = η* where
*	yι - v>Ax
η =  -----γ----γ—^―,
(y2 - w>Ax) v>wx>x
(7)
then with some simple algebra, it is easy to see that the main task loss lm(x, y1; A0, v) = 0. Con-
cretely, test-time training drives the main task loss down to zero with a single gradient step for a
carefully chosen learning rate. In practice, this learning rate is unknown since it depends on the
unknown y∖. However, since our model is convex, as long as η* is positive, it suffices to set η to
6
Under review as a conference paper at ICLR 2020
Figure 3: Scatter plot of the inner product between the gradients (on the shared feature extractor θe) of the
main task lm and the self-supervised task le, and the improvement in test error (%) from test-time training, for
the standard (left) and online (right) version. Each point is the average over a test set, and each scatter plot has
75 test sets, from all 15 types of corruptions over five levels as described in subsection 3.1. The blue lines and
bands are the best linear fits and the 99% confidence intervals. The linear correlation coefficients are 0.93 and
0.89 respectively, indicating strong positive correlation between the two quantities, as suggested by Theorem 1.
be a small positive constant (See Lemma 1). If x = 0, one sufficient condition for η* to be positive
(when neither loss is zero) is to have
sign y1 - v>Ax = sign y2 - w>Ax and v>w > 0 .	(8)
For our toy model, both parts in Equation 8 have an intuition interpretation. The first part says that
the mistakes should be correlated, in the sense that predictions from both tasks are mistaken in the
same direction. The second part, v>w > 0, says that the decision boundaries on the feature space
should be correlated. In fact, these two parts hold iff hVlm(A), Vls(A)i > 0 (see Lemma 2). To
summarize, if the gradients have positive correlation, test-time training is guaranteed to reduce the
main task loss. Our main theoretical result extends this to general smooth and convex loss functions.
Theorem 1. Let lm(x, y; θ) denote the main task loss on test instance x, y with parameters θ, and
ls(x; θ) the self-supervised task loss that only depends on x 5. Assume that for all x, y, lm(x, y; θ)
is differentiable, convex and β-smooth in θ, and both kVlm(x, y; θ)k , kVls(x, θ)k ≤ G for all θ.
With a fixed learning rate η = ^^, for every x, y such that
hVlm(x, y; θ), Vls(x; θ)i >,	(9)
we have
lm(x, y; θ) > lm(x, y; θ(x)),	(10)
where θ(x) = θ - η Vls (x; θ) i.e. test-time training with one step of gradient descent.
The proof is in Appendix B.2. Theorem 1 reveals gradient correlation as a determining factor of
the success of test-time training in the smooth and convex case. In Figure 3, we empirically show
that our insight also holds for non-convex loss functions, on the deep learning model and across
the diverse set of corruptions considered in section 3; stronger gradient correlation clearly indicates
higher performance improvements over the baseline.
5	Related Work
Our work has been influenced by the successes and limitations of many related fields. Each of these
fields contains maybe hundreds of interesting works, which we unfortunately do not have enough
time and space to acknowledge in this draft. We apologize for the omissions and are happy to include
additional citations upon request.
Learning on test instances. Concurrent work Bau et al. (2019) improves photo manipulation with
a generative adversarial network, by adapting its image prior to the statistics of the input image.
Shocher et al. (2018) performs super-resolution on an image, by learning to recover the original
5Because the main task branch and the self-supervised branch are kept fixed at test-time, we do not explicitly
describe their parameters, and include them implicitly in the loss functions.
7
Under review as a conference paper at ICLR 2020
image itself from its downsampled version. An older work, Jain & Learned-Miller (2011) improves
Viola-Jones (Viola et al., 2001) for face detection, by bootstrapping the more difficult faces in an
image from the easier ones with high confidence in the same image. The online version of our
algorithm is inspired by Mullapudi et al. (2018), which makes video segmentation more efficient
by using a student model that learns online from a teacher model. The idea of online updates has
also been used in Kalal et al. (2011) for tracking and detection. Zhu et al. (2019), a concurrent
work in echocardiography, improves the deep learning model that tracks myocardial motion and
cardiac blood flow with sequential updates. Lastly, we share the philosophy of transductive learning
(Vapnik, 2013; Gammerman et al., 1998), but have little in common with their classical algorithms;
concurrent work Tripuraneni & Mackey (2019) theoretically explores this for linear prediction.
Adversarial robustness studies the robust risk: Rp,∆(θ) = Eχ,y〜P maxδ∈∆ l(x + δ, y; θ) where
l is some loss function, and ∆ is the set of perturbations; ∆ is often chosen as the Lp ball, for
p ∈ {1, 2, ∞}. Many popular algorithms formulate and solve this as a robust optimization problem
(Goodfellow et al., 2014; Madry et al., 2017; Sinha et al., 2017; Raghunathan et al., 2018; Wong
& Kolter, 2017; Croce et al., 2018), and the most well known technique is adversarial training.
Another line of work is based on randomized smoothing (Cohen et al., 2019; Salman et al., 2019),
while some other approaches such as input transformations (Guo et al., 2017b; Song et al., 2017) are
shown to be less effective (Athalye et al., 2018). There are two main problems in this field. First, all
the approaches mentioned above can be seen as smoothing the decision boundary. This establishes a
theoretical tradeoff between accuracy and robustness (Tsipras et al., 2018; Zhang et al., 2019), which
we also observe empirically with our adversarial training baseline in Section 3. Intuitively, the more
diverse ∆ is, the less effective this one-boundary-fits-all approach can be for a particular element of
∆. Second, adversarial methods rely heavily on the mathematical structure of ∆, which might not
accurately model perturbations in the real world. Therefore, generalization remains hard outside of
the ∆ we know in advance or can mathematically model, especially for non-adversarial distribution
shifts. Empirically, Kang et al. (2019) shows that robustness for one ∆ might not transfer to another,
and training on the L∞ ball actually hurts robustness on the L1 ball.
Non-adversarial robustness studies the effect of corruptions, perturbations, out-of-distribution
examples, and real-world distribution shifts (Hendrycks et al., 2019a;b; 2018; Hendrycks & Gimpel,
2016). Geirhos et al. (2018) show that training on images corrupted by Gaussian noise makes deep
learning models recover super-human performance on this particular noise type, but cannot improve
performance on another those corrupted by another noise type e.g. salt-and-pepper noise.
Unsupervised domain adaptation (a.k.a. transfer learning) studies the problem of distribution
shift (from P to Q), when unlabled data from Q is available at training-time (Tzeng et al., 2017;
Ganin et al., 2016; Gong et al., 2012; Long et al., 2016; Chen et al., 2018; 2011; Hoffman et al.,
2017; Csurka, 2017; Long et al., 2015). We are inspired by this very active and successful com-
munity, especially (Sun et al., 2019), and believe that progress in this community can motivate new
algorithms in the framework of test-time learning. Our update rule can be viewed as performing
one-sample unsupervised domain adaptation on the fly 6. On the other hand, test-time learning
comes from realizing the limitations of the unsupervised domain adaptation setting, that outside
of the specific target distribution where data is available for training, generalization is still elusive.
Previous works make the source and target distributions broader with multiple and evolving sources
and targets without fundamentally address this problem (Hoffman et al., 2018; 2012; 2014).
Self-supervised learning studies how to create labels from the data, by designing ingenious tasks
that contain semantic information without human annotations, such as context prediction (Doersch
et al., 2015), solving jigsaw puzzles (Noroozi & Favaro, 2016), colorization (Larsson et al., 2017;
Zhang et al., 2016), noise prediction (Bojanowski & Joulin, 2017), and feature clustering (Caron
et al., 2018). Self-supervision has also been used on videos (Wang & Gupta, 2015; Wang et al.,
2019). Particularly relevant to our work, Asano et al. (2019) shows that self-supervised learning on
only a single image, surprisingly, can produce low-level features that generalize well. In addition,
6 Note that typical unsupervised domain adaptation algorithms,such as those based on distributional discrep-
ancy, adversarial learning, co-training and generative modeling, might not work in our framework because the
concept of a target distribution, which has been so deeply rooted and heavily relied on, becomes ill-defined
when there is only one sample from the target domain.
8
Under review as a conference paper at ICLR 2020
Hendrycks et al. (2019b) proposes that jointly training a main task and a self-supervised task (our
joint training baseline in section 3) can improve robustness of the main task. The same idea is used
in few-shot learning (Su et al., 2019), and domain generalization (Carlucci et al., 2019).
Domain generalization studies when a meta distribution generates multiple environment distribu-
tions, some of which are available during training (source), while others are used for testing (target)
(Li et al., 2018; Shankar et al., 2018; Muandet et al., 2013; Balaji et al., 2018; Ghifary et al., 2015;
Motiian et al., 2017; Li et al., 2017a; Gan et al., 2016). With only a few environments, information
on the meta distribution is often too scarce to be helpful, and with many environments, we are back
to the i.i.d. setting where each environment can be seen as a sample, and a strong baseline is to sim-
ply train on all the environments (Li et al., 2019). The setting of domain generalization is limited
by the inherent tradeoff between specificity and generality of a fixed decision boundary, and the fact
that generalization is again elusive outside of the meta distribution i.e. the actual P .
Continual learning (a.k.a. learning without forgetting) studies when a model is made to learn a
sequence of tasks, and not forget about the task at the beginning (Li & Hoiem, 2017; Lopez-Paz &
Ranzato, 2017; Kirkpatrick et al., 2017; Santoro et al., 2016). Test-time training does not care about
forgetting the past test instances since they have already been evaluated on; and if a past instance
comes up by any chance, it would go through test-time training again. In addition, the impact of
forgetting the training set is minimal, because both tasks have been jointly trained. This is in contrast
to continual learning, when the tasks are trained one-by-one from scratch.
Few (one)-shot learning studies extremely small training sets (maybe for some categories) (Snell
et al., 2017; Vinyals et al., 2016; Fei-Fei et al., 2006; Ravi & Larochelle, 2016; Li et al., 2017b; Finn
et al., 2017; Gidaris & Komodakis, 2018). Our update rule can be viewed as performing one-shot
self-supervised learning and can potentially be improved by progress in few-shot learning.
Online learning (a.k.a. online optimization) is a well-studied area of learning theory (Shalev-
Shwartz et al., 2012; Hazan et al., 2016). The basic setting repeats the following: receive xt, predict
yt, receive yt from a worst-case oracle and learn. Final performance is evaluated using the regret,
colloquially how much worse than the best fixed model in hindsight. Itis easy to see how our setting
differs, even for the online version. We learn before predicting yt, but never receive any yt that is
evaluated on, thus do not need to consider the worst-case oracle or the regret.
6	Conclusion
The idea of test-time training also makes sense for other tasks such as segmentation and detection,
and in other fields such as speech recognition and natural language processing. More generally, we
hope this paper can encourage researchers to abandon the self-imposed constraint of a fixed decision
boundary at test-time, or even altogether, the artificial divison between training and testing.
References
Yuki M Asano, Christian Rupprecht, and Andrea Vedaldi. Surprising effectiveness of few-image
unsupervised feature learning. arXiv preprint arXiv:1904.13132, 2019.
Anish Athalye, Nicholas Carlini, and David Wagner. Obfuscated gradients give a false sense of
security: Circumventing defenses to adversarial examples. arXiv preprint arXiv:1802.00420,
2018.
Yogesh Balaji, Swami Sankaranarayanan, and Rama Chellappa. Metareg: Towards domain gener-
alization using meta-regularization. In Advances in Neural Information Processing Systems, pp.
998-1008,2018.
David Bau, Hendrik Strobelt, William Peebles, Jonas Wulff, Bolei Zhou, Jun-Yan Zhu, and Antonio
Torralba. Semantic photo manipulation with a generative image prior. ACM Transactions on
Graphics (TOG), 38(4):59, 2019.
9
Under review as a conference paper at ICLR 2020
Piotr Bojanowski and Armand Joulin. Unsupervised learning by predicting noise. In Proceedings
ofthe 34th International Conference on Machine Learning-Volume 70, pp. 517-526. JMLR. org,
2017.
Fabio M Carlucci, Antonio D’Innocente, Silvia Bucci, Barbara Caputo, and Tatiana Tommasi. Do-
main generalization by solving jigsaw puzzles. In Proceedings of the IEEE Conference on Com-
puter Vision and Pattern Recognition, pp. 2229-2238, 2019.
Mathilde Caron, Piotr Bojanowski, Armand Joulin, and Matthijs Douze. Deep clustering for unsu-
pervised learning of visual features. In Proceedings of the European Conference on Computer
Vision (ECCV), pp. 132-149, 2018.
Rich Caruana. Multitask learning. Machine learning, 28(1):41-75, 1997.
Minmin Chen, Kilian Q Weinberger, and John Blitzer. Co-training for domain adaptation. In Ad-
vances in neural information processing systems, pp. 2456-2464, 2011.
Xilun Chen, Yu Sun, Ben Athiwaratkun, Claire Cardie, and Kilian Weinberger. Adversarial deep
averaging networks for cross-lingual sentiment classification. Transactions of the Association for
Computational Linguistics, 6:557-570, 2018.
Jeremy M Cohen, Elan Rosenfeld, and J Zico Kolter. Certified adversarial robustness via randomized
smoothing. arXiv preprint arXiv:1902.02918, 2019.
Francesco Croce, Maksym Andriushchenko, and Matthias Hein. Provable robustness of relu net-
works via maximization of linear regions. arXiv preprint arXiv:1810.07481, 2018.
Gabriela Csurka. Domain adaptation for visual applications: A comprehensive survey. arXiv
preprint arXiv:1702.05374, 2017.
Gavin Weiguang Ding, Luyu Wang, and Xiaomeng Jin. AdverTorch v0.1: An adversarial robustness
toolbox based on pytorch. arXiv preprint arXiv:1902.07623, 2019.
Carl Doersch, Abhinav Gupta, and Alexei A Efros. Unsupervised visual representation learning by
context prediction. In Proceedings of the IEEE International Conference on Computer Vision, pp.
1422-1430, 2015.
Li Fei-Fei, Rob Fergus, and Pietro Perona. One-shot learning of object categories. IEEE transactions
on pattern analysis and machine intelligence, 28(4):594-611, 2006.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation
of deep networks. In Proceedings of the 34th International Conference on Machine Learning-
Volume 70, pp. 1126-1135. JMLR. org, 2017.
Alexander Gammerman, Volodya Vovk, and Vladimir Vapnik. Learning by transduction. In Pro-
ceedings of the Fourteenth conference on Uncertainty in artificial intelligence, pp. 148-155. Mor-
gan Kaufmann Publishers Inc., 1998.
Chuang Gan, Tianbao Yang, and Boqing Gong. Learning attributes equals multi-source domain gen-
eralization. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pp. 87-97, 2016.
Yaroslav Ganin, Evgeniya Ustinova, Hana Ajakan, Pascal Germain, Hugo Larochelle, Francois
Laviolette, Mario Marchand, and Victor Lempitsky. Domain-adversarial training of neural net-
works. The Journal of Machine Learning Research, 17(1):2096-2030, 2016.
Robert Geirhos, Carlos RM Temme, Jonas Rauber, Heiko H Schutt, Matthias Bethge, and Felix A
Wichmann. Generalisation in humans and deep neural networks. In Advances in Neural Informa-
tion Processing Systems, pp. 7538-7550, 2018.
Muhammad Ghifary, W Bastiaan Kleijn, Mengjie Zhang, and David Balduzzi. Domain generaliza-
tion for object recognition with multi-task autoencoders. In Proceedings ofthe IEEE international
conference on computer vision, pp. 2551-2559, 2015.
10
Under review as a conference paper at ICLR 2020
Spyros Gidaris and Nikos Komodakis. Dynamic few-shot visual learning without forgetting. In
Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 4367-
4375, 2018.
Spyros Gidaris, Praveer Singh, and Nikos Komodakis. Unsupervised representation learning by
predicting image rotations. arXiv preprint arXiv:1803.07728, 2018.
Boqing Gong, Yuan Shi, Fei Sha, and Kristen Grauman. Geodesic flow kernel for unsupervised
domain adaptation. In 2012 IEEE Conference on Computer Vision and Pattern Recognition, pp.
2066-2073. IEEE, 2012.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014.
Chuan Guo, Geoff Pleiss, Yu Sun, and Kilian Q Weinberger. On calibration of modern neural
networks. In Proceedings of the 34th International Conference on Machine Learning-Volume 70,
pp. 1321-1330. JMLR. org, 2017a.
Chuan Guo, Mayank Rana, Moustapha Cisse, and Laurens van der Maaten. Countering adversarial
images using input transformations. arXiv preprint arXiv:1711.00117, 2017b.
Elad Hazan et al. Introduction to online convex optimization. Foundations and Trends® in Opti-
mization, 2(3-4):157-325, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016a.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. In European conference on computer vision, pp. 630-645. Springer, 2016b.
Kaiming He, Ross Girshick, and Piotr Dollar. Rethinking imagenet pre-training. arXiv preprint
arXiv:1811.08883, 2018.
Dan Hendrycks and Thomas Dietterich. Benchmarking neural network robustness to common cor-
ruptions and perturbations. arXiv preprint arXiv:1903.12261, 2019.
Dan Hendrycks and Kevin Gimpel. A baseline for detecting misclassified and out-of-distribution
examples in neural networks. arXiv preprint arXiv:1610.02136, 2016.
Dan Hendrycks, Mantas Mazeika, Duncan Wilson, and Kevin Gimpel. Using trusted data to train
deep networks on labels corrupted by severe noise. In Advances in neural information processing
systems, pp. 10456-10465, 2018.
Dan Hendrycks, Mantas Mazeika, Saurav Kadavath, and Dawn Song. Improving model robustness
and uncertainty estimates with self-supervised learning. 2019a.
Dan Hendrycks, Mantas Mazeika, Saurav Kadavath, and Dawn Song. Using self-supervised learning
can improve model robustness and uncertainty. arXiv preprint arXiv:1906.12340, 2019b.
Judy Hoffman, Brian Kulis, Trevor Darrell, and Kate Saenko. Discovering latent domains for multi-
source domain adaptation. In European Conference on Computer Vision, pp. 702-715. Springer,
2012.
Judy Hoffman, Trevor Darrell, and Kate Saenko. Continuous manifold based adaptation for evolv-
ing visual domains. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 867-874, 2014.
Judy Hoffman, Eric Tzeng, Taesung Park, Jun-Yan Zhu, Phillip Isola, Kate Saenko, Alexei A Efros,
and Trevor Darrell. Cycada: Cycle-consistent adversarial domain adaptation. arXiv preprint
arXiv:1711.03213, 2017.
Judy Hoffman, Mehryar Mohri, and Ningshan Zhang. Algorithms and theory for multiple-source
adaptation. In Advances in Neural Information Processing Systems, pp. 8246-8256, 2018.
11
Under review as a conference paper at ICLR 2020
Gao Huang, Yu Sun, Zhuang Liu, Daniel Sedra, and Kilian Q Weinberger. Deep networks with
stochastic depth. In European conference on computer vision, pp. 646-661. Springer, 2016.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015.
Vidit Jain and Erik Learned-Miller. Online domain adaptation of a pre-trained cascade of classifiers.
In CVPR 2011, pp. 577-584. IEEE, 2011.
Zdenek Kalal, Krystian Mikolajczyk, and Jiri Matas. Tracking-learning-detection. IEEE transac-
tions on pattern analysis and machine intelligence, 34(7):1409-1422, 2011.
Daniel Kang, Yi Sun, Tom Brown, Dan Hendrycks, and Jacob Steinhardt. Transfer of adversarial
robustness between perturbation types. arXiv preprint arXiv:1905.01034, 2019.
Harini Kannan, Alexey Kurakin, and Ian Goodfellow. Adversarial logit pairing. arXiv preprint
arXiv:1803.06373, 2018.
James Kirkpatrick, Razvan Pascanu, Neil Rabinowitz, Joel Veness, Guillaume Desjardins, Andrei A
Rusu, Kieran Milan, John Quan, Tiago Ramalho, Agnieszka Grabska-Barwinska, et al. Overcom-
ing catastrophic forgetting in neural networks. Proceedings of the national academy of sciences,
114(13):3521-3526, 2017.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. Tech-
nical report, Citeseer, 2009.
Gustav Larsson, Michael Maire, and Gregory Shakhnarovich. Colorization as a proxy task for visual
understanding. In CVPR, 2017.
Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M Hospedales. Deeper, broader and artier domain
generalization. In Proceedings of the IEEE International Conference on Computer Vision, pp.
5542-5550, 2017a.
Da Li, Jianshu Zhang, Yongxin Yang, Cong Liu, Yi-Zhe Song, and Timothy M Hospedales. Episodic
training for domain generalization. arXiv preprint arXiv:1902.00113, 2019.
Ya Li, Xinmei Tian, Mingming Gong, Yajing Liu, Tongliang Liu, Kun Zhang, and Dacheng Tao.
Deep domain generalization via conditional invariant adversarial networks. In Proceedings of the
European Conference on Computer Vision (ECCV), pp. 624-639, 2018.
Zhenguo Li, Fengwei Zhou, Fei Chen, and Hang Li. Meta-sgd: Learning to learn quickly for few-
shot learning. arXiv preprint arXiv:1707.09835, 2017b.
Zhizhong Li and Derek Hoiem. Learning without forgetting. IEEE transactions on pattern analysis
and machine intelligence, 40(12):2935-2947, 2017.
Zhuang Liu, Mingjie Sun, Tinghui Zhou, Gao Huang, and Trevor Darrell. Rethinking the value of
network pruning. arXiv preprint arXiv:1810.05270, 2018.
Mingsheng Long, Yue Cao, Jianmin Wang, and Michael I Jordan. Learning transferable features
with deep adaptation networks. arXiv preprint arXiv:1502.02791, 2015.
Mingsheng Long, Han Zhu, Jianmin Wang, and Michael I Jordan. Unsupervised domain adaptation
with residual transfer networks. In Advances in Neural Information Processing Systems, pp. 136-
144, 2016.
David Lopez-Paz and Marc’Aurelio Ranzato. Gradient episodic memory for continual learning. In
Advances in Neural Information Processing Systems, pp. 6467-6476, 2017.
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu.
Towards deep learning models resistant to adversarial attacks. arXiv preprint arXiv:1706.06083,
2017.
12
Under review as a conference paper at ICLR 2020
Saeid Motiian, Marco Piccirilli, Donald A Adjeroh, and Gianfranco Doretto. Unified deep super-
vised domain adaptation and generalization. In Proceedings of the IEEE International Conference
on Computer Vision, pp. 5715-5725, 2017.
Krikamol Muandet, David Balduzzi, and Bernhard Scholkopf. Domain generalization via invariant
feature representation. In International Conference on Machine Learning, pp. 10-18, 2013.
Ravi Teja Mullapudi, Steven Chen, Keyi Zhang, Deva Ramanan, and Kayvon Fatahalian. Online
model distillation for efficient video inference. arXiv preprint arXiv:1812.02699, 2018.
Mehdi Noroozi and Paolo Favaro. Unsupervised learning of visual representations by solving jigsaw
puzzles. In European Conference on Computer Vision, pp. 69-84. Springer, 2016.
Aditi Raghunathan, Jacob Steinhardt, and Percy Liang. Certified defenses against adversarial exam-
ples. arXiv preprint arXiv:1801.09344, 2018.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. 2016.
Benjamin Recht, Rebecca Roelofs, Ludwig Schmidt, and Vaishaal Shankar. Do cifar-10 classifiers
generalize to cifar-10? arXiv preprint arXiv:1806.00451, 2018.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei.
ImageNet Large Scale Visual Recognition Challenge. International Journal of Computer Vision
(IJCV), 115(3):211-252, 2015. doi: 10.1007/s11263-015-0816-y.
Hadi Salman, Greg Yang, Jerry Li, Pengchuan Zhang, Huan Zhang, Ilya Razenshteyn, and Sebastien
Bubeck. Provably robust deep learning via adversarially trained smoothed classifiers. arXiv
preprint arXiv:1906.04584, 2019.
Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, and Timothy Lillicrap. Meta-
learning with memory-augmented neural networks. In International conference on machine learn-
ing, pp. 1842-1850, 2016.
Shai Shalev-Shwartz et al. Online learning and online convex optimization. Foundations and
Trends® in Machine Learning, 4(2):107-194, 2012.
Shiv Shankar, Vihari Piratla, Soumen Chakrabarti, Siddhartha Chaudhuri, Preethi Jyothi, and
Sunita Sarawagi. Generalizing across domains via cross-gradient training. arXiv preprint
arXiv:1804.10745, 2018.
Vaishaal Shankar, Achal Dave, Rebecca Roelofs, Deva Ramanan, Benjamin Recht, and Lud-
wig Schmidt. A systematic framework for natural perturbations from videos. arXiv preprint
arXiv:1906.02168, 2019.
Assaf Shocher, Nadav Cohen, and Michal Irani. zero-shot super-resolution using deep internal
learning. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pp. 3118-3126, 2018.
Aman Sinha, Hongseok Namkoong, and John Duchi. Certifying some distributional robustness with
principled adversarial training. arXiv preprint arXiv:1710.10571, 2017.
Jake Snell, Kevin Swersky, and Richard Zemel. Prototypical networks for few-shot learning. In
Advances in Neural Information Processing Systems, pp. 4077-4087, 2017.
Yang Song, Taesup Kim, Sebastian Nowozin, Stefano Ermon, and Nate Kushman. Pixeldefend:
Leveraging generative models to understand and defend against adversarial examples. arXiv
preprint arXiv:1710.10766, 2017.
Jong-Chyi Su, Subhransu Maji, and Bharath Hariharan. Boosting supervision with self-supervision
for few-shot learning. arXiv preprint arXiv:1906.07079, 2019.
Yu Sun, Eric Tzeng, Trevor Darrell, and Alexei A Efros. Unsupervised domain adaptation through
self-supervision. arXiv preprint, 2019.
13
Under review as a conference paper at ICLR 2020
Nilesh Tripuraneni and Lester Mackey. Debiasing linear prediction. arXiv preprint
arXiv:1908.02341, 2019.
Dimitris Tsipras, Shibani Santurkar, Logan Engstrom, Alexander Turner, and Aleksander Madry.
Robustness may be at odds with accuracy. arXiv preprint arXiv:1805.12152, 2018.
Eric Tzeng, Judy Hoffman, Kate Saenko, and Trevor Darrell. Adversarial discriminative domain
adaptation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pp. 7167-7176, 2017.
Vladimir Vapnik. The nature of statistical learning theory. Springer science & business media,
2013.
Oriol Vinyals, Charles Blundell, Timothy Lillicrap, Daan Wierstra, et al. Matching networks for one
shot learning. In Advances in neural information processing systems, pp. 3630-3638, 2016.
Paul Viola, Michael Jones, et al. Rapid object detection using a boosted cascade of simple features.
CVPR (1), 1(511-518):3, 2001.
Xiaolong Wang and Abhinav Gupta. Unsupervised learning of visual representations using videos.
In ICCV, 2015.
Xiaolong Wang, Allan Jabri, and Alexei A. Efros. Learning correspondence from the cycle-
consistency of time. In CVPR, 2019.
Eric Wong and J Zico Kolter. Provable defenses against adversarial examples via the convex outer
adversarial polytope. arXiv preprint arXiv:1711.00851, 2017.
Yuxin Wu and Kaiming He. Group normalization. In Proceedings of the European Conference on
Computer Vision (ECCV), pp. 3-19, 2018.
Hongyang Zhang, Yaodong Yu, Jiantao Jiao, Eric P Xing, Laurent El Ghaoui, and Michael I
Jordan. Theoretically principled trade-off between robustness and accuracy. arXiv preprint
arXiv:1901.08573, 2019.
Richard Zhang, Phillip Isola, and Alexei A Efros. Colorful image colorization. In European confer-
ence on computer vision, pp. 649-666. Springer, 2016.
Wentao Zhu, Yufang Huang, Mani A Vannan, Shizhen Liu, Daguang Xu, Wei Fan, Zhen Qian, and
Xiaohui Xie. Neural multi-scale self-supervised registration for echocardiogram dense tracking.
arXiv preprint arXiv:1906.07357, 2019.
14
Under review as a conference paper at ICLR 2020
A Informal Discussion on Our Variab le Decision B oundary
In section 1, we claim that in traditional supervised learning θ gives a fixed decision boundary, while
our θ gives a variable decision boundary. Here we informally discuss this claim.
Denote the input space X and output space Y. A decision boundary is simply a mapping f : X → Y .
Let Θ be a model class e.g Rd. Now consider a family of parametrized functions gθ : X → Y,
where θ ∈ Θ. In the context of deep learning, g is the neural network architecture and θ contains
the parameters. We say that f is a fixed decision boundary w.r.t. g and Θ if there exists θ ∈ Θ s.t.
f(x) = gθ(x) for every x ∈ X, and a variable decision boundary if for every x ∈ X, there exists
θ ∈ Θ s.t. f(x) = gθ (x). Note how selection ofθ can depend on x for a variable decision boundary,
and cannot for a fixed one. It is then trivial to verify that our claim is true under those definitions.
A critical reader might say that with an arbitrarily large model class, can’t every decision boundary
be fixed? Yes, but this is not the end of the story. Let d = dim(X) × dim(Y), and consider the
enormous model class Θ0 = Rd which is capable of representing all possible mappings between X
and Y. Let gθ0 0 simply be the mapping represented by θ0 ∈ Θ0. A variable decision boundary w.r.t.
g and Θ then indeed must be a fixed decision boundary w.r.t. g0 and Θ0, but we would like to note
two things. First, without any prior knowledge, generalization in Θ0 is impossible with any finite
amount of training data; reasoning about g0 and Θ0 is most likely not productive from an algorithmic
point of view, and the concept of a variable decision boundary is to avoid such reasoning. Second,
selecting θ based on x for a variable decision boundary can be thought of as “training” on all points
x ∈ Rd ; however, “training” only happens when necessary, for the x that it actually encounters.
Altogether, the concept of a variable decison boundary is different from what can be described by
traditional learning theory. A formal discussion is beyond the scope of this paper.
B Proofs
Here we prove the theoretical results covered in section 4.
B.1 Proofs for the toy problem
The following setting applies to the two lemmas; this is simply the setting of our toy problem,
reproduced here for ease of reference. Consider a two layer linear network parametrized by A ∈
Rh×d (shared) and v , w ∈ Rh (fixed) for the two heads, respectively. Denote x ∈ Rd the input and
y1 , y2 ∈ R the labels for the two tasks, respectively. For the main task loss
lm(A; v) = 2 (yι - v>Ax)2,	(11)
and the self-supervised task loss
ls(A; W) = 1 (y2 - w>Ax)2,
test-time learning yields an updated matrix
A0 J A — η 仅2 — w>Ax) (—wx>
where η is the learning rate.
Lemma 1. Following the exposition of section 4, denote
* =	(yι — v>Ax)
η	(y2 — w>Ax)v>wx>χ.
(12)
(13)
(14)
Assume η* ∈ [, ∞) for some > 0. Then for any η ∈ (0, ], we are guaranteed an improvement on
the main loss i.e. lm(A0) < lm(A).
Proof. From the exposition of section 4, we know that
Lm (A — η+DsA)) = 0,
15
Under review as a conference paper at ICLR 2020
which can also be derived from simple algebra. Then by convexity, we have
lm (A + ηVls(A)) = Im ( (1 - 券)A + η7 (A - η"lS(A)))
≤ (1 - η) Im(A) +0
≤ (1 - /) lm(A)
< lm(A),
where the last inequality uses the assumption that lm,(A) > 0, which holds because η* > 0.
Lemma 2. Define hU, V i = vec (U)> vec (V ) i.e. the Frobenious inner product, then
sign (η*) = sign(hVlm(A), Vls(A))).
(15)
(16)
(17)
(18)
(19)
Proof. By simple algebra,
(Vlm(A), Vls(A)i = h(yι - v>Ax) (—vx>),"- w> Ax) (-wx>)i	(20)
=(yι — v>Ax) (y2 — w>Ax) Tr (xv>wx>)	(21)
= y1 - v>Ax y2 - w>Ax v>wx>x,	(22)
which has the same sign as η*.
B.2 Proof of Theorem 1
For any η, by smoothness and convexity,
lm(x, y; θ(x)) = lm(x, y; θ — ηVls (x; θ))	(23)
Denote
≤ lm(x, y; θ) + ηhVlm(x, y; θ), Vls(x, θ)i + η2β kVls(x; θ)k2.
Then Equation 23 becomes
* = hVlm(x,y; θ), Vls(x, θ)i
η ― -βkVls(x; θ)k2
lm(x,y; θ — η* Vls(x; θ)) ≤ lm(x,y; θ)—
hVlm(x, y; θ), Vls(x, θ)i2
2βkVls(x; θ)k2
And by our assumptions on the gradient norm and gradient inner product,
lm(x, y; θ)
- lm(x, y; θ - n*Vls(x; θ)) ≥ 2βQ2 .
(24)
(25)
(26)
Because We cannot observe η* in practice, We instead use a fixed learning rate η = eG, as stated in
Theorem 1. Now we argue that this fixed learning rate still improves performance on the main task.
By our assumptions, η* ≥ βG, so η ∈ (0, η*]. Denote g = Vls(x; θ), then by convexity of lm,
lm(x, y; θ(x)) = lm(x, y; θ — ηg)	(27)
=Im，, y;(1—ηη*j θ+η (θ—η*g)j	(28)
≤ (1 — N) lm(x,y; θ) + Nlm(x,y; θ - η*g)	(29)
η*	η*
Combining with Equation 26, we have
lm(x, y; θ(X)) ≤ (1 — η*) Im(X, y; θ) + η7 (lm(x, y; θ) — 2βG^)	(30)
2
=lm(x,y; θ) — η 2βG2	(31)
Since η∕η* > 0, We have shown that
lm(x, y; θ) — lm(x, y; θ(x)) > 0.	(32)
16
Under review as a conference paper at ICLR 2020
C Computational Aspects of Our Method
At test-time, our method is 2xbatch_sizexnumber_of_iterations times slower than regular test-
ing, which only performs a single forward pass for each sample. As the first work on test-time
learning, this paper is not as concerned about computational efficiency as improving robustness, but
here we provide two potential solutions that might be useful, but have not been thoroughly verified.
The first is to use the thresholding trick on ls, introduced as a solution for the small batches problem
in section 2. For the models considered in our experiments, roughly 80% of the test instances fall
below the threshold, so test-time learning can only be performed on the other 20% without much
effect on performance, because those 20% contain most of the samples with wrong predictions.
The second is to reduce the number_of.iterations of test-time updates. For the online version,
the number_of.iterations is already 1, so there is nothing to do. For the standard version, We
have done some preliminary experiments setting number_of.iterations to 1 (instead of 10) and
learning rate to 0.01 (instead of 0.001), and observing results almost as good as the standard hyper-
parameter setting. A more in depth discussion on efficiency is left for future works, which might,
during training, explicitly make the model amenable to fast updates.
D Sample Images from the Common Corruptions Benchmark
Gaussian Noise Shot Noise Impulse Noise Defocus Blur Frosted Glass Blur
Motion Blur Zoom Blur Snow	Frost	Fog
Brightness Contrast Elastic Pixelate	JPEG
Figure 4: Sample images from the Common Corruptions Benchmark, taken from the original paper
by Hendrycks & Dietterich (2019).
E Additional Results on the Common Corruptions Data s et
For table aethetics, we use the following abbreviations: B for baseline, JT for joint training, TTT for
test-time training standard version, and TTTO for test-time training online version.
We have also abbreviated the names of the corruptions. The full names are, in order: original test set,
Gaussian noise, shot noise, impulse noise, defocus blur, glass blue, motion blur, zoom blur, snow,
frost, fog, brightness, contrast, elastic transformation, pixelation, and JPEG compression.
E.1	Results using Batch Normalization
As discussed in section 3, Batch Normalization (BN) is ineffective for small batches, which are
the inputs for test-time training (both standard and online version) since there is only one sample
available when forming each batch; therefore, our main results are based on a ResNet using Group
Normalization (GN). Here we provide results of our method on CIFAR-10-C level 5, with a ResNet
using Batch Normalization (BN). These results are meant to be merely a point of reference for the
curious readers, instead of our technical contributions.
17
Under review as a conference paper at ICLR 2020
In the early stage of this project, we have experimented with two potential solutions to the small
batches problem with BN. The naive solution is to fix the BN layers during test-time training. but
this diminishes the performance gains since there are fewer shared parameters. The better solution,
adopted for the results below, is hard example mining: instead of updating on all inputs, we only
update on inputs that incur large self-supervised task loss ls, where the large improvements might
counter the negative effects of inaccurate statistics.
Baseline
Joint training
Test-time training
Figure 5: Test error (%) on CIFAR-10-C, level 5, ResNet-26 with Batch Normalization.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	SnoW	frost	fog	brit	Contr	elast	pixel	jpeg
"ɪ	7.9	^639^	58.8	64.3	ɪr	34.6"	H6^	-45.9-	3T9^	44.0	37.5	13.0	"692^	338	^6T4	31.7
"J^	7.5	70'7T	65.6	67.2	-43?T	35Γ	^9^	^42^	-30.3	44.5	42.5	T2Γ	386^	307^	-62.6-	31.9
TTT	7.9	~479~	^452	54.8		304	ɪr	"309~	ɪr	343^	^269	T2.6	^352~	30.6	3T2~	31.3
Table 4: Test error (%) on CIFAR-10-C, level 5, ResNet-26 with Batch Normalization.
Test-time training (standard version) is still very effective with BN. In fact, some of the improve-
ments are quite dramatic, such as on contrast (34%), defocus blue (18%) and Gaussian noise (22%
comparing to joint-training, and 16% comparing to the baseline). Performance on the original dis-
tribution is still almost the same, and the original error with BN is in fact slightly lower than with
GN, and takes half as many epochs to converge.
We did not further experiment with BN because of two reasons: 1) The online version does not work
with BN, because the problem with inaccurate batch statistics is exacerbated when training online
for many (e.g. 10000) steps. 2) The baseline error for almost every corruption type is significantly
higher with BN than with GN. Although unrelated to the main idea of our paper, we make the
interesting note that GN significantly improves model robustness.
E.2 Additional Baseline: Adversarial Logit Pairing
As discussed in subsection 3.1, Hendrycks & Dietterich (2019) point to Adversarial Logit Pairing
(ALP) (Kannan et al., 2018) as an effective method for improving model robustness to corruptions
and perturbations, even though it was designed to defend against adversarial attacks. We take ALP
as an additional baseline on all benchmarks based on CIFAR-10 (using GN), following the training
procedure in Kannan et al. (2018) and their recommended hyper-parameters. The implementation
of the adversarial attack comes from the codebase of Ding et al. (2019). We did not run ALP on
ImageNet because the two papers we reference for this method, Kannan et al. (2018) and Hendrycks
& Dietterich (2019), did not run on ImageNet or make any claim or recommendation.
18
Under review as a conference paper at ICLR 2020
E.3 Results on CIFAR-10-C and ImageNet-C, level 5
The following two tables correspond to the bar plots in section 3.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	SnoW	frost	fog	brit	Contr	elast	pixel	jpeg
B	^89^	ɪr	47.2	ɪr	-23.7-	ɪr	-24.3	-26.T	^56^	34.4	28.1	135	"25.0"	■27.4	358"	29.8
JT	ɪr	"49.^	45.3	53.4	ɪr	-48.5	"24.8"	-26.T	"25.0"	32.5	27.5	T2.6	-25.3	^0"	316	287Γ
TTT	799~	4566~	718	50.0	ɪr	"46?1	"23.0"	-23.9-	-23.9	30.0	^51	TΣΣ	-23.9	■22.6	ɪr	27.2-
TTTO	-82^	ɪr	22.6	30.6	-T46^	34.4	38.3	17Γ	"20.0"	18.0	16.9	ɪɪ	156^	^21Γ6^	181	ɪr
ALP	16.5	^^Σ7~	^229	28.3	^^50~	156	ɪr	ɪr	^^52^	^272	^648	^217	^736	^230	ɪr	^w
Table 5: Test error (%) on CIFAR-10-C, level 5, ResNet-26.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	snow	frost	fog	brit	contr	elast	pixel	jpeg
B	■68.9	1~πτ	^0^	1.3	~T5	6.6	318^	162^	T57	149-	15.3	43.9	-9.7-	165	T53	23.4
JT	"691	~ΣΓ~		2.1	-87-	67Γ	TΣ3	160^	T53	158	170	45.3	nɪ	184	T97	22.9
TTT	69.0	~1Γ		3.5	10Γ	~68~	T35	18T	T7Γ	179-	20.0	47.0	T44	-20.9^	■22.8"	25.3
TTTO	^688		^286	26.9	^^37~	6.6	ɪr		356	^187	776	38.3	^353	143	~47Γ	^443
Table 6: Test accuracy (%) on ImageNet-C, level 5, ResNet-18.
E.4 Results on CIFAR-10-C, levels 1-4
The following bar plots and tables are on levels 1-4 of CIFAR-10-C. The original distribution is the
same for all levels, so are our results on the original distribution.
Figure 6: Test error (%) on CIFAR-10-C, level 4. See subsection 3.1 for details.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	snow	frost	fog	brit	contr	elast	pixel	jpeg
B	^89^	-46.T	ɪ!	44.8	153^	32.5	T9Γ	-20.T	ɪʃ	■26.9	13.3	105	T37	ɪ^	353	26.9
JT	ɪr	~50Γ	38.3	42.2	16.T	30.2"	ɪr	-20.T	ɪr	^54	141	100	T47	^190"	332	25.1
TTT	-7.9-		■35.4	39.8	150^	"47.8"	T9Γ	18Γ	ɪr	■24.0	135	100	T4Γ	177	■29.4	245Γ
TTTO	ɪr	-22.9-	20.0	23.9	T1T	351	T56	138^	T86	^159^	TΣ3	^97^	T19	167	T36	^198^
ALP	165	ɪr	^205	24.5		159~	^¾.7	ɪr	ɪɪ	139	Z2Σ	175	337	121	191	T85^
Table 7: Test error (%) on CIFAR-10-C, level 4, ResNet-26.
Figure 7: Test error (%) on CIFAR-10-C, level 3. See subsection 3.1 for details.
19
Under review as a conference paper at ICLR 2020
	orig	gauss	shot	impul	defoc	glass	motn	zoom	SnoW	frost	fog	brit	Contr	elast	pixel	jpeg
B	^89^	^42^	35:1	30.7	^!Σ2^	nr	T86^	17.T	19.0"	^53^	10.8	"9.7-	1ΓT6^	15.3	ɪr	24.6
JT	ɪr	ɪr	34.4	ɪ^	^1Σ2^	379"	ɪr		ɪr	^50"	H4	"9.2"	12.0	T52	^8"	22.8-
TTT	7^9~	372	316	28.6		358"	ɪr	T58^	T78^	ɪʃ	H0^	^9T	1ΓT6^	T43	18.9"	22.T
TTTO	-82^	ɪr	!77	17.9	-90-	^34	T53^	ɪr	16.4	T58	10.9	"9.0"	T07^	TΣ8^	TΣ2"	!87^
ALP	16.5	ɪð"	19.3	20.5	~Γ92~		ɪθ"		^M9~	^242	^30T	T66^	ɪr	^209^	178~	!80^
Table 8:	Test error (%) on CIFAR-10-C, level 3, ResNet-26.
Figure 8: Test error (%) on CIFAR-10-C, level 2. See subsection 3.1 for details.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	snow	frost	fog	brit	contr	elast	pixel	jpeg
B	^89^	3T7^	22.6	24.3	-9.9-	"42.6"	T49^	T47^	ɪr	18.4	"9.8"	^9TT	10.0	T3Γ	T7T	22.4
JT	8n~	3T0^	22.6	23.4	^9T	39.2"	16.4	~4A2	ɪr	17.5	"9.T	-8.3-	T06^	TΣ8^	T5.9"	20.5
TTT	-7.9-	-28.8-	20^	23.0	~0Q~	36.6	15.4	13?T	ɪr	16.9	"9.2"	~3Γ	T02^	TΣ5	T4.8"	!97^
TTTO	-82^	16.8-	!38"	15.F	^^8.^	^23y4	13.3	TTT	T68^	!Σ7^	"9.T	■"8.T	^9.^	TΣ4	TTT	17.0
ALP	16.5	~18.0~	!72	19.0	~Γ78~	^M7~	ɪr		ɪp	ɪ!	^2Σ4	T6.3	^¾2	^203~	174	!78~
Table 9:	Test error (%) on CIFAR-10-C, level 2, ResNet-26.
Figure 9: Test error (%) on CIFAR-10-C, level 1. See subsection 3.1 for details.
	orig	gauss	shot	impul	defoc	glass	motn	zoom	snow	frost	fog	brit	contr	elast	pixel	jpeg
B	ɪr	ɪr	T7T	17.0	-9.0-	-44.0	12?T	13.9-	T43^	T34	9.2	"8.9"	-9.0-	T31^	TΣ0	17.3
JT	ɪr	-20.T	!66	16.9	-82-	-40.5	12^	13.0-	T3Γ	!Σ3^	■"8.T	ɪr	^8.^	TΣ9^	ɪr	15.9-
TTT	-7.9-	ɪr	!58	16.5	-8.0-	37.9"	317^	ɪr	12.8-	T19^	~2Γ	~0Γ	^83^	12.6	τm	15.5
TTTO	ɪr	T38^	TT9"	12.2	^^8.^	■24.4	10.5	ɪr	TΣ4	T07^	-8Γ	~3Γ	^86^	T24	~07Γ	!44
ALP	T7.Q	~16.8~	T76	16.8	^^9~	187~	ɪp	~Γ73~	T75	T7.4	T6Γ	T8.4	^M4	^170	172	
Table 10: Test error (%) on CIFAR-10-C, level 1, ResNet-26.
20
Under review as a conference paper at ICLR 2020
Figure 10: Sample Images from the VID dataset in subsection 3.2 adapted to CIFAR-10. Each row
shows eight sample images from one class. The seven classes shown are, in order: airplane, bird,
car, dog, cat, horse, ship.
21