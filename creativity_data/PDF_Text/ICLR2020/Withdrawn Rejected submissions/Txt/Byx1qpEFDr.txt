On Recovering Latent Factors From Sampling And
Firing Graph
a
Pierre Gouedard
a
20th September 2019
Abstract
Consider a set of latent factors whose observable effect of activation is caught on a measure
space that appears as a grid of bits tacking value in {0, 1}. This paper intend to deliver a
theoretical and practical answer to the question: Given that we have access to a perfect
indicator of the activation of latent factors that label a finite dataset of grid’s activity, can
we imagine a procedure to build a generic identificator of factor’s activations ?
1	Introduction
This paper starts by introducing a mathematical framework for our solution. Then it describes
a procedure to build the generic factor’s activations identificator. Finally it presents the result of
the procedure for two particular statistical modelling of the measure grid’s activity. This paper
has been influenced by modern machine learning techniques, reviewed in [?], especially algorithm
that perform automated feature engineering such as neural network and deep learning [?] as well
as tree learning techniques [?] and improvements [?] and [?]. Finally, modern signal processing
techniques, that I have been taught at the Ecole Polytechnique Federale De Lausanne, reviewed
in [?], and recent work in statistics in large dimensions, to which I have been introduced during
my stay in the Laboratoire d’Informatique Gaspard Monge, reviewed in [?], has been more than
determinant for the conception of this paper. In order to make the core subject of this report
more consistent, we introduce the following notations:
•	n the size of the measure grid.
•	G the measure grid, composed of bits, G = {b1, . . . bn}.
•	S(G) the set of all possible permutations of G, |S(G)|= 2n.
•	S (G , l) the set of all permutations of G of size l.
•	K the number of latent factors.
•	F the set of latent factors, F = {f1, . . . fK}.
1
Figure 1: Measure grid model
•	S(F) the set of all possible permutations of F, |S (F)|= 2K.
•	S(F, l) the set of all permutations of F of size l.
•	G(f) the set of bits activated by factor f , G(f) ∈ S(G) and f ∈ F.
•	G-1 (b) the set of factors that activate grid’s bit b, G-1 (b) ∈ S(F) and b ∈ G.
•	F (2) the field with elements {0, 1}, equipped with the logical XOR and logical AND
respectively as the addition and multiplication.
2	Definitions And Properties
2.1	Statistical definitions
In this section we provide formalism for the statistical description of factors’s activity and their
signature on the measure grid.
Activation of factors
Each factor takes value in {0, 1} at each instant of time. A factor with value 1 at some instant
is active, otherwise it has value 0. At this stage of the paper we assume no particular statistical
model for factors. Nevertheless, if we consider the set of all possible combination of active and
unactive factors (F (2)K), we assume that there is a well defined distribution d0 such that
d0 : F (2)K → [0, 1]
d0x = P (f1 = x1 , . . . , fK = xK)
2
The statistical signature of a factor on the measure grid describes how the factor is linked to
measure grid’s bits. At this stage we simply assume that there is a well defined probability
measure so that for any I ∈ S(G)
P(G(f) = I) ∈ [0, 1]
X P(G(f) = I) = 1
I∈S(G)
Latent factors’s activations and signatures on the measure grid induce activations of measure
grid’s bits. We refer to this distribution over all possible combinations of activations of bits as
d, and define it as
d : F(2)n → [0,1]
dx = P (b1 = x1 , . . . , bn = xn)
Finally, we can also modelize the connection between factors and a measure grid’s bit as a
signature of the grid’s bit on factor space. That is, for I ∈ S(F), there is a well defined
probability measure so that
P(G-1(b) =I) ∈ [0, 1]
X P(G-1(b) = I) = 1
I∈S(F)
Characteristic polynome
The activity of factors and grid’s bits may be modelized using a set of multivariate polynomials
whose fiber and image domain is respectively F (2)n and F (2). The set of polynome associated
with a set I ∈ S(F) and I0 ∈ S(G) is denoted respectively {PI,l}l∈N and {PI0,l }l∈N. It represents
a segmentation of states of respectively factors of I and measure grid’s bits of I0.
PI,l : F (2)K → F(2)
Pι,ι[χ] = jpπ∈S(I 0,l) xπ1
.∙x∏ι, if l ∈{1,...,∣I∣}
otherwise
and
PI0,l : F(2)n → F(2)
P"χ0] = ∣ ∑∏∈S(10,1) x∏ι ∙... ∙ χ∏ι, if l ∈{1,…，∣ι∣}
otherwise
0,
3
Where S(I, l) and S(I0, l) are the set of all permutations of size l of respectively I and I0,
x = [xf1, . . . , xfK] and x0 = [xb1 , . . . , xbn]. Furthermore we define the characteristic polynomial
of a set I ∈ S(F) and I0 ∈ S(G) at level l0 ∈ {0, . . . , |I|} and l00 ∈ {0, . . . , |I0|} as
PIl0 : F (2)K → F (2)
|I|
PIl0 = XPI,l
l=l0
PIl000 : F (2)n → F (2)
|I0|
PIl00 = XPI0,l
l=l00
So far, the addition is set to be the logical XOR in the definition of fields F (2). However, in
the rest of this report, we will use symbol + and as representation of a logical OR in F (2).
This notation enables Us to save a lot of time in writing complex polynomials. Denoting ㊉ the
logical XOR and X the opposite of x, one have
(X ∙ y)㊉(X ∙ y) = x + y
Operators on polynome
In order to qualify a set of factors and grid’s bits, we define some basic operator. First, let IG
be a subset of S(G), we denote by F2(IG, G) the operator that transforms IG into a set of |IG|
vector in F(2)|G|.
F2(IG, G) ： S(G) → F(2)lGl×lIG|
For each vector X ∈ F2({I}, G) such that I ∈ IG , an entry takes value 1 if the associated index
belongs to I, 0 otherwise. This operator is convenient to evaluate the characteristic polynome.
As an example, let (I, I0) ∈ S(G)2 and l0 ∈ {1, . . . |I|} then
L ,	1, if |I0 ∩ 11≥ lo
X	PIl0 [X] =	,	0
χ∈F2({i 0},G)	[0, OtherWiSe
Furthermore, given the distribution over measure grid’s bits activation d, we define the norm of
a characteristic Polynome PIl0 with respect to d as
k.kd ： PF2(S(G),G) → [0, 1]
kPIl0kd=	X	PIl0 [X] ×dx
x∈F2(S(G),G)
Where PF2 (S(G),G) the space of all polynomials with domain F2 (S(G), G) and × is the simple
multiplication in R. Finally, keeping previous notations, let {PIli }i=1,...,k a set of characteristic
polynome for some integer k ≥ 2, we define the product operator with respect to d as
4
h., . . . , .id : PFk2(S(G),G) → [0, 1]
hPlι1,…,Plk id = X	(pI1 [x] •…∙Plk [x]) × dx
x∈F2(S(G),G)
Where ∙ denotes the usual multiplication in F(2) and X is the simple multiplication in R. Finally,
each operator specified above can also be defined in the factor space, using the characteristic
polynomial in factor space and the distribution over factors’s activations d0.
Stochastic processus induced by factor’s activation
Factors’s activations are observed as a strictly stationnary stochastic processus. That is for a
couple (I, l) ∈ F × {1, . . . , |I |}, we associate a stochastic process xlI [t] defined as
xl [t] = f 1, with probability ∣∣PIkd，
I 0, Otherwise
with {xlI [t]}t∈N 2-by-2 independant. Factors’s signatures and their activations lead to bits’s
activations that are also observed as striclty stationary stochastic processus. Again for a couple
(I, l) ∈ G × {1, . . . , |I |}, we associate a stochastic process xlI [t] defined as
了用一(1, with probability ∣∣PI∣∣d
I0, Otherwise
with {xlI [t]}t∈N 2-by-2 independant.
2.2 Firing Graph
The firing graph is the main data structure used in our solution. In this section we propose a
definition of it, as well as basic tools to support its analysis.
Graph specification
The algorithm presented in this report use a particular data structure that we refer as firing
graph and that we denote G(V, Dw).
•	V is the set of vertices V = {v1, . . . , v|V|}
•	Dw is the weighted direct link matrix, Dw ∈ NIVl×lVl and [Dw]仃=W indicate an edge of
weight w from vertex vi to vertex vj if w > 0
G is a directed weighted graph whose vertices are organized in layer. A vertex v of some layer
i ∈ N must have at least one incoming edge from a vertex of layer i - 1. It may also have
incoming edges from any vertices of layer k ∈ N, k < i. Such a set of vertices will be referred as
the input domain of v . Vertices of layer 0 have empty input domains, they correspond to bits
of the measure grid G. Each vertex stores the tuple (I, l0)
5
•	I the set of vertices at the tail of incoming edge of the vertex, referred as input set
•	l0 the firing rate’s lower bound of the vertex, referred as level, l0 ∈ {1, . . . , |I|}
Layer O
Layer 2
I = {%} and input domain is {vι,v2, V3,v4, ¾}
O
I = [vγ^V)} and input domain is {01,02,03}
Figure 2: Firing graph
Graph Polynomials
As for bits of the measure grid and factors, a vertex v (I, l0) of a firing graph is assiociated
with the set of polynomes {PI,l}l∈{l0,...,|I| }. Each polynome is a segment of its characteristic
polynome Pv that describes activation, at instant t, of v, given its input domain’s activations at
instant t - 1. If we denote by n, I and l0 respectively the size of the input domain of v, the set
of vertex that has a link toward v and the level of v, then
Pv,l : F (2)n → F (2)
Pv,l [x] =
π∈S(I,l) xπ1
0,
xπ2
xπl, if l ∈ {l0,...,|I|}
otherwise
Pv : F (2)n → F (2)
|I|
Pv [x] = X Pv,l [x]
l=l0
Where S(I, l) is the set of all permutations of size l of elements of I and x ∈ F2 ({I}, Dv), where
Dv is the input domain of v . Furthermore, all operators on polynome defined previously is
applicable. Let v, v1, . . . , vk be some vertices of the firing graph with the same input domain
and d a distribution over activations of their input domain’s vertices. Then the norm and the
product with respect to distribution d are defined as
∣∣Pv Ild=	E	Pv	[x]	X dχ	PI,…,PvGd =	E	(Pvι	[x]	.…∙ Pvk [x])	X	dχ
x∈F2 (S(G),G)	x∈F2 (S(G),G)
Finally, activations of vertices are observed as stochastic processus. Given a vertex v(I, l) we
6
define
1, with probability kPv kd
xv[t] =
I 0, Otherwise
The stochastic process that takes value 1 if the vertex v actvivates and 0 otherwise, at each
instant of time. If measure grid’s bits compound layer 0 of the firing graph, then, from definition
of bit’s stochastic processus and linearity of state’s propagations, xv [t] is strictly stationary.
Connection to grid’s bit
The firing graph is a convenient data structure to measure activity of a complex group of measure
grid’s bits. When the firing graph’s layer 0 is composed of measure grid’s bits, the characteristic
polynome of each vertex can be represented as a characteristic polynome in the measure grid’s
space, without consideration of time and delay. Let G be such a firing graph, then for any vertex
of layer 1, v(I, |I|), the characteristic polynome v is equal to the characteristic polynome of the
set of bits I ∈ G with level |I |.
Pv = PI,|I|
xv[t] = x|II| [t - 1]
Furthermore if we set the level of v to 1 its characteristic polynome become the logical or-sum
of the characteristic polynome of each bits of I
Pv =	P{b},1
b∈I
x" [t] = [1, if pb∈I x{b}[t- 1] > 0
I0, Otherwise
Besides, one can design more complexe arrangements of vertices that enable to model activations
of multiple sets of measure grid’s bits. Let G be a firing graph with its layer 0 composed of G,
let u(I, |I|) and V(I0,1), such that I ∩ 10 = 0, be vertices of layer 1 and w({u,v}, 2) a vertex of
layer 2. Then one can see that that characteristic polynome of w verifies
PW = EPI ∪{b},∣I |+1
b∈I0
田 _ J 1, if Pb∈I0 xI∪{b} [t - 2] > 0
xw [t] =
I0, Otherwise
2.3 Evaluation of measure grid’s bits
A perfect indicator of the activation of a given factor f can be used to evaluate the possibility
of any set of bits to be part of f’s signature on the measure grid.
7
Factor’s signature
One way to describe the activity of a factor f on the measure grid is to associate it to a polynome
in the measure grid’s space
PG(f) :F(2)n →F(2)
PG(f) = PG(f),|G(f)|
PG(f) is refered as the polynomial signature of f on G. Anytime f is active then its polynomial
signature takes value 1. Yet under particular modelling of factor’s links to measure grid, the
polynomial signature of f can take value 1 while f is not active. More formally let f ∈ F,
∀I ∈ S(F) such that x ∈ F2 ({I}, F) and x0 ∈ F2({∪f∈IG(f)}, G)
Pf [x] = 1 ⇒ PG(f) [x0] = 1
Furthermore if ! ∃J ∈ S(F \ {f}) such that G(f) ⊂ Sf0∈J G(f 0) then
Pf [x] = 1 ⇔ PG(f) [x0] = 1
basic metrics
Let I ∈ S(G), l ∈ {1, . . . , |I|}, f ∈ F and e the event ”factor f is active”. Then we define the
recall coefficient of couple (I, l) with respect to f as
μi,l,f = hPI,PG(f)id∣e + hPI, PG(f)id∣e
Where d|e is the distribution over bit's activations given event e and Pgf)is the complement
of PG(f) in F (2). Furthermore we define the precision coefficient of couple (I, l) with respect to
f as
νι,ι,f = hPI，PG(f)id∣e + hPI, PG(f)力恒
Where d|e is the distribution over bit's activations given not event e. Finally We define the
purity coefficient of couple (I, l) with respect to f as
ωI,l,f
JVIhf
μI,ι,f
The loWer ωI,l,f is, the purer is the couple (I, l) With respect to f. The recall, precision and
purity coefficient can be defined for any vertex v of a firing graph Where vertices of layer 0 are
composed by measure grid's bit and are denoted respectively μv,f, Vvf and ωv,f. The latter are
computed by using the representation of Pv as a characteristic polynomial in the measure grid's
space.
8
advanced metrics
Let I ∈ S(G), l ∈ {1, . . . , |I |}, f ∈ F and e the event ”factor f is active”. We define the precision
of the couple (I, l) with respect to factor f as
φ ： kPlkd,e
φlff	kPl kd
We also define the recall of the couple (I, l) with respect to factor f as
ψI,l,f
kPl kd,e
kPG(f )kd,e
Where d, e, the distribution over the combination of activations of measure grid’s bits that
intetersect with event e. The precision and the recall are defined for any vertex v of a firing graph
where vertices of layer 0 are composed by measure grid’s bit and are denoted respectively φv,f
and ψv,f . Again, The latter are computed by using the representation of Pv as a characteristic
polynomial in the measure grid’s space.
Advanced stochastic process induced by vertex
Given a firing graph with its layer 0 composed of measure grid’s bits, we have seen that the
propagation of activations induces a stochastic process at each vertex. Here we introduce some
more complex stochastic processus at each vertex of G. Given a vertex v at layer k ≥ 0, its
characteristic polynome Pv, a factor f ∈ F and e, the event ”factor f is active”, we define the
score process of v with respect to factor f as
T
sv,f [N, T, p, q] = N +	sv,p,q,t,f
t=1
Where (N, T, p, q) ∈ N4 and {sv,p,q,t,f}t∈N a set of i.i.d random variable. sv,p,q,t,f takes value q
if the event e was true at instant t - k and value -p if it was false, given that v activates at
instant t. That is, ∀ t < k, sv,p,q,t,f = 0 and ∀ t ≥ k
q, with probability qs
-p, with probability 1 - qs
Where q$ = q-qrq- with q『=∣∣Pvkd,e and qp = ∣∣Pv∣∣d-qr. d,e is the distribution over measure
grid’s activations that intersect with the event e
2.4 Properties
This paragraph intend to deliver useful properties for the analysis of the algorithm. The proof
of every properties can be found in the appendix A at the end of this paper.
sv,p,q,t,f
9
Polynomial decomposition
Partition
Let v1(I, l0), v2(J, 0) and v3(K, 0), be three vertices at the layer 1 of some firing graph, with the
same input domain G. If I = J ∪ K and J ∩ K = 0, then, ∀x ∈ F2(S(G), G)
|I|	|J|
PI0 [x] = XX Pj,j [x] ∙Pκ,ι-j [x]	⑴
l=l0 j=0
In paticular for b ∈ I
P1,1 [x] = Pι∖{b},ι [x] ∙ P{b},0 [x]+ Pι∖{b},i-1 [x] ∙ P{b},ι [x]	(2)
Decomposition
Let G be a firing graph with layer 0 composed of G. Let u(I, lu), v(I0, lv) such that I ∩ I0 = 0
as vertices of layer 1 and w({u, v}, 2) as vertex of layer 2. Let K ∈ ∪l∈{lv,...,|I0|}S(I0, l), x ∈
F2(S(G),G) and x0 = Pu[x] Pv[x] then
|I|
PK,∣K| [x] ∙ p{u,v},2 [x0] = XX PJ∪K,l+∖K∖ [x]	⑶
l=lu J∈S(I,l)
In particular if lu = |I| and lv = 1, then for any vertex of layer 0, b ∈ I0
Pb,1 [X] ∙P{u,v},2 [X0] = PI∪{b},∖I∖+1 [x]	(4)
Metrics
Throughout this section, we consider G to be a firing graph with layer 0 composed by measure
grid’s bits G and f ∈ F denote some target factor that is linked to some bit of the measure
grid. The distribution of activation of latent factors and measure grid’s bits will be respectively
denoted d and d0 and e is the event ”factor f is active”. Furthermore we use v to denote some
vertex of G whose characteristic polynome respects Pv = PIl with (I, l) ∈ S(G), {1, . . . , |I|} and
f ∈ F some factor
Precision of VerteX
The precision of v with respect to f is
φ =	kPf kd0
φv,f = kPf kd0+(1-kPf kd0) X ωι,ι,f
Furthermore, if μv,f = 1 we have
φv,f ≤
kPf kd0_______________
kPf kd0 + (I- kPf kd0) X ωG(f),∖G(f )∖,f
(5)
(6)
10
Recall of vertex
The recall of v with respect to f is
ψv,f = μI,l,f	⑺
Furthermore,
0≤φv,f≤ 1	(8)
Where right equality is reached whenever v is connected to a set of measure grid’s bit I ∈ G,
with level l0 = |I| such that I ⊂ G(f).
vertex's score process
If sv,f [N, T, p, q] denotes the score process of v with respect to f , with N, T, p, q ∈ N4, then
E[sv,f[N,T,p,q]] = N +T × (φI,l,f × (p+q) -p)	(9)
Furthermore,
Var [sv,p,q,t,f] = (q+p)2 × φI,l,f × (1 - φI,l,f)	(10)
3 Identification of Latent Factor
In this section, we present a procedure to identify a latent factor’s activation. The procedure
consists of two steps:
•	Sampling: Sample the measure grid and build a firing graph.
•	Draining: Drain the firing graph to exclude high purity coefficient’s vertices.
Both processus will be described and the efficiency of the draining algorithm quantified.
3.1 Sampling
Sampling the measure grid consists in following a procedure to select some bits of it. This
procedure is usually designed to be the most efficient in the fullfilment of specific quantitative
objective. First, we assume that we have access to a determinist exact indicator of f ’s activations
with f ∈ F . Then, the objective of sampling is to maximize the probability that we sample
a bit whose purity coefficient with respect to f is lower or equal to some positive constant ω.
That is, if we denote s the random variable of the outcome of a single sampling, the objective
is to maximize
P(ω{s},1,f ≤ ω)
11
Again, if we have a set I ⊂ G of bits, the objective of sampling is to maximize the probability
of selecting a bit b, for which the purity of I ∪ {b} at level |I |+1 is lower to a given positive
constant ω. That is, if we denote by s the random variable of the outcome of a single sampling,
the objective is to maximize
P(ωI∪{s},∣I|,f ≤ ω)
We propose a very intuitive sampling method based on the indicator of activation of target
factor f . Given parameters ps ∈ [0, 1] and Sp respectively the probability of picking a bit and a
set of pre-selected measure grid’s bits, the sampling procedure writes
Algorithm 1 Sampling
Input: pS , Sp
Output: S
S . {}, Xf — nextFactorState(), XG — nextGridState()
while S is empty do
if xf = 1 and ∀b ∈ Sp XG [b] = 1 then
for all b ∈ G \ S ∪ Sp do
if XG [b] = 1 then
S — S ∪ {b} with probability Ps
end if
end for
end if
Xf J nextFactorState(
XG J nextGridState()
end while
Where Xf and XG are respectively a scalar that takes value 1 when factor f is active, 0 otherwise,
and a mapping with measure grid’s bits as keys and their states as values (0 or 1). The second
mean of the sampling procedure is to build a firing graph. The construction of the firing graph
requires to set a parameter N ∈ N that corresponds to the initial weigth of edges that will
be drained. In addition we set a mask matrix Gmask ∈ {0, 1}|V | that controls which vertex is
allowed to have their outcoming edges updated during draining. We consider two kind of firing
graphs.
12
Figure 3: Single sampled firing graph
In figure ??, sampled bits {b1, . . . , bns} are used as vertices of the layer 0 of a firing graph G,
nS = |S|. Then vertex v({b1 , . . . , bns }, 1) is added at the layer 1 of G. Furthermore, we set
Gmask so to allow only layer 0’s outcoming edges to be updated through draining.
Figure 4: Joint sampled firing graph
In figure ??, sampled bits {bι,…，bns} and pre-selected bits {b；,...,bk} for some k ∈ N* Com-
pound the layer 0 of the firing graph G, nS = |S|. Then, vertices v({b1, . . . , bns }, 1) and
13
u({b1 , . . . , bk}, k) are added at layer 1 of G and vertex w({u, v}, 2) at layer 2 of G. Finally,
we set Gmask so that only b1 , . . . , bns ’s outcoming edges are allowed to be updated through
draining.
3.2	Draining
Draining the firing graph consists in iterating a forward propagation of bits’s activations and
a backward propagation of feedback generated by factor’s activations through the firing graph.
Feedback are meant to increment or decrement the weight of unmasked vertices’s outcoming
edges. Given that an edge with a null or negative weigth vanishes, at the end of the routine,
connections of the graph differentiate between vertices’s purity. To ease understanding of the
algorithm, we split vertices of the firing graph into input and core vertices which are respectively
vertices of layer 0 and vertices of layers > 0. Furthermore, we introduce a new type of vertices
that can only have incoming edges from core vertices. We refer to those vertices as outputs.
Figure 5: Draining diagram
We use ni , nc and no to refer to the number of respectively input, core and output vertices.
Furthermore, we define Iw ∈ Nni×nc, Cw ∈ Nnc×nc and Ow ∈ Nnc×no that correspond to the
weighted direct link matrices respectively from input toward core vertices, core toward core
vertices and core toward output vertices. Furthermore we will use A = Aw > 0, A ∈ {I, C, O}
to denote the corresponding unweighted direct link matrices. Finally, in order to represent in a
more convenient way stochastic processus induced by measure grid’s activations, we define the
following stochastics vectors
•	xi(t)	∈	{0, 1}1×ni	the vector of activations of input vertices at instant t
•	x(ct)	∈	{0, 1}1×nc	the vector of activations of core vertices at instant t
•	x(ot)	∈	{0, 1}1×no	the vector of activations of output vertices at instant	t
The propagation of activations through the firing graph can be represented with two equations:
14
Forward processing (FP)
Forward transmitting (FT)
Xct)= XitT) ∙ I + XctT) ∙ C
x(t) = x(t-1) O
Xo	Xc
if [Xct)]i >li
Otherwise
if [Xθt)]j > 1
Otherwise
Where ∙ is the usual matrix multiplication, (i,j) ∈ {1,...nc} ×{1,...no} and li is the level of
the ith core vertex. An output vertex of the firing graph is fed with the activation of a targeted
factor decayed in time by the number of layer - 1. That is, for single and joint sampled firing
graphs, the decay is respectively set to 1 and 2. Factor’s activations generate a feedback to the
output that is back propagated through the firing graph. Supposing that we set the factor’s
decay to d ≥ 1, the feedback is defined as
X(bt,o) = X(ot) ◦ (p + q) × X(ft-d) - p
Where ◦ denotes the Hadamard product, X(ft-d) is the vector of states of factors at instant t - d
and p, q are pre-difined positive integers. A correct backpropagation of X(bt,o) up to the input
vertices is made possible by using time and space coherence of firing graph’s forward states. We
denote by Vi , i ∈ N the set of vertices that has a path, composed of i vertices, toward an output
vertex. Let G be a firing graph with k ∈ N* layers augmented with a layer of ouptut vertices.
Let Vo the set of output vertices, ∀v, o ∈ V0 × Vo, v is elligible to o’s feedback at instant t if and
only if
•	v was active at instant t - 1
•	v has an edge toward o
The same principle can be used to backpropagate the feedback from vetices of V0 towards
vertices of V1 and so on. Generally speaking, the back propagation from vertices of Vi towards
Vi+1 respects ∀v, v0 ∈ Vi × Vi-1, v is elligible to feedback of v0 at instant t if and only if
•	v was active at instant t - (2 × i + 1)
•	v has an edge toward v0
Finally we can encode the backpropagation equations as
Backward transmitting (BT)	BaCkWard ProCeSSing (BP)
Xbtc = (O ∙ Xbt-I) + C ∙ XbTI)) ◦ X热
Xbti)=(I ∙ Xbt-I)) ◦ XmT
no×dmax -2
c ,:(dmax-2))
15
Structure udpates (SU)
Ow = Ow + O ◦ (Xbt-I) ∙ XiScf
Cw = Cw + C ◦ (Xbt-I) ∙ XlScf
Iw = Iw +1 ◦ (Xbtc-1) ∙ Xm)i)T
Where Xm(t),c = hx(ct) ... x(ct-dmax)iTandXm(t),i = hxi(t) ... xi(t-dmax)iT,Xc(,tb) ∈ {0, q, -p}nc×dmax
for t ∈ N* and Xc0) = 0nc×dmax. Furthermore dmax ≥ (l - 1) X 2 + 1 where l is the number of
layers of the firing graph. Finally we provide a parameter T ∈ N to the draining algorithm. It
controls the targeted number of feedback that an edge should receive before disabling its up-
date. Maintaining update’s permissions for each edge requires an operation similar to structure
updates. Finally, the draining algorithm iterates forward and backward pass until either G is
composed of two distinct connexe components, no structure update is enabled or the maximum
number of iterations Tmax ∈ N has been reached.
Algorithm 2 Draining
Input: G, T, Tmax , p, q, decay
Output: G drained
i J 0
Xb,c, Xb,o,Xi,xc,Xm,c,Xm,i J InitSignals()
while i < Tmax do
xi J nextGridState()
xc, xo J FT(G, xi, xc)
Xm,c, Xm,i , xc, xo J FP(xc , xo)
if i ≥ decay then
xf J nextF actoreState()
Xb,c,Xb,o J BP(Xb,c, Xb,oxf, p, q)
G0 J SU(T,G,Xb,c,Xb,o,Xm,c,Xm,i)
Xb,c,Xb,i J BT(G,Xb,c,Xb,o,Xm,c,Xm,i,)
GJG0
end if
if G.cc == 2 or not Gmask.any() then
break
. Initialisation
. Core loop
. Forward pass
. Backward pass
. Stop conditions
end if
iJi+1
end while
Clearly, the complexity of the algorithm is dominated by the backward transmit and structure
updates operations. A standard worst case analysis of those operations gives O(n4 × d2max),
where n is the total number of vertices in the firing graph. Yet this analysis relies on standard
complexity time for dense matrix operations, and does not take into account neither the sparsity
16
of signals and direct link matrices nor the distribution of input vertices’s activations. In practice,
we have found that the forward and backward propagation of bits and factors’s activations is
time consuming, especially when both N and T are large numbers. Thus, to reduce running
time, batch_size successive bits and factors's states are forward and backward propagated with
an efficient vectorization of the equation. The decrease in time complexity of this practical trick
is impressive and worth the gain in space complexity of the algorithm. Finally this trick may
requires to dynamically change the batch_size so that treshold for the number of updates at each
edges is respected.
3.3	Analysis of the algorithm
Theorem 3.1 Given a set of sampled bits S, a set of pre-selected bits I = {b1, ...,b↑} a target
factor f and G, the firing graph built after sampling algorithm. A 5-tuple (ω, N, T, p, q) exists
such that the probability of event E: ”no input vertices of G have outcoming edges at the end of
the draining” is upper bounded. More specifically
|S|
P(E) ≤ Ep- X PS (Ks ∈ S \ ωI∪{s},∣I∣+1,f < ω}l= j)
j=0
Where p- = P (sv,f [N, T,p, q] < 0∣ω∕∪{s},i+ι,f < ω). Where V(I ∪ {s}, i + 1), for any s ∈ S, is a
vertex of layer 1 of a firing graph G of 2 layers. Furthermore
P (sv,f [N,T,Ρ,q] < 0∣ωι∪{s},i+ι,f < ω) ≤ C × max exp -T ×
exp (-T × δfc)
With δf, C and c are postitive constants that depends on ω and i and f . Var[sv,p,q,f,t] = σ2 .
Proof. As a reminder, in the core of this proof, we refer to d and d0 respectively to the
distribution over bits’s activations and factors’s activations. Given the arrangement of vertices
of graph G and the forward equations of the draining algorithm, the activation of any vertices
b ∈ S that will be propagated toward an output vertex, is modelled by the following characteristic
polynomial
P{b},1 ∙ P{u,v},2
With v(S, 1) and u({bf,...,货},i). Thus, using (??), the activity of b that is propagated to the
ouptut vertex is the same than the activity of a vertex v({b1,..., b↑,b}, i + 1) at the layer 1 of
a firing graph G0 where 圻，...然 and b compound its layer 0. Furtermore, given the time and
space consistency of the backpropagation of the feedback from the output vertex, the weight of
the outcoming edge of b, at the convergence of the draining algorithm, is either 0 or equal to
the score process of vertex v in G0 with respect to f, sv,f [N, T, p, q]. Then, the first inequality
is obtained by developping
17
|S|
P (E) = XP- × p*j × PS (|{s ∈ S \ ωι∪{s},i+ι,f < ω}∣= j)
j=0
|S|
≤ Xpj- × PS (∣{s ∈ S \ ωI∪{s},i+1,f < ω}l=j)
j=0
Where
•	I = {b↑,...,b*}
•	P- = P (sv,f (N,T,p,q) < 0∣ω∕∪{s},i+ι,f < ω)
•	P+ = P (sv,f (N, T,p,q) < 0∣ω∕u{s},i+ι,f ≥ ω)
Then, we choose the value of the postive real ω such that a measure grid,s bit b+ verifies
b+ =arg min∣ω - ω1∪{b},i+1,f ∣
beG
such that ω — ω∕∪{b},i+ιj > 0
And we define the vertex v+(I U {b+}, i + 1) and δ+ = ∣ω — ωrv+,f ∣. If vertex V is such that
ωvj < ω then using (??) one gets
忆 kd≥L⅛
kPf S+(ω — δ) × (1 -忆S) ≥kPf S+(ω - δ+) × (1 -忆lb，)
----V	' '	V-'
φv,f------------φv+ ,f
>	kPf kd，
>	IIPf kd，+ω × (1-IlPf kd，)
V----------V-----------}
φ
For some real δ ≥ δ+ > 0. Then, We choose the 4-tuple (N, T,p, q) as follow:
(p, q) ∈ N2 such that φ × (p + q) — p < 0
N = -T × (φ × (p + q) — p)
T ∈ N such that N large enough
Thus, given ωv,f < ω one can write
P (sv,f [N, T,p,q] < 0)= P (N + X SvDq,T,f < 0)
=P (X sv,P,q3f - T × E [sv,p,q,ι,f] < -n - T × E [sv,p,q,ι,f]
Furthermore from the definition of φ and φv,f we have
φv,f = φ + δ × φ × φv,f ×
V
-{z≡
δv,f
1 - kPf kd，
kPf kd，
18
Yet using equation (??) one have
E [sv,p,q,1,f] = φv,f × (p + q) - p
= (φ+δv,f) × (p+q) -p
Using N = -T × (φ × (p + q) - p) and the definition of φ one have
-N-T × E [sv,p,q,1,f] = -T × (p+q) × δv,f
Thus
P(sv,f[N,T,p,q] <0) =P XT sv,p,q,t,f - E [sv,p,q,t,f] < -T × (p + q) × δv,f
≤P	|Xsv,p,q,t,f - E	[sv,p,q,t,f]	|> T ×	(p + q)	× δv,f
≤ P	|XT	sv,p,q,t,f - E	[sv,p,q,t,f]	|> T ×	δf
With δf = (P + q) X δ+ X φ2 X I-PkPfy.
At this point we have to notice that {sv,p,q,t,f}t=1,...,T is a sequence of i.i.d random variables with
mean μ and variance σ2 that verifies ∣Sv,p,q,t,f ∣≤ max(p,q). Thus one can apply the Chernoff
inequality as formulated in [?]. In particular, taking λ = σ-1δf we obtain
T T	T	/ T	`
P ( |^X sv,p,q,tnf - E [sv,p,q,t,f ] |> Tδf ) = P ( | ^X sv,p,q,t - E [sv,p,q,t] |> λσ√T
t=1	t=1
≤ C X max exp -T X
, exp (-T X δfc)
With C, c some positive constant and Var[sv,p,q,t,f] = σ2 for t ∈ {1, . . . , T}. Q.E.D.
Theorem 3.2 Given a set of sampled bits S, a set of pre-selected bits I = {圻，…，b" a
target factor f and G the firing graph built after sampling algorithm. A sequence of 5-tuple
(ω, N, T, p, q) exists such that for each input vertex v of G, from which the output is reachable,
we have
P(ωv,f > ω) ≤ C x max (exp (—T X (fC) ) , exp (-T X δ∕c))	(11)
Where v(I ∪ {s}, i + 1), for any s ∈ S, is a vertex of layer 1 of a firing graph G of 2 layers and
δf, C and c are postitive constants that depends on ω and i and Var[sv,p,q,f,t] = σ2 .
19
Proof. As in the proof of the previous theorem, using the arrangement of vertices of G, the
property (??) and the forward and backward equations of the draining algorithm, one can show
that the weight of the outcoming edge of any vertices b ∈ S of G is either equal to 0 or to
the score process Sv,f [N, T,p, q] where v({b；,...,b，b},i + 1) is a vertex at the layer 1 of a
firing graph G0 where b1,...,b彳 and b compound its layer 0. Furthermore, if sample b still have
outcoming edges after draining, then
P (ωv,f > ω) = PS (ωI∪{b},i+1,f > ω) × P (Svf (N, T,p,q) > 0lωI∪{b},i+1,f > ω)
Then, we choose the value of the postive real ω such that a bit b- verifies
b- =argmin∣ω - ωι∪{b},f |
b∈G
such that ω - ωI∪{b},f < 0
And We define the vertex V-(I ∪ {b-},i + 1) and δ- = ∣ω — ωv-,f |. If V is such that ωv,f < ω
then using (??) we have
kp⅛≤kPfkd0<	kPf kd0
IlPf kd0+(ω + δ) X (1 -IlPf lid，)一∣∣Pf |合+(ω + δ-) X (1 -IlPf |出)∣∣Pf |合 +ω X (1 -IlPf1⑺
S-------V--------} S-------V---------} S-----V-------}
φv,f	φv-,f	φ
for some δ ≥ δ- > 0. Then defining the 4-tuple (N, T, p, q) as
(p, q) ∈ N2 such that φ X (p + q) - p < 0
N = -T X (φ X (p + q) - p)
T ∈ N such that N large enough
Then, reproducing the same development as it was done in the proof of previous theorem, one
can derive a convenient form to easily apply the Chernoff inequality.
P(Sv,f(N, T, p, q) > 0lωv,f >ω) ≤ P (| sv,p,q,t,f - E [sv,p,q,t,f ] | > T X δf
With δf = (p + q) X δ- X φ2 X I-PPfy.Then using the Chernoff inequality as written in [?]
using λ = σ-1δf we obtain
T T -1	T	T T-1	`
P ( । X sv,p,q,t,f - E [sv,p,q,t,f] |> T X δf j = P ( | X sv,p,q,t,f - E [sv,p,q,t,f] |> λσ√T
t=0	t=0
≤ C X max exp -T X
exp (-T X δfc)
With C, c some positive constant and Var[Sv,p,q,t,f] = σ2. Q.E.D
20
3.4 Limit of the generic case
The combination of theorems shows that the association of sampling and draining with the right
choice of 5-tuple (ω, N, T, p, q) gives a convenient tool to select measure grid’s bits with purity
coefficient lower than a target ω. Furthermore, when T → +∞, the correct selction is almost
certain, which highlights the trade-off between efficiency and complexity of the algorithm that
is embedded in the choice of ω and T , on which depends N, p and q. This generic procedure
and its analysis deliver a strong framework that eases the derivation of more specific results
that may be obtained under specific modelling of latent factors’s activations and measure grid
signatures. Nevertheless, it leaves two fundamental points clueless
•	No possibility to quantify further the effectiveness of the sampling strategy
•	No specific procedure or heuristics to choose positive real value ω
In the rest of this paper, we present two particular cases of factor’s and measure grid’s modelling
that enables a better quantification of the sampling strategy and stronger heuristics for the choice
of ω .
4	Case of signal plus noise
This particular case is designed to be easy to analyze. We first define the statistical modelling of
factors and bits’s activations. Then, we quantify the sampling strategy and justify a choice for
the 5-tuple (ω, T, N, p, q). Finally, we present simulations and provide discussion of the results
obtained with this special case.
4.1	Statistical modelling
In this particular case, we assume that the target factor f is linked to some |G(f)|= k measure
grid’s bits and activates with probability pf . We also assume that bits of the measure grid are
identically and independently subject to a noisy activation with probability pN . We may see
noisy activations as the result of n noisy latent factors, linked to exactly 1 bit of the measure
grid, that is K = n + 1. Under this model, the probability for a bit b ∈ G to activate is defined
as
^pfh ,.吟 JPf + PNX (I-Pf), if b ∈G(f*)
P (”b active”) =
I Pn,	Otherwise
As a consequence, for any I ∈ S(G) such that 11∩G(f )|= i and j = |I|—i if we set X ∈ F2({I}, G),
the distribution over measure grid bits’s activations is defined as
PiN+j X (1 - PN)n-i-j X (1 - Pf) + PjN X (1 - PN)n-k-j X Pf , if i = k
dx =
IPiN+j X (1 - PN)n-i-j X (1 - Pf),	Otherwise
In the rest of the section, we will always refer to this distribution as d.
21
4.2	Evaluation of bits
Let G be a firing graph with a layer 0 composed of measure grid’s bits. Then, the precision of
a vertex v(I, |I|) of layer 1 of G, with respect to f, depends only on |I| and |I ∩ G(f)|. Indeed,
if |I ∩G (f )|= i then
φv,f
Pf________
Pf + (I - Pf) X PN
With identification of terms using (??) we have ωv,f = piN and using previously defined distri-
bution, one finds that μvf = PN|-i, Vvf = PN|. Besides, given a set of bits I such that I ⊂ G(f),
if b ∈ G(f) \ I, the precision of vertex v(I ∪ {b}, |I |+1) with respect to f is
_________Pf________
Pf + (1 — Pf) × PN|+1
if b / G(f)
Pf
Pf + (1 - Pf) × P|NI|
4.3	Sampling Strategy
In this particular case we follow the generic sampling procedure S with parameter PS . Thus,
using the previously defined statistical distribution of bits’s activations, if we denote S, the set
of sampled bits using S , the distribution of the cardinal of S is
(n — k∖	1	,
× PsN-k × (1 - PN)n-k-s × PS , if s ≥ k
s—k
0,	otherwise
Thus its expected size is E [|S|] = k + (n — k) × PN × PS. Furthermore if I = {圻，...，偿} ∈ S(G)
is some set of pre-selected bits and S is a set of bits sampled using S , a positive real ωi exists
such that
PS (|{s ∈ S \ ωι∪{s},∣ι∣+ι,f <ωi}∣= j) = PS (|{s ∈ S \ S ∈ G(f )|= j)
= (IGCf)1—i! X PS X (1-Ps)|G(f)|-i-j
4.4	Identification of factors
First, in the case of a single sampled firing graph, one can see that bits’s purity coefficients take
only two values with respect to f
PN, if b ∈ G(f)
ω{b},1,f = j 1, otherwise
22
Thus if we choose
ω0 =
(1 + PN )
2
It maximizes the purity margin defined as
δ0
(ω0 - ω{b},1,f ) + (ω{b0 },1,f - ω0 )	(1 - pN )
2
2
Where b ∈ G(f) and b0 ∈/ G(f). In the case of a joint sampled firing graph in which a set
I = {b1,…，&} of i ∈ N* pre-selected bits that verify ∀b ∈ I, b ∈ G(f), remaining bit’s purity
coefficients with respect to f can take again two values
piN+1, if b∈G(f)
ωI"+1f=jpN,	otherwise
Thus if we choose
ωi =
(1+ PN) X PiN
2
it maximizes the purity margin defined as
(ωi - ωI ∪{b},i+1,f) + (ωI∪{b0},i+1,f - ωi )	(1 - PN) × PiN
δi =-----------------------------------------=-
i2	2
Where b ∈ G(f) and b0 ∈/ G(f). Finally we define the 5-tuple (Ni , Ti , P, q) as
(P, q) ∈ N2 such that φi × (P + q) - P ≤ 0 and φ0i × (P + q) - P > 0
N = -T × (φ × (P + q) - P)
T ∈ N such that N large enough
Where t ∈ N, φi = --l PfI--Y and φi =-工7---pf------V.
, i	pf +ωi ×(1-pf)	i pf +(ωi -δi)×(1-pf)
4.5	Simulation
The signal plus noise model is implemented in python and mainly uses standard numpy and
scipy modules to generate random signal that fit its probabilistic model. More details about the
implementation can be found in appendix B. We generate n = 1000 bits that randomly activate
with probability PN and we choose randomly |G(f)|= 50 bits that are linked to a latent factor
that activates with probability Pf = 0.3. Finally we build the single sampled firing graph using
PS = 1.
23
FigUre 6: observation Of(r+-he SCorePrOCeSSfor different; SNR InodeIS 7 = 500
EaCh SUbPlot; Of figure 77 ShOWStJhe WeightJ Of OUtJComing edges Of SamPIed VerHCes∙ BlUe HneS
ShOWtJhe WeightJ Of edges out;Coming from SaInPIed bi- b m g(j) and red IineS COlTeSPond bo
(r+-he WeightJ Of edges out;Comiilg from SaInPIed bi- b 铲 g(j)∙ Finally(r+-he black horN∙oma IHne
represeas(r+-he Lheore ECai Inean VaIUe Of SFf-V 7"P-Of a VertJeX WitJh ChaTaCtJeriSE CPOlynOme
Pd = Pw) I “ w±h b m g(j)∙ As theory SUggeStJyWe Can See two distinct; Phenomenony blues
HneS ConVergeaTOUnd tiheoreEcal InealI for process Of b±s Iinked bo(r+-he tjaτg⅛fact;Or and red
HneS ConVergetJo 0∙ HOWeVeL(r+-he higher is P=(r+-he IeSS IlOECeabIeiStJhe disEIlctio∙n between
each process。ThiSiS explained by(r+-he fact; tjhatj(r+-he higher ISPN-(r+-he COSer are(r+-he precision Of
b±s Iinked(r+-o barget; factor f and(r+-he precision Of IIoiSy b⅛∙s∙ FUtJhermore(r+-he IatJer ObSerVaEon
induces a high VaIUe OfP + q WhiCh result; in a InOreVOIaEIeSCOreProcess∙ FOrtJheSeCond
SimUlatJo∙n We USe Tl = IOOɔ一 g(j)τ50"pf = O.W- 7 = 200 and PS H 05 YetJ a⅛(r+-he end Of(r+-he
draining We ChooSe all(r+-he input; VerECeS Of(r+-he firing graph bhat; StJ≡have an out;Coming edge
and USe bheh Combined actjivatjo∙n as an estdmat;Or Of(r+-he tjaτge- fact;OyS acEvatio∙n∙ We bhen
IneaSUre tjheτ PreeiSo∙n and recall OVerlOO repetio∙n for each SNR ra⅛o∙
24
Value of the score process
II	2
Ul	O	C∏	O
OOOO
Value of the score process
II	2	2
Ul O C∏ O Ul
OOOOOO
A11
20 40 60 ∞0 IoO 120
NUmber Of-s-r⅛-on (Xlo)
(a) PN = 03 Sq) = (LI)
10 20 30 40 50 60 70
NUmber Of-s-r⅛-on×10)
(C) PN =97 2 (PA) = (3-5)
Value of the score process
II 2	2	3
5	。	5	。	5	。
OOOOOO
八
10 20 30 40 50 60 7。 ∞0
NUmber Of-terato∙n (XIo)
(b) PN = 0∙57 Sq) = (223)
Value of the score process
I	II 2	2	3
5	5	。	5	。	5	。
oooooooo
O
10 20 30 40 5。
NUmber Of-terato∙n (XIO)
(d) PN = 09 Sq) = (511)
PN	Mean φ	Standard deviation φ	Mean ψ	Standard deviation ψ	Number of fails
0.3	1.0	0.00	0.87	0.30	0
0.5	1.0	0.03	0.66	0.42	0
0.7	0.97	0.13	0.43	0.46	4
0.9	0.75	0.14	0.13	0.25	19
Table 1: Evaluation of naive factor’s activation estimation, T = 200, 100 repetitions
Table ?? shows quality indicators of the estimator for different SNR ratio. The two first columns
give respectively the mean and standard deviation of the precision of the estimator. The two
following columns are respectively the mean and the standard deviation of the recall of the
estimator. Finally the last column is the number of experiments that ended without any input
vertices having a path towards the output, so that the construction of an estimator is not possible.
Again, we see that the quality of the estimator drops as the theoretical precision between noisy
bits and factor’s bits are close to each other. Yet it reveals that this naive estimator, for a
reasonable SNR ratio, is still efficient to predict the activation of target latent factor. Finally,
we simulate the signal plus noise model in the settings of joint sampled firing graph. We use a
measure grid of n = 1000 bits from which we sampled randomly |G (f)|= 50 bits linked to target
factor f that activates with probability pf = 0.3 and we set pN = 0.6. Finally we built the
joint sampled firing graph by pre-selecting randomly 5 bits linked to the factor and running the
sampling algorithm described previously using pS = 1.
ə,loos əip J。9n-B>
Figure 7: Observation of the score process in a joint sampled firing graph with T = 500 and
(p, q) = (7, 1)
25
In this case, we obtain N = 7 and ω5 ' 0.062 when following the procedure described in previous
section. As for the first experiment, blue lines show the weight of edges outcoming from sampled
bit b ∈ G(f) and red lines correspond to the weight of edges outcoming from sampled bit b ∈/ G(f).
The black horizontal line represents the theoretical mean value of sv,f [N, T, p, q], where v has
characteristic polynome Pv = P{b1,...,b5,b},5, with {b1 , . . . , b5} the set of pre-selected bits and
b ∈ G(f). The simulation validate the expectation from theory and the high value of p + q
explains the high volatility of score processus.
5	Case of sparse measure grid
This particular case is more complex than the previous one. We first define the statistical
signature of factors and bits’s activations. Then we quantify the sampling strategy and justify
a choice for the 5-tuple (ω, T, N, p, q). Finally, we present simulations and provide discussion of
results obtained with this particular case.
5.1	Statistical modelling
Latent factor activation
We assume that each of the K latent factors activates independantly with probability pf . As
a consequence, for any I ∈ S(F), if we define x such that x ∈ F2 ({I}, F), we can define the
distribution of factor’s activation as
d0x = |KI|! × p|fI| × (1 - pf)K-|I|
Measure grid activation
We assume two major properties of activations of measure grid’s bits.
•	For each factor f ∈ F, each bit b ∈ G has equal probability pg to belong to G(f).
•	For each factor f ∈ F, for each couple b1 , b2 ∈ G2, events ”b1 ∈ G(f)” and ”b2 ∈ G(f)” are
independent.
As a consequence the probability for a bit b to activate, given that every factor of some set
{f1 , . . . , fk } ⊂ F is active, writes
k
P (b active |f1 , . . . , fk active) =
i=1
= 1 - (1 - pg)k
The above quantity depends only on the number of active latent factors. Thus, for any I ∈ S(G),
if we define x ∈ F2(S(G), G), we can define the distribution of bits’s activations as
ki	× pig × (1 - pg)k-i
26
dx = X	Kk	× pfk × (1 -pf)K-k × hpig|k × (1 - pg|k)n-ii
With i = |I| and pg|k = P (b active |f1, . . . , fk active).
5.2	Evaluation of bits
Let G be a firing graph whose layer 0 is composed of measure grid’s bits. Given a target factor
f, the precision with respect to f of a vertex v({b}, 1) of the layer 1 of G depends on wether
b ∈ G(f) and on |G-1(b)|. Indeed, if b ∈ G(f) and |G-1(b)|= l, l ∈ {1, . . . ,K}, it will be said to
have a purity rank of l and its precision with respect to f writes
φ =____________Pf__________
v,f — Pf + (1 - Pf) X ωι
where ωl = 1 - (1 - pf)l-1 . If b0 ∈/ G(f) the precision of v0({b0}, 1) with respect to f writes
φv0,f = Pf
Futhermore, if we have a vertex v(I, |I|) such that ∀b ∈ I, b ∈ G(f) and minb∈I |G -1 (b)|= l, then
the precision of v with respect to f verifies
φv,f ≤ Pf + ω- X (I - Pf)
With
ωl- =	X	Kk Pfk X (1 - Pf)K-k
k=K-l-1	k
The minimum purity coefficient one can obtained with bits that verifies b ∈ G(f) and |G-1(b)|= l.
That is, the case of a vertex v (I , |I |) with I composed of every possible
Kl
such bits.
5.3	Sampling Strategy
We follow the generic sampling procedure S with parameter PS . Although it is not hard to
derive key quantification such as E [|S|] or probabilities to sample bits linked to a target factor
f under this modelling, generic formulas are not elegant and present not much interest in this
simulation.
5.4	Identification of factors
First, in the case of a single sampled firing graph, for any grid’s bits linked to factor f, there
is only K different purity coefficients possible. Thus we may set ω to ωl , using l reasonably
small to differentiate lower purity rank from greater purity rank samples. In the case of a joint
sampled graph, where a set of I = {b；,..线} were pre-selected then the choice of ω is not
trivial and is hard to be efficiently and generically derived. Let ω∕,∣∕∣f the purity coefficient of
27
the pre-selected set of bits We set ω = ωι,∣ι∣,f - δ where δ ∈ R should be chosen with caution.
Finally we choose the 5-tuple {(ω, N, T, p, q) as
(p, q) ∈ N2 such that φ × (p + q) - p < 0
N = -T × (φ × (p + q) - p)
T ∈ N such that N large enough
Where φ = —, pf	.
pf +ω×(1-pf)
5.5	Simulation
The sparse measure grid model is implemented using python and the standard python numpy
and scipy modules to generate random signal that fit its probabilistic model. In our case we
generate n = 1000 bits with K = 10 latent factors that activate with probability pf = 0.3
and we link measure grid’s bits independently with probability pg = 0.3. Finally we built the
single sampled firing graph running the sampling algorithm described previously, using pS = 1.
Finally, we set ω = ω10 , the higher purity coefficient for bits linked to the target factor f .
Ooo
Ooto
8 6 4
ssəuojd əjous əip J。θn-B>
1400
1200
1000
Figure 8: Observation of the score process in a single sampled firing graph with T = 1000 and
(p, q) = (1, 1)
We clearly see a rapid differentiation of score processus according to their purity rank. We can
also observe that, at the end of draining, the higher the purity coefficient is, the closer are weights
28
of corresponding edges. Finally, the behaviour of score processus validates the efficiency of the
draining algorithm to rank bits of the measure grids blindly, in an attempt to identify latent
factors. The second experiment with the sparse measure grid model aims to give intuition on
the choice of δ used for draining a joint sampled firing graph. As for the previous simulation, we
generate n = 1000, bits with K = 10 latent factors that activate with probability pf = 0.3 and
we link measure grid’s bits independently with probability pg = 0.3. Then we choose randomly
i = 5 bits, denoted by I = {bj,..., b*}, with purity rank 4 with respect to the target factor
f . Finally we sampled and built the joint sampled firing graph using pS = 1 and the set of
pre-selected bits I. The procedure described in the previous section to choose the target purity
coefficient consists in estimating the purity coefficient ωI,∣I∣,f and to set δ so that ω = ωI,∣I∣,f - δ.
(a) δ = 0.
(b) δ = 10-2
(c) δ = 5 × 10-2
(d) δ = 10-1
Figure 9: Observation of sampled bit’s score processus in a joint sampled firing graph i = 5,
T = 500 and (p, q) = (1, 1)
In each simulation, ωI,∣I∣,f has been estimated using 1000 samples and We use T = 500. FUr-
thermore, each figure corresponds to a different value of δ that induces different values of ω , set
as ω = ω1,∣1 ∣,f — δ. As for the first experiment, the different colored lines in each subfigure show
the weight of edges outcoming from sampled bits with different purity ranks. As expected, we
29
can see that the higher δ is, the more discriminative the draining procedure is. If δ is set to 0,
then every sampled bits will remain connected in the firing graph after draining, which is not of
great interest. Yet, if δ is set too high we may end with two connexe components, which is not
desirable neither. Thus, the experiment confirms the difficulties that we may face choosing the
right value for δ .
6	Discussion
This paper has presented an algorithm that consists in a generic optimisation of a firing graph,
in an attempt to solve the abstract task of identifying latent factor’s activations. Furthermore
it has provided theoretical certitude on the effectivness of the procedure. However, the iterative
optimisation method associated with the diversity and flexibility of the architecture of a firing
graph opens doors to further applications, notably in the field of inverse problem and in the
very hype field of machine learning. Indeed in supervised classification, we are given a dataset
composed of features that may be numerical or categorical description of samples and targets
that specify the class of samples. If we assume that the activation of a target is a combination
of latent factors’s activations and that we operate the minimum transformation of features so
that they take the form of a measure grid, a light layer of procedures could turn our solution
into a supervised classificator. The specificity of such a learner would give it an interesting
position in the supervised learning landscape. Indeed, its iterative optimisation and flexible
architecture could make it an adaptative learner, that scale to large dataset, with minimum
processing work on raw data, in the manner of a neural network. Yet unlike neural network the
algorithm handle very efficiently categorical or sparse feature space. Furthermore, compared to
the most advanced tree based classification, its flexible architecture is more suitable to learning
update and on-the-fly evaluation or addition of new features. Finally, given the hype granted to
the field of machine learning nowaday, both in the scientific comunity and civil society, it would
be common sense to orient this piece of research to this field.
30
Appendices
A Properties
Partition
Let v1 (I, l0), v2 (J, 0) and v3(K, 0), be three vertices at the layer 1 of some firing graph, with
the same input domain G such that I = J ∪ K and J ∩ K = 0. result (??) stands that
∀x ∈ F2(S(G),G)
|I|	|J|
PI0 [x] = XXPj,j [x] ∙Pκ,i-j [x]
l=l0 j=0
Proof. The statement above can also be written
|J|
Pi,i [x] = X Pj,j [x] ∙Pκ,i-j [x]
j=0
∀ l ∈ {l0, . . . , |I|}, now we propose a simple proof by contradiction. Let l ∈ {l0, . . . , |I |},
X ∈ S(G) and x ∈ F2({X},G) such that
PI,l [x] = 1
|J|
X pJ,j [x] ∙ pK,l-j [x] = 0
j=0
Yet, if J and K is a partition of I and |I ∩ X ∣= l, then (j*,k*) ∈ {0,... | J ∣} ×{0,... |K|} exists
such taht
|X ∩ J l=j*
|X ∩ K| = k*
j* + k* = l
Thus for x ∈ F2({X}, G)
PJj* [χ] ∙ Pκ,k* [χ] = 1
which contradicts our first assumption. Let l ∈ {l0, . . . , |I|}, X ∈ S(G) and x ∈ F2({X}, G) such
that
31
PI,l [x] = 0
|J|
X Pj,j [x] ∙Pκ,ι-j [χ] = ι
j=0
Thus above statement implies that j* ∈ {0,..., min(l, | J|)} exists such that
PJj*[x] ∙ pκ,ι-j*[x] = 1
Thus |X ∩ J|= j* and |X ∩ K|= l - j*. Since J and K is a partion of I we must have
|X ∩ 11= |X ∩ J| + |X ∩ KI= l
As a consequence for x ∈ F2({X}, G), PI,l [x] = 1 and give us the contradiction.
Result (??) is a particular case of result (??)
Decomposition
Let G be a firing graph with layer 0 composed of G. Let u(I, lu), V(I0,lv) such that I ∩ 10 = 0
be vertices of layer 1 and w({u, v}, 2) be a vertex of layer 2. Let K ∈ ∪l∈{lv,...,|I0|}S(I0, l),
x ∈ F2(S(G), G) and x0 = Pu[x] Pv [x] , the result (??) stands that
|I|
PK,∣K| [x] ∙ P{u,v},2 [x ]= Σ Σ PJ∪κ,l+∣κ∣ [x]
l=lu J∈S(I,l)
Proof. The proof the above statement is derived by a straight forward development of the
equation, first using result (??) and the fact that K and I0 \ K is a partition of I0 we can write
|I|
P{u,v},2 [* x0] = I E PI,l [x]
l=lu
/ 1I1
= X PI,l [x]
l=lu
|I0|
XPI0,l [x]
l=lv
|I0| |K|
ΣΣPK,k [x] ∙ PI0∖K,l-k [x]
l=lv k=0
Thus
32
PK,∖K∖ [x] ∙ P{u,v},2 [x ]
|I|	|I0| |K|
=PK,∖K∖ [x] ∙ IX Pι,ι [χ]) ∙ IXXPK,k [x] ∙ PI0∖K,l-k [x]
l=lu	l=lv k=0
∖I∖	∖I0∖
I X PI,l [x] I ∙ I X PK,∖K∖ [x] ∙ PI0∖K,l-∖K∖ [x]
l=lu	l=lv
∖I∖	∖I0∖-∖K∖
X PIl [x] ∙ PK,∖K∖ [x] I ∙ X PI0∖K,l [x]
l=lu	l=0
/ V----------V---------}
=1
∖I∖
=X pI,l [x] ∙PK,∖K∖ [x]
l=lu
The last line is equal to P∖lI=∖l PJ∈S(I,l) PJ∪K,l+∖K∖ [x] and thus the proof is achieved.
Result (??) is a particular case of result (??)
Let G be a firing graph with layer 0 composed by measure grid’s bits G and f ∈ F denote some
target factor that is linked to some bit of the measure grid. The distribution of activation of
latent factors and measure grid’s bits will be denoted d and d0 and the event ”factor f is active”
will be denoted by e. Furthermore, let v be some vertex of G whose characteristic polynome
respects Pv = PIl with (I, l) ∈ S(G), {1, . . . , |I|} and f ∈ F some factor.
Precision of VerteX
The result (??) stands that the precision of v with respect to f writes
φ =	kPf kd0
φv,f = kPf kd0+(1-kPf kd0) X ωI,ι,f
Proof. First, starting from the defintion of φv,f
,,	kPI kd,e
(Kf = φI,lf = 1P⅛
Thus using P* = Pgf),∖G(f)∖ one have
φ = ________________hPI,P*id,e +〈PI, P*id,e_______________
Qlvf 一〈PI, P*id,e +〈PI, P*id,e +〈PI, P*id,e +〈PI, P*id,E
Yet〈PI, P*id,e = 0
φ = ______________________〈PI,P*id∖e XkPf kd0
φv,f =〈PI,P*id∖e X kPfkd0 + (〈PI,P*id忸 +〈PI,P*id∖e) X kPfkd0
Finally by identification of term
33
φ =__________________μι,ι,f X kPf kd0__________
φvf = μι,ι,f ×kPf kd0+νι,ι,f X (1-kPf kd0)
Which gives the expected result.
The result (??) stands that if μv,f = 1 we have
φ ≤_____________________f_______________________
v,f ~ kPf kd0+(I- kPf kdO) X ωG(f),∣G(f)∣,f
Proof. The result (??) can be proven by simple contradiction, suppose there is a tuple (I, l0) 6=
(G(f), |G(f)|) such that
μI,lo,f = 1
νI,l0,f < νG(f),∣G(f)∣,f
First, denoting PG(f),∣G(f)∣ = P* and using (??) We have
∣I∣ I∩G(f)
hPIl0,P*id=X X
hPI∩G(f),k ∙ PI∖G(f),l-k，P*id
l=l0 k=0
∣I∣ I∩G(f)
=	PI∩G(f),k[x] ∙ PI\G(f),l-k[x] ∙ P*[x] X dx
l=l0 k=0 x∈F2(S(G),G)
(∣i∣	ʌ
=E	P*[χ]∙ f∑PI\G(f),l-∣I∩G(f)∣[x] I × dx
x∈F2 (S(G),G)	l=l0
Where d is any well defined ditribution on F2(S(G), G). Thus, we have
(III	ʌ
μI,lo,f =	Σ	P*[x] ∙ I £PI\G(f),l-∣I∩G(f)∣[x] I × dx∣e
x∈F2(S(G),G)	l=l0
As a consequence, in order to have μι,io,f = 1 we most have {PI∖g(f),ι-∣I∩G(f)∣}ι∈{io,…,∣I∣} to be
a partion of F2(S(G), G). Thus l0 ≤ |I \ G(f)|. On the other end the precision coefficient writes
νI,l0,f =	X	P*[x] ∙ (XPI∖G(f),l-∣I∩G(f)∣[x]) X dx忸 + hPlI0, P*id∣e
x∈F2(S(G),G)	l=l0
soifl0 ≤ |I\G(f)|
νI,lo,f = νG(f ),∣G(f )∣,f + hPI0，P*id∣e
≥ νG(f),∣G(f)∣,f
Since〈PI0, P*id忸 ≥ 0, which lead to a contradiction.
34
ReCall of VerteX
The result (??) stands that the recall of v with respect to f is
ψv,f = μι,ι,f
Furthermore, the result (??) stands that
0≤φv,f≤ 1
Where right equality is reaChed wheneVer v is ConneCted to a set of measure grid’s bit I ∈ G,
with leVel l0 = |I| suCh that I ⊂ G(f).
Proof. From the definition of ψv,f we haVe
ψvf = ψI,l,f
kPl kd,e
kPG(f )kd,e
Thus using P* = Pgf ),∣G(f)∣ one have
ψvf =
hPl,P*id,e +〈PI, P*id,e
kPf kdo
Yet hPl, P*id,e = 0, thus
ψvf =
〈PI,P*id,e =〈PI,P*id∣e ×kPf kdo
kPf kdo =	f0
μι,ι,f
Finally the result (??) direCtly Comes with the definition.
vertex's score process
Let sv,f [N, T, p, q] be the sCore proCess of v with respeCt to f , for some N, T, p, q ∈ N4 . The
result (??) stands that
E[sv,f[N,T,p,q]] = N +T × (qs × (p+q) -p) = N +T × (φI,l,f × (p+q) -p)
Proof. From the definition of the score process we have
T
sv,f [N, T, p, q] = N + X sv,p,q,f,t
t=1
with {sv,p,q,f,t}t=1,...,T a sequence of i.i.d such that
35
sv,p,q,t,f
q, with probability q$ = —qr—
qr +qp
-p, with probability 1 - qs
Thus we can write
T
E[sv,f[N,T,p,q] = N + X E [sv,p,q,t,f]
t=1
T
= N + q × qs - p × (1 - qs)
t=1
T
= N+ qs × (p+q) -p
t=1
= N + T × (qs × (p + q) - p)
Yet qs = qrqrqp, with qr = ∣∣Pv kd,e and qp = ∣∣Pvkd,s, thus
=	kPvkd,e	= ∣Pvkd,e
qs = ∣Pvkd,e + kPvkdf = ∣Pvkd
Which is the definition of φv,f that is equal to φI,l,f by definition.
Furthermore the result (??) stands that,
Var [sv,p,q,t,f] = (p+q)2 × φI,,l,f × (1 - φI,l,f)
Proof. Using the result of previous proof we first compute E sv2,p,q,t,f
E sv2,p,q,t,f = q2 × qs + p2 × (1 - qs)
= q2 × φv,f + p2 × (1 - φv,f)
= φv,f × (q +p) × (q -p) +p2
Furthermore we have seen previously that E [sv,p,q,t,f] = φv,f × (p + q) - p, thus
E [sv,p,q,t,f]2 = φv,f × (p+ q) × (φv,f × (p+q) - 2 × p) +p2
Finally
Var [sv,p,q,t,f] = E sv2,q,p,t,f - E [sv,p,q,t,f] = (q + p)2 × φv,f × (1 - φv,f)
Which gives the expected result since φv,f = φI,l,f by definition.
36
B Implementation
The code that has been used to obtain results of simulations can be found on github at ht-
tps：//github.com/PierreGouedard/deyep under the branch publi-1. The code is exclusively Writ-
ten in python, is compatible with interpreter python2.7 and python3 and requires python mod-
ules numpy and scipy. Code for simulation can be found under
•	tests/signaLplus_noise_1.py
•	tests/signaLpluS_noise_2.py
•	tests/signaLpluS_noise_3.py
•	tests/sparse_identification.py
•	tests/sparse_identification_2.py
Where the list beloW are relative to the root directory of the project. The code in the branch
Publi_1 has not changed since the submision of this paper, however, the code in other branch,
notably master, may have been optimised, augmented or refactored.
37
References
[1]	Christopher M Bishop. Pattern recognition and machine learning. Information science and
statistics. Springer, New York, NY, 2006. Softcover published in 2016.
[2]	Yann LeCun, Yoshua Bengio, and Geoffrey Hinton. Deep learning. Nature, 521(7553):436-
444, 5 2015.
[3]	L. Breiman, J. H. Friedman, R. A. Olshen, and C. J. Stone. Classification and Regression
Trees. Wadsworth and Brooks, Monterey, CA, 1984.
[4]	Andy Liaw and Matthew Wiener. Classification and Regression by randomForest. R News,
2(3):18-22, 2002.
[5]	Ji Zhu, Hui Zou, Saharon Rosset, and Trevor Hastie. Multi-class adaboost, 2009.
[6]	Martin Vetterli, Jelena Kovacevic, and Vivek K Goyal. Foundations of Signal Processing.
Cambridge University Press, 2014.
[7]	T. Tao. Topics in Random Matrix Theory, ser. Graduate Studies in Mathematics. Provid-
ence, Rhode Island: American Mathematical Society, 2012.
38