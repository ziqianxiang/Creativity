Table 1: Accuracy and runtime analysis. We compare the average error between the ground-truthparticle positions and two predicted future frames on the test set. Additionally, we report the averagedistance from the ground truth to the prediction over the whole sequence. In this test mode somemethods become unstable after a few frames. In the last column we report the average inferencetime per frame.
Table 2: Ablation study. We compare the average error between the ground-truth particle positionsand two predicted future frames on the test set, evaluated over whole test sequences (left) and juston the final frames of each test sequence (middle; this focuses on frames with small motion). Therightmost column shows the average distance from the ground truth to the predicted point set overwhole test sequences. Ours w/o interpolation uses nearest-neighbor instead of trilinear interpolationfor the convolution filters. Ours w/o window uses a(xi, x) = 1 in Equation 7. Ours w/ naive lossuses Euclidean distance as the loss, i.e. we set γ = 1 and φi = 1 in Equation 16. Ours w/o FCuses only convolutions and includes the central particle in the convolution (rather than separatelyprocessing its features via an FC layer).
Table 3: Application to an inverse problem: material estimation from observed fluid motion. Toestimate the viscosity we backpropagate through our network and optimize ν with gradient descent.
Table 4: Runtime analysis. We compare the average per frame inference time and the time usedfor the nearest neighbor search (NNS). Our convolution achieves the shortest inference times incomparison even if NNS times would be excluded. Irrespective of that, the methods used for findingneighbors can have a significant contribution to the total runtime. Since fluid particles are moving,acceleration structures for the neighbor search have to be rebuilt each frame. This affects the KD-Tree methods as well as the methods using spatial hashing. Note that we use the same NNS forPCNN and Ours (denoted with *). For all methods except for SPNets the inference time is shorteron the smaller DPI DamBreak data (3456 particles compared to the 6000 particles of our data). Weattribute this to a higher number of neighbors on the DPI DamBreak, which is about 49 on averagecompared to the average 40 neighbors on our datasets. All runtimes were measured on a systemwith an Intel Core i9-7960 and an NVIDIA RTX 2080Ti.
Table 5: Comparison of different window functions. Ours uses a window function similar to thepoly6 kernel used in Muller et al. (2003). Ours triangular window uses atriangular window function.
