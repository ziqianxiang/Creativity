Published as a conference paper at ICLR 2020
PAC Confidence Sets for Deep Neural Net-
works via Calibrated Prediction
Sangdon Park
University of Pennsylvania
sangdonp@cis.upenn.edu
Nikolai Matni
University of Pennsylvania
nmatni@seas.upenn.edu
Osbert Bastani
University of Pennsylvania
obastani@seas.upenn.edu
Insup Lee
University of Pennsylvania
lee@cis.upenn.edu
Ab stract
We propose an algorithm combining calibrated prediction and generalization
bounds from learning theory to construct confidence sets for deep neural networks
with PAC guarantees—i.e., the confidence set for a given input contains the true
label with high probability. We demonstrate how our approach can be used to
construct PAC confidence sets on ResNet for ImageNet, a visual object tracking
model, and a dynamics model for the half-cheetah reinforcement learning prob-
lem. 1
1 Introduction
A key challenge facing deep neural networks is that they do not produce reliable confidence esti-
mates, which are important for applications such as safe reinforcement learning (Berkenkamp et al.,
2017), guided exploration (Malik et al., 2019), and active learning (Gal et al., 2017).
We consider the setting where the test data follows the same distribution as the training data (i.e., we
do not consider adversarial examples designed to fool the network (Szegedy et al., 2014)); even in
this setting, confidence estimates produced by deep neural networks are notoriously unreliable (Guo
et al., 2017). One intuition for this shortcoming is that unlike traditional supervised learning al-
gorithms, deep learning models typically overfit the training data (Zhang et al., 2017). As a con-
sequence, the confidence estimates of deep neural networks are flawed even for test data from the
training distribution since, by construction, they overestimate the likelihood of the training data.
A promising approach to addressing this challenge is temperature scaling (Platt, 1999). This ap-
Proach takes as input a trained neural network f^(y | x)—i.e., whose parameters φ have already
been fit to a training dataset Ztrain——which produces unreliable probabilities f^(y | x). Then, this
approach rescales these confidence estimates based on a validation dataset to improve their “calibra-
tion”. More precisely, this approach fits confidence estimates of the form
fφ,τ(y | x)(X eχp(Tlogfφ(y |x)),
where τ ∈ R>0 is a temperature scaling parameter that is fit based on the validation dataset. The
goal is to choose τ to minimize calibration error, which roughly speaking measures the degree to
which the reported error rate differs from the actual error rate.
The key insight is that in the temperature scaling approach, only a single parameter τ is fit to the
validation data—thus, unlike fitting the original neural network, the temperature scaling algorithm
comes with generalization guarantees based on traditional statistical learning theory.
Despite the improved generalization guarantees, these confidence estimates still do not come with
theoretical guarantees. We are interested in producing confidence sets that satisfy statistical guar-
antees while being as small as possible. Given a test input x ∈ X, a confidence set CT (x) ⊆ Y
1Our code is available at https://github.com/sangdon/PAC-confidence-set.
1
Published as a conference paper at ICLR 2020
|C (x)| = 1
5 ≤ |C(x)| ≤ 10	50 ≤ |C(x)| ≤ 100
|C(x)| ≥ 200
Table 1:	ImageNet images with varying ResNet confidence set sizes. The confidence set sizes are
on the top. The true label is on the left-hand side. Incorrectly labeled images are boxed in red.
(parameterized by T ∈ R) should contain the true label y for at least a 1 - fraction of cases:
P(x,y)〜D [y ∈ CT (X)] ≥ 1 - e.
Since we are fitting a parameter T to based on Zval, we additionally incur a probability of fail-
ure due to the randomness in Zval. In other words, given e, δ ∈ R>0, we aim to obtain probably
approximately correct (PAC) confidence sets CT (x) ⊆ Y satisfying the guarantee
PZval〜Dn 卜(x,y)〜D(y ∈ CT(X)) ≥ 1 — e) ≥ 1 — δ.
Indeed, techniques from statistical learning theory (Vapnik, 1999) can be used to do so (Vovk, 2013).
There are a number of reasons why confidence sets can be useful. First, they can be used to inform
safety critical decision making. For example, consider a doctor who uses prediction tools to help
perform diagnosis. Having a confidence set would both help the doctor estimate the confidence
of the prediction (i.e., smaller confidence sets imply higher confidence), but also give a sense of
the set of possible diagnoses. Second, having a confidence set can be useful for reasoning about
safety since they contain the true outcome with high probability. For instance, robots may use a
confidence set over predicted trajectories to determine whether it is safe to act with high probability.
As a concrete example, consider a self-driving car that uses a deep neural network to predict the
path that a pedestrian might take. We require that the self-driving car avoid the pedestrian with high
probability, which it can do by avoiding all possible paths in the predicted confidence set.
Contributions. We propose an algorithm combining calibrated prediction and statistical learning
theory to construct PAC confidence sets for deep neural networks (Section 3). We propose instantia-
tions of this framework in the settings of classification, regression, and learning models for reinforce-
ment learning (Section 3.6). Finally, we evaluate our approach on three benchmarks: ResNet (He
et al., 2016) for ImageNet (Russakovsky et al., 2015), a model (Held et al., 2016) learned for a vi-
sual object tracking benchmark (Wu et al., 2013), and a probabilistic dynamics model (Chua et al.,
2018) learned for the half-cheetah environment (Brockman et al., 2016) (Section 4). Examples of
ImageNet images with different sized ResNet confidence sets are shown in Table 1. As can be seen,
our confidence sets become larger and the images become more challenging to classify. In addition,
we show predicted confidence sets for ResNet in Table 2, as well as predicted confidence sets for
the visual object tracking model in Table 3.
Related work. There has been work on constructing confidence sets with theoretical guarantees.
Oftentimes, these guarantees are asymptotic rather than finite sample (Steinberger & Leeb, 2016;
2018). Alternatively, there has been work focused on predicting confidence sets with a given ex-
pected size (Denis & Hebiri, 2017).
More relatedly, there has been recent work on obtaining PAC guarantees. For example, there has
been some work specific prediction tasks such as binary classification (Lei, 2014; Wang & Qiao,
2
Published as a conference paper at ICLR 2020
1 ≤ |C(x)| < 5
5 ≤ |C(x)| < 10
10 ≤ |C(x)| < 20
king penguin
shopping basket
(
，
chambered
nautilus
)
English springer,
Welsh springer
spaniel ,
collie,
boxer,
Saint Bernard,
Leonberg
— ~~~~	'
Chihuahua,
toy terrier,
Italian greyhound,
Boston bull,
miniature pinscher
face powder,
√--------
hamper,
lotion,
packet,
shopping basket
banded gecko,
-----------Γ-
common iguana,
American chameleon,
whiptail,
agama,
frilled lizard,
alligator lizard,
green lizard,
African chameleon,
Komodo dragon
altar,
analog clock,
bell cote, castle,
church,
cinema, dome,
monastery,
palace, vault,
wall clock
barber chair,
hand blower,
medicine chest,
paper towel,
plunger,
shower curtain,
soap dispenser,
toilet seat,
tub, washbasin,
washer, toilet tissue
Table 2:	Confidence sets of ImageNet images with varying ResNet confidence set sizes. The pre-
dicted confidence set is shown to the right of the corresponding input image. The true label is shown
in red, and the predicted label is shown with a hat. See Table 5 in Appendix D for more examples.
Table 3:	Visualization of confidence sets for the tracking dataset (Wu et al., 2013), including the
ground truth bounding box (white), the bounding box predicted by the original neural network (Held
et al., 2016) (red), and the bounding box produced using our confidence set predictor (green). We
have overapproximated the predicted ellipsoid confidence set with a box. Our bounding box contains
the ground truth bounding box with high probability. See Table 9 in Appendix D for more examples.
2018). There has also been work in the setting of regression (Lei et al., 2018; Barber et al., 2019).
However, in this case, the confidence sets are fixed in size—i.e., they do not depend on the input
x (Barber et al., 2019). Furthermore, they make stability assumptions about the learning algorithm
(though they achieved improved rates by doing so) (Lei et al., 2018; Barber et al., 2019).
The most closely related work is on conformal prediction (Papadopoulos, 2008; Vovk, 2013). Like
our approach, this line of work provides a way to construct confidence sets from a given confidence
predictor, and provided PAC guarantees for the validity of these confidence sets. Indeed, with some
work, our generalization bound Theorem 1 can be shown to be equivalent to Theorem 1 in Vovk
(2013). In contrast to their approach, we proposed to use calibrated prediction to construct confi-
dence predictors that can suitably be used with deep neural networks. Furthermore, our approach
3
Published as a conference paper at ICLR 2020
makes explicit the connections to temperature scaling and as well as to generalization bounds from
statistical learning theory (Vapnik, 1999). In addition, unlike our paper, they do not explicitly pro-
vide an efficient algorithm for constructing confidence sets. Finally, we also propose an extension
to the case of learning models for reinforcement learning.
Finally, we build on a long line of work on calibrated prediction, which aims to construct “cali-
brated” probabilities (Murphy, 1972; DeGroot & Fienberg, 1983; Platt, 1999; Zadrozny & Elkan,
2001; 2002; Naeini et al., 2015; Kuleshov & Liang, 2015). Roughly speaking, probabilities are cal-
ibrated if events happen at rates equal to the predicted probabilities. This work has recently been
applied to obtaining confidence estimates for deep neural networks (Guo et al., 2017; Kuleshov
et al., 2018; Pearce et al., 2018), including for learned models for reinforcement learning (Malik
et al., 2019). However, these approaches do not come with PAC guarantees.
2	PAC Confidence Sets
Our goal is to estimate confidence sets that are as small as possible, while simultaneously ensuring
that they are probably approximately correct (PAC) (Valiant, 1984). Essentially, a confidence set is
correct if it contains the true label. More precisely, let X be the inputs and Y be the labels, and let
D be a distribution over Z = X × Y. A confidence set predictor is a function C : X → 2Y such
that C(x) ⊆ Y is a set of labels; we denote the set of all confidence set predictors by C. For a given
example (x, y)〜D, We say C is correct if y ∈ C(x). Then, the error of C is
L(C)
=P(χ,y)〜D[y 6∈C(x)].	(1)
Finally, consider an algorithm A that takes as input a validation set Zval ⊆ Z consisting of n i.i.d.
samples (x, y)〜D, and outputs a confidence set predictor C. Given e, δ ∈ R>o, we say that A is
probably approximately correct (PAC) if
PZval〜Dn IL(C) > e where C = A(Zval)] < δ.	⑵
Our goal is to design an algorithm A that satisfies (2) while constructing confidence sets C(x) that
are as “small in size” as possible on average. The size of C(x) depends on the domain. For classifi-
cation, we consider confidence sets that are arbitrary subsets of labels C(x) ⊆ Y = {1, ..., Y }, and
we measure the size by |C(x)| ∈ N—i.e., the number of labels in C(x). For regression, we consider
confidence sets that are intervals C(x) = [a, b] ⊆ Y = R, and we measure size by b - a—i.e., the
length of the predicted interval. Note that there is an intrinsic tradeoff between satisfying (2) and
average size of C(x)—larger confidence sets are more likely to satisfy (2).
3	PAC Algorithm for Confidence Set Construction
Our algorithm is formulated in the empirical risk framework. Typically, this framework refers to
empirical risk minimization. In our setting, such an algorithm would take as input (i) a parametric
family of confidence set predictors C = {Cθ | θ ∈ Θ}, where Θ is the parameter space, and (ii) a
training set Zval ⊆ Z of n i.i.d. samples (x, y)〜D, and output the confidence set predictor C^,
where θ minimizes the empirical risk:
∕Λ	♦2 / C 厂7	∖
θ = argminL(Cθ; Zval)
θ∈Θ
where	Lc ZVal) = I X	I[y∈ C(x)].
(x,y)∈Zval
Here, I[φ] ∈ {0, 1} is the indicator function, and the empirical risk L in an estimate of the confidence
set error (1) based on the validation set Zval.
However, our algorithm does not minimize the empirical risk. Rather, recall that our goal is to
minimize the size of the predicted confidence sets given a PAC constraint on the true risk L(θ)
based on the given PAC parameters , δ ∈ R>0 and the number of available validation samples
n = |Zval|. Thus, the risk shows up as a constraint in the optimization problem, and the objective is
instead to minimize the size of the predicted confidence sets:
θ = arg min S(θ) subj. to L(Cθ; ZVal) ≤ α.	(3)
θ∈Θ
4
Published as a conference paper at ICLR 2020
At a high level, the value α = α(n, , δ) ∈ R≥0 is chosen to enforce the PAC constraint, and
is based on generalization bounds from statistical learning theory (Valiant, 1984). Furthermore,
following the temperature scaling approach (Platt, 1999), the parameter space Θ is chosen to be as
small as possible (in particular, one dimensional) to enable good generalization. Finally, our choice
of size metric S follows straightforwardly based on our choice of parameter space. In the remainder
of this section, we describe the choices of (i) parameter space Θ, (ii) size metric S(θ), and (iii)
confidence level α(n, , δ) in more detail, as well as how to solve (3) given these choices.
3.1 CHOICE OF PARAMETER SPACE Θ
Probability forecasters. Our construction of the parameteric family of confidence set predictors Cθ
assumes given a probability forecaster f : X → PY, where PY is a space of probability distributions
over Y. Given such an f, we use f (y | x) to denote the probability of label y under distribution
f (x). Intuitively, f (y | x) should be the probability (or probability density) that y is the true label
for a given input X—i.e., f (y | x) ≈ P(χ,γ)〜D [Y = y | X = x]. For example, in classification, We
can choose PY to be the space of categorical distributions over Y , and f may be a neural network
Whose last layer is a softmax layer With |Y | outputs. Then, f(y | x) = f(x)y. Alternatively, in
regression, We can choose PY to be the space of Gaussian distributions, and f may be a neural
network whose last layer outputs the values (μ, σ) ∈ R X R>o of a Gaussian distribution. Then,
f (y | x) = N(x; μ(x), σ(x)2), where (μ(x),σ(x)) = f (x), andN(∙; μ, σ2) is the Gaussian density
function with mean μ and variance σ2.
Training a probability forecaster. To train a probability forecaster, we use a standard approach
to calibrated prediction that combines maximum likelihood estimation with temperature scaling. 2
First, we consider a parametric model family F = {fφ | φ ∈ Φ}, where Φ is the parameter space.
Note that Φ can be high-dimensional—e.g., the weights ofa neural network model. Given a training
set Ztrain ⊆ Z of m i.i.d. samples (x, y)〜 D, the maximum likelihood estimate (MLE) of φ is
φ = arg min '(Φ; Ztrain)	where	'(φ; Ztrain) = — E log fφ(y | x)∙	(4)
φ∈Φ	(x,y)∈Ztrain
I-V T	1 1	f	. 1	FF ∙1 ∙ . i'	.	T T	. 1	Λ 1	∙ . Λ 1 ∙	.1	♦	7 ∙ .)
We could now use f$ as the probability forecaster. However, the problem with directly using φ is that
because φ may be high-dimensional, it often overfits the training data Ztrain. Thus, the probabilities
are typically overconfident compared to what they should be.
To reduce their confidence, we use the temperature scaling approach to calibrate the predicted
probabilities (Platt, 1999; Guo et al., 2017). Intuitively, this approach is to train an MLE estimate
using exactly the same approach used to train φ, but using a single new parameter τ ∈ R>0 . The
key idea is that this time, the model family is based on the parameters φ from (4). In other words,
the “shape” of the probabilities forecast by f^ are preserved, but their exact values are shifted.
More precisely, consider the model family F0 = {f^ T | T ∈ R>o}, where
φ,τ
fφ,τ(y |X) (X eχp (Tlog fφ(y | x)).
Then, we have the following MLE for τ :
T = arg min '0(τ; Ztrain)
τ ∈R>0
where	'0(τ； Ztrain) = - E	log fφ,τ (y | x).
(x,y)∈Zt0rain
(5)
Note that T is estimated based on a second training set Ztrain. Because we are only fitting a single
parameter, this training set can be much smaller than the training set Ztrain used to fit φ.
Parametric family of confidence set predictors. Finally, given a probability forecaster f, we con-
sider one dimensional parameter space Θ = R; in an analogy to the temperature scaling technique
for calibrated prediction, we denote this parameter by T ∈ Θ. In particular, we assume a confidence
probability predictor f is given, and consider
CT (x) = {y ∈ Y | f(y | x) ≥ e-T}.
2A priori, it is not obvious that using temperature scaling can improve our confidence set predictor; we give
a detailed discussion in Appendix A.1.
5
Published as a conference paper at ICLR 2020
In other words, CT (x) is the set of y with high probability given x according to f. Considering this
1	.	1	..1	∙	∙	r∙ ∕c∖ F rr∖
scalar parameter space, we denote the minimum of (3) by T .
3.2	CHOICE OF SIZE METRIC S(T)
To choose the size metric S(T), we note that for our chosen parametric family of confidence set
predictors, smaller values correspond to uniformly smaller confidence sets—i.e.,
T ≤ T0 ⇒ ∀x, CT (x) ⊆ CT 0 (x).
Thus, we can simply choose the size metric to be
S(T) = T.	(6)
This choice minimizes the size of the confidence sets produced by our algorithm.
3.3	CHOICE OF CONFIDENCE LEVEL α(n, , δ)
Naive approach based on VC generalization bound. A naive approach to choosing α(n, , δ) is
to do so based on the VC dimension generalization bound (Vapnik, 1999). It is not hard to show
that the problem of estimating T is equivalent to a binary classification problem, and that the VC
dimension of Θ for this problem is 1. Thus, the VC dimension bound implies that for all T ∈ Θ,
PZval〜Dn L(CT) ≤ L(CT； Zval) + rlθg(2n) + n- log®4) ≥ 1 - δ.	⑺
The details of this equivalence are given in Appendix B.2. Then, suppose we choose
α(n, e, δ) = e -
log(2n) + 1 - log(δ∕4)
With this choice, for the solution T of (3) with a
n
α(n, , δ), the constraint in (3) ensures that
L(CT； Zval) ≤ α(n, e, δ). Together with the VC generalization bound (7), We have
PZVal〜Dn [L(CT^) > e] < δ,
which is exactly desired the PAC constraint on our predicted confidence sets.
Direct generalization bound. In fact, we can get better choices of α by directly bounding general-
ization error. For instance, in the realizable setting (i.e., we always have L(CT； Zval) = 0), we can
get rates of n = O(1∕e) instead of n = O(1∕e2) (Kearns & Vazirani, 1994); see Appendix A.2 for
details. We can achieve these rates by choosing α = 0, but then, the PAC guarantees we obtain may
actually be stronger than desired (i.e., for e0 < e). Intuitively, we can directly prove a bound that
interpolates between the realizable setting and the VC generalization bound—in particular:
Theorem 1. For any e ∈ [0, 1], n ∈ N>0, and k ∈ {0, 1, ..., n}, we have
PZVaLDn [L(Ct) > e] ≤ XX (n)ei(1 - e)n-i,
i=0	i
where T is the solution to (3) with α = k/n. 3
We give a proof in Appendix B.2. Based on Theorem 1, we can choose
α(n, e, δ) = max k∕n subj. to X nei(1 - e)n-i < δ.	(8)
k∈N∪{0}	i=0 i
3.4	Theoretical Guarantees
We have the following guarantee, which follows straightforwardly from Theorem 1:
Corollary 1. Let T be the solution to (3)for α = α(n, e, δ) chosen according to (8). Then, we have
PZval〜Dn [L(CT) > e] < δ∙
In other words, our algorithm is probably approximately correct.
3The theorem statement relies on additional standard technical conditions; see Appendix B.1.
6
Published as a conference paper at ICLR 2020
Algorithm 1 Algorithm for solving (3).
procedure ESTIMATECONFIDENCESETPREDICTOR(Ztrain, Zt0rain, Zval)
Estimate φ, T using (4) and (5), respectively
Compute α(n, , δ) according to (8) by enumerating k ∈ {0, 1, ..., n}
Let k* = n ∙ α(n, e, δ) (note that k ∈ {0,1,…,n})
Sort (x, y) ∈ Zval in ascending order of f^^(y | x)
Let (χk* + ι, yk*+ι) be the (k + 1)st element in the sorted Zval
Solve (3) by choosing T = - log f^,τ(yk* + ι | xk* + ι)
Return CT : x →{y ∈ Y | f^,τ(y | x) ≥ e-T}
end procedure
3.5	Practical Implementation
Our algorithm for estimating a confidence set predictor CT is summarized in Algorithm 1. The
algorithm solves the optimization problem (3) using the choices ofΘ, S(T), and α(n, , δ) described
in the preceding sections. There are two key implementation details that we describe here.
Computing α(n, , δ). To compute α(n, , δ), we need to solve (8). A straightforward approach is to
enumerate all possible choices ofk ∈ {0, 1, ..., n}. There are two optimizations. First, the objective
is monotone increasing in k, so we can enumerate k in ascending order until the constraint no longer
holds. Second, rather than re-compute the left-hand side of the constraint Pk=o (，)ei(1 - e)n-i,
we can accumulate the sum as we iterate over k. We can also incrementally compute ni , i , and
(1 - )n-i. For numerical stability, we perform these computations in log space.
Solving (3). To solve (3), note that the constraint in (3) is equivalent to
X	E(x,y;	T)	≤ n∙α(n,e, δ)	where	E(x,y;	T)= I	hfφ,τ(y	|	x)	<	e-1 .	(9)
(x,y)∈Zval
Also, note that k = n ∙ α(n, e, δ) is an integer due to the definition of α(n, e, δ) in (8). Thus, We
can interpret (9) as saying that E(x, y; T) = 1 for at most k of the points (x, y) ∈ Zval.
In addition, note that E(x, y; T) decreases monotonically as f^τ(y | x) becomes larger. Thus, we
can sort the points (x, y) ∈ ZVal in ascending order of f^τ(y | x), and require that only the first k
points (x, y) in this list satisfy E(x, y; T) = 1. In particular, letting (xk* + ι, yk*+ι) be the (k* + 1)st
point, (9) is equivalent to
fφ,τ(yk* + 1 | xk* + 1) ≥ e-T.	(IO)
In other words, this constraint says that T must satisfy yk*+ι ∈ CT(xk* + ι). Finally, the solution T
to (3) is the smallest T that satisfies (10), which is the T that makes (10) hold with equality—i.e.,
T = - log fφ,τ(yk*+ι I xk*+ι).	(11)
We have assumed f^τ(yk* + ι I xk*+ι) > f^τ(yk* I xk*); if not, we decrement k* until this holds.
3.6	Probability Forecasters for Specific Tasks
We briefly discuss the architectures we use for probability forecasters for various tasks. We give
details, including how we measure the sizes of predicted confidence sets CT (x), in Appendix C.
We consider three tasks: classification, regression, and model-based reinforcement learning. For
classification, we use the standard approach of using a soft-max layer to predict label probabilities
f(y I x). For regression, we also use a standard approach where the neural network predicts both
the mean μ(x) and covariance Σ(x) of a Gaussian distribution N(μ(x), Σ(x)); then, f (y ∣ x)=
N(y; μ(x), ∑(x)) is the probability density of y according to this Gaussian distribution.
Finally, for model-based reinforcement learning, our goal is to construct confidence sets over
trajectories predicted using a learned model of the dynamics. We consider unknown dynamics
7
Published as a conference paper at ICLR 2020
1000
α,z-sφjα,s .=0。α,z 一 S ⅛0u
800
600
400
D
C+D
IOOO
800
600
400
200
incorrect
correct
200
0
(c)
1000
(b)
800
600
400
200
IoT
10~1
(d)
0
0
Figure 1: Results on ResNet for ImageNet with n = 20000. Default parameters are = 0.01
and δ = 10-5 . We plot the median and min/max confidence set sizes. (a) Ablation study; C is
“calibrated predictor” (i.e., use fφ T instead of fφ), and D is “direct bound” (i.e., use Theorem 1
instead of the VC generalization bound). (b) Restricted to correctly vs. incorrectly labeled images.
(c) Varying . (d) Varying δ .
g* (χ0 | x, U) mapping a state-action pair (x, U) to a distribution over states χ0, and consider a known
(and fixed) policy π(u | x) mapping a given state x to a distribution over actions u ∈ U ⊆ RdU .
Then, We let f *(χ0 | x) = E∏(u∣χ)[g*(χ0 | u)] denote the (unknown) closed-loop dynamics.
Next, we consider a forecaster f (χ0 | x) ≈ f *(χ0 | x) of the form f (x0 | x) = N(x0; μ(χ), Σ(χ)),
and our goal is to construct confidence sets for the predictions of f . However, we want to do so for
not just for one-step predictions, but for predictions over a time horizon H ∈ N. In particular, given
initial state xo ∈ X, we can sample x；：H = (xι,…，XH)〜f * by letting x∩ = x° and sequentially
sampling x*+1 〜f ( ∙ | x*) for each t ∈ {0,1,…,H - 1}. Then, our goal is to construct a
confidence set that contains x1*:H ∈ XH with high probability (over both the randomness in an
initial state distribution xo 〜do and the randomness in f *).
To do so, we construct and use a forecaster f (x1:H | xo) based on f. In principle, this task is
a special case of multivariate regression, where the inputs are X (i.e., the initial state xo) and the
outputs are Y = XH (i.e., a predicted trajectory x1:H). However, the variance Σ(x) predicted by
our probability forecaster is only for a single step, and does not take into account the fact that x is
itself uncertain. Thus, we use a simple heuristic where we accumulate variances over time. More
precisely, we construct (i) the predicted mean x±H = (x1,..., XH) by xo = xo and xt+ι = μ(xt)
for t ∈ {0,1,..., H - 1}, and (ii) the predicted variances Σ±H = (∑ι,…，∑h) by
∑ t = Σ(x°) + Σ(xι) + …+ Σ(xt-1).
We use a probability forecaster f (xi：H | xo) = N(xi：H; xi：H, ∑i:H) to construct confidence sets.
4	Experiments
We describe our experiments on ImageNet (a classification task), a visual object tracking benchmark
(a regression task), and the half-cheetah environment (a model-based reinforcement learning task).
We give additional results in Appendix D.
8
Published as a conference paper at ICLR 2020
(a)	(b)	(c)
Figure 2: Confidence set sizes for an object tracking benchmark (Wu et al., 2013); we use n =
5, 000, = 0.01, and δ = 10-5. (a) Ablation study similar to Figure 3. In (b) and (c), we show how
the confidence set sizes produced using our algorithm vary with respect to and δ, respectively.
ResNet for ImageNet. We use our algorithm to compute confidence sets for ResNet (He et al., 2016)
on ImageNet (Russakovsky et al., 2015), for = 0.01, δ = 10-5, and n = 20000 validation images.
We show the results in Figure 1. In (a), we compare our approach to an ablation. In particular,
C refers to performing an initial temperature scaling step to calibrate the neural network predictor
(i.e., using f^ instead of f^ ʌ), and (ii) D refers to using Theorem 1 instead of the VC generalization
φ	φ,τ
bound. Thus, C + D refers to our approach. As can be seen, using calibrated predictor produces a
noticeable reduction in the maximum confidence set size.
We also compared to the ablation C—i.e., using the VC generalization bound. However, we were
unable to obtain valid confidence sets for our choice of e and δ—i.e., (3) is infeasible. That is, using
Theorem 1 outperforms using the VC generalization bound since the VC bound is too loose to satisfy
the PAC criterion for our choice of parameters. In addition, in Table 6 in Appendix D, we show
results for larger choices of e and δ; these results show that our approach substantially outperforms
the ablation based on the VC bound even when the VC bound produces valid confidence sets.
In (b), we show the confidence set sizes for images correctly vs. incorrectly labeled by ResNet. As
expected, the sizes are substantially larger for incorrectly labeled images. Finally, in (c) and (d), we
show how the sizes vary with e and δ, respectively. As expected, the dependence on e is much more
pronounced (note that δ is log-scale).
Visual object tracking. We apply our confidence set prediction algorithm to a 2D visual single-
object tracking task, which is a multivariate regression problem. Specifically, the input space X
consists of the previous image, the previous bounding box (in R4), and the current image. The
output space Y = R4 is a current bounding box. We use the regression-based tracker from Held
et al. (2016), and retrain the regressor neural network to predict the mean and variance ofa Gaussian
distribution. More precisely, our object tracking model predicts the mean and variance of each
bounding box parameter-i.e., (xmin, ymin, Xmax, ymax). Given this bounding box forecaster f^, We
calibrate and estimate a confidence set predictor as described in Section 3.6.
We use the visual object tracking benchmark from Wu et al. (2013) to train and evaluate our con-
fidence set predictor. This benchmark consists of 99 video sequences labeled With ground truth
bounding boxes. We randomly split these sequences to form the training set for calibration, valida-
tion set for confidence set estimation, and test set for evaluation. For each sequence, a pair of tWo
adjacent frames constitute a single example. Our training dataset contains 20,882 labeled examples,
each consisting ofofa pair of consecutive images and ground truth bounding boxes. The validation
set for confidence set estimation and test set contain 22,761 and 22,761 labeled examples, respec-
tively. Figure 2 shoWs the sizes of the predicted confidence sets; the sizes are measured as described
in Section 3.6 for regression tasks. As for ResNet, We omit results for the VC bound ablation since
n is too small to get a bound. The trends are similar to the ones for ResNet.
Half-cheetah. We use our algorithm to compute confidence sets for a probabilistic neural netWork
dynamics model (Chua et al., 2018) for the half-cheetah environment (Brockman et al., 2016), for
e = 0.01, δ = 10-5, H = 20 time steps, and n = 5000 validation rollouts. When using temperature
scaling to calibrate f^ to obtain f^ ʌ, we calibrate each dimension of time steps independently (i.e.,
φ	φ,τ
we fit H parameters, where H is time horizon). We show the results in Figure 3.
9
Published as a conference paper at ICLR 2020
41B52953O
^r^r-u--u--u-oooo
Wwwwwiiii
a-8S—60Dz-s WS .juoɔ
C+D	A+D A+C+D
102* -
1Om
10»
10lβ
1012.
10*
(-euφ6OD ΦN-W4jωs
5	10	15
Time step
10*
10«
Figure 3: Results on the dynamics model for the half-cheetah with n = 5000. Default parameters
are = 0.01 and δ = 10-5. (a) Ablation study; A is “accumulated variance” (i.e., for each t ∈
{1,…，20}, use ∑t instead of ∑t = Σ(xt-ι)), and C and D are as for ResNet. We plot the median
and min/max confidence set sizes (see Section 3.6), averaged across t ∈ {1, ..., 20}. (b) Same
ablations, but with per time step size. We plot the average size of the confidence set for the predicted
state xt on step t, as a function oft ∈ {1, ..., 20}. (c) Varying , and (d) varying δ.
In (a), we compare to two ablations. The labels C and D are as for ResNet; in addition, A refers to
using the accumulated variance ∑t instead of the one-step predicted variances ∑t = ∑(χt-ι). Thus,
A + C + D is our approach. As before, we omit results for the ablation using the VC generalization
bound since n is so small that the bound does not hold for any k for the given and δ . In (b), we
show the same ablations over the entire trajectory until t = 20. As can be seen, using the calibrated
predictor produces a large gain; these gains are most noticeable in the tails. Using the accumulated
confidence produces a smaller, but still significant, gain. In (c) and (d), we show how the sizes vary
with and δ, respectively. The trends are similar those for ResNet.
5 Conclusion
We have proposed an algorithm for constructing PAC confidence sets for deep neural networks.
Our approach leverages statistical learning theory to obtain theoretical guarantees on the predicted
confidence sets. These confidence sets quantify the uncertainty of deep neural networks. For in-
stance, they can be used to inform safety-critical decision-making, and to ensure safety with high-
probability in robotics control settings that leverage deep neural networks for perception. Future
work includes extending these results to more complex tasks (e.g., structured prediction), and han-
dling covariate shift (e.g., to handle policy updates in reinforcement learning).
Acknowledgments
This work was support in part by NSF CCF-1910769 and by the Air Force Research Laboratory
and the Defense Advanced Research Projects Agency under Contract No. FA8750-18-C-0090. Any
opinions, findings and conclusions or recommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Air Force Research Laboratory (AFRL), the
Defense Advanced Research Projects Agency (DARPA), the Department of Defense, or the United
States Government.
10
Published as a conference paper at ICLR 2020
References
Rina Foygel Barber, Emmanuel J Candes, Aaditya Ramdas, and Ryan J Tibshirani. Predictive
inference with the jackknife+. arXiv preprint arXiv:1905.02928, 2019.
Felix Berkenkamp, Matteo Turchetta, Angela Schoellig, and Andreas Krause. Safe model-based
reinforcement learning with stability guarantees. In Advances in neural information processing
systems,pp. 908-918, 2017.
Marko Bohanec and Vladislav Rajkovic. Knowledge acquisition and explanation for multi-attribute
decision making. In 8th Intl Workshop on Expert Systems and their Applications, 1988.
Christopher P Bonafide, A Russell Localio, John H Holmes, Vinay M Nadkarni, Shannon Stemler,
Matthew MacMurchy, Miriam Zander, Kathryn E Roberts, Richard Lin, and Ron Keren. Video
analysis of factors associated with response time to physiologic monitor alarms in a childrens
hospital. JAMA pediatrics, 171(6):524-531, 2017.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym. arXiv preprint arXiv:1606.01540, 2016.
Kurtland Chua, Roberto Calandra, Rowan McAllister, and Sergey Levine. Deep reinforcement learn-
ing in a handful of trials using probabilistic dynamics models. In Advances in Neural Information
Processing Systems, pp. 4754-4765, 2018.
Paulo Cortez and Alice Maria Goncalves Silva. Using data mining to predict secondary school
student performance. 2008.
Morris H DeGroot and Stephen E Fienberg. The comparison and evaluation of forecasters. Journal
of the Royal Statistical Society: Series D (The Statistician), 32(1-2):12-22, 1983.
Christophe Denis and Mohamed Hebiri. Confidence sets with expected sizes for multiclass classifi-
cation. The Journal of Machine Learning Research, 18(1):3571-3598, 2017.
Yarin Gal, Riashat Islam, and Zoubin Ghahramani. Deep bayesian active learning with image data.
In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pp. 1183-
1192. JMLR. org, 2017.
Chuan Guo, Geoff Pleiss, Yu Sun, and Kilian Q Weinberger. On calibration of modern neural
networks. arXiv preprint arXiv:1706.04599, 2017.
H Altay Guvenir, Burak Acar, Gulsen Demiroz, and Ayhan Cekin. A supervised machine learning
algorithm for arrhythmia analysis. In Computers in Cardiology 1997, pp. 433-436. IEEE, 1997.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition
(CVPR), pp. 770-778, 2016.
David Held, Sebastian Thrun, and Silvio Savarese. Learning to track at 100 fps with deep regression
networks. In European Conference on Computer Vision, pp. 749-765. Springer, 2016.
Michael J Kearns and Umesh Virkumar Vazirani. An introduction to computational learning theory.
MIT press, 1994.
Alex Krizhevsky. One weird trick for parallelizing convolutional neural networks. arXiv preprint
arXiv:1404.5997, 2014.
Volodymyr Kuleshov and Percy S Liang. Calibrated structured prediction. In Advances in Neural
Information Processing Systems, pp. 3474-3482, 2015.
Volodymyr Kuleshov, Nathan Fenner, and Stefano Ermon. Accurate uncertainties for deep learning
using calibrated regression. arXiv preprint arXiv:1807.00263, 2018.
Jing Lei. Classification with confidence. Biometrika, 101(4):755-769, 2014.
11
Published as a conference paper at ICLR 2020
Jing Lei, Max GSell, Alessandro Rinaldo, Ryan J Tibshirani, and Larry Wasserman. Distribution-
free predictive inference for regression. Journal of the American Statistical Association, 113
(523):1094-1111,2018.
Ali Malik, Volodymyr Kuleshov, Jiaming Song, Danny Nemer, Harlan Seymour, and Stefano Er-
mon. Calibrated model-based deep reinforcement learning. In International Conference on Ma-
chine Learning, pp. 4314-4323, 2019.
Allan H Murphy. Scalar and vector partitions of the probability score: Part i. two-state situation.
Journal of Applied Meteorology, 11(2):273-282, 1972.
Mahdi Pakdaman Naeini, Gregory Cooper, and Milos Hauskrecht. Obtaining well calibrated prob-
abilities using bayesian binning. In Twenty-Ninth AAAI Conference on Artificial Intelligence,
2015.
Harris Papadopoulos. Inductive conformal prediction: Theory and application to neural networks.
In Tools in artificial intelligence. IntechOpen, 2008.
T Pearce, M Zaki, A Brintrup, and A Neely. High-quality prediction intervals for deep learning: A
distribution-free, ensembled approach. In 35th International Conference on Machine Learning,
ICML 2018, volume 9, pp. 6473-6482, 2018.
John Platt. Probabilistic outputs for support vector machines and comparisons to regularized likeli-
hood methods. Advances in large margin classifiers, 1999.
J Ross Quinlan. Combining instance-based and model-based learning. In Proceedings of the Tenth
International Conference on International Conference on Machine Learning, pp. 236-243. Mor-
gan Kaufmann Publishers Inc., 1993.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, et al. Imagenet large scale visual
recognition challenge. International journal of computer vision, 115(3):211-252, 2015.
Lukas Steinberger and Hannes Leeb. Leave-one-out prediction intervals in linear regression models
with many variables. arXiv preprint arXiv:1602.05801, 2016.
Lukas Steinberger and Hannes Leeb. Conditional predictive inference for high-dimensional stable
algorithms. arXiv preprint arXiv:1809.01412, 2018.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfel-
low, and Rob Fergus. Intriguing properties of neural networks. In International Conference on
Learning Representations (ICLR), 2014.
Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Du-
mitru Erhan, Vincent Vanhoucke, and Andrew Rabinovich. Going deeper with convolutions. In
Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 1-9, 2015.
Leslie G Valiant. A theory of the learnable. Communications of the ACM, 27(11):1134-1142, 1984.
Vladimir N Vapnik. An overview of statistical learning theory. IEEE transactions on neural net-
works, 10(5):988-999, 1999.
Vladimir Vovk. Conditional validity of inductive conformal predictors. Machine learning, 92(2-3):
349-376, 2013.
Wenbo Wang and Xingye Qiao. Learning confidence sets using support vector machines. In Ad-
vances in Neural Information Processing Systems, pp. 4929-4938, 2018.
Yi Wu, Jongwoo Lim, and Ming-Hsuan Yang. Online object tracking: A benchmark. In IEEE
Conference on Computer Vision and Pattern Recognition (CVPR), 2013.
Bianca Zadrozny and Charles Elkan. Obtaining calibrated probability estimates from decision trees
and naive bayesian classifiers. In In Proceedings of the Eighteenth International Conference on
Machine Learning. Citeseer, 2001.
12
Published as a conference paper at ICLR 2020
Bianca Zadrozny and Charles Elkan. Transforming classifier scores into accurate multiclass proba-
bility estimates. In Proceedings of the eighth ACM SIGKDD international conference on Knowl-
edge discovery and data mining, pp. 694-699. ACM, 2002.
Chiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals. Understanding
deep learning requires rethinking generalization. In ICLR, 2017.
13
Published as a conference paper at ICLR 2020
A Discussion of Algorithm Design Choices
A. 1 Usefulness of Temperature Scaling
In this section, we discuss why temperature scaling can help improve the predicted confidence sets.
A concern is that temperature scaling does not change the ordering of label probabilities. Thus, we
may expect that temperature scaling does not affect the predicted confidence sets. However, this
fact only holds when considering a single input x—i.e., the ordering of the probabilities p(y | x)
for y ∈ Y is not changed by temperature scaling. Indeed, the order of confidences for labels for
different inputs can change. For a concrete example, consider two inputs x and x0, and the case
Y = {0, 1, 2}. Assume that the label probabilities are
f ( ∙ | x) = [1/3 1/3 1∕3]>
f ( ∙ | x0) = [3∕4 1/4 0]>.
Now, if we take temperature τ very large, then the labels become roughly
fτ( ∙ | x) = [1/3 1/3 1∕3]>
fτ( ∙ | x0) = [1/2 1/2 0]>.
As a consequence, there are confidence sets that are achievable when using fτ that are not achievable
when using f. In particular, the confidence sets
CT(X) = 0
CT(x0) = {0, 1}
can be achieved using fτ (e.g., with e-T = 2/5). However, it is impossible to achieve these
confidence sets using f for any choice of T, since if 1 ∈ CT (x0), then it must be the case that
CT (x) = {0, 1, 2}. Intuitively, we expect calibrated prediction to improve the ordering of probabili-
ties across different inputs. Our experiments support this intuition, since they show that empirically,
using calibrated predictors fτ produces confidence sets of smaller size.
A.2 Usefulness of Direct Bound
One key design choice is to use a specialized generalization bound that directly provides PAC guar-
antees on our confidence sets rather than simply applying the VC dimension bound. The easiest way
to determine which bound is better is to examine which one produces a smaller confidence set. In our
approach, the size of the confidence set decreases monotonically with the choice of α = α(n, , δ) in
(3). Thus, the bound that produces larger α is better. Recall that the VC dimension bound produces
αVC(n, , δ)
log(2n) + 1 - log(6/4)
n
-
whereas our direct bound produces (for k = 0)
αdirect(n, , δ) = max k/n subj. to X n i(1 - )n-i < δ.
Directly comparing these two choices of α is difficult, but our experiments show empirically that
using the direct bound outperforms using the indirect bound.
A more direct way to compare the two approaches is to instead ask how large n needs to be to
achieve α(n, , δ) = 0. For αVC, it is easy to check that we need
n ≥ lOg(2n)+ 12+lOg(40
2
Thus, We need n to be at least O(log(1/6)/c2) (and possibly greater, to account for the log(2n)
term). In contrast, for our direct bound, α = 0 corresponds to the case k = 0. To achieve k = 0, it
suffices to have n satisfying (1 - )n < δ. Using (1 - )n ≤ e-n, it suffices to have n satisfying
n ≥ log(1∕δ)
14
Published as a conference paper at ICLR 2020
Figure 4: Sample complexity of different bounds; we fix δ = 10-5. Left: Sample complexity ofVC
bound and direct bound when k = 0. Right: Sample complexity of direct bound for varying k.
In other words, n only needs to be O(log(1∕δ)∕e). For small e (e.g., e = 0.01), We need 100×
fewer samples to achieve the same size confidence set (i.e., with choice α(n, , δ) = 0). In Figure 4
(right), we compute the exact values of n needed to get α(n, e, δ) = 0 as a function of e for each
bound (fixing δ = 10-5). As expected, our bound requires substantially smaller n.
Finally, in Figure 4 (right), we compare the magnitude of n needed to achieve larger values of α
using our direct bound; for simplicity, we actually consider larger values of k (where α = k/n), but
the qualitative insights are the same. As can be seen, even for large k, (e.g., k = 50), the number of
samples increases, but not substantially.
B	Theoretical Guarantees
B.1	Assumptions
We make two additional technical assumptions in Theorem 1, both of which are standard. First, we
assume that f is measurable; this assumption holds for all models used in practice, including neural
networks (e.g., it holds as long as f is continuous).
Second, letting φ : Z → R, where Z = X × Y, be defined by φ((x, y)) = - log f(y | x), we
assume that the distribution DD induced by φ on R has continuous cumulative distribution function
(CDF). More precisely, letting μ° be the measure defining D, then D is defined by the measure
μD(t) = μD (O-I(U),
where φ-1 : R → 2Z is the inverse of φ in the sense that z ∈ φ-1(φ(z)) for all z ∈ Z. Then,
we assume that the CDF corresponding to D is continuous. This second assumption is standard in
statistical learning theory (Kearns & Vazirani, 1994). Essentially, it says that for any t ∈ R, the
probability that t = - log f(y | x) must equal zero. This assumption should hold unless p(x, y) or
f(y | x) are degenerate in some way. Furthermore, we can detect this case. In particular, the failure
mode corresponds to the case that we see multiple points with the same value - log f(y | x). Thus,
choosing T= - log f (y | x) would include all these points, so the realized error rate α is larger
than desired for T . In this case, we can simply choose a slightly larger T to avoid this problem.
B.2	Proof of Theorem 1
At a high level, our proof proceeds in three steps. First, we show that a confidence set predictor CT
can be encoded as a binary classifier MT . Second, we show that a PAC bound for MT implies a
PAC bound for CT (where in both cases, the unknown parameter is T ∈ R). Third, we prove PAC
bounds on the error of MT; by the second step, these bounds complete our proof.
Encoding CT as a binary classifier MT. We begin by showing how the problem of learning aPAC
confidence set predictor CT reduces to the problem of learning a PAC binary classifier MT. First,
we show that for any T ∈ R, the confidence set predictor CT can be encoded as a binary classifier
MT. Consider any parameter T ∈ Θ = R. Recall that we use the model f(y | x) to construct the
confidence set predictor
CT (x) = {y ∈ Y | f(y | x) ≥ e-T}.
15
Published as a conference paper at ICLR 2020
Now, define the map φ : Z → R by φ(x, y) = - log f(y | x), where Z = X × Y, and define the
binary classifier MT : R → {0, 1} by
MT (t) = I[t ≤ T].
Here, I[s] is the indicator function, which returns one if a statement s is true and zero otherwise. We
claim that
CT (x) = {y ∈ Y | MT (φ(x, y)) = 1}.
(12)
To see this claim, note that
CT (x) = {y
= {y
= {y
= {y
= {y
∈
∈
∈
∈
∈
Y
Y
Y
Y
Y
f(y | x) ≥ e-T}
- log f(y | x) ≤ T}
φ(x, y) ≤ T}
I[φ(x, y) ≤T] =1}
MT (φ(x, y)) = 1},
as claimed.
PAC bound for MT implies PAC bound for CT. Next, we show that a PAC bound for MT implies
a PAC bound for CT . More precisely, we design a data distribution D and loss `, and show that (i)
the distribution of T (trained to optimize MT) is the same as the distribution ofT (constructed using
our algorithm), and (ii) a PAC bound for MT (where T is trained on data from D) implies a PAC
bound for CT. We show that as a consequence, a PAC bound on MT implies a PAC bound on CT.
We begin by constructing D and `. To this end, recall that D is a given distribution over X × Y .
We define a data distribution D over X × Y, where X = R and Y = {0, 1}, as follows. The
first component of D is the distribution over X induced by φ from D, and the second component
is the distribution over Y that places all probability mass on 1. Formally, D exists assuming φ is
measurable, so the induced distribution exists; for all our choices off (i.e., categorical or Gaussian),
this property is satisfied. Then,
μD((t,a)) = μD(φ-1(t)) ∙ I[a = 1],
where 小力 is the measure encoding D, and μ0 is the measure encoding D. Furthermore, we define
` : Y × Y → {0, 1} to be the 0-1 loss `(a, a0) = I[a 6= a0]. Finally, let T be chosen using our
algorithm—i.e.,
T = arg min T subj. to L(CT； Z) ≤ α
L(CT; Z) = |Z| ^X I[y ∈ CT(X)],
(x,y)∈Z
1
L(MT; Z) = |Z|
for any α ∈ R≥0, and let T be chosen similarly for MT —i.e.,
T = arg min T subj. to L(MT； Z) ≤ α
X '(Mt(t),a) = ⅛ X I[MtS = a].
|Z|
(t,a)∈Z	1 1 (t,a)∈Z
Now, we show (i) above. In particular, we claim that T(Z) has the same distribution as T(Z), where
_ _______ _ 二 二一 一 一 一. 一 一 — — 一一- 二一-一
Z 〜Dn and Z 〜Dn are random datasets. To this end, define Φ : Zn → Zn by
Φ((z1, ...,zn)) = ((φ(z1), 1), ..., (φ(zn), 1)).
Note that
1n
L(MT；◎(Z)) = ∣φ(Z)∣ J2I[MT(φ(xi,yi)) = 1]
1n
IZI ∑i[yi ∈ CT(χi)]
L(CT=;Z),
16
Published as a conference paper at ICLR 2020
from which it follows that
T(Z) = arg min T subj. to L(CT； Z) ≤ α
=arg min T subj. to L(MT； Φ(Z)) ≤ a
~ , ..
=T(Φ(Z)).
By construction of Φ, the random variables Z and Φ(Z) have the same distribution; thus, it follows
that the random variables T(Z) and T (Φ(Z)) have the same distribution as well. Since T(Z) =
T (Φ(Z)), it follows that T(Z) has the same distribution as T(Z), as claimed.
Next, We show (ii) above. In particular, We claim that a PAC bound for MT(Z)—i.e.,
PZ〜Dn [L(MT(Z)) ≤ e] ≥ 1 - δ,
implies a PAC bound for CT(Z)—ie,
PZ〜Dn [L(CT(Z)) ≤ e] ≥ 1 - δ,
Where the true losses are
~ , -. .. ., - ..
L(Mt )= E(t,a)〜D ['(Mτ(t), a)] = P(t,a)〜D Mτ(t) = a]
L(CT ) = E(x,y)〜D [I[y ∈ CT (X)]] = P(x,y)〜D 位 ∈ CT (X)]∙
Note that it suffices to shoW that the true loss for CT equals the true loss for MT —i.e.,
L(Ct ) = L(Mt ),
since this equation (together with the PAC bound for MT(Z)) implies
PZ〜Dn [L(CT(Z)) ≤ d= PZ〜Dn [L(MT(Z)) ≤ e] ≥ 1 - δ,
as desired. To see the claim, note that
L(Mt )= P(t,a)〜D [Mτ(t) = a]
=/I[Mτ(t) = a]dμD((t, a))
=X I[a = 1] ∙ Z I[Mτ(t) = a]dμD(φ-1(t))
a=0
=/ I[Mτ(t) = 1]dμD (Φ-1 (t))
Now, using the change of variables t 7→ φ(z), we have
L(MT) = /
=Z
I [Mt (Φ(z)) = 1]dμD (z)
I[Mt(φ(x,y)) = 1] ∙ D(x,y)dxdy.
Then, using (12), We have
L(MT) = ∕l[y ∈ CT (x)]D(x, y)dxdy
=P(x,y)〜D [y ∈ CT (x)]
= L(CT),
as claimed.
Finally, combining (i) and (ii), we have
PZ〜Dn[L(CT(Z)) ≤ e] = PZ〜Dn[L(CT(Z)) ≤ e] ≥ 1 - δ,
17
Published as a conference paper at ICLR 2020
where the first equality follows since (i) says that T(Z) (where Z 〜Dn) has the same distribution
as T(Z) (where Z 〜Dn), and the second inequality follows by (ii).
Generalization bound. Finally, We prove the PAC bound
PZ〜Dn [L(Mt) ≤ e] ≥ 1 - δ0,	(13)
for MT, where δo = Pk=。(n)ei(1 - e)n-i; for conciseness, We have dropped the dependence
of T on Z. By the previous step, this bound implies the theorem statement. To this end, we first
simplify the left-hand side of the inequality (13). In particular, let T* be the smallest T for which
L(Mt*) = e; such a T* exists by our assumption that D has continuous density function.
First, We claim that T < T* implies L(MT) > L(MT*). Assuming T < T*, then
~ , - ,.
L(Mt )= P(3 〜D [Mt (t) = a]
=E(t,α)〜D [I[MT⑴=a]
=E(t,α)〜D [I[MT (t) = 1]]
=E(t,a)〜D [I[I[t ≤ T] = 1]]
=E(t,a)〜D [I[t>T]]
> E(t,a)〜D [I[t > T*]]
=L(MT*).
Assuming T ≥ T*, we can similarly show that L(MT) ≤ L(MT*). It follows that
PZ〜Dn [L(Mt) >e] = PZ〜Dn [L(Mt) > L(MT*)]
=PZ〜Dn [t < T*].
As a consequence, (13) is equivalent to
PZ〜Dn [t < T*] ≤ δ0.
Next, recall that T must satisfy L(MT； Z) ≤ α, where
1
L(Mt; Z) = - E I[Mt(t) = a].
(t,α)∈Z
Assuming T < T*,and using k = n ∙ α,it follows that
k ≥ ^X i[MT(t) = a] = ^X i[MT(t) =1]
(t,α)∈Z	(t,o)∈Z
=E i[t>T]
(t,α)∈Z
≥ E I[t>T*].
(t,α)∈Z
As a consequence, we have
PZ〜Dn [T < T*] ≤ PZ〜Dn	E I[t >T*] ≤ k
L(t,α)∈Z	_|
k	r	-
=E PZ 〜D n	E I[t>T *] = i .
i=0	1(t,α)∈Zval	_
18
Published as a conference paper at ICLR 2020
By our definition of T*, the event in the final expression Says that the sum of n i.i.d. Bernoulli
random variables I[t > T*]〜Bernoulli(e) is at most k. Thus, this event follows a distribution
Binomial(n, ), so
kk
PZ 〜D n TT <T *] ≤ X BinOmial(i; n, e) = X (：)ei (1 - e)n-i = δ°,
i=0	i=0
as claimed. The theorem statement follows.
C Details on Probability Forecasters for Specific Tasks
In this section, we describe architectures for probability forecasters for classification, regression,
and model-based reinforcement learning.
Classification. For the case Y = {1, ..., Y }, we choose the probability forecaster f to be a neural
network with a softmax output. Then, we can compute a given confidence set
CT(X) = {y ∈ Y | f (y | χ) ≥ e-T}
by explicitly enumerating y ∈ Y. We measure the size of CT (x) as |CT (x)|.
Regression. For the case Y = R, we choose the probability forecaster f to be a neural network that
outputs the parameters (μ, σ) ∈ Y × R>o of a Gaussian distribution. Then, We have
CT(X)= μ - σʌ/2(T - log(σ√2π)), μ + σʌ/2(T - log(σ√2π)).
This choice generalizes to Y = Rd by having f output the parameters (μ, Σ) ∈ Y × S^。(where
Sd0 is the set of d dimensional symmetric positive definite matrices) of a d dimensional Gaussian
distribution. Note that CT(X) is an ellipsoid CT(X) = μ + ΛSd-1, where Λ ∈ Rd×d and Sd-1 is
the unit sphere in Rd; in particular, Λ = D- 1 Q, where QDQ> is the eigendecomposition of
(2T — dln 2π — lndet Σ)-1 ∙ Σ-1.
We measure the size of CT(x) as ∣∣Λ∣∣f, where ∣∣ ∙ ∣∣f is the Frobenius norm.
Model-based reinforcement learning. In model-based reinforcement learning, the goal is to predict
trajectories based on a model of the dynamics. We consider an MDP with states X ⊆ RdX, actions
U ⊆ RdU, an unknown distribution over initial states x。〜d。，and unknown dynamics g* (x0 | x, U)
mapping a state-action pair (X, u) ∈ X × U to a distribution over states X0 ∈ X. We assume a fixed,
known policy π(u | X), mapping a state X ∈ X to a distribution over actions u ∈ U. The (unknown)
closed-loop dynamics are f*(χ0 | x) = E∏(u∣χ)[g*(χ0 | x,u)].
Given initial state x。∈ X and time horizon H ∈ N, we can sample a trajectory x；:H =
(x；,…，xH) 〜 f * by setting x∩ = x。and sequentially sampling xt+1 〜f * ( ∙ I x*) for
t ∈ {0, 1, ..., H -1}. Our goal is to predict a confidence set CT(x。) ⊆ XH that contains x1*:H ∈ XH
with high probability (according to both the randomness in initial states x。〜 d。and in f). This
problem is a multivariate regression problem with inputs X and outputs Y = XH .
We assume given a probability forecaster f (x0 ∣ x) = N(x0; μ(x), Σ(x)) trained to predict the
distribution over next states—i.e., f(x0 | x) ≈ f* (x0 | x). Given initial state x。 ∈ X and time
horizon H ∈ N, we construct the mean trajectory x±H by setting x。= x。and letting xt+ι = μ(xt).
To account for the fact that the variances accumulate over time, we sum them together to obtain the
predicted variances ∑ι∙H—i.e.,
∑ t = ∑(xo) + ∑(xι) + ... + Σ(x⅛-ι).
Then, we use the probability forecast f (xi：H, Σ±H) = N(xi：H, ΣLH) (where we think of xi：H as
a vector in RH∙dX and Σi：H as a block diagonal matrix in R(H∙dX)×(H∙dX)) to construct confidence
sets.
Finally, we describe how we measure the size of a predicted confidence set CT(x。) ⊆ XH. In
particular, note that CT(x。) has the form
CT(x。) = (CT,i(x。), ..., CT,H(x。)),
19
Published as a conference paper at ICLR 2020
」。」」04os .juoɔ
0.0
0.0200-
0.0175-
0.0150
0.0125-
0.0100-
0.0075
0.0050-
0.0025
o.oooo-
(nocal.)
(a)
Q∙8∙64
Iooo
」。」」s .Juoo
naive naive ours
(no cal.)
Ooooo
Ooooo
0 8 6 4 2
α,z - s&s .=0。
naive naive ours
(no cal.)
(b)
4185296rno
10,10,1011011011010101°
Illll
a-8S—60Dss .juoɔ
naive
(no cal.)
naive
ours
(c)	(d)
Figure 5: Comparison to baselines that do not have theoretical guarantees. In (a) and (b), we show
results for ImageNet, and in (c) and (d), we show results for the half-cheetah. In (a) and (c), we
show the empirical error in the confidence set sizes; the dotted line denotes = 0.01, our target
confidence set error. In (b) and (d), we show the sizes of the constructed confidence sets.
i.e., CT,t(x0) is the confidence set for the state xt reached after t time steps. Then, we measure the
size of the confidence set for each component CT,t(x0) (for t ∈ {1, ..., H}) individually, and take
the average. As in the case of regression, Cτ,t(χo) is an ellipsoid Cτ,t(χo) = Xt + AtSdX-1; then,
the size of CT(x0) is H-1 PtH=1 kΛtkF.
An additional detail is that when we calibrate this forecaster, we calibrate each component CT,t(x0)
individually—i.e., we use H calibration parameters τ1, ..., τH.
D	Additional Results
D.1 Comparison to Additional Baselines
We compare to two baselines that do not have theoretical guarantees. We assume given a probability
forecaster f(y | x). Then, given an input x ∈ X, we construct the confidence set to satisfy
X f(y | x) ≥ 1-e.	(14)
y∈C(x)
More precisely, we first rank the labels in decreasing order of f(y | x), to obtain a list
(y1, y2, ..., y|Y|). Then, we choose the smallest k such that (14) holds for C(x) = {y1, ..., yk}.
Intuitively, if the probabilities f(y | x) are correct (i.e., f(y | x) is the true probability of y given
x), then this confidence set should contain the true label y with high probability.
For regression, we cannot explicitly rank labels y ∈ Y ⊆ Rd, but they are monotonically decreasing
away from the mean. Then, assuming f (y | x) = N(y; μ(χ), Σ(χ)) is Gaussian, We take an
ellipsoid of shape Σ(x) around μ(x) with minimum radius that captures 1 - e of the probability
mass of f(y | x). More precisely, we choose
C(X) = CT(X)(X)
T(X) = argminT∈rT subj. to Pf(y∣χ)[y ∈ CT(x)] ≥ 1 - e,
20
Published as a conference paper at ICLR 2020
IOOO
D
C+D
800
600
400
200
0
Figure 6: Confidence set sizes for two neural network architectures trained on ImageNet; for both,
we use n = 20, 000, = 0.01 and δ = 10-5. Left: AlexNet (Krizhevsky, 2014); here, the empirical
confidence set error of our approach C + D is 0.0066. Right: GoogLeNet (Szegedy et al., 2015);
here, the empirical confidence set error of our approach is 0.0061.
where CT (x) = {y ∈ Y | f(y | x) ≥ e-T} as before. Note that unlike our algorithm, the threshold
T (x) is not a learned parameter, but is computed independently for each new input x. We can solve
for T(X) efficiently by changing basis to convert f (y | x) to a standard Gaussian distribution, and
then using the error function to compute the cutoff that includes the desired probability mass.
In Figure 5, we compare the confidence sets constructed using this approach with (i) the forecaster
fφ(y I x) without any calibration, and (ii) the calibrated forecaster fφτ(y | x). We plot both the
confidence set sizes and the empirical error rates. For the latter, recall that a confidence set predictor
C is correct if L(C) < , where L(C) the true error rate. However, we cannot measure L(C);
instead, We approximate it on a held-out test set ZteSt ⊆ X × Y—i.e., L(C) ≈ L(C; Ztest), where
1
| Ztest |
Ztest)
I[y 6∈C(x)].
(x,y)∈Ztest
Intuitively, L(C; ZteSt) is the fraction of inputs (x, y) ∈ ZteSt such that the predicted confidence set
for X does not contain y. We say a confidence set C is empirically valid when L(C; ZteSt) < e.
Recall that our algorithm guarantees correctness with probability at least 1 - δ, where δ = 10-5.
As can be seen, the baseline approaches are not empirically valid in all cases. In one case—namely,
the baseline with the calibrated forecaster on ImageNet—the confidence sets are almost empirically
valid. However, in this case, the confidence sets are much larger than those based on our approach,
despite the fact that the error rate of our confidence sets are empirically valid. Thus, our algorithms
outperform the baselines in all cases.
D.2 Results on Additional ImageNet Neural Network Architectures
We apply our approach to two additional neural network architectures for ImageNet: AlexNet
(Krizhevsky, 2014) and GoogLeNet (Szegedy et al., 2015). Our results are shown in Figure 6.
As can be seen, calibration reduces the confidence set sizes for AlexNet, but actually increases the
confidence set sizes for GoogleNet. Thus, both calibrated and uncalibrated models may need to be
considered when constructing confidence set predictors. Also, we find that confidence set sizes are
correlated with classification error—the test errors for AlexNet, GoogleNet, and ResNet are 47.83%,
29.41%, and 21.34%, respectively, and their confidence set sizes decrease in the same order.
D.3 Results on Additional Classification Datasets
We apply our approach to three small classification datasets: an Arrhythmia detection dataset (Gu-
venir et al., 1997), acar evaluation dataset (Bohanec & Rajkovic, 1988), and a medical alarm dataset
(Bonafide et al., 2017). The confidence set sizes are shown in Figure 7. We choose larger values ofe
and δ since we cannot obtain confidence sets that satisfy the PAC criterion with smaller e and δ when
the number of validation examples n is too small. For all three datasets, the empirical confidence
set error is smaller than the specified error e; thus, the constructed confidence sets are empirically
valid. For these datasets, the confidence set sizes of our approach C + D and our approach without
calibration D are similar, most likely due to the small number of class labels.
21
Published as a conference paper at ICLR 2020
(a) Arrhythmia	(b) Car
(c) CHOP Alarm
Figure 7: Confidence set sizes for three additional classification benchmarks: (a) the arrhythmia
detection dataset (Guvenir et al., 1997); here, n = 90,	= 0.1, δ = 0.05, and the empirical
confidence set error of our approach C + D is 0.0435, (b) the car evaluation dataset (Bohanec &
Rajkovic, 1988); here, n = 345, = 0.05, δ = 10-5, and the empirical confidence set error of our
approach C + D is 0.0172, and (c) the CHOP alarm dataset (Bonafide et al., 2017); here, n = 1000,
= 0.02, δ = 10-5, and the empirical confidence set error of our approach C+D is 0.0159. (d) The
fractions of actionable and false alarms with a confidence set {0} (i.e., only contains false alarm).
(d) Suppressed alarms
We additionally ran our approach on a medical dataset where classification decisions are safety
critical; thus, correct predicted confidence sets are required. In particular, we use the Children’s
Hospital of Philadelphia (CHOP) alarm dataset (Bonafide et al., 2017). This dataset consists of vital
signs from 100 patients around one year of age. One of the vital signs is the oxygen level of the
blood, and a medical device generates an alarm if the oxygen level is below a specified level. The
labels indicate whether the generated alarm is true (y = 1) or false (y = 0). We use n = 1000,
= 0.02, and δ = 10-5. The empirical confidence set error of our approach is L(C; Ztest) = 0.0159.
The key question is how many false alarms can be reliably detected using machine learning to help
reduce alarm fatigue. We consider an approach where we use the predicted confidence sets to detect
false alarms. In particular, we first train a probability forecaster f : X → PY, where Y = {0, 1}, to
predict the probability that an alarm is true, and then construct a calibrated confidence set predictor
f : X → 2Y based on this forecaster. We consider an alarm to be false if the predicted confidence
set is f(x) = {0}—i.e., according to our confidence set predictor, the alarm is definitely false. Then,
our PAC guarantee says that the alarm is actually false with probability at least 1 - . In summary,
we suppress an alarm if f(x) = {0}. Using our approach, 176/630 (i.e., 27.94%) of false alarms
are suppressed, while only 13/187 (i.e., 6.95%) true alarms are suppressed (see Figure 7 (d)).
D.4 Results on Additional Regression Datasets
We ran our algorithm on two small regression baselines—the Auto MPG dataset (Quinlan, 1993)
and the student grade dataset (Cortez & Silva, 2008). We show results in Figure 8. The parameters
we use are = 0.1 and δ = 0.05; as with the smaller classification datasets, we use larger choices
of and δ since we cannot construct valid confidence sets for smaller choices. For the Auto MPG
dataset, the empirical confidence set error of our final model C + D is L(C; ZteSt) = 0.0597, so
these are empirically valid. For the student grade dataset, the error is L(C; Ztest) = 0.1250, which is
slightly larger than desired; this failure is likely due to the fact that the failure probability δ = 0.05
is somewhat large.
22
Published as a conference paper at ICLR 2020
ω-s 4ωs uuoɔ
Figure 8: Confidence set sizes for two benchmarks focused on regression; for both, we use = 0.1
and δ = 0.05. Left: the Auto MPG dataset (Quinlan, 1993); here, n = 70, and the empirical
confidence set error of our approach C + D is 0.1250. Right: The student grade dataset (Cortez &
Silva, 2008); here, n = 100, and the empirical confidence set error of our approach is 0.0597.
D.5 Additional Results on ImageNet, Half-Cheetah, and Object Tracking
Table 4 & 5 show examples of ResNet confidence set sizes for ImageNet images. Table 6 shows
results for varying , δ on ResNet. Tables 7 & 8 show results for varying , δ on the Half-Cheetah.
Table 9 shows visualizations of the confidence sets predicted for our object tracking benchmark.
23
Published as a conference paper at ICLR 2020
α≡s二E
|C(x)| = 1	5 ≤ |C(x)| ≤ 10	50 ≤ |C(x)| ≤ 100	|C(x)| ≥ 200
EJqoz
EUEUEq
I°SnolB。
qsyiBis
u-ssoi3s
Table 4: ImageNet images with varying ResNet confidence set sizes. The confidence set sizes are
on the top. The true label is on the left-hand side. Incorrectly labeled images are boxed in red.
24
Published as a conference paper at ICLR 2020
1 ≤ |C(x)| < 5
uin}
5 ≤ 叵(x)| < 10
10 ≤ 叵(x)| < 20
{shopping basket}
(
chambered
nautilus
bonnet
)
ʃMadagascar cat,
indri
ballpoint,
fountain pen
{ibex,
impala,
gazelle
indigo bunting,
bee eater,
hummingbird,
jacamar
' ----------.
Chihuahua,
toy terrier,
Italian greyhound,
Boston bull,
miniature pinscher
English springer,
Welsh springer
spaniel ,
collie,
boxer,
Saint Bernard,
Leonberg
face powder,
hamper,
lotion,
packet,
shopping basket
kite,
bald eagle,
vulture,
great grey owl,
bittern
tiger cat,
lynx,
leopard,
snow leopard,
jaguar,
tiger,
cheetah
cash machine,
desktop computer,
entertain. center,
home theater,
loudspeaker,
monitor,
screen,
television
common iguana,
whiptail, agama,
frilled lizard,
alligator lizard,
green lizard,
Komodo dragon,
African crocodile,
American alligator
1 -Γ^ Γ ∙
barber chair,
barbershop,
electric fan,
hand blower,
iron,
rocking chair,
table lamp,
tricycle,
vacuum
banded gecko,
.
common iguana,
American chameleon,
whiptail,
agama,
frilled lizard,
alligator lizard,
green lizard,
African chameleon,
Komodo dragon
altar,
analog clock,
bell cote, castle,
church,
cinema, dome,
monastery,
palace, vault,
wall clock
barber chair,
hand blower,
medicine chest,
paper towel,
plunger,
shower curtain,
soap dispenser,
toilet seat,
tub, washbasin,
washer, toilet tissue
1 r-------
beach wagon,
cab, car wheel,
convertible, grille,
limousine, minivan,
mobile home,
passenger car,
pickup,
recreational vehicle,
sports car, tow truck
cannon, castle,	'
一■``■∙⅛.
cliff dwelling,
megalith, monastery,
obelisk, prison,
stone wall,
triumphal arch,
vault, alp,
cliff, promontory,
valley
amphibian,	'
cassette player,
fire engine,
minibus, minivan,
passenger car,
pole, police van,
puck, racer,
radio, school bus,
screwdriver, streetcar,
-------------.
trolleybus
junco, water ouzel,
water snake, drake,
red-breasted merganser,
goose, crayfish,
little blue heron,
European gallinule,
ruddy turnstone,
red-backed sandpiper,
redshank, dowitcher,
oystercatcher, albatross,
otter
accordion,	'
acoustic guitar,
banjo, bassoon,
cornet, drum,
drumstick,
electric guitar,
French horn,
maraca, microphone,
oboe, sax,
stage, torch,
—.
trombone, violin
Table 5: Confidence sets of ImageNet images with varying ResNet confidence set sizes. The pre-
dicted confidence set is shown to the right of the corresponding input image. The true label is shown
in red, and the predicted label is shown with a hat.
25
Published as a conference paper at ICLR 2020
3
-
s.0 H 9 XTO H 9 ∞0.0 H 9 s o H 9 5.0 H 9
3z-stis .juoɔ
3z-stis .juoɔ
3z-stis .juoɔ
3z-s 43S .⅛0u
3z-s 43S .⅛0u
3z-s 43S .⅛0u
Table 6:	Confidence set sizes for ResNet trained on ImageNet, for varying , δ and for n = 20, 000.
The plots are as in Figure 1 (a).
26
Published as a conference paper at ICLR 2020
so H 9
∞0.0 H 9 s o H 9
5 0 H 9
δ= 10-1
δ= 10-3
δ= 10-5
C
418529630
orɔrɑ/ɑ/ɑ/oooo
Wwwwwiiii
(86,60-) 3.uo□
A+D A+C+D
418529630
orɔrɑ/ɑ/ɑ/oooo
Wwwwwiiii
(86,60-) 3.uo□
41852963P
orɔrɑ/ɑ/ɑ/oootf
Wwwwwiiii
(86,6) 3%ω .⅛00
18529630
ɔrɑ/ɑ/ɑ/oooo
Wwwwiiii
-8,60-) 3.uo□
418529630
OrorajaJaJOOOO
Wwwwwiiii
(86,6) HSBkUCO
寸0.0 :
418529630
orɔrɑ/ɑ/ɑ/oooo
Wwwwwiiii
(3-86,6) 3%ω .⅛00
418529630
Wwwwwiiii
(86,6) HSEkuo。
A+D A+C+D
418529630
Wwwwwiiii
(86,6) HSBkUCO
418529630
orɔrɑ/ɑ/ɑ/oooo
Wwwwwiiii
(3-86,6) 3%ω .⅛00
C
418529630
ɔrorɑ/ɑ/ɑ/oooo
Wwwwwiiii
(86,6) HSEkuo。
18529630
ɔrɑ/ɑ/ɑ/oooo
Wwwwiiii
-8,60-) 3.uo□
A+D A+C+D
A+D A+C+D
41852963P
OrorajaJaJOOOrtV
Wwwwwiiii
(86,6) HSBkUCO
41852963P
orɔrɑ/ɑ/ɑ/oootf
Wwwwwiiii
(3-86,6) 3%ω .⅛00
1852963P
ɔrɑ/ɑ/ɑ/oootf
Wwwwiiii
-8,60-) 3.uo□
418529 何 3P
ɔrorɑ/ɑ/ɑ/ Ortv
Wwwwwiiii
(86,60-) 3.uo□
A+D A+C+D
Table 7:	Confidence set sizes for a neural network dynamics model trained on the half-cheetah
environment, for varying , δ and for n = 5000. The plots are as in Figure 3 (a).
27
Published as a conference paper at ICLR 2020
δ= 10-1
δ= 10-3
δ= 10-5
go∙ou9 寸 0∙0υ9 ∞0.0H ZO∙0"9 I0∙0"9
(αj-e * 6-)αjz-S ⅛ω
Time step
(αj-e * 6-)αjz-S ⅛ω .^⊂00
Time step
(αj-e 吊 60-)αjz-S 4αjs .juoɔ
Time step
(αj-e * 6-)αjz-S ⅛ω .^⊂00
Time step
?e 吊 6-)αjz-S ⅛ω .^⊂00
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-) ωN-ω 4s .Ju。。
Time step
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e * 6O-) ωN-ω ⅛ω .^⊂00
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-)z - s 4s .Juou
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-) ωN-ω ⅛ω .^⊂00
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e * 6O-) ωN-ω 4s .Juou
(ω-eus∙60-j ωN-ω lα,s ∙JUO□
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-) ωN-ω 4s .Ju。。
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-) ωN-ω ⅛ω .^⊂00
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-)z - s 4s .Juou
≈β≈4≈0*∙*≈0β0400
Wwwwwiii
(-e 吊 60-) ωN-ω ⅛ω .^⊂00
5	10	15	20
Time step
Table 8:	Confidence set sizes for a neural network dynamics model trained on the half-cheetah
environment, for varying , δ and for n = 5000. The plots are as in Figure 3 (b).
28
Published as a conference paper at ICLR 2020
Table 9:	Visualization of confidence sets for the tracking dataset (Wu et al., 2013), including the
ground truth bounding box (white), the bounding box predicted by the original neural network (Held
et al., 2016) (red), and the bounding box produced using our confidence set predictor (green). We
have overapproximated the predicted ellipsoid confidence set with a box. Our bounding box contains
the ground truth bounding box with high probability.
29