ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
ReMixMatch: Semi-Supervised Learning with
Distribution Alignment and Augmentation
Anchoring
David Berthelot, Nicholas Carlini, Ekin D. Cubuk, Alex Kurakin, Han Zhang, Colin Raffel
Google Research
{dberth,ncarlini,cubuk,kurakin,zhanghan,craffel}@google.com
Kihyuk Sohn
Google Cloud AI
kihyuks@google.com
Ab stract
We imProve the recently-ProPosed “MixMatch” semi-suPervised learning algo-
rithm by introducing tWo neW techniques: distribution alignment and augmenta-
tion anchoring. Distribution alignment encourages the marginal distribution of
Predictions on unlabeled data to be close to the marginal distribution of ground-
truth labels. Augmentation anchoring feeds multiPle strongly augmented versions
of an inPut into the model and encourages each outPut to be close to the Predic-
tion for a Weakly-augmented version of the same inPut. To Produce strong aug-
mentations, We ProPose a variant of AutoAugment Which learns the augmentation
Policy While the model is being trained. Our neW algorithm, dubbed ReMix-
Match, is significantly more data-efficient than Prior Work, requiring betWeen
5× and 16× less data to reach the same accuracy. For examPle, on CIFAR-
10 With 250 labeled examPles We reach 93.73% accuracy (comPared to Mix-
Match’s accuracy of 93.58% With 4,000 examPles) and a median accuracy of
84.92% With just four labels Per class. We make our code and data oPen-source
at https://github.com/google-research/remixmatch.
1	Introduction
Semi-suPervised learning (SSL) Provides a means of leveraging unlabeled data to imProve a model’s
Performance When only limited labeled data is available. This can enable the use of large, PoWerful
models When labeling data is exPensive or inconvenient. Research on SSL has Produced a diverse
collection of aPProaches, including consistency regularization (Sajjadi et al., 2016; Laine & Aila,
2017) Which encourages a model to Produce the same Prediction When the inPut is Perturbed and
entroPy minimization (Grandvalet & Bengio, 2005) Which encourages the model to outPut high-
confidence Predictions. The recently ProPosed “MixMatch” algorithm (Berthelot et al., 2019) com-
bines these techniques in a unified loss function and achieves strong Performance on a variety of
image classification benchmarks. In this PaPer, We ProPose tWo imProvements Which can be readily
integrated into MixMatch’s frameWork.
First, We introduce “distribution alignment”, Which encourages the distribution of a model’s aggre-
gated class Predictions to match the marginal distribution of ground-truth class labels. This concePt
Was introduced as a “fair” objective by Bridle et al. (1992), Where a related loss term Was shoWn to
arise from the maximization of mutual information betWeen model inPuts and outPuts. After revieW-
ing this theoretical frameWork, We shoW hoW distribution alignment can be straightforWardly added
to MixMatch by modifying the “guessed labels” using a running average of model Predictions.
Second, We introduce “augmentation anchoring”, Which rePlaces the consistency regularization
comPonent of MixMatch. For each given unlabeled inPut, augmentation anchoring first generates a
Weakly augmented version (e.g. using only a fliP and a croP) and then generates multiPle strongly
augmented versions. The model’s Prediction for the Weakly-augmented inPut is treated as the basis
1
ReMixMatch: Semi-SuPerVised Learning With Distribution Alignment and Augmentation Anchoring
Figure 1: Distribution alignment. Guessed label
distributions are adjusted according to the ratio
of the emPirical ground-truth class distribution
diVided by the aVerage model Predictions on un-
labeled data.
Figure 2: Augmentation anchoring. We use
the Prediction for a Weakly augmented image
(green, middle) as the target for Predictions on
strong augmentations of the same image (blue).
of the guessed label for all of the strongly augmented Versions. To generate strong augmentations,
We introduce a Variant of AutoAugment (Cubuk et al., 2018) based on control theory Which We dub
“CTAugment”. Unlike AutoAugment, CTAugment learns an augmentation Policy alongside model
training, making it Particularly conVenient in SSL settings.
We call our imProVed algorithm “ReMixMatch” and exPerimentally Validate it on a suite of stan-
dard SSL image benchmarks. ReMixMatch achieVes state-of-the-art accuracy across all labeled data
amounts, for examPle achieVing an accuracy of 93.73% With 250 labels on CIFAR-10 comPared to
the PreVious state-of-the-art of 88.92% (and comPared to 96.09% for fully-suPerVised classifica-
tion With 50,000 labels). We also Push the limited-data setting further than eVer before, ultimately
achieVing a median of 84.92% accuracy With only 40 labels (just 4 labels Per class) on CIFAR-10.
To quantify the imPact of our ProPosed imProVements, We carry out an extensiVe ablation study to
measure the imPact of our imProVements to MixMatch. Finally, We release all of our models and
code to facilitate future Work on semi-suPerVised learning.
2	Background
The goal of a semi-suPerVised learning algorithm is to learn from unlabeled data in a Way that
imProVes Performance on labeled data. TyPical Ways of achieVing this include training against
“guessed” labels for unlabeled data or oPtimizing a heuristically-motiVated objectiVe that does not
rely on labels. This section reVieWs the semi-suPerVised learning methods releVant to ReMixMatch,
With a Particular focus on the comPonents of the MixMatch algorithm uPon Which We base our Work.
Consistency Regularization Many SSL methods rely on consistency regularization to enforce
that the model outPut remains unchanged When the inPut is Perturbed. First ProPosed in (Bach-
man et al., 2014), (Sajjadi et al., 2016) and (Laine & Aila, 2017), this aPProach Was referred to
as “Regularization With Stochastic Transformations and Perturbations” and the F-ModeFrespec-
tiVely. While some Work Perturbs adVersarially (Miyato et al., 2018) or using droPout (Laine & Aila,
2017; TarVainen & Valpola, 2017), the most common perturbation is to apply domain-specific data
augmentation (Laine & Aila, 2017; Sajjadi et al., 2016; Berthelot et al., 2019; Xie et al., 2019). The
loss function used to measure consistency is typically either the mean-squared error (Laine & Aila,
2017; TarVainen & Valpola, 2017; Sajjadi et al., 2016) or cross-entropy (Miyato et al., 2018; Xie
et al., 2019) betWeen the model’s output for a perturbed and non-perturbed input.
Entropy Minimization GrandValet & Bengio (2005) argues that unlabeled data should be used
to ensure that classes are Well-separated. This can be achieVed by encouraging the model’s output
distribution to haVe loW entropy (i.e., to make “high-confidence” predictions) on unlabeled data. For
example, one can explicitly add a loss term to minimize the entropy of the model’s predicted class
distribution on unlabeled data (GrandValet & Bengio, 2005; Miyato et al., 2018). Related to this idea
are “self-training” methods (McLachlan, 1975; Rosenberg et al., 2005) such as Pseudo-Label (Lee,
2013) that use the predicted class on an unlabeled input as a hard target for the same input, Which
implicitly minimizes the entropy of the prediction.
2
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
Standard Regularization Outside of the setting of SSL, it is often useful to regularize models
in the over-Parameterized regime. This regularization can often be aPPlied both When training on
labeled and unlabeled data. For examPle, standard “Weight decay” (Hinton & van CamP, 1993)
Where the L2 norm of Parameters is minimized is often used alongside SSL techniques. Similarly,
PoWerful MixUP regularization (Zhang et al., 2017) Which trains a model on linear interPolants of
inPuts and labels has recently been aPPlied to SSL (Berthelot et al., 2019; Verma et al., 2019).
Other Approaches The three aforementioned categories of SSL techniques does not cover the
full literature on semi-suPervised learning. For examPle, there is a significant body of research on
“transductive” or graPh-based semi-suPervised learning techniques Which leverage the idea that un-
labeled dataPoints should be assigned the label of a labeled dataPoint if they are sufficiently similar
(Gammerman et al., 1998; Joachims, 2003; 1999; Bengio et al., 2006; Liu et al., 2018). Since our
Work does not involve these (or other) aPProaches to SSL, We Will not discuss them further. A more
substantial overvieW of SSL methods is available in (ChaPelle et al., 2006).
2.1	MixMatch
MixMatch (Berthelot et al., 2019) unifies several of the Previously mentioned SSL techniques. The
algorithm Works by generating “guessed labels” for each unlabeled examPle, and then using fully-
suPervised techniques to train on the original labeled data along With the guessed labels for the
unlabeled data. This section revieWs the necessary details of MixMatch; see (Berthelot et al., 2019)
for a full definition.
Let X = (xb, pb) : b ∈ (1, . . . , B) be a batch of labeled data and their corresPonding one-hot
labels representing one of L classes and let Xb be augmented versions of these labeled examples.
Similarly, let U = ub : b ∈ (1, . . . , B) be a batch of unlabeled examPles. Finally, let pmodel (y |
x; θ) be the predicted class distribution produced by the model for input x.
MixMatch first produces K weakly augmented versions of each unlabeled datapoint Ub,k for
k ∈ {1, . . . , K}. Then, it generates a “guessed label” qb for each ub by computing the average
prediction qb across the K augmented versions: qb =六 Pk Pmodel(y | Ub,k； θ). The guessed label
distribution is then sharpened by adjusting its temperature (i.e. raising all probabilities to a power
of 1⅛ and renormalizing). Finally, pairs of examples (χ1,p1), (χ2,p2) from the combined set of
labeled examples and unlabeled examples with label guesses are fed into the MixUp (Zhang et al.,
2017) algorithm to compute examples (x0,p0) where x0 = λx1 + (1 — λ)x2 for λ 〜 Beta(α, α),
and similarly for p0. Given these mixed-up examples, MixMatch performs standard fully-supervised
training with minor modifications. A standard cross-entropy loss is used for labeled data, whereas
the loss for unlabeled data is computed using a mean square error (i.e. the Brier score (Brier, 1950))
and is weighted with a hyperparameter λU. The terms K (number of augmentations), T (sharpening
temperature), α (MixUp Beta parameter), and λU (unlabeled loss weight) are MixMatch’s hyper-
parameters. For augmentation, shifting and flipping was used for the CIFAR-10, CIFAR-100, and
STL-10 datasets, and shifting alone was used for SVHN.
3	ReMixMatch
Having introduced MixMatch, we now turn to the two improvements we propose in this paper:
Distribution alignment and augmentation anchoring. For clarity, we describe how we integrate them
into the base MixMatch algorithm; the full algorithm for ReMixMatch is shown in algorithm 1.
3.1	Distribution Alignment
Our first contribution is distribution alignment, which enforces that the aggregate of predictions on
unlabeled data matches the distribution of the provided labeled data. This general idea was first
introduced over 25 years ago (Bridle et al., 1992), but to the best of our knowledge is not used in
modern SSL techniques. A schematic of distribution alignment can be seen in fig. 1. After reviewing
and extending the theory, we describe how it can be straightforwardly included in ReMixMatch.
3
ReMixMatch: Semi-SuPerVised Learning With Distribution Alignment and Augmentation Anchoring
Algorithm 1 ReMixMatch algorithm for producing a collection of processed labeled examples and
Processed unlabeled examPles With label guesses (cf. Berthelot et al. (2019) Algorithm 1.)
1:	Input: Batch of labeled examPles and their one-hot labels X = (xb, pb) : b ∈ (1, . . . , B) , batch of
unlabeled examPles U = ub : b ∈ (1, . . . , B) , sharPening temPerature T, number of augmentations
K, Beta distribution Parameter α for MixUp.
2:	for b = 1 to B do
3:	Xb = StrongAugment(Xb) // Apply strong data augmentation to Xb
4:	Ub,k = StrongAugment(Ub); k ∈{1,...,K} // Apply StrOng data augmentation K times to Ub
5:	Ub = WeakAugment(Ub) // APPIy weak data augmentation to Ub
6:	qb = Pmodel (y | Ub; θ) // Compute prediction for weak augmentation of Ub
7:	qb = Normalize(qb X p(y) /P(y)) // Apply distribution alignment
8:	qb = Normalize(q1/T) // Apply temperature SharPening to label guess
9:	end for
10:	X=((Xb,Pb); b ∈ (1,...,B)) // Augmented labeled examples and their labels
11:	UI = ：(Ub,i,qb)； b ∈ (1,...,B)) // First strongly augmented unlabeled example and guessed label
12:	U= ((Ub,k,qb); b ∈ (1,...,B),k ∈ (1,..., K))	// All strongly augmented unlabeled examples
13:	U = U ∪ ((Ub,qb); b ∈ (1,...,B))	// AddweakIyaUgmentedUnlabeled examples
14:	W = Shuffle(Concat(X, U))	// COmbine and shuffle labeled and unlabeled data
15:	X0 = (MiXUP(Xi, Wi); i ∈ (1,...,∣X∣)) // Apply MiXUP to labeled data and entries from W
16:	U0 = (MiXUP(Ui, Wi+∣χ∣); i ∈ (1,..., |U|))	// Apply MixUp to unlabeled data and the rest of W
17:	return X0, U0, Ui
3.1.1	Input- Output Mutual Information
As PreViously mentioned, the Primary goal of an SSL algorithm is to incorPorate unlabeled data in
a Way Which imProVes a model’s Performance. One Way to formalize this intuition, first ProPosed
by Bridle et al. (1992), is to maximize the mutual information betWeen the model’s inPut and outPut
for unlabeled data. IntuitiVely, a good classifier’s Prediction should dePend as much as Possible on
the inPut. FolloWing the analysis from Bridle et al. (1992), We can formalize this objectiVe as
I (y; X)= 〃汉y,χ)log ppyyp⅛
dy dx
H(Ex [pmodel (y|x; θ)]) - Ex[H(pmodel(y|x; θ))]
(1)
(2)
where H(∙) refers to the entropy. See Appendix A for a proof. To interpret this result, observe
that the second term in eq. (2) is the familiar entroPy minimization objectiVe (GrandValet & Bengio,
2005), which simply encourages each individual model output to have low entropy (suggesting high
confidence in a class label). The first term, however, is not widely used in modern SSL techniques.
This term (roughly speaking) encourages that on average, across the entire training set, the model
predicts each class with equal frequency. Bridle et al. (1992) refer to this as the model being “fair”.
3.1.2	Distribution Alignment in ReMixMatch
MixMatch already includes a form of entropy minimization via the “sharpening” operation which
makes the guessed labels (synthetic targets) for unlabeled data have lower entropy. We are therefore
interested in also incorporating a form of “fairness” in ReMixMatch. However, note that the objec-
tive H(Ex [pmodel (y|x; θ)]) on its own essentially implies that the model should predict each class
with equal frequency. This is not necessarily a useful objective if the dataset’s marginal class distri-
bution p(y) is not uniform. Furthermore, while it would in principle be possible to directly minimize
this objective on a per-batch basis, we are instead interested in integrating it into MixMatch in a way
which does not introduce an additional loss term or any sensitive hyperparameters.
To address these issues, we incorporate a form of fairness we call “distribution alignment” which
proceeds as follows: over the course of training, we maintain a running average of the model’s
predictions on unlabeled data, which we refer to as p(y). Given the model,s prediction q =
Pmodei(y∣u; θ) on an unlabeled example u, we scale q by the ratio p(y)∕p(y) and then renormal-
ize the result to form a valid probability distribution: q = Normalize(q X p(y)∕p(y)) where
4
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
Normalize(x)i = x%/ Ej Xj. We then use q as the label guess for u, and proceed as usual with
sharpening and other processing. In practice, we compute p(y) as the moving average of the model's
predictions on unlabeled examples over the last 128 batches. We also estimate the marginal class
distribution p(y) based on the labeled examples seen during training. Note that a better estimate for
p(y) could be used ifit is known a priori; in this work we do not explore this direction further.
3.2	Improved Consistency Regularization
Consistency regularization underlies most SSL methods (Miyato et al., 2018; Tarvainen & Valpola,
2017; Berthelot et al., 2019; Xie et al., 2019). For image classification tasks, consistency is typically
enforced between two augmented versions of the same unlabeled image. In order to enforce a form
of consistency regularization, MixMatch generates K (in practice, K = 2) augmentations of each
unlabeled example u and averages them together to produce a “guessed label” for u.
Recent work (Xie et al., 2019) found that applying stronger forms of augmentation can significantly
improve the performance of consistency regularization. In particular, for image classification tasks
it was shown that using variants of AutoAugment (Cubuk et al., 2018) produced substantial gains.
Since MixMatch uses a simple flip-and-crop augmentation strategy, we were interested to see if
replacing the weak augmentation in MixMatch with AutoAugment would improve performance but
found that training would not converge. To circumvent this issue, we propose a new method for
consistency regularization in MixMatch called “Augmentation Anchoring”. The basic idea is to
use the model’s prediction for a weakly augmented unlabeled image as the guessed label for many
strongly augmented versions of the same image.
A further logistical concern with using AutoAugment is that it uses reinforcement learning to learn
a policy which requires many trials of supervised model training. This poses issues in the SSL
setting where we often have limited labeled data. To address this, we propose a variant of Au-
toAugment called “CTAugment” which adapts itself online using ideas from control theory without
requiring any form of reinforcement learning-based training. We describe Augmentation Anchoring
and CTAugment in the following two subsections.
3.2.1	Augmentation Anchoring
We hypothesize the reason MixMatch with AutoAugment is unstable is that MixMatch averages the
prediction across K augmentations. Stronger augmentation can result in disparate predictions, so
their average may not be a meaningful target. Instead, given an unlabeled input we first generate an
“anchor” by applying weak augmentation to it. Then, we generate K strongly-augmented versions
of the same unlabeled input using CTAugment (described below). We use the guessed label (after
applying distribution alignment and sharpening) as the target for all of the K strongly-augmented
versions of the image. This process is visualized in fig. 2.
While experimenting with Augmentation Anchoring, we found it enabled us to replace MixMatch’s
unlabeled-data mean squared error loss with a standard cross-entropy loss. This maintained stability
while also simplifying the implementation. While MixMatch achieved its best performance at only
K = 2, we found that augmentation anchoring benefited from a larger value ofK = 8. We compare
different values of K in section 4 to measure the gain achieved from additional augmentations.
3.2.2	Control Theory Augment
AutoAugment (Cubuk et al., 2018) is a method for learning a data augmentation policy which results
in high validation set accuracy. An augmentation policy consists a sequence of transformation-
parameter magnitude tuples to apply to each image. Critically, the AutoAugment policy is learned
with supervision: the magnitudes and sequence of transformations are determined via training many
models on a proxy task which e.g. involves the use of 4,000 labels on CIFAR-10 and 1,000 labels on
SVHN (Cubuk et al., 2018). This makes applying AutoAugment methodologically problematic for
low-label SSL. To remedy this necessity for training a policy on labeled data, RandAugment (Cubuk
et al., 2019) uniformly randomly samples transformations, but requires tuning the hyper-parameters
for the random sampling on the validation set, which again is methodologically difficult when only
very few (e.g., 40 or 250) labeled examples are available.
5
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
Thus, in this work, we develop CTAugment, an alternative approach to designing high-performance
augmentation strategies. Like RandAugment, CTAugment also uniformly randomly samPles trans-
formations to aPPly but dynamically infers magnitudes for each transformation during the training
Process. Since CTAugment does not need to be oPtimized on a suPervised Proxy task and has no
sensitive hyPerParameters, We can directly include it in our semi-suPervised models to exPeriment
With more aggressive data augmentation in semi-suPervised learning. Intuitively, for each augmen-
tation Parameter, CTAugment learns the likelihood that it Will Produce an image Which is classified
as the correct label. Using these likelihoods, CTAugment then only samPles augmentations that
fall Within the netWork tolerance. This Process is related to What is called density-matching in Fast
AutoAugment (Lim et al., 2019), Where Policies are oPtimized so that the density of augmented
validation images match the density of images from the training set.
First, CTAugment divides each Parameter for each transformation into bins of distortion magnitude
as is done in AutoAugment (see APPendix C for a list of the bin ranges). Let m be the vector of
bin Weights for some distortion Parameter for some transformation. At the beginning of training, all
magnitude bins are initialized to have a Weight set to 1. These Weights are used to determine Which
magnitude bin to aPPly to a given image.
At each training steP, for each image tWo transformations are samPled uniformly at random. To
augment images for training, for each Parameter of these transformations We Produce a modified
set of bin weights m where rhi = m⅛ if m⅛ > 0.8 and rmi = 0 otherwise, and sample magnitude
bins from Categorical(Normalize(m)). To update the weights of the sampled transformations,
we first sample a magnitude bin mi for each transformation parameter uniformly at random. The
resulting transformations are applied to a labeled example x with label p to obtain an augmented
version x. Then, we measure the extent to which the model,s prediction matches the label as ω =
1 - 2L P ∣Pmodei(y∣X; θ) - p|. The weight for each sampled magnitude bin is updated as mi =
ρmi + (1 - ρ)ω where ρ = 0.99 is a fixed exponential decay hyperparameter.
3.3	Putting it all together
ReMixMatch’s algorithm for processing a batch of labeled and unlabeled examples is shown in al-
gorithm 1. The main purpose of this algorithm is to produce the collections X0 andU0, consisting of
augmented labeled and unlabeled examples with MixUp applied. The labels and label guesses in X0
and U0 are fed into standard cross-entropy loss terms against the model’s predictions. Algorithm 1
also outputs Uι, which consists of a single heavily-augmented version of each unlabeled image and
its label guesses without MixUP applied. UI is used in two additional loss terms which provide a
mild boost in performance in addition to improved stability:
Pre-mixup unlabeled loss We feed the guessed labels and predictions for example in UI as-is into
a separate cross-entropy loss term.
Rotation loss Recent result have shown that applying ideas from self-supervised learning to SSL
can produce strong performance (Gidaris et al., 2018; Zhai et al., 2019). We integrate this idea
by rotating each image U ∈ Ui as Rotate(u, r) where we sample the rotation angle r uniformly
from r 〜{0,90,180, 270} and then ask the model to predict the rotation amount as a four-class
classification problem.
In total, the ReMixMatch loss is
H(p, pmodel(y|x; θ)) + λU	H(q, pmodel(y|u; θ))	(3)
x,p∈X 0	u,q∈U 0
+λu^ι E H(q,Pmodei(y∣u; θ)) + λr £ H(r, Pmodei (r| Rotate(u,r); θ))	(4)
-7^∕	f^t
u,q∈U1	u∈U1
Hyperparameters ReMixMatch introduce two new hyperparameters: the weight on the rotation
loss λr and the weight on the un-augmented example λz^ι. In practice both are fixed λr = λz^ι = 0.5.
ReMixMatch also shares many hyperparameters from MixMatch: the weight for the unlabeled loss
λU , the sharpening temperature T , the MixUp Beta parameter, and the number of augmentations
K. All experiments (unless otherwise stated) use T = 0.5, Beta = 0.75, and λU = 1.5. We found
6
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
using a larger number of augmentations monotonically increases accuracy, and so set K = 8 for all
exPeriments (as running With K augmentations increases comPutation by a factor of K).
We train our models using Adam (Kingma &Ba, 2015) With a fixed learning rate of 0.002 and Weight
decay (Zhang et al., 2018) With a fixed value of 0.02. We take the final model as an exPonential
moving average over the trained model Weights With a decay of 0.999.
4 Experiments
We noW test the efficacy of ReMixMatch on a set of standard semi-suPervised learning benchmarks.
Unless otherWise noted, all of the exPeriments Performed in this section use the same codebase
and model architecture (a Wide ResNet-28-2 (Zagoruyko & Komodakis, 2016) With 1.5 million
Parameters, as used in (Oliver et al., 2018)).
4.1	Realistic SSL setting
We folloW the Realistic Semi-SuPervised Learning (Oliver et al., 2018) recommendations for Per-
forming SSL evaluations. In Particular, as mentioned above, this means We use the same model
and training algorithm in the same codebase for all exPeriments. We comPare against VAT (Miyato
et al., 2018) and MeanTeacher (Tarvainen & ValPola, 2017), coPying the re-imPlementations over
from the MixMatch codebase (Berthelot et al., 2019).
Fully supervised baseline To begin, We train a fully-suPervised baseline to measure the highest
accuracy We could hoPe to obtain With our training PiPeline. The exPeriments We Perform use the
same model and training algorithm, so these baselines are valid for all discussed SSL techniques. On
CIFAR-10, We obtain an fully-suPervised error rate of 4.25% using Weak fliP + croP augmentation,
Which droPs to 3.62% using AutoAugment and 3.91% using CTAugment. Similarly, on SVHN We
obtain 2.70% error using Weak (fliP) augmentation and 2.31% and 2.16% using AutoAugment and
CTAugment resPectively. While AutoAugment Performs slightly better on CIFAR-10 and slightly
Worse on SVHN comPared to CTAugment, it is not our intent to design a better augmentation
strategy; just one that can be used without a pre-training or tuning of hyper-parameters.
CIFAR-10 Our results on CIFAR-10 are shoWn in table 1, left. ReMixMatch sets the neW state-
of-the-art for all numbers of labeled examPles. Most imPortantly, ReMixMatch is 16× more data
efficient than MixMatch (e.g., at 250 labeled examPles ReMixMatch has identical accuracy com-
Pared to MixMatch at 4,000).
SVHN Results for SVHN are shoWn in table 1, right. ReMixMatch reaches state-of-the-art at 250
labeled examPles, and Within the margin of error for state-of-the-art otherWise.
	CIFAR-10		SVHN			
Method	250 labels	1000 labels	4000 labels	250 labels	1000 labels	4000 labels
VAT	36.03±2.82	18.64±0.40	11.05±0.31	8.41±1.01	5.98±0.21	4.20±0.15
Mean Teacher	47.32±4.71	17.32±4.00	10.36±0.25	6.45±2.43	3.75±0.10	3.39±0.11
MixMatch	11.08±0.87	7.75±0.32	6.24±0.06	3.78±0.26	3.27±0.31	2.89±0.06
ReMixMatch	6.27±0.34	5.73±0.16	5.14±0.04	3.10±0.50	2.83±0.30	2.42±0.09
UDA, reported*	8.76±0.90	5.87±0.13	5.29±0.25	2.76±0.17	2.55±0.09	2.47±0.15
Table 1: Results on CIFAR-10 and SVHN. * For UDA, due to adaPtation difficulties, We rePort the
results from Xie et al. (2019) Which are not comParable to our results due to a different netWork
imPlementation, training Procedure, etc. For VAT, Mean Teacher, and MixMatch, We rePort results
using our reimPlementation, Which makes them directly comParable to ReMixMatch’s scores.
4.2	STL-10
The STL-10 dataset consists of 5,000 labeled 96 × 96 color images draWn from 10 classes and
100,000 unlabeled images draWn from a similar—but not identical—data distribution. The labeled
7
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
set is partitioned into ten pre-defined folds of 1,000 images each. For efficiency, we only run our
analysis on five of these ten folds. We do not Perform evaluation here under the Realistic SSL (Oliver
et al., 2018) setting When comParing to non-MixMatch results. Our results are, hoWever, directly
comParable to the MixMatch results. Using the same WRN-37-2 netWork (23.8 million Parameters),
We reduce the error rate by a factor of tWo comPared to MixMatch.
Method	Error Rate
SWWAE	25.70
CC-GAN	22.20
MixMatch	10.18 ± 1.46
ReMixMatch (K=1)	6.77 ± 1.66
ReMixMatch (K=4)	6.18 ± 1.24
Table 2: STL-10 error rate using
1000-label sPlits. SWWAE and CC-
GAN results are from (Zhao et al.,
2015) and (Denton et al., 2016).
Ablation	Error Rate	Ablation	Error Rate
ReMixMatch	5.94	No rotation loss	6.08
With K=1	7.32	No Pre-mixuP loss	6.66
With K=2	6.74	No dist. alignment	7.28
With K=4	6.21	L2 unlabeled loss	17.28
With K=16	5.93	No strong aug.	12.51
MixMatch	11.08	No Weak aug.	29.36
Table 3: Ablation study. Error rates are rePorted on a single
250-label sPlit from CIFAR-10.
4.3	Towards few-shot learning
We find that ReMixMatch is able to Work in extremely loW-label settings. By only changing λr from
0.5 to 2 We can train CIFAR-10 With just four labels Per class and SVHN With only 40 labels total.
On CIFAR-10 We obtain a median-of-five error rate of 15.08%; on SVHN We reach 3.48% error and
on SVHN With the “extra” dataset We reach 2.81% error. Full results are given in APPendix B.
4.4	Ablation Study
Because We have made several changes to the existing MixMatch algorithm, here We Perform an
ablation study and remove one comPonent of ReMixMatch at a time to understand from Which
changes Produce the largest accuracy gains. Our ablation results are summarized in Table 3. We
find that removing the Pre-mixuP unlabeled loss, removing distribution alignment, and loWering K
all hurt Performance by a small amount. Given that distribution alignment imProves Performance,
We Were interested to see Whether it also had the intended effect of making marginal distribution
of model Predictions match the ground-truth marginal class distribution. We measure this directly
in aPPendix D. Removing the rotation loss reduces accuracy at 250 labels by only 0.14 Percent-
age Points, but We find that in the 40-label setting rotation loss is necessary to Prevent collaPse.
Changing the cross-entroPy loss on unlabeled data to an L2 loss as used in MixMatch hurts Perfor-
mance dramatically, as does removing either of the augmentation comPonents. This validates using
augmentation anchoring in Place of the consistency regularization mechanism of MixMatch.
5 Conclusion
Progress on semi-suPervised learning over the Past year has uPended many of the long-held beliefs
about classification, namely, that vast quantities of labeled data is necessary. By introducing aug-
mentation anchoring and distribution alignment to MixMatch, We continue this trend: ReMixMatch
reduces the quantity of labeled data needed by a large factor comPared to Prior Work (e.g., beating
MixMatch at 4000 labeled examPles With only 250 on CIFAR-10, and closely aPProaching Mix-
Match at 5000 labeled examPles With only 1000 on STL-10). In future Work, We are interested in
Pushing the limited data regime further to close the gaP betWeen feW-shot learning and SSL. We also
note that in many real-life scenarios, a dataset begins as unlabeled and is incrementally labeled until
satisfactory Performance is achieved. Our strong emPirical results suggest that it Will be Possible
to achieve gains in this “active learning” setting by using ideas from ReMixMatch. Finally, in this
PaPer We Present results on Widely-studied image benchmarks for ease of comParison. HoWever,
the true PoWer of data-efficient learning Will come from aPPlying these techniques to real-World
Problems Where obtaining labeling data is exPensive or imPractical.
8
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
References
PhiliP Bachman, Ouais Alsharif, and Doina PrecuP. Learning With Pseudo-ensembles. In Advances
in Neural Information Processing Systems, 2014.
Yoshua Bengio, Olivier Delalleau, and Nicolas Le Roux. Label Propagation and Quadratic Crite-
rion, chaPter 11. MIT Press, 2006.
David Berthelot, Nicholas Carlini, Ian GoodfelloW, Nicolas PaPernot, Avital Oliver, and Colin
Raffel. Mixmatch: A holistic aPProach to semi-suPervised learning. arXiv preprint
arXiv:1905.02249, 2019.
John S. Bridle, Anthony J. R. Heading, and David J. C. MacKay. UnsuPervised classifiers, mutual
information and’Phantom targets. In Advances in neural information processing systems, 1992.
Glenn W. Brier. Verification of forecasts exPressed in terms of Probability. Monthey Weather Review,
78(1):1-3,1950.
Olivier ChaPelle, Bernhard ScholkoPf, and Alexander Zien. Semi-Supervised Learning. MIT Press,
2006.
Ekin D. Cubuk, Barret ZoPh, Dandelion Mane, Vijay Vasudevan, and Quoc V. Le. Autoaugment:
Learning augmentation Policies from data. arXiv preprint arXiv:1805.09501, 2018.
Ekin D. Cubuk, Barret ZoPh, Jonathon Shlens, and Quoc V. Le. Randaugment: An automated,
randomized data augmentation strategy. arXiv preprint arXiv:XXXX.XXXXX, 2019.
Emily Denton, Sam Gross, and Rob Fergus. Semi-suPervised learning With context-conditional
generative adversarial netWorks. arXiv preprint arXiv:1611.06430, 2016.
Alexander Gammerman, Volodya Vovk, and Vladimir VaPnik. Learning by transduction. In Pro-
ceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence, 1998.
SPyros Gidaris, Praveer Singh, and Nikos Komodakis. UnsuPervised rePresentation learning by
Predicting image rotations. arXiv preprint arXiv:1803.07728, 2018.
Yves Grandvalet and Yoshua Bengio. Semi-suPervised learning by entroPy minimization. In Ad-
vances in Neural Information Processing Systems, 2005.
Geoffrey Hinton and DreW van CamP. KeePing neural netWorks simPle by minimizing the descriP-
tion length of the Weights. In Proceedings of the 6th Annual ACM Conference on Computational
Learning Theory, 1993.
Thorsten Joachims. Transductive inference for text classification using suPPort vector machines. In
International Conference on Machine Learning, 1999.
Thorsten Joachims. Transductive learning via sPectral graPh Partitioning. In International Confer-
ence on Machine Learning, 2003.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic oPtimization. In Third Interna-
tional Conference on Learning Representations, 2015.
Samuli Laine and Timo Aila. TemPoral ensembling for semi-suPervised learning. In Fifth Interna-
tional Conference on Learning Representations, 2017.
Dong-Hyun Lee. Pseudo-label: The simPle and efficient semi-suPervised learning method for deeP
neural netWorks. In ICML Workshop on Challenges in Representation Learning, 2013.
Sungbin Lim, Ildoo Kim, TaesuP Kim, Chiheon Kim, and SungWoong Kim. Fast autoaugment.
arXiv preprint arXiv:1905.00397, 2019.
Bin Liu, Zhirong Wu, Han Hu, and StePhen Lin. DeeP metric transfer for label ProPagation With
limited annotated data. arXiv preprint arXiv:1812.08781, 2018.
9
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
Geoffrey J. McLachlan. Iterative reclassification procedure for constructing an asymptotically opti-
mal rule of allocation in discriminant analysis. Journal of the American Statistical Association,
70(350):365-369,1975.
Takeru Miyato, Shin-ichi Maeda, Shin Ishii, and Masanori Koyama. Virtual adversarial training: a
regularization method for suPervised and semi-suPervised learning. IEEE transactions on pattern
analysis and machine intelligence, 2018.
Avital Oliver, Augustus Odena, Colin Raffel, Ekin Dogus Cubuk, and Ian GoodfelloW. Realistic
evaluation of deeP semi-suPervised learning algorithms. In Advances in Neural Information Pro-
cessing Systems, PP. 3235-3246, 2018.
Chuck Rosenberg, Martial Hebert, and Henry Schneiderman. Semi-suPervised self-training of object
detection models. In Proceedings of the Seventh IEEE Workshops on Application of Computer
Vision, 2005.
Mehdi Sajjadi, Mehran Javanmardi, and Tolga Tasdizen. Regularization With stochastic transfor-
mations and Perturbations for deeP semi-suPervised learning. In Advances in Neural Information
Processing Systems, 2016.
Antti Tarvainen and Harri ValPola. Mean teachers are better role models: Weight-averaged consis-
tency targets imProve semi-suPervised deeP learning results. In Advances in neural information
processing systems, 2017.
Vikas Verma, Alex Lamb, Juho Kannala, Yoshua Bengio, and David LoPez-Paz. InterPolation con-
sistency training for semi-suPervised learning. arXiv preprint arXiv:1903.03825, 2019.
Qizhe Xie, Zihang Dai, Eduard Hovy, Minh-Thang Luong, and Quoc V. Le. UnsuPervised data
augmentation for consistency training. arXiv preprint arXiv:1904.12848, 2019.
Sergey Zagoruyko and Nikos Komodakis. Wide residual netWorks. In Proceedings of the British
Machine Vision Conference (BMVC), 2016.
Xiaohua Zhai, Avital Oliver, Alexander Kolesnikov, and Lucas Beyer. s4l: Self-suPervised semi-
suPervised learning. arXiv preprint arXiv:1905.03670, 2019.
Guodong Zhang, Chaoqi Wang, BoWen Xu, and Roger Grosse. Three mechanisms of Weight decay
regularization. arXiv preprint arXiv:1810.12281, 2018.
Hongyi Zhang, MoustaPha Cisse, Yann N. DauPhin, and David LoPez-Paz. mixuP: Beyond emPiri-
cal risk minimization. arXiv preprint arXiv:1710.09412, 2017.
Junbo Zhao, Michael Mathieu, Ross Goroshin, and Yann Lecun. Stacked What-Where auto-encoders.
arXiv preprint arXiv:1506.02351, 2015.
10
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
A Proof of Equation 2
The Proof here folloWs closely Bridle et al. (1992). We begin With the definition
I (y; X)=HP 加 Xxbg pρy⅛χX)
dy dX
ReWriting terms We obtain
Zp(x) dx Zp(y∣x)log PpyyX) dy
∕p(χ)dχ ∕p(y iχ)log ∕p(x)%X)dχ dy
Then, reWriting both integrals as exPectations We obtain
L
£p(y∕χ) log
i=1
L
Ep(y∕χ) logp(y∕χ)
i=1
L
£p(yi ∣χ) log p(yi∣χ)
i=1
∕p(ylχ)log Eχp(⅛)idy
p(y∕χ)
Ex[p(yi∣χ)]
L
-Ex Ep(yi∣χ)logEχ[p(yi∣χ)]
i=1
L
-EEx [p(yi∣χ)]log Ex[p(yi∣χ)]]
i=1
H(Ex[Pmodel(y∣Χ; θ)]) - Ex[H(Pmodel(y∣Χ; θ))]
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
B Full 40 label results
We noW rePort the full results for running ReMixMatch With just 40 labeled examPles. We sort the
table by error rate over five different sPlits (i.e., 40-label subsets) of the training data. High variance
is to be exPected When choosing so feW labeled examPles at random.
Dataset	SPlit (ordered by error rate)
	1	2	3	4	5
CIFAR-10	10.88	12.65	15.08	16.78	19.49
SVHN	3.43	3.46	3.48	4.06	12.24
SVHN+extra	2.59	2.71	2.81	3.50	15.14
Table 4: Sorted error rate of ReMixMatch With 40 labeled examPles.
11
ReMixMatch: Semi-SuPervised Learning With Distribution Alignment and Augmentation Anchoring
C Transformations included in CTAugment
Transformation	Description	Parameter	Range
Autocontrast	Maximizes the image contrast by setting the dark- est (lightest) pixel to black (white), and then blends with the original image with blending ra- tio λ.	λ	[0, 1]
Blur Brightness	Adjusts the brightness of the image. B = 0 re- turns a black image, B = 1 returns the original image.	B	[0, 1]
Color	Adjusts the color balance of the image like in a TV. C = 0 returns a black & white image, C = 1 returns the original image.	C	[0, 1]
Contrast	Controls the contrast of the image. A C = 0 re- turns a gray image, C = 1 returns the original image.	C	[0, 1]
Cutout	Sets a random square patch of side-length (L×image width) pixels to gray.	L	[0, 0.5]
Equalize	Equalizes the image histogram, and then blends with the original image with blending ratio λ.	λ	[0, 1]
Invert	Inverts the pixels of the image, and then blends with the original image with blending ratio λ.	λ	[0, 1]
Identity	Returns the original image.		
Posterize	Reduces each pixel to B bits.	B	[1, 8]
Rescale	Takes a center crop that is of side-length (L×image width), and rescales to the original im- age size using method M .	L	[0.5, 1.0]
		M	see caption
Rotate	Rotates the image by θ degrees.	θ	[-45, 45]
Sharpness	Adjusts the sharpness of the image, where S = 0 returns a blurred image, and S = 1 returns the original image.	S	[0, 1]
Shear-X	Shears the image along the horizontal axis with rate R.	R	[-0.3, 0.3]
Shear_y	Shears the image along the vertical axis with rate R.	R	[-0.3, 0.3]
Smooth	Adjusts the smoothness of the image, where S = 0 returns a maximally smooth image, and S = 1 returns the original image.	S	[0, 1]
Solarize	Inverts all pixels above a threshold value of T .	T	[0, 1]
Translate_x	Translates the image horizontally by (λ×image width) pixels.	λ	[-0.3, 0.3]
TransIate_y	Translates the image vertically by (λ×image width) pixels.	λ	[-0.3, 0.3]
Table 5: The ranges for all of the listed Parameters are discretized into 17 equal bins. The only
excePtion is the M Parameter of the Rescale transformation, Which takes on one of the folloWing six
oPtions: anti-alias, bicubic, bilinear, box, hamming, and nearest.
D Measuring the effect of distribution alignment
Recall that the goal of distribution alignment is to encourage the marginal distribution of the model’s
predictions p(y) to match the true marginal class distributionp(y). To measure whether distribution
alignment indeed has this effect, we monitored the KL divergence between p(y) and p(y) over the
course of training. We show the KL divergence for a training run on CIFAR-10 with 250 labels with
12
ReMixMatch: Semi-SuPerVised Learning With Distribution Alignment and Augmentation Anchoring
Figure 3: KL divergence between the marginal distribution of model predictions vs. the true marginal
distribution of class labels oVer the course of training With and Without distribution alignment. This
figure corresPonds to a training run on CIFAR-10 With 250 labels.
and without distribution alignment in fig. 3. Indeed, the KL divergence between p(y) and p(y) is
significantly smaller throughout training.
E	CTAugment parameters effects
In this section we comPare the effects of varying the CTAugment hyPer-Parameters on CIFAR10
with 250 labels, using the standard ReMixMatch settings. The exPonential weight decay ρ does not
effect the results significantly while dePth and threshold have significant effects. The default settings
are highlighted in the table. They aPPear to Perform well and have been shown to be robust across
many datasets in our Previous exPeriments.
DePth	Threshold	ρ	Error rate
1	0.80	0.99	23.90
2	0.80	0.99	6.25
3	0.80	0.99	6.36
2	0.50	0.99	10.51
2	0.80	0.99	6.25
2	0.90	0.99	10.80
2	0.95	0.99	18.47
2	0.80	0.9	6.15
2	0.80	0.99	6.25
2	0.80	0.999	6.02
Table 6: Effects of hyPer-Parameters for CTAugment, the bold results are the default settings used
for all exPeriments.
13