Published as a conference paper at ICLR 2020
Population-Guided Parallel Policy Search
for Reinforcement Learning
Whiyoung Jung, Giseung Park, Youngchul Sung*
School of Electrical Engineering
Korea Advanced Institute of Science and Technology
{wy.jung, gs.park, ycsung}@kaist.ac.kr
Ab stract
In this paper, a new population-guided parallel learning scheme is proposed to en-
hance the performance of off-policy reinforcement learning (RL). In the proposed
scheme, multiple identical learners with their own value-functions and policies
share a common experience replay buffer, and search a good policy in collabo-
ration with the guidance of the best policy information. The key point is that
the information of the best policy is fused in a soft manner by constructing an
augmented loss function for policy update to enlarge the overall search region by
the multiple learners. The guidance by the previous best policy and the enlarged
range enable faster and better policy search. Monotone improvement of the ex-
pected cumulative return by the proposed scheme is proved theoretically. Working
algorithms are constructed by applying the proposed scheme to the twin delayed
deep deterministic (TD3) policy gradient algorithm. Numerical results show that
the constructed algorithm outperforms most of the current state-of-the-art RL al-
gorithms, and the gain is significant in the case of sparse reward environment.
1	Introduction
RL is an active research field and has been applied successfully to games, simulations, and ac-
tual environments. With the success of RL in relatively easy tasks, more challenging tasks such as
sparse reward environments (Oh et al. (2018); Zheng et al. (2018); Burda et al. (2019)) are emerg-
ing, and developing good RL algorithms for such challenging tasks is of great importance from
both theoretical and practical perspectives. In this paper, we consider parallel learning, which is
an important line of RL research to enhance the learning performance by having multiple learners
for the same environment. Parallelism in learning has been investigated widely in distributed RL
(Nair et al. (2015); Mnih et al. (2016); Horgan et al. (2018); Barth-Maron et al. (2018); Espeholt
et al. (2018)), evolutionary algorithms (Salimans et al. (2017); Choromanski et al. (2018); Khadka
& Tumer (2018); Pourchot & Sigaud (2019)), concurrent RL (Silver et al. (2013); Guo & Brunskill
(2015); Dimakopoulou & Van Roy (2018); Dimakopoulou et al. (2018)) and population-based train-
ing (PBT) (Jaderberg et al. (2017; 2018); Conti et al. (2018)). In this paper, in order to enhance the
learning performance, we apply parallelism to RL based on a population of policies, but the usage
is different from the previous methods.
One of the advantages of using a population is the capability to evaluate policies in the population.
Once all policies in the population are evaluated, we can use information of the best policy to en-
hance the performance. One simple way to exploit the best policy information is that we reset the
policy parameter of each learner with that of the best learner at the beginning of the next M time
steps; make each learner perform learning from this initial point for the next M time steps; select
the best learner again at the end of the next M time steps; and repeat this procedure every M time
steps in a similar way that PBT does (Jaderberg et al. (2017)). We will refer to this method as the
resetting method in this paper. However, this resetting method has the problem that the search area
covered by all N policies in the population collapses to one point at the time of parameter copying
and thus the search area can be narrow around the previous best policy point. To overcome such
disadvantage, instead of resetting the policy parameter with the best policy parameter periodically,
* Corresponding author
1
Published as a conference paper at ICLR 2020
we propose using the best policy information in a soft manner. In the proposed scheme, the shared
best policy information is used only to guide other learners’ policies for searching a better policy.
The chief periodically determines the best policy among all learners and distributes the best policy
parameter to all learners so that the learners search for better policies with the guidance of the pre-
vious best policy. The chief also enforces that the N policies are spread in the policy space with a
given distance from the previous best policy point so that the search area by all N learners maintains
a wide area and does not collapse into a narrow region.
The proposed Population-guided Parallel Policy Search (P3S) learning method can be applied to
any off-policy RL algorithms and implementation is easy. Furthermore, monotone improvement
of the expected cumulative return by the P3S scheme is theoretically proved. We apply our P3S
scheme to the TD3 algorithm, which is a state-of-the-art off-policy algorithm, as our base algorithm.
Numerical result shows that the P3S-TD3 algorithm outperforms the baseline algorithms both in the
speed of convergence and in the final steady-state performance.
2	Background and Related Works
Distributed RL Distributed RL is an efficient way of taking advantage of parallelism to achieve
fast training for large complex tasks (Nair et al. (2015)). Most of the works in distributed RL
assume a common structure composed of multiple actors interacting with multiple copies of the same
environment and a central system which stores and optimizes the common Q-function parameter or
the policy parameter shared by all actors. The focus of distributed RL is to optimize the Q-function
parameter or the policy parameter fast by generating more samples for the same wall clock time
with multiple actors. For this goal, researchers investigated various techniques for distributed RL,
e.g., asynchronous update of parameters (Mnih et al. (2016); Babaeizadeh et al. (2017)), sharing an
experience replay buffer (Horgan et al. (2018)), GPU-based parallel computation (Babaeizadeh et al.
(2017); Clemente et al. (2017)), GPU-based simulation (Liang et al. (2018)) and V-trace in case of
on-policy algorithms (Espeholt et al. (2018)). Distributed RL yields performance improvement in
terms of the wall clock time but it does not consider the possible enhancement by interaction among
a population of policies of all learners like in PBT or our P3S. The proposed P3S uses a similar
structure to that in (Nair et al. (2015); Espeholt et al. (2018)): that is, P3S is composed of multiple
learners and a chief. The difference is that each learner in P3S has its own Q or value function
parameter and policy parameter, and optimizes the parameters in parallel to search in the policy
space.
Population-Based Training Parallelism is also exploited in finding optimal parameters and hyper-
parameters of training algorithms in PBT (Jaderberg et al. (2017; 2018); Conti et al. (2018)). PBT
trains neural networks, using a population with different parameters and hyper-parameters in paral-
lel at multiple learners. During the training, in order to take advantage of the population, it evaluates
the performance of networks with parameters and hyper-parameters in the population periodically.
Then, PBT selects the best hyper-parameters, distributes the best hyper-parameters and the corre-
sponding parameters to other learners, and continues the training of neural networks. Recently, PBT
is applied to competitive multi-agent RL (Jaderberg et al. (2018)) and novelty search algorithms
(Conti et al. (2018)). The proposed P3S uses a population to search a better policy by exploiting
the best policy information similarly to PBT, but the way of using the best policy information is
different. In P3S, the parameter of the best learner is not copied but used in a soft manner to guide
the population for better search in the policy space.
Guided Policy Search Our P3S method is also related to guided policy search (Levine & Koltun
(2013); Levine et al. (2016); Teh et al. (2017); Ghosh et al. (2018)). Teh et al. (2017) proposed a
guided policy search method for joint training of multiple tasks in which a common policy is used
to guide local policies and the common policy is distilled from the local policies. Here, the local
policies’ parameters are updated to maximize the performance and minimize the KL divergence
between the local policies and the common distilled policy. The proposed P3S is related to guided
policy search in the sense that multiple policies are guided by a common policy. However, the
difference is that the goal of P3S is not learning multiple tasks but learning optimal parameter for a
common task as in PBT. Hence, the guiding policy is not distilled from multiple local policies but
chosen as the best performing policy among multiple learners.
2
Published as a conference paper at ICLR 2020
Exploiting Best Information Exploiting best information has been considered in the previous works
(White & Sofge (1992); Oh et al. (2018); Gangwani et al. (2019)). In particular, Oh et al. (2018);
Gangwani et al. (2019) exploited past good experiences to obtain a better policy, whereas P3S ex-
ploits the current good policy among multiple policies to obtain a better policy.
3 Population-Guided Parallel Policy Search
The overall structure of the proposed P3S
scheme is described in Fig. 1. We have N iden-
tical parallel learners with a shared common
experience replay buffer D, and all N identi-
cal learners employ a common base algorithm
which can be any off-policy RL algorithm. The
execution is in parallel. The i-th learner has
its own environment Ei, which is a copy of
the common environment E , and has its own
value function (e.g., Q-function) parameter θi
and policy parameter φi . The i-th learner in-
teracts with the environment copy E i with ad-
ditional interaction with the chief, as shown in Figure 1: The overall structure of P3S
Fig. 1. At each time step, the i-th learner performs an action ait to its environment copy E i by using
its own policy πφi, stores its experience (sit, ait, rti, sit+1) to the shared common replay buffer D for
all i = 1,2,... ,N. Then, each learner updates its value function parameter and policy parameter
once by drawing a mini-batch of size B from the shared common replay buffer D by minimizing its
own value loss function and policy loss function, respectively.
Due to parallel update of parameters, the policies of all learners compose a population ofN different
policies. In order to take advantage of this population, we exploit the policy information from the
best learner periodically during the training like in PBT (Jaderberg et al. (2017)). Suppose that the
Q-function parameter and policy parameter of each learner are initialized and learning is performed
as described above for M time steps. At the end of the M time steps, we determine who is the best
learner based on the average of the most recent Er episodic rewards for each learner. Let the index
of the best learner be b. Then, the policy parameter information φb of the best learner can be used
to enhance the learning of other learners for the next M time steps. Instead of copying φb to other
learners like in PBT, we propose using the information φb in a soft manner. That is, during the next
i
M time steps, while we set the loss function L(θi) for the Q-function to be the same as the loss
L(θi) of the base algorithm, we set the loss function L(φi) for the policy parameter φi of the i-th
learner as the following augmented version:
L(φi) = L(φi) + 1{i=b}βEs〜D [D(∏φi,∏φb)]	(1)
where L(φi) is the policy loss function of the base algorithm, 1{.} denotes the indicator function,
β(> 0) is a weighting factor, D(π, π0) be some distance measure between two policies π and π0.
Networks
sθou-Jθdxω
qe .1名3£e-ed
.O133UelS
eM3"Pod3
Parameters B-φb
(ʌ Update β,φb
Replay Buffer 0	Parameters β.φb
BatCh OfEXPerienCeSfrome
3.1 Theoretical Guarantee of Monotone Improvement of Expected
Cumulative Return
In this section, we analyze the performance of the proposed soft-fusion approach theoretically and
show the effectiveness of the proposed soft-fusion approach. Consider the current update period
and its previous update period. Let πφolid be the policy of the i-th learner at the end of the previous
update period and let ∏φb be the best policy among all policies ∏φid, i = 1,…，N. Now, consider
any learner i who is not the best in the previous update period. Let the policy of learner i in the
current update period be denoted by πφi , and let the policy loss function of the base algorithm
be denoted as L(πφi ). In order to analyze the performance, we consider L(πφi ) in the form of
L(∏φi) = Es〜d,。〜∏φi(∙∣s) [-Qπ0i (s, a)]. The reason behind this choice is that most of actor-
critic methods update the value (or Q-)function and the policy iteratively. That is, for given πφolid, the
πold	πold
Q-function is first updated to approximate Q φi . Then, with the approximation Q φi , the policy is
3
Published as a conference paper at ICLR 2020
updated to yield an updated policy πφniew. This procedure is repeated iteratively. Such loss function is
used in many RL algorithms such as SAC and TD3 (Haarnoja et al. (2018); Fujimoto et al. (2018)).
For the distance measure D(π, π0) between two policies π and π0, we consider the KL divergence
KL(∏∣∣∏0) for analysis. Then, by eq. (1) the augmented loss function for non-best learner i at the
current update period is expressed as
L(πφi ) = Es~D,a~∏φi(∙∣s)
[-Qπ*i (s,a)i + βEs〜D[KL(∏φi(∙∣s)ll∏φb(∙∣s))]
Ea~πφi(∙lS)
old
-Q φi (s, a) +βlog
∏φi (a|s)
∏φb (a|s)
(2)
(3)
Let πφniew be a solution that minimizes the augmented loss function eq. (3). We assume the following
conditions.
Assumption 1. For all s,
old	old
Ea〜∏φb(∙∣s) [Qπφi (s, a)] ≥ Ea〜∏oid(∙∣s) [Qπφi (s, a)] .	(A1)
Assumption 2. For some ρ, d > 0,
KLEe(∙∣s)∣∣∏φb(∙∣s)) ≥ max {ρmaxKL (πnew(∙∣s0)∣∣∏φid(∙∣s0)) ,d} , ∀s.	(A2)
Assumption 1 means that if we draw the first time step action a from πφb and the following actions
from πφolid, then this yields better performance on average than the case that we draw all actions
including the first time step action from πφolid. This makes sense because of the definition of πφb .
Assumption 2 is about the distance relationship among the policies to ensure a certain level of
spreading of the policies for the proposed soft-fusion approach. With the two assumptions above,
we have the following theorem regarding the proposed soft-fusion parallel learning scheme:
Theorem 1. Under Assumptions 1 and 2, the following inequality holds:
new	(a)
Q φi (s,a) ≥ Qπφb(s, a)+ βEst+rs∞〜∏φb
∞
X γk-t∆(sk)
k=t+1
^{^^^^^^^^^^^^^^^^^"
≥ Qπφb (s, a) ∀(s, a),
Improvement gap
where
∀i 6= b.
(4)
∆(s)= KLknew(∙∣s)∣∣∏φb(∙∣s)) - max {ρm;axKL (πnew(∙∣s0)∣∣∏φid(∙∣s0)) ,d} .	(5)
Here, inequality (a) requires Assumption 1 only and inequality (b) requires Assumption 2.
Proof. See Appendix A.
□
Theorem 1 states that the new solution πφniew for the current update period with the augmented loss
function yields better performance (in the expected reward sense) than the best policy πφb of the
previous update period for any non-best learner i of the previous update period. Hence, the proposed
parallel learning scheme yields monotone improvement of expected cumulative return.
3.2 Implementation
The proposed P3S method can be applied to any off-policy base RL algorithms whether the base RL
algorithms have discrete or continuous actions. For implementation, we assume that the best policy
update period consists of M time steps. We determine the best learner at the end of each update
period based on the average of the most recent Er episodic rewards of each learner. The key point in
implementation is adaptation of β so that the improvement gap βEst+js∞〜∏b [P∞=t+ι γk-t∆(sk)]
in (4) becomes non-negative and is maximized for given ρ and d. The gradient of the im-
provement gap with respect to β is given by ∆ := Est+^s∞〜∏b [P∞=t+ι Yk-t∆(sk)], and ∆
is the average (with forgetting) of ∆(sk) by using samples from ∏b. Hence, if ∆ > 0, i.e.,
4
Published as a conference paper at ICLR 2020
KL knew(∙∣s)∣∣∏φb(∙∣s)) > max {ρmaxs，KL (∏new(∙∣s0)∣∣∏φid(∙∣s0)) ,d} on average, then β
should be increased to maximize the performance gain. Otherwise, β should be decreased. There-
fore, we adopt the following adaptation rule for β which is common for all non-best learners:
Je J 2β
Ie J e/2
•£ ΓΛ	、____r . ΓΛ	.7	1 . . 1 r
if Dspread > max{ρDch
ange, dmin} × 1.5
if Dspread < max{ρDch
ange, dmin}/1.5
(6)
Here, Dspread = N-LI Pi∈I-b Es-D [D(∏new ,∏φb)]
is the estimated distance between πφniew and
Πφb, and D Change = NLI Pi∈I-b Es-D ∣D(∏new ,∏φid)]
is the estimated distance between πφniew
and πφolid averaged over all N - 1 non-best learners, where dmin and ρ are predetermined hyper-
parameters. Dspread and max{ρDchange, dmin} are our practical implementations of the left-hand
side (LHS) and the right-hand side (RHS) of eq. (A2), respectively. This adaptation method is
similar to that used in PPO (Schulman et al. (2017)).
The update (6) of e is done every M time steps and the updated e
is used for the next M time steps. As time steps elapse, e is settled
down so that Dspread is around dsearch = max{ρDchange , dmin }
and this implements Assumption 2 with equality. Hence, the pro-
posed P3S scheme searches a spread area with rough radius dsearch
around the best policy in the policy space, as illustrated in Fig. 2.
The search radius dsearch is determined proportionally to Dchange
that represents the speed of change in each learner’s policy. In the
case of being stuck in local optima, the change Dchange can be
small, making the search area narrow. Hence, we set a minimum
search radius dmin to encourage escaping out of local optima.
Figure 2: The conceptual
search coverage in the policy
space by parallel learners
We applied P3S to TD3 as the base algorithm. The constructed algorithm is named P3S-TD3.
The details of TD3 is explained in Appendix G. We used the mean square difference given by
D(∏(s),∏0(s)) = 2 k∏(s) 一 ∏0(s)k2 as the distance measure between two policies for P3S-TD3.
Note that if we consider two deterministic policies as two stochastic policies with same standard
deviation, the KL divergence between the two stochastic policies is the same as the mean square
difference. For initial exploration P3S-TD3 uses a uniform random policy and does not update all
policies over the first Tinitial time steps. The pseudocode of the P3S-TD3 is given in Appendix H.
The implementation code for P3S-TD3 is available at https://github.com/wyjung0625/
p3s.
4 Experiments
4.1	Comparison to baselines
In this section, we provide numerical results on performance comparison between the proposed
P3S-TD3 algorithm and current state-of-the-art on-policy and off-policy baseline algorithms on sev-
eral MuJoCo environments (Todorov et al. (2012)). The baseline algorithms are Proximal Policy
Optimization (PPO) (Schulman et al. (2017)), Actor Critic using Kronecker-Factored Trust Region
(ACKTR) (Wu et al. (2017)), Soft Q-learning (SQL) (Haarnoja et al. (2017)), (clipped double Q)
Soft Actor-Critic (SAC) (Haarnoja et al. (2018)), and TD3 (Fujimoto et al. (2018)).
Hyper-parameter setting All hyper-parameters we used for evaluation are the same as those in the
original papers (Schulman et al. (2017); Wu et al. (2017); Haarnoja et al. (2017; 2018); Fujimoto
et al. (2018)). Here, we provide the hyper-parameters of the P3S-TD3 algorithm only, while details
of the hyper-parameters for TD3 are provided in Appendix I. On top of the hyper-parameters for
the base algorithm TD3, we used N = 4 learners for P3S-TD3. To update the best policy and
e, the period M = 250 is used. The number of recent episodes Er = 10 was used to determine
the best learner b. For the search range, we used the parameter ρ = 2, and tuned dmin among
dmin = {0.02, 0.05} for all environments. Details on dmin for each environment is shown in
Appendix I. The time steps for initial exploration Tinitial is set as 250 for Hopper-v1 and Walker2d-
v1 and as 2500 for HalfCheetah-v1 and Ant-v1.
5
Published as a conference paper at ICLR 2020
(a) Hopper-v1	(b) Walker2d-v1	(c) HalfCheetah-v1	(d) Ant-v1
Figure 3: Performance for PPO (red), ACKTR (purple), SQL (brown), (clipped double Q) SAC
(orange), TD3 (green), and P3S-TD3 (proposed method, blue) on MuJoCo tasks.
Evaluation method Fig. 3 shows the learning curves over one million time steps for several MuJoCo
tasks: Hopper-v1, Walker2d-v1, HalfCheetah-v1, and Ant-v1. In order to have sample-wise fair
comparison among the considered algorithms, the time steps in the x-axis in Fig. 3 for P3S-TD3
is the sum of time steps of all N users. For example, in the case that N = 4 and each learner
performs 100 time steps in P3S-TD3, the corresponding x-axis value is 400 time steps. Since each
learner performs parameter update once with one interaction with environment per each time step
in P3S-TD3, the total number of parameter updates at the same x-axis value in Fig. 3 is the same
for all algorithms including P3S-TD3, and the total number of interactions with environment at
the same x-axis value in Fig. 3 is also the same for all algorithms including P3S-TD3. Here, the
performance is obtained through the evaluation method which is similar to those in Haarnoja et al.
(2018); Fujimoto et al. (2018). Evaluation of the policies is conducted every Reval = 4000 time
steps for all algorithms. At each evaluation instant, the agent (or learner) fixes its policy as the one at
the evaluation instant, and interacts with the same environment separate for the evaluation purpose
with the fixed policy to obtain 10 episodic rewards. The average of these 10 episodic rewards is the
performance at the evaluation instant. In the case of P3S-TD3 and other parallel learning schemes,
each of the N learners fixes its policy as the one at the evaluation instant, and interacts with the
environment with the fixed policy to obtain 10 episodic rewards. First, the 10 episodic rewards
are averaged for each learner and then the maximum of the 10-episode-average rewards of the N
learners is taken as the performance at that evaluation instant. We performed this operation for five
different random seeds, and the mean and variance of the learning curve are obtained from these five
simulations. The policies used for evaluation are stochastic for PPO and ACKTR, and deterministic
for the others.
Performance on MuJoCo environments In Fig. 3, it is observed that all baseline algorithms is
similar to that in the original papers (Schulman et al. (2017); Haarnoja et al. (2018); Fujimoto et al.
(2018)). With this verification, we proceed to compare P3S-TD3 with the baseline algorithms. It
is seen that the P3S-TD3 algorithm outperforms the state-of-the-art RL algorithms in terms of both
the speed of convergence with respect to time steps and the final steady-state performance (except in
Walker2d-v1, the initial convergence is abit slower than TD3.) Especially, in the cases of Hopper-v1
and Ant-v1, TD3 has large variance and this implies that the performance of TD3 is quite dependent
on the initialization and it is not easy for TD3 to escape out of bad local minima resulting from
bad initialization in certain environments. However, it is seen that P3S-TD3 yields much smaller
variance than TD3. This implies that the wide area search by P3S in the policy space helps the
learners escape out of bad local optima.
4.2 Comparison with other parallel learning schemes and ablation study
In the previous subsection, we observed that P3S enhances the performance and reduces dependence
on initialization as compared to the single learner case with the same complexity. In fact, this should
be accomplished by any properly-designed parallel learning scheme. Now, in order to demonstrate
the true advantage of P3S, we compare P3S with other parallel learning schemes. P3S has several
components to improve the performance based on parallelism: 1) sharing experiences from multiple
policies, 2) using the best policy information, and 3) soft fusion of the best policy information for
wide search area. We investigated the impact of each component on the performance improvement.
For comparison we considered the following parallel policy search methods gradually incorporating
more techniques:
6
Published as a conference paper at ICLR 2020
(f) Del. Walker2d-v1
(e) Del. Hopper-v1
(g) Del. HalfCheetah-v1
(h) Del. Ant-v1
Figure 4: Performance of different parallel learning methods on MuJoCo environments (up), on
delayed MuJoCo environments (down)
1.	Original Algorithm The original algorithm (TD3) with one learner
2.	Distributed RL (DRL) N actors obtain samples from N environment copies. The com-
mon policy and the experience replay buffer are shared by all N actors.
3.	Experience-Sharing-Only (ESO) N learners interact with N environment copies and up-
date their own policies using experiences drawn from the shared experience replay buffer.
4.	Resetting (Re) At every M0 time steps, the best policy is determined and all policies are
initialized as the best policy, i.e., the best learner’s policy parameter is copied to all other
learners. The rest of the procedure is the same as experience-sharing-only algorithm.
5.	P3S At every M time steps, the best policy information is determined and this policy is
used in a soft manner based on the augmented loss function.
Note that the resetting method also exploits the best policy information from N learners. The main
difference between P3S and the resetting method is the way the best learner’s policy parameter is
used. The resetting method initializes all policies with the best policy parameter every M0 time
steps like in PBT (Jaderberg et al. (2017)), whereas P3S algorithm uses the best learner’s policy
parameter information determined every M time steps to construct an augmented loss function. For
fair comparison, M and M0 are determined independently and optimally for P3S and Resetting,
respectively, since the optimal period can be different for the two methods. We tuned M0 among
{2000, 5000, 10000} (MuJoCo environments) and {10000, 20000, 50000} (Delayed MuJoCo envi-
ronments) for Re-TD3, whereas M = 250 was used for P3S-TD3. The specific parameters used for
Re-TD3 are in Appendix I. Since all N policies collapse to one point in the resetting method at the
beginning of each period, we expect that a larger period is required for resetting to have sufficiently
spread policies at the end of each best policy selection period. We compared the performance of
the aforementioned parallel learning methods combined with TD3 on two classes of tasks; MuJoCo
environments, and Delayed sparse reward MuJoCo environments.
Performance on MuJoCo environments The upper part of Fig. 4 shows the learning curves of the
considered parallel learning methods combined with TD3 for the four tasks (Hopper-v1, Walkerd-v1,
HalfCheetah-v1 and Ant v1). It is seen that P3S-TD3 outperforms other parallel methods: DRL-
TD3, ESO-TD3 and Re-TD3 except the case that ESO-TD3 or Re-TD3 slightly outperforms P3S-
TD3 in Hopper-v1 and Walker2d-v1. In the case of Hopper-v1 and Walker2d-v1, ESO-TD3 has
better final (steady-state) performance than all other parallel methods. Note that ESO-TD3 obtains
most diverse experiences since the N learners shares the experience replay buffer but there is no
interaction among the N learners until the end of training. So, it seems that this diverse experience
is beneficial to Hopper-v1 and Walker2d-v1.
7
Published as a conference paper at ICLR 2020
(a)	(b)
(c)
Figure 5: Ablation study of P3S-TD3 on Delayed Ant-v1: (a) Performance and β (1 seed) with
dmin = 0.05, (b) Distance measures with dmin = 0.05, and (c) Comparison with different dmin =
0.02, 0.05
Performance on Delayed MuJoCo environments Sparse reward environments especially require
more search to obtain a good policy. To see the performance of P3S in sparse reward environments,
we performed experiments on Delayed MuJoCo environments. Delayed MuJoCo environments are
reward-sparsified versions of MuJoCo environments and used in Zheng et al. (2018). Delayed Mu-
JoCo environments give non-zero rewards periodically with frequency freward or only at the end of
episodes. That is, in a delayed MuJoCo environment, the environment accumulates rewards given
by the corresponding MuJoCo environment while providing zero reward to the agent, and gives the
accumulated reward to the agent. We evaluated the performance on the four delayed environments
with freward = 20: Delayed Hopper-v1, Delayed Walker2d-v1, Delayed HalfCheetah-v1 and De-
layed Ant-v1.
The lower part of Fig. 4 shows the learning curves of the different parallel learning methods for the
four delayed MuJoCo environments. It is seen that P3S outperforms all other considered parallel
learning schemes on all environments except on delayed Hopper-v1. It seems that the enforced
wide-area policy search with the soft-fusion approach in P3S is beneficial to improve performance
in sparse reward environments.
Benifits of P3S Delayed Ant-v1 is a case of sparse reward environment in which P3S shows signif-
icant improvement as compared to other parallel schemes. As shown in Fig. 4h, the performance of
TD3 drops below zero initially and converges to zero as time goes. Similar behavior is shown for
other parallel methods except P3S. This is because in Delayed Ant-v1 with zero padding rewards
between actual rewards, initial random actions do not generate significant positive speed to a for-
ward direction, so it does not receive positive rewards but receives negative actual rewards due to the
control cost. Once its performance less than 0, learners start learning doing nothing to reach zero
reward (no positive reward and no negative reward due to no control cost). Learning beyond this
seems difficult without any direction information for parameter update. This is the interpretation
of the behavior of other algorithms in Fig. 4h. However, it seems that P3S escapes from this local
optimum by following the best policy. This is evident in Fig. 5a, showing that after few time steps,
β is increased to follow the best policy more. Note that at the early stage of learning, the perfor-
mance difference among the learners is large as seen in the large Db spread values in Fig. 5b. As time
elapses, all learners continue learning, the performance improves, and the spreadness among the
learners’ policies shrinks. However, the spreadness among the learners’ policies is kept at a certain
level for wide policy search by dmin , as seen in Fig. 5b. Fig. 5c shows the performance of P3S with
dmin = 0.05 and 0.02. It shows that a wide area policy search is beneficial as compared to a narrow
area policy search. However, it may be detrimental to set too large a value for dmin due to too large
statistics discrepancy among samples from different learners’ policies.
5 Conclusion
In this paper, we have proposed a new population-guided parallel learning scheme, P3S, to enhance
the performance of off-policy RL. In the proposed P3S scheme, multiple identical learners with their
own value-functions and policies sharing a common experience replay buffer search a good policy
with the guidance of the best policy information in the previous search interval. The information of
the best policy parameter of the previous search interval is fused in a soft manner by constructing
an augmented loss function for policy update to enlarge the overall search region by the multiple
8
Published as a conference paper at ICLR 2020
learners. The guidance by the previous best policy and the enlarged search region by P3S enables
faster and better search in the policy space, and monotone improvement of expected cumulative
return by P3S is theoretically proved. The P3S-TD3 algorithm constructed by applying the proposed
P3S scheme to TD3 outperforms most of the current state-of-the-art RL algorithms. Furthermore, the
performance gain by P3S over other parallel learning schemes is significant on harder environments
especially on sparse reward environments by searching wide range in policy space.
Acknowledgments
This work was supported in part by the ICT R&D program of MSIP/IITP (2016-0-00563, Research
on Adaptive Machine Learning Technology Development for Intelligent Autonomous Digital Com-
panion) and in part by the National Research Foundation of Korea(NRF) grant funded by the Korea
government(Ministry of Science and ICT) (NRF2017R1E1A1A03070788).
References
Mohammad Babaeizadeh, Iuri Frosio, Stephen Tyree, Jason Clemons, and Jan Kautz. Reinforcement
learning through asynchronous advantage actor-critic on a GPU. In International Conference on
Learning Representations, Apr 2017.
Gabriel Barth-Maron, Matthew W. Hoffman, David Budden, Will Dabney, Dan Horgan, Dhruva TB,
Alistair Muldal, Nicolas Heess, and Timothy Lillicrap. Distributed distributional deterministic
policy gradients. In International Conference on Learning Representations, Apr 2018.
Yuri Burda, Harrison Edwards, Amos Storkey, and Oleg Klimov. Exploration by random network
distillation. May 2019.
Krzysztof Choromanski, Mark Rowland, Vikas Sindhwani, Richard E. Turner, and Adrian Weller.
Structured evolution with compact architectures for scalable policy optimization. In Proceedings
ofthe 35th International Conference on Machine Learning, pp. 970-978, Jul 2018.
Alfredo V. Clemente, HUmberto N. Castejon, and Arjun Chandra. Efficient parallel methods for
deep reinforcement learning. arXiv preprint arXiv:1705.04862, 2017.
Edoardo Conti, Vashisht Madhavan, Felipe Petroski Such, Joel Lehman, Kenneth O. Stanley, and
Jeff Clune. Improving exploration in evolution strategies for deep reinforcement learning via a
population of novelty-seeking agents. pp. 5027-5038, Dec 2018.
Maria Dimakopoulou and Benjamin Van Roy. Coordinated exploration in concurrent reinforcement
learning. In Proceedings of the 35th International Conference on Machine Learning, volume 80,
pp. 1271-1279, Jul 2018.
Maria Dimakopoulou, Ian Osband, and Benjamin Van Roy. Scalable coordinated exploration in
concurrent reinforcement learning. In Advances in Neural Information Processing Systems, pp.
4223-4232, Dec 2018.
Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymyr Mnih, Tom Ward, Yotam
Doron, Vlad Firoiu, Tim Harley, Iain Dunning, Shane Legg, and Koray Kavukcuoglu. IMPALA:
Scalable distributed deep-RL with importance weighted actor-learner architectures. In Proceed-
ings of the 35th International Conference on Machine Learning, pp. 1407-1416, Jul 2018.
Scott Fujimoto, Herke van Hoof, and David Meger. Addressing function approximation error in
actor-critic methods. In Proceedings of the 35th International Conference on Machine Learning,
pp. 1587-1596, Jul 2018.
Tanmay Gangwani, Qiang Liu, and Jian Peng. Learning self-imitating diverse policies. In Interna-
tional Conference on Learning Representations, May 2019.
Dibya Ghosh, Avi Singh, Aravind Rajeswaran, Vikash Kumar, and Sergey Levine. Divide-and-
conquer reinforcement learning. In International Conference on Learning Representations, Apr
2018.
9
Published as a conference paper at ICLR 2020
Zhaohan Guo and Emma Brunskill. Concurrent PAC RL. In AAAI Conference on Artificial Intelli-
gence,pp. 2624-2630, Jan 2015.
Tuomas Haarnoja, Haoran Tang, Pieter Abbeel, and Sergey Levine. Reinforcement learning with
deep energy-based policies. In Proceedings of the 34th International Conference on Machine
Learning, pp. 1352-1361, 2017.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy
maximum entropy deep reinforcement learning with a stochastic actor. In Proceedings of the 35th
International Conference on Machine Learning, pp. 1861-1870, Jul 2018.
Dan Horgan, John Quan, David Budden, Gabriel Barth-Maron, Matteo Hessel, Hado Van Has-
selt, and David Silver. Distributed prioritized experience replay. In International Conference on
Learning Representations, Apr 2018.
Max Jaderberg, Valentin Dalibard, Simon Osindero, Wojciech M. Czarnecki, Jeff Donahue, Ali
Razavi, Oriol Vinyals, Tim Green, Iain Dunning, Karen Simonyan, Chrisantha Fernando,
and Koray Kavukcuoglu. Population based training of neural networks. arXiv preprint
arXiv:1711.09846, 2017.
Max Jaderberg, Wojciech M. Czarnecki, Iain Dunning, Luke Marris, Guy Lever, Antonio Garcia
Castaneda, Charles Beattie, Neil C. Rabinowitz, Ari S. Morcos, Avraham Ruderman, Nico-
las Sonnerat, Tim Green, Louise Deason, Joel Z. Leibo, David Silver, David Hassabis, Koray
Kavukcuoglu, and Thore Graepel. Human-level performance in first-person multiplayer games
with population-based deep reinforcement learning. arXiv preprint arXiv:1807.01281, 2018.
Shauharda Khadka and Kagan Tumer. Evolution-guided policy gradient in reinforcement learning.
In Advances in Neural Information Processing Systems, pp. 1196-1208, Dec 2018.
Sergey Levine and Vladlen Koltun. Guided policy search. In Proceedings of the 30th International
Conference on Machine Learning, pp. 1-9, 2013.
Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuo-
motor policies. The Journal of Machine Learning Research, 17(1):1334-1373, 2016.
Jacky Liang, Viktor Makoviychuk, Ankur Handa, Nuttapong Chentanez, Miles Macklin, and Dieter
Fox. GPU-accelerated robotic simulation for distributed reinforcement learning. In Conference
on Robot Learning, pp. 270-282, 2018.
Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint arXiv:1509.02971, 2015.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy P. Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. In Proceedings of the 33rd International Conference on Machine Learning, pp. 1928-
1937, 2016.
Arun Nair, Praveen Srinivasan, Sam Blackwell, Cagdas Alcicek, Rory Fearon, Alessandro De Maria,
Vedavyas Panneershelvam, Mustafa Suleyman, Charles Beattie, Stig Petersen, Shane Legg,
Volodymyr Mnih, Koray Kavukcuoglu, and David Silver. Massively parallel methods for deep
reinforcement learning. arXiv preprint arXiv:1507.04296, 2015.
Junhyuk Oh, Yijie Guo, Satinder Singh, and Honglak Lee. Self-imitation learning. In Proceedings
of the 35th International Conference on Machine Learning, pp. 3878-3887, 2018.
Alois PoUrchot and Olivier Sigaud. CEM-RL: Combining evolutionary and gradient-based methods
for policy search. In International Conference on Learning Representations, 2019.
Tim Salimans, Jonathan Ho, Xi Chen, Szymon Sidor, and Ilya Sutskever. Evolution strategies as a
scalable alternative to reinforcement learning. arXiv preprint arXiv:1703.03864, 2017.
10
Published as a conference paper at ICLR 2020
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region
policy optimization. In Proceedings of the 32nd International Conference on Machine Learning,
pp.1889-1897, 2015.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy
optimization algorithms. arXiv preprint arXiv:1707.06347, 2017.
David Silver, Leonard Newnham, David Barker, Suzanne Weller, and Jason McFall. Concurrent re-
inforcement learning from customer interactions. In International Conference on Machine Learn-
ing, volume 28, pp. 924-932, Jun 2013.
Yee Whye Teh, Victor Bapst, Wojciech M. Czarnecki, John Quan, James Kirkpatrick, Raia Had-
sell, Nicolas Heess, and Razvan Pascanu. Distral: Robust multitask reinforcement learning. In
Advances in Neural Information Processing Systems, pp. 4499-4509, Dec 2017.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026-
5033. IEEE, Oct 2012.
David A. White and Donald A. Sofge. The role of exploration in learning control. Handbook of
Intelligent Control: Neural, Fuzzy and Adaptive Approaches, pp. 1-27, 1992.
Yuhuai Wu, Elman Mansimov, Roger Grosse, Shun Liao, and Jimmy Ba. Scalable trust-region
method for deep reinforcement learning using kronecker-factored approximation. In Advances in
Neural Information Processing Systems, pp. 5279-5288, Dec 2017.
Zeyu Zheng, Junhyuk Oh, and Satinder Singh. On learning intrinsic rewards for policy gradient
methods. In Advances in Neural Information Processing Systems, pp. 4649-4659, Dec 2018.
11
Published as a conference paper at ICLR 2020
Appendix A. Proof of Theorem 1
In this section, we prove Theorem 1. Let πφolid be the policy of the i-th learner at the end of the
previous update period and let ∏φb be the best policy among all policies ∏φid, i = 1,… ，N. Now,
consider any learner i who is not the best in the previous update period. Let the policy of learner i
in the current update period be denoted by πφi, and let the policy loss function of the base algorithm
be denoted as L(πφi), given in the form of
L(∏φi ) = Es~D,a~πφi(∙∣s) ^QnOid (s,a)[
(7)
The reason behind this choice is that most of actor-critic methods update the value (or Q-)function
and the policy iteratively. That is, for given πφolid, the Q-function is first updated so as to approximate
πold	πold
Q φi . Then, with the approximation Q φi the policy is updated to yield an updated policy πφniew ,
and this procedure is repeated iteratively. Such loss function is used in many RL algorithms such
as SAC and TD3 (Haarnoja et al. (2018); Fujimoto et al. (2018)). SAC updates its policy by mini-
mizing Es~D,a~∏∕(.∣s) [-Qπold(s, a) + logπ0(a∣s)] over π0. TD3 updates its policy by minimizing
Es~D,a=∏0(s) [-Qπold (s, a)].
With the loss function eq. (7) and the KL divergence KL(∏∣∣∏0) as the distance measure D(∏, ∏0)
between two policies π and π0 as stated in the main paper, the augmented loss function for non-best
learner i at the current update period is expressed as
L(πφi ) = Es~D,a~∏φi(∙∣s)
h-Qπoid (s,。)] + βEs~D [KL(∏φi (∙∣s)∣∣∏φb (∙∣s))]
πold	πφi (a|s)
Es~D Ea~∏ i(∙∣s) -Q φi(s,a)+ β log 0 Z m
L	φi	[	∏φb (a|s)
Let πφniew be a solution that minimizes the augmented loss function eq. (9).
Assumption 1. For all s,
πold	πold
Ea~πφb(∙∣s) IQ φi Ga" ≥ Ea~πoid(∙∣s) [q φi (s, a" ∙
Assumption 2. For some ρ, d > 0,
KLknew(∙∣s)∣∣∏φb(∙∣s)) ≥ max {ρmaxKLs(∙∣s0)∣∣∏Φid(∙∣s0))，”}，∀s∙
(8)
(9)
(10)
(11)
For simplicity of notations, we use the following notations from here on.
•	πi for πφi
•	πoild for πφolid
•	πni ew for πφniew
•	πb for πφb .
•	KLmax (πnew ||n0id) for maxs0 KL 卜 new (∙ls0)llπφid(∙ls0))
A.1. A Preliminary Step
Lemma 1. Let πni ew be the solution of the augmented loss function eq. (9). Then, with Assumption
1, we have the following:
Ea~πnew(Ts) [Q∏θld (s，a)i ≥ Ea~∏0id(∙∣s) hQnOld(S，a)]	(12)
for all s.
12
Published as a conference paper at ICLR 2020
Proof. For all s,
Ea〜∏ild(∙∣s) h-Qπold(s,a)i ≥ Ea〜∏b(∙∣s) h-Qπold(s,a)i	(13)
o	(a)
=Ea〜πb(∙∣s) -QnOld(S, a) + β log S ! ʌ	(14)
' 一	πb(a∣s)
≥ EaFS(∙∣sJ-Qπ0ld(s,a)+ βlog π⅛W 1	(15)
(b)	new、— L	πb(a∣s)
≥ Ea〜πnew(Ts) h-Q∏οld(s,a)i，	(16)
where Step (a) holds by Assumption 1, (b) holds by the definition of πniew, and (c) holds since KL
divergence is always non-negative.	□
With Lemma 1, we prove the following preliminary result before Theorem 1:
Proposition 1. With Assumption 1, the following inequality holds for all s and a:
ii
Qπnew (s, a) ≥ QπOld (s, a).	(17)
Proof of Proposition 1. For arbitrary st and at,
i
QπOld(st, at)
=r(st,at) + YEst+ι〜p(∙∣st,at) [Eat+1〜∏old [Qπ0ld(St+1,at+l)]]	(18)
≤ r(st,at) + YEst+ι~p(.∣st,at) [Eat+1〜πnew [Q old (st+1, at+1 )|	(19)
=Est+i：st+2〜∏new [r(St,at) + Yr(St+1,at+1) + Y2Eat+2〜n0ld [Qπ0ld(st+2,at+2)]]	QO)
≤ Est+1 ：st+2~nnew Ir(St, at)+ Yr(St+1,at+1) + Y2Eat+2 〜πnew [Qπ0ld(St+2, at+2)□	QI)
≤ ...	(22)
∞
≤ Est+I：s8〜nnew X γk *r(Sk,ak)	(23)
k=t
i
= Qπnew (St, at),	(24)
wherep(∙∣St,at) in eq. (18)is the environment transition probability, and St+ι : St+2 〜 ∏ii,ew in eq.
(20) means that the trajectory from St+1 to St+2 is generated by πni ew together with the environment
transition probability p(∙∣St, at). (Since the use of p(∙∣St,at) is obvious, we omittedp(∙∣St,at) for
notational simplicity.) Steps (a) and (b) hold due to Lemma 1.	□
A.2. Proof of Theorem 1
Proposition 1 states that for a non-best learner i, the updated policy πni ew with the augmented loss
function yields better performance than its previous policy πoild, but Theorem 1 states that for a non-
best learner i, the updated policy πni ew with the augmented loss function yields better performance
than even the previous best policy πb .
To prove Theorem 1, we need further lemmas: We take Definition 1 and Lemma 2 directly from
reference (Schulman et al. (2015)).
Definition 1 (From Schulman et al. (2015)). Consider two policies π and π0. The two policies π
and π0 are α-coupled if Pr (a = a0) ≤ α, (a, a0)〜(π(∙∣s), π0(∙∣s)) forall S.
Lemma 2 (From Schulman et al. (2015)). Given α-coupled policies π and π0, for all S,
|Ea〜∏0 [Aπ(s, a)]| ≤ 2αmax ∣Aπ(s, a)|,	(25)
s,a
where Aπ (S, a) is the advantage function.
13
Published as a conference paper at ICLR 2020
Proof. (From Schulman et al. (2015))
∣Ea~∏o [Aπ (s,a)]∣ = ∣Ea0~∏0 [Aπ(s,a0)] - Ea~∏ [Aπ (s,a)]∣	(26)
(a)
=∣E(a,a0)~(π,π0)[Aπ(s,a0)-Aπ(s,a)]	(27)
=|Pr(a = a )E(a,a0)~(n,n0)|a=a0 [A (s, a ) - A (s, a)]
+ PKa = a0)E(a,a0)~(n,n0)|a=a0 [A" (S, a0) - An (S, a)] |	(28)
= Pr(a 6= a0)|E(a
,a0)~(π,π0)∣a=a0[Aπ(s,a0) - An(s,a)]∣	(29)
≤ 2α max ∣Aπ(s,α)∣ ,	(30)
s,a
where Step (a) holds since E0~∏ [Aπ (s, a)] = 0 for all S by the property of an advantage function.
□
By modifying the result on the state value function in Schulman et al. (2015), we have the following
lemma on the Q-function:
Lemma 3. Given two policies π and π0, the following equality holds for arbitrary S0 and a0:
∞
Qπ0(s0,ao) = Qπ(s0,ao) + γEτ~∏0 XYtTAn(st,at) ,	(31)
t=1
where ET ~∏ is expectation over trajectory T which start from a state si drawn from the transition
probability p(∙∣so, ao) ofthe environment.
Proof. Note that
Qn (s0, ao)	=	r0	+	YEsι~p(∙∣s0,ao)	[V"(si)]	(32)
Qn(S0, a0)	=	r0	+	YEsι~p(∙∣s0,ao)	[V" (s1)i	(33)
Hence, it is sufficient to show the following equality:
∞
Eτ~∏0 X YjAn (st, at) = Esι~p(∙∣so,ao∕Vn0 (si)] - Esι~p(∙∣so,ao) [V" (si)]	(34)
t=i
Note that
An (St, at) = Est+ι~p(∙∣st,αt) [rt + YV" (st+1) - V" (st)]	(35)
Then, substituting eq. (35) into the LHS of eq. (34), we have
ET ~n0	∞ XYt-iAn(st,at)	=ET ~n0	∞ XYt-i(r	t + YVn(st+i) - Vn(st))	(36)
	t=i	=ET ~n0	t=i ∞ XYt-irt	- Esι~p(∙∣S0,ao) [Vn (Si)]	(37)
			t=i		
=Esι~p(∙∣so,"o JV '(Si )] - Esi ~p(∙∣so,αo) [V F (si)] ,	(38)
where eq. (37) is valid since Et~∏o [P∞=i YtT(YVn(st+i) — Vn(st))]	=
-Esι~p(.∣s0,ao) [Vn(si)]. Since the RHS of eq. (38) is the same as the RHS of eq. (34),
the claim holds.	口
Then, we can prove the following lemma regarding the difference between the Q-functions of two
α-coupled policies π and π0 :
Lemma 4. Let π and π0 be α-coupled policies. Then,
∣Qn(s, a) — Qn0(s,a)∣ ≤ ；—Y max {Cα2,1∕C},	(39)
where = maxs,a |An (s, a)| and C > 0
14
Published as a conference paper at ICLR 2020
Proof. From Lemma 3, we have
∞
Qπ(so, ao) - Qπ(so, a。) = γEτ〜∏0 X YtTAn(st,at) .	(40)
t=1
Then, from eq. (40) we have
∣Qπ0(s0,ao) — Qn(s0,a0)∣ = γEτ〜∏0 XYt-1Aπ(st,at) I	(41)
t=1
∞
≤ YXY j ∣Est,at〜∏0 [An(st,at)]∣	(42)
t=1
∞
≤ Y X Yt-12α max |An (s, a)|	(43)
t=1	s,a
=-^Y- 2α	(44)
1-Y
≤ ι-γ (Cα2 + 1/C)	(45)
≤ JY 2 max {Cα2,1/C},	(46)
where = maxs,a |An(s, a)| and C > 0. Here, eq. (43) is valid due to Lemma 2, eq. (45) is valid
since Cɑ2 + 1/C - 2α = C (α - C)2 ≥ 0, and eq. (46) is valid since the sum of two terms is less
than or equal to two times the maximum of the two terms.	□
Up to now, we considered some results valid for given two α-coupled policies π and π0. On the other
hand, it is shown in Schulman et al. (2015) that for arbitrary policies π and π0, if we take α as the
maximum (over s) of the total variation divergence max§ DTV (∏(∙∣s)∣∣∏0(∙∣s)) between ∏(∙∣s) and
π0(∙∣s), then the two policies are α-coupled with the α value of a = max§ DTV(∏(∙∣s)∣∣∏0(∙∣s)).
Applying the above facts, we have the following result regarding πni ew and πoi ld:
Lemma 5. For some constants ρ, d > 0,
Qnnew (s, a) ≤ Qnold(S, a) + β max {ρKLmax (∏L |忌"),d}	(47)
for all s and a, where KLmax (π∣∣π0) = max§ KL (π(∙∣s)∣∣π0(∙∣s)).
Proof. For πni ew and πoild, take α as the maximum of the total variation divergence between πni ew
and ∏0id, i.e., α = max§ DTV(∏4ew(∙∣s)∣∣∏0id(∙∣s)). Let this α value be denoted by a. Then, by
the result of Schulman et al. (2015) mentioned in the above, ∏new and are α-coupled with
α = maxs DTV Mew (Is)llnOld(Is)). SinCe
DTV(∏new(∙∣s)ll∏0id(∙∣s))2 ≤ KL(∏new(∙∣s)ll∏0id(∙∣s)),	(48)
by the relationship between the total variation divergence and the KL divergence, we have
α2 ≤ maxKL(∏Lw(Is)llnOid(Is)).	(49)
s
Now, substituting n = ∏new, n0 = nO3 and a = α into eq. (39) and applying eq. (49), We have
IQnnew(S, a) - Qnold(S, a) ∣ ≤ β max {ρKLmaχ (∏new∣∣∏0id) ,d}	(50)
for some ρ, d > 0. Here, proper scaling due to the introduction of β is absorbed into ρ
and d. That is, P can be set as β(Yγ and d can be set as .(上；)。. Then, by Proposition
II	II
ii ii
1,	IIQnnew (s,	a)	- Qnold (s,	a)II	in the LHS of eq. (50) becomes	IIQnnew (s,	a)	- Qnold (s,	a)II	=
ii
Qnnew (s, a) - Qnold (s, a). Hence, from this fact and eq. (50), we have eq. (47). This concludes
proof.	□
15
Published as a conference paper at ICLR 2020
Proposition 2. With Assumption 1, we have
Ea5new(.∣s) [Qπnew(s,α)i ≥ E皿∏b(.∣s) [Qπnew(s,α)] + β∆⑹.	(51)
where
δ(S)= [ KL (nJ (∙∣s)∣∣π6(∙∣s)) — max {ρKLmax (πintiw ∖∖πiold) ,d}]	(52)
Proof.
Ea〜πb(∙∣s)卜Qπnew(s, α)]	(53)
≥ Ea〜∏b(∙∣sj-Qπold(s,a)] — β max {ρKLmaX (π°new ∣∣π0ld) ,d}	(54)
(a)
i	πb(a∣s)^l
=Ea 〜∏b(∙∣s) -Q old (s,a) + β log πb(a∣s) - β max {ρKLmax (πnew ∣∣∏0id) ,d]	(55)
≥ Ea 〜Fw (∙∣Sj-Qπold(s,a) + β log π⅛w⅞V 1 - β max {ρKLmax HeW ∣∣ 篇d) ,d}	(56)
(b)	L	π (a∣S) _
=EaFeW(∙∣s) [-Qπold (s,a)] + βKL (πnew (∙∣s)∣∣πb (∙∣S)) - β max {ρKLmaX (nL ∣∣πold) ,d}
(57)
=EaFeWGISJ-Qπold(s,a)] + β [KL KeW (∙∣s)∣∣nb(∙∣s)) - max {ρKLmaX 侬晨 ∣∣ 篇d) ,d}]
(58)
=Ea5new(. ∣ S) [-Qπ°ld(s,a)] + β∆(s)	(59)
≥ EaFeW (∙ ∣ s) [-QnneW (s,a)] + g(s),	(60)
where step (a) is valid due to Lemma 5, step (b) is valid due to the definition of n^w, and step (c) is
valid due to Proposition 1.	□
Finally, we prove Theorem 1.
Theorem 1. Under Assumptions 1 and 2, thefollowing inequality holds:
一∞	-
Qπnew (s,a) ≥ Qπ"(s,a) + βEs,+rs∞〜∏b	X Yk-t∆(sfc) ≥ Qπ" (s, a), ∀(s,a), Vi = b.
_k=t+1	.
(61)
where
∆(s) = [ KL Eew (∙∣s)∣∣nb(∙∣s)) - max {PKLmax (nilew ∣∣n0ld) ,d}]	(62)
Proof of Theorem 1: Proof of Theorem 1 is by recursive application of Proposition 2. For arbitrary
St and at,
_i ,	,
Q new (st,at)
=r(st,at)+ YESt+ι 〜p(∙ ∣ st,at JEat+1 FeWlQπnew(st+1,at+1)]]	(63)
≥ r(st, at) + YESt+ι 〜p(∙ ∣ St ,at JEat+1 〜πb IQnneW(St+1, at+1)] + β δ(St+1)]	(64)
=ESt+1 ：St+2~nb Ir(St, at) + Yr(St+1, at+1) + Y2Eat+2〜nneW IQnneW(St+2, at+2)]]
+ βESt+ι,St+2〜nb [Y∆(St+ι)]	(65)
≥ ESt+i：St+2 〜πb Ir(St,at) + Yr(St+1,at+1) + Y2Eat+2 〜πb IQnneW (St+2 ,at+2 )] + βY 次(St+2)]
+ βESt+i：St+2〜nb [Yδ(St+1)]	(66)
16
Published as a conference paper at ICLR 2020
> ...
∞
> Est+ιis∞~πb〉： Y r(sk, ak)
_k=t
Qnb (st,αt) + β Est+1∙.s∞^∏b
∞
+ βEst+rs∞5b	X Yk-t∆(sk)
_k=t+1	.
∞
E Yk-t
_k=t+1
∆(Sk )
where steps (a) and (b) hold because of Proposition 2. Assumption 2 ensures
△(S)= [KL HneW (•国 Hnb(Is)) — max {PKLmax EeW ∖∖π0ld) ,d}] > 0, ∀s∙
Hence, the second term in (68) is non-negative. Therefore, We have
_i ,	,
Q new (st,at)
∞
>	Qπb(st,αt) + βEst+^∞5b	X γk-t∆(sk)
_k=t+1	.
>	Qπb(st, at)
(67)
(68)
(69)
(70)
(71)
□
17
Published as a conference paper at ICLR 2020
APPENDIX B. INTUITION OF THE IMPLEMENTATION OF β ADAPTATION
Due to Theorem 1, we have
∞
Qnnew(St, at) ≥ QTn(st, at) + βEs,+js∞〜∏b	X Yk-t∆(sk)
k=t+1
'---------------{z---------------}
Improvement gap
where
δ(S)= [KL (∏Lw (IS)IInb(IS)) - max {ρKLmaχ (πilew ||nOld) ,d}] ≥ 0, ∀s∙
(72)
(73)
In deriving eqs. (72) and (73), we only used Assumption 1. When we have Assumption 2, the
improvement gap term in (72) becomes non-negative and we have
ib
Qπnew(St,at) ≥ Qπ (St, at)	(74)
as desired. However, in practice, Assumption 2 should be implemented so that the im-
provement gap term becomes non-negative and we have the desired result (74). The imple-
mentation of the condition is through adaptation of β . We adapt β to maximize the im-
Provement gap βEst+^s∞〜∏b [P∞=t+ι YkT∆(sk)] in (72) for given P and d. Let Us denote
Est+rs∞〜T [P∞=t+ι Yk-t∆(sk)] by ∆. Then, the improvement gap is given by β∆. Note that ∆
is the average (with forgetting) of∆(Sk) by Using samples from πb. The gradient of the improvement
gap with respect to β is given by
Ne (β∆)=∆.	(75)
Thus, if ∆ > 0, i.e., KL (∏new(∙∣s)∣∣πb(∙∣s)) > max {ρKL
max (πnew ||n0ld) ,d} on average,
then β should be increased to maximize the performance gain. On the other hand, if ∆ < 0,
i.e., KL (∏new(∙∣s)∣∣πb(∙∣s)) ≤ max {ρKLmaχ (∏new∣∣∏0ld), d} on average, then β should be de-
creased. Therefore, we adapt β as follows:
β =J β - 2β
Ie 一 β∕2
•£	T-∖	、	____C . ΓΛ	,1 ɪ) . . 1 r
if Dspread > max{ρDch
ange, dmin} × 1.5
if Dspread < max{ρDch
ange, dmin }/1.5
where Dspread	and Dchange
KLmax (∏niew "∏0ld) , respectively.
are implementations of KL 也力忧(∙∣s)∣∣∏b(∙∣s))
(76)
and
18
Published as a conference paper at ICLR 2020
Appendix C.	Comparison to Baselines on Delayed MuJoCo
Environments
In this section, we provide the learning curves of the state-of-the-art single-learner baselines on
delayed MuJoCo environments. Fig. 6 shows the learning curves of P3S-TD3 algorithm and the
single-learner baselines on the four delayed MuJoCo environments: Delayed Hopper-v1, Delayed
Walker2d-v1, Delayed HalfCheetah-v1, and Delayed Ant-v1. It is observed that in the delayed Ant-
v1 environment, ACKTR outperforms the P3S-TD3 algorithm. It is also observed that P3S-TD3
significantly outperforms all baselines on all other environments than the delayed Ant-v1 environ-
ment.
Total Time Steps (Ie6)
Total Time Steps (Ie6)
(a) Delayed Hopper-v1
(c) Delayed HalfCheetah-v1
Figure 6: Performance for PPO (brown), ACKTR (purple), (clipped double Q) SAC (orange), TD3
(green), and P3S-TD3 (proposed method, blue) on the four delayed MuJoCo tasks with freward =
20.
(b) Delayed Walker2d-v1
(d) Delayed Ant-v1
19
Published as a conference paper at ICLR 2020
Appendix D.	Comparison to CEM-TD3
In this section, we compare the performance of TD3 and P3S-TD3 with CEM-TD3 (Pourchot &
Sigaud (2019)), which is a state-of-the-art evolutionary algorithm. CEM-TD3 uses a population to
search a better policy as other evolutionary algorithms do. The operation of CEM-TD3 is described
as follows:
1.	It first samples N policies by drawing policy parameters from a Gaussian distribution.
2.	It randomly selects a half of the population. The selected policies and a common Q function
are updated based on minibatches drawn from a common replay buffer.
3.	Both the updated selected policies and the unselected policies are evaluated and the expe-
riences during the evaluation are stored in the common replay buffer.
4.	After evaluation of all N policies, it takes the best N/2 policies and updates the mean and
variance of the policy parameter distribution as the mean and variance of the parameters of
the best N/2 policies.
5.	Steps 1 to 4 are iterated until the time steps reach maximum.
For the performance comparision, we used the implementation of CEM-TD3 in the original pa-
per (Pourchot & Sigaud (2019))1 with the hyper-parameters provided therein. Table 1 shows the
steady state performance on MuJoCo and delayed MuJoCo environments. Fig. 7 in the next page
shows the learning curves on MuJoCo and delayed MuJoCo environments. It is seen that P3S-TD3
outperforms CEM-TD3 on all environments except delayed HalfCheetah-v1. Notice that P3S-TD3
significantly outperforms CEM-TD3 on delayed Walker2d-v1 and delayed Ant-v1.
Table 1: Steady state performance of P3S-TD3, CEM-TD3, and TD3
Environment	P3S-TD3	CEM-TD3	TD3
Hopper-v1	3705.92	3686.08	2555.85
Walker2d-v1	4953.00	4819.40	4455.51
HalfCheetah-v1	11961.44	11417.73	9695.92
Ant-v1	5339.66	4379.73	3760.50
Delayed Hopper-v1	3355.53	3117.20	1866.02
Delayed Walker2d-v1	4058.85	1925.63	2016.48
Delayed HalfCheetah-v1	5754.80	6389.40	3684.28
Delayed Ant-v1	724.50	70.44	-7.45
1The code is available at https://github.com/apourchot/CEM-RL.
20
Published as a conference paper at ICLR 2020
(a) HOPPer-VI	(b) Delayed HOPPer-VI
(d) Delayed WaIker2d-v1
(c) WaIker2d-v1
0.0	0.2	0.4	0.6	0.8	1.0
Total Time Steps (le6)
(e) HalfCheetah-v1
Total Time Steps (Ie6)
(g) Ant-v1
Figure 7: Performance ofP3S-TD3, CEM-TD3, and TD3
(f) Delayed HalfCheetah-v1
-400
-600
0.0	0.2	0.4	0.6	0.8	1.0
Total Time Steps (Ie6)
(h) Delayed Ant-V1
21
Published as a conference paper at ICLR 2020
Appendix E.	C omparis on to Method using Center Policy
In this section, we consider a variant of the proposed P3S-TD3 algorithm, named Center-TD3. This
variant uses a center policy like in Distral (Teh et al. (2017)) and Divide-and-Conquer (Ghosh et al.
(2018)). Center-TD3 has N policies and a center policy πc in addition. The value and policy
parameter update procedure is the same as the original TD3 algorithm but the loss functions are
newly defined. That is, the Q function loss is the same as the original TD3 algorithm, but the
parameters of the N policies are updated based on the following loss:
L(Oi)= E s~D -Qθi (S, πφi (S)) + 2 I∣πφi (S)- πφc (S)Il2 .	(77)
The parameter loss function of Center-TD3 is obtained by replacing the best policy with the center
policy in the parameter loss function of P3S-TD3. The center policy is updated in every M time
steps to the direction of minimizing the following loss
~ , ʌ
L(φ ) = Es~D
βN
2Xllπφi (S)-πφc (S)ll2
(78)
Center-TD3 follows the spirit of Distral (Teh et al. (2017)) and Divide-and-Conquer (Ghosh et al.
(2018)) algorithms.
We tuned and selected the hyper-parameters for Center-TD3 from the sets β ∈ {1, 10} and M ∈
{2, 20, 40, 100, 200, 500}. We then measured the performance of Center-TD3 by using the selected
hyper-parameter β = 1, M = 40. Fig. 8 in the next page and Table 2 show the learning curves
and the steady-state performance on MuJoCo and delayed MuJoCo environments, respectively. It is
seen that P3S-TD3 outperforms Center-TD3 on all environments except Delayed HalfCheetah-v1.
Table 2: Steady state performance of P3S-TD3, Center-TD3, and TD3
Environment	P3S-TD3	Center-TD3	TD3
Hopper-v1	^^3705.92	3675.28	2555.85
Walker2d-v1	4953.00	4689.34	4455.51
HalfCheetah-v1	11961.44	10620.84	9695.92
Ant-v1	5339.66	4616.82	3760.50
Delayed Hopper-v1	3355.53	3271.50	1866.02
Delayed Walker2d-v1	4058.85	2878.85	2016.48
Delayed HalfCheetah-v1	5754.80	6047.47	3684.28
Delayed Ant-v1	724.50	688.96	-7.45
22
Published as a conference paper at ICLR 2020
(a) HOPPer-VI
(b) Delayed Hopper-v1
(c) WaIker2d-v1
(d) Delayed Walker2d-v1
0.0	0.2	0.4	0.6	0.8	1.0
Total Time Steps (Ie6)
Total Time Steps (Ie6)
(e) HalfCheetah-v1
0.0	0.2	0.4	0.6	0.8	1.0
To⅛l Time Steps (Ie6)
(g) Ant-v1
(f) Delayed HalfCheetah-v1
0.0	0.2	0.4	0.6	0.8	1.0
Total Time Steps (Ie6)
(h) Delayed Ant-v1
Figure 8: Performance ofP3S-TD3, Center-TD3, and TD3
23
Published as a conference paper at ICLR 2020
Appendix F.	Res ult on Swimmer-v 1
Khadka & Tumer (2018); Pourchot & Sigaud (2019) noticed that most deep RL methods suffer
from a deceptive gradient problem on the Swimmer-v1 task, and most RL methods could not learn
effectively on the Swimmer-v1 task. Unfortunately, we observed that the proposed P3S-TD3 algo-
rithm could not solve the deceptive gradient problem in the Swimmer-v1 task either. Fig. 9 shows
the learning curves of P3S-TD3 and TD3 algorithm. In Khadka & Tumer (2018), the authors pro-
posed an effective evolutionary algorithm named ERL to solve the deceptive gradient problem on
the Swimmer-v1 task, yielding the good performance on Swimmer-v1, as shown in Fig. 9. P3S-TD3
falls short of the performance of ERL on Swimmer-v1. However, it is known that CEM-TD3 dis-
cussed in Appendix D outperforms ERL on other tasks (Pourchot & Sigaud (2019)). Furthermore,
we observed that P3S-TD3 outperforms CEM-TD3 on most environments in Appendix D.
SP-IeMaX ωCTSΦ><
350
300
250
200
150
100
50
0
—— ERL (Khadka & Turner (2018))
——P3S-TD3
——TD3
0.0	0.2	0.4	0.6	0.8	1.0
Total Time Steps (Ie6)
Figure 9: Performance on Swimmer-v1 of P3S-TD3 (blue), TD3 (orange), and the final performance
of evolutionary RL (Khadka & Tumer (2018), green dashed line).
24
Published as a conference paper at ICLR 2020
Appendix G.	The Twin Delayed Deep Deterministic Policy Gradient
(TD3) Algorithm
The TD3 algorithm is a current state-of-the-art off-policy algorithm and is a variant of the deep
deterministic policy gradient (DDPG) algorithm (Lillicrap et al. (2015)). The TD3 algorithm tries
to resolve two problems in typical actor-critic algorithms: 1) overestimation bias and 2) high vari-
ance in the approximation of the Q-function. In order to reduce the bias, the TD3 considers two
Q-functions and uses the minimum of the two Q-function values to compute the target value, while
in order to reduce the variance in the gradient, the policy is updated less frequently than the Q-
functions. Specifically, let Qθ1, Qθ2 and πφ be two current Q-functions and the current deterministic
policy, respectively, and let Qθ10 , Qθ20 and πφ0 be the target networks of Qθ1 , Qθ2 and πφ , respec-
tively. The target networks are initialized by the same networks as the current networks. At time
step t, the TD3 algorithm takes an action at with exploration noise : at = πφ (st) + , where is
zero-mean Gaussian noise with variance σ2, i.e., E 〜N(0, σ2). Then, the environment returns re-
ward rt and the state is switched to st+1. The TD3 algorithm stores the experience (st, at, rt, st+1)
at the experience replay buffer D. After storing the experience, the Q-function parameters θ1 and θ2
are updated by gradient descent of the following loss functions:
L(θj )= E(s,a,r,s0)~D [3 - Qθj (S, a))2] , j = 1, 2	(79)
where E(s,a,r,s，)~D denotes the sample expectation With an uniform random mini-batch of Size B
drawn from the replay buffer D, and the target value y is given by
y = r + Y min Qθo (s0 ,∏φo (s0) + e),	C ~ clip (N (0,σ2), -c, c).	(80)
j=1,2	j
Here, for the computation of the target value, the minimum of the two target Q-functions is used to
reduce the bias. The procedure of action taking and gradient descent for θ1 and θ2 are repeated for
d times (d = 2), and then the policy and target networks are updated. The policy parameter φ is
updated by gradient descent by minimizing the loss function for φ:
L(φ) = -Es~D [Qθι (s,∏φ(s))],	(81)
and the target network parameters θj0 and φ0 are updated as
θj — (1 — T )θj + τθj	φ0 — (1 — T )φ0 + τφ.	(82)
The networks are trained until the number of time steps reaches a predefined maximum.
25
Published as a conference paper at ICLR 2020
Appendix H.	Pseudocode of the P3S-TD3 Algorithm
Algorithm 1 The Population-Guided Parallel Policy Search TD3(P3S-TD3) Algorithm
Require: N: number of learners, Tinitial : initial exploration time steps, T : maximum time steps,
M : the best-policy update period, B: size of mini-batch, d: update interval for policy and target
networks.
1:	Initialize φ1 =…=φN = φb, θj =…=θjN, j = 1,2, randomly.
2:	Initialize β = 1, t = 0
3:	while t < T do
4:	t J t + 1 (one time step)
5:	for i = 1,2,…，N in parallel do
6:	if t < Tinitial then
7:	Take a uniform random action ait to environment copy Ei
8:	else
9:	Take an action at = πi (Si) + e, E 〜N(0, σ2) to environment copy Ei
10:	end if
11:	Store experience (sit, ait, rti, sit+1) to the shared common experience replay D
12:	end for
13:	if t < Tinitial then
14:	continue (i.e., go to the beginning of the while loop)
15:	end if
16:	for i = 1,2,…，N in parallel do
17:	Sample a mini-batch B = {(stl, atl, rtl, stl+1)}l=1,...,B from D
18:	Update θj, j = 1, 2, by gradient descent for minimizing L(θj) in (83) with B
19:	if t ≡ 0(mod d) then
20:	Update φi by gradient descent for minimizing L(φi) in (84) with B
21:	Update the target networks: (θji )0 J (1 - τ)(θji )0 + τθji, (φi)0 J (1 - τ)(φi)0 + τφi
22:	end if
23:	end for
24:	ift ≡ 0(mod M) then
25:	Select the best learner b
26:	Adapt β
27:	end if
28:	end while
In P3S-TD3, the i-th learner has its own parameters θ1i, θ2i , and φi for its two Q-functions and
policy. Furthermore, it has (θ1i )0, (θ2i )0, and (φi)0 which are the parameters of the corresponding
target networks. For the distance measure between two policies, we use the mean square difference,
given by D(π(s), ∏(s)) = 2 ∣∣π(s) 一 ∏(s)k2. For the i-th learner, as in TD3, the parameters θj,
j = 1, 2 are updated every time step by minimizing
L(θj) = E(s,a,r,s0)〜D h(y - Qθi(s,a))2i	(83)
where y = r + Y min7-=ι,2 Q©)o (s0, ∏(φi)o (s0) + e), C 〜clip (N (0, σ2), -c, c). The parameter φi
is updated every d time steps by minimizing the following augmented loss function:
L(Oi)= E S 〜D -Qθiι (S,πφi (S)) + 1{i=b} 2 ∣∣πφi (S)- πφb (S)Il2 .	(84)
For the first Tinitial time steps for initial exploration we use a random policy and do not update
all policies over the initial exploration period. With these loss functions, the reference policy, and
the initial exploration policy, all procedure is the same as the general P3S procedure described in
Section 3. The pseudocode of the P3S-TD3 algorithm is shown above.
26
Published as a conference paper at ICLR 2020
Appendix I. Hyper-parameters
TD3 The networks for two Q-functions and the policy have 2 hidden layers. The first and second
layers have sizes 400 and 300, respectively. The non-linearity function of the hidden layers is ReLU,
and the activation functions of the last layers of the Q-functions and the policy are linear and hyper-
bolic tangent, respectively. We used the Adam optimizer with learning rate 10-3, discount factor
γ = 0.99, target smoothing factor τ = 5 × 10-3, the period d = 2 for updating the policy. The
experience replay buffer size is 106, and the mini-batch size B is 100. The standard deviation for
exploration noise σ and target noise σ are 0.1 and 0.2, respectively, and the noise clipping factor C
is 0.5.
P3S-TD3 In addition to the hyper-parameters for TD3, we used N = 4 learners, the period M =
250 of updating the best policy and β, the number of recent episodes Er = 10 for determining
the best learner b. The parameter dmin was chosen among {0.02, 0.05} for each environment, and
the chosen parameter was 0.02 (Walker2d-v1, Ant-v1, Delayed Hopper-v1, Delayed Walker2d-v1,
Delayed HalfCheetah-v1), and 0.05 (Hopper-v1, HalfCheetah-v1, Delayed Ant-v1). The parameter
ρ for the exploration range was 2 for all environments. The time steps for initial exploration Tinitial
was set as 250 for Hopper-v1 and Walker2d-v1 and as 2500 for HalfCheetah-v1 and Ant-v1.
Re-TD3 The period M0 was chosen among {2000, 5000, 10000} (MuJoCo environments) and
{10000, 20000, 50000} (Delayed MuJoCo environments) by tuning for each environment. The cho-
sen period M0 was 2000 (Ant-v1), 5000 (Hopper-v1, Walker2d-v1, HalfCheetah-v1), 10000 (De-
layed HalfCheetah-v1, Delayed Ant-v1), and 20000 (Delayed Hopper-v1, Delayed Walker2d-v1).
27