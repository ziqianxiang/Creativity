Published as a conference paper at ICLR 2020
Multi-agent Reinforcement Learning
for Networked System Control
Tianshu Chu
Uhana Inc.
Palo Alto, CA 94304, USA
cts198859@hotmail.com
Sandeep Chinchali & Sachin Katti
Stanford University
Stanford, CA 94305, USA
{csandeep,skatti}@stanford.edu
Ab stract
This paper considers multi-agent reinforcement learning (MARL) in networked
system control. Specifically, each agent learns a decentralized control policy based
on local observations and messages from connected neighbors. We formulate
such a networked MARL (NMARL) problem as a spatiotemporal Markov decision
process and introduce a spatial discount factor to stabilize the training of each local
agent. Further, we propose a new differentiable communication protocol, called
NeurComm, to reduce information loss and non-stationarity in NMARL. Based
on experiments in realistic NMARL scenarios of adaptive traffic signal control
and cooperative adaptive cruise control, an appropriate spatial discount factor
effectively enhances the learning curves of non-communicative MARL algorithms,
while NeurComm outperforms existing communication protocols in both learning
efficiency and control performance.
1	Introduction
Reinforcement learning (RL), formulated as a Markov decision process (MDP), is a promising
data-driven approach for learning adaptive control policies (Sutton & Barto, 1998). Recent advances
in deep neural networks (DNNs) further enhance its learning capacity on complex tasks. Successful
algorithms include deep Q-network (DQN) (Mnih et al., 2015), deep deterministic policy gradient
(DDPG) (Lillicrap et al., 2015), and advantage actor critic (A2C) (Mnih et al., 2016). However, RL is
not scalable in many real-world control problems. This scalability issue is addressed in multi-agent
RL (MARL), where each agent learns its individual policy from only local observations. However,
MARL introduces new challenges in model training and execution, due to non-stationarity and partial
observability in a decentralized MDP from the viewpoint of each agent. To address these challenges,
various learning methods and communication protocols are proposed to stabilize training and improve
observability.
This paper considers networked MARL (NMARL) in the context of networked system control (NSC),
where agents are connected via a communication network for a cooperative control objective. Each
agent performs decentralized control based on its local observations and messages from connected
neighbors. NSC is extensively studied and widely applied. Examples include connected vehicle
control (Jin & Orosz, 2014), traffic signal control (Chu et al., 2019), distributed sensing (Xu et al.,
2018), and networked storage operation (Qin et al., 2016). We expect an increasing trend of NMARL
based controllers in the near future, after the development of advanced communication technologies
such as 5G and Internet-of-Things.
Recent works studied decentralized NMARL under assumptions of global observations and local
rewards (Zhang et al., 2018; Qu et al., 2019), which are reasonable in multi-agent gaming but not
suitable in NSC. First, the control infrastructures are distributed in a wide region, so collecting global
observations in execution increases communication delay and failure rate, and hurts the robustness.
Second, online learning is not common due to safety and efficiency concerns. Rather, each model is
trained offline and tested extensively before field deployment. In online execution, the model only
runs forward propagation, and its performance is constantly monitored for triggering re-training. To
reflect these practical constraints in NSC, we assume 1) each agent is connected to a limited number
1
Published as a conference paper at ICLR 2020
of neighbors and communication is restricted to its neighborhood, and 2) training is offline and global
information is available in rollout training minibatches, despite a decentralized training process.
The contributions of this paper are three-fold. First, we formulate NMARL under the aforementioned
NSC assumptions as a decentralized spatiotemporal MDP, and introduce a spatial discount factor to
stabilize training, especially for non-communicative algorithms. Second, we propose a new neural
communication protocol, called NeurComm, to adaptively share information on both system states
and agent behaviors. Third, we design and simulate realistic NMARL environments to evaluate and
compare our approaches against recent MARL baselines. 1
2	Related Work
MARL works can be classified into four groups based on their communication methods. The first
group is non-communicative and focuses on stabilizing training with advanced value estimation
methods. In MADDPG, each action-value is estimated by a centralized critic based on global
observations and actions (or inferred actions) (Lowe et al., 2017). COMA extends the same idea to
A2C and estimates each advantage using a centralized critic and a counterfactual baseline (Foerster
et al., 2018). In Dec-HDRQN (Omidshafiei et al., 2017) and PS-TRPO (Gupta et al., 2017), the
centralized critic takes local observations, but the parameters are shared globally. In the NMARL
work of Zhang et al. (2018), the critic is fully decentralized but each takes global observations and
performs consensus updates. In this paper, we empirically confirm that a spatial discount factor helps
stabilize the training of non-communicative algorithms under neighborhood observation.
The second group considers heuristic communication protocols or direct information sharing. Foerster
et al. (2017) shows performance gains with directly-shared low dimensional policy fingerprints from
other agents. Similarly, mean field MARL takes the average of neighbor policies for informed
action-value estimation (Yang et al., 2018). The major disadvantage of this group is that, unlike
NeurComm, the communication is not explicitly designed for performance optimization, which may
cause inefficient and redundant communications in execution.
The third group proposes learnable communication protocols. In DIAL, the message is generated
together with action-value estimation by each DQN agent, then it is encoded and summed with other
input signals at the receiver side (Foerster et al., 2016). CommNet is a more general communication
protocol, but it calculates the mean of all messages instead of encoding them (Sukhbaatar et al., 2016).
Both works, especially CommNet, incur an information loss due to aggregation on input signals.
Another collection of works focuses on communications in strategy games. In BiCNet (Peng et al.,
2017), a bi-directional RNN is used to enable flat communication among agents, while in Master-
Slave (Kong et al., 2017), two-way message passing is utilized in a hierarchical RNN architecture of
master and slave agents. In contrast to existing protocols, NeurComm 1) encodes and concatenates
signals, instead of aggregating them, to minimize information loss, and 2) includes policy fingerprints
in communication to reduce non-stationarity.
The fourth group focuses on communication attentions to selectively send messages. ATOC (Jiang &
Lu, 2018) learns a soft attention which allocates a communication probability to each other agent,
while IC3Net (Singh et al., 2018) learns a hard binary attention which decides communicating or
not. These works are especially useful when each agent has to prioritize the communication targets.
NMARL is less likely the case since the communication range is restricted to small neighborhoods.
3	Spatiotemporal RL
This section formulates the NMARL problem as a decentralized spatiotemporal MDP, and introduces
the spatial discount factor to reduce its learning difficulty. To simplify the notation, we assume the
true system state is observable, and use “state” and “observation” interchangeably. This does not
affect the validity of proposed methods in practice. To save space, all proofs are deferred to A.
1Code link: https://github.com/cts198859/deeprl_network.
2
Published as a conference paper at ICLR 2020
3.1	Networked MARL
The networked system is represented by a graph G(V, E) where i ∈ V is each agent and ij ∈ E is
each communication link. The corresponding MDP is characterized as (G, {Si, Ai}i∈V , p, r) where
Si and Ai are the local state space and action space of agent i. Let S := ×i∈V Si and A := ×i∈V Ai
be the global state space and action space, MDP transitions follow a stationary probability distribution
p : S × A × S → [0, 1], and global step rewards be denoted by r : S × A → R. In a multi-agent
MDP, each agent i follows a decentralized policy πi : Si × Ai → [0, 1] to chose its own action
ai,t 〜∏i(∙∣Si,t) at time t. The MDP objective is to maximize E[R∏], where Rn = PT=t YτTrT is
the long-term global return with discount factor γ. Here the expectation is taken over the global policy
π : S×A→ [0,1],the initial distribution St 〜ρ, and the transition ST +1 〜p(∙∣Sτ ,aτ), regarding the
step reward rτ = r(sτ, aτ), ∀τ < T, and the terminal reward rT = rT (sT ) 2. The same system can
be formulated as a centralized MDP. Defining Vπ(S) = E[Rtπ |St = S] as the state-value function and
Qπ(s,a) = E[R∏|st = s, at = a] as the action-value function, we have E[R∏] = Ps∈s P(S)Vπ(s),
Vπ(S) = Pa∈A π(a∣s)Qn(s, a), and the advantage function Aπ(s, a) = Qn(s, a) — Vπ(s).
MARL provides a scalable solution for controlling networked systems, but it introduces partial
observability and non-stationarity in decentralized MDP of each agent, leading to inefficient and
unstable learning performance. To see this, note Si,t ∈ Si ⊆ S does not provide sufficient information
for ∏i. Even assuming Si,t = st, the transition Pi(si,t+ι∣Si,t,ai,t) = Pa-i,t∈A-i ∏-i(a-i,t∣st) ∙
p(st+ι∣st, ai,t, a-i,t) is non-stationary if the behavior policies of other agents π- := {∏7- }j∈v∖{i}
are evolving over time. In this paper, we enforce practical constraints and only allow local observations
and neighborhood communications, which makes MARL even more challenging.
Definition 3.1 (Networked Multi-agent MDP with Neighborhood Communication). In a networked
cooperative multi-agent MDP (G, {Si, Ai}i∈V, {Mij}ij∈E,p, {ri}i∈V) with the message space M,
the global reward is defined as r =由 Pi∈v %. All local rewards are shared globally, whereas the
communication is limited to neighborhoods, that is, each agent i observes si,t := Si,t ∪ mNii,t. Here
Ni := {j ∈ V|ji ∈ E}, mNii,t := {mji,t}j∈Ni, and each message mji,t ∈ Mji is derived from all
the available information at that neighbor.
3.2	Spatiotemporal RL
Definition 3.2 (Spatiotemporal MDP). We assume local transitions are independent of other agents
given the neighboring agents, that is,
pi(Si,t+1|SVi,t, ai,t) =	∑ π πj(aj,t同,t) ∙ P(Si,t+l∖sVi,t,ai,t,aNi,t),	⑴
aNi,t ∈ANi j∈Ni
where Vi := Ni ∪ {i} is the closed neighborhood, and p is abused to denote any stationary transition.
Then from the viewpoint of each agent i, Definition 3.1 is equivalent to a decentralized spatiotemporal
MDP, characterized as (Si, Ai, {Mji}j∈Ni,pi, {ri}i∈V), by optimizing the discounted return
Rin,t = XT γτ-t Xαdijrj,t ,	(2)
τ=t	j∈V
where 0 ≤ α ≤ 1 is the spatial discount factor, and dij is distance between agents i and j .
The major assumption in Definition 3.2 is that the Markovian property holds both temporally
and spatially, so that the next local state depends on the neighborhood states and policies only.
This assumption is valid in most networked control systems such as traffic and wireless networks,
as well as the power grid, where the impact of each agent is spread over the entire system via
controlled flows, or chained local transitions. Note in NSC, each agent is connected to a limited
number of neighbors (the degree of G is low). So spatiotemporal MDP is decentralized during
model execution, and it naturally extends properties of MDP. To reduce the learning difficulty of
spatiotemporal MDP, a spatiotemporally discounted return is introduced in Eq. (2) to scale down
reward signals further away (which are more difficult to fit using local information). When α → 0,
2In infinite MDP, rT (s) = E Pt∞=T γt-Trt sT = s
3
Published as a conference paper at ICLR 2020
each agent performs local greedy control; when α → 1, each agent performs global coordination
and Rnt = Rn,∀i ∈ V. Further, we have Qn(s,a) = Qn(s,avj = E[Rπt∣st = s,aVi,t = ay」,
and Vin(s,a-i) = Vn(s,aN) = Paa∈a. ∏i(a∕3i)Q∏(s,avj, since the immediate local reward of
each agent is only affected by controls within its closed neighborhood.
Now we assume each agent is A2C, with parametric models ∏θi (Si) and Vωi (si, aχ,) for fitting the
optimal policy ∏i and value function Vni. Note if Si is able to provide global information through
cascaded neighborhood communications, both πθ, and Vω, are able to fit return Rin,t. Also, global
and future information, such as Rin,τ and aN,,τ, are always available from each rollout minibatch in
offline training. In contrast, only local information sSi,t is allowed in online execution of policy πθ,.
Proposition 3.1 (Spatiotemporal RL with A2C). Let {πθ, }i∈V and {Vω, }i∈V be the decentralized
actor-critics, and {(si,τ, mN,i,τ, ai,τ, ri,τ)}i∈V,τ ∈B be the on-policy minibatch from spatiotemporal
MDPs under stationary policies {πθ,}i∈V. Then each actor and critic are updated by losses
L(Bi)= IBI X ( -log πθi (ai,"si,τ)An,τ + β X πθi (a∕si,τ )log πθi (ai∖si,τ ) j ,
IBI τ∈B	a,∈A,
L(ωi) = ∣B∣ X (RnT- Vω, (si,τ, aNi,τ)),
IBI τ∈B
(3)
(4)
0
where AnT = RnT - vi,τ is the estimated advantage, RnT = ETB=T Y -T (∑j∈v αdij j，) +
γ τB -τ vi,τB is the sampled action-value, vi,τ = Vω- (sSi,τ, aN,,τ) is the estimated state-value, and β
ω,
is the coefficient of the entropy loss.
4	Spatiotemporal RL with Neural Communication
For efficient and adaptive information sharing, we propose a new communication protocol called
NeurComm. To simplify the notation, we assume all messages sent from agent i are identical, i.e.,
mij = mi , ∀j ∈ Ni . Then
hi,t = gν,(hi,t-1,eλ,s(sV,,t),eλ,p(πN,,t-1),eλ,h(hN,,t-1)),	(5)
where hi,t is the hidden state (or the belief) of each agent and eλ, and gν, are differentiable message
encoding and extracting functions 3. To avoid dilution of state and policy information (the former
is for improving observability while the later is for reducing non-stationarity), state and policy
are explicitly included in the message besides agent belief, i.e., mi,t = si,t ∪ πi,t-1 ∪ hi,t-1, or
sSi,t := sV,,t∪πN,,t-1∪hN,,t-1 as in Eq. (5). Note the communication phase is prior-decision, so only
hi,t-1 and πi,t-1 are available. This protocol can be easily extended for multi-pass communication:
hi(,kt) = gν(k)(hi(,kt-1),eλ,s(sV,,t),eλ,p(πN,,t-1),eλ,h(h(Nk,-,t1))), where hi(,0t) = hi,t-1, and k denotes
each of the communication passes. The communication attentions can be integrated either at the
sender as μi,t(m%,t), or at the receiver as μi,t(mN,,t). Replacing the input (S%,t) of Eq. (3)(4) with the
belief (hi,t), the actor and critic become ∏θ,(∙∣hi,t) and Vω, (hi,t, aN,,t), and the frozen estimations
are πi,t and vi,t, respectively.
Proposition 4.1 (Neighborhood Neural Communication). In spatiotemporal RL with neighborhood
NeurComm, each agent utilizes the delayed global information to learn its belief, and it learns the
message to optimize the control performance of all other agents.
NeurComm enabled MARL can be represented using a single meta-DNN since all agents are
connected by differentiable communication links, and sSi are the intermediate outputs after com-
munication layers. Fig. 1a illustrates the forward propagations inside each individual agent and
Fig. 1b shows the broader multi-step spatiotemporal propagations. Note the gradient propagation
of this meta-DNN is decentralized based on each local loss signal. As time advances, the involved
parameters in each propagation expand spatially in the meta-DNN, due to the cascaded neigh-
borhood communication. To see this mathematically, ∏θ,,t(∙∣hi,t) = ∏q. t(∙∖sy,,t, ∏N,,t-ι), with
θi,t = {λi,νi,θi}; while πθi,t+ι (∙∖hi,t+1) = πθi^t+ι ('审寸户+〜尸^储{sNj ,t"Nj ,t—1} j∈NiT With
3Additional cell state needs to be maintained if LSTM is used.
4
Published as a conference paper at ICLR 2020
θi,t+1 = {λj , νj }j∈Ni ∪ {λi , νi , θi}. In other words, {λi , νi} will be updated for improving actors
πθj , ∀j ∈ V, as soon as they are included in θj ; meanwhile, ri will be included in Rjπ . In contrast,
the policy is fully decentralized in execution, as gνi depends on Si only.
(a) Intra-step propagations.
Figure 1: Forward propagations of NeurComm enabled MARL, illustrated in a queueing system. (a)
Single-step forward propagations inside agent i. Different colored boxes and arrows show different
outputs and functions, respectively. Solid and dashed arrows indicate actor and critic propagations,
respectively. (b) Multi-step forward propagations for updating the belief of agent i.
(b) Inter-step propagations.
NeurComm is general enough and has connections to other communication protocols. CommNet
performs a more lossy aggregation since the received messages are averaged before encoding, and
all encoded inputs are summed up (Sukhbaatar et al., 2016). In DIAL, each DQN agent encodes
the received messages instead of averaging them, but still it sums all encoded inputs (Foerster et al.,
2016). Also, both CommNet and DIAL do not have policy fingerprints included in messages.
5	Numerical Experiments
5.1	Environment Setup
There are several benchmark MARL environments such as cooperative navigation and predator-prey,
but few of them represent NSC. Here we design two NSC environments: adaptive traffic signal control
(ATSC) and cooperative adaptive cruise control (CACC). Both ATSC and CACC are extensively
studied in intelligent transportation systems, and they hold assumptions of a spatiotemporal MDP.
5.1.1	Adaptive Traffic Signal Control
The objective of ATSC is to adaptively adjust signal phases to minimize traffic congestion based on
real-time road-traffic measurements. Here we implement two ATSC scenarios: a 5 × 5 synthetic traffic
grid and a real-world 28-intersection traffic network from Monaco city, using standard microscopic
traffic simulator SUMO (Krajzewicz et al., 2012).
General settings. For both scenarios, each episode simulates the peak-hour traffic, and a 5s control
interval is applied to prevent traffic light from too frequent switches, based on RL control latency and
driver response delay. Thus, one MDP step corresponds to 5s simulation and the horizon is 720 steps.
Further, a 2s yellow time is inserted before switching to red light for safety purposes. In ATSC, the
real-time traffic flow, that is, the total number of approaching vehicles along each incoming lane, is
measured by near-intersection induction-loop detectors (ILDs) (shown as the blue areas of example
intersections in Fig. 2). The cost of each agent is the sum of queue lengths along all incoming lanes.
Scenario settings. Fig. 2a illustrates the traffic grid formed by two-lane arterial streets with speed
limit 20m/s and one-lane avenues with speed limit 11m/s. We simulate the peak-hour traffic dynamics
through four collections of time-variant traffic flows, with both loading and recovering phases. At
beginning, three major flows F1 are generated with origin-destination (O-D) pairs x10-x4, x11-x5,
and x12-x6, meanwhile three minor flows f1 are generated with O-D pairs x1-x7, x2-x8, and x3-x9.
5
Published as a conference paper at ICLR 2020
After 15 minutes, F1 and f1 start to decay, while their opposite flows F2 and f2 start to dominate,
as shown in Fig. 2b. Note the flows define the high-level demand only, the particular route of each
vehicle is randomly generated. The grid is homogeneous and all agents have the same action space,
which is a set of five pre-defined signal phases. Fig. 2c illustrates the Monaco traffic network, with
controlled intersections in blue. NMARL in this scenario is more challenging since the network
is heterogeneous with a variety of observation and action spaces. Four traffic flow collections are
generated to simulate the peak-hour traffic, and each flow is a multiple of a “unit” flow of 325veh/hr,
with randomly sampled O-D pairs inside rectangle areas in Fig. 2c. F1 and F2 are simulated during
the first 40min, as [1, 2, 4, 4, 4, 4, 2,1] unit flows with 5min intervals; F3 and F4 are generated in the
same way, but with a delay of 15min. See code for more details.
(c) Monaco traffic network.
(a) Synthetic traffic grid. (b) Traffic flows within the grid.
Figure 2: ATSC scenarios for NMARL. (a) Synthetic traffic grid, with major and minor traffic flows
shown in solid and dotted arrows. (b) Simulated time-variant traffic flows within the traffic grid. (c)
Monaco traffic network, with traffic flow collections shown in colored arrows.
5.1.2	Cooperative Adaptive Cruise Control
The objective of CACC is to adaptively coordinate a platoon of vehicles to minimize the car-following
headway and speed perturbations based on real-time vehicle-to-vehicle communication. Here we
implement two CACC scenarios: “Catch-up” and “Slow-down”, with physical vehicle dynamics.
General settings. For both CACC tasks, we simulate a string of 8 vehicles for 60s, with a 0.1s
control interval. Each vehicle observes and shares its headway h, velocity v, and acceleration a to
neighbors within two steps. The safety constraints are: h ≥ 1m, v ≤ 30m/s, |a| ≤ 2.5m/s2. Safe
RL is relevant here, but itself is a big topic and out of the scope of this paper. So we adopt a simple
heuristic optimal velocity model (OVM) (Bando et al., 1995) to perform longitudinal vehicle control
under above constraints, whose behavior is affected by hyper-parameters: headway gain α°, relative
velocity gain β°, stop headway hst = 5m and full-speed headway hgo = 35m. Usually (α°, β°)
represent the human driver behavior, here we train NMARL to recommend appropriate (α°, β°) for
each OVM controller, selected from four levels {(0, 0), (0.5, 0), (0, 0.5), (0.5, 0.5)}. Assuming the
target headway and velocity profile are h* = 20m and V, respectively, the cost of each agent is
(hi,t - h* )2 + (vi,t - v* )2 + 0.1u2,t. Whenever a collision happens (hi,t < 1m), a large penalty of
1000 is assigned to each agent and the state becomes absorbing. An additional cost 5(2hst - hi,t)2+ is
provided in training for potential collisions.
Scenario settings. Since exploring a collision-free CACC strategy itself is challenging for on-
policy RL, we consider simple scenarios. In Catch-up scenario, vi,0 = vt* =15m/s and hi,0 = h*,
∀i = 1, whereas h1,0 = a ∙ h*, with a ∈ U[3, 4]. In Slow-down scenario, vi,0 = v0 = 615m/s,
b ∈ U [1.5, 2.5], and hi,0 = h*, ∀i, whereas vt* linearly decreases to 15m/s during the first 30s and
then stays at constant.
5.2	Algorithm Setup
For fair comparison, all MARL approaches are applied to A2C agents with learning methods in
Eq. (3)(4), and only neighborhood observation and communication are allowed. IA2C performs
independent learning, which is an A2C implementation of MADDPG (Lowe et al., 2017) as the critic
takes neighboring actions (see Eq. (4)). ConseNet (Zhang et al., 2018) has the additional consensus
6
Published as a conference paper at ICLR 2020
update to overwrite parameters of each critic as the mean of those of all critics inside the closed
neighborhood. FPrint (Foerster et al., 2017) includes neighbor policies. DIAL (Foerster et al., 2016)
and CommNet (Sukhbaatar et al., 2016) are described in Section 4. IA2C, ConseNet, and FPrint are
non-communicative policies since they utilize only neighborhood information. In contrast, DIAL,
CommNet, and NeurComm are communicative policies. Note communicative policies require more
messages to be transferred and so higher communication bandwidth. In particular, the local message
sizes are O(∣s∕ + ∣∏i∣ + |hi|) for DIAL and NeurComm, O(∣s∕ + |hi |) for CommNet, O(∣s∕ + ∣∏i∣)
for FPrint, and O(|si|) for IA2C and ConseNet. The implementation details are in C.1.
All algorithms use the same DNN hidden layers: one fully-connected layer for message encoding eλ,
and one LSTM layer for message extracting gν . All hidden layers have 64 units. The encoding layer
implicitly learns normalization across different input signal types. We train each model over 1M
steps, with γ = 0.99, actor learning rate 5 × 10-4, and critic learning rate 2.5 × 10-4. Also, each
training episode has a different seed for generalization purposes. In ATSC, β = 0.01, |B| = 120,
while in CACC, β = 0.05, |B| = 60, to encourage the exploration of collision-free policies. Each
training takes about 30 hours on a 32GB memory, Intel Xeon CPU machine.
5.3	Ablation Study
We perform ablation study in proposed scenarios, which are sorted as ATSC Monaco > ATSC Grid
> CACC Slow-down > CACC Catch-up by task difficulty. ATSC is more challenging than CACC
due to larger scale (>=25 vs 8), more complex dynamics (stochastic traffic flow vs deterministic
vehicle dynamics), and longer control interval (5s vs 0.1s). ATSC Monaco > ATSC Grid due to
more heterogenous network, while CACC Slow-down > CACC Catch-up due to more frequently
changing leading vehicle profile. To visualize the learning performance, we plot the learning curve,
that is, average episode return (R= T PT- Pi∈v ri,t) VS training step. For better visualization,
all learning curves are smoothened using moving average with a window size of 100 episodes.
First, we investigate the impact of spatial discount factor, by comparing the learning curves among
α ∈ {0.8,0.9, l} for IA2C and CommNet. Fig. 3 reveals a few interesting facts. First, αCCommNet is
always higher than α^c. Indeed, αCommNet = 1 in almost all scenarios (except for ATSC Monaco).
This is because communicative policies perform delayed global information sharing, whereas non-
communicative policies utilize neighborhood information only, causing difficulty to fit the global
return. Second, learning performance becomes much more sensitive to α when the task is more
difficult. Specifically, all α values lead to similar learning curves in CACC Catch-up, whereas
appropriate α values help IA2C converge to much better policies more steadily in other scenarios.
Third, α* is high enough: a^C = 0.9 except for CACC Slow-down where a良2c = 0.8. This is
because the discounted problem must be similar enough to the original problem in execution.
Next, we investigate the impact of NeurComm under α = 1. We start with a baseline which is
similar to existing differentiable protocols, i.e., hi,t = LSTM(hi,t-1, relu(sVi,t ) + relu(mNi,t )).
We then evaluate two intermediate protocols “Concat Only” and “FPrint Only”, in which encoded
inputs are concatenated and neighbor policies are included, respectively. Finally we evaluate their
combination NeurComm. As shown in Fig. 3, all protocols have similar learning curves in easy
CACC Catch-up scenario. Otherwise, both “Concat” and “FPrint” are able to enhance the baseline
learning curves in certain scenarios and their affects are additive in NeurComm.
5.4	Training Results
Fig. 4 compares the learning curves of all MARL algorithms, after tuned a* ∈ {0.6,0.8,0.9,0.95,1}.
As expected, α* for non-communicative policies are lower than those for communicative policies.
Table 1: Best spatial discount factors a* across NMARL scenarios.
Scenario Name	NeurComm	CommNet	DIAL	IA2C	FPrint	ConseNet
ATSC Grid	10	10	^^T0-	0.9	0.95	0.9
ATSC Monaco	1.0	0.9	0.9	0.9	0.9	0.9
CACC Catch-up	1.0	1.0	1.0	1.0	1.0	1.0
CACC Slow-down	1.0	1.0	1.0	0.8	0.9	0.8
7
Published as a conference paper at ICLR 2020
(a) ATSC Grid.	(b) ATSC Monaco. (c) CACC Catch-up. (d) CACC Slow-down.
Figure 3: Sensitivity and ablation study of spatial discount factor (top) and NeurComm (bottom). The
best learning curves are in bold.
(a) ATSC Grid.	(b) ATSC Monaco. (c) CACC Catch-up. (d) CACC Slow-down.
Figure 4: Training performance comparison after tuned spatial discount factors.
Tab. 1 summarizes α* of controllers across different NMARL scenarios. For challenging scenarios like
ATSC Monaco, lower α is preferred by almost all policies (except NeurComm). This demonstrates
that α is an effective way to enhance MARL performance in general, especially for challenging
tasks like ATSC Monaco. From another view point, α serves as an informative indicator on problem
difficulty and algorithm coordination level. Based on Fig. 4, NeurComm is at least competitive in
CACC scenarios, and it clearly outperforms other policies on both sample efficiency and learning
stability in more challenging ATSC scenarios. Note in CACC a big penalty is assigned whenever a
collision happens, so the standard deviation of episode returns is high.
5.5	Execution Results
We freeze and evaluate trained MARL policies in another 50 episodes, and summarize the results in
Tab. 2. In CACC scenarios, α enhanced FPrint policy achieves the best execution performance. Note
NeurComm still outperforms other communicative algorithms, so this result implies that delayed
information sharing may not be helpful in easy but real-time and safety-critical CACC tasks. In
contrast, NeurComm achieves the best execution performance for ATSC tasks. We also evaluate
the execution performance of ATSC and CACC using domain-specific metrics in Tab. 3 and Tab. 4,
respectively. The results are consistent with the reward-defined ones in Tab. 2.
Further, we investigate the performance of top policies in ATSC scenarios. For each ATSC scenario,
we select the top two non-communicative and communicative policies and visualize their impact on
network traffic by plotting the time series of network averaged queue length and intersection delay in
Fig. 5. Note the line and shade show the mean and standard deviation of each metric across execution
runs, respectively. Based on Fig. 5a, NeurComm achieves the most sustainable traffic control in
ATSC Grid, so that the congested grid starts recovering immediately after the loading phase ends
at 3000s. During the same unloading phase, CommNet prevents the queues from further increasing
while non-communicative policies are failed to do so. Also, FPrint is less robust than IA2C as it
8
Published as a conference paper at ICLR 2020
Table 2: Execution performance comparison over trained MARL policies. Best values are in bold.
Scenario Name	NeurComm	CommNet	DIAL	IA2C	FPrint	ConseNet
ATSC Grid	--136.1-	--1651-	-214.4	-160.2	-155.9	-187.5
ATSC Monaco	-226.3	-263.0	-339.4	-369.7	-359.4	-528.9
CACC Catch-up	-94.6	-95.6	-246.4	-261.7	-57.8	-419.7
CACC Slow-down	-934.7	-950.8	-1112	-2209	-697.9	-1038
(a) Average queue length (b) Average queue length (c) Average intersection (d) Average intersection
in ATSC Grid.	in ATSC Monaco.	delay in ATSC Grid.	delay in ATSC Monaco.
Figure 5: Execution performance comparison among top policies in ATSC scenarios, measured as
average queue length and average intersection delay over time.
introduces a sudden congestion jump at 1000s. Similarly, NeurComm achieves the lowest saturation
rate in ATSC Monaco (Fig. 5b).
Intersection delay is another key metric in ATSC. Based on Fig. 5c, communicative policies are able
to reduce intersection delay as well in ATSC Grid, though it is not explicitly included in the objective
and so is not optimized by non-communicative policies. In contrast, communicative policies have fast
increase on intersection delay in ATSC Monaco. This implies that communicative algorithms are able
to capture the spatiotemporal traffic pattern in homogeneous networks whereas they still have the risk
of overfitting on queue reduction in realistic and heterogenous networks. For example, they block the
short source edges on purpose to reduce on-road vehicles by paying a small cost of queue length.
Finally, we investigate the robustness (string stability) of top policies in CACC scenarios. In particular,
we plot the time series of headway and velocity for the first and the last vehicles in the platoon. The
profile of the first vehicle indicates how adaptively the controller pursues h* and v*, while that of
the last vehicle indicates how stable the controlled platoon is. Based on Tab. 1 and Tab. 4, the top
communicative and non-communicative controllers are NeurComm and FPrint.
Fig. 6 shows the corresponding headway and velocity profiles for the selected controllers. Interest-
ingly, MARL controllers are able to achieve steady state v* and h* for the first vehicle of platoon,
whereas they still have difficulty to eliminate the perturbation through the platoon. This may be
because of the heuristic low-level controller as well as the delayed information sharing.
(a) Headway profiles
in CACC Catch-up
(b) Velocity profiles
in CACC Catch-up
(c) Headway profiles
in CACC Slow-down
(d) Velocity profiles
in CACC Slow-down
Figure 6: Headway and velocity profiles of the first and last vehicles of the platoon, controlled by top
communicative and non-communicative policies in execution.
9
Published as a conference paper at ICLR 2020
6	Conclusions
We have formulated the spatiotemporal MDP for decentralized NSC under neighborhood commu-
nication. Further, we have introduced the spatial discount factor to enhance non-communicative
MARL algorithms, and proposed a neural communication protocol NeurComm to design adaptive
and efficient communicative MARL algorithms. We hope this paper provides a rethink on developing
scalable and robust MARL controllers for NSC, by following practical engineering assumptions and
combining appropriate learning and communication methods rather than reusing existing MARL
algorithms. One future direction is improving the recurrent units to naturally control spatiotemporal
information flows within the meta-DNN in a decentralized way.
Acknowledgments
We would like to thank Marco Pavone and Alexander Anemogiannis for valuable discussions and
insightful comments.
References
Masako Bando, Katsuya Hasebe, Akihiro Nakayama, Akihiro Shibata, and Yuki Sugiyama. Dy-
namical model of traffic congestion and numerical simulation. Physical review E, 51(2):1035,
1995.
Tianshu Chu, Jie Wang, Lara Codeca, and Zhaojian Li. Multi-agent deep reinforcement learning for
large-scale traffic signal control. IEEE Transactions on Intelligent Transportation Systems, 2019.
Jakob Foerster, Ioannis Alexandros Assael, Nando de Freitas, and Shimon Whiteson. Learning to
communicate with deep multi-agent reinforcement learning. In Advances in Neural Information
Processing Systems, pp. 2137-2145, 2016.
Jakob Foerster, Nantas Nardelli, Gregory Farquhar, Philip Torr, Pushmeet Kohli, Shimon Whiteson,
et al. Stabilising experience replay for deep multi-agent reinforcement learning. arXiv preprint
arXiv:1702.08887, 2017.
Jakob N Foerster, Gregory Farquhar, Triantafyllos Afouras, Nantas Nardelli, and Shimon Whiteson.
Counterfactual multi-agent policy gradients. In Thirty-Second AAAI Conference on Artificial
Intelligence, 2018.
Jayesh K Gupta, Maxim Egorov, and Mykel Kochenderfer. Cooperative multi-agent control using
deep reinforcement learning. In International Conference on Autonomous Agents and Multiagent
Systems, pp. 66-83. Springer, 2017.
Jiechuan Jiang and Zongqing Lu. Learning attentional communication for multi-agent cooperation.
In Advances in Neural Information Processing Systems, pp. 7254-7264, 2018.
I Ge Jin and Gdbor Orosz. Dynamics of connected vehicle systems with delayed acceleration
feedback. Transportation Research Part C: Emerging Technologies, 46:46-64, 2014.
Xiangyu Kong, Bo Xin, Fangchen Liu, and Yizhou Wang. Revisiting the master-slave architecture in
multi-agent deep reinforcement learning. arXiv preprint arXiv:1712.07305, 2017.
Daniel Krajzewicz, Jakob Erdmann, Michael Behrisch, and Laura Bieker. Recent development and
applications of SUMO - Simulation of Urban MObility. International Journal On Advances in
Systems and Measurements, 5(3&4):128-138, December 2012.
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint arXiv:1509.02971, 2015.
Ryan Lowe, Yi Wu, Aviv Tamar, Jean Harb, OpenAI Pieter Abbeel, and Igor Mordatch. Multi-agent
actor-critic for mixed cooperative-competitive environments. In Advances in Neural Information
Processing Systems, pp. 6379-6390, 2017.
10
Published as a conference paper at ICLR 2020
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control
through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. In International Conference on Machine Learning, pp. 1928-1937, 2016.
Shayegan Omidshafiei, Jason Pazis, Christopher Amato, Jonathan P How, and John Vian. Deep
decentralized multi-task multi-agent rl under partial observability. arXiv preprint arXiv:1703.06182,
2017.
Peng Peng, Ying Wen, Yaodong Yang, Quan Yuan, Zhenkun Tang, Haitao Long, and Jun Wang.
Multiagent bidirectionally-coordinated nets: Emergence of human-level coordination in learning
to play starcraft combat games. arXiv preprint arXiv:1703.10069, 2017.
Junjie Qin, Yinlam Chow, Jiyan Yang, and Ram Rajagopal. Distributed online modified greedy
algorithm for networked storage operation under uncertainty. IEEE Transactions on Smart Grid, 7
(2):1106-1118, 2016.
Chao Qu, Shie Mannor, Huan Xu, Yuan Qi, Le Song, and Junwu Xiong. Value propagation for de-
centralized networked deep multi-agent reinforcement learning. arXiv preprint arXiv:1901.09326,
2019.
Amanpreet Singh, Tushar Jain, and Sainbayar Sukhbaatar. Learning when to communicate at scale in
multiagent cooperative and competitive tasks. arXiv preprint arXiv:1812.09755, 2018.
Sainbayar Sukhbaatar, Rob Fergus, et al. Learning multiagent communication with backpropagation.
In Advances in Neural Information Processing Systems, pp. 2244-2252, 2016.
Richard S Sutton and Andrew G Barto. Reinforcement learning: an introduction. Neural Networks,
IEEE Transactions on, 9(5):1054-1054, 1998.
Yong Xu, Renquan Lu, Peng Shi, Hongyi Li, and Shengli Xie. Finite-time distributed state estimation
over sensor networks with round-robin protocol and fading channels. IEEE transactions on
cybernetics, 48(1):336-345, 2018.
Yaodong Yang, Rui Luo, Minne Li, Ming Zhou, Weinan Zhang, and Jun Wang. Mean field multi-agent
reinforcement learning. arXiv preprint arXiv:1802.05438, 2018.
Kaiqing Zhang, Zhuoran Yang, Han Liu, Tong Zhang, and Tamer BaSar Fully decentralized multi-
agent reinforcement learning with networked agents. arXiv preprint arXiv:1802.08757, 2018.
Appendix
A Proofs
A. 1 Proof of Proposition 3.1
Proof. The proof follows the learning method in A2C Mnih et al. (2016), which shows that
L(θ) = |BB| X (Tog∏θ(ατ∣Sτ)Aπ + β X ∏θ(α∣Sτ)log∏θ(α∣Sτ) ) ,	(6)
| | τ∈B	a∈A
L(ω)= l⅛ X(Rn - vω(sτ))2,	⑺
∣B∣ τ∈B
0
where An = Rn - v「, RT = T0=τ=T Y 一丁丁z + γ B-τVtb , and v「=匕一(s「), based on on-policy
minibatch from a MDP {(sτ, aτ, rτ)}τ∈B.
Now we consider spatiotemporal MDP, which has transition in Eq. (1), optimizes return in Eq. (2), and
collects experience (si,t, mN⅛t, a*, r%,t), where ri,t = Pj∈v αdijrj,t. In Theorem 3.1 of Zhang
11
Published as a conference paper at ICLR 2020
et al. (2018), the decentralized actor and critic are ∏θi(S) and Vωi(s, a-i), for fitting ∏*(∙∣s) and
Paa∈a. ∏i(ai∣s)Qπi(s, a) under global observations, respectively. Now assuming the observations
and communications are restricted to each neighborhood as in Definition 3.1, then the actor and critic
become ∏θi(Si) ≈ ∏θi(s) and 匕乂^,。凶)≈ ‰ (s, a-i), with the best observability.
Hence, replacing ∏θ(a|s), Vω(s), r by ∏θi(。/0)，Vωi(Si, aN), and ri, respectively, we establish
Eq. (3)(4) from Eq. (6)(7), which concludes the proof.	□
Note partial observability and non-stationarity are present in ∏θi (a∕Si) and Vω⅛(Si, a，N). Fortunately,
communication improves the observability. Based on Definition 3.1, any information that agent j
knows at time t can be included in mji,t. We assume Sj,t ∪ {mkj,t-1}k∈Nj ⊂ mji,t. Then
SSi,t ⊃ Si,t ∪ {Sj,t ∪ {mkj,t-1 }k∈Nj }j∈Ni
⊃ {Sj,t}j∈Vi ∪ {Sj,t-1 ∪ {mkj,t-2}k∈Nj }j ∈V |dij =2
⊃ {sj,t}j∈Vi ∪ {sj,t-1}j∈V∣dij =2 ∪ {sj,t-2 ∪ {mkj,t-3}k∈Nj }j∈V∣dij =3
⊃...
⊃ Si,t ∪ Sj,t+1-dij j ∈V \{i} .
Thus, SSi,t includes the delayed global observations. On the other hand, Eq. (1)(2) mitigate the
non-stationarity. To see this mathematically,
Eπi,p [rSi,t |St, at] =Eπi,pi [ri,t |SVi,t, aNi,t] + α	Eπi,pj [rj,t |SVj,t, aVj \{i},t]
j∈Ni
dmax
+ X∣αd X	Epj[rj,t∣sv"Vj,t]),
d=2	j ∈{V |dij =d}
where the further away reward signals are discounted more. Note if communication is allowed, each
agent will have delayed global observations, and the non-stationarity mainly comes from limited
information of future actions.
A.2 Proof of Proposition 4.1
This proposition contains two statements regarding neural communication based global information
sharing in forward and backward propagations. We establish each of them separately.
Lemma A.1 (Spatial Information Propagation). In NeurComm, the delayed global information is
utilized to estimate each hidden state, that is,
hi,t ⊃ si,θ:t ∪ ss0：t^.^1-ddij , πjι0∙.t-dij1 j∈v∖{i} ,	(8)
where x ⊃ y if information y is utilized to estimate x, and x0:t := {x0, x1, . . . , xt}.
Proof. Based on the definition of NeurComm protocol (Eq. (5)), mi,t ⊃ hi,t-1, and hi,t ⊃ hi,t-1 ∪
SVi ,t ∪ πNi,t-1 ∪ mNi,t. Hence,
hi,t ⊃ Si,t ∪ {Sj,t, πj,t-1}j∈Ni ∪ {hj,t-1}j∈Vi
⊃ si,t ∪ {sj,t, πj,t-1}j∈Ni ∪ {sj,t-1 ∪ {sk,t-1, πk,t-2} k∈Nj ∪ {hk,t-2} k∈Vj }技心
=si,t-1：t ∪ {sj,t-上t, πj,t-2：t-1 }j∈Ni ∪ {sj,t-1, πj,t-2}j∈{V∣dij = 2}
∪ {hj,t-2}j∈{V∣dij ≤2}
⊃...
⊃ si,θ:t ∪ {sj,0：t,nj,t-2：t-l}jENi ∪ {sj,0：t-1,nj,0：t-2}jE{V|dij = 2}
∪ ... ∪ { sj,6t+1-dmax , nj,0:t-dmax } j∈{V∣ dij = dmax},
which concludes the proof.	□
Lemma A.2 (Spatial Gradient Propagation). In NeurComm, each message is learned to optimize
the performance of other agents, that is, {νi, λi} receive almost all gradients from L(θj), L(ωj),
∀j ∈ {V|j 6= i}.
12
Published as a conference paper at ICLR 2020
Proof. If we rewrite the required information for a given hidden state hi,t using intermediate messages
instead of inputs, the result of Lemma A.1 becomes
hi,t ⊃ {mj,t}j∈Ni ⊃ {hj,t-1}j∈Ni
⊃ {mj,t-1}j∈{V∣dij =2} ⊃ ...
⊃ {mj,t+1-d}j∈{V∣dij =d} ⊃ …
Hence, mi,τ is included in the meta-DNN of agent j at time τ + dij - 1. In other words, {νi, λi}
receive gradients from L(θj), L(ωj), ∀j ∈ {V|j 6= i}, except for the first dij - 1 experience samples.
Assuming dmax	|B|, {νi , λi} receive almost all gradients from loss signals of all other agents,
which concludes the proof.	□
B	Algorithms
Algo. 1 presents the algorithm of model training in a synchronous way, following descriptions in
Section 3 and 4. Four iterations are performed at each step: the first iteration (lines 3-5) updates and
sends messages; the second iteration (lines 6-10) updates hidden state, policy, and action; the third
iteration (lines 11-14) updates value estimation and executes action; the fourth iteration (lines 22-26)
performs gradient updates on actor, critic, and neural communication. On the other hand, Algo. 2
presents the algorithm of decentralized model execution in an asynchronous way. It runs as a job that
repeatedly measures traffic, sends message, receives messages, and performs control.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
Algorithm 1: Multi-agent A2C with NeurComm (Training)
Parameter: α, β, γ, T, |B|, ηω, η.
Result: {λi, νi, ωi, θi}i∈V.
initialize s0, π-ι, h-ι, t J 0, k J 0, B — 0;
repeat
for i ∈ V do
I Send mi,t = fλi(hi,t-ι)
end
for i ∈ V do
observe Si,t = sVi,t ∪ KNi,t-ι ∪ mNi,t；
update hi,t J gνi(hi,t-ι, Si,t), ∏i,t J ∏θi(∙∣hi,t);
update ai,t 〜∏i,t
end
for i ∈ V do
update vi,t J VLi(hi,t,aNi,t)；
execute ai,t；
end
simulate {si,t+1, ri,t}i∈V;
update B J B ∪ {(si,t, πi,t-1, ai,t, ri,t, vi,t)}i∈V;
update t J t + 1, k J k + 1;
if t = T then
I initialize s0, π-ι, h-ι, t J 0;
end
if k = |B| then
for i ∈ V do
update Rτπi, Aτπi, ∀τ ∈ B, based on Proposition 3.1;
update {λj,νj}j∈v ∪ {ωi}, based on ηwRL(Wi);
update {λj,νj}j∈v ∪ {θi}, based on ηVL(θi);
end
initialize B J 0, k J 0;
end
until Stop condition is reached;
13
Published as a conference paper at ICLR 2020
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Algorithm 2: Multi-agent A2C with NeurComm (Execution)
Parameter: {λi, %, ωi, θi}i∈v, ∆t
comm, ∆tcontrol.
for i ∈ V do
initialize h J 0, ∏ J 0, {sj,∏j, mj}j∈Ni J 0；
repeat
observe si;
update mi J fλi (hi);
send si , πi , mi ;
for j ∈ N do
I receive and update sj, ∏j, mj within ∆tcomm;
end
update Si J SVi ∪ ∏Ni ∪ mN ；
update hi J gνi(hi, Si) ∏i J ∏θi(∙∣hi);
execute a，i 〜πi;
sleep ∆tcontrol ;
until Stop condition is reached;
end
C Experiment Details
C.1 Algorithm Setup
Detailed algorithm implementations are listed below, in term of Eq. (5). IA2C: hi,t =
LSTM(hi,t-1, relu(sVi,t)). ConseNet: same as IA2C but with consensus critic up-
date. FPrint: hi,t = LSTM(hi,t-1, concat(relu(sVi,t), relu(πNi,t-1))). NeurComm:
hi,t = LSTM(hi,t-1, concat(relu(sVi,t), relu(πNi,t-1), relu(hNi,t-1))). DIAL: hi,t =
LSTM(hi,t-1, relu(sVi,t) + relu(relu(hi,t-1)) + onehot(ai,t-1)). CommNet: hi,t =
LSTM(hi,t-1, tanh(sVi,t) + linear(mean(hNi,t-1))). For ConseNet, we only do consensus up-
date on the LSTM layer, since the input and output layer sizes may not be fixed across agents. Also, the
actor and critic are πi,t = softmax(hi,t), and vi,t = linear(concat(hi,t, onehot(aNi,t)))
C.2 Experiments in ATSC Environment
C.2. 1 Action Space
Fig. 7	illustrates the action space of five phases for each intersection in the ATSC Grid scenario.
The ATSC Monaco scenario has complex and heterogeneous action spaces, please see the code for
more details. To summarize, there are 11 two-phase intersections, 3 three-phase intersections, 10
four-phase intersections, 1 five-phase intersection, and 3 six-phase intersections.
C.2.2 S ummary of Execution Performance
Table 3 summarizes the key metrics in ATSC. The spatial average is taken at each second, and then
the temporal average is calculated for all metrics (except for trip delay, which is directly aggregated
over all trips). NeurComm outperforms all baselines on minimizing queue length and intersection
delay. Interestingly, even though IA2C is good at optimizing the given objective of queue length, it
performs poorly on optimizing intersection and trip delays.
C.2.3 Visualization of Execution Performance
Fig. 8	and Fig. 9 show screenshots of traffic distributions in the grid at different simulation steps for
each MARL controller. The visualization is based on one execution episode with random seed 2000.
Clearly, communicative MARL controllers have better performance on reducing the intersection
delay. NeurComm and CommNet have the best overall performance.
14
Published as a conference paper at ICLR 2020
Figure 7: Possible signal phases at each intersection.
Table 3: Performance of MARL controllers in ATSC environments: synthetic traffic grid (top) and
Monaco traffic network (bottom). Best values are in bold.
Temporal Average Metrics	NeurComm	CommNet	DIAL	IA2C	FPrint	ConseNet
avg queue length [veh]	116	144	2.36	1.63	1.62	2.04
avg intersection delay [s/veh]	68	111	145	376	415	366
avg vehicle speed [m/s]	2.28	1.82	1.78	0.26	0.23	0.29
trip delay [s]	293	455	1949	2067	1949	321
avg queue length [veh]	127	156	1.88	1.93	1.87	2.74
avg intersection delay [s/veh]	221.1	236.5	231.3	147.4	174.8	187.3
avg vehicle speed [m/s]	0.55	0.61	0.94	2.36	1.26	1.03
trip delay [s]	569	847	506	295	428	540
C.3 Experiments in CACC Environments
C.3.1 S ummary of Execution Performance
Table 4 summarizes the key metrics in CACC. The best headway and velocity averages are closest
ones to h* = 20m, and v* = 15m∕s. Note the averages are only computed from safe execution
episodes, and we use another metric “collision number” to count the number of episodes where an
collision happens within the horizon. Ideally, “collision-free” is the top priority. However, safe RL is
not the focus of this paper so trained MARL controllers cannot achieve this goal in the experiments
of CACC.
Table 4: Performance of MARL controllers in CACC environments: catch-up (above) and slow-down
(below). Best values are in bold.
Temporal Average Metrics	NeurComm	CommNet	DIAL	IA2C	FPrint	ConseNet
avg vehicle headway [m]	-2045	-^20.47^^	21.99	22.02	20.44	21.45
std vehicle headway [m]	1.20	1.18	0.20	0.19	1.03	0
avg vehicle velocity [m/s]	15.33	15.33	15.07	15.07	15.33	15.00
std vehicle velocity [m/s]	0.90	0.87	0.16	0.18	0.75	0
collision number	0	0	0	0	0	0
avg vehicle headway [m]	15:84	-^1624^^	14.42	-	18.21	11.60
std vehicle headway [m]	2.10	2.16	1.70	-	2.40	0.49
avg vehicle velocity [m/s]	13.43	13.82	12.28	-	15.47	8.59
std vehicle velocity [m/s]	2.77	2.88	2.49	-	3.37	1.19
collision number	13	12	16	50	8	23
15
Published as a conference paper at ICLR 2020
t = 1500 sec
t = 2500 sec
t = 3500 sec
Ja号 suoɔ
Figure 8: Screenshots of traffic distribution in the grid. Each row is a non-communicative MARL
controller and each column is a simulation step. The traffic condition along each lane is visualized as
a line segment, with the color indicating the queue length or congestion level (grey: 0% traffic, green:
25% traffic, yellow: 50% traffic, orange: 70% traffic, red: 90% traffic, intermediate traffic condition
is shown as the interpolated color), while the thickness indicating the intersection delay (the thicker
the longer waiting time at intersection).
16
Published as a conference paper at ICLR 2020
t = 2500 sec
t = 1500 sec
t = 3500 sec
UIulOOJnOZ
JoZEEOO
Figure 9: Screenshots of traffic distribution in the grid. Each row is a communicative MARL
controller and each column is a simulation step.
1+ ,JI-
--I
ɑvɪɑ
17