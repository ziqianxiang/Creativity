Published as a conference paper at ICLR 2020
Understanding and Improving Information
Transfer in Multi-Task Learning
Sen Wu*
Stanford University
Hongyang R. Zhang*
University of Pennsylvania
Christopher Re
Stanford University
Ab stract
We investigate multi-task learning approaches that use a shared feature represen-
tation for all tasks. To better understand the transfer of task information, we study
an architecture with a shared module for all tasks and a separate output module
for each task. We study the theory of this setting on linear and ReLU-activated
models. Our key observation is that whether or not tasks’ data are well-aligned
can significantly affect the performance of multi-task learning. We show that mis-
alignment between task data can cause negative transfer (or hurt performance)
and provide sufficient conditions for positive transfer. Inspired by the theoreti-
cal insights, we show that aligning tasks’ embedding layers leads to performance
gains for multi-task training and transfer learning on the GLUE benchmark and
sentiment analysis tasks; for example, we obtain a 2.35% GLUE score average
improvement on 5 GLUE tasks over BERTLARGE using our alignment method.
We also design an SVD-based task reweighting scheme and show that it improves
the robustness of multi-task training on a multi-label image dataset.
1	Introduction
Multi-task learning has recently emerged as a powerful paradigm in deep learning to obtain lan-
guage (Devlin et al. (2018); Liu et al. (2019a;b)) and visual representations (Kokkinos (2017)) from
large-scale data. By leveraging supervised data from related tasks, multi-task learning approaches
reduce the expensive cost of curating the massive per-task training data sets needed by deep learning
methods and provide a shared representation which is also more efficient for learning over multiple
tasks. While in some cases, great improvements have been reported compared to single-task learning
(McCann et al. (2018)), practitioners have also observed problematic outcomes, where the perfor-
mances of certain tasks have decreased due to task interference (Alonso and Plank (2016); Bingel
and S0gaard (2017)). Predicting when and for which tasks this occurs is a challenge exacerbated by
the lack of analytic tools. In this work, we investigate key components to determine whether tasks
interfere constructively or destructively from theoretical and empirical perspectives. Based on these
insights, we develop methods to improve the effectiveness and robustness of multi-task training.
There has been a large body of algorithmic and theoretical studies for kernel-based multi-task learn-
ing, but less is known for neural networks. The conceptual message from the earlier work (Bax-
ter (2000); Evgeniou and Pontil (2004); Micchelli and Pontil (2005); Xue et al. (2007)) show that
multi-task learning is effective over “similar” tasks, where the notion of similarity is based on the
single-task models (e.g. decision boundaries are close). The work on structural correspondence
learning (Ando and Zhang (2005); Blitzer et al. (2006)) uses alternating minimization to learn a
shared parameter and separate task parameters. Zhang and Yeung (2014) use a parameter vector for
each task and learn task relationships via l2 regularization, which implicitly controls the capacity of
the model. These results are difficult to apply to neural networks: it is unclear how to reason about
neural networks whose feature space is given by layer-wise embeddings.
To determine whether two tasks interfere constructively or destructively, we investigate an architec-
ture with a shared module for all tasks and a separate output module for each task (Ruder (2017)).
See Figure 1 for an illustration. Our motivating observation is that in addition to model similarity
which affects the type of interference, task data similarity plays a second-order effect after control-
ling model similarity. To illustrate the idea, we consider three tasks with the same number of data
* Equal contribution. Correspondence to {senwu,hongyang,chrismre}@cs.stanford.edu
1
Published as a conference paper at ICLR 2020
Task-Specific Modules (A)
Figure 1: An illustration of
the multi-task learning architecture
with a shared lower module B and
k task-specific modules {Ai}ik=1.
Figure 2: Positive vs. Negative transfer is affected by the data
一not just the model. See lower right-vs-mid. Task 2 and 3
have the same model (dotted lines) but different data distribu-
tions. Notice the difference of data in circled areas.
samples where task 2 and 3 have the same decision boundary but different data distributions (see
Figure 2 for an illustration). We observe that training task 1 with task 2 or task 3 can either im-
prove or hurt task 1’s performance, depending on the amount of contributing data along the decision
boundary! This observation shows that by measuring the similarities of the task data and the models
separately, we can analyze the interference of tasks and attribute the cause more precisely.
Motivated by the above observation, we study the theory of multi-task learning through the shared
module in linear and ReLU-activated settings. Our theoretical contribution involves three compo-
nents: the capacity of the shared module, task covariance, and the per-task weight of the training
procedure. The capacity plays a fundamental role because, if the shared module’s capacity is too
large, there is no interference between tasks; if it is too small, there can be destructive interference.
Then, we show how to determine interference by proposing a more fine-grained notion called task
covariance which can be used to measure the alignment of task data. By varying task covariances,
we observe both positive and negative transfers from one task to another! We then provide sufficient
conditions which guarantee that one task can transfer positively to another task, provided with suffi-
ciently many data points from the contributor task. Finally, we study how to assign per-task weights
for settings where different tasks share the same data but have different labels.
Experimental results. Our theory leads to the design of two algorithms with practical interest.
First, we propose to align the covariances of the task embedding layers and present empirical evalu-
ations on well-known benchmarks and tasks. On 5 tasks from the General Language Understanding
Evaluation (GLUE) benchmark (Wang et al. (2018b)) trained with the BERTLARGE model by De-
vlin et al. (2018), our method improves the result of BERTLARGE by a 2.35% average GLUE score,
which is the standard metric for the benchmark. Further, we show that our method is applicable
to transfer learning settings; we observe up to 2.5% higher accuracy by transferring between six
sentiment analysis tasks using the LSTM model of Lei et al. (2018).
Second, we propose an SVD-based task reweighting scheme to improve multi-task training for set-
tings where different tasks have the same features but different labels. On the ChestX-ray14 dataset,
we compare our method to the unweighted scheme and observe an improvement of 0.4% AUC score
on average for all tasks . In conclusion, these evaluations confirm that our theoretical insights are
applicable to a broad range of settings and applications.
2	Three Components of Multi-Task Learning
We study multi-task learning (MTL) models with a shared module for all tasks and a separate output
module for each task. We ask: What are the key components to determine whether or not MTL is
better than single-task learning (STL)? In response, we identify three components: model capacity,
task covariance, and optimization scheme. After setting up the model, we briefly describe the role
of model capacity. We then introduce the notion of task covariance, which comprises the bulk of the
section. We finish by showing the implications of our results for choosing optimization schemes.
2
Published as a conference paper at ICLR 2020
2.1	Modeling Setup
We are given k tasks. Let mi denote the number of data samples of task i. For task i, let Xi ∈ Rmi×d
denote its covariates and let yi ∈ Rmi denote its labels, where d is the dimension of the data. We
have assumed that all the tasks have the same input dimension d. This is not a restrictive assumption
and is typically satisfied, e.g. for word embeddings on BERT, or by padding zeros to the input
otherwise. Our model assumes the output label is 1-dimensional. We can also model a multi-label
problem with k types of labels by having k tasks with the same covariates but different labels. We
consider an MTL model with a shared module B ∈ Rd×r and a separate output module Ai ∈ Rr
for task i, where r denotes the output dimension of B. See Figure 1 for the illustration. We define
the objective of finding an MTL model as minimizing the following equation over B and the Ai ’s:
k
f(A1, A2, . . . , Ak; B) = X L (g(XiB)Ai, yi) ,	(1)
i=1
where L is a loss function such as the squared loss. The activation function g : R → R is applied on
every entry of Xi B . In equation 1, all data samples contribute equally. Because of the differences
between tasks such as data size, it is natural to re-weight tasks during training:
k
f (A1, A2,. .., Ak; B)= X αi ∙ LlgbiB)Ai, yi ),	⑵
i=1
This setup is an abstraction of the hard parameter sharing architecture (Ruder (2017)). The shared
module B provides a universal representation (e.g., an LSTM for encoding sentences) for all tasks.
Each task-specific module Ai is optimized for its output. We focus on two models as follows.
The single-task linear model. The labels y of each task follow a linear model with parameter θ ∈ Rd :
y = Xθ + ε. Every entry of ε follows the normal distribution N(0, σ2) with variance σ2. The
function g(XB) = XB. This is a well-studied setting for linear regression (Hastie et al. (2005)).
The single-task ReLU model. Denote by ReLU(x) = max(x, 0) for any x ∈ R. We will also
consider a non-linear model where Xθ goes through the ReLU activation function with a ∈ R and
θ ∈ Rd: y = a ∙ ReLU(Xθ) + ε, which applies the ReLU activation on Xθ entrywise. The encoding
function g(XB) then maps to ReLU(XB).
Positive vs. negative transfer. For a source task and a target task, we say the source task transfers
positively to the target task, if training both through equation 1 improves over just training the target
task (measured on its validation set). Negative transfer is the converse of positive transfer.
Problem statement. Our goal is to analyze the three components to determine positive vs. negative
transfer between tasks: model capacity (r), task covariances ({Xi>Xi}ik=1) and the per-task weights
({αi}ik=1). We focus on regression tasks under the squared loss but we also provide synthetic exper-
iments on classification tasks to validate our theory.
Notations. For a matrix X, its column span is the set of all linear combinations of the column vectors
of X. Let X* denote its pseudoinverse. Given u,v ∈ Rd, cos(u, V) is equal to u>v∕(ku∣∣∙ ∣∣vk).
2.2	Model Capacity
We begin by revisiting the role of model capacity, i.e. the output dimension ofB (denoted by r). We
show that as a rule of thumb, r should be smaller than the sum of capacities of the STL modules.
Example. Suppose we have k linear regression tasks using the squared loss, equation 1 becomes:
k
f(A1,A2,...,Ak;B) = X∣XiBAi-yi∣2F.	(3)
i=1
The optimal solution of equation 3 for task i is θi = (Xi>Xi)*Xi>yi ∈ Rd. Hence a capacity of 1
suffices for each task. We show that if r ≥ k, then there is no transfer between any two tasks.
3
Published as a conference paper at ICLR 2020
Source vs. target (Task 1): Same covariance (Source: Task 2) Diff. covariance (Source: Task 3)
IIS ,1-UΛI「七① d S'S-J ① PBj.
2000 4000 6000 8000	2000 4000	6000 8000	2000 4000	6000 8000
# Data samples of source task	# Data samples of source task	# Data samples of source task
(a) Linear regression tasks (b) Logistic classification tasks (c) ReLU regression tasks
Figure 3: Performance improvement of a target task (Task 1) by MTL with a source task vs. STL.
Red: positive transfer when the source is Task 2, which has the same covariance matrix with target.
Green: negative (to positive) transfer when the source is Task 3, which has a different covariance
from the target, as its # of samples increases. See the example below for the definition of each task.
Proposition 1. Let r ≥ k. There exists an optimum B? and {Ai?}ik=1 of equation 3 where B?Ai? =
θi, for all i = 1, 2, . . . , k.
To illustrate the idea, as long as B? contains {θi }ik=1 in its column span, there exists Ai? such that
B?Ai? = θi , which is optimal for equation 3 with minimum error. But this means no transfer
among any two tasks. This can hurt generalization if a task has limited data, in which case its STL
solution overfits training data, whereas the MTL solution can leverage other tasks’ data to improve
generalization. The proof of Proposition 1 and its extension to ReLU settings are in Appendix A.1.
Algorithmic consequence. The implication is that limiting the shared module’s capacity is nec-
essary to enforce information transfer. If the shared module is too small, then tasks may interfere
negatively with each other. But if it is too large, then there may be no transfer between tasks. In Sec-
tion 3.3, we verify the need to carefully choose model capacity on a wide range of neural networks
including CNN, LSTM and multi-layer perceptron.
2.3 Task Covariance
To show how to quantify task data similarity, we illustrate with two regression tasks under the linear
model without noise: y1 = X1 θ1 and y2 = X2θ2 . By Section 2.2, it is necessary to limit the
capacity of the shared module to enforce information transfer. Therefore, we consider the case of
r = 1. Hence, the shared module B is now a d-dimensional vector, and A1, A2 are both scalars.
A natural requirement of task similarity is for the STL models to be similar, i.e. ∣cos(θι, Θ2)∣ to be
large. To see this, the optimal STL model for task 1 is (X>X1)-1X>y1 = θ`. Hence if ∣cos(θ1,θ2)∣
is 1, then tasks 1 and 2 can share a model B ∈ Rd which is either θ1 or -θ1. The scalar A1 and A2
can then transform B to be equal to θ1 and θ2 .
Is this requirement sufficient? Recall that in equation 3, the task data X1 and X2 are both multiplied
by B . If they are poorly “aligned” geometrically, the performance could suffer. How do we formal-
ize the geometry between task alignment? In the following, we show that the covariance matrices of
Xi and X2, which we define to be X>X1 and X>X2,captures the geometry. Wefix ∣cos(θ1,θ2)∣ to
be close to 1 to examine the effects of task covariances. In Appendix A.2.1 we fix task covariances
to examine the effects of model cosine similarity. Concretely, equation 3 reduces to:
maRd h(B) = hkχBk，y1i2+〈普，y2i2,	⑷
where we apply the first-order optimality condition on A1 and A2 and simplify the equation. Specif-
ically, we focus on a scenario where task 1 is the source and task 2 is the target. Our goal is to
determine when the source transfers to the target positively or negatively in MTL. Determining the
type of transfer from task 2 to task 1 can be done similarly. Answering the question boils down to
studying the angle or cosine similarity between the optimum of equation 4 and θ2.
Example. In Figure 3, we show that by varying task covariances and the number of samples, we can
observe both positive and negative transfers. The conceptual message is the same as Figure 2; we
4
Published as a conference paper at ICLR 2020
Algorithm 1 Covariance alignment for multi-task training
Require: Task embedding layers X1 ∈ Rm1×d,X2 ∈ Rm2×d,. . . ,Xk ∈ Rmk×d, shared module B
Parameter: Alignment matrices R1 , R2 , . . . , Rk ∈ Rd×d and output modules A1 , A2 . . . , Ak ∈ Rr
1:	Let Zi = Xi Ri, for 1 ≤ i ≤ k.
Consider the following modified loss (with B being fixed):
f(Aι ,...,Ak ； Rι,...,Rk) = Pi=I L(g(ZiB)Ai,yi) = Pk=ι L(g(XH 闻 4,yi)
2:	Minimize f by alternatively applying a gradient descent update on Ai and Ri , given a sampled data batch
from task i.
Other implementation details are described in Appendix B.3.
describe the data generation process in more detail. We use 3 tasks and measure the type of transfer
from the source to the target. The x-axis is the number of data samples from the source. The y-axis
is the target’s performance improvement measured on its validation set between MTL minus STL.
Data generation. We have ∣cos(θ1,θ2)∣ ≈ 1 (Say 0.96). For i ∈ {1, 2, 3}, let Ri ⊆ Rmi×d denote
a random Gaussian matrix drawn from N(0, 1). Let S1, S2 ⊆ {1, 2, . . . , d} be two disjoint sets of
size d/10. For i = 1, 2, let Di be a diagonal matrix whose entries are equal to a large value κ (e.g.
κ = 100) for coordinates in Si and 1 otherwise. Let Qi ⊆ Rd×d denote an orthonormal matrix, i.e.
Qi>Qi is equal to the identity matrix, orthogonalized from a random Gaussian matrix.
Then, we define the 3 tasks as follows. (i) Task 1 (target): X1 = R1Q1D1 and y1 = X1θ1. (ii) Task
2 (source task for red line): X2 = R2Q1D1 and y2 = X2θ2. (iii) Task 3 (source task for green line):
X3 = R3Q2D2 and y3 = X3θ2. Task 1 and 2 have the same covariance matrices but task 1 and 3
have different covariance matrices. Intuitively, the signals of task 1 and 3 lie in different subspaces,
which arise from the difference in the diagonals of Di and the orthonormal matrices.
Analysis. Unless the source task has lots of samples to estimate θ2, which is much more than the
samples needed to estimate only the coordinates of S1, the effect of transferring to the target is small.
We observe similar results for logistic regression tasks and for ReLU-activated regression tasks.
Theory. We rigorously quantify how many data points is needed to guarantee positive transfer. The
folklore in MTL is that when a source task has a lot of data but the related target task has limited
data, then the source can often transfer positively to the target task. Our previous example shows
that by varying the source’s number of samples and its covariance, we can observe both types of
transfer. How much data do we need from the source to guarantee a positive transfer to the target?
We show that this depends on the condition numbers of both tasks’ covariances.
Theorem 2 (informal). For i = 1, 2, let yi = Xi θi + εi denote two linear regression tasks with
parameters θi ∈ Rd and mi number of samples. Suppose that each row of the source task X1 is
drawn independently from a distribution with covariance Σ1 ⊆ Rd×d and bounded l2-norm. Let
c = κ(X2)sin(θ1, θ2) and assume that c ≤ 1/3. Denote by (B?, A1?, A?2) the optimal MTL solution.
With high probability, when mi is at least on the order of (κ2(∑1) ∙ κ4(X2) ∙ ∣∣y2k2)∕c4, we have
kB?A? — θ2k∕kθ2k ≤ 6c +ɪηj⅛.	(5)
1 - 3c ∣X2θ2 ∣
Recall that for a matrix X, κ(X) denotes its condition number. Theorem 2 quantifies the trend in
Figure 3, where the improvements for task 2 reaches the plateau when m1 becomes large enough.
The parameter c here indicates how similar the two tasks are. The smaller sin(θ1, θ2) is, the smaller
c is. As an example, if sin(θ1, θ2) ≤ δ∕κ(X2) for some δ, then equation 5 is at most O(δ) +
∣ε2 ∣∕∣X2θ2∣.1 The formal statement, its proof and discussions on the assumptions are deferred to
Appendix A.2.2.
The ReLU model. We show a similar result for the ReLU model, which requires resolving the chal-
lenge of analyzing the ReLU function. We use a geometric characterization for the ReLU function
under distributional input assumptions by Du et al. (2017). The result is deferred to Appendix A.2.3.
1The estimation error of θ2 is upper bounded by task 2's signal-to-noise ratio ∣∣ε2k∕kX2θ2k. This depen-
dence arises because the linear component A2? fits the projection of y2 to X2B?. So even if B? is equal to θ2,
there could still be an estimation error out ofA?2, which cannot be estimated from task 1’s data.
5
Published as a conference paper at ICLR 2020
Algorithm 2 An SVD-based task re-weighting scheme
Input: k tasks: (X, yi) ∈ (Rm×d, Rm); a rank parameter r ∈ {1, 2, . . . , k}
Output: A weight vector: {α1 , α2 , . . . , αk }
1:	Let θi = X> yi .
2:	Ur, Dr, Vr = SVDr(θι,θ2 ,...,θk), i.e. the best rank-r approximation to the θjs.
3:	Let αi = kθi> Ur k, for i = 1, 2, . . . , k.
Algorithmic consequence. An implication of our theory is a covariance alignment method to im-
prove multi-task training. For the i-th task, we add an alignment matrix Ri before its input Xi passes
through the shared module B . Algorithm 1 shows the procedure.
We also propose a metric called covariance similarity score to measure the similarity between two
tasks. Given X1 ∈ Rm1 ×d and X2 ∈ Rm2×d, we measure their similarity in three steps: (a) The
covariance matrix is X1>X1. (b) Find the best rank-r1 approximation to be U1,r1 D1,r1 U1>,r , where
r1 is chosen to contain 99% of the singular values. (c) Apply step (a),(b) to X2 , compute the score:
Covariance similarity score :
k(Ul,r1D*1)>。2,「2。鬃 kF
1/2	1/2
kU1,rι D1,rιkF ∙kU2,r2 D2,r2 IIf
(6)
The nice property of the score is that it is invariant to rotations of the columns of X1 and X2 .
2.4 Optimization Scheme
Lastly, we consider the effect of re-weighting the tasks (or their losses in equation 2). When does re-
weighting the tasks help? In this part, we show a use case for improving the robustness of multi-task
training in the presence of label noise. The settings involving label noise can arise when some tasks
only have weakly-supervised labels, which have been studied before in the literature (e.g. Mintz
et al. (2009); Pentina and Lampert (2017)). We start by describing a motivating example.
Consider two tasks where task 1 is y1 = Xθ and task 2 is y2 = Xθ + ε2. If we train the two
tasks together, the error ε2 will add noise to the trained model. However, by up weighting task 1,
we reduce the noise from task 2 and get better performance. To rigorously study the effect of task
weights, we consider a setting where all the tasks have the same data but different labels. This setting
arises for example in multi-label image tasks. We derive the optimal solution in the linear model.
Proposition 3. Let the shared module have capacity r ≤ k. Given k tasks with the same covariates
X ⊆ Rm×d but different labels {yi}ik=1. Let X be full rank and UDV > be its SVD. Let Qr Qr> be
the best rank-r approximation to Pik=1 αiU>yiyi>U. Let B? ⊆ Rd×r be an optimal solution for
the re-weighted loss. Then the column span of B? is equal to the column span of (X>X)-1V DQr.
We can also extend Proposition 3 to show that all local minima of equation 3 are global minima in
the linear setting. We leave the proof to Appendix A.3. We remark that this result does not extend
to the non-linear ReLU setting and leave this for future work.
Based on Proposition 3, we provide a rigorous proof of the previous example. Suppose that X is
full rank, (X>X)*X[α1y1,α1y2]) = [α1θ,α2θ + α2(X>X)-1Xε2]. Hence, when we increase
α1, cos(B?, θ) increases closer to 1.
Algorithmic consequence. Inspired by our theory, we describe a re-weighting scheme in the pres-
ence of label noise. We compute the per-task weights by computing the SVD over X>yi, for
1 ≤ i ≤ k. The intuition is that if the label vector of a task yi is noisy, then the entropy of yi is
small. Therefore, we would like to design a procedure that removes the noise. The SVD procedure
does this, where the weight of a task is calculated by its projection into the principal r directions.
See Algorithm 2 for the description.
6
Published as a conference paper at ICLR 2020
Figure 4: Illustration of the covariance alignment module on task embeddings.
3 Experiments
We describe connections between our theoretical results and practical problems of interest. We show
three claims on real world datasets. (i) The shared MTL module is best performing when its capacity
is smaller than the total capacities of the single-task models. (ii) Our proposed covariance alignment
method improves multi-task training on a variety of settings including the GLUE benchmarks and
six sentiment analysis tasks. Our method can be naturally extended to transfer learning settings and
we validate this as well. (iii) Our SVD-based reweighed scheme is more robust than the standard
unweighted scheme on multi-label image classification tasks in the presence of label noise.
3.1	Experimental Setup
Datasets and models. We describe the datasets and models we use in the experiments.
GLUE: GLUE is a natural language understanding dataset including question answering, sentiment
analysis, text similarity and textual entailment problems. We choose BERTLARGE as our model,
which is a 24 layer transformer network from Devlin et al. (2018). We use this dataset to evaluate
how Algorithm 1 works on the state-of-the-art BERT model.
Sentiment Analysis: This dataset includes six tasks: movie review sentiment (MR), sentence sub-
jectivity (SUBJ), customer reviews polarity (CR), question type (TREC), opinion polarity (MPQA),
and the Stanford sentiment treebank (SST) tasks.
For each task, the goal is to categorize sentiment opinions expressed in the text. We use an embed-
ding layer (with GloVe embeddings2) followed by an LSTM layer proposed by Lei et al. (2018)3.
ChestX-ray14: This dataset contains 112,120 frontal-view X-ray images and each image has up to
14 diseases. This is a 14-task multi-label image classification problem. We use the CheXNet model
from Rajpurkar et al. (2017), which is a 121-layer convolutional neural network on all tasks.
For all models, we share the main module across all tasks (BERTLARGE for GLUE, LSTM for
sentiment analysis, CheXNet for ChestX-ray14) and assign a separate regression or classification
layer on top of the shared module for each tasks.
Comparison methods. For the experiment on multi-task training, we compare Algorithm 1 by
training with our method and training without it. Specifically, we apply the alignment procedure on
the task embedding layers. See Figure 4 for an illustration, where Ei denotes the embedding of task
i, Ri denotes its alignment module and Zi = EiRi is the rotated embedding.
For transfer learning, we first train an STL model on the source task by tuning its model capacity
(e.g. the output dimension of the LSTM layer). Then, we fine-tune the STL model on the target
task for 5-10 epochs. To apply Algorithm 1, we add an alignment module for the target task during
fine-tuning.
For the experiment on reweighted schemes, we compute the per-task weights as described in Algo-
rithm 2. Then, we reweight the loss function as in equation 2. We compare with the reweighting
techniques of Kendall et al. (2018). Informally, the latter uses Gaussian likelihood to model classi-
2http://nlp.stanford.edu/data/wordvecs/glove.6B.zip
3We also tested with multi-layer perceptron and CNN. The results are similar (cf. Appendix B.5).
7
Published as a conference paper at ICLR 2020
(a) MTL on GLUE over 10 task pairs (b) Transfer learning on six sentiment analysis tasks
Figure 5: Performance improvements of Algorithm 1 by aligning task embeddings.
fication outputs. The weights, defined as inversely proportional to the variances of the Gaussian, are
optimized during training. We also compare with the unweighted loss (cf. equation 1) as a baseline.
Metric. We measure performance on the GLUE benchmark using a standard metric called the
GLUE score, which contains accuracy and correlation scores for each task.
For the sentiment analysis tasks, We measure the accuracy of predicting the sentiment opinion.
For the image classification task, We measure the area under the curve (AUC) score. We run five
different random seeds to report the average results. The result of an MTL experiment is averaged
over the results of all the tasks, unless specified otherwise.
For the training procedures and other details on the setup, We refer the reader to Appendix B.
3.2	Experimental Results
We present use cases of our methods on open-source datasets. We expected to see improvements via
our methods in multi-task and other settings, and indeed We saw such gains across a variety of tasks.
Improving multi-task training. We apply Algorithm 1 on five tasks (CoLA, MRPC, QNLI, RTE,
SST-2) from the GLUE benchmark using a state-of-the-art language model BERTLArge. 4 We
train the output layers {Ai} and the alignment layers {R} using our algorithm. We compare the
average performance over all five tasks and find that our method outperforms BERTLARGE by 2.35%
average GLUE score for the five tasks. For the particular setting of training two tasks, our method
outperforms BERTLARGE on 7 of the 10 task pairs. See Figure 5a for the results.
Improving transfer learning. While our study has focused on multi-task learning, transfer learning
is a naturally related goal - and we find that our method is also useful in this case. We validate this
by training an LsTM on sentiment analysis. Figure 5b shows the result with ssT being the source
task and the rest being the target task. Algorithm 1 improves accuracy on four tasks by up to 2.5%.
Reweighting training for the same task covariates. We evaluate Algorithm 2 on the ChestX-ray14
dataset. This setting satisfies the assumption of Algorithm 2, which requires different tasks to have
the same input data. Across all 14 tasks, we find that our reweighting method improves the technique
of Kendall et al. (2018) by 0.1% AUC score. Compared to training with the unweighted loss, our
method improves performance by 0.4% AUC score over all tasks.
3.3	Ablation Studies
Model capacity. We verify our hypothesis that the capacity of the MTL model should not exceed the
total capacities of the sTL model. We show this on an LsTM model with sentiment analysis tasks.
Recall that the capacity of an LsTM model is its output dimension (before the last classification
layer). We train an MTL model with all tasks and vary the shared module’s capacity to find the
optimum from 5 to 500. similarly we train an sTL model for each task and find the optimum.
In Figure 1, we find that the performance of MTL peaks when the shared module has capacity
100. This is much smaller than the total capacities of all the sTL models. The result confirms that
4https://github.com/google-research/bert
8
Published as a conference paper at ICLR 2020
Figure 6: Covariance similarity score vs.
performance improvements from alignment.
Table 1: Comparing the model capacity between
MTL and STL.
Task	STL		MTL	
	Cap.	Acc.	Cap.	Acc.
SST	200	82.3		90.8
MR	200	76.4		96.0
CR	5	73.2	100	78.7
SUBJ	200	91.5		89.5
MPQA	500	86.7		87.0
TREC	100	85.7		78.7
Overall	1205	82.6	100	85.1
stnemevorpmI ecnamrofre
0.04
0.02
0
LSTM
Baseline
....Covariance
A Alignment
冰
• TREC,SUBJ∣
ICR,MR
MPQA,SUBJ∣
Cr CR, SUBJ
⅜∙TREC,SST I
0.1	0.2 0.3 0.4 0.5
Covariance similarity score
2
constraining the shared module’s capacity is crucial to achieve the ideal performance. Extended
results on CNN/MLP to support our hypothesis are shown in Appendix B.5.
Task covariance. We apply our metric of task covariance similarity score from Section 2.3 to
provide an in-depth study of the covariance alignment method. The hypothesis is that: (a) aligning
the covariances helps, which we have shown in Figure 5a; (b) the similarity score between two tasks
increases after applying the alignment. We verify the hypothesis on the sentiment analysis tasks. We
use the single-task model’s embedding before the LSTM layer to compute the covariance.
First, we measure the similarity score using equation 6 between all six single-task models. Then,
for each task pair, we train an MTL model using Algorithm 1. We measure the similarity score on
the trained MTL model. Our results confirm the hypothesis (Figure 6): (a) we observe increased
accuracy on 13 of 15 task pairs by up to 4.1%; (b) the similarity score increases for all 15 task pairs.
Optimization scheme. We verify the robustness of Algorithm 2. After selecting two tasks from the
ChestX-ray14 dataset, we test our method by assigning random labels to 20% of the data on one
task. The labels for the other task remain unchanged.
On 10 randomly selected pairs, our method improves over the unweighted scheme by an average
1.0% AUC score and the techniques of Kendall et al. (2018) by an average 0.4% AUC score. We
include more details of this experiment in Appendix B.5.
4	Related Work
There has been a large body of recent work on using the multi-task learning approach to train deep
neural networks. Liu et al. (2019a); McCann et al. (2018) and subsequent follow-up work show
state-of-the-art results on the GLUE benchmark, which inspired our study of an abstraction of the
MTL model. Recent work of Zamir et al. (2018); Standley et al. (2019) answer which visual tasks
to train together via a heuristic which involves intensive computation. We discuss several lines of
studies related to this work. For complete references, we refer the interested readers to the survey of
Ruder (2017); Zhang and Yang (2017) and the surveys on domain adaptation and transfer learning
by Pan and Yang (2009); Kouw (2018) for references.
Theoretical studies of multi-task learning. Of particular relevance to this work are those that
study the theory of multi-task learning. The earlier works of Baxter (2000); Ben-David and Schuller
(2003) are among the first to formally study the importance of task relatedness for learning multiple
tasks. See also the follow-up work of Maurer (2006) which studies generalization bounds of MTL.
A closely related line of work to structural learning is subspace selection, i.e. how to select a
common subspace for multiple tasks. Examples from this line work include Obozinski et al. (2010);
Wang et al. (2015); Fernando et al. (2013); Elhamifar et al. (2015). Evgeniou and Pontil (2004);
Micchelli and Pontil (2005) study a formulation that extends support vector machine to the multi-
task setting. See also Argyriou et al. (2008); Pentina et al. (2015); Pentina and Ben-David (2015);
Pentina and Lampert (2017) that provide more refined optimization methods and further study. The
work of Ben-David et al. (2010) provides theories to measure the differences between source and
target tasks for transfer learning in a different model setup. Khodak et al. (2019); Kong et al. (2020);
9
Published as a conference paper at ICLR 2020
Du et al. (2020) consider the related meta learning setting, which is in spirit an online setting of
multi-task learning.
Our result on restricting the model capacities for multi-task learning is in contrast with recent the-
oretical studies on over-parametrized models (e.g. Li et al. (2018); Zhang et al. (2019a); Bartlett
et al. (2020)), where the model capacities are usually much larger than the regime we consider here.
It would be interesting to better understand multi-task learning in the context of over-parametrized
models with respect to other phenomenon such as double descent that has been observed in other
contexts (Belkin et al. (2019)).
Finally, Zhang et al. (2019b); Shui et al. (2019) consider multi-task learning from the perspective of
adversarial robustness. Mahmud and Ray (2008) consider using Kolmogorov complexity measure
the effectiveness of transfer learning for decision tree methods.
Hard parameter sharing vs soft parameter sharing. The architecture that we study in this work
is also known as the hard parameter sharing architecture. There is another kind of architecture
called soft parameter sharing. The idea is that each task has its own parameters and modules. The
relationships between these parameters are regularized in order to encourage the parameters to be
similar. Other architectures that have been studied before include the work of Misra et al. (2016),
where the authors explore trainable architectures for convolutional neural networks.
Domain adaptation. Another closely related line of work is on domain adaptation. The acute
reader may notice the similarity between our study in Section 2.3 and domain adaptation. The cru-
cial difference here is that we are minimizing the multi-task learning objective, whereas in domain
adaptation the objective is typically to minimize the objective on the target task. See Ben-David
et al. (2010); Zhang et al. (2019b) and the references therein for other related work.
Optimization techniques. Guo et al. (2019) use ideas from the multi-armed bandit literature to de-
velop a method for weighting each task. Compared to their method, our SVD-based method is con-
ceptually simpler and requires much less computation. Kendall et al. (2018) derive a weighted loss
schme by maximizing a Gaussian likelihood function. Roughly speaking, each task is reweighted
by 1∕σ2 where σ is the standard deviation of the Gaussian and a penalty of log σ is added to the
loss. The values of {σi }i are also optimized during training. The exact details can be found in the
paper. The very recent work of Li and Vasconcelos (2019) show empirical results using a similar
idea of covariance normalization on imaging tasks for cross-domain transfer.
5	Conclusions and Future Work
We studied the theory of multi-task learning in linear and ReLU-activated settings. We verified our
theory and its practical implications through extensive synthetic and real world experiments.
Our work opens up many interesting future questions. First, could we extend the guarantees for
choosing optimization schemes to non-linear settings? Second, a limitation of our SVD-based op-
timization scheduler is that it only applies to settings with the same data. Could we extend the
method for heterogeneous task data? More broadly, we hope our work inspires further studies to
better understand multi-task learning in neural networks and to guide its practice.
Acknowledgements. Thanks to Sharon Y. Li and Avner May for stimulating discussions dur-
ing early stages of this work. We are grateful to the Stanford StatsML group and the anony-
mous referees for providing helpful comments that improve the quality of this work. We grate-
fully acknowledge the support of DARPA under Nos. FA87501720095 (D3M), FA86501827865
(SDH), and FA86501827882 (ASED); NIH under No. U54EB020405 (Mobilize), NSF under Nos.
CCF1763315 (Beyond Sparsity), CCF1563078 (Volume to Velocity), and 1937301 (RTML); ONR
under No. N000141712266 (Unifying Weak Supervision); the Moore Foundation, NXP, Xilinx,
LETI-CEA, Intel, IBM, Microsoft, NEC, Toshiba, TSMC, ARM, Hitachi, BASF, Accenture, Er-
icsson, Qualcomm, Analog Devices, the Okawa Foundation, American Family Insurance, Google
Cloud, Swiss Re, and members of the Stanford DAWN project: Teradata, Facebook, Google, Ant Fi-
nancial, NEC, VMWare, and Infosys. H. Zhang is supported in part by Gregory Valiant’s ONR YIP
award (#1704417). The experiments are partly run on Stanford’s SOAL cluster. 5 The U.S. Govern-
ment is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding
5https://5harad.com/soal-cluster/
10
Published as a conference paper at ICLR 2020
any copyright notation thereon. Any opinions, findings, and conclusions or recommendations ex-
pressed in this material are those of the authors and do not necessarily reflect the views, policies, or
endorsements, either expressed or implied, of DARPA, NIH, ONR, or the U.S. Government.
References
Hector Martlnez Alonso and Barbara Plank. When is multitask learning effective? semantic Se-
quence prediction under varying data conditions. arXiv preprint arXiv:1612.02251, 2016.
Rie Kubota Ando and Tong Zhang. A framework for learning predictive structures from multiple
tasks and unlabeled data. Journal of Machine Learning Research, 6(Nov):1817-1853, 2005.
Andreas Argyriou, Andreas Maurer, and Massimiliano Pontil. An algorithm for transfer learning in a
heterogeneous environment. In Joint European Conference on Machine Learning and Knowledge
Discovery in Databases, pages 71-85. Springer, 2008.
Maria-Florina Balcan, Yingyu Liang, David P Woodruff, and Hongyang Zhang. Matrix completion
and related problems via strong duality. In 9th Innovations in Theoretical Computer Science
Conference (ITCS 2018), 2018.
Peter L Bartlett, Philip M Long, Gabor Lugosi, and Alexander Tsigler. Benign ovefitting in linear
regression. Proceedings of the National Academy of Sciences, 2020.
Jonathan Baxter. A model of inductive bias learning. Journal of artificial intelligence research, 12:
149-198, 2000.
Mikhail Belkin, Daniel Hsu, Siyuan Ma, and Soumik Mandal. Reconciling modern machine-
learning practice and the classical bias-variance trade-off. Proceedings of the National Academy
of Sciences, 116(32):15849-15854, 2019.
Shai Ben-David and Reba Schuller. Exploiting task relatedness for multiple task learning. In Learn-
ing Theory and Kernel Machines, pages 567-580. Springer, 2003.
Shai Ben-David, John Blitzer, Koby Crammer, Alex Kulesza, Fernando Pereira, and Jennifer Wort-
man Vaughan. A theory of learning from different domains. Machine learning, 79(1-2):151-175,
2010.
Joachim Bingel and Anders S0gaard. Identifying beneficial task relations for multi-task learning in
deep neural networks. arXiv preprint arXiv:1702.08303, 2017.
John Blitzer, Ryan McDonald, and Fernando Pereira. Domain adaptation with structural correspon-
dence learning. In Proceedings of the 2006 conference on empirical methods in natural language
processing, pages 120-128. Association for Computational Linguistics, 2006.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep
bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.
Simon S Du, Jason D Lee, Yuandong Tian, Barnabas Poczos, and Aarti Singh. Gradient de-
scent learns one-hidden-layer cnn: Don’t be afraid of spurious local minima. arXiv preprint
arXiv:1712.00779, 2017.
Simon S Du, Wei Hu, Sham M Kakade, Jason D Lee, and Qi Lei. Few-shot learning via learning
the representation, provably. arXiv preprint arXiv:2002.09434, 2020.
Ehsan Elhamifar, Guillermo Sapiro, and S Shankar Sastry. Dissimilarity-based sparse subset selec-
tion. IEEE transactions on pattern analysis and machine intelligence, 38(11):2182-2197, 2015.
Theodoros Evgeniou and Massimiliano Pontil. Regularized multi-task learning. In Proceedings
of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining,
pages 109-117. ACM, 2004.
Basura Fernando, Amaury Habrard, Marc Sebban, and Tinne Tuytelaars. Unsupervised visual do-
main adaptation using subspace alignment. In Proceedings of the IEEE international conference
on computer vision, pages 2960-2967, 2013.
11
Published as a conference paper at ICLR 2020
Han Guo, Ramakanth Pasunuru, and Mohit Bansal. Autosem: Automatic task selection and mixing
in multi-task learning. arXiv preprint arXiv:1904.04153, 2019.
Trevor Hastie, Robert Tibshirani, Jerome Friedman, and James Franklin. The elements of statistical
learning: data mining, inference and prediction. The Mathematical Intelligencer, 27(2):83-85,
2005.
Minqing Hu and Bing Liu. Mining and summarizing customer reviews. In Proceedings of the
tenth ACM SIGKDD international conference on Knowledge discovery and data mining, pages
168-177. ACM, 2004.
Alex Kendall, Yarin Gal, and Roberto Cipolla. Multi-task learning using uncertainty to weigh losses
for scene geometry and semantics. In Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 7482-7491, 2018.
Mikhail Khodak, Maria-Florina Balcan, and Ameet Talwalkar. Provable guarantees for gradient-
based meta-learning. arXiv preprint arXiv:1902.10644, 2019.
Yoon Kim. Convolutional neural networks for sentence classification. arXiv preprint
arXiv:1408.5882, 2014.
Iasonas Kokkinos. Ubernet: Training a universal convolutional neural network for low-, mid-, and
high-level vision using diverse datasets and limited memory. In Proceedings of the IEEE Confer-
ence on Computer Vision and Pattern Recognition, pages 6129-6138, 2017.
Weihao Kong, Raghav Somani, Zhao Song, Sham Kakade, and Sewoong Oh. Meta-learning for
mixed linear regression. arXiv preprint arXiv:2002.08936, 2020.
Wouter M Kouw. An introduction to domain adaptation and transfer learning. arXiv preprint
arXiv:1812.11806, 2018.
Tao Lei, Yu Zhang, Sida I Wang, Hui Dai, and Yoav Artzi. Simple recurrent units for highly par-
allelizable recurrence. In Proceedings of the 2018 Conference on Empirical Methods in Natural
Language Processing, pages 4470-4481, 2018.
Xin Li and Dan Roth. Learning question classifiers. In Proceedings of the 19th international
conference on Computational linguistics-Volume 1, pages 1-7. Association for Computational
Linguistics, 2002.
Yuanzhi Li, Tengyu Ma, and Hongyang Zhang. Algorithmic regularization in over-parameterized
matrix sensing and neural networks with quadratic activations. In Conference On Learning The-
ory, pages 2-47, 2018.
Yunsheng Li and Nuno Vasconcelos. Efficient multi-domain learning by covariance normaliza-
tion. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages
5424-5433, 2019.
Xiaodong Liu, Pengcheng He, Weizhu Chen, and Jianfeng Gao. Multi-task deep neural networks
for natural language understanding. arXiv preprint arXiv:1901.11504, 2019a.
Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike
Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining
approach. arXiv preprint arXiv:1907.11692, 2019b.
MM Mahmud and Sylvian Ray. Transfer learning using kolmogorov complexity: Basic theory and
empirical evaluations. In Advances in neural information processing systems, pages 985-992,
2008.
Pasin Manurangsi and Daniel Reichman. The computational complexity of training relu (s). arXiv
preprint arXiv:1810.04207, 2018.
Andreas Maurer. Bounds for linear multi-task learning. Journal of Machine Learning Research, 7
(Jan):117-139, 2006.
12
Published as a conference paper at ICLR 2020
Bryan McCann, Nitish Shirish Keskar, Caiming Xiong, and Richard Socher. The natural language
decathlon: Multitask learning as question answering. arXiv preprint arXiv:1806.08730, 2018.
Charles A Micchelli and Massimiliano PontiL Kernels for multi-task learning. In Advances in
neural information processing systems, pages 921-928, 2005.
Mike Mintz, Steven Bills, Rion Snow, and Dan Jurafsky. Distant supervision for relation extraction
without labeled data. In Proceedings of the Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP:
Volume 2-Volume 2, pages 1003-1011. Association for Computational Linguistics, 2009.
Ishan Misra, Abhinav Shrivastava, Abhinav Gupta, and Martial Hebert. Cross-stitch networks for
multi-task learning. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, pages 3994-4003, 2016.
Guillaume Obozinski, Ben Taskar, and Michael I Jordan. Joint covariate selection and joint subspace
selection for multiple classification problems. Statistics and Computing, 20(2):231-252, 2010.
Sinno Jialin Pan and Qiang Yang. A survey on transfer learning. IEEE Transactions on knowledge
and data engineering, 22(10):1345-1359, 2009.
Bo Pang and Lillian Lee. A sentimental education: Sentiment analysis using subjectivity summa-
rization based on minimum cuts. In Proceedings of the 42nd annual meeting on Association for
Computational Linguistics, page 271. Association for Computational Linguistics, 2004.
Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization
with respect to rating scales. In Proceedings of the 43rd annual meeting on association for com-
putational linguistics, pages 115-124. Association for Computational Linguistics, 2005.
Anastasia Pentina and Shai Ben-David. Multi-task and lifelong learning of kernels. In International
Conference on Algorithmic Learning Theory, pages 194-208. Springer, 2015.
Anastasia Pentina and Christoph H Lampert. Multi-task learning with labeled and unlabeled tasks.
In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages
2807-2816. JMLR. org, 2017.
Anastasia Pentina, Viktoriia Sharmanska, and Christoph H Lampert. Curriculum learning of multi-
ple tasks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pages 5492-5500, 2015.
Pranav Rajpurkar, Jeremy Irvin, Kaylie Zhu, Brandon Yang, Hershel Mehta, Tony Duan, Daisy
Ding, Aarti Bagul, Curtis Langlotz, Katie Shpanskaya, et al. Chexnet: Radiologist-level pneumo-
nia detection on chest x-rays with deep learning. arXiv preprint arXiv:1711.05225, 2017.
Sebastian Ruder. An overview of multi-task learning in deep neural networks. arXiv preprint
arXiv:1706.05098, 2017.
Changjian Shui, Mahdieh Abbasi, LouiS-Emile Robitaille, BoyU Wang, and Christian Gagne.
A principled approach for learning task similarity in multitask learning. arXiv preprint
arXiv:1903.09109, 2019.
Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D Manning, Andrew Ng,
and Christopher Potts. Recursive deep models for semantic compositionality over a sentiment
treebank. In Proceedings of the 2013 conference on empirical methods in natural language pro-
cessing, pages 1631-1642, 2013.
Trevor Standley, Amir R Zamir, Dawn Chen, Leonidas Guibas, Jitendra Malik, and Silvio Savarese.
Which tasks should be learned together in multi-task learning? arXiv preprint arXiv:1905.07553,
2019.
Joel A Tropp et al. An introduction to matrix concentration inequalities. Foundations and TrendsR
in Machine Learning, 8(1-2):1-230, 2015.
13
Published as a conference paper at ICLR 2020
Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel Bowman. Glue:
A multi-task benchmark and analysis platform for natural language understanding. In Proceedings
of the 2018 EMNLP Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for
NLP, pages 353-355, 2018a.
Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R Bowman.
Glue: A multi-task benchmark and analysis platform for natural language understanding. arXiv
preprint arXiv:1804.07461, 2018b.
Xiaosong Wang, Yifan Peng, Le Lu, Zhiyong Lu, Mohammadhadi Bagheri, and Ronald M Sum-
mers. Chestx-ray8: Hospital-scale chest x-ray database and benchmarks on weakly-supervised
classification and localization of common thorax diseases. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 2097-2106, 2017.
Yu Wang, David Wipf, Qing Ling, Wei Chen, and Ian James Wassell. Multi-task learning for
subspace segmentation. 2015.
Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating expressions of opinions and emotions
in language. Language resources and evaluation, 39(2-3):165-210, 2005.
Ya Xue, Xuejun Liao, Lawrence Carin, and Balaji Krishnapuram. Multi-task learning for classifica-
tion with dirichlet process priors. Journal of Machine Learning Research, 8(Jan):35-63, 2007.
Amir R Zamir, Alexander Sax, William Shen, Leonidas J Guibas, Jitendra Malik, and Silvio
Savarese. Taskonomy: Disentangling task transfer learning. In Proceedings of the IEEE Con-
ference on Computer Vision and Pattern Recognition, pages 3712-3722, 2018.
Hongyang Zhang, Vatsal Sharan, Moses Charikar, and Yingyu Liang. Recovery guarantees for
quadratic tensors with limited observations. In International Conference on Artificial Intelligence
and Statistics (AISTATS), 2019a.
Yu Zhang and Qiang Yang. A survey on multi-task learning. arXiv preprint arXiv:1707.08114,
2017.
Yu Zhang and Dit-Yan Yeung. A regularization approach to learning task relationships in multitask
learning. ACM Transactions on Knowledge Discovery from Data (TKDD), 8(3):12, 2014.
Yuchen Zhang, Tianle Liu, Mingsheng Long, and Michael I Jordan. Bridging theory and algorithm
for domain adaptation. arXiv preprint arXiv:1904.05801, 2019b.
14
Published as a conference paper at ICLR 2020
A Missing Details of Section 2
We fill in the missing details left from Section 2. In Section A.1, we provide rigorous arguments
regarding the capacity of the shared module. In Section A.2, we fill in the details left from Section
2.3, including the proof of Theorem 2 and its extension to the ReLU model. In Section A.3, we
provide the proof of Proposition 3 on the task reweighting schemes. We first describe the notations.
Notations. We define the notations to be used later on. We denote f(x) . g(x) if there exists an
absolute constant C such that f(x) ≤ Cg(x). The big-O notation f(x) = O(g(x)) means that
f(x) . g(x).
Suppose A ∈ Rm×n, then λmax(A) denotes its largest singular value and λmin(A) denotes its
min{m, n}-th largest singular value. Alternatively, we have λmin(A) = minx:kxk=1 kAxk. Let
κ(A) = λmaχ(A)∕λmin(A) denote the condition number of A. Let Id denotes the identity matrix.
Let U * denote the Moore-Penrose pseudo-inverse of the matrix U. Let k ∙ k denote the Euclidean
norm for vectors and spectral norm for matrices. Let ∣∣∙∣∣f denote the Frobenius norm of a matrix.
Let hA, B, =i Tr(A>B) denote the inner product of two matrices.
The sine function is define as sin(u, V) =，1 - cos(u, v)2, where We assume that sin(u, V) ≥ 0
which is without loss of generality for our study.
A.1 Missing Details of Section 2.2
We describe the full detail to show that our model setup captures the phenomenon that the shared
module should be smaller than the sum of capacities of the single-task models. We state the fol-
lowing proposition which shows that the quality of the subspace B in equation 1 determines the
performance of multi-task learning. This supplements the result of Proposition 1.
Proposition 4. In the optimum of f (∙) (equation 1), each Ai Selects the vector V within the column
span of gB (Xi) to minimize L(V, yi). As a corollary, in the linear setting, the optimal B can be
achieved at a rotation matrix B? ⊆ Rd×r by maximizing
k
XhB(B>Xi>XiB)*B>,Xi>yiyi>Xii.	(7)
i=1
Furthermore, any B? which contains {θi}ik=1 in its column subspace is optimal. In particular, for
such a B?, there exists {Ai?} so that B?Ai? = θi for all 1 ≤ i ≤ k.
Proof. Recall the MTL objective in the linear setting from equation 3 as follows:
k
minf(A1,A2,...,Ak;B)=X(XiBAi-yi)2,
i=1
Note that the linear layer Ai can pick any combination within the subspace of B . Therefore, we
could assume without loss of generality that B is a rotation matrix. i.e. B>B = Id. After fixing B,
since objective f (∙) is linear in Ai for all i, by the local optimality condition, we obtain that
Ai = (B>Xi>XiB)*B>Xi>yi
Replacing the solution of Ai to f (∙),we obtain an objective over B.
k
h(B) =XkXiB(B>Xi>XiB)*B>Xi>yi-yik2F.
i=1
Next, note that
kXiB(B>Xi>XiB)*B>Xi>yik2F =Tr(yi>XiB(B>Xi>XiB)*B>Xi>yi)
= hB(B>Xi>XiB)B>,Xi>yiyi>Xii,
where we used the fact that A* AA* = A* forA = B>Xi>XiB in the first equation. Hence we have
shown equation 7.
15
Published as a conference paper at ICLR 2020
For the final claim, as long as B? contains {θi}ik=1 in its column subspace, then there exists Ai? such
that B?Ai? = θi . The B? and {Ai?}ik=1 are optimal solutions because each θi is an optimal solution
for the single-task problem.	□
The above result on linear regression suggests the intuition that optimizing an MTL model reduces
to optimizing over the span of B . The intuition can be easily extended to linear classification tasks
as well as mixtures of regression and classification tasks.
Extension to the ReLU setting. If the shared module’s capacity is larger than the total capacities
of the STL models, then we can put all the STL model parameters into the shared module. As in
the linear setting, the final output layer Ai can pick out the optimal parameter for the i-th task. This
remains an optimal solution to the MTL problem in the ReLU setting. Furthermore, there is no
transfer between any two tasks through the shared module.
A.2 Missing Details of Section 2.3
A.2.1 The Effect of Cosine Similarity
We consider the effect of varying the cosine similarity between single task models in multi-task
learning. We first describe the following proposition to solve the multi-task learning objective when
the covariances of the task data are the same. The idea is similar to the work of Ando and Zhang
(2005) and we adapt it here for our study.
Proposition 5. Consider the reweighted loss of equation 2 with the encoding function being linear,
where the weights are {αi}ik=1. Suppose the task features of every task have the same covariance:
Xi> Xi = Σ for all 1 ≤ i ≤ k. Let Σ = V DV > be the singular vector decomposition (SVD) of Σ.
Then the optimum of f (∙) in equation 3 is achieved at:
B? = V D-1/2C?,
where C?C?> is the best rank-r approximation subspace of Pik=1 αiUi>yiyi>Ui and Xi = UiDV >
is the SVD ofXi, for each 1 ≤ i ≤ k.
As a corollary, denote by λ1, λ2, . . . , λk as the singular values of D-1V > Pik=1 αiXi>yiyi>Xi in
decreasing order. Then the difference between an MTL model with hidden dimension r and the all
the single task models is bounded by Pik=r+1 λi2.
Proof. Note that B? is obtained by maximizing
k
XhB(B>Xi>XiB)-1B>,αiXi>yiyi>Xii
i=1
Let C = DV > B . Clearly, there is a one to one mapping between B and C . And we have B =
V D-1C. Hence the above is equivalent to maximizing over C ⊆ Rd×r with
kk
XhC(C>C)-1C>,D-1V> X αiXi>yiyi>Xi VD-1i
i=1	i=1
k
=hC(C>C)-1C>,XαiUi>yiyi>Uii.
i=1
Note that C(C>C)-1C> is a projection matrix onto a subspace of dimension r. Hence
the maximum (denote by C?) is attained at the best rank-r approximation subspace of
Pk=I αiU>yiy>Ui.	□
To illustrate the above proposition, consider a simple setting where Xi is identity for every 1 ≤
i ≤ k, and yi = ei , i.e. the i-th basis vector. Note that the optimal solution for the i-th task is
(Xi>Xi )-1 Xi>yi = yi . Hence the optimal solutions are orthogonal to each other for all the tasks,
with λi = 1 for all 1 ≤ i ≤ k. And the minimum STL error is zero for all tasks.
16
Published as a conference paper at ICLR 2020
Consider the MTL model with hidden dimension r. By Proposition 5, the minimum MTL error is
achieved by the best rank-r approximation subspace to Pik=1 Xi>yiyi>Xi = Pik=1 yiyi>. Denote
the optimum as Br? . The MTL error is:
kk
X kyik2 - hX yiyi>, Br?Br?>i = k - r.
i=1	i=1
Different data covariance. We provide upper bounds on the quality of MTL solutions for different
data covariance, which depend on the relatedness of all the tasks. The following procedure gives the
precise statement. Consider k regression tasks with data {(Xi, yi)}k=ι. Let θi = (X>Xi)*X>yi
denote the optimal solution of each regression task. Let W ⊆ Rd×k denote the matrix where the
i-th column is equal to θi . Consider the following procedure for orthogonalizing W for 1 ≤ i ≤ k.
a)	Let W? ∈ Rd denote the vector which maximizes Pk=Ih ∣∣XiBk, yi〉2 over B ∈ Rd;
b)	Denote by λj = Pj=Ih kχjwj*k ,yj i 2;
c)	For each 1 ≤ i ≤ k, project Xi Wi? off from every column of Xi . Go to Step a).
Proposition 6. Suppose that r ≤ d. Let B ? denote the optimal MTL solution of capacity r in
the shared module. Denote by OPT = Pk=I(Ilyik2 — kXi(X>Xi)*X>yik2). Then h(B?) ≤
OPT - Pid=r+1 λi.
Proof. It suffices to show that OPT is equal to Pik=1 λi. The result then follows since h(B?) is
less than the error given by W?,..., W?, which is equal to OPT — Pd=r+ι λ%.	□
A.2.2 Proof of Theorem 2
We fill in the proof of Theorem 2. First, we restate the result rigorously as follows.
Theorem 2. For i = 1, 2, let (Xi, yi) ∈ (Rmi×d, Rmi) denote two linear regression tasks with
parameters θi ∈ Rd. Suppose that each row of Xi is drawn independently from a distribution with
Covariance ∑ι ⊆ Rd×d and bounded 12-norm √L. Assume that θ>∑1θ1 = 1 w.l.o.g.
Let c ∈ [κ(X2) sin(θ1, θ2), 1/3] denote the desired error margin. Denote by (B?, A1?, A2?) the
optimal MTL solution. With probability 1 — δ over the randomness of (X1, y1), when
(L∑∑kl∖ log d κ(∑ι)κ2(X2)	2 κ2(∑ι)κ4(X2) 2 Λ
m1 & max( λmin(∑ι)，—C2— ky2k，—C4- % log δ),
we have that kB?A? — θ2Vkθ2k ≤ 6c + ι-13cl∣ε2IMIχ2θ2l∣.
We make several remarks to provide more insight on Theorem 2.
•	Theorem 2 guarantees positive transfers in MTL, when the source and target models are
close and the number of source samples is large. While the intuition is folklore in MTL, we
provide a formal justification in the linear and ReLU models to quantify the phenomenon.
•	The error bound decreases with c, hence the smaller c is the better. On the other hand, the
required number of data points m1 increases. Hence there is a trade-off between accuracy
and the amount of data.
•	c is assumed to be at most 1/3. This assumption arises when we deal with the label noise
of task 2. If there is no noise for task 2, then this assumption is not needed. If there is
noise for task 2, this assumption is satisfied when sin(θι,θ2) is less than 1∕(3κ(X2)). In
synthetic experiments, we observe that the dependence on κ(X2) and sin(θ1, θ2) both arise
in the performance of task 2, cf. Figure 3 and Figure 7, respectively.
The proof of Theorem 2 consists of two steps.
17
Published as a conference paper at ICLR 2020
a)	We show that the angle between B? and θ1 will be small. Once this is established, we get
a bound on the angle between B? and θ2 via the triangle inequality.
b)	We bound the distance between B?A2 and θ2. The distance consists of two parts. One part
comes from B?, i.e. the angle between B? and θ2 . The second part comes from A2, i.e.
the estimation error of the norm of θ2, which involves the signal to noise ratio of task two.
We first show the following geometric fact, which will be used later in the proof.
Fact 7. Let a, b ∈ Rd denote two unit vectors. Suppose that X ∈ Rm×d has full column rank with
condition number denoted by κ = κ(X). Then we have
∣sin(Xa, Xb) | ≥ ɪ ∣sin(a, b) |.
Proof. Let X = UDV > be the SVD of X. Since X has full column rank by assumption, we have
X>X = XX> = Id. Clearly, we have sin(X a, Xb) = sin(DV >a, DV >b). Denote by a0 = V >a
and b0 = V >b. We also have that a0 and b0 are both unit vectors, and sin(a0, b0) = sin(a, b). Let
λ1 , . . . , λd denote the singular values of X . Then,
sin2 (Da0, Db0) = 1 -
(Pd=ι λ2aibi)2
(Pd=I λ2ai2) (Pd=I λ2bi2)
Pι≤ij≤d λ2λ2(aibj - aj Ui))
(Pd=ι λ2ai2) (Pd=ι λ2bi2)
4
≥ λT^ ∙ X (aibj - ajbi)
max	1≤i,j≤d
dd	d
κ4((X ai2)(X bi2) -(X aibi)2) = κ4 sin2(a0,b0).
κ	i=1	i=1	i=1	κ
This concludes the proof.
□
We first show the following Lemma, which bounds the angle between B? and θ2.
Lemma 8. In the setting of Theorem 2, with probability 1 - δ over the randomness of task one, we
have that
|sin(B?/2)| ≤ sin(θ1,θ2) + c∕κ(X2).
Proof. Wenotethat h(B?) ≥ ∣∣y1∣∣2 by the optimality of B?. Furthermore, h 1皮看?八 ,y2 ≤ ∣∣y2∣∣2.
Hence we obtain that
hkXBk ,y1i2 ≥ky1k2 -ky2k2.
For the left hand side,
hkX：B?k, y1i2 = hkX：B?k, X1 θ1 + ε1i2
=h⅛¾ ,X1 θιi2 + h3 ,ειi2 +2h" ,χιθιih" ,ειi
Note that the second term is a chi-squared random variable with expectation σ12 . Hence it is
bounded
by σ2 Jlog 1
with probability at least 1 - δ.
Similarly, the third term is bounded by
2kχι θιkσι Jlog 1
with probability 1 -
δ . Therefore, we obtain the following:
kX1θ1k2 COS2(XiB?,Xiθι) ≥ ky1k2 -ky2k2
-(σ2 + 2σιkχιθιk)ylogδ^
18
Published as a conference paper at ICLR 2020
Note that
ky1k2 ≥ ∣∣χιθι∣∣2 + 2hxiθ1,ε1i
≥ kxiθ1k2 - 2kχιθιkσι jog δ .
Therefore,
kXιθιk2cos2(XιB*,Xιθι) ≥ kXιθ“∣2 - |妫『-(σ2 +3σJ∣Xιθιk)ʌ/lθgj
⇒Sin2(X B? Xθ ) ≤	ky2k2 + 4σ1g
⇒	(XIB ,X1θ1) ≤ W> + kXιθιk
⇒sin2(B*,θι) ≤ κ2(XI)(∣J-y2kp + 彳1/^^]	(byLemma7)
kX1θ1 k2	kX1θ1 k
By matrix Bemstein inequality (see e.g. TroPP et al. (2015)), when mi ≥ 10∣∣∑ι∣∣ log d/入言也(夕1),
we have that:
ɪ X>Xi — Σι
m1	1
≤ $ λmin (Σ1 ) .
Hence we obtain that κ2(X1) ≤ 3κ(∑ι) and ∣∣X1θ1k2 ≥ mi ∙ θ>∑ιθι∕2 ≥ mi/2 (where we
assumed that θ1>Σ1θ1 = 1). Therefore,
sin2(B?, θi) ≤ 3κ(Σi)
ky2k2 , 4σ1 /ɑgɪ
-------I-	
m2/4--√m1∕2
which is at most c2∕κ2(X2) by our setting of mi. Therefore, the conclusion follows by triangle
inequality (noting that both C and sin(θi, θ2) are less than 1/2).	□
Based on the above Lemma, we are now to ready to Prove Theorem 2.
Proof of Theorem 2. Note that in the MTL model, after obtaining B?, we then solve the linear layer
for each task. For task 2, this gives weight value A? := hX2θ,y2)/kX2θk2. Thus the regression
coefficients for task 2 is B?A2?. For the rest of the Proof, we focus on bounding the distance between
B?A2? and θ2 . By triangle inequality,
kB?A? - θ2k ≤ lhχg⅛il + NBX2θ2i -kθ2k∣ + kB*kθ2k- θ2k .	(8)
Note that the second term of equation 8 is equal to
|"2"XXθB-I甸®" ≤ κ(X2) ∙kθ2 -kθ2kB*k∙
The first term of equation 8 is bounded by
kε2k	≤	kε2kkθ2k	(9)
kX2B*k - kX2θ2k-kX2(θ2 --Θ2-B?)-.	( )
Lastly, we have that
kθ2 — kθ2kB*k2 = kθ2k22(1 — Cos(B*,θ2)) ≤ 2kθ2k2 sin2(B*,θ2)
By Lemma 8, we have
∣sin(B?,θ2)∣ ≤ sin(θ1,θ2) + c/K(X2)
19
Published as a conference paper at ICLR 2020
Therefore, we conclude that equation 9 is at most
_______________________kε2k∙kθ2k______________________
kX2θ2k - √2λmaχ(X2)kθ2k Sin(θ1,θ2) - √2cλmin(X2)kθ2 k
≤	kε2∣H∣θ2k
≤kX2θ2k — 3cλmin(X2)kθ2 k
≤ɪ kε2∣H∣θ2 k
≤ 1 - 3c kX2θ2k
Thus equation 8 is at most the following.
kθ2 k∙ (i⅛ ⅛O + √2(K(X2) + I) ∙ Sin(BS)
≤kθ2k∙ (ɪ需备 +6c).
1 - 3c kX2θ2 k
Hence We obtain the desired estimation error of BA?.	□
A.2.3 Extension to The ReLU Model
In this part, We extend Theorem 2 to the ReLU model. Note that the problem is reduced to the
folloWing objective.
max g(B)
B∈Rd
h ReLU(XIB)	∖2 + h ReLU(X2B)	、?
h IIReLU(X1B)k ,y1i + h IIReLU(X2B)k, y2i
(10)
We make a crucial assumption that task 1’s input X1 folloWs the Gaussian distribution. Note that
making distributional assumptions is necessary because for Worst-case inputs, even optimizing a
single ReLU function under the squared loss is NP-hard (Manurangsi and Reichman (2018)). We
state our result formally as folloWs.
Theorem 9. Let (X1, y1) ∈ (Rm1 ×d, Rm1 ) and (X2, y2) ∈ (Rm2×d, Rm2 ) denote two
tasks. Suppose that each row of X1 is drawn from the standard Gaussian distribution. And
yi = ai ∙ ReLU(Xiθi) + εi are generated via the ReLU model with θ1, θ2 ∈ Rd. Let
E (ai ∙ ReLU(Xiθi))j2 = 1 for every 1 ≤ j ≤ m1 without loss of generality, and let σ12 denote the
variance of every entry of ε1.
Suppose that C ≥ sin(θι, θ2)∕κ(X2). Denote by (B?, A?, A?) the optimal MTL solution ofequa-
tion 10. With probability 1 - δ over the randomness of (X1, y1), when
m1 & max
ky2k2
we have that the estimation error is at most:
sin(B?, θ1) ≤ sin(θ1, θ2) + O(c∕κ(X2)),
|A2 - a2| ≤ O(c) ,____1	_______kε2k______
-02- - D (1 —O(C)) ■ a2 ∙ ReLU(kX2θ2k)
Proof. The proof folloWs a similar structure to that of Theorem 2. Without loss of generality, We
can assume that θ1, θ2 are both unit vectors. We first bound the angle betWeen B? and θ1.
By the optimality of B?, We have that:
h ReLU(XIB?)	i2 ≥ h ReLU(XIθι)	i2 _k k2
(kReLU(X1B*)k,y1> 一 ,∣∣ReLU(X1 θ1)k'y1>	"y2”
From this We obtain:
2	ReLU(X1B?)
a1 ∙ h∣∣ReLU(XιB*)k,
ReLU(X1B?)i2

≥a12 ∙ kReLU(X1θ1)k2 - ky2k2 -(σ12+4a1 ∙σ1kReLU(X1θ1)k)
(11)
20
Published as a conference paper at ICLR 2020
Note that each entry of ReLU(X1θ1) is a truncated Gaussian random variable. By the Hoeffding
bound, with probability 1 - δ we have
kReLU(X1θ1)k2 -
log1.
As for hReLU(X1B?), ReLU(X1θ1)i, we will use an epsilon-net argument over B? to show the
concentration. For a fixed B? , we note that this is a sum of independent random variables that are
all bounded within O (log 等)With probability 1 - δ. Denote by φ the angle between B? and θι,
a standard geometric fact states that (see e.g. Lemma 1 of Du et al. (2017)) for a random Gaussian
vector x ∈ Rd,
E [ReLU(x>B?) ∙ ReLU(X>&)]=学 + CoS φ呼 φ -6：=粤.
x	2	2π	2
Therefore, by applying Bernstein’s inequality and union bound, with probability 1 - η we have:
KReLU(XιB?), ReLU(X心)〉-mig(φ)∕2∣ ≤ 2
"i g(φ) log 1
,21	1 1 mi
+3log η log 万
By standard arguments, there exists a set of dO(d) unit vectors S such that for any other unit vector
U there exists U ∈ S such that ku - Uk ≤ min(1∕d3, c2∕κ2(X2)). By setting η = d-O(d) and
take union bound over all unit vectors in S, we have that there exists U ∈ S satisfying ∣∣B? - Uk ≤
min(1∕d3, c2 ∕κ2 (X2)) and the following:
KReLU(XiU), ReLU(X1θ1)i — mιg(φ0)∕2∣ . P mid log d + d log2 d
≤ 2mic2∕κ2(X2)	(by our setting of mi)
where φ0 is the angle between U and θi. Note that
∣hReLU(X1θ) - ReLU(XiB?), ReLU(X心))| ≤ ∣∣X1(U - B*)∣∣∙ ||ReLU(X$i)k
≤ c2∕κ2(X2) ∙ O(mi)
Together we have shown that
KReLU(XiB?), ReLU(Xiθi)i - mig(φ0)∕2∣ ≤ c2∕κ2(X2) ∙ O(mi).
Combined with equation 11, by our setting of mi , it is not hard to show that
g(φ0) ≥ 1 - O(c2∕κ2(X2)).
Note that
1 - g(φ ) = 1 - CoS φ - CoS φ (tan φ - φ )
≤ 1 - Cosφ0 = 2sin2 φ . c2∕κ2(X2),
which implies that sin2 φ0 . c2∕κ2(X2) (since cosΦ2- ≥ 0.9). Finally note that ∣∣U — B?k ≤
c2∕κ2 (X2 ), hence
kU - B?k2 = 2(1 - cos(U, B?)) ≥ 2sin2(U, B?).
Overall, we conclude that sin(B?, θi) ≤ O(c∕κ(X2)). Hence
sin(B?, θ2) ≤ sin(θi,θ2) + O(c∕κ(X2)).
For the estimation of a2, we have
hReLU(X2B*),y2> _	KReLU(X2B?),£2〉|
kReLU(X2B?)k2 - a2 ≤ kReLU(X2B?)k2
hReLU(X2B?), ReLU(X2B?) - ReLU(X2θ2)i
+a2	∣∣ReLU(X2B*)k2
The first part is at most
kε2 k ≤_________________________M_______________________
∣∣ReLU(X2B*)k — ∣∣ReLU(X2θ2)k - kReLU(X2θ2) - ReLU(X2B?)k
≤	1	kε2k
≤ 1 -O(C) kReLU(X2θ2)k
Similarly, we can show that the second part is at most O(c). Therefore, the proof is complete. □
21
Published as a conference paper at ICLR 2020
A.3 Proof of Proposition 3
In this part, we present the proof of Proposition 3. In fact, we present a more refined result, by
showing that all local minima are global minima for the reweighted loss in the linear case.
k
f(A1, A2, . . . , Ak; B) = X αi kXiBAi - yi)k2F .	(12)
i=1
The key is to reduce the MTL objective f (∙) to low rank matrix approximation, and apply recent
results by Balcan et al. (2018) which show that there is no spurious local minima for the latter
problem .
Lemma 10. Assume that Xi> Xi = αiΣ with αi > 0 for all 1 ≤ i ≤ k. Then all the local minima
of f(A1 , . . . , Ak; B) are global minima of equation 3.
Proof. We first transform the problem from the space of B to the space of C . Note that this is
without loss of generality, since there is a one to one mapping between B and C with C = DV >B.
In this case, the corresponding objective becomes the following.
k
g(A1, ... ,Ak; B) = ^X αi ∙ kUiCAi- yik2
i=1
kk
=X kC(√α-Ai) - √0-U>yik2 + Xαi ∙ (kyik2 -kU>yik2)
i=1	i=1
The latter expression is a constant. Hence it does not affect the optimization solution. For the
former, denote by A ∈ Rr×k as stacking the √α-A-'s together column-wise. Similarly, denote by
Z ∈ Rd×k as stacking √O-U>y- together column-wise. Then minimizing g(∙) reduces solving low
rank matrix approximation: kCA - Z k2F .
By Lemma 3.1 of Balcan et al. (2018), the only local minima of kCA - Zk2 are the ones where
CA is equal to the best rank-r approximation of Z. Hence the proof is complete.	□
Now we are ready to prove Proposition 3.
Proof of Proposition 3. By Proposition 5, the optimal solution of B? for equation 12 is V D-1
times the best rank-r approximation to α-U> y-y-> U, where we denote the SVD of X as UDV> .
Denote by Qr Qr> as the best rank-r approximation to U> ZZ> U, where we denote by Z =
[√0ιyι, √02y2,..., ^√0kyk] as stacking the k vectors to a d by k matrix. Hence the result of
Proposition 5 shows that the optimal solution B? is V D-1Qr, which is equal to (X>X)-1XQr.
By Proposition 4, the optimality ofB? is the same up to transformations on the column space. Hence
the proof is complete.	□
To show that all local minima are also equal to (X>X)-1XQr, we can simply apply Lemma 10
and Proposition 3.
Remark. This result only applies to the linear model and does not work on ReLU models. The ques-
tion of characterizing the optimization landscape in non-linear ReLU models is not well-understood
based on the current theoretical understanding of neural networks. We leave this for future work.
22
Published as a conference paper at ICLR 2020
B S upplementary Experimental Results
We fill in the details left from our experimental section. In Appendix B.1, we review the datasets
used in our experiments. In Appendix B.2, we describe the models we use on each dataset. In
Appendix B.3, we describe the training procedures for all experiments. In Appendix B.4 and Ap-
pendix B.5, we show extended synthetic and real world experiments to support our claims.
B.1	Datasets
We describe the synthetic settings and the datasets Sentiment Analysis, General Language Under-
standing Evaluation (GLUE) benchmark, and ChestX-ray14 used in the experiments.
Synthetic settings. For the synthetic experiments, we draw 10,000 random data samples with di-
mension d = 100 from the standard Gaussian N(0, 1) and calculate the corresponding labels based
on the model described in experiment. We split the data samples into training and validation sets
with 9,000 and 1,000 samples in each. For classification tasks, we generate the labels by applying
a sigmoid function and then thresholding the value to binary labels at 0.5. For ReLU regression
tasks, we apply the ReLU activation function on the real-valued labels. The number of data samples
used in the experiments varies depending on the specification. Specifically, for the task covariance
experiment of Figure 3, we fix task 1’s data with m1 = 9, 000 training data and vary task 2’s data
under three settings: (i) same rotation Q1 = Q2 but different singular values D1 6= D2 ; (ii) same
singular values D1 = D2 but random rotations Q1 6= Q2 .
Sentiment analysis. For the sentiment analysis task, the goal is to understand the sentiment opinions
expressed in the text based on the context provided. This is a popular text classification task which
is usually formulated as a multi-label classification task over different ratings such as positive (+1),
negative (-1), or neutral (0). We use six sentiment analysis benchmarks in our experiments:
•	Movie review sentiment (MR): In the MR dataset (Pang and Lee (2005)), each movie re-
view consists of a single sentence. The goal is to detect positive vs. negative reviews.
•	Sentence subjectivity (SUBJ): The SUBJ dataset is proposed in Pang and Lee (2004) and
the goal is to classify whether a given sentence is subjective or objective.
•	Customer reviews polarity (CR): The CR dataset (Hu and Liu (2004)) provides customer
reviews of various products. The goal is to categorize positive and negative reviews.
•	Question type (TREC): The TREC dataset is collected by Li and Roth (2002). The aim is
to classify a question into 6 question types.
•	Opinion polarity (MPQA): The MPQA dataset detects whether an opinion is polarized or
not (Wiebe et al. (2005)).
•	Stanford sentiment treebank (SST): The SST dataset, created by Socher et al. (2013), is an
extension of the MR dataset.
The General Language Understanding Evaluation (GLUE) benchmark. GLUE is a collection
of NLP tasks including question answering, sentiment analysis, text similarity and textual entail-
ment problems. The GLUE benchmark is a state-of-the-art MTL benchmark for both academia and
industry. We select five representative tasks including CoLA, MRPC, QNLI, RTE, and SST-2 to
validate our proposed method. We emphasize that the goal of this work is not to come up with a
state-of-the-art result but rather to provide insights into the working of multi-task learning. It is
conceivable that our results can be extended to the entire dataset as well. This is left for future work.
More details about the GLUE benchmark can be found in the original paper (Wang et al. (2018a)).
ChestX-ray14. The ChestX-ray14 dataset (Wang et al. (2017)) is the largest publicly available
chest X-ray dataset. It contains 112,120 frontal-view X-ray images of 30,805 unique patients. Each
image contains up to 14 different thoracic pathology labels using automatic extraction methods on
radiology reports. This can be formulated as a 14-task multi-label image classification problem.
The ChestX-ray14 dataset is a representative dataset in the medical imaging domain as well as in
computer vision. We use this dataset to examine our proposed task reweighting scheme since it
satisfies the assumption that all tasks have the same input data but different labels.
23
Published as a conference paper at ICLR 2020
B.2	Models
Synthetic settings. For the synthetic experiments, we use the linear regression model, the logistic
regression model and a one-layer neural network with the ReLU activation function.
Sentiment analysis. For the sentiment analysis experiments, we consider three different models
including multi-layer perceptron (MLP), LSTM, CNN:
•	For the MLP model, we average the word embeddings of a sentence and feed the result into
a two layer perceptron, followed by a classification layer.
•	For the LSTM model, we use the standard one-layer single direction LSTM as proposed
by Lei et al. (2018), followed by a classification layer.
•	For the CNN model, we use the model proposed by Kim (2014) which uses one convolu-
tional layer with multiple filters, followed by a ReLU layer, max-pooling layer, and classi-
fication layer. We follow the protocol of Kim (2014) and set the filter size as {3, 4, 5}.
We use the pre-trained GLoVe embeddings trained on Wikipedia 2014 and Gigaword 5 corpora 6.
We fine-tune the entire model in our experiments. In the multi-task learning setting, the shared
modules include the embedding layer and the feature extraction layer (i.e. the MLP, LSTM, or CNN
model). Each task has its separate output module.
GLUE. For the experiments on the GLUE benchmark, we use a state-of-the-art language model
called BERT (Devlin et al. (2018)). For each task, we add a classification/regression layer on top it
as our model. For all the experiments, we use the BERTLARGE uncased model, which is a 24 layer
network as described in Devlin et al. (2018). For the multi-task learning setting, we follow the work
of Liu et al. (2019a) and use BERTLARGE as the shared module.
ChestX-ray14. For the experiments on the ChestX-ray14 dataset, we use the DenseNet model
proposed by Rajpurkar et al. (2017) as the shared module, which is a 121 layer network. For each
task, we use a separate classification output layer. We use the pre-trained model7 in our experiments.
B.3	Training Procedures
In this subsection, we describe the training procedures for our experiments.
Mini-batch SGD. We describe the details of task data sampling in our SGD implementation.
•	For tasks with different features such as GLUE, we first divide each task data into small
batches. Then, we mix all the batches from all tasks and shuffle randomly. During every
epoch, a SGD step is applied on every batch over the corresponding task. If the current
batch is for task i, then the SGD is applied on Ai , and possibly Ri or B depending on the
setup. The other parameters for other tasks are fixed.
•	For tasks with the same features such as ChestX-ray14, the SGD is applied on all the tasks
jointly to update all the Ai ’s and B together.
Synthetic settings. For the synthetic experiments, we do a grid search over the learning rate from
{1e - 4, 1e - 3, 1e - 2, 1e - 1} and the number of epochs from {10, 20, 30, 40, 50}. We pick the
best results for all the experiments. We choose the learning rate to be 1e - 3, the number of epochs
to be 30, and the batch size to be 50. For regression task, we report the Spearman’s correlation score
For classification task, we report the classification accuracy.
Sentiment analysis. For the sentiment analysis experiments, we randomly split the data into train-
ing, dev and test sets with percentages 80%, 10%, and 10% respectively. We follow the protocol
of Lei et al. (2018) to set up our model for the sentiment analysis experiments.
The default hidden dimension of the model (e.g. LSTM) is set to be 200, but we vary this parameter
for the model capacity experiments. We report the accuracy score on the test set as the performance
metric.
6http://nlp.stanford.edu/data/wordvecs/glove.6B.zip
7https://github.com/pytorch/vision
24
Published as a conference paper at ICLR 2020
一- - - - - 一O
024
..
-0 -0
)noitalerroc namraepS(
LTS revo ecnamrofrep LTM
Cosine distance between tasks
LTS revo ecnamrofrep LTM
(A0aJΠ8s
Cosine distance between tasks
(UOW。。UBE」B①ds)
LTS revo ecnamrofrep LT
(b) Logistic classification tasks
IlS 括Ao 8UBE」0七①d IiW
50
0.0
)ycaruccA
Cosine distance between tasks	Cosine distance between tasks
(c) Regression tasks with ReLU non-linearity	(d) Classification tasks with ReLU non-linearity
Figure 7: Comparing MTL model performance over different task similarity. For (a) and (c), MTL
trains two regression tasks; For (b) and (d), MTL trains two classification tasks. For regression
tasks, we use spearman correlation as model performance indicator. For classification tasks, we
use accuracy as the metric. We report the average model performance over two tasks. The x-axis
denotes the cosine distance, i.e. 1 - cos(θ1 , θ2).
GLUE. For the GLUE experiments, the training procedure is used on the alignment modules and
the output modules. Due to the complexity of the BERTLARGE module, which involves 24 layers of
non-linear transformations.
We fix the BERTLARGE module during the training process to examine the effect of adding the
alignment modules to the training process. In general, even after fine-tuning the BERTLARGE module
on a set of tasks, it is always possible to add our alignment modules and apply Algorithm 1.
For the training parameters, we apply grid search to tune the learning rate from {2e-5, 3e-5, 1e-5}
and the number of epochs from {2, 3, 5, 10}. We choose the learning rate to be 2e-5, the number
of epochs to be 5, and with batch size 16 for all the experiments.
We use the GLUE evaluation metric (cf. Wang et al. (2018b)) and report the scores on the develop-
ment set as the performance metric.
ChestX-ray14. For the ChestX-ray14 experiments, we use the configuration suggested by Rajpurkar
et al. (2017) and report the AUC score on the test set after fine-tuning the model for 20 epochs.
B.4	Extended Synthetic Experiments
Varying cosine similarity on linear and ReLU models. We demonstrate the effect of cosine simi-
larity in synthetic settings for both regression and classification tasks.
Synthetic tasks. We start with linear settings. We generate 20 synthetic task datasets (either for
regression tasks, or classification tasks) based on data generation procedure and vary the task simi-
larity between task 1 and task i. We run the experiment with a different dataset pairs (dataset 1 and
dataset i).
25
Published as a conference paper at ICLR 2020
① ɔu(OIWot① J
-0.2
Sim. 0.9	Sim. 0.5	Sim. 0.1
Sim. 0.7	Sim. 0.3
.2 0
0.
stnemevorpm
2000 4000 6000 8000
# Data size
stnemevorpmI ecnamrofre
Sim. 0.9	Sim. 0.5	Sim. 0.1
Sim. 0.7	Sim. 0.3
0.1
0
-0.1
-0.2
2000 4000 6000 8000
# Data size
(a)	Regression tasks with non-linearity
(b)	Classification tasks with non-linearity
Figure 8:	The performance improvement on the target task (MTL minus STL) by varying the cosine
similarity of the two tasks’ STL models. We observe that higher similarity between the STL models
leads to better improvement on the target task.
11ω—工- ⅞∩- S-XSqlBoel
0.2-
0.1
0 -
-0.1
-0.2
Positive Transfer
■ Baseline
■ Algorithm 1
Negative Transfer
11ω—工- ⅞∩- S-XSqlBoel
0.2
2000 4000 6000 8000
-0.2
0.
-0.1
Positive Transfer
■ Baseline
■ Algorithm 1
Negative Transfer
2000 4000 6000 8000
# Data samples of source task
# Data samples of source task
0.15
(a) Linear regression tasks	(b) Regression tasks with ReLU activation
Figure 9:	Comparing Algorithm 1 to the baseline MTL training on the synthetic example in Section
2.3. Algorithm 1 corrects the negative transfer phenomenon observed in Figure 3.
After generating the tasks, we compare the performance gap between MTL and STL model.
Results. From Figure 7a and Figure 7a, we find that for both regression and classification settings,
with the larger task similarity the MTL outperforms more than STL model and the negative transfer
could occur if the task similarity is too small.
ReLU settings. We also consider a ReLU-activated model. We use the same setup as the linear
setting, but apply a ReLU activation to generate the data. Similar results are shown in Figure 7c, 7d.
Higher rank regimes for ReLU settings. We provide further validation of our results on ReLU-
activated models.
Synthetic tasks. In this synthetic experiment, there are two sets of model parameters Θ1 ⊆ Rd×r and
Θ2 ⊆ Rd×r (d = 100 and r = 10). Θ1 is a fixed random rotation matrix and there are m1 = 100
data points for task 1. Task 2’s model parameter is Θ2 = αΘ1 + (1 - α)Θ0, where Θ0 is also a fixed
rotation matrix that is orthogonal to Θ1. Note that α is the cosine value/similarity of the principal
angle between Θ1 and Θ2 .
We then generate X1 ⊆ Rm1×d and X2 ⊆ Rm2×d from Gaussian. For each task, the labels are
yi = ReLU(XiΘi)e + εi, where e ∈ Rr is the all ones vector and εi is a random Gaussian noise.
Given the two tasks, we use MTL with ReLU activations and capacity H = 10 to co-train the two
tasks. The goal is to see how different levels of α or similarity affects the transfer from task two to
task one. Note that this setting parallels the ReLU setting of Theorem 9 but applies to rank r = 5.
26
Published as a conference paper at ICLR 2020
A
0.8
n
o
o
<
0.7 d
0.6
MTL-Avg. peak
0.9
LSTM
MTL-Avg.
■ STL-SST
■ STL-MR
■ STL-CR
■ STL-SUBJ
■ Stl-mpqa
■ STL-TREC
0	100	200	300	400	500

Model capacity
Figure 10:	Cross validation to choose the best performing model capacity for each model.
o 0.85-
2	-
8	、
N	；
0.80-
0.90
. peak
STL-SSTPeak !
MTL-Avg
STL-SST
STL-MR
AO& ⊃00<
广田“STL-MR peak
CNN
MTL-Avg. peak ■ MTL-AVg.
■ STL-SST
STL-SSTpeak
STL-MR peak
■ STL-MR
LSTM
500
Model capacity
1000
0.90
0.85
0.80
0.75
0	100 200 300 400	500
Model capacity

0
Figure 11:	Validation on MLP, CNN and LSTM models for sentiment analysis tasks.
Results. In Figure 8 we show that the data size, the cosine similarity between the STL solutions and
the alignment of covariances continue to affect the rate of transfer in the new settings. The study
shows that our conceptual results are applicable to a wide range of settings.
Evaluating Algorithm 1 on linear and ReLU-activated models. We consider the synthetic ex-
ample in Section 2.3 to compare Algorithm 1 and the baseline MTL training. Recall that in the
example, when the source and target tasks have different covariance matrices, MTL causes negative
transfer on the target task. Our hypothesis in this experiment is to show that Algorithm 1 can correct
the misalignment and the negative transfer.
Synthetic tasks. We evaluate on both linear and ReLU regression tasks. The linear case follows the
example in Section 2.3. For the ReLU case, the data is generated according to the previous example.
Results. Figure 9 confirms the hypothesis. We observe that Algorithm 1 corrects the negative transfer
in the regime where the source task only has limited amount of data. Furthermore, Algorithm 1
matches the baseline MTL training when the source task has sufficiently many data points.
B.5 Extended Ablation Studies
Cross validation for choosing model capacities. We provide a cross validation experiment to
indicate how we choose the best performing model capacities in Figure 1. This is done on the six
sentiment analysis tasks trained with an LSTM layer.
In Figure 10, we vary the model capacities to plot the validation accuracies of the MTL model trained
with all six tasks and the STL model for each task. The result complements Table 1 in Section 3.3.
Choosing model capacities for CNN and MLP. Next we verify our result on model capacities for
CNN and MLP models. We select the SST and MR datasets from the sentiment analysis tasks for
this experiment. We train all three models CNN, MLP and LSTM by varying the capacities.
Results. From Figure 11 we observe that the best performing MTL model capacity is less than total
best performing model capacities of STL model on all models.
27
Published as a conference paper at ICLR 2020
The effect of label noise on Algorithm 2. To evaluate the robustness of Algorithm 2 in the presence
of label noise, we conduct the following experiment. First, we subsample 10% of the ChestX-ray14
dataset and select two tasks from it. Then, we randomly pick one task to add 20% of noise to its
labels by randomly flipping them with probability 0.5. We compare the performance of training both
tasks using our reweighting scheme (Algorithm 2) vs. the reweighting techniques of Kendall et al.
(2018) and the unweighted loss scheme.
Results. On 10 randomly chosen task pairs, our method improves over the unweighted training
scheme by 1.0% AUC score and 0.4% AUC score over Kendall et al. (2018) averaged over the 10
task pairs. Figure 12 shows 5 example task pairs from our evaluation.
ecnamrofrep LT
■ Unweighted loss ■ Kendall et al. ■ Algorithm 2
0.7
0.6
0.5
0.4 -
Consolidation Consolidation Consolidation	Edema Fibrosis
Cardiomegaly Edema	Infiltration	Atelectasis	Consolidation
Figure 12:	Comparing Algorithm 2 to the unweighted scheme and Kendall et al. (2018).
28