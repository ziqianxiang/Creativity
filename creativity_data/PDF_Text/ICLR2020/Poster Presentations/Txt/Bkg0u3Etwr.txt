Published as a conference paper at ICLR 2020
Maxmin	Q-learning:	Controlling	the
Estimation Bias of Q-learning
Qingfeng Lan, Yangchen Pan, Alona Fyshe, Martha White
Department of Computing Science
University of Alberta
Edmonton, Alberta, Canada
{qlan3,pan6,alona,whitem}@ualberta.ca
Ab stract
Q-learning suffers from overestimation bias, because it approximates the
maximum action value using the maximum estimated action value. Algorithms
have been proposed to reduce overestimation bias, but we lack an understanding of
how bias interacts with performance, and the extent to which existing algorithms
mitigate bias. In this paper, we 1) highlight that the effect of overestimation bias
on learning efficiency is environment-dependent; 2) propose a generalization of
Q-learning, called Maxmin Q-learning, which provides a parameter to flexibly
control bias; 3) show theoretically that there exists a parameter choice for Maxmin
Q-learning that leads to unbiased estimation with a lower approximation variance
than Q-learning; and 4) prove the convergence of our algorithm in the tabular
case, as well as convergence of several previous Q-learning variants, using a novel
Generalized Q-learning framework. We empirically verify that our algorithm
better controls estimation bias in toy environments, and that it achieves superior
performance on several benchmark problems. 1
1	Introduction
Q-learning (Watkins, 1989) is one of the most popular reinforcement learning algorithms. One of the
reasons for this widespread adoption is the simplicity of the update. On each step, the agent updates
its action value estimates towards the observed reward and the estimated value of the maximal action
in the next state. This target represents the highest value the agent thinks it could obtain from the
current state and action, given the observed reward.
Unfortunately, this simple update rule has been shown to suffer from overestimation bias (Thrun &
Schwartz, 1993; van Hasselt, 2010). The agent updates with the maximum over action values might
be large because an action’s value actually is high, or it can be misleadingly high simply because
of the stochasticity or errors in the estimator. With many actions, there is a higher probability that
one of the estimates is large simply due to stochasticity and the agent will overestimate the value.
This issue is particularly problematic under function approximation, and can significant impede the
quality of the learned policy (ThrUn & Schwartz, 1993; Szita & LOrincz, 2008; Strehl et al., 2009)
or even lead to failures of Q-learning (Thrun & Schwartz, 1993). More recently, experiments across
several domains suggest that this overestimation problem is common (Hado van Hasselt et al., 2016).
Double Q-learning (van Hasselt, 2010) is introduced to instead ensure underestimation bias. The
idea is to maintain two unbiased independent estimators of the action values. The expected action
value of estimator one is selected for the maximal action from estimator two, which is guaranteed not
to overestimate the true maximum action value. Double DQN (Hado van Hasselt et al., 2016), the
extension of this idea to Q-learning with neural networks, has been shown to significantly improve
performance over Q-learning. However, this is not a complete answer to this problem, because
trading overestimation bias for underestimation bias is not always desirable, as we show in our
experiments.
1Code is available at https://github.com/qlan3/Explorer
1
Published as a conference paper at ICLR 2020
Several other methods have been introduced to reduce overestimation bias, without fully moving
towards underestimation. Weighted Double Q-learning (Zhang et al., 2017) uses a weighted
combination of the Double Q-learning estimate, which likely has underestimation bias, and the
Q-learning estimate, which likely has overestimation bias. Bias-corrected Q-Learning (Lee et al.,
2013) reduces the overestimation bias through a bias correction term. Ensemble Q-learning and
Averaged Q-learning (Anschel et al., 2017) take averages of multiple action values, to both reduce
the overestimation bias and the estimation variance. However, with a finite number of action-
value functions, the average operation in these two algorithms will never completely remove the
overestimation bias, as the average of several overestimation biases is always positive. Further,
these strategies do not guide how strongly we should correct for overestimation bias, nor how to
determine—or control—the level of bias.
The overestimation bias also appears in the actor-critic setting (Fujimoto et al., 2018; Haarnoja
et al., 2018). For example, Fujimoto et al. (2018) propose the Twin Delayed Deep Deterministic
policy gradient algorithm (TD3) which reduces the overestimation bias by taking the minimum
value between two critics. However, they do not provide a rigorous theoretical analysis for the effect
of applying the minimum operator. There is also no theoretical guide for choosing the number of
estimators such that the overestimation bias can be reduced to 0.
In this paper, we study the effects of overestimation and underestimation bias on learning
performance, and use them to motivate a generalization of Q-learning called Maxmin Q-learning.
Maxmin Q-learning directly mitigates the overestimation bias by using a minimization over multiple
action-value estimates. Moreover, it is able to control the estimation bias varying from positive
to negative which helps improve learning efficiency as we will show in next sections. We prove
that, theoretically, with an appropriate number of action-value estimators, we are able to acquire an
unbiased estimator with a lower approximation variance than Q-learning. We empirically verify our
claims on several benchmarks. We study the convergence properties of our algorithm within a novel
Generalized Q-learning framework, which is suitable for studying several of the recently proposed
Q-learning variants. We also combine deep neural networks with Maxmin Q-learning (Maxmin
DQN) and demonstrate its effectiveness in several benchmark domains.
2	Problem Setting
We formalize the problem as a Markov Decision Process (MDP), (S, A, P, r, γ), where S is the state
space, Ais the action space, P : S ×A×S → [0, 1] is the transition probabilities, r : S ×A×S → R
is the reward mapping, and γ ∈ [0, 1] is the discount factor. At each time step t, the agent observes
a state St ∈ S and takes an action At ∈ A and then transitions to a new state St+1 ∈ S according
to the transition probabilities P and receives a scalar reward Rt+1 = r(St, At, St+1) ∈ R. The goal
of the agent is to find a policy π : S × A → [0, 1] that maximizes the expected return starting from
some initial state.
Q-learning is an off-policy algorithm which attempts to learn the state-action values Q : S × A → R
for the optimal policy. It tries to solve for
Q*(s, a) = E∣Rt+ι + max Q*(St+ι,a0) ∣ St = s, At = a]
The optimal policy is to act greedily with respect to these action values: from each s select a
from argmaXa∈A Q*(s,a). The update rule for an approximation Q for a sampled transition
st, at, rt+1, st+1 is:
Q(St, at) J Q(St,at) + α(YQ - Q(3 * st, at))	for YQ == rt+1 + Y maχ Q(St+1, aO)	(I)
a0∈A
where α is the step-size. The transition can be generated off-policy, from any behaviour
that sufficiently covers the state space. This algorithm is known to converge in the tabular
setting (Tsitsiklis, 1994), with some limited results for the function approximation setting (Melo
& Ribeiro, 2007).
3 Understanding when Overestimation Bias Helps and Hurts
In this section, we briefly discuss the estimation bias issue, and empirically show that both
overestimation and underestimation bias may improve learning performance, depending on the
2
Published as a conference paper at ICLR 2020
environment. This motivates our Maxmin Q-learning algorithm described in the next section, which
allows us to flexibly control the estimation bias and reduce the estimation variance.
The overestimation bias occurs since the target maxa0∈A Q(st+1, a0) is used in the Q-learning
update. Because Q is an approximation, it is probable that the approximation is higher than the true
value for one or more of the actions. The maximum over these estimators, then, is likely to be skewed
towards an overestimate. For example, even unbiased estimates Q(st+1, a0) for all a0, will vary due
to StoChaSticity. Q(st+1, a0) = Q* (st+1,a0) + ea, and for some actions, eao will be positive. AS a
result, E[maxa0∈a Q(st+ι,a0)] ≥ max。，∈aE[Q(st+ι,a0)] = max。，∈aQ*(st+ι,a0).
This overestimation bias, however, may not always be detrimental. And, further, in some cases,
erring towards an underestimation bias can be harmful. Overestimation bias can help encourage
exploration for overestimated actions, whereas underestimation bias might discourage exploration.
In particular, we expect more overestimation bias in highly stochastic areas of the world; if those
highly stochastic areas correspond to high-value regions, then encouraging exploration there might
be beneficial. An underestimation bias might actually prevent an agent from learning that a region is
high-value. Alternatively, if highly stochastic areas also have low values, overestimation bias might
cause an agent to over-explore a low-value region.
We show this effect in the simple MDP, shown in Figure 1. The MDP for state A has only two
actions: Left and Right. It has a deterministic neutral reward for both the Left action and the
Right action. The Left action transitions to state B where there are eight actions transitions to
a terminate state with a highly stochastic reward. The mean of this stochastic reward is μ. By
selecting μ > 0, the stochastic region becomes high-value, and We expect overestimation bias to
help and underestimation bias to hurt. By selecting μ < 0, the stochastic region becomes low-value,
and we expect overestimation bias to hurt and underestimation bias to help.
Figure 1: A simple episodic MDP, adapted from Figure 6.5 in Sutton & Barto (2018) which is used
to highlight the difference between Double Q-learning and Q-learning. This MDP has two non-
terminal states A and B . Every episode starts from A which has two actions: Left and Right. The
Right action transitions to a terminal state with reward 0. The Left action transitions to state B with
reward 0. From state B, there are 8 actions that all transition to a terminal state with a reward μ + ξ,
where ξ is drawn from a uniform distribution U(-1,1). When μ > 0, the optimal action in state A
is Left; when μ < 0, it is Right.
We test Q-learning, Double Q-learning and our new algorithm Maxmin Q-learning in this
environment. Maxmin Q-learning (described fully in the next section) uses N estimates of the
action values in the targets. For N = 1, it corresponds to Q-learning; otherwise, it progresses from
overestimation bias at N = 1 towards underestimation bias with increasing N . In the experiment,
we used a discount factor γ = 1; a replay buffer with size 100; an -greedy behaviour with = 0.1;
tabular action-values, initialized with a Gaussian distribution N (0, 0.01); and a step-size of 0.01 for
all algorithms.
The results in Figure 2 verify our hypotheses for when overestimation and underestimation bias help
and hurt. Double Q-learning underestimates too much for μ = +1, and converges to a suboptimal
policy. Q-learning learns the optimal policy the fastest, though for all values of N = 2, 4, 6, 8,
Maxmin Q-learning does progress towards the optimal policy. All methods get to the optimal policy
for μ = —1, but now Double Q-learning reaches the optimal policy the fastest, and followed by
Maxmin Q-learning with larger N .
4	Maxmin Q-learning
In this section, we develop Maxmin Q-learning, a simple generalization of Q-learning designed to
control the estimation bias, as well as reduce the estimation variance of action values. The idea is
3
Published as a conference paper at ICLR 2020
Distance
of training
policy to
optimal
policy
1.2η
Q-Ieaming
(b) μ = —0.1 (underestimation helps)
----Double Q-Ieaming
Maxmin Q-Ieaming (N=2)
Maxmin Q-Ieaming (N =4)
----Maxmin Q-Ieaming (N=6)
0.6-
0.4
0.2-
o.o-
----Maxmin Q-Ieaming (N=8)
Episodes
(a) μ = +0.1 (overestimation helps)
Figure 2: Comparison of three algorithms using the simple MDP in Figure 1 with different values
of μ, and thus different expected rewards. For μ = +0.1, shown in (a), the optimal e-greedy policy
is to take the Left action with 95% probability. For μ = -0.1, shown in in (b), the optimal policy is
to take the Left action with 5% probability. The reported distance is the absolute difference between
the probability of taking the Left action under the learned policy compared to the optimal e-greedy
policy. All results were averaged over 5, 000 runs.
to maintain N estimates of the action values, Qi , and use the minimum of these estimates in the
Q-learning target: maxa0 mini∈{1,...,N} Qi(s0, a0). For N = 1, the update is simply Q-learning, and
so likely has overestimation bias. As N increase, the overestimation decreases; for some N > 1,
this maxmin estimator switches from an overestimate, in expectation, to an underestimate. We
characterize the relationship between N and the expected estimation bias below in Theorem 1. Note
that Maxmin Q-learning uses a different mechanism to reduce overestimation bias than Double Q-
learning; Maxmin Q-learning with N = 2 is not Double Q-learning.
The full algorithm is summarized in Algorithm 1, and is a simple modification of Q-learning with
experience replay. We use random subsamples of the observed data for each of the N estimators, to
make them nearly independent. To do this training online, we keep a replay buffer. On each step, a
random estimator i is chosen and updated using a mini-batch from the buffer. Multiple such updates
can be performed on each step, just like in experience replay, meaning multiple estimators can be
updated per step using different random mini-batches. In our experiments, to better match DQN, we
simply do one update per step. Finally, it is also straightforward to incorporate target networks to
get Maxmin DQN, by maintaining a target network for each estimator.
We now characterize the relation between the number of action-value functions used in Maxmin
Q-learning and the estimation bias of action values. For compactness, we write Qisa instead of
Qi(s, a). Each Qisa has random approximation error eisa
QSa = Qsa + el
We assume that eisa is a uniform random variable U(-τ, τ) for some τ > 0. The uniform random
assumption was used by Thrun & Schwartz (1993) to demonstrate bias in Q-learning, and reflects
that non-negligible positive and negative eisa are possible. Notice that for N estimators with nsa
samples, the τ will be proportional to some function of nsa/N, because the data will be shared
amongst the N estimators. For the general theorem, we use a generic τ , and in the following
corollary provide a specific form for τ in terms of N and nsa .
Recall that M is the number of actions applicable at state s0 . Define the estimation bias ZMN for
transition s, a, r, s0 to be
ZMN d=ef (r + γ max Qsm0ain0 ) - (r+γmaxQss0a0)
a0	a0
= γ(max Qsm0ain0 - max Qss0a0)
a0	a0
4
Published as a conference paper at ICLR 2020
Algorithm 1: Maxmin Q-learning
Input: step-size a, exploration parameter e > 0, number of action-value functions N
Initialize N action-value functions {Q1, . . . , QN} randomly
Initialize empty replay buffer D
Observe initial state s
while Agent is interacting with the Environment do
Qmin(S, a) — mink∈{i,...,N} Qk(s, a), ∀a ∈ A
Choose action a by -greedy based on Qmin
Take action a, observe r, s0
Store transition (s, a, r, s0) in D
Select a subset S from {1, . . . , N} (e.g., randomly select one i to update)
for i ∈ S do
Sample random mini-batch of transitions (sD, aD, rD, s0D) from D
Get update target: YMQ — r° + Y maXαo∈A Qmirn(SD,α0)
Update action-value Qi: Qi(Sd, aD) — Qi(s∏ ,a∏) + α[YMQ - Qri(SD,a□)]
end
S	— S0
end
where
Qsmain d=ef i∈{m1,.i.n.,N} Qisa
Qsa
min
i∈{1,...,N}
i
sa
+
e
We now show how the expected estimation bias E [ZMN] and the variance of Qsmain are related to
the number of action-value functions N in Maxmin Q-learning.
Theorem 1 Under the conditions stated above,
(i)	the expected estimation bias is
M (M - 1)∙∙∙1
E [ZMN] = γτ [1 - 2tMN]	where tMN
(M + N)(M - 1 + N) ∙∙∙(I + N)
E[Zmn] decreases as N increases: E[Zm N =1] = γτM-I and E[Zm N→∞] = 一γτ.
(ii)	M+1
4Nτ2
Var[QminI = (N +1)2(N + 2).
2
Var[Qmin] decreases as N increases: V ar [Qmin]=每 forN=1 and Var[Qmin] = 0 for N → ∞.
Theorem 1 is a generalization of the first lemma in Thrun & Schwartz (1993); we provide the proof
in Appendix A as well as a visualization of the expected bias for varying M and N. This theorem
shows that the average estimation bias E[ZMN], decreases as N increases. Thus, we can control
the bias by changing the number of estimators in Maxmin Q-learning. Specifically, the average
estimation bias can be reduced from positive to negative as N increases. Notice that E[ZMN] = 0
when tMN = 1. This suggests that by choosing N such that tMN ≈ 21, we can reduce the bias to
near 0.
Furthermore, V ar[Qsmain] decreases as N increases. This indicates that we can control the estimation
variance of target action value through N. We show just this in the following Corollary. The subtlety
is that with increasing N, each estimator will receive less data. The fair comparison is to compare
the variance of a single estimator that uses all of the data, as compared to the maxmin estimator
which shares the samples across N estimators. We show that there is an N such that the variance is
lower, which arises largely due to the fact that the variance of each estimator decreases linearly in n,
but the τ parameter for each estimator only decreases at a square root rate in the number of samples.
Corollary 1 Assuming the nsa samples are evenly allocated amongst the N estimators, then T =
{32NInSa where σ2 is the variance ofsamples for (s, a) and, for QSa the estimator that uses all
5
Published as a conference paper at ICLR 2020
(a) Robustness under increasing reward variance
Figure 3: Comparison of four algorithms on Mountain Car under different reward variances. The
lines in (a) show the average number of steps taken in the last episode with one standard error. The
lines in (b) show the number of steps to reach the goal position during training when the reward
variance σ2 = 10. All results were averaged across 100 runs, with standard errors. Additional
experiments with further elevated σ2 can be found in Appendix C.2.
nsa samples for a single estimate,
12N2
VarQn=(N +1)2(N + 2) Vag∙
Under this uniform random noise assumption, for N ≥ 8, V ar[Qsmain] < Var[Qsa].
5	Experiments
In this section, we first investigate robustness to reward variance, in a simple environment (Mountain
Car) in which we can perform more exhaustive experiments. Then, we investigate performance in
seven benchmark environments.
Robustness under increasing reward variance in Mountain Car Mountain Car (Sutton &
Barto, 2018) is a classic testbed in Reinforcement Learning, where the agent receives a reward
of -1 per step with γ = 1, until the car reaches the goal position and the episode ends. In our
experiment, we modify the rewards to be stochastic with the same mean value: the reward signal is
sampled from a Gaussian distribution N (-1, σ2) on each time step. An agent should learn to reach
the goal position in as few steps as possible.
The experimental setup is as follows. We trained each algorithm with 1, 000 episodes. The number
of steps to reach the goal position in the last training episode was used as the performance measure.
The fewer steps, the better performance. All experimental results were averaged over 100 runs.
The key algorithm settings included the function approximator, step-sizes, exploration parameter
and replay buffer size. All algorithm used -greedy with = 0.1 and a buffer size of 100. For
each algorithm, the best step-size was chosen from {0.005, 0.01, 0.02, 0.04, 0.08}, separately for
each reward setting. Tile-coding was used to approximate the action-value function, where we used
8 tilings with each tile covering 1/8th of the bounded distance in each dimension. For Maxmin
Q-learning, we randomly chose one action-value function to update at each step.
As shown in Figure 3, when the reward variance is small, the performance of Q-learning, Double Q-
learning, Averaged Q-learning, and Maxmin Q-learning are comparable. However, as the variance
increases, Q-learning, Double Q-learning, and Averaged Q-learning became much less stable than
Maxmin Q-learning. In fact, when the variance was very high (σ = 50, see Appendix C.2), Q-
learning and Averaged Q-learning failed to reach the goal position in 5, 000 steps, and Double Q-
learning produced runs > 400 steps, even after many episodes.
6
Published as a conference paper at ICLR 2020
Results on Benchmark Environments To evaluate Maxmin DQN, we choose seven games
from Gym (Brockman et al., 2016), PyGame Learning Environment (PLE) (Tasfi, 2016), and
MinAtar (Young & Tian, 2019): Lunarlander, Catcher, Pixelcopter, Asterix, Seaquest, Breakout,
and Space Invaders. For games in MinAtar (i.e. Asterix, Seaquest, Breakout, and Space Invaders),
we reused the hyper-parameters and settings of neural networks in (Young & Tian, 2019). And the
step-size was chosen from [3 * 10-3,10-3, 3 * 10-4,10-4,3 * 10-5]. For Lunarlander, Catcher, and
Pixelcopter, the neural network was a multi-layer perceptron with hidden layers fixed to [64, 64].
The discount factor was 0.99. The size of the replay buffer was 10, 000. The weights of neural
networks were optimized by RMSprop with gradient clip 5. The batch size was 32. The target
network was updated every 200 frames. -greedy was applied as the exploration strategy with
decreasing linearly from 1.0 to 0.01 in 1, 000 steps. After 1, 000 steps, was fixed to 0.01. For
Lunarlander, the best step-size was chosen from [3 * 10-3, 10-3, 3 * 10-4, 10-4, 3 * 10-5]. For
Catcher and Pixelcopter, the best step-size was chosen from [10-3, 3 * 10-4, 10-4, 3 * 10-5, 10-5].
For both Maxmin DQN and Averaged DQN, the number of target networks N was chosen from
[2, 3, 4, 5, 6, 7, 8, 9]. And we randomly chose one action-value function to update at each step. We
first trained each algorithm in a game for certain number of steps. After that, each algorithm was
tested by running 100 test episodes with -greedy where = 0.01. Results were averaged over
20 runs for each algorithm, with learning curves shown for the best hyper-parameter setting (see
Appendix C.3 for the parameter sensitivity curves).
We see from Figure 4 that Maxmin DQN performs as well as or better than other algorithms.
In environments where final performance is noticeably better—-Pixelcopter, Lunarlander and
Asterix—the initial learning is slower. A possible explanation for this is that the Maxmin agent
more extensively explored early on, promoting better final performance. We additionally show on
Pixelcopter and Asterix that for smaller N, Maxmin DQN learns faster but reaches suboptimal
performance—behaving more like Q-learning—and for larger N learns more slowly but reaches
better final performance.
6	Convergence Analysis of Maxmin Q-learning
In this section, we show Maxmin Q-learning is convergent in the tabular setting. We do so by
providing a more general result for what we call Generalized Q-learning: Q-learning where the
bootstrap target uses a function G of N action values. The main condition on G is that it maintains
relative maximum values, as stated in Assumption 1. We use this more general result to prove
Maxmin Q-learning is convergent, and then discuss how it provides convergence results for Q-
learning, Ensemble Q-learning, Averaged Q-learning and Historical Best Q-learning as special
cases.
Many variants of Q-learning have been proposed, including Double Q-learning (van Hasselt, 2010),
Weighted Double Q-learning (Zhang et al., 2017), Ensemble Q-learning (Anschel et al., 2017),
Averaged Q-learning (Anschel et al., 2017), and Historical Best Q-learning (Yu et al., 2018). These
algorithms differ in their estimate of the one-step bootstrap target. To encompass all variants, the
target action-value of Generalized Q-learning Y GQ is defined based on action-value estimates from
both dimensions:
YGQ = r + γQsG0Q(t - 1)	(2)
where t is the current time step and the action-value function QsGQ(t) is a function of Qs1 (t -
K),...,Qs1(t-1),...,QsN(t-K),...,QsN(t-1):
/ Ql(t- K)	...	Ql(t- 1) ∖
GO, 、 I	Q2(t-K)	...	Q2(t-1)
QGQ(t) = G	.	.	.	⑶
.	..
QsN(t-K)	... QsN(t-1)
For simplicity, the vector (QsGaQ(t))a∈A is denoted as QsGQ(t), same for Qis(t). The corresponding
update rule is
QSa(t) - QSa(t - 1) + αSa(t - 1)(YGQ - Q* - 1))	(4)
For different G functions, Generalized Q-learning reduces to different variants of Q-learning,
including Q-learning itself. For example, Generalized Q-learning can be reduced to Q-learning
7
Published as a conference paper at ICLR 2020
(f) Asterix
(h) Pixelcopter with varying N
(i) Asterix with varying N
Figure 4: Learning curves on the seven benchmark environments. The depicted return is averaged
over the last 100 episodes, and the curves are smoothed using an exponential average, to match
previous reported results (Young & Tian, 2019). The results were averaged over 20 runs, with the
shaded area representing one standard error. Plots (h) and (i) show the performance of Maxmin
DQN on Pixelcopter and Asterix, with different N, highlighting that larger N seems to result in
slower early learning but better final performance in both environments.
8
Published as a conference paper at ICLR 2020
simply by setting K = 1, N = 1 with G(Qs) = maxa∈A Qsa. Double Q-learning can be specified
with K = 1,N = 2, andG(Q1,Q2) = Q2	1 .
s s	s,arg maxa0∈A Qs1a0
We first introduce Assumption 1 for function G in Generalized Q-learning, and then state the
theorem. The proof can be found in Appendix B.
Assumption 1 (Conditions on G) Let G : RnNK 7→ R and G(Q) = q where Q = (Qiaj ) ∈
RnNK, a ∈ A and |A| = n, i ∈ {1, . . . , N},j ∈ {0, . . . , K - 1} and q ∈ R.
(i)	If Qiaj = Qakl, ∀i, k, ∀j, l, and ∀a, then q = maxa Qiaj.
(ii)	∀Q, Q0 ∈ RnNK, | G(Q)- G(Q0) ∣≤ maxa,i,j | Qj - Q0j |.
We can verify that Assumption 1 holds for Maxmin Q-learning. Set K = 1 and set N to be a
positive integer. Let Qs = (Qs1, . . . , QsN) and define GMQ(Qs) = maxa∈A mini∈{1,...,N} Qisa. It
is easy to check that part (i) of Assumption 1 is satisfied. Part (ii) is also satisfied because
| G(Qs)- G(Qs) l≤l maxmin Qisa- maxmin Qsia0 l≤ max | Qisa - Qsia | .
a i	a0	i0	a,i
Assumption 2 (Conditions on the step-sizes) There exists some (deterministic) constant C such
that for every (s, a) ∈ S × A, i ∈ {1, . . . , N}, 0 ≤ αisa(t) ≤ 1, and with probability 1,
∞∞
X(αisa(t))2 ≤ C,	Xαisa(t)=∞
t=0	t=0
Theorem 2 Assume a finite MDP (S, A, P, R) and that Assumption 1 and 2 hold. Then the action-
value functions in Generalized Q-learning, using the tabular update in Equation (3), will converge
to the optimal action-value function with probability 1, in either of the following cases: (i) γ < 1,
or (ii) γ = 1, ∀a ∈ A, Qis1a(t = 0) = 0 where s1 is an absorbing state and all policies are proper.
As shown above, because the function G for Maxmin Q-learning satisfies Assumption 1, then by
Theorem 2 it converges. Next, we apply Theorem 2 to Q-learning and its variants, proving the
convergence of these algorithms in the tabular case. For Q-learning, set K = 1 and N = 1. Let
GQ (Qs ) = maxa∈A Qsa. It is straightforward to check that Assumption 1 holds for function GQ .
For Ensemble Q-learning, set K = 1 and set N to be a positive integer. Let GEQ((Qs1, . . . , QsN)) =
maxa∈A -N PN=I Qlsa. Easy to check that Assumption 1 is satisfied. For Averaged Q-learning, the
proof is similar to Ensemble Q-learning except that N = 1 and K is a positive integer. For Historical
Best Q-learning, set N = 1 and K to be a positive integer. We assume that all auxiliary action-value
functions are selected from action-value functions at most K updates ago. Define GHBQ to be the
largest action-value among Qsa(t - 1), . . . , Qsa(t - K) for state s. Assumption 1 is satisfied and
the convergence is guaranteed.
7 Conclusion
Overestimation bias is a byproduct of Q-learning, stemming from the selection of a maximal value
to estimate the expected maximal value. In practice, overestimation bias leads to poor performance
in a variety of settings. Though multiple Q-learning variants have been proposed, Maxmin Q-
learning is the first solution that allows for a flexible control of bias, allowing for overestimation
or underestimation determined by the choice of N and the environment. We showed theoretically
that we can decrease the estimation bias and the estimation variance by choosing an appropriate
number N of action-value functions. We empirically showed that advantages of Maxmin Q-learning,
both on toy problems where we investigated the effect of reward noise and on several benchmark
environments. Finally, we introduced a new Generalized Q-learning framework which we used to
prove the convergence of Maxmin Q-learning as well as several other Q-learning variants that use
N action-value estimates.
Acknowledgments
We would like to thank Huizhen Yu and Yi Wan for their valuable feedback and helpful discussion.
9
Published as a conference paper at ICLR 2020
References
Oron Anschel, Nir Baram, and Nahum Shimkin.	Averaged-DQN: Variance Reduction and
Stabilization for Deep Reinforcement Learning.	In International Conference on Machine
Learning,pp. 176-185, 2017.
Dimitri P Bertsekas and John N Tsitsiklis. Parallel and Distributed Computation: Numerical
Methods, volume 23. Prentice hall Englewood Cliffs, NJ, 1989.
Dimitri P Bertsekas and John N Tsitsiklis. Neuro-dynamic Programming, volume 5. Athena
Scientific Belmont, MA, 1996.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. OpenAI Gym. arXiv preprint arXiv:1606.01540, 2016.
Herbert Aron David and Haikady Navada Nagaraja. Order Statistics. Encyclopedia of Statistical
Sciences, 2004.
Scott Fujimoto, Herke Hoof, and David Meger. Addressing function approximation error in actor-
critic methods. In International Conference on Machine Learning, pp. 1587-1596, 2018.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-
policy maximum entropy deep reinforcement learning with a stochastic actor. In International
Conference on Machine Learning, pp. 1861-1870, 2018.
Hado Hado van Hasselt, Arthur Guez, and David Silver. Deep Reinforcement Learning with Double
Q-learning. In AAAI Conference on Artificial Intelligence, 2016.
Donghun Lee, Boris Defourny, and Warren B. Powell. Bias-corrected Q-learning to Control Max-
operator Bias in Q-learning. In IEEE Symposium on Adaptive Dynamic Programming and
Reinforcement Learning, pp. 93-99, 2013.
Francisco S Melo and M Isabel Ribeiro. Q-learning with Linear Function Approximation. In
International Conference on Computational Learning Theory, pp. 308-322, 2007.
Alexander L. Strehl, Lihong Li, and Michael L. Littman. Reinforcement Learning in Finite MDPs:
PAC Analysis. Journal of Machine Learning Research, 10(Nov):2413-2444, 2009.
Richard S Sutton and Andrew G Barto. Reinforcement Learning: An Introduction. MIT Press,
second edition, 2018.
Istvan Szita and Andras Lorincz. The Many Faces of Optimism: A Unifying Approach. In
International Conference on Machine learning, pp. 1048-1055. ACM, 2008.
Norman Tasfi. Pygame learning environment. https://github.com/ntasfi/
PyGame-Learning-Environment, 2016.
Sebastian Thrun and Anton Schwartz. Issues in Using Function Approximation for Reinforcement
Learning. In Fourth Connectionist Models Summer School, 1993.
John N Tsitsiklis. Asynchronous Stochastic Approximation and Q-learning. Machine learning,
1994.
Hado van Hasselt. Double Q-learning. In Advances in Neural Information Processing Systems, pp.
2613-2621, 2010.
Chris Watkins. Learning from Delayed Rewards. PhD thesis, King’s College, Cambridge, 1989.
Kenny Young and Tian Tian. MinAtar: An Atari-inspired Testbed for More Efficient Reinforcement
Learning Experiments. arXiv preprint arXiv:1903.03176, 2019.
Wenwu Yu, Rui Wang, Ruiying Li, Jing Gao, and Xiaohui Hu. Historical Best Q-Networks for
Deep Reinforcement Learning. In International Conference on Tools with Artificial Intelligence,
pp. 6-11, 2018.
Zongzhang Zhang, Zhiyuan Pan, and Mykel J. Kochenderfer. Weighted Double Q-learning. In
International Joint Conference on Artificial Intelligence, pp. 3455-3461, 2017.
10
Published as a conference paper at ICLR 2020
A The Proof of Theorem 1
We first present Lemma 1 here as a tool to prove Theorem 1. Note that the first three properties in
this lemma are well-known results of order statistics (David & Nagaraja, 2004).
Lemma 1 LetX1, . . . , XN be N i.i.d. random variables from an absolutely continuous distribution
with probability density function(PDF) f(x) and cumulative distribution function (CDF) F (x).
Denote μ = E[Xi] and σ2 = Var[Xi] < +∞. Set Xi：N = mini∈{i,...,N}Xi and XN:N =
maxi∈{1,...,N} Xi. Denote the PDF and CDF of X1:N as f1:N (x) and F1:N (x), respectively.
Similarly, denote the PDF and CDF of XN:N as fN:N (x) and FN:N (x), respectively. We then
have
(i)	μ - (√2n?; ≤ E[X1：N] ≤ μ and E[X1：N +1] ≤ E[X1:N].
(ii)	F1:N (x) = 1 - (1 - F (x))N. f1:N(x) = Nf(x)(1 - F(x))N-1.
(iii)	FN:N (x) = (F (x))N. fN:N (x) = Nf(x)(F(x))N-1.
(iv)	If Xi,...,Xn 〜U(-τ,τ), we have Var(Xi：N) = (N+4N/N+2)and Var(X1：N +1) <
V ar(X1:N) ≤ Var(X1:1) = σ2 for any positive integer N.
Proof.
(i)	By the definition of X1：N, we have X1：N+1 ≤ X1：N. Thus E[X1：N+1] ≤ E [X1：N]. Since
E[Xi：i] = E[Xi] = μ, E[Xi:N] ≤ E[Xi：i] = μ. Theproof of μ - √--1 ≤ E[X[N]
can be found in (David & Nagaraja, 2004, Chapter 4 Section 4.2).
(ii)	We first consider the cdf of X1：N. F1：N (x) := P (X1：N ≤ x) = 1 - P (X1：N > x) =
1 — P (Xi > x,..., XM >x) = 1 — P(Xi >x)…P(XN >x) = 1 — (1 — F (X))N.
Then the pdf of Xi：N is fi：N(x) ：= d¾N = Nf(x)(1 - F(X))N-1.
(iii)	Similar to (ii), we first consider cdf of XN：N. FN：N (X) := P(XN：N ≤ X) = P(Xi ≤
x,...,Xn ≤ X) = P (Xi ≤ x)…P(XM ≤ X) = (F (x))n . Then the pdf of Xn ：n is
fN：n(x) := dFNN = Nf(X)(F(x))n-i.
(iv)
Since Xi,..., Xn 〜 Uniform(一τ,τ), we have F(x) = ɪ + 2T and f (x) = 2T.
Var(Xi：N) = E[Xi：N2] ― E[Xi：NF = 4τ2( (N +i)(N+2) ― (N+i)2 ) = (N+TnτN+2).
It is easy to check that V ar(Xi：N+i) < V ar(Xi：N) ≤ V ar(Xi：i) = σ2 for any positive
integer N .
Next, we prove Theorem 1.
Proof. Let f(X) and F(X) be the cdf and pdf of esa, respectively. Similarly, Let fN (X) and FN (X)
be the Cdf and pdf of mini∈{i,...,N} eSa∙ Since e§a is sampled from Uniform(-τ, T), it is easy to
get f (x) = 2T and F (x) = i + 券.By Lemma 1, We have /n (x) = Nf (x)[1 - F (x)]n-i =
11
Published as a conference paper at ICLR 2020
N(1 - -XT)n-1 and FN(x) = 1 - (1 - F(X))N = 1 - (2 -券)N. The expectation of ZMN is
E[Zmn] = γE[(maX Qman - maX Q；”)]
= YE[ma0x min eisa0]
a i∈{1,...,N }
= Y	M xfN (x)FN (x)M -1 dx
Y [τ MN— (1 - ɪ)
Y J-T	2τ (2 2τ)
Y /「di—； - 2χτ Y
N-1[1-(1 - ±)n]mTdx
[(2	2τ) ]
M
YT - Y /]l-(； - 2xτ)N]Mdx
γτ[1 - 2 / (1 - yN)mdy]	(y =f 2
x
2τ
—
Let tMN = R01(1 - yN)M dy, so that E[ZMN] = Yτ[1 - 2tMN]. Substitute y by t where t = yN,
then
tMN = "τy Z tN-1(1 - t)Mdt
N0
=NN B N，M + 1)
=1 Γ(M + 1)Γ( N)
—N Γ(M + N + 1)
= Γ(M + 1)Γ(1 + N)
—T(M + Nn + 1)
_	M (M - 1)∙∙∙1
(M + N)(M - 1 + NN)…(1 + NN)
Each term in the denominator decreases as N increases, because 1/N gets smaller. Therefore,
tM,N =1 = M+ι and tM,N→∞ = 1. Using this, we conclude that E[Zmn] decreases as N increases
and E[zM,N =1] = Yτ M +1 and E[zM,N→∞] = - Yτ.
By Lemma 1, the variance of Qsmain is
V ar[Qsmain]
4Nτ 2
(N +1)2(N + 2)
2
Var[Qmin] decreases as N increases. Inparticular, Var[Qmin] = Tf for N = 1 and Var[Qmin]
0 for N → ∞. ■
The bias-variance trade-off of Maxmin Q-learning is illustrated by the empirical results in Figure 5,
which support Theorem 1. For each M, N can be selected such that the absolute value of the
expected estimation bias is close to 0 according to Theorem 1. As M increases, we can adjust N to
reduce both the estimation variance and the estimation bias.
Finally, we prove the result of the Corollary.
Corollary 1 Assuming the nsa samples are evenly allocated amongst the N estimators, then T =
,3σ2N∕nsα where σ2 is the variance of samples for (s, a) and, for Qsa the estimator that uses all
nsa samples for a single estimate,
V ar[Qsmain]
12N 2
(N +1)2(N + 2)
V ar[Qsa].
Under this uniform random noise assumption, for N ≥ 8, V ar[Qsmain] < V ar[Qsa].
12
Published as a conference paper at ICLR 2020
The expected estimation bias (E[Zmn})
CN寸 ∞ 9L Zm 寸 9 bcnl 99cn
(BSUoDoeJO,leqlunN
Number of action-value functions (N)
(a) Bias control
(πssot,e∖∕Γ∈δot,e∖) o口Rl(υOUEμE>
(b) Variance reduction
Figure 5: Empirical results of Theorem 1. M is the number of available actions for some state s. N
is the number of action-value functions in Maxmin Q-learning. In Figure 5 (a), we show a heat map
of bias control in Maxmin Q-learning. In Figure 5 (b), we show how the variance ratio of Qsmain and
Qsa (i.e. Var[Qsmain]/V ar[Qsa]) reduces as N increases. For a better comparison, we set γτ = 1.
Proof. Because Qsa is a sample mean, its variance is σ2N∕nsa where σ2 is the variance of samples
for (s, a) and its mean is Qsa (because it is an unbiased sample average). Consequently, esa has
mean zero and variance σ2N∕nsa. Because esa is a uniform random variable which has variance
3T2, we know that T = ∙∖∕3σ2N∕nsa. Plugging this value into the variance formula in Theorem 1,
we get that
V ar[Qsmain]
4Nτ 2
(N +1)2(N + 2)
(N+1)2(N+2)
12N2
(N +1)2(N + 2)Var [Qsa]
because V ar [Qsa] = σ2 /nsa for the sample average Qsa that uses all the samples for one estimator.
Easy to verify that for N ≥ 8, V ar[Qsmain] < V ar[Qsa].
B	The Convergence Proof of Generalized Q-learning
The convergence proof of Generalized Q-learning is based on Tsitsiklis (1994). The key steps to
use this result for Generalized Q-learning include showing that the operator is a contraction and
verifying the noise conditions. We first show these two steps in Lemma 2 and Lemma 3. We then
use these lemmas to make the standard argument for convergence.
B.1	Problem Setting for Generalized Q-learning
Consider a Markov decision problem defined on a finite state space S . For every state s ∈ S, there is
a finite set A of possible actions for state s and a set of non-negative scalars pss0 (a), a ∈ A, s0 ∈ S,
such that Pj∈Spss0 (a) = 1 for all a ∈ A. The scalar pss0 (a) is interpreted as the probability of a
transition to s0, given that the current state is s and action a is applied. Furthermore, for every state
s and action a, there is a random variable rsa which represents the reward if action a is applied at
state s. We assume that the variance of rsa is finite for every s and a ∈ A.
13
Published as a conference paper at ICLR 2020
A stationary policy is a function π defined on S such that π(s) ∈ A for all s ∈ S. Given a stationary
policy, we obtain a discrete-time Markov chain fπ (t) with transition probabilities
Pr(fπ (t + 1) = Slfn (t) = S) = Psso(∏(s))	⑸
Let γ ∈ [0, 1] be a discount factor. For any stationary policy π and initial state S, the state value Vsπ
is defined by
Vn = T→∞ E [X Yt rfπ (t),∏(fπ (t))fπ ⑼=s]
t=0
The optimal state value function V * is defined by
V* =SuPVn,	S ∈ S
n
(6)
(7)
The Markov decision problem is to evaluate the function V*. Once this is done, an optimal policy
is easily determined.
Markov decision problems are easiest when the discount γ is strictly smaller than 1. For the
undiscounted case (γ = 1), we will assume throughout that there is a reward-free state, say state 1,
which is absorbing; that is, p11(a) = 1 and r1u = 0 for all a ∈ A. The objective is then to reach
that state at maximum expected reward. We say that a stationary policy is proper if the probability
of being at the absorbing state converges to 1 as time converges to infinity; otherwise, we say that
the policy is improper.
We define the dynamic programming operator T : R|S| 7→ R|S| , with components Ti , by letting
Ts(V) = max{E[rsa] + γ	pss0 (a)Vs0}	(8)
a∈A	s0∈S
It is well known that if γ < 1, then T is a contraction with respect to the norm ∣∣ ∙ ∣∣∞ and V * is its
unique fixed point.
For Generalized Q-learning algorithm, assume that there are N estimators of action-values
Q1, . . . , QN. Let m be the cardinality of S and n be the cardinality of A. We use a discrete
index variable t in order to count iterations. Denote Qij (t) = Qi(t + j). After t iterations, we have
a vector Q(t) ∈ Rw and w = mnNK, with components Qisja(t), (S, a) ∈ S × A, i ∈ {1, . . . , N},
and j ∈ {0, . . . , K - 1}.
By definition, for j ∈ {1, . . . , K - 1}, we have
Qisja(t + 1) = Qis,aj-1(t).	(9)
For j = 0, we have Qis0a = Qisa . And we update according to the formula
Qisa(t + 1) = Qisa(t) + αisa(t)[Y GQ(t) - Qisa(t)]	(10)
where
YGQ(t)=rsa+γQfG(Qs,a)(t).	(11)
Here, each αisa(t) is a nonnegative step-size coefficient which is set to zero for those (S, a) ∈ S × A
and i ∈ {1, . . . , N} for which Qisa is not to be updated at the current iteration. Furthermore, rsa
is a random sample of the immediate reward if action a is applied at state S. f(S, a) is a random
successor state which is equal to S0 with probability pss0 (a). Finally, QsGQ(t) is defined as
QsGQ(t) = G(Qs(t))	(12)
where G is a mapping from RnNK to R. It is understood that all random samples that are drawn in
the course of the algorithm are drawn independently.
Since for j ∈ {1, . . . , K - 1}, we just preserve current available action-values, we only focus on
the case that j = 0 in the sequel. Let F be the mapping from RmnNK into RmnN with components
Fsia defined by
Fsia(Q) =E[rsa]+γE[QfG(Qs,a)]	(13)
14
Published as a conference paper at ICLR 2020
and note that
E[QsGQ] = X pss0 (a)QsG0Q	(14)
s0∈S
If Fsia(Q(t)) = Q(t)isa, we can do K more updates such that Q(t)iaj = Q(t)kal, ∀i, k ∈ {1, . . . , N},
∀j,l ∈ {0,... ,K- 1}, and ∀a ∈ A.
In view of Equation 13, Equation 10 can be written as
Qisa(t + 1) = Qisa(t) + αsia(t)[Fsia(Q(t)) - Qisa(t) + wsia(t)]	(15)
where
wia(t) = rsa - E[rsa] + Y(QGQ⑷⑴ — E[Qf(Q,a) (t)F⑴])	(⑹
and F(t) represents the history of the algorithm during the first t iterations. The expectation in the
expression E[QfG(Qs,a)(t)|F(t)] is with respect to f(s, a).
B.2	Key Lemmas and the Proofs
Lemma 2 Assume Assumption 1 holds for function G in Generalized Q-learning. Then we have
E [w2a ⑴IF ⑴] ≤ Var(rSa) +	maXχrη max maχ/Qsa(T )|2.
sa	i∈{1,...,N} τ≤t (s,a)∈S×A	sa
Proof. Under Assumption 1, the conditional variance of QfG(Qs,a) given F (t), is bounded
above by the largest possible value that this random variable could take, which is
maxi∈{1,...,N} maxj∈{0,...,K-1} max(s,a)∈S×A |Qisa(t -j)|2. We then take the conditional
variance of both sides of Equation 16, to obtain
E[w2a⑴IF⑴] ≤ Var(rsa)+, max	max	max	|QSa(T)|2	(17)
sa	i∈{1,...,N} τ≤t (s,a)∈S×A sa
We have assumed here that rsa is independent from f (s, a). If it is not, the right-hand side in the
last inequality must be multiplied by 2, but the conclusion does not change. ■
Lemma 3 F is a contraction mapping, in each of the following cases:
(i)	γ < 1.
(ii)	γ = 1 and ∀a ∈ A, Qis a (t = 0) = 0 where s1 is an absorbing state. All policies are
proper.
Proof. For discounted problems (γ < 1), Equation 13 easily yields ∀Q, Q0,
IFsia(Q)-Fsia(Q0)I ≤γmaxIQsGQ-Q0sGQI	(18)
s∈S
In particular, F is a contraction mapping, with respect to the maximum norm ∣∣T∣∞.
For undiscounted problems (γ = 1), our assumptions on the absorbing state s1 imply that the update
equation for Qis1a degenerates to Qis1a(t+1) = Qis1a(t), for all t. We will be assuming in the sequel,
that Qis a is initialized at zero. This leads to an equivalent description of the algorithm in which the
mappings Fsia of Equation 13 are replaced by mappings Fsia satisfying Fsia = Fsia if s 6= s1 and
ɪ - , . . , ____________________________ _ _
FS1 a(Q) = 0 for all a ∈ A, i ∈ {1,...,N} and Q ∈ Rn.
Let us consider the special case where every policy is proper. By Proposition 2.2 in the work
of (Bertsekas & Tsitsiklis, 1996), there exists a vector v > 0 such that T is a contraction with
respect to the norm ∣∣ ∙ ∣∣v. In fact, a close examination of the proof of this Proposition 2.2 shows
that this proof is easily extended to show that the mapping F (with components Fsia) is a contraction
with respect to the norm ∣∣ ∙ ∣∣z, where ZSa = VS for every a ∈ A and i ∈ {1,..., N}. ■
15
Published as a conference paper at ICLR 2020
B.3	Models and Assumptions
In this section, we describe the algorithmic model to be employed and state some assumptions that
will be imposed.
The algorithm consists of noisy updates of a vector x ∈ Rn , for the purpose of solving a
system of equations of the form F (x) = x. Here F is assumed to be a mapping from Rn into
itself. Let F1 , . . . , Fn : Rn 7→ R be the corresponding component mappings; that is, F (x) =
(F1(x), . . . , Fn(x)) for all x ∈ Rn.
Let N be the set of non-negative integers. We employ a discrete ”time” variable t, taking values
in N. This variable need not have any relation with real time; rather, it is used to index successive
updates. Let x(t) be the value of the vector x at time t and let xi (t) denote its ith component. Let
T i (ii) (iii) (iv) (v) be an infinite subset of N indicating the set of times at which an update of xi is performed. We
assume that
xi(t + 1) = xi(t), t ∈/ Ti	(19)
Regarding the times that xi is updated, we postulate an update equation of the form
xi(t+1)=xi(t)+αi(t)(Fi(xi(t))-xi(t)+wi(t)), t∈Ti	(20)
Here, α(t) is a step-size parameter belonging to [0, 1], wi(t) is a noise term, and xi(t) is a vector of
possibly outdated components of x. In particular, we assume that
xi (t) = (x1(τ1i(t)), . . . ,xn(τni(t))), t ∈ Ti	(21)
where each τji(t) is an integer satisfying 0 ≤ τji(t) ≤ t. If no information is outdated, we have
τji (t) = t and xi (t) = x(t) for all t; the reader may wish to think primarily of this case. For an
interpretation of the general case, see (Bertsekas & Tsitsiklis, 1989). In order to bring Eqs. 19 and
20 into a unified form, it is convenient to assume that αi(t), wi(t), and τji(t) are defined for every i,
j, and t, but that αi(t) = 0 and τji(t) = t for t ∈/ Ti.
We will now continue with our assumptions. All variables introduced so far
(χ(t),τi(t),αi(t),wi(t)) are viewed as random variables defined on a probability space (Ω, F, P)
and the assumptions deal primarily with the dependencies between these random variables. Our
assumptions also involve an increasing sequence {F (t)}t∞=0 of subfields of F. Intuitively, F(t) is
meant to represent the history of the algorithm up to, and including the point at which the step-sizes
αi(t) for the tth iteration are selected, but just before the noise term wi(t) is generated. Also, the
measure-theoretic terminology that ”a random variable Z is F (t)-measurable” has the intuitive
meaning that Z is completely determined by the history represented by F (t).
The first assumption, which is the same as the total asynchronism assumption of Bertsekas &
Tsitsiklis (1989), guarantees that even though information can be outdated, any old information
is eventually discarded.
Assumption 3 For any i and j, limt→∞ τji(t) = ∞, with probability 1.
Our next assumption refers to the statistics of the random variables involved in the algorithm.
Assumption 4 Let {F (t)}t∞=0 be an increasing sequence of subfields of F.
(i) x(0) is F (0)-measurable.
(ii) For every i and t, wi (t) is F(t + 1)-measurable.
(iii) For every i, j and t, αi(t) and τji(t) are F (t)-measurable.
(iv) For every i and t, we have E [wi (t)|F (t)] = 0.
(v) There exist (deterministic) constants A and B such that
E [w2 (t)|F (t)] ≤ A + B max max |xj (τ )|2, ∀i,t	(22)
i	j τ≤t
16
Published as a conference paper at ICLR 2020
Assumption 4 allows for the possibility of deciding whether to update a particular component xi at
time t, based on the past history of the process. In this case, the step-size αi (t) becomes a random
variable. However, part (iii) of the assumption requires that the choice of the components to be
updated must be made without anticipatory knowledge of the noise variables wi that have not yet
been realized.
Finally, we introduce a few alternative assumptions on the structure of the iteration mapping F . We
first need some notation: if x, y ∈ Rn, the inequality x ≤ y is to be interpreted as xi ≤ yi for all i.
Furthermore, for any positive vector V = (vι,..., vn), We define a norm k ∙ ∣∣v on Rn by letting
∣x∣v
max |Xi|
i	vi
x ∈ Rn
(23)
Notice that in the special case where all components of V are equal to 1, ∣ ∙ ∣∣v is the same as the
maximum norm ∣∣ ∙ ∣∣∞.
Assumption 5 Let F : Rn 7→ Rn.
(i)	The mapping F is monotone; that is, if x ≤ y, then F(x) ≤ F (y).
(ii)	The mapping F is continuous.
(iii)	The mapping F has a unique fixed point x* .
(iv)	If e ∈ Rn is the vector with all components equal to 1, and r is a positive scalar, then
F(x) - re ≤ F(x - re) ≤ F(x + re) ≤ F(x) + re	(24)
Assumption 6 There exists a vector x* ∈ Rn, a positive vector V, anda scalar β ∈ [0, 1), such that
∣F (x) -x*∣v ≤ β∣x-x*∣v, ∀x ∈ Rn	(25)
Assumption 7 There exists a positive vector V, a scalar β ∈ [0, 1), and a scalar D such that
∣F (x)∣v ≤β∣x∣v+D, ∀x∈Rn	(26)
Assumption 8 There exists at least one proper stationary policy. Every improper stationary policy
yields infinite expected cost for at least one initial state.
Theorem 3	Let Assumptions 3, 4, 2, and 7 hold. Then the sequence x(t) is bounded with probability
1.
Theorem 4	Let Assumptions 3, 4, 2, and 5 hold. Furthermore, suppose that x(t) is bounded with
probability 1. Then x(t) converges to x* with probability 1.
Theorem 5	Let Assumptions 3, 4, 2, and 6 hold. Then x(t) converges to x* with probability 1.
Detailed proofs of Theorems 3, 4, and 5 can be found in the work of Bertsekas & Tsitsiklis (1989).
B.4 Proof of Theorem 2
We first state Theorem 2 here again and then show the proof.
Theorem 2 Assume a finite MDP (S, A, P, R) and that Assumption 1 and 2 hold. Then the
action-value functions in Generalized Q-learning, using tabular update in Equation (3), will
converge to the optimal action-value function with probability 1, in each of the following cases:
(i)	γ < 1.
(ii)	γ = 1 and ∀a ∈ A, Qis a(t = 0) = 0 where s1 is an absorbing state. All policies are
proper.
17
Published as a conference paper at ICLR 2020
Proof. We first check Assumptions 3, 4, 2, and 6 in Section B.3 are satisfied. Then we simply apply
Theorem 5 to Generalized Q-learning.
Assumption 3 is satisfied in the special case where τji(t) = t, which is what was implicitly assumed
in Equation 10, but can be also satisfied even if we allow for outdated information.
Regarding Assumption 4, parts (i) and (ii) of the assumption are then automatically valid. Part (iii)
is quite natural: in particular, it assumes that the required samples are generated after we decide
which components to update during the current iteration. Part (iv) is automatic from Equation 16.
Part (v) is satisfied by Lemma 2.
Assumption 2 needs to be imposed on the step-sizes employed by the Generalized Q-learning
algorithm. This assumption is standard for stochastic approximation algorithms. In particular, it
requires that every state-action pair (s, a) is simulated an infinite number of times.
By Lemma 3, F is a contraction mapping. Assumption 6 is satisfied.
All assumptions required by Theorem 5 are verified, convergence then follows from Theorem 5.
C	Additional Empirical Results
C.1 MDP results
Comparison of three algorithms using the simple MDP in Figure 1 with different values of μ is
shown in Figure 6. For μ = +0.1, the learning curves of action value Q(A, Left) are shown in (a).
Here, the true action value Q(A, Left) is +0.1. For μ = -0.1, the learning curves of action value
Q(A, Left) are shown in (b). The true action value Q(A, Left) is -0.1. All results were averaged
over 5, 000 runs.
0.1-
o.o-
Q(A,LEFT)
-0.1-
-0.2-
-0.3- ∣
0
----Maxmin Q-Ieaming (N=6)
----Maxmin Q-Ieaming (N=8)
----True value
2000	4000
Episodes
(a) μ = +0.1
Figure 6: MDP results
C.2 Mountain Car results
Comparison of four algorithms on Mountain Car under different reward settings is shown in Figure 7.
All experimental results were averaged over 100 runs. Note that for reward variance σ2 = 50, both
Q-learning and Averaged Q-learning fail to reach the goal position in 5, 000 steps so there are no
learning curves shown in Figure 7 (d) for these two algorithms.
C.3 Benchmark Environment results
The sensitivity analysis results of seven benchmark environment are shown in Figure 8.
18
Published as a conference paper at ICLR 2020
(c) Reward 〜N(—1,10)
Figure 7: Mountain Car results
(d) Reward 〜N(—1, 50)
19
Published as a conference paper at ICLR 2020
(a) Catcher
/O9ιo
(b) Pixelcopter
(c) Lunarlander
(d) Asterix
Average
Return
(e) Space Invaders
(f) Breakout
/O9ιo
(g) Seaquest
Figure 8: Sensitivity analysis
20