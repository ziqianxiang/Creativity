Published as a conference paper at ICLR 2020
On the Relationship between Self-Attention
and Convolutional Layers
Jean-Baptiste Cordonnier, Andreas Loukas & Martin Jaggi
Ie 1, 1 ♦	1-1，1 1 T	/1—1 lʌ 1 -T ∖
Ecole PolytechniqUe Federale de LaUsanne (EPFL)
{first.last}@epfl.ch
Ab stract
Recent trends of incorporating attention mechanisms in vision have led re-
searchers to reconsider the sUpremacy of convolUtional layers as a primary bUild-
ing block. Beyond helping CNNs to handle long-range dependencies, Ramachan-
dran et al. (2019) showed that attention can completely replace convolUtion and
achieve state-of-the-art performance on vision tasks. This raises the qUestion: do
learned attention layers operate similarly to convolUtional layers? This work pro-
vides evidence that attention layers can perform convolUtion and, indeed, they of-
ten learn todo so in practice. Specifically, we prove that a mUlti-head self-attention
layer with sUfficient nUmber of heads is at least as expressive as any convolUtional
layer. OUr nUmerical experiments then show that self-attention layers attend to
pixel-grid patterns similarly to CNN layers, corroborating oUr analysis. OUr code
is pUblicly available1 .
1	Introduction
Recent advances in NatUral LangUage Processing (NLP) are largely attribUted to the rise of the trans-
former (Vaswani et al., 2017). Pre-trained to solve an UnsUpervised task on large corpora of text,
transformer-based architectUres, sUch as GPT-2 (Radford et al., 2018), BERT (Devlin et al., 2018)
and Transformer-XL (Dai et al., 2019), seem to possess the capacity to learn the Underlying strUctUre
of text and, as a conseqUence, to learn representations that generalize across tasks. The key differ-
ence between transformers and previoUs methods, sUch as recUrrent neUral networks (Hochreiter &
SchmidhUber, 1997) and convolUtional neUral networks (CNN), is that the former can simUltane-
oUsly attend to every word of their inpUt seqUence. This is made possible thanks to the attention
mechanism—originally introdUced in NeUral Machine Translation to better handle long-range de-
pendencies (BahdanaU et al., 2015). With self-attention in particUlar, the similarity of two words in
a seqUence is captUred by an attention score measUring the distance of their representations. The
representation of each word is then Updated based on those words whose attention score is highest.
Inspired by its capacity to learn meaningfUl inter-dependencies between words, researchers have
recently considered Utilizing self-attention in vision tasks. Self-attention was first added to CNN
by either Using channel-based attention (HU et al., 2018) or non-local relationships across the image
(Wang et al., 2018). More recently, Bello et al. (2019) aUgmented CNNs by replacing some convolU-
tional layers with self-attention layers, leading to improvements on image classification and object
detection tasks. Interestingly, Ramachandran et al. (2019) noticed that, even thoUgh state-of-the
art resUlts are reached when attention and convolUtional featUres are combined, Under same com-
pUtation and model size constraints, self-attention-only architectUres also reach competitive image
classification accUracy.
These findings raise the question, do self-attention layers process images in a similar manner to
convolutional layers? From a theoretical perspective, one coUld argUe that transfomers have the
capacity to simulate any function——including a CNN. Indeed, Perez et al. (2019) showed that a multi-
layer attention-based architectUre with additive positional encodings is TUring complete Under some
strong theoretical assumptions, such as unbounded precision arithmetic. Unfortunately, universality
results do not reveal how a machine solves a task, only that it has the capacity to do so. Thus, the
question of how self-attention layers actually process images remains open.
1Code: github.com/epfml/attention-cnn. Website: epfml.github.io/attention-cnn.
1
Published as a conference paper at ICLR 2020
Contributions. In this work, we put forth theoretical and empirical evidence that self-attention
layers can (and do) learn to behave similar to convolutional layers:
I.	From a theoretical perspective, we provide a constructive proof showing that self-attention
layers can express any convolutional layers.
Specifically, we show that a single multi-head self-attention layer using relative positional encoding
can be re-parametrized to express any convolutional layer.
II.	Our experiments show that the first few layers of attention-only architectures (Ramachan-
dran et al., 2019) do learn to attend on grid-like pattern around each query pixel, similar to
our theoretical construction.
Strikingly, this behavior is confirmed both for our quadratic encoding, but also for relative encoding
that is learned. Our results seem to suggest that localized convolution is the right inductive bias
for the first few layers of an image classifying network. We provide an interactive website2 to
explore how self-attention exploits localized position-based attention in lower layers and content-
based attention in deeper layers. For reproducibility purposes, our code is publicly available.
2	Background on Attention Mechanisms for Vision
We here recall the mathematical formulation of self-attention layers and emphasize the role of posi-
tional encodings.
2.1	The Multi-Head Self-Attention Layer
Let X ∈ RT ×Din be an input matrix consisting of T tokens in of Din dimensions each. While in
NLP each token corresponds to a word in a sentence, the same formalism can be applied to any
sequence of T discrete objects, e.g. pixels. A self-attention layer maps any query token t ∈ [T]
from Din to Dout dimensions as follows:
Self-Attention(X)t,: := softmax (At,:) XWval,	(1)
where we refer to the elements of the T × T matrix
A :=XWqryWke>yX>	(2)
as attention scores and the softmax output3 as attention probabilities. The layer is parametrized
by a query matrix Wqry ∈ RDin ×Dk , a key matrix Wkey ∈ RDin ×Dk and a value matrix Wval ∈
RDin ×Dout .For simplicity, we exclude any residual connections, batch normalization and constant
factors.
A key property of the self-attention model described above is that it is equivariant to reordering, that
is, it gives the same output independently of how the T input tokens are shuffled. This is problematic
for cases we expect the order of things to matter. To alleviate the limitation, a positional encoding
is learned for each token in the sequence (or pixel in an image), and added to the representation of
the token itself before applying self-attention
A:= (X+P)WqryWke>y(X+P)>,	(3)
where P ∈ RT ×Din contains the embedding vectors for each position. More generally, P may be
substituted by any function that returns a vector representation of the position.
It has been found beneficial in practice to replicate this self-attention mechanism into multiple heads,
each being able to focus on different parts of the input by using different query, key and value
matrices. In multi-head self-attention, the output of the Nh heads of output dimension Dh are
concatenated and projected to dimension Dout as follows:
MHSA(X) := concat Self-Attentionh(X) Wout + bout
h∈[Nh]
(4)
and two new parameters are introduced: the projection matrix Wout ∈ RNhDh×Dout and a bias term
bout ∈ RDout .
2epfml.github.io/attention-cnn
3softmax (At,:)k = exp(At,k)/ Pp exp(At,p)
2
Published as a conference paper at ICLR 2020
2.2	Attention for Images
Convolutional layers are the de facto choice for building neural networks that operate on images.
We recall that, given an image tensor X ∈ RW ×H ×Din of width W, height H and Din channels, the
output of a convolutional layer for pixel (i, j) is given by
COnV(X)i,j,： :=	E	Xi+δ1,j+δ2,Wδ1,δ2,"db,	(5)
(δ1,δ2)∈ ∆K
where W is the K × K × Din × Dout weight tensor 4, b ∈ RDout is the bias vector and the set
K
∆∆K :
K
^2
K
^2
K
^2
—
2
×
—
contains all possible shifts appearing when convolving the image with a K × K kernel.
In the following, we review how self-attention can be adapted from 1D sequences to images.
With images, rather than tokens, we have query and key pixels q, k ∈ [W] × [H]. Accordingly, the
input is a tensor X of dimension W × H × Din and each attention score associates a query and a key
pixel.
To keep the formulas consistent with the 1D case, we abuse notation and slice tensors by using a 2D
index vector: ifp = (i, j), we write Xp,: and Ap,: to mean Xi,j,: and Ai,j,:,:, respectively. With this
notation in place, the multi-head self attention layer output at pixel q can be expressed as follows:
Self-AttentiOn(X)q,: =	sOftmax (Aq,:)k Xk,: Wval	(6)
k
and accordingly for the multi-head case.
2.3	Positional Encoding for Images
There are two types of positional encoding that has been used in transformer-based architectures:
the absolute and relative encoding (see also Table 3 in the Appendix).
With absolute encodings, a (fixed or learned) vector Pp,: is assigned to each pixel p. The computa-
tion of the attention scores we saw in eq. (2) can then be decomposed as follows:
Aaqb,ks = (Xq,: + Pq,:)WqryWke>y(Xk,: + Pk,:)>
= Xq,:WqryWke>yXk>,: + Xq,:WqryWk>eyPk>,: + Pq,:WqryWke>yXk,: + Pq,:WqryWke>yPk,:	(7)
where q and k correspond to the query and key pixels, respectively.
The relative positional encoding was introduced by Dai et al. (2019). The main idea is to only
consider the position difference between the query pixel (pixel we compute the representation of)
and the key pixel (pixel we attend) instead of the absolute position of the key pixel:
Aq,k := X>,:Wq>y Wkey Xk,: + X>,W>y Wk”6 + u>‰ Xk,: + V> W^ 了6	(8)
In this manner, the attention scores only depend on the shift δ := k - q. Above, the learnable
vectors u and v are unique for each head, whereas for every shift δ the relative positional encoding
rδ ∈ RDp is shared by all layers and heads. Moreover, now the key weights are split into two types:
Wkey pertain to the input and Wkey to the relative position of pixels.
3	Self-Attention as a Convolutional Layer
This section derives sufficient conditions such that a multi-head self-attention layer can simulate a
convolutional layer. Our main result is the following:
Theorem 1. A multi-head self-attention layer with Nh heads of dimension Dh, output dimen-
sion Dout and a relative positional encoding of dimension Dp ≥ 3 can express any convolutional
layer ofkernel size √Nh X √Nh and min(Dh, Dout) output channels.
4To simplify notation, we index the first two dimensions of the tensor from -bK/2c to bK/2c.
3
Published as a conference paper at ICLR 2020
The theorem is proven constructively by selecting the parameters of the multi-head self-attention
layer so that the latter acts like a convolutional layer. In the proposed construction, the attention
scores of each self-attention head should attend to a different relative shift within the set ∆∆K =
{-bK/2c, . . . , bK/2c}2 of all pixel shifts in a K × K kernel. The exact condition can be found in
the statement of Lemma 1.
Then, Lemma 2 shows that the aforementioned condition is satisfied for the relative positional en-
coding that we refer to as the quadratic encoding:
v(h):= -α(h) (1, -2∆(1h), -2∆(2h)) rδ:= (kδk2, δ1, δ2) Wqry=Wkey:=0 Wdkey:= I (9)
The learned parameters ∆(h) = (∆(1h), ∆(2h)) and α(h) determine the center and width of attention
of each head, respectively. On the other hand, δ = (δ1 , δ2) is fixed and expresses the relative shift
between query and key pixels.
It is important to stress that the above encoding is not the only one for which the conditions of
Lemma 1 are satisfied. In fact, in our experiments, the relative encoding learned by the neural
network also matched the conditions of the lemma (despite being different from the quadratic en-
coding). Nevertheless, the encoding defined above is very efficient in terms of size, as only Dp = 3
dimensions suffice to encode the relative position of pixels, while also reaching similar or better
empirical performance (than the learned one).
The theorem covers the general convolution operator as defined in eq. (17). However, machine
learning practitioners using differential programming frameworks (Paszke et al., 2017; Abadi et al.,
2015) might question if the theorem holds for all hyper-parameters of 2D convolutional layers:
•	Padding: a multi-head self-attention layer uses by default the "SAME" padding while a
convolutional layer would decrease the image size by K - 1 pixels. The correct way to
alleviate these boundary effects is to pad the input image with bK/2c zeros on each side.
In this case, the cropped output of a MHSA and a convolutional layer are the same.
•	Stride: a strided convolution can be seen as a convolution followed by a fixed pooling
operation—with computational optimizations. Theorem 1 is defined for stride 1, but a
fixed pooling layer could be appended to the Self-Attention layer to simulate any stride.
•	Dilation: a multi-head self-attention layer can express any dilated convolution as each head
can attend a value at any pixel shift and form a (dilated) grid pattern.
Remark for the 1D case. Convolutional layers acting on sequences are commonly used in the lit-
erature for text (Kim, 2014), as well as audio (van den Oord et al., 2016) and time series (Franceschi
et al., 2019). Theorem 1 can be straightforwardly extended to show that multi-head self-attention
with Nh heads can also simulate a 1D convolutional layer with a kernel of size K = Nh with
min(Dh , Dout) output channels using a positional encoding of dimension Dp ≥ 2. Since we have
not tested empirically if the preceding construction matches the behavior of 1D self-attention in
practice, we cannot claim that it actually learns to convolve an input sequence—only that it has the
capacity to do so.
Proof of Main Theorem
The proof follows directly from Lemmas 1 and 2 stated below:
Lemma 1. Consider a multi-head self-attention layer consisting of Nh = K2 heads, Dh ≥ Dout
and let f : [Nh] → ∆∆K be a bijective mapping of heads onto shifts. Further, suppose that for
every head the following holds:
softmax(A(qh:))k = 1	iff(h) = q - k	(10)
q,:	0 otherwise.
Then, for any convolutional layer with a K × K kernel and Dout output channels, there exists
{Wv(ahl)}h∈[Nh] suchthatMHSA(X) = Conv(X) for every X ∈ RW×H×Din.
4
Published as a conference paper at ICLR 2020
Multi-Head Self-Attention Layer
∑ X札;A«网
k,e∏V]×[H]
Attention maps for pixel q
Filter matrices
2 ×
Figure 1: Illustration of a Multi-Head Self-Attention layer applied to a tensor image X. Each head h
attends pixel values around shift ∆(h) and learn a filter matrix Wv(ahl ) . We show attention maps
computed for a query pixel at position q .
Proof. Our first step will be to rework the expression of the Multi-Head Self-Attention operator from
equation (1) and equation (4) such that the effect of the multiple heads becomes more transparent:
MHSA(X) =bout+ X softmax(A(h))XWv(ahl)Wout[(h- 1)Dh+1 : hDh+1]	(11)
I y.,	।-------------------------------}
{z∖^"^
W(h)
h∈[Nh]
Note that each head’s value matrix Wv(ahl ) ∈ RDin ×Dh and each block of the projection matrix Wout
of dimension Dh × Dout are learned. Assuming that Dh ≥ Dout, we can replace each pair of
matrices by a learned matrix W (h) for each head. We consider one output pixel of the multi-head
self-attention:
MHSA(X)q,: = X	Xsoftmax(A(qh,:))kXk,: W(h)+bout	(12)
h∈[Nh]	k
Due to the conditions of the Lemma, for the h-th attention head the attention probability is one when
k = q - f(h) and zero otherwise. The layer’s output at pixel q is thus equal to
MHSA(X)q =	Xq-f(h),:W(h) + bout
h∈[Nh]
(13)
For K = √Nh, the above can be seen to be equivalent to a convolutional layer expressed in eq. 17:
there is a one to one mapping (implied by map f) between the matrices W(h) for h = [Nh] and the
matrices Wk.,：,： forall (k1,k2) ∈ [K]2.	□
Remark about Dh and Dout. It is frequent in transformer-based architectures to set
Dh = Dout/Nh, hence Dh < Dout. In that case, W (h) can be seen to be of rank Dout - Dh,
which does not suffice to express every convolutional layer with Dout channels. Nevertheless, it can
be seen that any Dh out of Dout outputs of MHSA(X) can express the output of any convolutional
layer with Dh output channels. To cover both cases, in the statement of the main theorem we assert
that the output channels of the convolutional layer should be min(Dh, Dout). In practice, we advise
to concatenate heads of dimension Dh = Dout instead of splitting the Dout dimensions among heads
to have exact re-parametrization and no “unused” channels.
Lemma 2. There exists a relative encoding scheme {rδ ∈ RDp }δ∈Z2 with Dp ≥ 3 and parame-
ters Wqry , Wkey , Wkey , u with Dp ≤ Dk such that, for every ∆ ∈ ∆∆K there exists some vector v
(conditioned on ∆) yielding softmax(Aq,：)k = 1 if k - q = ∆ and zero, otherwise.
Proof. We show by construction the existence of a Dp = 3 dimensional relative encoding scheme
yielding the required attention probabilities.
5
Published as a conference paper at ICLR 2020
As the attention probabilities are independent of the input tensor X, we set Wkey = Wqry = 0 which
leaves only the last term of eq. (8). Setting Wckey ∈ RDk×Dp to the identity matrix (with appropriate
row padding), yields Aq,k = v>rδ where δ := k - q. Above, we have assumed that Dp ≤ Dk
such that no information from rδ is lost.
Now, suppose that we could write:
Aq,k=-α(kδ-∆k2+c)
(14)
for some constant c. In the above expression, the maximum attention score over Aq,: is -αc and it
is reached for Aq,k with δ = ∆. On the other hand, the α coefficient can be used to scale arbitrarily
the difference between Aq,∆ and the other attention scores.
In this way, for δ = ∆, we have
e-α(kδ-∆k2+c)
αl→∞ SoftmaX(Aq,：)k = αl→∞ P ,e-α(k(k-q,)-∆k2 + c)
k0
e-αkδ-∆k2	1
=lim ----------------------=----------------------------------= 1
α→∞ Pk0 e-ak(k-qO)-52	1+limα→∞ Pko=k e-αk(k-q' fk2	1
and for δ 6= ∆, the equation becomes limα→∞ softmaX(Aq,:)k = 0, exactly as needed to satisfy
the lemma statement.
What remains is to prove that there exist v and {rδ}δ∈Z2 for which eq. (14) holds. Expanding the
RHS of the equation, we have -α(kδ - ∆k2 + c) = -α(kδk2 + k∆k2 - 2hδ, ∆i + c) . Now ifwe
set v = -α (1, -2∆1, -2∆2) and rδ = (kδk2, δ1, δ2), then
Aq,k = v>rδ = -α(kδk2-2∆1δ1-2∆2δ2) = -α(kδk2-2hδ,∆i) = -α(kδ-∆k2-k∆k2),
which matches eq. (14) with C = -∣∣ ∆ k2 and the proof is concluded.	□
Remark on the magnitude of α. The exact representation of one pixel requires α (or the matrices
Wqry and Wkey) to be arbitrary large, despite the fact that the attention probabilities of all other
pixels converge exponentially to 0 as α grows. Nevertheless, practical implementations always rely
on finite precision arithmetic for which a constant α suffices to satisfy our construction. For instance,
since the smallest positive float32 scalar is approximately 10-45, setting α = 46 would suffice
to obtain hard attention.
4	Experiments
The aim of this section is to validate the applicability of our theoretical results—which state that
self-attention can perform convolution—and to examine whether self-attention layers in practice
do actually learn to operate like convolutional layers when trained on standard image classification
tasks. In particular, we study the relationship between self-attention and convolution with quadratic
and learned relative positional encodings. We find that, for both cases, the attention probabilities
learned tend to respect the conditions of Lemma 1, supporting our hypothesis.
4.1	Implementation Details
We study a fully attentional model consisting of six multi-head self-attention layers. As it has already
been shown by Bello et al. (2019) that combining attention features with convolutional features
improves performance on Cifar-100 and ImageNet, we do not focus on attaining state-of-the-art
performance. Nevertheless, to validate that our model learns a meaningful classifier, we compare
it to the standard ResNet18 (He et al., 2015) on the CIFAR-10 dataset (Krizhevsky et al.). In all
experiments, we use a 2 × 2 invertible down-sampling (Jacobsen et al., 2018) on the input to reduce
the size of the image. As the size of the attention coefficient tensors (stored during forward) scales
quadratically with the size of the input image, full attention cannot be applied to bigger images.
The fixed size representation of the input image is computed as the average pooling of the last layer
representations and given to a linear classifier.
6
Published as a conference paper at ICLR 2020
Epoch
Figure 2: Test accuracy on CIFAR-10.
Models	accuracy	# of params	# of FLOPS
ResNet18	0.938	11.2M	1.1B
SA quadratic emb.	0.938	12.1M	6.2B
SA learned emb.	0.918	12.3M	6.2B
SA learned emb. + content	0.871	29.5M	15B
Table 1: Test accuracy on CIFAR-10 and model
sizes. SA stands for Self-Attention.
Figure 3: Centers of attention of each attention head (different colors) at layer 4 during the training
with quadratic relative positional encoding. The central black square is the query pixel, whereas
solid and dotted circles represent the 50% and 90% percentiles of each Gaussian, respectively.
We used the PyTorch library (Paszke et al., 2017) and based our implementation on PyTorch Trans-
formers5. We release our code on Github6 and hyper-parameters are listed in Table 2 (Appendix).
Remark on accuracy. To verify that our self-attention models perform reasonably well, we dis-
play in Figure 6 the evolution of the test accuracy on CIFAR-10 over the 300 epochs of training
for our self-attention models against a small ResNet (Table 1). The ResNet is faster to converge,
but we cannot ascertain whether this corresponds to an inherent property of the architecture or an
artifact of the adopted optimization procedures. Our implementation could be optimized to exploit
the locality of Gaussian attention probabilities and reduce significantly the number of FLOPS. We
observed that learned embeddings with content-based attention were harder to train probably due to
their increased number of parameters. We believe that the performance gap can be bridged to match
the ResNet performance, but this is not the focus of this work.
4.2	Quadratic Encoding
As a first step, we aim to verify that, with the relative position encoding introduced in equation (9),
attention layers learn to behave like convolutional layers. We train nine attention heads at each layer
to be on par with the 3 × 3 kernels used predominantly by the ResNet architecture. The center of
attention of each head h is initialized to ∆(h) 〜N(0, 2I2).
Figure 3 shows how the initial positions of the heads (different colors) at layer 4 changed during
training. We can see that after optimization, the heads attend on specific pixel of the image forming a
grid around the query pixel. Our intuition that Self-Attention applied to images learns convolutional
filters around the queried pixel is confirmed.
Figure 4 displays all attention head at each layer of the model at the end of the training. It can be
seen that in the first few layers the heads tend to focus on local patterns (layers 1 and 2), while deeper
layers (layers 3-6) also attend to larger patterns by positioning the center of attention further from
the queried pixel position. We also include in the Appendix a plot of the attention positions for a
higher number of heads (Nh = 16). Figure 14 displays both local patterns similar to CNN and long
range dependencies. Interestingly, attention heads do not overlap and seem to take an arrangement
maximizing the coverage of the input space.
5github.com/huggingface/pytorch-transformers
6github.com/epfml/attention-cnn
7
Published as a conference paper at ICLR 2020
Figure 4: Centers of attention of each attention head (different colors) for the 6 self-attention layers
using quadratic positional encoding. The central black square is the query pixel, whereas solid and
dotted circles represent the 50% and 90% percentiles of each Gaussian, respectively.
4.3	Learned Relative Positional Encoding
We move on to study the positional encoding used in practice by fully-attentional models on images.
We implemented the 2D relative positional encoding scheme used by (Ramachandran et al., 2019;
Bello et al., 2019): we learn a bDp/2c position encoding vector for each row and each column pixel
shift. Hence, the relative positional encoding of a key pixel at position k with a query pixel at posi-
tion q is the concatenation of the row shift embedding δ1 and the column shift embedding δ2 (where
δ = k - q). We chose Dp = Dout = 400 in the experiment. We differ from their (unpublished)
implementation in the following points: (i) we do not use convolution stem and ResNet bottlenecks
for downsampling, but only a 2 × 2 invertible downsampling layer (Jacobsen et al., 2018) at input,
(ii) we use Dh = Dout instead of Dh = Dout/Nh backed by our theory that the effective number of
learned filters is min(Dh, Dout).
At first, we discard the input data and compute the attention scores solely as the last term of eq. (8).
The attention probabilities of each head at each layer are displayed on Figure 5. The figure confirms
our hypothesis for the first two layers and partially for the third: even when left to learn the positional
encoding scheme from randomly initialized vectors, certain self-attention heads (depicted on the left)
learn to attend to individual pixels, closely matching the condition of Lemma 1 and thus Theorem
1. At the same time, other heads pay attention to horizontally-symmetric but non-localized patterns,
as well as to long-range pixel inter-dependencies.
We move on to a more realistic setting where the attention scores are computed using both positional
and content-based attention (i.e., q>k + q>r in (Ramachandran et al., 2019)) which corresponds to
a full-blown standalone self-attention model.
The attention probabilities of each head at each layer are displayed in Figure 6. We average the
attention probabilities over a batch of 100 test images to outline the focus of each head and remove
the dependency on the input image. Our hypothesis is confirmed for some heads of layer 2 and 3:
even when left to learn the encoding from the data, certain self-attention heads only exploit position-
based attention to attend to distinct pixels at a fixed shift from the query pixel reproducing the
receptive field of a convolutional kernel. Other heads use more content-based attention (see Figures 8
to 10 in Appendix for non-averaged probabilities) leveraging the advantage of Self-Attention over
CNN which does not contradict our theory. In practice, it was shown by Bello et al. (2019) that
combining CNN and self-attention features outperforms each taken separately. Our experiments
shows that such combination is learned when optimizing an unconstrained fully-attentional model.
The similarity between convolution and multi-head self-attention is striking when the query pixel is
slid over the image: the localized attention patterns visible in Figure 6 follow the query pixel. This
characteristic behavior materializes when comparing Figure 6 with the attention probabilities at a
different query pixel (see Figure 7 in Appendix). Attention patterns in layers 2 and 3 are not only
localized but stand at a constant shift from the query pixel, similarly to convolving the receptive
field of a convolutional kernel over an image. This phenomenon is made evident on our interactive
website7. This tool is designed to explore different components of attention for diverse images with
or without content-based attention. We believe that it is a useful instrument to further understand
how MHSA learns to process images.
7epfml.github.io/attention-cnn
8
Published as a conference paper at ICLR 2020
Figure 5: Attention probabilities of each head (column) at each layer (row) using learned relative
positional encoding without content-based attention. The central black square is the query pixel. We
reordered the heads for visualization and zoomed on the 7x7 pixels around the query pixel.
Figure 6: Attention probabilities for a model with 6 layers (rows) and 9 heads (columns) using
learned relative positional encoding and content-content based attention. Attention maps are aver-
aged over 100 test images to display head behavior and remove the dependence on the input content.
The black square is the query pixel. More examples are presented in Appendix A.
9
Published as a conference paper at ICLR 2020
5	Related Work
In this section, we review the known differences and similarities between CNNs and transformers.
The use of CNN networks for text—at word level (Gehring et al., 2017) or character level (Kim,
2014)—is more seldom than transformers (or RNN). Transformers and convolutional models have
been extensively compared empirically on tasks of Natural Language Processing and Neural Ma-
chine Translation. It was observed that transformers have a competitive advantage over convolu-
tional model applied to text (Vaswani et al., 2017). It is only recently that Bello et al. (2019);
Ramachandran et al. (2019) used transformers on images and showed that they achieve similar ac-
curacy as ResNets. However, their comparison only covers performance and number of parameters
and FLOPS but not expressive power.
Beyond performance and computational-cost comparisons of transformers and CNN, the study of
expressiveness of these architectures has focused on their ability to capture long-term dependencies
(Dai et al., 2019). Another interesting line of research has demonstrated that transformers are Turing-
complete (Dehghani et al., 2018; Perez et al., 2019), which is an important theoretical result but is
not informative for practitioners. To the best of our knowledge, we are the first to show that the class
of functions expressed by a layer of self-attention encloses all convolutional filters.
The closest work in bridging the gap between attention and convolution is due to Andreoli
(2019). They cast attention and convolution into a unified framework leveraging tensor outer-
product. In this framework, the receptive field of a convolution is represented by a “basis” tensor
A ∈ RK×K×H×W ×H×W . For instance, the receptive field of a classical K × K convolutional
kernel would be encoded by A∆,q,k = l{k - q = ∆} for ∆ ∈ ∆∆K . The author distinguishes
this index-based convolution with content-based convolution where A is computed from the value
of the input, e.g., using a key/query dot-product attention. Our work moves further and presents
sufficient conditions for relative positional encoding injected into the input content (as done in prac-
tice) to allow content-based convolution to express any index-based convolution. We further show
experimentally that such behavior is learned in practice.
6	Conclusion
We showed that self-attention layers applied to images can express any convolutional layer (given
sufficiently many heads) and that fully-attentional models learn to combine local behavior (similar
to convolution) and global attention based on input content. More generally, fully-attentional mod-
els seem to learn a generalization of CNNs where the kernel pattern is learned at the same time as
the filters—similar to deformable convolutions (Dai et al., 2017; Zampieri, 2019). Interesting di-
rections for future work include translating existing insights from the rich CNNs literature back to
transformers on various data modalities, including images, text and time series.
Acknowledgments
Jean-Baptiste Cordonnier is thankful to the Swiss Data Science Center (SDSC) for funding this
work. Andreas Loukas was supported by the Swiss National Science Foundation (project “Deep
Learning for Graph Structured Data”, grant number PZ00P2 179981).
10
Published as a conference paper at ICLR 2020
References
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S.
Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew
Harp, Geoffrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz Kaiser, Manjunath
Kudlur, Josh Levenberg, Dan Mane, Rajat Monga, Sherry Moore, Derek Murray, Chris Olah,
Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker, Vin-
cent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden, Martin Watten-
berg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. TensorFlow: Large-scale machine learning
on heterogeneous systems, 2015. Software available from tensorflow.org.
Jean-Marc Andreoli. Convolution, attention and structure embedding. NeurIPS 2019 workshop on
Graph Representation Learning, Dec 13, 2019, Vancouver, BC, Canada, 2019.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. In 3rd International Conference on Learning Representations,
ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings, 2015.
Irwan Bello, Barret Zoph, Ashish Vaswani, Jonathon Shlens, and Quoc V. Le. Attention Augmented
Convolutional Networks. arXiv:1904.09925 [cs], April 2019.
Jifeng Dai, Haozhi Qi, Yuwen Xiong, Yi Li, Guodong Zhang, Han Hu, and Yichen Wei. Deformable
convolutional networks. CoRR, abs/1703.06211, 2017.
Zihang Dai, Zhilin Yang, Yiming Yang, Jaime G. Carbonell, Quoc V. Le, and Ruslan Salakhut-
dinov. Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context. CoRR,
abs/1901.02860, 2019.
Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and Lukasz Kaiser. Universal
transformers. CoRR, abs/1807.03819, 2018.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: pre-training of deep
bidirectional transformers for language understanding. CoRR, abs/1810.04805, 2018.
Jean-Yves Franceschi, Aymeric Dieuleveut, and Martin Jaggi. Unsupervised scalable representation
learning for multivariate time series. In NeurIPS 2019, 2019.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N. Dauphin. Convolutional
sequence to sequence learning. CoRR, abs/1705.03122, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. CoRR, abs/1512.03385, 2015.
SePP Hochreiter and JUrgen Schmidhuber. Long short-term memory. Neural Computation, 9(8):
1735-1780,1997.
Jie Hu, Li Shen, and Gang Sun. Squeeze-and-excitation networks. In 2018 IEEE Conference on
Computer Vision and Pattern Recognition, CVPR 2018, Salt Lake City, UT, USA, June 18-22,
2018, PP. 7132-7141, 2018.
Jorn-Henrik Jacobsen, Arnold W.M. Smeulders, and Edouard Oyallon. i-revnet: Deep invertible
networks. In International Conference on Learning Representations, 2018.
Yoon Kim. Convolutional neural networks for sentence classification. In Proceedings of the
2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), PP. 1746-
1751, Doha, Qatar, October 2014. Association for ComPutational Linguistics. doi: 10.3115/v1/
D14-1181.
Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton. Cifar-10 (canadian institute for advanced re-
search).
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
PyTorch. In NIPS Autodiff Workshop, 2017.
11
Published as a conference paper at ICLR 2020
Jorge Perez, Javier Marinkovic, and Pablo Barcelo. On the turing completeness of modern neural
network architectures. CoRR, abs/1901.03429, 2019.
Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language
models are unsupervised multitask learners. 2018.
Prajit Ramachandran, Niki Parmar, Ashish Vaswani, Irwan Bello, Anselm Levskaya, and Jonathon
Shlens. Stand-alone self-attention in vision models. CoRR, abs/1906.05909, 2019.
Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alexander
Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. Wavenet: A generative
model for raw audio. arXiv preprint arXiv:1609.03499, 2016.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez,
Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. CoRR, abs/1706.03762, 2017.
Xiaolong Wang, Ross B. Girshick, Abhinav Gupta, and Kaiming He. Non-local neural networks. In
2018 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2018, Salt Lake City,
UT USA, June 18-22, 2018,pp. 7794-7803, 2018.
Zhilin Yang, Zihang Dai, Yiming Yang, Jaime G. Carbonell, Ruslan Salakhutdinov, and Quoc V.
Le. Xlnet: Generalized autoregressive pretraining for language understanding.	CoRR,
abs/1906.08237, 2019.
Luca Zampieri. Geometric deep learning for volumetric computational fluid dynamics. pp. 67,
2019.
12
Published as a conference paper at ICLR 2020
Appendix
A More Examples with Content-based Attention
We present more examples of attention probabilities computed by self-attention model. Figure 7
Figure 7: Attention probabilities for a model with 6 layers (rows) and 9 heads (columns) using
learned relative positional encoding and content-content attention. We present the average of 100
test images. The black square is the query pixel.
Figure 8: Attention probabilities for a model with 6 layers (rows) and 9 heads (columns) using
learned relative positional encoding and content-content based attention. The query pixel (black
square) is on the frog head.
13
Published as a conference paper at ICLR 2020
Figure 9: Attention probabilities for a model with 6 layers (rows) and 9 heads (columns) using
learned relative positional encoding and content-content based attention. The query pixel (black
square) is on the horse head.
Figure 10: Attention probabilities for a model with 6 layers (rows) and 9 heads (columns) using
learned relative positional encoding and content-content based attention. The query pixel (black
square) is on the building in the background.
14
Published as a conference paper at ICLR 2020
B Hyper-parameters used in our Experiments
Hyper-parameters	
number of layers	6
number of heads	9
hidden dimension	400
intermediate dimension	512
invertible pooling width	2
dropout probability	0.1
layer normalization epsilon	10-12
number of epochs	300
batch size	100
learning rate	0.1
weight decay	0.0001
momentum	0.9
cosine decay	X
linear warm up ratio	0.05
Table 2: Self-attention network parameters
C Positional Encoding References
Model	type of positional encoding			relative
	sinusoids	learned	quadratic	
Vaswani et al. (2017)	X			
Radford et al. (2018)		X		
Devlin et al. (2018)		X		
Dai et al. (2019)	X			X
Yang et al. (2019)	X			X
Bello et al. (2019)		X		X
Ramachandran et al. (2019)		X		X
Our work		X	X	X
Table 3: Types of positional encoding used by transformers models applied to text (top) and images
(bottom). When multiple encoding types have been tried, we report the one advised by the authors.
D	Generalized Lemma 1
We present a generalization of Lemma 1 that replaces the necessity of hard attention (to single
pixels) by a milder assumption: the attention probabilities should span the grid receptive field. The
conditions of this Lemma are still satisfied by Lemma 2, hence Theorem 1 follows.
Lemma 3. Consider a multi-head self-attention layer consisting of Nh ≥ K2 heads, Dh ≥ Dout
and letω : [H] × [W] → [HW] be a pixel indexing. Then, for any convolutional layer with a K ×
K kernel and Dout output channels, there exists {Wv(ahl ) }h∈[Nh] and Wout such that MHSA(X) =
Conv(X) for every X ∈ RW ×H ×Din if and only if, for all q ∈ [H] × [W], 8
span({eω(q+∆) ∈ RHW : ∆ ∈ ∆∆K}) ⊆ span({vect(softmax(A(qh,:))) : h ∈ [Nh]}) .
8the vectorization operator vect(∙) flattens a matrix into a vector
15
Published as a conference paper at ICLR 2020
*- eω(q+Δ)
HW
Eq
an。QWQ
3 VOaEQ
WCOnV
Figure 11: Factorization of the vectorized weight matrices Vqconv and VqSA used to compute the
output at position q for an input image of dimension H × W . On the left: a convolution of kernel
2 × 2, on the right: a self-attention with Nh = 5 heads. Din = 2, Dout = 3 in both cases.
0			0			0
						
						
						
						
						
VeCt(W△,；,：)
Proof. Our first step will be to rework the expression of the Multi-Head Self-Attention operator from
equation (1) and equation (4) such that the effect of the multiple heads becomes more transparent:
MHSA(X) =bout+ X softmax(A(h))XWv(ahl)Wout[(h- 1)Dh+1 : hDh+1]	(15)
、y. I	X------------------------------}
^^{^^™
W(h)
h∈[Nh]
Note that each head’s value matrix Wv(ahl ) ∈ RDin ×Dh and each block of the projection matrix Wout
of dimension Dh × Dout are learned. Assuming that Dh ≥ Dout, we can replace each pair of
matrices by a learned matrix W (h) for each head. We consider one output pixel of the multi-head
self-attention and drop the bias term for simplicity:
MHSA(X)q,: = X	Xa(qh,k)Xk,:W(h)=XXk,:	X a(qh,k)W(h),	(16)
h∈[Nh]	k	k	h∈[Nh]
`---------{---------}
WSA ∈RDin ×Dout
with a(qh,k) = softmax(A(qh,:))k. We rewrite the output of a convolution at pixel q in the same manner:
COnV(X)q,:= E Xq+∆,,W∆,:,: = E	Xk,： 1
∆∈ ∆κ	k∈[H]×[W ]	J
{k-q∈ ∆K}Wk-q,:,: .
___________ J
{^^^^^^^^^^^^
Wqco,nkv∈RD
in ×Dout
(17)
Equality between equations (16) and (17) holds for any input X if and only if the linear transfor-
mations for each pair of key/query pixels are equal, i.e. Wqc,oknv = WqS,Ak ∀q, k. We vectorize the
weight matrices into matrices of dimension DinDout × HW as Vqconv := [Vect(Wqc,oknv)]k∈[H]×[W]
and VqSA := [Vect(WqS,Ak)]k∈[H]×[W] . Hence, to show that COnV(X) = MHSA(X) for all X, we
must show that Vqconv = VqSA for all q.
The matrix Vqconv has a restricted support: only the columns associated with a pixel shift ∆ ∈ ∆∆K
in the receptive field of pixel q can be non-zero. This leads to the factorization Vqconv = W convEq
displayed in Figure 11 where W conv ∈ RDinDout×K2 and Eq ∈ RK2×HW. Given an ordering of
the shifts ∆ ∈ ∆∆κ indexed by j, set (Wconv)：,j = Vect(WΑ：,：) and (Eq)j,： = eω(q+∆).On the
other hand, we decompose VqSA = WSAAq with (W SA)：,h = Vect(W(h)) and (Aq)h,i = a(qh,ω) (i).
The proof is concluded by showing that rOw(Eq) ⊆ rOw(Aq) is a necessary and sufficient condition
for the existence of a WSA such that any Vqconv = WconvEq can be written as WSAAq .
Sufficient. Given that rOw(Eq) ⊆ rOw(Aq), there exists Φ ∈ RK2×Nh such that Eq = ΦAq and a
valid decomposition is WSA = WconvΦ which gives WSAAq = Vqconv.
Necessary. Assume there exists x ∈ RHW such that x ∈ rOw(Eq) and x 6∈ rOw(Aq) and set x>
to be a row of Vqconv. Then, WSAAq 6= Vqconv for any WSA and there is no possible decomposition.
□
16
Published as a conference paper at ICLR 2020
E Generalized Quadratic Positional Encoding
We noticed the similarity of the attention probabilities in the quadratic positional encoding (Sec-
tion 3) to isotropic bivariate Gaussian distributions with bounded support:
softmax(Aq,:)k =
e-αk(k-q)-∆k2
P ∈[W]×[H a-w-qfk2.
(18)
Building on this observation, we further extended our attention mechanism to non-isotropic Gaus-
sian distribution over pixel positions. Each head is parametrized by a center of attention ∆ and a
covariance matrix Σ to obtain the following attention scores,
Aq,k = - 1(δ - ∆)>∑-1 (δ - ∆) = -2δ>Σ-1 δ + δ>Σ-1 ∆ - 2∆>Σ-1 ∆ ,	(19)
where, once more, δ = k - q. The last term can be discarded because the softmax is shift invariant
and we rewrite the attention coefficient as a dot product between the head target vector v and the
relative position encoding rδ (consisting of the first and second order combinations of the shift in
pixels δ):
V = 2(2(Σ-1 ∆)ι, 2(Σ-1 ∆)2, -Σ-,1, -Σ-,2, -2 ∙ Σ[,2)> and r = (δι, δ2, δ2, δ2, διδ2)> .
Evaluation. We trained our model using this generalized quadratic relative position encoding. We
were curious to see if, using the above encoding the self-attention model would learn to attend to
non-isotropic groups of pixels—thus forming unseen patterns in CNNs. Each head was parametrized
by ∆ ∈ R2 and Σ-1/2 ∈ R2×2 to ensure that the covariance matrix remained positive semi-definite.
We initialized the center of attention to ∆(h) 〜N(0, 2I2) and Σ-1/2 = I2 + N(0, 0.01I2) so that
initial attention probabilities were close to an isotropic Gaussian. Figure 12 shows that the network
did learn non-isotropic attention probability patterns, especially in high layers. Nevertheless, the fact
that we do not obtain any performance improvement seems to suggest that attention non-isotropy is
not particularly helpful in practice—the quadratic positional encoding suffices.
using non-isotropic Gaussian parametrization. The central black square is the query pixel, whereas
solid and dotted circles represent the 50% and 90% percentiles of each Gaussian, respectively.
Pruning degenerated heads. Some non-isotropic attention heads attend on “non-intuitive”
patches of pixels: either attending a very thin stripe of pixels, when Σ-1 was almost singular, or
attending all pixels uniformly, when Σ-1 was close to 0 (i.e. constant attention scores). We asked
ourselves, are such attention patterns indeed useful for the model or are these heads degenerated and
unused? To find out, we pruned all heads having largest eigen-values smaller than 10-5 or condition
number (ratio of the biggest and smallest eigen-values) greater than 105. Specifically in our model
with 6-layer and 9-heads each, we pruned [2, 4, 1, 2, 6, 0] heads from the first to the last layer. This
means that these layers cannot express a 3 × 3 kernel anymore. As shown in yellow on fig. 2, this
ablation initially hurts a bit the performance, probably due to off biases, but after a few epochs of
continued training with a smaller learning rate (divided by 10) the accuracy recovers its unpruned
value. Hence, without sacrificing performance, we reduce the size of the parameters and the number
of FLOPS by a fourth.
F	Increasing the Number of Heads
For completeness, we also tested increasing the number of heads of our architecture from 9 to 16.
17
Published as a conference paper at ICLR 2020
Epoch
Models	accuracy	# of params	# of FLOPS
ResNet18	0.938	11.2M	1.1B
SA quadratic emb.	0.938	12.1M	6.2B
SA quadratic emb. gen.	0.934	12.1M	6.2B
SA quadratic emb. gen. pruned	0.934	9.7M	4.9B
SA learned emb.	0.918	12.3M	6.2B
SA learned emb. + content	0.871	29.5M	15B
Table 4: Number of parameters and accuracy
on CIFAR-10 per model. SA stands for Self-
Attention.
Figure 13: Evolution of test accuracy on CIFAR-
10. Pruned model (yellow) is continued training
of the non-isotropic model (orange).
using quadratic positional encoding. The central black square is the query pixel, whereas solid and
dotted circles represent the 50% and 90% percentiles of each Gaussian, respectively.
Similar to Figure 4, we see that the network distinguishes two main types of attention patterns.
Localized heads (i.e., those that attend to nearly individual pixels) appear more frequently in the first
few layers. The self-attention layer uses these heads to act in a manner similar to how convolutional
layers do. Heads with less-localized attention become more common at higher layers.
18