Figure 1: Comparison of synthesis with property signatures and without property signatures. Thex-axis denotes time elapsed in seconds. Roughly speaking, we let the distributed synthesizer runfor 1 day. The y-axis represenets the cumulative number of programs synthesized. On average, thebaseline solved 28 of the test programs, while the baseline enhanced with property signatures solved73 test programs (around 2.6 times as many programs). Both the baseline and the run with propertysignatures were run with three different random seeds. Altogether, this experiment provides strongevidence that property signatures can be useful.
Figure 2: The top-down synthesizer that we use as a baseline in this work. In a loop until a satisfyingprogram is found or we run out of time, we pop the lowest-cost partial program from the queue of allpartial programs, then we fill in the holes in all ways allowed by the type system, pushing each newpartial program back onto the queue. If there are no holes to fill, the program is complete, and wecheck it against the spec. The cost of a partial program is the sum of the costs of its pool elements,plus a lower bound on the cost of filling each of its typed holes, plus the sum of the costs of a fewspecial operations such as tuple construction and lambda abstraction.
