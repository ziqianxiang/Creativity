Figure 1: Example Loop Invariant inference problem.
Figure 2: Illustration of the mapping S on >, ≥, = when B = 20 and = 0.2When e goes to zero and B * e goes to infinity, our continuous mapping of “>" and "≥" will preservetheir original semantics. Under these conditions, our mapping satisfies all three desirable properties.
Figure 3: System architecture and CLN construction from SMT templates.
Figure 4:	Performance evaluation.
Figure 5:	Finding the loop invariant for Problem 1, which involves a disjunction of equalitiesAnother problem with multivariable conjunction is shown in Figure 6. In this program, we useunknown to denote an external function call that returns either true or false. As we cannot assumemuch about the function, we model the function call as sampling from a Bernoulli distribution withsuccess probability 0.5. Although the branching behavior is may not be deterministic, we know(t + u = 0) ∧ (v + w = 0) ∧ (u + w ≥ 0) is a correct invariant, as it holds regardless of whichbranch is taken. Our CLN2INV can learn this invariant within 20 seconds, while both Code2inv andLoopInvGen time out after one hour without finding a solution.
Figure 6:	Pseudocode for Problem 2, which involves a conjunction of equalitiessummations, which have many more higher order terms. We do not evaluate the other methods onthese problems because they are not configured for nonlinear arithmetic by default.
Figure 7:	Ablation study comparing static vs trained models.
Figure 8: Illustration of how training data is generated. After the sampling procedure in (b) we havea collection of 88 samples which will later be fed to the CLN model.
Figure 9: Pseudocode for Polynomial Invariant ProblemThe example loop in Figure 9 computes the sum of the first k cubes. We know this sum has a closedform solution:kXk3i=0k2(k + 1)2	k4+2k3+k244For this problem, we would hope to extract the invariant:(4u = t4 + 2t3 + t2) ∧ (t <= k)However, by naively using the polynomial kernel just as methods like NumInv suggest (Nguyenet al., 2017), we will have 35 monomials of degree at most four over three variables as candidateterms (t3u, t2k2, tu2k, ...), and the model must learn to ignore all the terms except u, t4, t3, and t2.
