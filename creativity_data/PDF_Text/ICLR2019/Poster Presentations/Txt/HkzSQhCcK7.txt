Published as a conference paper at ICLR 2019
STCN: Stochastic Temporal Convolutional
Networks
Emre Aksan & Otmar Hilliges
Department of Computer Science
ETH Zurich, Switzerland
{emre.aksan, otmar.hilliges}@inf.ethz.ch
Ab stract
Convolutional architectures have recently been shown to be competitive on many
sequence modelling tasks when compared to the de-facto standard of recurrent
neural networks (RNNs), while providing computational and modeling advan-
tages due to inherent parallelism. However, currently there remains a performance
gap to more expressive stochastic RNN variants, especially those with several lay-
ers of dependent random variables. In this work, we propose stochastic temporal
convolutional networks (STCNs), a novel architecture that combines the computa-
tional advantages of temporal convolutional networks (TCN) with the representa-
tional power and robustness of stochastic latent spaces. In particular, we propose
a hierarchy of stochastic latent variables that captures temporal dependencies at
different time-scales. The architecture is modular and flexible due to decoupling
of deterministic and stochastic layers. We show that the proposed architecture
achieves state of the art log-likelihoods across several tasks. Finally, the model is
capable of predicting high-quality synthetic samples over a long-range temporal
horizon in modeling of handwritten text.
1	Introduction
Generative modeling of sequence data requires capturing long-term dependencies and learning of
correlations between output variables at the same time-step. Recurrent neural networks (RNNs)
and its variants have been very successful in a vast number of problem domains which rely on
sequential data. Recent work in audio synthesis, language modeling and machine translation tasks
(Dauphin et al., 2016; Van Den Oord et al., 2016; Dieleman et al., 2018; Gehring et al., 2017) has
demonstrated that temporal convolutional networks (TCNs) can also achieve at least competitive
performance without relying on recurrence, and hence reducing the computational cost for training.
Both RNNs and TCNs model the joint probability distribution over sequences by decomposing the
distribution over discrete time-steps. In other words, such models are trained to predict the next
step, given all previous time-steps. RNNs are able to model long-term dependencies by propagating
information through their deterministic hidden state, acting as an internal memory. In contrast,
TCNs leverage large receptive fields by stacking many dilated convolutions, allowing them to model
even longer time scales up to the entire sequence length. It is noteworthy that there is no explicit
temporal dependency between the model outputs and hence the computations can be performed in
parallel. The TCN architecture also introduces a temporal hierarchy: the upper layers have access
to longer input sub-sequences and learn representations at a larger time scale. The local information
from the lower layers is propagated through the hierarchy by means of residual and skip connections
(Van Den Oord et al., 2016; Bai et al., 2018).
However, while TCN architectures have been shown to perform similar or better than standard re-
current architectures on particular tasks (Van Den Oord et al., 2016; Bai et al., 2018), there currently
remains a performance gap to more recent stochastic RNN variants (Bayer & Osendorfer, 2014;
Chung et al., 2015; Fabius & van Amersfoort, 2014; Fraccaro et al., 2016; Goyal et al., 2017; Sha-
banian et al., 2017). Following a similar approach to stochastic RNNs, Lai et al. (2018) present a
significant improvement in the log-likelihood when a TCN model is coupled with latent variables,
albeit at the cost of limited receptive field size.
1
Published as a conference paper at ICLR 2019
Figure 1: The computational graph of generative (left) and inference (right) models of STCN. The approximate
posterior q is conditioned on dt and is updated by the prior p which is conditioned on the TCN representations
of the previous time-step dt-1. The random latent variables at the upper layers have access to a long history
while lower layers receive inputs from more recent time steps.
In this work we propose a new approach for augmenting TCNs with random latent variables, that
decouples deterministic and stochastic structures yet leverages the increased modeling capacity effi-
ciently. Motivated by the simplicity and computational advantages of TCNs and the robustness and
performance of stochastic RNNs, we introduce stochastic temporal convolutional networks (STCN)
by incorporating a hierarchy of stochastic latent variables into TCNs which enables learning of
representations at many timescales. However, due to the absence of an internal state in TCNs, in-
troducing latent random variables analogously to stochastic RNNs is not feasible. Furthermore,
defining conditional random variables across time-steps would result in breaking the parallelism of
TCNs and is hence undesirable.
In STCN the latent random variables are arranged in correspondence to the temporal hierarchy of
the TCN blocks, effectively distributing them over the various timescales (see figure 1). Crucially,
our hierarchical latent structure is designed to be a modular add-on for any temporal convolutional
network architecture. Separating the deterministic and stochastic layers allows us to build STCNs
without requiring modifications to the base TCN architecture, and hence retains the scalability of
TCNs with respect to the receptive field. This conditioning of the latent random variables via differ-
ent timescales is especially effective in the case of TCNs. We show this experimentally by replacing
the TCN layers with stacked LSTM cells, leading to reduced performance compared to STCN.
We propose two different inference networks. In the canonical configuration, samples from each
latent variable are passed down from layer to layer and only one sample from the lowest layer is
used to condition the prediction of the output. In the second configuration, called STCN-dense, we
take inspiration from recent CNN architectures (Huang et al., 2017) and utilize samples from all
latent random variables via concatenation before computing the final prediction.
Our contributions can thus be summarized as: 1) We present a modular and scalable approach to
augment temporal convolutional network models with effective stochastic latent variables. 2) We
empirically show that the STCN-dense design prevents the model from ignoring latent variables
in the upper layers (Zhao et al., 2017). 3) We achieve state-of-the-art log-likelihood performance,
measured by ELBO, on the IAM-OnDB, Deepwriting, TIMIT and the Blizzard datasets. 4) Finally
we show that the quality of the synthetic samples matches the significant quantitative improvements.
2	Background
Auto-regressive models such as RNNs and TCNs factorize the joint probability of a variable-length
sequence x = {x1, . . . , xT} as a product of conditionals as follows:
T
Pθ (x) = ɪɪpθ(Xt|xi：t-1)	,	(1)
t=1
where the joint distribution is parametrized by θ. The prediction at each time-step is conditioned on
all previous observations. The observation model is frequently chosen to be a Gaussian or Gaussian
mixture model (GMM) for real-valued data, and a categorical distribution for discrete-valued data.
2
Published as a conference paper at ICLR 2019
2.1	Temporal Convolutional Networks
In TCNs the joint probabilities in Eq. (1) are parametrized by a stack of convolutional layers. Causal
convolutions are the central building block of such models and are designed to be asymmetric such
that the model has no access to future information. In order to produce outputs of the same size as
the input, zero-padding is applied at every layer.
In the absence of a state transition function, a large receptive field is crucial in capturing long-range
dependencies. To avoid the need for vast numbers of causal convolution layers, typically dilated
convolutions are used. Exponentially increasing the dilation factor results in an exponential growth
of the receptive field size with depth (Yu & Koltun, 2015; Van Den Oord et al., 2016; Bai et al., 2018).
In this work, without loss of generality, we use the building blocks of Wavenet (Van Den Oord et al.,
2016) as gated activation units (van den Oord et al., 2016) have been reported to perform better.
A deterministic TCN representation dlt at time-step t and layer l summarizes the input sequence x1:t :
dlt = Conv(l)(dlt-1, dlt--1j) and dt1 = Conv(1) (xt, xt-j) ,	(2)
where the filter width is 2 and j denotes the dilation step. In our work, the stochastic variables
zl , l = 1 . . . L are conditioned on TCN representations dl that are constructed by stacking K
Wavenet blocks over the previous dl-1 (for details see Figure 4 in Appendix).
2.2	Non-sequential Latent Variable Models
VAEs (Kingma & Welling, 2013; Rezende et al., 2014) introduce a latent random variable z to
learn the variations in the observed non-sequential data where the generation of the sample x is
conditioned on the latent variable z. The joint probability distribution is defined as:
Pθ(x, Z)= Pθ(x∣z)pθ(Z) ,	(3)
and parametrized by θ. Optimizing the marginal likelihood is intractable due to the non-linear
mappings between z and x and the integration over z. Instead the VAE framework introduces an
approximate posterior qφ(z∣x) and optimizes a lower-bound on the marginal likelihood:
logPθ(x) ≥ -KL(qφ(z∖x)∖∖pθ(z)) + Eqφ(z∣χ)[logPθ(x∣z)] ,	(4)
where KL denotes the Kullback-Leibler divergence. Typically the prior pθ (z) and the approximate
qφ(z∖x) are chosen to be in simple parametric form, such as a Gaussian distribution with diagonal
covariance, which allows for an analytical calculation of the KL-term in Eq. (4).
2.3	Stochastic RNNs
An RNN captures temporal dependencies by recursively processing each input, while updating an
internal state ht at each time-step via its state-transition function:
ht = f(h)(xt,ht-1)	,	(5)
where f(h) is a deterministic transition function such as LSTM (Hochreiter & Schmidhuber, 1997)
or GRU (Cho et al., 2014) cells. The computation has to be sequential because ht depends on ht-1.
The VAE framework has been extended for sequential data, where a latent variable zt augments the
RNN state ht at each sequence step. The joint distribution pθ (x, z) is modeled via an auto-regressive
model which results in the following factorization:
T
Pθ (x, z) = ɪɪpθ(Xt\zi：t,xi：t-1 )pθ(Zt\xi：t-i,zi：t-i)	.	(6)
t=1
In contrast to the fixed prior of VAEs, N(0, I), sequential variants define prior distributions condi-
tioned on the RNN hidden state h and implicitly on the input sequence x (Chung et al., 2015).
3
Published as a conference paper at ICLR 2019
Figure 2: Graphical model view of generative models of STCN (left) and STCN-dense (middle), and the
inference model (right), which is shared by both variants. Diamonds represent the outputs of deterministic
dilated convolution blocks where the dependence of dt on the past inputs is not shown for clarity (see Eq. (2)).
xt and zt are observable inputs and latent random variables, respectively. The generative task is to predict the
next step in the sequence, given all past steps. Note that in the STCN-dense variant the next step is conditioned
on all latent variables ztl for l = 1 . . . L.
3	Stochastic Temporal Convolutional Networks
The mechanics of STCNs are related to those of VRNNs and LVAEs. Intuitively, the RNN state
ht is replaced by temporally independent TCN layers dlt . In the absence of an internal state, we
define hierarchical latent variables ztl that are conditioned vertically, i.e., in the same time-step, but
independent horizontally, i.e., across time-steps. We follow a similar approach to LVAEs (S0nderby
et al., 2016) in defining the hierarchy in a top-down fashion and in how we estimate the approximate
posterior. The inference network first computes the approximate likelihood, and then this estimate is
corrected by the prior, resulting in the approximate posterior. The TCN layers d are shared between
the inference and generator networks, analogous to VRNNs (Chung et al., 2015).
Figure 2 depicts the proposed STCN as a graphical model. STCNs consist of two main modules:
the deterministic temporal convolutional network and the stochastic latent variable hierarchy. For
a given input sequence x = {xt}, t = 1 . . . T we first apply dilated convolutions over the entire
sequence to compute a set of deterministic representations dlt , l = 1 . . . L. Here, dlt corresponds to
the output of a block of dilated convolutions at layer l and time-step t. The output dlt is then used to
update a set of random latent variables ztl arranged to correspond with different time-scales.
To preserve the parallelism of TCNs, we do not introduce an explicit dependency between different
time-steps. However, we suggest that conditioning a latent variable ztl-1 on the preceding variable
ztl implicitly introduces temporal dependencies. Importantly, the random latent variables in the
upper layer have access to a larger receptive field due to its deterministic input dlt-1, whereas latent
random variables in lower layers are updated with different, more local information. However, the
latent variable ztl-1 may receive longer-range information from ztl.
The generative and inference models are jointly trained by optimizing a step-wise variational lower
bound on the log-likelihood (Kingma & Welling, 2013; Rezende et al., 2014). In the following
sections we describe these components and build up the lower-bound for a single time-step t.
3.1	Generative Model
Each sequence step xt is generated from a set of latent variables zt, split into layers as follows:
L-1
Pθ(ZtIxLt-I)= Pθ(ZLIdL-I) Y Pθ(ZtIzl+1,dt-1)	,	⑺
l=1
Where Pθ(ZtIzl+1,dt-i) = N(μt,p, σl,p) and [μt,p, σlt,r∖ = f(l(ZIt+ ∖dt-i) .	⑻
Here the prior is modeled by a Gaussian distribution with diagonal covariance, as is common in the
VAE framework. The subscript p denotes items of the generative distribution. For the inference
distribution we use the subscript q. The distributions are parameterized by a neural network fp(l) and
conditioned on: (1) the dlt-1 computed by the dilated convolutions from the previous time-step, and
4
Published as a conference paper at ICLR 2019
(2)	a sample from the preceding level at the same time-step ztl+1. Please note that at inference time
we draw samples from the approximate posterior distribution zl+1 〜qφ(zlt+1∖∙). The generative
model, on the other hand, uses the prior zl+1 〜pθ(zl+1∖∙).
We propose two variants of the observation model. In the non-sequential scenario, the observations
are defined to be conditioned on only the last latent variable in the hierarchy, i.e., pθ(xt∖zt1), follow-
ing S0nderby et al. (2016); Gulrajani et al. (2016) and Rezende et al. (2014) our STCN variant uses
the same observation model, allowing for an efficient optimization. However, latent units are likely
to become inactive during training in this configuration (Burda et al., 2015; Bowman et al., 2015;
Zhao et al., 2017) resulting in a loss of representational power.
The latent variables at different layers are conditioned on different contexts due to the inputs dlt .
Hence, the latent variables are expected to capture complementary aspects of the temporal context.
To propagate the information all the way to the final prediction and to ensure that gradients flow
through all layers, we take inspiration from Huang et al. (2017) and directly condition the output
probability on samples from all latent variables. We call this variant of our architecture STCN-dense.
The final predictions are then computed by the respective observation functions:
pθ(xt∖zt) = f(o)(zt1) and pθdense(xt∖zt) = f(o)(zt1, zt2 . . . ztL) ,	(9)
where f(o) corresponds to the output layer constructed by stacking 1D convolutions or Wavenet
blocks depending on the dataset.
3.2	Inference Model
In the original VAE framework the inference model is defined as a bottom-up process, where the la-
tent variables are conditioned on the stochastic layer below. Furthermore, the parameterization of the
prior and approximate posterior distributions are computed separately (Burda et al., 2015; Rezende
et al., 2014). In contrast, S0nderby et al. (2016) propose a top-down dependency structure shared
across the generative and inference models. From a probabilistic point of view, the approximate
Gaussian likelihood, computed bottom-up by the inference model, is combined with the Gaussian
prior, computed top-down from the generative model. We follow a similar procedure in computing
the approximate posterior.
First, the parameters of the approximate likelihood are computed for each stochastic layer l:
[μt,q,σl,q] = fqιl(zlt+∖dlt)	,	(10)
followed by the downward pass, recursively computing the prior and approximate posterior by
precision-weighted addition:
(Jiq = (σl,q)-2 + (σl,p)-2	,	(11)
μt,q = σt,q (μt,q (Jt,q )	+ μt,p(Jt,P)	.
Finally, the approximate posterior has the same decomposition as the prior (see Eq. (7)):
L-1
qΦ(zt\xi：t) = qφ(zt∖dt ) Y qΦ(zt∖zt+1,dt) ,	(12)
ι=1
qφkzt∖zlt + ,dt) = N (μt,q，Jt,q)	.	(13)
Note that the inference and generative network share the parameters of dilated convolutions Conv(ι).
3.3 Learning
The variational lower-bound on the log-likelihood at time-step t can be defined as follows:
log P(Xt) ≥ Eqφ(zt∣xt)[log Pθ (Xt\zt)] — DKL(qφ(zt\x1:t)\\Pθ (Zt\x1:t-1))
=Eqφ(z1...zL∣xt)[log Pθ (xt∖z1 ... zL)] — DKL®(Zt ... zL∖xLt)∖∖pθ (ZI ... ZL\x1:t-1))
Lt(θ, φ; Xt) = LtRecon + LtKL.
(14)
5
Published as a conference paper at ICLR 2019
Using the decompositions from Eq. (7) and (12), the Kullback-Leibler divergence term becomes:
LKL = - Dkl(qφ(ZLIdL川Pθ(ZL|dL-i))
L-1
-X Eqφ(zl+11∙)[DκL(qφ(Zt∣zt+1 ,dt)I∣PΘ(Zt∣zt+1 ,dt-1))].
=1
(15)
The KL term is the same for the STCN and STCN-dense variants. The reconstruction term LtRecon ,
however, is different. In STCN we only use samples from the lowest layer of the hierarchy, whereas
in STCN-dense we use all latent samples in the observation model:
LtRecon = Eqφ(zt1...ztL|xt) [logpθ(xtIZt1)]	,	(16)
LRecon-dense =旧1。(Zt... E) [1°g p0 (Xt 区...].	(17)
In the dense variant, samples drawn from the latent variables Ztl are carried over the dense connec-
tions. Similar to Maal0e et al. (2016), the expectation over Zt variables are computed by Monte
Carlo sampling using the reparameterization trick (Kingma & Welling, 2013; Rezende et al., 2014).
Please note that the computation of LtRecon-dense does not introduce any additional computational
cost. In STCN, all latent variables have to be visited in terms of ancestral sampling in order to
draw the latent sample Zt1 for the observation xt . Similarly in STCN-dense, the same intermediate
samples Ztl are used in the prediction of xt .
One alternative option to use the latent samples could be to sum individual samples before feeding
them into the observation model, i.e., sum([Z^1 ... ZL]), (Maal0e et al., 2016). We empirically found
that this does not work well in STCN-dense. Instead, We concatenate all samples [Z1 ◦…O ZL]
analogously to DenseNet (Huang et al., 2017) and (Kaiser et al., 2018).
4	Experiments
We evaluate the proposed variants STCN and STCN-dense both quantitatively and qualitatively on
modeling of digital handwritten text and speech. We compare with vanilla TCNs, RNNs, VRNNs
and state-of-the art models on the corresponding tasks.
In our experiments we use two variants of the Wavenet model: (1) the original model proposed in
(Van Den Oord et al., 2016) and (2) a variant that we augment with skip connections analogously to
STCN-dense. This additional baseline evaluates the benefit of learning multi-scale representations
in the deterministic setting. Details of the experimental setup are provided in the Appendix. Our
code is available at https://ait.ethz.ch/projects/2019/stcn/.
Handwritten text: The IAM-OnDB and Deepwriting datasets consist of digital handwriting sequences where
each time-step contains real-valued (x, y) pen coordinates and a binary pen-up event. The IAM-OnDB data is
split and pre-processed as done in (Chung et al., 2015). Aksan et al. (2018) extend this dataset with additional
samples and better pre-processing.
Table 1 reveals that again both our variants outperform the vanilla variants of TCNs and RNNs on IAM-OnDB.
While the stochastic VRNN and SWaveNet are competitive wrt to the STCN variant, both are outperformed by
工 JQ 也<?+"'<r<swAι- S21/：,“
KxSV> * ' 乩跟让 b∙k
B St匕SGgj—wja
SS a” θCCc⅛S∖o∩ VJelIg 0∣ Us
中出&3 Vr,收2
CZ3A<⅛J Λ ('eʌ?	qγ⅛√<
飙启产一"i" ∕~"
.ZUZrS“-%/ "C C 研入5y
e游勺所姒7“ VjordΛ 族血，2
必 U产伊eʤw
l∕Y∣, NALr/N心/皿加九八0)
7、、4妙2 哂同除 IM勿加/
仍"C拇WY卜加?“ ∖0(∖^λ'
⑶iCASQngS2 Md2 3
CWJ nZ/八产NYM7也心
血…短蕨号Rf神C
内8八汁.CeEaqMIS Ohiʌʃ0^
以d f n ObaAeS 0√w>Λ kχ∙M
LN 心∙ i，叼造血心
j)(LMp # MO溢“VXSg bqΓQΛ3Qθ"
(a) Ground truth
(b) VRNN
(c) SwaveNet
(d) STCN-dense
Figure 3: (a) Handwriting samples from IAM-OnDB dataset. Generated samples from (b) VRNN, (c)
SWaveNet and (d) our model STCN-dense. Each line corresponds to one sample.
6
Published as a conference paper at ICLR 2019
Table 1: Average log-likelihood per sequence on TIMIT, Blizzard, IAM-OnDB and Deepwriting datasets.
(Normal) and (GMM) stand for unimodal Gaussian or multi-modal Gaussian Mixture Model (GMM) as the
observation model (Graves, 2013; Chung et al., 2015). Asterisks * indicate that We used our re-implementation
only for the Deepwriting dataset.
Models	TIMrr	Blizzard	IAM-OnDB	Deepwriting
Wavenet (GMM)	30188^^	8190	1381	612
Wavenet-dense (GMM)	30636	8212	1380	642
RNN (GMM) Chung et al. (2015)	26643	7413	1358	528 *
VRNN (Normal) Chung et al. (2015)	≈ 30235	≈ 9516	≈ 1354	≥ 495 *
VRNN (GMM) Chung et al. (2015)	≈ 29604	≈ 9392	≈ 1384	≥ 673 *
SRNN (Normal) Fraccaro et al. (2016)	≥ 60550	≥ 11991	n/a	n/a
Z-forcing (Normal) Goyal et al. (2017)	≥ 70469	≥ 15430	n/a	n/a
Var. Bi-LSTM (Normal) Shabanian et al. (2017)	≥ 73976	≥ 17319	n/a	n/a
SWaveNet (Normal) Lai et al. (2018)	≥ 72463	≥ 15708	≥ 1301	n/a
STCN (GMM)	≥ 69195	≥ 15800	≥ 1338	≥ 605
STCN-dense (GMM)	≥ 71386	≥ 16288	≥ 1796	≥ 797
STCN-dense-large (GMM)	≥ 77438	≥ 17670	n/a	n/a
the STCN-dense version. The same relative ordering is maintained on the DeepWriting dataset, indicating that
the proposed architecture is robust across datasets.
Fig. 3 compares generated handWriting samples. While all models produce consistent style, our model gen-
erates more natural looking samples. Note that the spacing betWeen Words is clearly visible and most of the
letters are distinguishable.
Speech modeling: TIMIT and Blizzard are standard benchmark dataset in speech modeling. The models are
trained and tested on 200 dimensional real-valued amplitudes. We apply the same pre-processing as Chung
et al. (2015). For this task We introduce STCN-dense-large, With increased model capacity. Here We use 512
instead of 256 convolution filters. Note that the total number of model parameters is comparable to SWaveNet
and other SOA models.
On TIMIT, STCN-dense (Table 1) significantly outperforms the vanilla TCN and RNN, and stochastic models.
On the Blizzard dataset, our model is marginally better than the Variational Bi-LSTM. Note that the inference
models of SRNN (Fraccaro et al., 2016), Z-forcing (Goyal et al., 2017), and Variational Bi-LSTM (Shabanian
et al., 2017) receive future information by using backWard RNN cells. Similarly, SWaveNet (Lai et al., 2018)
applies causal convolutions in the backWard direction. Hence, the latent variable can be expected to model
future dynamics of the sequence. In contrast, our models have only access to information up to the current
time-step. These results indicate that the STCN variants perform very Well on the speech modeling task.
Latent Space Analysis: Zhao et al. (2017) observe that in hierarchical latent variable models the upper layers
have a tendency to become inactive, indicated by a low KL loss (S0nderby et al., 2016; Dieng et al., 2018).
Table 2 shoWs the KL loss per latent variable and the corresponding log-likelihood measured by ELBO in
our models. Across the datasets it can be observed that our models make use of many of the latent variables
which may explain the strong performance across tasks in terms of log-likelihoods. Note that STCN uses a
standard hierarchical structure. However, individual latent variables have different information context due to
the corresponding TCN block’s receptive field. This observation suggests that the proposed combination of
TCNs and stochastic variables is indeed effective. Furthermore, in STCN we see a similar utilization pattern
of the z variables across tasks, whereas STCN-dense may have more flexibility in modeling the temporal
dependencies within the data due to its dense connections to the output layer.
Table 2: KL-loss per latent variable computed over the entire test split. KL5 corresponds to the KL-loss of the
top-most latent variable.
Dataset (Model)	ELBO	KL	KL1	KL2	KL3	KL4	KL5
IAM-OnDB (STCN-dense)	≥ 1796.3	1653.9	179^^	1287.4	305.3	41.0	2.4
IAM-OnDB (stcn)	≥ 1339.2	964.2	846.0	105.2	12.9	0.1	0.0
TIMIT (sTCN-dense)	≥ 71385.9	22297.5	16113.0	5641.6	529.0	8.3	5.7
TIMIT (stcn)	≥ 69194.9	23118.3	22275.5	487.2	355.5	0.0	0.0
7
Published as a conference paper at ICLR 2019
Replacing TCN with RNN: To better understand potential symergies between dilated CNNs and the proposed
latent variable hierarchy, we perform an ablation study, isolating the effect of TCNs and the latent space. To this
end the deterministic TCN blocks are replaced with LSTM cells by keeping the latent structure intact. We dub
this condition LadderRNN. We use the TIMIT and IAM-OnDB datasets for evaluation. Table 3 summarizes
performance measured by the ELBO.
The most direct translation of the the STCN architecture into an RNN counterpart has 25 stacked LSTM cells
with 256 units each. Similar to STCN, we use 5 stochastic layers (see Appendix 7.1). Note that stacking this
many LSTM cells is unusual and resulted in instabilities during training. Hence, the performance is similar
to vanilla RNNs. The second LadderRNN configuration uses 5 stacked LSTM cells with 512 units and a
one-to-one mapping with the stochastic layers. On the TIMIT dataset, all LadderRNN configurations show a
significant improvement. We also observe a pattern of improvement with densely connected latent variables.
This experiments shows that the proposed modular latent variable design does allow for the usage of different
building blocks. Even when attached to LSTM cells, it boosts the log-likelihood performance (see 5x512-
LadderRNN), in particular when used with dense connections. However, the empirical results suggest that
the densely connected latent hierarchy interacts particularly well with dilated CNNs. We suggest this is due
to the hierarchical nature on both sides of the architecture. On both datasets STCN models achieved the
best performance and significantly improve with dense connections. This supports our contribution of a latent
variable hierarchy, which models different aspects of information from the input time-series.
Table 3: ELBO of LadderRNN and STCN models using the same latent space configuration. The prefix of a
model entries denote the number of RNN or TCN layers and unit size per layer. Models have similar number
of trainable parameters.
Models	TIMIT	IAM-OnDB
25x256-LadderRNN (Normal)	≥ 28207	≥ 1305
25x256-LadderRNN-dense (Normal)	≥ 27413	≥ 1278
25x256-LadderRNN (GMM)	≥ 24839	≥ 1381
25x256-LadderRNN-dense (GMM)	≥ 26240	≥ 1377
5x512-LadderRNN (Normal)	≥ 49770	≥ 1299
5x512-LadderRNN-dense (Normal)	≥ 48612	≥ 1374
5x512-LadderRNN (GMM)	≥ 47179	≥ 1359
5x512-LadderRNN-dense (GMM)	≥ 50113	≥ 1581
25x256-STCN (Normal)	≥ 64913	≥ 1327
25x256-STCN-dense (Normal)	≥ 70294	≥ 1729
25x256-STCN (GMM)	≥ 69195	≥ 1339
25x256-STCN-dense (GMM)	≥ 71386	≥ 1796
5	Related Work
Rezende et al. (2014) propose Deep Latent Gaussian Models (DLGM) and S0nderby et al. (2016) propose
the Ladder Variational Autoencoder (LVAE). In both models the latent variables are hierarchically defined and
conditioned on the preceding stochastic layer. LVAEs improve upon DLGMs via implementation ofa top-down
hierarchy both in the generative and inference model. The approximate posterior is computed via a precision-
weighted update of the approximate likelihood (i.e., the inference model) and prior (i.e., the generative model).
Similarly, the PixelVAE (Gulrajani et al., 2016) incorporates a hierarchical latent space decomposition and uses
an autoregressive decoder. Zhao et al. (2017) show under mild conditions that straightforward stacking of latent
variables (as is done e.g. in LVAE and PixelVAE) can be ineffective, because the latent variables that are not
directly conditioned on the observation variable become inactive.
Due to the nature of the sequential problem domain, our approach differs in the crucial aspects that STCNs
use dynamic, i.e., conditional, priors (Chung et al., 2015) at every level. Moreover, the hierarchy is not only
implicitly defined by the network architecture but also explicitly defined by the information content, i.e., recep-
tive field size. Dieng et al. (2018) both theoretically and empirically show that using skip connections from the
latent variable to every layer of the decoder increases mutual information between the latent and observation
variables. Similar to Dieng et al. (2018) in STCN-dense, we introduce skip connections from all latent variables
to the output. In STCN the model is expected to encode and propagate the information through its hierarchy.
Yang et al. (2017) suggest using autoregressive TCN decoders to remedy the posterior collapse problem ob-
served in language modeling with LSTM decoders (Bowman et al., 2015). van den Oord et al. (2017) and
Dieleman et al. (2018) use TCN decoders conditioned on discrete latent variables to model audio signals.
8
Published as a conference paper at ICLR 2019
Stochastic RNN architectures mostly vary in the way they employ the latent variable and parametrize the
approximate posterior for variational inference. Chung et al. (2015) and Bayer & Osendorfer (2014) use the
latent random variable to capture high-level information causing the variability observed in sequential data.
Particularly Chung et al. (2015) shows that using a conditional prior rather than a standard Gaussian distribution
is very effective in sequence modeling. In (Fraccaro et al., 2016; Goyal et al., 2017; Shabanian et al., 2017), the
inference model, i.e., the approximate posterior, receives both the past and future summaries of the sequence
from the hidden states of forward and backward RNN cells. The KL-divergence term in the objective enforces
the model to learn predictive latent variables in order to capture the future states of the sequence.
Lai et al. (2018)’s SWaveNet is most closely related to ours. SWaveNet also introduces latent variables into
TCNs. However, in SWaveNet the deterministic and stochastic units are coupled which may prevent stacking
of larger numbers of TCN blocks. Since the number of stacked dilated convolutions determines the receptive
field size, this directly correlates with the model capacity. For example, the performance of SWaveNet on the
IAM-OnDB dataset degrades after stacking more than 3 stochastic layers (Lai et al., 2018), limiting the model
to a small receptive field. In contrast, we aim to preserve the flexibility of stacking dilated convolutions in the
base TCN. In STCNs, the deterministic TCN units do not have any dependency on the stochastic variables (see
Figure 1) and the ratio of stochastic to deterministic units can be adjusted, depending on the task.
6	Conclusion
In this paper we proposed STCNs, a novel auto-regressive model, combining the computational benefits of
convolutional architectures and expressiveness of hierarchical stochastic latent spaces. We have shown the
effectivness of the approach across several sequence modelling tasks and datasets. The proposed models are
trained via optimization of the ELBO objective. Tighter lower bounds such as IWAE (Burda et al., 2015) or
FIVO (Maddison et al., 2017) may further improve modeling performance. We leave this for future work.
Acknowledgements
This work was supported in parts by the ERC grant OPTINT (StG-2016-717054). We gratefully acknowledge
the support of NVIDIA Corporation with the donation of the Titan Xp GPU used for this research.
9
Published as a conference paper at ICLR 2019
References
Martin Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, San-
jay Ghemawat, Geoffrey Irving, Michael Isard, Manjunath Kudlur, Josh Levenberg, Rajat Monga, Sherry
Moore, Derek G. Murray, Benoit Steiner, Paul Tucker, Vijay Vasudevan, Pete Warden, Martin Wicke, Yuan
Yu, and Xiaoqiang Zheng. Tensorflow: A system for large-scale machine learning. In 12th USENIX
Symposium on Operating Systems Design and Implementation (OSDI 16), pp. 265-283, 2016. URL
https://www.usenix.org/system/files/conference/osdi16/osdi16-abadi.pdf.
Emre Aksan, Fabrizio Pece, and Otmar Hilliges. DeepWriting: Making Digital Ink Editable via Deep Genera-
tive Modeling. In SIGCHI Conference on Human Factors in Computing Systems, CHI ’18, New York, NY,
USA, 2018. ACM.
Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and recurrent
networks for sequence modeling. arXiv preprint arXiv:1803.01271, 2018.
Justin Bayer and Christian Osendorfer. Learning stochastic recurrent networks. arXiv preprint
arXiv:1411.7610, 2014.
Samuel R Bowman, Luke Vilnis, Oriol Vinyals, Andrew M Dai, Rafal Jozefowicz, and Samy Bengio. Gener-
ating sentences from a continuous space. arXiv preprint arXiv:1511.06349, 2015.
Yuri Burda, Roger Grosse, and Ruslan Salakhutdinov. Importance weighted autoencoders. arXiv preprint
arXiv:1509.00519, 2015.
Kyunghyun Cho, Bart Van Merrienboer, Caglar GulCehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder for statistical
maChine translation. arXiv preprint arXiv:1406.1078, 2014.
Junyoung Chung, Kyle Kastner, Laurent Dinh, Kratarth Goel, Aaron C Courville, and Yoshua Bengio. A
reCurrent latent variable model for sequential data. In Advances in neural information processing systems,
pp. 2980-2988, 2015.
Yann N Dauphin, Angela Fan, MiChael Auli, and David Grangier. Language modeling with gated Convolutional
networks. arXiv preprint arXiv:1612.08083, 2016.
Sander Dieleman, Aaron van den Oord, and Karen Simonyan. The challenge of realistic music generation:
modelling raw audio at sCale. arXiv preprint arXiv:1806.10474, 2018.
Adji B Dieng, Yoon Kim, Alexander M Rush, and David M Blei. Avoiding latent variable collapse with
generative skip models. arXiv preprint arXiv:1807.04863, 2018.
Otto Fabius and Joost R van Amersfoort. Variational recurrent auto-encoders. arXiv preprint arXiv:1412.6581,
2014.
Marco Fraccaro, S0ren Kaae S0nderby, Ulrich Paquet, and Ole Winther. Sequential neural models with stochas-
tic layers. In Advances in neural information processing systems, pp. 2199-2207, 2016.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional sequence to
sequence learning. arXiv preprint arXiv:1705.03122, 2017.
Anirudh Goyal ALIAS PARTH Goyal, Alessandro Sordoni, Marc-Alexandre C6te, Nan Ke, and Yoshua Ben-
gio. Z-forcing: Training stochastic recurrent networks. In Advances in Neural Information Processing
Systems, pp. 6713-6723, 2017.
Alex Graves. Generating sequences with recurrent neural networks. arXiv preprint arXiv:1308.0850, 2013.
Ishaan Gulrajani, Kundan Kumar, Faruk Ahmed, Adrien Ali Taiga, Francesco Visin, David Vazquez, and Aaron
Courville. Pixelvae: A latent variable model for natural images. arXiv preprint arXiv:1611.05013, 2016.
Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural ComPutation, 9(8):1735-1780,
1997.
Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kilian Q Weinberger. Densely connected convolutional
networks. In CVPR, volume 1, pp. 3, 2017.
Lukasz Kaiser, Aurko Roy, Ashish Vaswani, Niki Pamar, Samy Bengio, Jakob Uszkoreit, and Noam Shazeer.
Fast decoding in sequence models using discrete latent variables. arXiv preprint arXiv:1803.03382, 2018.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.
10
Published as a conference paper at ICLR 2019
Guokun Lai, Bohan Li, Guoqing Zheng, and Yiming Yang. Stochastic wavenet: A generative latent variable
model for sequential data, 2018.
Lars Maal0e, CasPer Kaae S0nderby, S0ren Kaae S0nderby, and Ole Winther. Auxiliary deep generative
models. arXiv preprint arXiv:1602.05473, 2016.
Chris J Maddison, John Lawson, George Tucker, Nicolas Heess, Mohammad Norouzi, Andriy Mnih, Arnaud
Doucet, and Yee Teh. Filtering variational objectives. In Advances in Neural Information Processing Sys-
tems,pp. 6573-6583, 2017.
Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic backpropagation and approximate
inference in deep generative models. arXiv preprint arXiv:1401.4082, 2014.
Samira Shabanian, Devansh Arpit, Adam Trischler, and Yoshua Bengio. Variational bi-lstms. arXiv preprint
arXiv:1711.05717, 2017.
Casper Kaae S0nderby, Tapani Raiko, Lars Maal0e, S0ren Kaae S0nderby, and Ole Winther. Ladder variational
autoencoders. In Advances in neural information processing systems, pp. 3738-3746, 2016.
Aaron Van Den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal KalCh-
brenner, Andrew W Senior, and Koray Kavukcuoglu. Wavenet: A generative model for raw audio. In SSW,
pp. 125, 2016.
Aaron van den Oord, Nal Kalchbrenner, Lasse Espeholt, Oriol Vinyals, Alex Graves, et al. Conditional image
generation with pixelCnn deCoders. In Advances in Neural Information Processing Systems, pp. 4790-4798,
2016.
Aaron van den Oord, Oriol Vinyals, et al. Neural discrete representation learning. In Advances in Neural
Information Processing Systems, pp. 6306-6315, 2017.
Zichao Yang, Zhiting Hu, Ruslan Salakhutdinov, and Taylor Berg-Kirkpatrick. Improved variational autoen-
coders for text modeling using dilated convolutions. arXiv preprint arXiv:1702.08139, 2017.
Fisher Yu and Vladlen Koltun. Multi-scale context aggregation by dilated convolutions. arXiv preprint
arXiv:1511.07122, 2015.
Shengjia Zhao, Jiaming Song, and Stefano Ermon. Learning hierarchical features from generative models.
arXiv preprint arXiv:1702.08396, 2017.
11
Published as a conference paper at ICLR 2019
7	Appendix
7.1	Network Details
Figure 4: Generative model of STCN-dense architecture. Building blocks are highlighted. Note that the
dependence of dt,l = 1 …L on past inputs is not visualized for clarity.
The network architecture of the proposed model is illustrated in Fig. 4. We make only a small modification
to the vanilla Wavenet architecture. Instead of using skip connections from Wavenet blocks, we only use the
latent sample zt in order to make a prediction of xt . In STCN-dense configuration, zt is the concatenation of
all latent variables in the hierarchy, i.e., Zt = [z1 ◦…◦ zL], whereas in STCN only z1 is fed to the output
layer.
Each stochastic latent variable ztl (except the top-most ztL) is conditioned on a deterministic TCN representation
dlt and the preceding random variable ztl+1 . The latent variables are calculated by using the latent layers fp(l)
or fq(l) which are neural networks.
We do not define a latent variable per TCN layer. Instead, the stochastic layers are uniformly distributed where
each random variable is conditioned on a number of stacked TCN layers dlt . We stack K Wavenet blocks (see
figure 4 left) with exponentially increasing dilation size.
Observation Model: We use Normal or GMM distributions with 20 components to model real-valued data.
All Gaussian distributions have diagonal covariance matrix.
Output layer f(o) : For the IAM-OnDB and Deepwriting datasets we use 1D convolutions with ReLU nonlin-
earity. We stack 5 of these layers with 256 filters and filter size 1.
For TIMIT and Blizzard datasets Wavenet blocks in the output layer perform significantly better. We stack 5
Wavenet blocks with dilation size 1. For each convolution operation in the block we use 256 filters. The filter
size of the dilated convolution is set to 2. The STCN-dense-large model is constructed by using 512 filters
instead of 256.
TCN blocks dlt: The number of Wavenet blocks is usually determined by the desired receptive field size.
•	For the handwriting datasets K = 6 and L = 5. In total we have 30 Wavenet blocks where each
convolution operation has 256 filters with size 2.
•	For speech datasets K = 5 and L = 5. In total we have 25 Wavenet blocks where each convolution
operation has 256 filters with size 2. The large model configuration uses 512 filters.
Latent layers fp(l) and fq(l): The number of stochastic layers per task is given by L. We used [32, 16, 8, 5, 2]
dimensional latent variables for the handwriting tasks. It is [256, 128, 64, 32, 16] for speech datasets. Note that
the first entry of the list corresponds to z1 .
The mean and sigma parameters of the Normal distributions modeling the latent variables are calculated by the
fp(l) and fq(l) networks. We stack 2 1D convolutions with ReLU nonlinearity and filter size 1. The number of
filters are the same as the number of Wavenet block filters for the corresponding task.
Finally, we clamped the latent sigma predictions between 0.001 and 5.
12
Published as a conference paper at ICLR 2019
7.2	Training Details
In all STCN experiments we applied KL annealing. In all tasks, the weight of the KL term is initialized with 0
and increased by 1 × e-4 at every step until it reaches 1.
The batch size was 20 for all datasets except for Blizzard where it was 128.
We use the ADAM optimizer with its default parameters and exponentially decay the learning rate. For the
handwriting datasets the learning rate was initialized with 5 × e-4 and followed a decay rate of 0.94 over 1000
decay steps. On the speech datasets it was initialized with 1 × e-3 and decayed with a rate of 0.98. We applied
early stopping by measuring the ELBO performance on the validation splits.
We implement STCN models in Tensorflow (Abadi et al., 2016). Our code and models achieving the SOA
results are available at https://ait.ethz.ch/projects/2019/stcn/.
7.3	Detailed Results
Here we provide the extended results table with Normal observation model entries for available models.
Table 4: Average log-likelihood per sequence on TIMIT, Blizzard, IAM-OnDB and Deepwriting datasets.
(Normal) and (GMM) stand for unimodal Gaussian or multi-modal Gaussian Mixture Model (GMM) as the
observation model (Graves, 2013; Chung et al., 2015). Asterisks * indicate that We used our re-implementation
only for the Deepwriting dataset.
Models	TIMIT	Blizzard	IAM-OnDB	DeepWriting
Wavenet (Normal)	-^-7443^^	3784	1053	337
Wavenet (GMM)	30188	8190	1381	612
Wavenet-dense (Normal)	-8579	3712	1030	323
Wavenet-dense (GMM)	30636	8212	1380	642
RNN (Normal) Chung et al. (2015)	-1900	3539	1016	363 *
RNN (GMM) Chung et al. (2015)	26643	7413	1358	528 *
VRNN (Normal)Chung et al. (2015)	≈ 30235	≈ 9516	≈ 1354	≥ 495 *
VRNN (GMM) Chung et al. (2015)	≈ 29604	≈ 9392	≈ 1384	≥ 673 *
SRNN (Normal) Fraccaro et al. (2016)	≥ 60550	≥ 11991	n/a	n/a
Z-forcing (Normal)Goyal et al. (2017)	≥ 70469	≥ 15430	n/a	n/a
Var. Bi-LSTM (Normal)Shabanian et al. (2017)	≥ 73976	≥ 17319	n/a	n/a
SWaveNet (Normal)Lai et al. (2018)	≥ 72463	≥ 15708	≥ 1301	n/a
STCN(Normal)	≥ 64913	≥ 13273	≥ 1327	≥ 575
STCN(GMM)	≥ 69195	≥ 15800	≥ 1338	≥ 605
STCN-dense(Normal)	≥ 70294	≥ 15950	≥ 1729	≥ 740
STCN-dense(GMM)	≥ 71386	≥ 16288	≥ 1796	≥ 797
STCN-dense-large (GMM)	≥ 77438	≥ 17670	n/a	n/a
13