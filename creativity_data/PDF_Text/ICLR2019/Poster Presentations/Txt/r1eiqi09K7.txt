Published as a conference paper at ICLR 2019
Riemannian Adaptive Optimization Methods
Gary Becigneul, Octavian-Eugen Ganea
Department of Computer Science
ETH Zurich, Switzerland
{gary.becigneul,octavian.ganea}@inf.ethz.ch
Ab stract
Several first order stochastic optimization methods commonly used in the Euclidean
domain such as stochastic gradient descent (sgd), accelerated gradient descent
or variance reduced methods have already been adapted to certain Riemannian
settings. However, some of the most popular of these optimization tools - namely
ADAM, ADAGRAD and the more recent AMSGRAD - remain to be generalized
to Riemannian manifolds. We discuss the difficulty of generalizing such adaptive
schemes to the most agnostic Riemannian setting, and then provide algorithms
and convergence proofs for geodesically convex objectives in the particular case
of a product of Riemannian manifolds, in which adaptivity is implemented across
manifolds in the cartesian product. Our generalization is tight in the sense that
choosing the Euclidean space as Riemannian manifold yields the same algorithms
and regret bounds as those that were already known for the standard algorithms.
Experimentally, we show faster convergence and to a lower train loss value for
Riemannian adaptive methods over their corresponding baselines on the realistic
task of embedding the WordNet taxonomy in the Poincare ball.
1	Introduction
Developing powerful stochastic gradient-based optimization algorithms is of major importance for a
variety of application domains. In particular, for computational efficiency, it is common to opt for
a first order method, when the number of parameters to be optimized is great enough. Such cases
have recently become ubiquitous in engineering and computational sciences, from the optimization
of deep neural networks to learning embeddings over large vocabularies.
This new need resulted in the development of empirically very successful first order methods such
as ADAGRAD (Duchi et al., 2011), ADADELTA (Zeiler, 2012), ADAM (Kingma & Ba, 2015) or its
recent update Amsgrad (Reddi et al., 2018).
Note that these algorithms are designed to optimize parameters living in a Euclidean space Rn , which
has often been considered as the default geometry to be used for continuous variables. However, a
recent line of work has been concerned with the optimization of parameters lying on a Riemannian
manifold, a more general setting allowing non-Euclidean geometries. This family of algorithms has
already found numerous applications, including for instance solving Lyapunov equations (Vander-
eycken & Vandewalle, 2010), matrix factorization (Tan et al., 2014), geometric programming (Sra
& Hosseini, 2015), dictionary learning (Cherian & Sra, 2017) or hyperbolic taxonomy embedding
(Nickel & Kiela, 2017; Ganea et al., 2018a; De Sa et al., 2018; Nickel & Kiela, 2018).
A few first order stochastic methods have already been generalized to this setting (see section 6),
the seminal one being Riemannian stochastic gradient descent (rsgd) (Bonnabel, 2013), along
with new methods for their convergence analysis in the geodesically convex case (Zhang & Sra,
2016). However, the above mentioned empirically successful adaptive methods, together with their
convergence analysis, remain to find their respective Riemannian counterparts.
Indeed, the adaptivity of these algorithms can be thought of as assigning one learning rate per
coordinate of the parameter vector. However, on a Riemannian manifold, one is generally not given
an intrinsic coordinate system, rendering meaningless the notions sparsity or coordinate-wise update.
1
Published as a conference paper at ICLR 2019
Our contributions. In this work we (i) explain why generalizing these adaptive schemes to the most
agnostic Riemannian setting in an intrinsic manner is compromised, and (ii) propose generalizations
of the algorithms together with their convergence analysis in the particular case of a product of
manifolds where each manifold represents one “coordinate” of the adaptive scheme. Finally, we (iii)
empirically support our claims on the realistic task of hyperbolic taxonomy embedding.
Our initial motivation. The particular application that motivated us in developing Riemannian
versions of Adagrad and Adam was the learning of symbolic embeddings in non-Euclidean spaces.
As an example, the GloVe algorithm (Pennington et al., 2014) - an unsupervised method for learning
Euclidean word embeddings capturing semantic/syntactic relationships - benefits significantly from
optimizing with Adagrad compared to using Sgd, presumably because different words are sampled
at different frequencies. Hence the absence of Riemannian adaptive algorithms could constitute a
significant obstacle to the development of competitive optimization-based Riemannian embedding
methods. In particular, we believe that the recent rise of embedding methods in hyperbolic spaces
could benefit from such developments (Nickel & Kiela, 2017; 2018; Ganea et al., 2018a;b; De Sa
et al., 2018; Vinh et al., 2018).
2	Preliminaries and notations
2.1	Differential geometry
We recall here some elementary notions of differential geometry. For more in-depth expositions, we
refer the interested reader to Spivak (1979) and Robbin & Salamon (2011).
Manifold, tangent space, Riemannian metric. A manifold M of dimension n is a space that can
locally be approximated by a Euclidean space Rn, and which can be understood as a generalization
to higher dimensions of the notion of surface. For instance, the sphere S := {x ∈ Rn | kxk2 = 1}
embedded in Rn is an (n- 1)-dimensional manifold. In particular, Rn is a very simple n-dimensional
manifold, with zero curvature. At each point x ∈ M, one can define the tangent space TxM, which
is an n-dimensional vector space and can be seen as a first order local approximation of M around x.
A Riemannian metric P is a collection P := (ρχ)χ∈M of inner-products ρχ(∙, ∙) : TxM X TxM → R
on TxM, varying smoothly with x. It defines the geometry locally on M. For X ∈ M and U ∈ TxM,
we also write ∣∣ukx := pρx(u, u). A Riemannian manifold is a pair (M, ρ).
Induced distance function, geodesics. Notice how a choice of a Riemannian metric P induces a
natural global distance function on M. Indeed, for x, y ∈ M, we can set d(x, y) to be equal to the
infimum of the lengths of smooth paths between X and y in M, where the length '(c) of a path C is
given by integrating the size of its speed vector C(t) ∈ T《)M, in the corresponding tangent space:
'(c) := f=o ∣∣C(t) kc(t)dt. A geodesic Y in (M, ρ) is a smooth curve Y : (a,b) → M which locally
has minimal length. In particular, a shortest path between two points in M is a geodesic.
Exponential and logarithmic maps. Under some assumptions, one can define at point X ∈ M the
exponential map expx : TxM → M. Intuitively, this map folds the tangent space on the manifold.
Locally, if v ∈ TxM, then for small t, expx (tv) tells us how to move in M as to take a shortest
path from X with initial direction v. In Rn, expx(v) = X + v. In some cases, one can also define the
logarithmic map logx : M → TxM as the inverse of expx.
Parallel transport. In the Euclidean space, if one wants to transport a vector v from X to y, one
simply translates v along the straight-line from X to y. In a Riemannian manifold, the resulting
transported vector will depend on which path was taken from X to y. The parallel transport Px (v; w)
of a vector v from a point X in the direction w and in a unit time, gives a canonical way to transport v
with zero acceleration along a geodesic starting from X, with initial velocity w.
2
Published as a conference paper at ICLR 2019
2.2	Riemannian optimization
Consider performing an sgd update of the form
xt+ι J Xt - αgt,	(1)
where gt denotes the gradient of objective ft 1 and α > 0 is the step-size. In a Riemannian manifold
(M, ρ), for smooth f : M → R, Bonnabel (2013) defines Riemannian SGD by the following update:
xt+1 J expxt (-αgt),	(2)
where gt ∈ TxtM denotes the Riemannian gradient of ft at xt. Note that when (M, ρ) is the
Euclidean space (Rn , In), these two match, since we then have expx (v) = x + v.
Intuitively, applying the exponential map enables to perform an update along the shortest path in the
relevant direction in unit time, while remaining in the manifold.
In practice, when expx (v) is not known in closed-form, it is common to replace it by a retraction
map Rx(v), most often chosen as Rx(v) = x + v, which is a first-order approximation of expx (v).
2.3	Amsgrad, Adam, Adagrad
Let’s recall here the main algorithms that we are taking interest in.
Adagrad. Introduced by Duchi et al. (2011), the standard form of its update step is defined as2
xit+1 J xit - αgti/
∖
t
X(gki)2.
k=1
(3)
Such updates rescaled coordinate-wise depending on the size of past gradients can yield huge
improvements when gradients are sparse, or in deep networks where the size of a good update may
depend on the layer. However, the accumulation of all past gradients can also slow down learning.
Adam. Proposed by Kingma & Ba (2015), the ADAM update rule is given by
xt+1 - Xt - αmt/∖fvt,	⑷
where mt = β1mt-1 + (1 -β1)gt can be seen as a momentum term and vti = β2vti-1 + (1 -β2)(gti)2
is an adaptivity term. When β1 = 0, one essentially recovers the unpublished method RMSPROP
(Tieleman & Hinton, 2012), the only difference to Adagrad being that the sum is replaced by
an exponential moving average, hence past gradients are forgotten over time in the adaptivity term
vt . This circumvents the issue of ADAGRAD that learning could stop too early when the sum of
accumulated squared gradients is too significant. Let us also mention that the momentum term
introduced by ADAM for β1 6= 0 has been observed to often yield huge empirical improvements.
Amsgrad. More recently, Reddi et al. (2018) identified a mistake in the convergence proof of
Adam. To fix it, they proposed to either modify the Adam algorithm with3
xt+1 J Xt — amt/ʌ/vɪ, where ^ = max{Vi-i, vi},	(5)
which they coin AMSGRAD, or to choose an increasing schedule for β2, making it time dependent,
which they call AdamNc (for non-constant).
3	Adaptive schemes in Riemannian manifolds
3.1	The difficulty of designing adaptive schemes in the general setting
Intrinsic updates. It is easily understandable that writing any coordinate-wise update requires the
choice of a coordinate system. However, on a Riemannian manifold (M, ρ), one is generally not
1to be interpreted as the objective with the same parameters, evaluated at the minibatch taken at time t.
2a small ε = 10-8 is often added in the square-root for numerical stability, omitted here for simplicity.
3with mt and vt defined by the same equations as in ADAM (see above paragraph).
3
Published as a conference paper at ICLR 2019
provided with a canonical coordinate system. The formalism only allows to work with certain local
coordinate systems, also called charts, and several different charts can be defined around each point
x ∈ M. One usually says that a quantity defined using a chart is intrinsic to M if its definition does
not depend on which chart was used. For instance, it is known that the Riemannian gradient gradf
of a smooth function f : M → R can be defined intrinsically to (M, ρ), but its Hessian is only
intrinsically defined at critical points4. It is easily seen that the rsgd update of Eq. (2) is intrinsic,
since it only involves exp and grad, which are objects intrinsic to (M, ρ). However, it is unclear
whether it is possible at all to express either of Eqs. (3,4,5) in a coordinate-free or intrinsic manner.
A tempting solution. Note that since an update is defined in a tangent space, one could be tempted
to fix a canonical coordinate system e := (e(1) , ..., e(n)) in the tangent space Tx0M ' Rd at the
initialization x0 ∈ M, and parallel-transport e along the optimization trajectory, adapting Eq. (3) to:
t
xt+1 - eχpχt (∆t),	et+1 - Pxt (et; Z), with ∆t := -αgt 0 t	(gk)2,	(6)
k=1
where 0 and (∙)2 denote coordinate-wise division and square respectively, these operations being
taken relatively to coordinate system et . In the Euclidean space, parallel transport between two points
x and y does not depend on the path it is taken along because the space has no curvature. However,
in a general Riemannian manifold, not only does it depend on the chosen path but curvature will also
give to parallel transport a rotational component5, which will almost surely break the sparsity of the
gradients and hence the benefit of adaptivity. Besides, the interpretation of adaptivity as optimizing
different features (i.e. gradient coordinates) at different speeds is also completely lost here, since the
coordinate system used to represent gradients depends on the optimization path. Finally, note that the
techniques we used to prove our theorems would not apply to updates defined in the vein of Eq. (6).
3.2	Adaptivity is possible across manifolds in a product
From now on, we assume additional structure on (M, ρ), namely that it is the cartesian product of n
Riemannian manifolds (Mi, ρi), where ρ is the induced product metric:
ρ1	.
M := Mi × …× Mn, P :=	...	.	(7)
Product notations. The induced distance function d on M is known to be given by d(x, y)2 =
Pin=1 di(xi, yi)2, where di is the distance in Mi. The tangent space at x = (x1, ..., xn) is given by
TxM = Txi Mi ㊉•…㊉ TxnMn, and the Riemannian gradient g of a smooth function f : M → R
at point X ∈ M is simply the concatenation g = ((g1)T …(gn)T)T of the Riemannian gradients
gi ∈ Txi Mi of each partial map fi : y ∈ Mi 7→ f(xi, ..., xi-i, y, xi+i, ..., xn). Similarly, the
exponential, log map and the parallel transport in M are the concatenations of those in each Mi .
Riemannian Adagrad. We just saw in the above discussion that designing meaningful adaptive
schemes - intuitively corresponding to one learning rate per coordinate - in a general Riemannian
manifold was difficult, because of the absence of intrinsic coordinates. Here, we propose to see each
component xi ∈ Mi of x as a “coordinate”, yielding a simple adaptation of Eq. (3) as
xi+i - eχp)t 卜αg"t X kgikkx)	⑻
On the adaptivity term. Note that we take (squared) Riemannian norms kgti k2xi = Pkxi (gtk, gtk) in
the adaptivity term rescaling the gradient. In the Euclidean setting, this quantity is simply a scalar
(gtk)2, which is related to the size of an SGD update of the ith coordinate, rescaled by the learning
4because the Poisson bracket cancels at critical points (Milnor, 1963, part 1.2).
5The rotational component of parallel transport inherited from curvature is called the holonomy.
4
Published as a conference paper at ICLR 2019
rate (See Eq. (1)): |gi| = |x；+i - Xi∣∕α. By analogy, note that the size of an RSGD update in
Mi (see Eq. (2)) is given by di(xit+1, xit) = di(expixi (-αgti), xit) = k - αgti kxi, hence we also
recover kgikXi = di(χi+ι, Xt)/α, which indeed suggests replacing the scalar (gi)2 by kgikXi when
transforming a coordinate-wise adaptive scheme into a manifold-wise adaptive one.
4 Ramsgrad, RadamNc: convergence guarantees
In section 2, we briefly presented Adagrad, Adam and Ams grad. Intuitively, Adam can be
described as a combination of ADAGRAD with a momentum (of parameter β1), with the slight
modification that the sum of the past squared-gradients is replaced with an exponential moving
average, for an exponent β2 . Let’s also recall that AMSGRAD implements a slight modification of
Adam, allowing to correct its convergence proof. Finally, AdamNc is simply Adam, but with a
particular non-constant schedule for β1 and β2. On the other hand, what is interesting to note is that
the schedule initially proposed by Reddi et al. (2018) for β2 in ADAMNC, namely β2t := 1 - 1/t,
lets vt recover the sum of squared-gradients of ADAGRAD. Hence, ADAMNC without momentum
(i.e. β1t = 0) yields ADAGRAD.
Assumptions and notations. For 1 ≤ i ≤ n, we assume (Mi, ρi) is a geodesically complete
Riemannian manifold with sectional curvature lower bounded by κi ≤ 0. As written in Eq. (7), let
(M, ρ) be the product manifold of the (Mi, ρi )'s. For each i, let Xi ⊂ Mi be a compact, geodesically
convex set and define X := Xi X …X Xn, the set of feasible parameters. Define Πχi : Mi → Xi to
be the projection operator, i.e. ΠXi (x) is the unique y ∈ Xi minimizing di(y, x). Denote by Pi, expi
and logi the parallel transport, exponential and log maps in (Mi, ρi), respectively. For f : M → R,
if g = gradf (x) for x ∈ M, denote by xi ∈ Mi and by gi ∈ TXi Mi the corresponding components
ofx and g. In the sequel, let (ft) be a family of differentiable, geodesically convex functions from M
to R. Assume that each Xi ⊂ Mi has a diameter bounded by D∞ and that for all 1 ≤ i ≤ n, t ∈ [T]
and x ∈ X, k(gradft(x))ikXi ≤ G∞. Finally, our convergence guarantees will bound the regret,
defined at the end of T rounds as RT = PtT=1 ft(xt) - minX∈X PjT=1 fj (x), so that RT = o(T).
Finally,夕Xi→yi denotes any isometry from TXiMi to TyiMi, for xi, yi ∈ Mi.
Following the discussion in section 3.2 and especially Eq. (8), we present Riemannian Amsgrad in
Figure 1a. For comparison, we show next to it the standard Amsgrad algorithm in Figure 1b.
Require: x1 ∈ X, {αt}tT=1, {β1t}tT=1, β2
Set mo = 0, τo = 0, vo = 0 and Vo = 0
for t = 1 to T do (for all 1 ≤ i ≤ n)
gt = gradft(xt)
mit = β1tτti-1 + (1 - β1t)gti
vti = β2vti-1 + (1 - β2)kgtik2Xi
Vi =maχ{vi-i,vi}
xt+ι = πχi (expXi (-αtmit/PI))
T = Qi -χt+Jmi)
end for
(a)	Ramsgrad in Mi X …X Mn.
Require: x1 ∈ X, {αt}tT=1, {β1t}tT=1, β2
Set mo = 0, vo = 0 and Vo = 0
for t = 1 to T do (for all 1 ≤ i ≤ n)
gt = gradft(xt)
mit = β1tmti-1 + (1 - β1t)gti
vti = β2vti-1 + (1 - β2 )(gti)2
Vi = maχ{vi-i,vi}
xt+ι = πXi (Xt- at mt/ Pi
end for
(b)	AMSGRAD in Rn .
Figure 1: Comparison of the Riemannian and Euclidean versions of Amsgrad.
Write hi := -αtmjt/∙∖∕Vt^. As a natural choice for H one could first parallel-transport6 mit from Xi
to Xi+ι := expχi (ht) using Pi(∙; ht), and then from Xtt+i to xtt+i along a minimizing geodesic.
As can be seen, if (Mi, ρi) = R for all i, RAMSGRAD and AMSGRAD coincide: we then have κi = 0,
di(xi,yi) = ∣xi - yi∣, ψi = Id, expXi(vi) = Xi + Vi, Mi x ∙∙∙ x Mn = Rn,	= (gi)2 ∈ R.
6The idea of parallel-transporting mt from TxtM to Txt+1 M previously appeared in Cho & Lee (2017).
5
Published as a conference paper at ICLR 2019
From these algorithms, RADAM and ADAM are obtained simply by removing the max operations,
i.e. replacing ^ = max{vi-ι,vj} with Vi = Vt. The convergence guarantee that We obtain for
RAMSGRAD is presented in Theorem 1, where the quantity ζ is defined by Zhang & Sra (2016) as
ζ(κ, c)
C /H
tanh(c ∙χ∕[K^)
1 + 3 ∣κ∣ + Oκ→0(κ2).
(9)
For comparison, we also show the convergence guarantee of the original Amsgrad in appendix C.
Note that when (Mi, ρi) = R for all i, convergence guarantees between RAMSGRAD and AMSGRAD
coincide as well. Indeed, the curvature dependent quantity (ζ(κi, D∞) + 1)/2 in the Riemannian
case then becomes equal to 1, recovering the convergence theorem of AMSGRAD. It is also interesting
to understand at which speed does the regret bound worsen when the curvature is small but non-zero:
by a multiplicative factor of approximately 1 + D∞∣κ∣∕6 (see Eq.(9)). Similar remarks hold for
RADAMNC, whose convergence guarantee is shown in Theorem 2. Finally, notice that β1 := 0 in
Theorem 2 yields a convergence proof for Radagrad, whose update rule we defined in Eq. (8).
Theorem 1 (Convergence of RAMSGRAD). Let (Xt) and (Vt) be the sequences obtained from
Algorithm 1a, ɑ = α∕y∕t,, βι = βιι, βιt ≤ βι forall t ∈ [T] and Y = β1∕√β2 < 1. We then have:
RT ≤
√Td∞
2α(I - βI)
n
X
i=1
+
+ 2(1-βι) i=1 t=1
α √1 + log T
(I-尸I)2(1 - Y)√1 - %
X y∞≡UX kgikx
(10)
Proof. See appendix A.
□
Theorem 2 (Convergence of RADAMNC). Let (xt) and (Vt) be the sequences obtained from
RadamNc, at = α∕√t, βι = β11, βιt = β1λt-1, λ < 1, β2t = 1 — 1/t. We then have:
RT
≤
a(ζ(κi,D∞) + I))
十一m3一)
βιD∞ G∞n
2a(1 - βι)(1 — λ)2
(11)
Proof. See appendix B.	□
The role of convexity. Note how the notion of convexity in Theorem 5 got replaced by the notion
of geodesic convexity in Theorem 1. Let us compare the two definitions: the differentiable functions
f : Rn → R and g : M → R are respectively convex and geodesically convex if for all x, y ∈ Rn,
u, V ∈ M:
f(x) - f(y) ≤ hgradf (x), x - yi, g(u) - g(V) ≤ ρu(gradg(u),-logu(V)).	(12)
But how does this come at play in the proofs? Regret bounds for convex objectives are usually
obtained by bounding PT=I ft(xt) — ft(x*) using Eq. (12) for any x* ∈ X, which boils down to
bounding each hgt, Xt - x*). In the Riemannian case, this term becomes Pxt (gt, — logχt (x*)).
The role of the cosine law. How does one obtain a bound on hgt, xt - x*i? For simplicity, let us
look at the particular case of an sgd update, from Eq. (1). Using a cosine law, this yields
hgt,χt- χ*i = 2α (kχt- χ*k2 - kχt+ι- χ*k2)+ 2 ι∣gtk2.	(13)
One now has two terms to bound: (i) when summing over t, the first one simplifies as a telescopic
summation; (ii) the second term PtT=1 αt ιgt ι2 will require a well chosen decreasing schedule for α.
In Riemannian manifolds, this step is generalized using the analogue lemma 6 introduced by Zhang &
Sra (2016), valid in all Alexandrov spaces, which includes our setting of geodesically convex subsets
of Riemannian manifolds with lower bounded sectional curvature. The curvature dependent quantity
ζ of Eq. (10) appears from this lemma, letting us bound ρi i (gti, - logi i (xi )).
xt	xt
6
Published as a conference paper at ICLR 2019
The benefit of adaptivity. Let us also mention that the above bounds significantly improve for
sparse (per-manifold) gradients. In practice, this could happen for instance for algorithms embedding
each word i (or node of a graph) in a manifold Mi and when just a few words are updated at a time.
On the choice of 夕i. The fact that our convergence theorems (See lemma 3) do not require specify-
ing 夕i suggests that the regret bounds could be improved by exploiting momentum/acceleration in
the proofs for a particular φi. Note that this remark also applies to AMSGRAD (Reddi et al., 2018).
5 Experiments
We empirically assess the quality of the proposed algorithms: Radam, Ramsgrad and Radagrad
compared to the non-adaptive Rsgd method (Eq. 2). For this, we follow (Nickel & Kiela, 2017) and
embed the transitive closure of the WordNet noun hierarchy (Miller et al., 1990) in the n-dimensional
Poincare model Dn of hyperbolic geometry which is well-known to be better suited to embed tree-like
graphs than the Euclidean space (Gromov, 1987; De Sa et al., 2018). In this case, each word is
embedded in the same space of constant curvature -1, thus Mi = Dn, ∀i. Note that it would also
be interesting to explore the benefit of our optimization tools for algorithms proposed in (Nickel &
Kiela, 2018; De Sa et al., 2018; Ganea et al., 2018a). The choice of the POinCare model is justified by
the access to closed form expressions for all the quantities used in Alg. 1a:
•	Metric tensor: Px = λχin, ∀x ∈ Dn, where λχ = 1/k? is the conformal factor.
•	Riemannian gradients are rescaled Euclidean gradients: gradf(x) = (1∕λx)VE f(x).
•	Distance function and geodesics, (Nickel & Kiela, 2017; Ungar, 2008; Ganea et al., 2018b).
•	Exponential and logarithmic maps: expx(v) = X ㊉(tanh (λx2vk)向)，where ㊉ is the
generalized Mobius addition (Ungar, 2008; Ganea et al., 2018b).
•	Parallel transport along the unique geodesic from X to y: Px→y(v) = λλx ∙ gyr[y, -χ]v. This
formula was derived from (Ungar, 2008; Ganea et al., 2018b), gyr being given in closed
form in (Ungar, 2008, Eq. (1.27)).
Dataset & Model. The transitive closure of the WordNet taxonomy graph consists of 82,115 nouns
and 743,241 hypernymy Is-A relations (directed edges E). These words are embedded in Dn such that
the distance between words connected by an edge is minimized, while being maximized otherwise.
We minimize the same loss function as (Nickel & Kiela, 2017) which is similar with log-likelihood,
but approximating the partition function using sampling of negative word pairs (non-edges), fixed to
10 in our case. Note that this loss does not use the direction of the edges in the graph7
e-dD(u,v)
L(θ) = P
e —dD(u0,v)
(u,v)∈E	u0∈N (v) e D
(14)
Metrics. We report both the loss value and the mean average precision (MAP) (Nickel & Kiela,
2017): for each directed edge (u, v), we rank its distance d(u, v) among the full set of ground
truth negative examples {d(u0, v)|(u0, v) ∈∕ E}. We use the same two settings as (Nickel & Kiela,
2017), namely: reconstruction (measuring representation capacity) and link prediction (measuring
generalization). For link prediction we sample a validation set of 2% edges from the set of transitive
closure edges that contain no leaf node or root. We only focused on 5-dimensional hyperbolic spaces.
Training details. For all methods we use the same “burn-in phase” described in (Nickel & Kiela,
2017) for 20 epochs, with a fixed learning rate of 0.03 and using RSGD with retraction as explained
in Sec. 2.2. Solely during this phase, we sampled negative words based on their graph degree raised
at power 0.75. This strategy improves all metrics. After that, when different optimization methods
start, we sample negatives uniformly. We use n = 5, following Nickel & Kiela (2017).
7In a pair (u, v), u denotes the parent, i.e. u entails v - parameters θ are coordinates of all u, v.
7
Published as a conference paper at ICLR 2019
Optimization methods. Experimentally we obtained slightly better results for RADAM over RAMS-
grad, so we will mostly report the former. Moreover, we unexpectedly observed convergence to
lower loss values when replacing the true exponential map with its first order approximation - i.e.
the retraction Rx(v) = x + v - in both RSGD and in our adaptive methods from Alg. 1a. One
possible explanation is that retraction methods need fewer steps and smaller gradients to “escape”
points sub-optimally collapsed on the ball border of Dn compared to fully Riemannian methods. As
a consequence, we report “retraction”-based methods in a separate setting as they are not directly
comparable to their fully Riemannian analogues.
Figure 2: Results for methods doing updates with the exponential map. From left to right we report:
training loss, MAP on the train set, MAP on the validation set.
Figure 3: Results for methods doing updates with the retraction. From left to right we report: training
loss, MAP on the train set, MAP on the validation set.
Results. We show in Figures 2 and 3 results for “exponential” based and “retraction” based methods.
We ran all our methods with different learning rates from the set {0.001, 0.003, 0.01, 0.03, 0.1, 0.3,
1.0, 3.0}. For the RSGD baseline we show in orange the best learning rate setting, but we also show
the previous lower (slower convergence, in blue) and the next higher (faster overfitting, in green)
learning rates. For RADAM and RAMSGRAD we only show the best settings. We always use β1 = 0.9
and β2 = 0.999 for these methods as these achieved the lowest training loss. RADAGRAD was
consistently worse, so we do not report it. As can be seen, Radam always achieves the lowest
training loss. On the MAP metric for both reconstruction and link prediction settings, the same method
also outperforms all the other methods for the full Riemannian setting (i.e. Tab. 2). Interestingly, in
the “retraction” setting, Radam reaches the lowest training loss value and is on par with Rsgd on
the MAP evaluation for both reconstruction and link prediction settings. However, Ramsgrad is
faster to converge in terms of MAP for the link prediction task, suggesting that this method has a
better generalization capability.
6	Related work
After Riemannian sgd was introduced by Bonnabel (2013), a pletora of other first order Riemannian
methods arose, such as Riemannian svrg (Zhang et al., 2016), Riemannian Stein variational gradient
descent (Liu & Zhu, 2017), Riemannian accelerated gradient descent (Liu et al., 2017; Zhang & Sra,
2018) or averaged rsgd (Tripuraneni et al., 2018), along with new methods for their convergence
analysis in the geodesically convex case (Zhang & Sra, 2016). Stochastic gradient Langevin dynamics
was generalized as well, to improve optimization on the probability simplex (Patterson & Teh, 2013).
Let us also mention that Roy et al. (2018) proposed Riemannian counterparts of SGD with momentum
and RMSprop, suggesting to transport the momentum term using parallel translation, which is an
idea that we preserved. However (i) no convergence guarantee is provided and (ii) their algorithm
8
Published as a conference paper at ICLR 2019
performs the coordinate-wise adaptive operations (squaring and division) w.r.t. a coordinate system
in the tangent space, which, as we discussed in section 3.1, compromises the possibility of obtaining
convergence guarantees. Finally, another version of Riemannian Adam for the Grassmann manifold
G(1, n) was previously introduced by Cho & Lee (2017), also transporting the momentum term using
parallel translation. However, their algorithm completely removes the adaptive component, since the
adaptivity term vt becomes a scalar. No adaptivity across manifolds is discussed, which is the main
point of our discussion. Moreover, no convergence analysis is provided either.
7	Conclusion
Driven by recent work in learning non-Euclidean embeddings for symbolic data, we propose to
generalize popular adaptive optimization tools (e.g. ADAM, AMSGRAD, ADAGRAD) to Cartesian
products of Riemannian manifolds in a principled and intrinsic manner. We derive convergence rates
that are similar to the Euclidean corresponding models. Experimentally we show that our methods
outperform popular non-adaptive methods such as Rsgd on the realistic task of hyperbolic word
taxonomy embedding.
Acknowledgments
Gary BecigneUl is funded by the Max Planck ETH Center for Learning Systems. Octavian Ganea is
funded by the Swiss National Science Foundation (SNSF) under grant agreement number 167176.
References
Peter Auer, Nicolo Cesa-Bianchi, and Claudio Gentile. Adaptive and self-confident on-line learning
algorithms. Journal of Computer and System Sciences, 64(1):48-75, 2002.
Silvere Bonnabel. Stochastic gradient descent on riemannian manifolds. IEEE Transactions on
Automatic Control, 58(9):2217-2229, 2013.
Anoop Cherian and Suvrit Sra. Riemannian dictionary learning and sparse coding for positive definite
matrices. IEEE transactions on neural networks and learning systems, 28(12):2859-2871, 2017.
Minhyung Cho and Jaehyung Lee. Riemannian approach to batch normalization. In Advances in
Neural Information Processing Systems, pp. 5225-5235, 2017.
Christopher De Sa, Albert Gu, Christopher Re, and Frederic Sala. Representation tradeoffs for
hyperbolic embeddings. 2018. URL https://www.cs.cornell.edu/~cdesa/papers/
arxiv2018_hyperbolic.pdf.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and
stochastic optimization. Journal of Machine Learning Research, 12(Jul):2121-2159, 2011.
Octavian-Eugen Ganea, Gary Becigneul, and Thomas Hofmann. Hyperbolic entailment cones for
learning hierarchical embeddings. In International Conference on Machine Learning, 2018a.
Octavian-Eugen Ganea, Gary Becigneul, and Thomas Hofmann. Hyperbolic neural networks. In
Advances in Neural Information Processing Systems, 2018b.
Mikhael Gromov. Hyperbolic groups. In Essays in group theory, pp. 75-263. Springer, 1987.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International
Conference on Learning Representations, 2015.
Chang Liu and Jun Zhu. Riemannian stein variational gradient descent for bayesian inference. arXiv
preprint arXiv:1711.11216, 2017.
Yuanyuan Liu, Fanhua Shang, James Cheng, Hong Cheng, and Licheng Jiao. Accelerated first-order
methods for geodesically convex optimization on riemannian manifolds. In Advances in Neural
Information Processing Systems 30, pp. 4868-4877. 2017.
9
Published as a conference paper at ICLR 2019
George A Miller, Richard Beckwith, Christiane Fellbaum, Derek Gross, and Katherine J Miller.
Introduction to wordnet: An on-line lexical database. International journal of lexicography, 3(4):
235-244,1990.
John Milnor. Morse Theory.(AM-51), volume 51. Princeton university press, 1963.
Maximilian Nickel and Douwe Kiela. Learning continuous hierarchies in the lorentz model of
hyperbolic geometry. In International Conference on Machine Learning, 2018.
MaXimillian Nickel and DouWe Kiela. Poincare embeddings for learning hierarchical representations.
In Advances in Neural Information Processing Systems, pp. 6341-6350, 2017.
Sam Patterson and Yee Whye Teh. Stochastic gradient riemannian langevin dynamics on the
probability simpleX. In Advances in Neural Information Processing Systems, pp. 3102-3110, 2013.
Jeffrey Pennington, Richard Socher, and Christopher D Manning. Glove: Global vectors for Word
representation. In EMNLP, volume 14, pp. 1532-43, 2014.
Sashank J Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In ICLR,
2018.
Joel W Robbin and Dietmar A Salamon. Introduction to differential geometry. ETH, Lecture Notes,
preliminary version, January, 2011.
S Kumar Roy, Zakaria Mhammedi, and Mehrtash Harandi. Geometry aWare constrained optimization
techniques for deep learning. CVPR, 2018.
Michael Spivak. A comprehensive introduction to differential geometry. volume four. 1979.
Suvrit Sra and Reshad Hosseini. Conic geometric optimization on the manifold of positive definite
matrices. SIAM Journal on Optimization, 25(1):713-739, 2015.
Mingkui Tan, Ivor W Tsang, Li Wang, Bart Vandereycken, and Sinno Jialin Pan. Riemannian pursuit
for big matriX recovery. In International Conference on Machine Learning, pp. 1539-1547, 2014.
Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running
average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26-31,
2012.
Nilesh Tripuraneni, Nicolas Flammarion, Francis Bach, and Michael I Jordan. Averaging stochastic
gradient descent on riemannian manifolds. In Conference On Learning Theory, COLT 2018,
Stockholm, Sweden, 6-9 July 2018., 2018.
Abraham Albert Ungar. A gyrovector space approach to hyperbolic geometry. Synthesis Lectures on
Mathematics and Statistics, 1(1):1-194, 2008.
Bart Vandereycken and Stefan VandeWalle. A riemannian optimization approach for computing
loW-rank solutions of lyapunov equations. SIAM Journal on Matrix Analysis and Applications, 31
(5):2553-2579, 2010.
Tran Dang Quang Vinh, Yi Tay, Shuai Zhang, Gao Cong, and Xiao-Li Li. Hyperbolic recommender
systems. arXiv preprint arXiv:1809.01703, 2018.
MattheW D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701,
2012.
Hongyi Zhang and Suvrit Sra. First-order methods for geodesically conveX optimization. In
Conference on Learning Theory, pp. 1617-1638, 2016.
Hongyi Zhang and Suvrit Sra. ToWards riemannian accelerated gradient methods. arXiv preprint
arXiv:1806.02812, 2018.
Hongyi Zhang, Sashank J Reddi, and Suvrit Sra. Riemannian svrg: Fast stochastic optimization on
riemannian manifolds. In Advances in Neural Information Processing Systems, pp. 4592-4600,
2016.
10
Published as a conference paper at ICLR 2019
A Proof of Theorem 1
Proof. Denote by X；+i := exp；i (-ɑtmit/y/V) and consider the geodesic triangle defined by X；+i,
Xt and x：. Now let a = di(xt+ι, x*), b = di(xt+ι, xi), c = di(xt,x" and A = ∠Xi+ιx；x：.
Combining the following formula8:
di(Xt,xt+ι )di (χt, x：) cos(∠χi+ιχtχ:)=h-αtm^yviιOgxt(X"ixi,	(15)
with the following inequality (given by lemma 6):
a2 ≤ ζ(κ, c)b2 + c2 - 2bc cos(A),
with
ζ(κ, c)
vzHc
tanh( ʌ∕jK∣c)'
(16)
yields
,	.	,，八	λ∕Vi /	.…	. 一、
h-mt,logxt(x*)ixt ≤ * (di(xt,x"2 - di(Xi+ι,x"2)
+ Z (Ki,di(xt,x") -αt= kmtkxi,	(17)
2 √vi	t
where the use the notation h∙, ∙ixi for ρxi(∙, ∙) When it is clear which metric is used. By defi-
nition of Πχi, we can safely replace Xt+ι by xt+i in the above inequality. Plugging mt =
βιt%一→xi (mi-1)+ (1 - βιt)gi into Eq. (17) gives US
h-gi, logxt (X "ixt ≤ 2α (竹 βι J (di (Xt ,C"2 - di(xt+l,X：)2
+ Z (Ki,di(xt，x：))
αt
2(1 - βιt) V^
kmitk2xit
β1t
+ (1 - βιt) hψxt-1 →xt (mt-1), logxt (Xi )ixt.
(18)
Now applying Cauchy-Schwarz’ and Young’s inequalities to the last term yields
h-gti,logxit(Xi：)ixit ≤
√^t
2αt(1 - βIt)
(dt(Xt,Xt)2 - di(Xt+i,X：)2)
+ Z(κt,di (x")
αt
2(1 - βιt) √^ik
mttk2xit
Bit	at
2(1 - βIt) p^t
kmtt-ik2xit-1
βit	√H
2(I- βIt) αt
k logxti(Xt：)k2xit.
(19)
+
+
From the geodesic convexity of ft for 1 ≤ t ≤ T , we have
T	T	nT
Xft(Xt) - ft(X：) ≤ Xh-gt, logxt (X：)ixt = XXh-gtt,logtxit(Xt：)ixit.	(20)
8 Note that since each Xi is geodesically convex, logarithms are well-defined.
11
Published as a conference paper at ICLR 2019
Let’s look at the first term. Using β1t ≤ β1 and with a change of indices, we have
nT
Xi=1Xt=1
2αt(1 - β1t)
(di(xi,x：)2 - di(xt+1,xD2
/	1
≤ 2(1- βι)
/	1
≤ 2(1- βι)
D∞2
nT
Xi=1Xt=2
nT
Xi=1Xt=2
n
2αT (1 - β1)
叵
αt
αt
X历,
i=1
αt-1
Vt-I
αt-1
一	JL .廨	一
di(*x；)2 + X ɪɪdi(x1,x"2
匕ɑι
n
D∞ + X 正 D∞
∞	i=1 α1	∞
(21)
(22)
(23)
(24)
—
—
where the last equality comes from a standard telescopic summation. We now need the following
lemma.
Lemma 3.
T
X pα⅛ kmikχi≤
(1- β	‰ UX kgtkxi
(25)
Proof. Let’s start by separating the last term, and removing the hat on v.
T	T-1
XpikmikXi ≤ X p⅛kmtkXi + p⅛kmτ∣∣X⅛	(26)
M √vi	t M √vi	t	√vT	T
T-1
≤ X pikmtkXi+ -Tf-kmτl∣Xi,	(27)
M √vi	t	√vT	T
Let’s now have a closer look at the last term. We can reformulate miT as:
T	T-j
mT = X(1 - β1j )( Y β1,(T-k+1))gXT-1→XT ◦•••◦ φlχj →xj+ι (gj )	(28)
j=1	k=1
Applying lemma 7, we get
kmiTk2xiT≤
X(1 - β1j) (Y β1,(Τ-k + 1)) j ×
j=1	k=1
X(I- β1j) Y Y β1,(T-k+1)) k*-1→xT。…。i⅛j→xj + 1(gj)kXT
j=1	k=1
Since 炉 is an isometry, We always have ki⅛→y(u)ky = ∣∣u∣χ, i.e.
kHT,ι→xT ◦•••◦ ψlxj →χj+ι (gj )kXT = kgj IlXj.
Using that β1k ≤ β1 for all k ∈ [T],
kmTkXT≤ 住(1-βj)βTj 住(1-βj)βT-jkgjkXj
Finally, (1 - β1j) ≤ 1 and PjT=1 β1T -j ≤ 1/(1 - β1) yield
kmTkXT≤ τ⅛ (XβT-jkgjkXj).
(29)
(30)
(31)
(32)
12
Published as a conference paper at ICLR 2019
Let’s now look at vTi . It is given by
T
vTi = (1 - β2)Xβ2T-jkgjik2xij	(33)
j=1
Combining Eq. (32) and Eq. (33) allows us to bound the last term of Eq. (26):
ρ⅛ kmT kxT ≤
α
PjT=1β1T-jkgjik2xij
≤
α
(1 - βι) Vt
T
X
j=1
β1T -jkgjik2xij
α
，(1- β2)βT-jkgjkXi
T
(I - β1) VZT(I - 82)
γT-jkgjikxij
With this inequality, we can now bound every term of Eq. (26):
TT
X P⅛ kmikxi≤ X
α
t
(1 - βι)VZt(I- β2) j=1 Yt jkgjkxj
α
(1 - βι )√Γ-？2
T1t
X √t X γ t-jk 叽
α
T
T
≤
≤
≤
≤
(I - β )√1 - β2
∑>i kxj ∑γj-t∕Pj
α
t=1
T
j=t
T
(1 - βι) λ∕1 — β2
∑kgi kxj ∑γj-t∕√t
α
(1 - βι )√Γ-?2
t=1
T
Xkgtik
t=1
j=t
1
Xj (1 - γ)√t
α
(I - βι)(1 - γ)√1 - β2
X kgtkxj tXX1
α √1 + log T
(I - βι)(1 - γ)√1 - β2
Putting together Eqs. (19), (20), (24) and lemma 3 lets us bound the regret:
T
nT
Eft(Xt)- ft(χ*) ≤ EEh-gi, logxi (W)ixi
t=1
≤	√Td∞
-2α(1 - βι)
i=1 t=1
Xqvf+
i=1
D∞2
2(1 - β1)
n T	E
XX βιt Pt
t
i=1 t=1
+
α √1 + log T
(I- βl)2(1 - γ)√1 - β2
n
X
i=1
2
ζ(κi, D∞) + 1
T
Xkgtik2xi,
t=1	j
(34)
(35)
(36)
(37)
(38)
(39)
(40)
(41)
(42)
(43)
□
(44)
(45)
(46)
13
Published as a conference paper at ICLR 2019
where we used the facts that d → Z(κ, d) is an increasing function, and that at/ p∕V^i ≤ αt-ι/,连-、,
which enables us to bound both the second and third terms of the right-hand side of Eq. (19) using
lemma 3.
□
Remark. Let Us notice that similarly as for Amsgrad, RAMSGRAD also has a regret bounded by
O(G∞Tt). This is easy to see from the proof of lemma 4. Hence the actual upper-bound on the
regret is a minimum between the one in O(G∞ √T) and the one of Theorem 1.
B Proof of Theorem 2
Proof. Similarly as for the proof of Theorem 1 (and with same notations), we obtain the inequality:
vi
h-gt, logχt (W)ixt ≤
2αt(1 - β1t)
(di(xt,xi)2 - di(xt+ι,xi)2
+ Z(Ki,di(x")
αt
2(1 - βιt) √Vik
mitk2xit
β1t αt
2(I- βIt) Pi
kmi-ιkxt-ι+2(i -tβ1t) a~ k ιogxt (W)kxt∙
(47)
+
From the geodesic convexity of ft for 1 ≤ t ≤ T, we have
T
T
nT
Eft(Xt)- ft(x*) ≤ Eh-gt,iogχt (χ* %t = E h-gi-og ιogχt (XiJixt.
(48)
t=1
t=1
i=1 t=1
With the same techniques as before, we obtain the same bound on the first term:
nT
XX
i=1 t=1
2αt (1 - β1t)
(di(χt,χ"2- di(χt+ι,χ"2) ≤ 2aτ d2- β)X qvτ.
(49)
However, for the other terms, we now need a new lemma:
Lemma 4.
T
X Wkmtkxi≤「
T
Xkgtik2xit.
t=1
(50)
Proof. Let’s start by separating the last term.
T
XjOt= kmtkxt
t=1 vti	t
Similarly as before, we have
T-1
X W kmtkxt+p⅛ kmT kxT.
(51)
kmiTk2xiT
i⅛ (XβT-jkgjkxj
(52)
vi
≤
≤
Let’s now look at vTi . Since β2t = 1 - 1/t, it is simply given by
T
vTi =Xkgtik2xit/T.
(53)
Combining these yields:
Pr kmT kxτ
1-β1	√∑T=ι kgikxi
β1T-jkgjik2xij
M=I kgk %
≤
α
α
T
≤ K j=1
(54)
14
Published as a conference paper at ICLR 2019
Using this inequality at all time-steps gives
T
X pαvi km；%
α χ P=O β1 k%kXj
1-β1 j=1 qPk=ιkgk kXi
α χ	kgjkXj
(ι - β1)2 j=ι q∑π⅞
≤
where the last inequality comes from lemma 8.
(55)
(56)
(57)
□
Putting everything together, we finally obtain
T	nT
Xft(xt) - ft(x*) ≤ XXh-gi, logχt (Xi)iXt
≤ √TD∞ X Γ7 +	D∞	X X β Pvi
-2α(1 - βι)鼻,T 2(1- βι)之？1tF
T
+ (1-⅛y ∑(Z (Ki,D∞) + i)∖∣ ∑kgikXj,
(58)
(59)
(60)
where We used that for this choice of at and β2t, We have at/ʌ/vi ≤ αt-1/∖∕vi-ι∙ Finally,
D∞ X X β Pvi V D∞G∞n X ∕tβ V β1D∞G∞n
2(1- βι) = = β1tF ≤ 2ɑ(1- βι) U β1t ≤ 2a(1- βι)(1 - λ)2 .
This combined With Eq. (53) yields the final result.
(61)
□
Remark. Notice the appearance of a factor n/a in the last term of the last equation. This term is
missing in corollaries 1 and 2 of Reddi et al. (2018), Which is a mistake. HoWever, this dependence in
n is not too harmful here, since this term does not depend on T.
C	Amsgrad
Theorem 5 (Convergence of AMSGRAD). Let (ft) be a family of differentiable, convex functions
from Rn to R. Let(Xt) and (Vt) be the sequences obtainedfrom Algorithm 1b, a = a∕√t, βι = β11,
βιt ≤ βι for all t ∈ [T] and Y = β1∕√β2 < 1. Assume that each Xi ⊂ R has a diameter bounded
by D∞ and that for all 1 ≤ i ≤ n, t ∈ [T] and X ∈ X, k(gradft(X))k∞ ≤ G∞. For (Xt) generated
using the AMS GRAD (Algorithm 1b), we have the following bound on the regret
RT≤
√Td∞
2a(1 - βI)
n	t—
X ^T++
i=1
D∞
2(1 - βι)
+
≤
≤
n
a √1 + log T
(1 - β1)2(1 - Y)√1 - β2
n uT
X utX(gti)2	(62)
i=1	t=1
Proof. See Theorem 4 of Reddi et al. (2018).
□
15
Published as a conference paper at ICLR 2019
D Useful lemmas
The following lemma is a user-friendly inequality developed by Zhang & Sra (2016) in order to
prove convergence of gradient-based optimization algorithms, for geodesically convex functions, in
Alexandrov spaces.
Lemma 6 (Cosine inequality in Alexandrov spaces). If a, b, c, are the sides (i.e., side lengths) of a
geodesic triangle in an Alexandrov space with curvature lower bounded by κ, and A is the angle
between sides b and c, then
a2 ≤ --Kjc__b2 + C _ 2bc Cos(A).	(63)
一tanh( √∣K∣c)
Proof. See section 3.1, lemma 6 of Zhang & Sra (2016).
□
Lemma 7 (An analogue of Cauchy-Schwarz). For allp, k ∈ N*, uι,..., Uk ∈ Rp, aι,..., ak ∈ R+,
we have
k	aiuik22 ≤
i
(64)
Proof. The proof consists in applying Cauchy-Schwarz’ inequality two times:
k	aiuik22 =
i	i,j
aiajui uj
=):√aiaj ( √aiui )	( √ajUj )
i,j
≤〉: √aiaj k √aiui ∣∣2 k √ajUj k 2
(65)
(66)
(67)
(68)
(69)
□
Finally, this last lemma is used by Reddi et al. (2018) in their convergence proof for AdamNc. We
need it too, in an analogue lemma.
Lemma 8 ((Auer et al., 2002)). For any non-negative real numbers y1, ..., yt, the following holds:
t
X
i=1
y
q∑j-=ι yj
≤2t
t
X yi .
i=1
(70)
16