Published as a conference paper at ICLR 2019
GO Gradient for Expectation-Based
Objectives
Yulai Cong*	Miaoyun Zhao*	Ke Bai LaWrence Carin
Department of Electrical and Computer Engineering, Duke University
Ab stract
Within many machine learning algorithms, a fundamental problem concerns effi-
cient calculation of an unbiased gradient wrt parameters γ for expectation-based
objectives Eqγ(y) [f (y)]. Most existing methods either (i) suffer from high vari-
ance, seeking help from (often) complicated variance-reduction techniques; or (ii)
they only apply to reparameterizable continuous random variables and employ a
reparameterization trick. To address these limitations, we propose a General and
One-sample (GO) gradient that (i) applies to many distributions associated with
non-reparameterizable continuous or discrete random variables, and (ii) has the
same low-variance as the reparameterization trick. We find that the GO gradient
often works well in practice based on only one Monte Carlo sample (although one
can of course use more samples if desired). Alongside the GO gradient, we develop
a means of propagating the chain rule through distributions, yielding statistical
back-propagation, coupling neural networks to common random variables.
1	Introduction
Neural networks, typically trained using back-propagation for parameter optimization, have recently
demonstrated significant success across a wide range of applications. There has been interest in
coupling neural networks with random variables, so as to embrace greater descriptive capacity. Recent
examples of this include black-box variational inference (BBVI) (Kingma & Welling, 2014; Rezende
et al., 2014; Ranganath et al., 2014; Hemgndez-Lobato et al., 2016; Ranganath et al., 2016b; Li
& Turner, 2016; Ranganath et al., 2016a; Zhang et al., 2018) and generative adversarial networks
(GANs) (Goodfellow et al., 2014; Radford et al., 2015; Zhao et al., 2016; Arjovsky et al., 2017; Li
et al., 2017; Gan et al., 2017; Li et al., 2018). Unfortunately, efficiently backpropagating gradients
through general distributions (random variables) remains a bottleneck. Most current methodology
focuses on distributions with continuous random variables, for which the reparameterization trick
may be readily applied (Kingma & Welling, 2014; Grathwohl et al., 2017).
As an example, the aforementioned bottleneck greatly constrains the applicability of BBVI, by
limiting variational approximations to reparameterizable distributions. This limitation excludes
discrete random variables and many types of continuous ones. From the perspective of GAN, the
need to employ reparameterization has constrained most applications to continuous observations.
There are many forms of data that are more-naturally discrete.
The fundamental problem associated with the aforementioned challenges is the need to efficiently
calculate an unbiased low-variance gradient wrt parameters γ for an expectation objective of the form
Eqγ (y) [f (y)]* 1. We are interested in general distributions qγ(y), for which the components of y may
be either continuous or discrete. Typically the components of y have a hierarchical structure, and a
subset of the components of y play a role in evaluating f (y).
Unfortunately, classical methods for estimating gradients of Eqγ (y) [f (y)] wrt γ have limitations.
The REINFORCE gradient (Williams, 1992), although generally applicable (e.g., for continuous
and discrete random variables), exhibits high variance with Monte Carlo (MC) estimation of the
* Correspondence to: Yulai Cong <yulaicong@gmail.com>, Miaoyun Zhao <miaoyun9zhao@gmail.com>.
1In this paper, we consider expectation objectives meeting basic assumptions: (i) qγ (y) is differentiable wrt
γ; (ii) f(y) is differentiable for continuous y; and (iii) f(y) < ∞ for discrete y. For simplicity of the main
paper, those assumptions are implicitly made, as well as fundamental rules like Leibniz’s rule.
1
Published as a conference paper at ICLR 2019
expectation, forcing one to apply additional variance-reduction techniques. The reparameterization
trick (Rep) (Salimans et al., 2013; Kingma & Welling, 2014; Rezende et al., 2014) works well, with
as few as only one MC sample, but it is limited to continuous reparameterizable y. Many efforts
have been devoted to improving these two formulations, as detailed in Section 6. However, none of
these methods is characterized by generalization (applicable to general distributions) and efficiency
(working well with as few as one MC sample).
The key contributions of this work are based on the recognition that REINFORCE and Rep are
seeking to solve the same objective, but in practice Rep yields lower-variance estimations, albeit for a
narrower class of distributions. Recent work (Ranganath et al., 2016b) has made a connection between
REINFORCE and Rep, recognizing that the former estimates a term the latter evaluates analytically.
The high variance by which REINFORCE approximates this term manifests high variance in the
gradient estimation. Extending these ideas, we make the following main contributions. (i) We
propose a new General and One-sample (GO) gradient in Section 3, that principally generalizes Rep
to many non-reparameterizable distributions and justifies two recent methods (Figurnov et al., 2018;
Jankowiak & Obermeyer, 2018); the “One sample” motivating the name GO is meant to highlight
the low variance of the proposed method, although of course one may use more than one sample
if desired. (ii) We find that the core of the GO gradient is something we term a variable-nabla,
which can be interpreted as the gradient of a random variable wrt a parameter. (iii) Utilizing variable-
nablas to propagate the chain rule through distributions, we broaden the applicability of the GO
gradient in Sections 4-5 and present statistical back-propagation, a statistical generalization of classic
back-propagation (Rumelhart & Hinton, 1986). Through this generalization, we may couple neural
networks to general random variables, and compute needed gradients with low variance.
2	Background
To motivate this paper, we begin by briefly elucidating common machine learning problems for which
there is a need to efficiently estimate gradients of γ for functions of the form Eqγ (y) [f (y)]. Assume
access to data samples {xi }i=1,N, drawn i.i.d. from the true (and unknown) underlying distribution
q(x). We seek to learn a model pθ (x) to approximate q(x). A classic approach to such learning
is to maximize the expected log likelihood θ = argmaxθ Eq(x) [log pθ (x)], perhaps with an added
regularization term on θ. Expectation Eq(χ)(∙) is approximated via the available data samples, as
θ = argmaxθN PN11 logpθ(xi).
It is often convenient to employ a model with latent variables z, i.e., pθ(x) = pθ (x, z)dz =
Ppθ(x∣z)p(z)dz, with prior p(z) on z. The integral wrt Z is typically intractable, motivating
introduction of the approximate posterior qφ(z∣x), with parameters φ. The well-known evidence
lower bound (ELBO) (Jordan et al., 1999; Bishop, 2006) is defined as
ELBO(θ, φ; x) = Eqφ(z∣χ)[logpθ(x, z) - log qφ(z∣x)]	(1)
=logPθ(X)- KL[qφ(z∣x)kPθ(z|x)] ≤ logPθ(x)	(2)
wherepθ(z|x) is the true posterior, and KL(∙k∙) represents the Kullback-Leibler divergence. Varia-
tional learning seeks (θ, φ) = argmax®# PN=I ELBO(θ, φ; Xi).
While computation of the ELBO has been considered for many years, a problem introduced recently
concerns adversarial learning of pθ (X), or, more precisely, learning a model that allows one to
efficiently and accurately draw samples X 〜p®(x) that are similar to X 〜q(x). With generative
adversarial networks (GANs) (Goodfellow et al., 2014), one seeks to solve
min max Eq(x) [log Dβ(X)] + Epθ(x) [log(1 - Dβ(X))] ,	(3)
θ β
where Dβ(X) is a discriminator with parameters β, quantifying the probability X was drawn from
q(X), with 1 - Dβ(X) representing the probability that it was drawn fromp®(X). There have been
many recent extensions of GAN (Radford et al., 2015; Zhao et al., 2016; Arjovsky et al., 2017; Li
et al., 2017; Gan et al., 2017; Li et al., 2018), but the basic setup in (3) holds for most.
To optimize (1) and (3), the most challenging gradients that must be computed are of the form
VγEqγ(y) [f (y)]; for (1) y = Z and Y = φ, while for (3) y = X and Y = θ. The need to evaluate
expressions like VYEqγ(y) [f (y)] arises in many other machine learning problems, and consequently
it has generated much prior attention.
2
Published as a conference paper at ICLR 2019
Evaluation of the gradient of the expectation is simplified if the gradient can be moved inside the
expectation. REINFORCE (Williams, 1992) is based on the identity
VYEqY(y) [f (y)] = EqY(y) f W)VY log qγ(y)].	⑷
While simple in concept, this estimate is known to have high variance when the expectation Eqγ(y)(∙)
is approximated (as needed in practice) by a finite number of samples.
An approach (Salimans et al., 2013; Kingma & Welling, 2014; Rezende et al., 2014) that has attracted
recent attention is termed the reparameterization trick, applicable when qY (y ) can be reparametrized
as y = Tγ(e), with E 〜q(e), where TY(e) is a differentiable transformation and q(e) is a simple
distribution that may be readily sampled. To keep consistency with the literature, we call a distribution
reparameterizable if and only if those conditions are satisfied2. In this case we have
Vγ Eqγ(y) [f(y)] = Eq(e)[[Vγ T Y (e)][Vy f (y)] ∣y=τ,(e)] ∙	(5)
This gradient, termed Rep, is typically characterized by relatively low variance, when approximating
Eq(e)(∙) with a small number of samples E 〜q(e). This approach has been widely employed for
computation of the ELBO and within GAN, but it limits one to models that satisfy the assumptions of
Rep.
3 GO Gradient
The reparameterization trick (Rep) is limited to reparameterizable random variables y with continuous
components. There are situations for which Rep is not readily applicable, e.g., where the components
of y may be discrete or nonnegative Gamma distributed. We seek to gain insights from the relationship
between REINFORCE and Rep, and generalize the types of random variables y for which the latter
approach may be effected. We term our proposed approach a General and One-sample (GO) gradient.
In practice, we find that this approach works well with as few as one sample for evaluating the
expectation, and it is applicable to more general settings than Rep.
Recall that Rep was first applied within the context of variational learning (Kingma & Welling,
2014), as in (1). Specifically, it was assumed qY(y) = Qv qY (yv), omitting explicit dependence on
data x, for notational convenience; yv is component v of y. In Kingma & Welling (2014) qY(yv)
corresponded to a Gaussian distribution q「(yv) = N(yv; μv(Y),σ2(γ)), with mean μv(Y) and
variance σv2(γ). In the following we generalize qY(yv) such that it need not be Gaussian. Applying
integration by parts (Ranganath et al., 2016b)
VYEqY(y)[f(y)] = XvEqY(y-v) R f(y)VYqY(yv)dyv]	(6)
= Xv EqY (y-v)h f (y)VγQγ(yv)]∣∞∞-R[VγQY(yv)]%。f(y)]dyV], (7)
'------------------------{z----------------------{-------------}
“0”	“Key”
where y-v denotes y with yv excluded, and QY(yv) is the cumulative distribution function (CDF)
of qY (yv). The “0” term is readily proven to be zero for any QY (yv), with the assumption that f(y)
doesn’t tend to infinity faster than VYQY(yv) tending to zero when yv → ±∞.
The “Key” term exactly recovers the one-dimensional Rep when reparameterization yv = τY (v),
Ev 〜q(∈v) exists (Ranganath et al., 2016b). Further, applying VYq?(yv) = q7 (yv )V? log q?(yv)
in (6) yields REINFORCE. Consequently, it appears that Rep yields low variance by analytically
setting to zero the unnecessary but high-variance-injecting “0” term, while in contrast REINFORCE
implicitly seeks to numerically implement both terms in (7).
We generalize qY(y) for discrete yv, here assuming yv ∈ {0, 1, . . . , ∞}. It is shown in Appendix
A.2 that this framework is also applicable to discrete yv with a finite alphabet. It may be shown (see
Appendix A.2) that
VY EqY (y)[f (y)] = Xv EqY (y-v) hXy f (y)VY qY (yv)i
= X EqY (y-v) h [f (y)VY QY (yv)]|yv =∞ - X [VY QY (yv)][f (y-v, yv + 1) - f(y)] i	()
v	^^}	y v
“0”	1-----------------------7----------------------}
0	“Key”
2A Bernoulli random variable y 〜Bernoulli(P) is identical to y = 1e<p With e 〜U(0,1). But y is called
non-reparameterizable because the transformation y = 1<P is not differentiable.
3
Published as a conference paper at ICLR 2019
where Qγ(yv) =	ynv=0 qγ (n), and Qγ (∞) = 1 for all γ.
Theorem 1 (GO Gradient). For expectation objectives Eqγ (y) [f (y)], where qγ(y) satisfies (i)
qγ(y) = v qγ (yv); (ii) the corresponding CDF Qγ(yv) is differentiable wrt parameters γ; and
(iii) one can calculate NYQY (yv), the General and One-sample (GO) gradient is defined as
VYEqY(y) [f (y)] = EqY(y) [GYγ⑻Dy [f®)]],	(9)
where GqY(y) specifies GK(y)，[…，gK(yv),…]With Variable-nabla gq(yv)，q-1)VκQ(yv),
Dy [f(y)]=[…，Dyv [f (y)], ∙∙∙ ]T, and
D [f(y)] ,	Vyvf(y),	Continous yv
yv y	f(y-v, yv + 1) - f (y), Discrete yv
All proofs are provided in Appendix A, where we also list gYqY (yv) for a wide selection of possible
qY (y), for both continuous and discrete y. Note for the special case with continuous y, GO reduces
to Implicit Rep gradients (Figurnov et al., 2018) and pathwise derivatives (Jankowiak & Obermeyer,
2018); in other words, GO provides a principled explanation for their low variance, namely their
foundation (implicit differentiation) originates from integration by parts. For high-dimensional
discrete y, calculating Dy [f (y)] is computationally expensive. Fortunately, for f(y) often used
in practice special properties hold that can be exploited for efficient parallel computing. Also for
discrete yv with finite support, it is possible that one could analytically evaluate a part of expectations
in (9) for lower variance, mimicking the local idea in Titsias & Lazaro-Gredilla (2015); Titsias (2015).
Appendix I shows an example illustrating how to handle these two issues in practice.
4 Deep GO Gradient
The GO gradient in Theorem 1 can only handle single-layer mean-field qY (y), characterized by an
independence assumption on the components of y. One may enlarge the descriptive capability of
qY (y) by modeling it as a marginal distribution of a deep model (Ranganath et al., 2016b; Bishop,
2006). Hereafter, we focus on this situation, and begin with a 2-layer model for simple demonstration.
Specifically, consider
qγ(y) = / qγ(y, λ)dλ = / qγy (y∣λ)qγλ (λ)dλ = / Yv qγy(yv∣λ) ∙ Yk qγλ (λk)dλ,
where γ = {γy , γλ}, y is the leaf variable, and the internal variable λ is assumed to be continuous.
Components of y are assumed to be conditionally independent given λ, but upon marginalizing out
λ this independence is removed.
The objective becomes EqY⑻[f (y)] = EqYy (y∣λ)q,λ (λ) [f (y)], and via Theorem 1
Vγy EqY (y)[f (y)]= EqY (y,λ) [@；；" '"^ [f ®)]] ∙	(10)
Lemma 1. Equation (10) exactly recovers the Rep gradient in (5), if γ = γy and qY (y) has
reparameterization y = TY (λ), λ 〜q(λ) for differentiable TY (λ) and easily sampled q(λ).
Lemma 1 shows that Rep is a special case of our deep GO gradient in the following Theorem 2.
Note neither Implicit Rep gradients nor pathwise derivatives can recover Rep in general, because a
neural-network-parameterized y = TY(λ) may lead to non-trivial CDF Qγ (y).
For the gradient wrt γλ, we first apply Theorem 1, yielding
vYλ EqY (y) [f (y)] = %λ (λ) hGYYλ (λ)Dλ [%y (y∣λ) [f (y)]]].
For continuous internal variable λ one can apply Theorem 1 again, from which
V,λEqY(y)[f(y)]= Eq,(y,λ) GYYλ(λ)GλYy(")Dy[f(y)] ∙	(11)
4
Published as a conference paper at ICLR 2019
Now extending the same procedure to deeper models with L layers, we generalize the GO gradient
in Theorem 2. Random variable y(L) is assumed to be the leaf variable of interest, and may be
continuous or discrete; latent/internal random variables {y(1), . . . , y(L-1)} are assumed continuous
(these generalize λ from above).
Theorem 2 (Deep GO Gradient). For expectation objectives Eqγ (y(L)) [f (y(L))] with qγ(y(L))
being the marginal distribution of
qγ(y(1),…,y(L))= qγ(1)(y ⑴)hY∖ qγ(o (y(l)∣y(lτ))i,
where Y = {γ⑴，…,Y(L)}, all internal variables y⑴,…，y(L-1) are continuous, the leaf Vari-
able y(L) is either continuous or discrete, qγ(l) (y(l) |y(l-1)) = Qv qγ(l) (yv(l) |y(l-1)), and one has
qγ(l) (yv(l)|y(l-1))	qγ(l) (yv(l) |y(l-1))
access to variable-nablas gγγ(l)	and gyγ(l-1)	, as defined in Theorem 1, the
General and One-sample (GO) gradient is defined as
VYo)Eqγ(y(L))[f(y(L))] = EqY(y(i),∙∙∙ ,y(L))hGqY((∣)(y(l)ly(l 1))BP[y(l)]i,	(12)
where BP[y(L)] = Dy(L) [f (y(L))] andBP[y(I)] = G：%；+1) (yC)BPIy(I+1)] for / < L.
Corollary 1. The deep GO gradient in Theorem 2 exactly recovers back-propagation (Rumelhart
& Hinton, 1986) when each element distribution qγ(l) (yv(l) |y(l-1)) is specified as the Dirac delta
function located at the activated value after activation function.
Figure 1 is presented for better understanding. With Variable-nablas, one can readily verify that the
deep GO gradient in Theorem 2 in expectation obeys the chain rule.
Assume all continuous variables y, and
abuse notations for better understanding.
Dy[f (y)] → Vyf (y),	GKy) → Vκy
Figure 1: Relating back-propagation (Rumelhart & Hinton, 1986) with the deep GO gradient in Theorem 2.
(i) In deterministic deep neural networks, one forward-propagates information using activation functions, like
ReLU, to sequentially activate {y(l)}ι=ι,…，l (black solid arrows), and then back-propagates gradients from
Loss f (∙) to each parameter Y((I via gradient-flow through {y(k) }k=L,…，ι (red dashed arrows). (ii) Similarly
for the deep GO gradient with 1 MC sample, one forward-propagates information to calculate the expected
loss function f(y(L)) using distributions as statistical activation functions, and then uses variable-nablas to
sequentially back-propagate gradients through random variables {y(k) }k=L,…,(to each γ(l), as in (12).
5	Statistical Back-Propagation and Hierarchical Variational
Inference
Recall the motivating discussion in Section 2, in which we considered generative model pθ(x, z) and
inference model qφ(z∣x),the former used to model synthesis of the observed data X and the latter used
for inference of z given observed x. In recent deep architectures, a hierarchical representation for cu-
mulative latent variables z = (z(1), . . . , z(L)) has been considered (Rezende et al., 2014; Ranganath
et al., 2015; Zhou et al., 2015; 2016; Ranganath et al., 2016b; Cong et al., 2017; Zhang et al., 2018). As
an example, there are models with pθ(x, Z) = pθ(XIz(I)) [ Q31 Pθ(Z(I)Iz(I+1))]pe(Z(L)). When
performing inference for such models, it is intuitive to consider first-order Markov chain structure
for qφ(zIX) = qφ(z(1) IX) QlL=2 qφ(z(l) Iz(l-1)). The discussion in this section is most relevant for
variational inference, for computation of VφEqφ(z(1),...,z(L) |x) [f(z(1), . . . , z(L))], and consequently
we specialize to that notation in the subsequent discussion (we consider representations in terms of z,
rather than the more general y notation employed in Section 4).
Before proceeding, we seek to make clear the distinction between this section and Section 4. In the
latter, only the leaf variable z(L) appears in VγEqγ(z(L)) [f(z(L))]; see (12), with y(L) → z(L). That
5
Published as a conference paper at ICLR 2019
is because in Section 4 the underlying model is a marginal distribution of z(L), i.e., qγ(z(L)), which
is relevant to the generators of GANs; see (3), with x → z(L) and pθ(x) → qγ(z(L)). Random vari-
ables z(1), . . . , z(L-1) were marginalized out of qγ(z(1), . . . , z(L-1), z(L)) to represent qγ(z(L)).
As discussed in Section 4, z(1) , . . . , z(L-1) were added there to enhance the modeling flexibility
of qγ(z(L)). In this section, the deep set of random variables z = (z(1) , . . . , z(L)) are inherent
components of the underlying generative model for x, i.e., pθ(x, z) = pθ(x, z(1), . . . , z(L)). Hence,
all components of Z manifested via inference model qφ(z∣x) = qφ(z⑴，...，Z(L)Ix) Play a role
in f (z). Besides, no specific structure is imposed on pθ(x, Z) and qφ(z∣x) in this section, moving
beyond the aforementioned first-order Markov structure. For a practical application, one may employ
domain knowledge to design suitable graphical models for pθ(x, Z) and qφ(z∣x), and then use the
following Theorem 3 for training.
Theorem 3 (Statistical Back-Propagation). For expectation objectives
Eqφ({z(i)}iL=1)f({Z(i)}iL=1)
where {Z(i)}iI=1 denotes I continuous internal variables with at least one child variable, {Z(j)}jL=I+1
represents L 一 I continuous or discrete leaf variables with no children except f (∙), and qφ(∙) is
constructed as a hierarchical probabilistic graphical model
qφ({z ⑺ }L=ι) = qφ({z(i)}I=I) YL=I+1 q。(Zcj) |{z(i)}I=I)
with each element distribution qφ (zv |pa(zv)) having accessible variable-nablas as defined in Theo-
rem 1, pa(zv) denotes the parent variables of zv, the General and One-sample (GO) gradient for
φk ∈ φ is defined as
Vφk Eqφ({z(i)}L=ι) [f ({Z⑴}L=l)] = Eqφ({z(i)}L=ι) [GΦk[ch(φk)]Bp[ch(Φk )]] ,	(13)
where ch(φk) denotes the children variables of φk, and with zv ∈ ch(φk),
Gφk[chOk)]=[…，gφk(^pa(Zv)), ∙∙∙],	BP[ch(φk)] = [∙∙∙ , BP[zv ],…]T,
and BP[zv] is iteratively calculated as BP[zv] = Gqzφv [ch(zv)] BP[ch(zv)], until leaf variables where
BP[zv] = Dzv[f({Z(i)}iL=1)].
Statistical back-propagation in Theorem 3 is relevant to hierarchical variational inference (HVI)
(Ranganath et al., 2016b; Hoffman & Blei, 2015; Mnih & Gregor, 2014) (see Appendix G), greatly
generalizing GO gradients to the inference of directed acyclic probabilistic graphical models. In
HVI variational distributions are specified as hierarchical graphical models constructed by neural
networks. Using statistical back-propagation, one may rely on GO gradients to perform HVI with
low variance, while greatly broadening modeling flexibility.
6	Related Work
There are many methods directed toward low-variance gradients for expectation-based objectives.
Attracted by the generalization of REINFORCE, many works try to improve its performance via
efficient variance-reduction techniques, like control variants (Mnih & Gregor, 2014; Titsias & Lazaro-
Gredilla, 2015; Gu et al., 2015; Mnih & Rezende, 2016; Tucker et al., 2017; Grathwohl et al., 2017) or
via data augmentation and permutation techniques (Yin & Zhou, 2018). Most of this research focuses
on discrete random variables, likely because Rep (if it exists) works well for continuous random
variables but it may not exist for discrete random variables. Other efforts are devoted to continuously
relaxing discrete variables, to combine both REINFORCE and Rep for variance reduction (Jang et al.,
2016; Maddison et al., 2016; Tucker et al., 2017; Grathwohl et al., 2017).
Inspired by the low variance of Rep, there are methods that try to generalize its scope. The Gener-
alized Rep (GRep) gradient (Ruiz et al., 2016) employs an approximate reparameterization whose
transformed distribution weakly depends on the parameters of interest. Rejection sampling variational
inference (RSVI) (Naesseth et al., 2016) exploits highly-tuned transformations in mature rejection
sampling simulation to better approximate Rep for non-reparameterizable distributions. Compared
6
Published as a conference paper at ICLR 2019
to the aforementioned methods, the proposed GO gradient, containing Rep as a special case for
continuous random variables, applies to both continuous and discrete random variables with the
same low-variance as the Rep gradient. Implicit Rep gradients (Figurnov et al., 2018) and pathwise
derivatives (Jankowiak & Obermeyer, 2018) are recent low-variance methods that exploit the gradient
of the expected function; they are special cases of GO in the single-layer continuous settings.
The idea of gradient backpropagation through random variables has been exploited before. RE-
LAX (Grathwohl et al., 2017), employing neural-network-parametrized control variants to assist
REINFORCE for that goal, has a variance potentially as low as the Rep gradient. SCG (Schulman
et al., 2015) utilizes the generalizability of REINFORCE to construct widely-applicable stochastic
computation graphs. However, REINFORCE is known to have high variance, especially for high-
dimensional problems, where the proposed methods are preferable when applicable (Schulman et al.,
2015). Stochastic back-propagation (Rezende et al., 2014; Fan et al., 2015), focusing mainly on
reparameterizable Gaussian random variables and deep latent Gaussian models, exploits the product
rule for an integral to derive gradient backpropagation through several continuous random variables.
By comparison, the proposed statistical back-propagation based on the GO gradient is applicable to
most distributions for continuous random variables. Further, it also flexibly generalizes to hierarchical
probabilistic graphical models with continuous internal variables and continuous/discrete leaf ones.
7	Experiments
We examine the proposed GO gradients and statistical back-propagation with four experiments:
(i) simple one-dimensional (gamma and negative binomial) examples are presented to verify the
GO gradient in Theorem 1, corresponding to nonnegative and discrete random variables; (ii) the
discrete variational autoencoder experiment from Tucker et al. (2017) and Grathwohl et al. (2017) is
reproduced to compare GO with the state-of-the-art variance-reduction methods; (iii) a multinomial
GAN, generating discrete observations, is constructed to demonstrate the deep GO gradient in
Theorem 2; (iv) hierarchical variational inference (HVI) for two deep non-conjugate Bayesian models
is developed to verify statistical back-propagation in Theorem 3. Note the experiments of Figurnov
et al. (2018) and Jankowiak & Obermeyer (2018) additionally support our GO in the single-layer
continuous settings.
Many mature machine learning frameworks, like TensorFlow (Abadi et al.) and PyTorch (Paszke
et al., 2017), are optimized for implementation of methods like back-propagation. Fortunately, all
gradient calculations in the proposed theorems obey the chain rule in expectation, enabling convenient
incorporation of the proposed approaches into existing frameworks. Experiments presented below
were implemented in TensorFlow or PyTorch with a Titan Xp GPU. Code for all experiments can be
found at github.com/YulaiCong/GOgradient.
Notation Gam(α, β) denotes the gamma distribution with shape α and rate β, NB(r, P) the negative
binomial distribution with number of failures r and success probability P, Bern(P) the Bernoulli
distribution with probability P, Mult(n, P) the multinomial distribution with number of trials n
and event probabilities P , Pois(λ) the Poisson distribution with rate λ, and Dir(α) the Dirichlet
distribution with concentration parameters α.
7.1	Gamma and NB One-dimensional Simple Examples
We first consider illustrative one-dimensional “toy” problems, to examine the GO gradient for both
continuous and discrete random variables. The optimization objective is expressed as
max ELBO(φ) = Eqφ(z) [logp(z|x) - log qφ (z)] + log p(x),
φ
where for continuous z we assume p(z|x) = Gam(z; α0, β0) for given set (α0, β0), with
qφ(z) = Gam(z; α, β) and φ = {α, β}; for discrete z we assume p(z|x) = NB(z; r0,p0) for
given set (r0,p0), with qφ(z) = NB(z; r,p) and φ = {r, p}. Stochastic gradient ascent with one-
sample-estimated gradients is used to optimize the objective, which is equivalent to minimizing
klSφ(Z)kp(ZIx)).
Figure 2 shows the results (see Appendix H for additional details). For the nonnegative continuous z
associated with the gamma distribution, we compare our GO gradient with GRep (Ruiz et al., 2016),
7
Published as a conference paper at ICLR 2019
0
102
100
10-2
GRep
RSVI
-*,-GRep-Stick
"-RSVI-Stick
a>。UEuB>，PB」Oð
Iteration
GRep
RSVI
-'-GRep-Stick
RSVI-Stick
—•—GO________
•。Ueue>，P£°O
Iteration
-0.2
0
-0',
081W
200	400	600	800	1000
Iteration
•ous」e>,p£°」
I—"→ REINFORCE
REINFORCE2
—GO
200	400	600	800	1000
Iteration
.,I..⅛⅛,
(a)	(b)	(c)	(d)
Figure 2: Gamma (a-c) and NB (d) toy experimental results. (a) The gradient variance of gamma shape α versus
iterations, with posterior parameters α0 = 1, β0 = 0.5. (b)-(c) The gradient variance of α and ELBOs versus
iterations respectively, when α0 = 0.01, β0 = 0.5. (d) The gradient variance of NB r versus iterations with
r0 = 10, p0 = 0.2. In each iteration, gradient variances are estimated with 20 Monte Carlo samples (each
sample corresponds to one gradient estimate), among which the last one is used to update parameters.
RSVI (Naesseth et al., 2016), and their modified version using the “sticking” idea (Roeder et al.,
2017), denoted as GRep-Stick and RSVI-Stick, respectively. For RSVI and RSVI-Stick, the shape
augmentation parameter is set as 5 by default. The only difference between GRep and GRep-Stick
(also RSVI and RSVI-Stick) is the latter does not analytically express the entropy Eqφ(z) [- log qφ (z)].
Figure 2(a) clearly shows the utility of employing sticking to reduce variance; without it, GRep and
RSVI exhibit high variance, that destabilizes the optimization for small gamma shape parameters,
as shown in Figures 2(b) and 2(c). We adopt the sticking approach hereafter for all the compared
methods. Among methods with sticking, GO exhibits the lowest variance in general, as shown in
Figures 2(a) and 2(b). GO empirically provides more stable learning curves, as shown in Figure
2(c). For the discrete case corresponding to the NB distribution, GO is compared to REINFORCE
(Williams, 1992). To address the concern about comparison with the same number of evaluations
of the expected function3, another curve of REINFORCE using 2 samples is also added, termed
REINFORCE2. It is apparent from Figure 2(d) that, thanks to analytically removing the “0” terms in
(8), the GO gradient has much lower variance, even in this simple one-dimensional case.
7.2	Discrete Variational Autoencoder
To demonstrate the low variance of the proposed GO gradient, we consider the discrete variational
autoencoder (VAE) experiment from REBAR (Tucker et al., 2017) and RELAX (Grathwohl et al.,
2017), to make a direct comparison with state-of-the-art variance-reduction methods. Since the
statistical back-propagation in Theorem 3 cannot handle discrete internal variables, we focus on the
single-latent-layer settings (1 layer of 200 Bernoulli random variables), i.e.,
Pθ(x, z): X 〜Bern(NNPx∣z(z)), Z 〜Bern(PZ)
qφ(z∣x): z 〜Bern(NNP2也(x))
where Pz is the parameters of the priorpθ(z), NNP x|z (z) means using a neural network to project
the latent binary code Z to the parameters P χ∣z of the likelihood pθ (x|z), and NNP z∣x (x) is similarly
defined for qφ(z∣x). The objective is given in (1). See Appendix I for more details.
Table 1: Best obtained ELBOs for discrete variational autoencoders. Results of REBAR and RELAX are
obtained by running the released code4 from Grathwohl et al. (2017). All methods are run with the same learning
rate for 1, 000, 000 iterations.
Dataset	Model	Training			Validation		
		REBAR	RELAX	GO	REBAR	RELAX	GO
MNIST	Linear 1 layer	-112.16	-112.89	-110.21	-114.85	-115.36	-114.27
	Nonlinear	-96.99	-95.99	-82.26	-112.96	-112.42	-111.48
Omniglot	Linear 1 layer	-122.19	-122.17	-119.03	-124.81	-124.95	-123.84
	Nonlinear	-79.51	-80.67	-54.96	-129.00	-128.99	-126.59
3In the NB experiments, REINFORCE uses 1 sample and 1 evaluation of the expected function; REIN-
FORCE2 uses 2 sample and 2 evaluations; and GO uses 1 sample and 2 evaluations.
8
Published as a conference paper at ICLR 2019
-110
152025
----REBAR train
--REBAR valid
----RELAX train
一 一 RELAX valid
GO train
GO valid
-110
-130
0	2
4	6	8	10
-135 1
0
O①，山
15202530
---REBAR train
--REBAR valid
---RELAX train
--RELAX valid
---GO train
--GO valid
2000	4000	6000	8000
Time (seconds)
Iteration	×ιo5
Table 2: Inception scores on quan-
tized MNIST. BGAN’s results are
run with the author-released code
https://github.com/rdevon/BGAN.
bits (states)	BGAN	MNGAN-GO
1 (1)	8.31 ± .06	9.10 ± .06
1 (2)	8.56 ± .04	8.40 ± .07
2 (4)	7.76 ± .04	9.02 ± .06
3 (8)	7.26 ± .03	9.26 ± .07
4 (16)	6.29 ± .05	9.27 ± .06
Figure 3: Training curves for the discrete VAE experiment with 1-layer linear model (see Appendix I) on the
stochastically binarized MNIST dataset(Salakhutdinov & Murray, 2008). All methods are run with the same
learning rate for 1, 000, 000 iterations. The black line represents the best training ELBO of REBAR and RELAX.
ELBOs are calculated using all training/validation data.
4/3
IZG
3 Uf ?
2 72
d 7s
03/
/ g7
δ 3 ¥
35，
2
3霜/
7‹-o
8 4 3
4 6 9
Figure 4: Generated samples from BGAN (top) and
MNGAN-GO (bottom) trained on 4-bit quantized
MNIST.

Figure 3 (also Figure 9 of Appendix I) shows the training curves versus iteration and running
time for the compared methods. Even without any variance-reduction techniques, GO provides
better performance, faster convergence rate, and better running efficiency (about ten times faster
in achieving the best training ELBO of RERAR/RELAX in this experiment). We believe GO’s
better performance originates from: (i) its inherent low-variance nature; (ii) GO has less parameters
compared to REBAR and RELAX (no control variant is adopted for GO); (iii) efficient batch
processing methods (see Appendix I) are adopted to benefit from parallel computing. Table 1 presents
the best training/validation ELBOs under various experimental settings for the compared methods.
GO provides the best performance in all situations. Additional experimental results are given in
Appendix I.
Many variance-reduction techniques can be used to further reduce the variance of GO, especially
when complicated models are of interest. Compared to RELAX, GO cannot be directly applied when
f(y) is not computable or where the interested model has discrete internal variables (like multilayer
Sigmoid belief networks (Neal, 1992)). For the latter issue, we present in Appendix B.4 a procedure
to assist GO (or statistical back-propagation in Theorem 3) in handling discrete internal variables.
7.3	Multinomial GAN
To demonstrate the deep GO gradient in Theorem 2, we adopt multinomial leaf variables x and
construct a new multinomial GAN (denoted as MNGAN-GO) for generating discrete observations
with a finite alphabet. The corresponding generator pθ (x) is expressed as
e 〜N(0, I), X 〜Mult(1, NNp(.)).
For brevity, we integrate the generator’s parameters θ into the NN notation, and do not explicitly
express them. Details for this example are provided in Appendix J.
We compare MNGAN-GO with the recently proposed boundary-seeking GAN (BGAN) (Hjelm et al.,
2018) on 1-bit (1-state, Bernoulli leaf variables x), 1-bit (2-state), 2-bit (4-state), 3-bit (8-state) and 4
4github.com/duvenaud/relax
9
Published as a conference paper at ICLR 2019
4-bit (16-state) discrete image generation tasks, using quantized MNIST datasets (LeCun et al., 1998).
Table 2 presents inception scores (Salimans et al., 2016) of both methods. MNGAN-GO performs
better in general. Further, with GO’s assistance, MNGAN-GO shows more potential to benefit
from richer information coming from more quantized states. For demonstration, Figure 4 shows the
generated samples from the 4-bit experiment, where better image quality and higher diversity are
observed for the samples from MNGAN-GO.
7.4	HVI for Deep Exponential Families and Deep Latent Dirichlet Allocation
To demonstrate statistical back-propagation in Theorem 3, we design variational inference nets for
two nonconjugate hierarchical Bayesian models, i.e., deep exponential families (DEF) (Ranganath
et al., 2015) and deep latent Dirichlet allocation (DLDA) (Zhou et al., 2015; 2016; Cong et al., 2017).
DEF : X 〜Pois(W(I)Z(I)), Z(I)〜Gam(αz, αz∕w(l+1)z(l+1)), W(I)〜Gam(αo,βo)
DLDA : x 〜Pois(Φ⑴Z(I)), Z(I)〜Gam(Φ(l+1)z(+1^ ,c(+1^), Φ(l) 〜Dir(η0).
For demonstration, We design the inference nets q°(z|x) following the first-order Markov chain
construction in Section 5, namely
qφ(z|x) : Z(I)〜Gam(NNaI) (x),NNg) (x)), Z(I)〜Gam(NNa) (Z(IT)), NNe) (Z(IT)»
Further details are provided in Appendix K. One might also wish to design inference nets that have
structure beyond the above first-order Markov chain construction, as in Zhang et al. (2018); we do
not consider that here, but Theorem 3 is applicable to that case.
Figure 5: ELBOs ofHVIfora 128-64 DEF on MNIST.
Except for different ways to calculate gradients, all other
experimental settings are the same for compared meth-
ods, including the sticking idea and one-MC-sample
gradient estimate.
MNIST. Upperleft is the training ELBOs. The re-
maining subfigures are learned dictionary atoms
from Φ(1) (top-right), Φ(1)Φ(2) (bottom-left), and
Φ(1) Φ(2)Φ(3) (bottom-right).
HVI for a 2-layer DEF is first performed, with the ELBO curves shown in Figure 5. GO enables
faster and more stable convergence. Figure 6 presents the HVI results for a 3-layer DLDA, for which
stable ELBOs are again observed. More importantly, with the GO gradient, one can utilize pure
gradient-based methods to efficiently train such complicated nonconjugate models for meaningful
dictionaries (see Appendix K for more implementary details).
8 Conclusions
For expectation-based objectives, we propose a General and One-sample (GO) gradient that applies to
continuous and discrete random variables. We further generalize the GO gradient to cases for which
the underlying model is deep and has a marginal distribution corresponding to the latent variables
of interest, and to cases for which the latent variables are hierarchical. The GO-gradient setup is
demonstrated to yield the same low-variance estimation as the reparameterization trick, which is
only applicable to reparameterizable continuous random variables. Alongside the GO gradient, we
constitute a means of propagating the chain rule through distributions. Accordingly, we present
statistical back-propagation, to flexibly integrate deep neural networks with general classes of random
variables.
10
Published as a conference paper at ICLR 2019
Acknowledgments
We thank the anonymous reviewers for their useful comments. The research was supported by part
by DARPA, DOE, NIH, NSF and ONR. The Titan Xp GPU used was donated by the NVIDIA
Corporation. We also wish to thank Chenyang Tao, Liqun Chen, and Chunyuan Li for helpful
discussions.
References
M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean,
M. Devin, et al. TensorFlow: Large-scale machine learning on heterogeneous systems. URL
https://www.tensorflow.org/. Software available from tensorflow.org.
M. Arjovsky, S. Chintala, and L. Bottou. Wasserstein GAN. In ICLR, 2017.
C. Bishop. Pattern Recognition and Machine Learning. Springer, 2006.
Y. Cong, B. Chen, H. Liu, and M. Zhou. Deep latent Dirichlet allocation with topic-layer-adaptive
stochastic gradient Riemannian MCMC. In ICML, 2017.
K. Fan, Z. Wang, J. Beck, J. Kwok, and K. Heller. Fast second order stochastic backpropagation for
variational inference. In NIPS,pp. 1387-1395, 2015.
M. Figurnov, S. Mohamed, and A. Mnih. Implicit reparameterization gradients. arXiv preprint
arXiv:1805.08498, 2018.
Z. Gan, L. Chen, W. Wang, Y. Pu, Y. Zhang, H. Liu, C. Li, and L. Carin. Triangle generative
adversarial networks. In NIPS, pp. 5253-5262, 2017.
K. Geddes, M. Glasser, R. Moore, and T. Scott. Evaluation of classes of definite integrals involving
elementary functions via differentiation of special functions. Applicable Algebra in Engineering,
Communication and Computing, 1(2):149-165, 1990.
I.	Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and
Y. Bengio. Generative adversarial nets. In NIPS, pp. 2672-2680, 2014.
W. Grathwohl, D. Choi, Y. Wu, G. Roeder, and D. Duvenaud. Backpropagation through the void:
Optimizing control variates for black-box gradient estimation. arXiv:1711.00123, 2017.
S. Gu, S. Levine, I. Sutskever, and A. Mnih. MuProp: Unbiased backpropagation for stochastic
neural networks. arXiv:1511.05176, 2015.
J.	M. Herndndez-Lobato, Y. Li, M. Rowland, D. Herndndez-Lobato, T. Bui, and R. E. Turner.
Black-box α-divergence minimization. In ICML, 2016.
R. Hjelm, A. Jacob, T. Che, A. Trischler, K. Cho, and Y. Bengio. Boundary seeking GANs. In ICLR,
2018.
M. Hoffman and D. Blei. Stochastic structured variational inference. In AISTATS, pp. 361-369, 2015.
E. Jang, S. Gu, and B. Poole. Categorical reparameterization with gumbel-softmax. arXiv:1611.01144,
2016.
M. Jankowiak and F. Obermeyer. Pathwise derivatives beyond the reparameterization trick. arXiv
preprint arXiv:1806.01851, 2018.
M. Jordan, Z. Ghahramani, T. Jaakkola, and L. Saul. An introduction to variational methods for
graphical models. Machine learning, 37(2):183-233, 1999.
D. P. Kingma and M. Welling. Auto-encoding variational Bayes. In ICLR, 2014.
Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
11
Published as a conference paper at ICLR 2019
C. Li, H. Liu, C. Chen, Y. Pu, L. Chen, R. Henao, and L. Carin. Alice: Towards understanding
adversarial learning for joint distribution matching. In NIPS, pp. 5501-5509, 2017.
C. Li, J. Li, G. Wang, and L. Carin. Learning to sample with adversarially learned likelihood-ratio.
2018.
Y. Li and R. E. Turner. Renyi divergence variational inference. In NIPS, pp. 1073-1081, 2016.
C. J. Maddison, A. Mnih, and Y. W. Teh. The concrete distribution: A continuous relaxation of
discrete random variables. arXiv:1611.00712, 2016.
A. Mnih and K. Gregor. Neural variational inference and learning in belief networks. In ICML, pp.
1791-1799, 2014.
A. Mnih and D. Rezende. Variational inference for monte carlo objectives. In ICML, pp. 2188-2196,
2016.
C. A. Naesseth, F. J. R. Ruiz, S. W. Linderman, and D. M. Blei. Rejection sampling variational
inference. arXiv:1610.05683, 2016.
R. M. Neal. Connectionist learning of belief networks. Artif. Intell., 56(1):71-113, 1992.
A. Paszke, S. Gross, S. Chintala, G. Chanan, E. Yang, Z. DeVito, Z. Lin, A. Desmaison, L. Antiga,
and A. Lerer. Automatic differentiation in PyTorch. 2017.
A. Radford, L. Metz, and S. Chintala. Unsupervised representation learning with deep convolutional
generative adversarial networks. arXiv:1511.06434, 2015.
R. Ranganath, S. Gerrish, and D. M. Blei. Black box variational inference. In AISTATS, 2014.
R. Ranganath, L. Tang, L. Charlin, and D. M. Blei. Deep exponential families. In AISTATS, 2015.
R. Ranganath, D. Tran, J. Altosaar, and D. Blei. Operator variational inference. In NIPS, pp. 496-504,
2016a.
R. Ranganath, D. Tran, and D. Blei. Hierarchical variational models. In ICML, pp. 324-333, 2016b.
D. J. Rezende, S. Mohamed, and D. Wierstra. Stochastic backpropagation and approximate inference
in deep generative models. In ICML, 2014.
G. Roeder, Y. Wu, and D. K. Duvenaud. Sticking the landing: Simple, lower-variance gradient
estimators for variational inference. In NIPS, pp. 6928-6937, 2017.
F. J. R. Ruiz, M. K. Titsias, and D. Blei. The generalized reparameterization gradient. In NIPS, pp.
460-468, 2016.
D. Rumelhart and G. Hinton. Learning representations by back-propagating errors. Nature, 323(9),
1986.
R. Salakhutdinov and I. Murray. On the quantitative analysis of deep belief networks. In ICML, pp.
872-879. ACM, 2008.
T. Salimans, D. A. Knowles, et al. Fixed-form variational posterior approximation through stochastic
linear regression. Bayesian Analysis, 8(4):837-882, 2013.
T. Salimans, I. Goodfellow, W. Zaremba, V. Cheung, A. Radford, and X. Chen. Improved techniques
for training gans. In NIPS, pp. 2234-2242, 2016.
J. Schulman, N. Heess, T. Weber, and P. Abbeel. Gradient estimation using stochastic computation
graphs. In NIPS, pp. 3528-3536, 2015.
M. Titsias. Local expectation gradients for doubly stochastic variational inference. arXiv preprint
arXiv:1503.01494, 2015.
M. Titsias and M. Ldzaro-Gredilla. Local expectation gradients for black box variational inference.
In NIPS, pp. 2638-2646, 2015.
12
Published as a conference paper at ICLR 2019
G.	Tucker, A. Mnih, C. Maddison, J. Lawson, and J. Sohl-Dickstein. REBAR: Low-variance, unbiased
gradient estimates for discrete latent variable models. In NIPS, pp. 2624-2633, 2017.
R. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning.
Machine learning, 8(3-4):229-256, 1992.
M. Yin and M. Zhou. ARM: Augment-REINFORCE-merge gradient for discrete latent variable
models. arXiv preprint arXiv:1807.11143, 2018.
H.	Zhang, B. Chen, D. Guo, and M. Zhou. WHAI: Weibull hybrid autoencoding inference for deep
topic modeling. In ICLR, 2018.
J. Zhao, M. Mathieu, and Y. LeCun. Energy-based generative adversarial network. In ICLR, 2016.
M. Zhou, Y. Cong, and B. Chen. The Poisson gamma belief network. In NIPS, pp. 3025-3033, 2015.
M. Zhou, Y. Cong, and B. Chen. Augmentable gamma belief networks. JMLR, 17(1):5656-5699,
2016.
13
Published as a conference paper at ICLR 2019
A Proof of Theorem 1
We first prove (7) in the main manuscript, followed by its discrete counterpart, i.e., (8) in the main
manuscript. Then, it is easy to verify Theorem 1.
A. 1 Proof of Equation (7) in the Main Manuscript
Similar proof in one-dimension is also given in the supplemental materials of Ranganath et al.
(2016b).
We want to calculate
VYEqγ(y) [f(y)] = VY EQv qγ(yv) [f(y)] = Xv Eqγ(y-v) [ R f(y)VYqY(yv)dyv],
where y-v denotes y with yv excluded. Without loss of generality, we assume yv ∈ (-∞, ∞).
Let v0(yv) = VYqY(yv), and we have
Zyv	yv
VYqY (t)dt = VY	qY (t)dt = VYQY (yv ),
where QY (yv ) is the cumulative distribution function (CDF) of qY (yv). Further define u(yv )
f(yv, y-v), we then apply integration by parts (or partial integration) to get
VY EqY (y)[f (y)]
EEE
vvv
XXX
===
(14)
qγ(y-v)	u(yv)v0(yv)dyv
qγ(y-v) [u(yv)v(yv)l∞∞ - R u0(yv)v(yv)dyv]
qγ(y-v) [f(y)VγQY(yv)∣∞∞ - R[VγQY(yv)][Vyvf(y)]dyv ].
With QY (∞) = 1 and QY (-∞) = 0, it’s straightforward to verify that the first term is always zero
for any QY (yv ), thus named the “0” term.
A.2 Proof of Equation (8) in the Main Manuscript
For discrete variables y, we have
VYEqγ(y)[f(y)] = Xv Eqγ(y-v)h XyN =0 f(y)VYqY(yv)i,
where y» ∈ {0,1,…，N} and N is the size of the alphabet.
To handle the summation of products of two sequences and develop discrete counterpart of (7), we
first introduce Abel transformation.
Abel transformation. Given two sequences {an} and {bn}, with n ∈ {0,…，N}, we define
B0 = b0 and Bn = Pkn=0 bn for n ≥ 1. Accordingly, we have
SN = X	anbn = a0b0 + X	an(Bn - Bn-1)
n=0	n=1
= a0B0 +	anBn -	an+1Bn
n=1	n=0
aNBN + XN-1 anBn - XN-1 an+1Bn
n=0	n=0
N-1
aNBN -	(an+1 - an)Bn.
Substituting n = yv, an = f (y), bn = VYqY (yv ), and Bn = VYQY (yv ) into the above equation,
we have
VY Eqγ (y)[f (y)] =
Xv Eqγ(y-v)[ f(y-,yv = N) VY QY (yv = N)- XN=O[f (y-V ,y +I) - f (y)]vγ QY (y)].
|	{z	}、	V	{._
“0，，	V
0	“Key”
14
Published as a conference paper at ICLR 2019
Note the first term equals zero for both finite alphabet, i.e., N < ∞, and infinite alphabet, i.e.,
N = ∞. When N = ∞, we get (8) in the main manuscript.
With the above proofs for Eqs. (7) and (8), one could straightforwardly verify Theorem 1.
Table 3: Variable-nabla examples. Note y is a scalar random variable.
qγ(y)
γ(y)
Delta δ(y — μ)
Bernoulli(p)
gμγ(y)
gpqγ(y)
1
/1/(1 - P) y = 0
Normal(μ,σ2)
gμγ (y) = 1
Log-Normal(μ,σ2)	g%Y(y) = y
Logit-Normal(μ,σ2) g%Y(y) = y(1 - y)
y = 1
-CqY Iy) — y-7
gσ ,、一 ~~σ
CaUchy(μ, Y)
Gamma(α,1)
gμγ (y) = 1
qY (y)
gσ
qY (y)
gσ
y log y-μ
y σ
Beta(α, β)
NB (r,p)
Exponential(λ)
Student’s t(v)
WeibUll(λ, k)
LaPlace(μ, b)
Poisson(λ)
Geometric(P)
Categorical(p)
gαqγ(y)
M (y) - y-μ
gγ	Y
[log(βy)-ψ(α)]Γ(α,βy)+βyT (3,α,βy)
gαqγ(y)
qγ (y)
gβ
grqγ(y)
gpqγ(y)
βα yθ,-^1 e — βy
log y - ψ(α) + ψ(α + β)
CqY (y) _ —y
gβ = - β
yα-1
y
(1 - y)β-1
B(y; α, β)
：2(1 - y)β-1
• 3F2(α,α, 1 - β; α + 1,α + 1; y)
log(1 - y) - ψ(β) + ψ(α + β)
yα-1(1 - y)β-1
B(1 - y; β, α)
1-y
-2~⅜ ∙ 3F2(β,β, 1 - a； β + 1,β + 1；1 - y)
β2yα-1
Iog(I - P) - ψ(T) + ψ(T + y + I) /	,e,,	,,、
---------- ----——------------(y + T)B(I - p； r,y + I)
(1 - P)r Py
y+r
1-p
y+r
+----N ∙3F2(r, r, -y; r + 1,r + 1;1 - P)
py r2
CqY (y) _ —y
gλ 一 λ
gVγ (y) = 2 (1 + W) v+1
CqY ⑻-y
gλ = λ
gμγ(y) = 1
qY (y)
gλ
qY (y)
gp
qY (y)
gp
1
y+1
—
p
[1+ ψ(V) - ψ(号)]• 2F1
+ 2yV+) • 2F1
3v
2
+ y • F202
3v
3 v+3
1 v+1 3
22
v+1
一,---；1； 1,-；
22	2
2,5；； 士；
22
gqγ(y) = k ιθg( λ)
CqY ⑻—y-μ
gb - b
-Py [10≤y, 1l≤y,…，1(N-1)≤y, 0]T
for y = {0,1,…，N}, P = [Pο,Pι,…，Pn]t
0

+
α
5

v

v

y2
v
v
ψ(x) is the digamma fUnction. Γ(x, y) is the UPPer incomPlete gamma fUnction. B(x; α, β) is the incomPlete
beta function. PFq (a1, •…,ap; b1, •…,bp; x) is the generalized hypergeometric function. T(m, s, x) is a
sPecial case of Meijer G-fUnction (Geddes et al., 1990).
B WHY DISCRETE Internal VARIABLES ARE CHALLENGING ?
For simpler demonstration, we first use a 2-layer model to show why discrete internal variables
are challenging. Then, we present an importance-sampling proposal that might be useful under
specific situations. Finally, we present a strategy to learn discrete internal variables with the statistical
back-propagation in Theorem 3 of the main manuscript.
Assume qγ(y) being the marginal distribution of the following 2-layer model
qγ(y) = %Yλ(λ)[qYy (ylλ)]
Where Y = {Yy, 7入}, qγ (y, λ = qγy (ylλ)qγλ(λ) = Qv qγy Iy 区)∙ Qk 9γλ(λk), and both the
leaf variable y and the internal variable λ could be either continuous or discrete.
Accordingly, the objective becomes
EqY (y)[f(y)]= %(y,λ)[f(y)]= EqYy (y∣λ)qYλ(λ)[f(y)].
15
Published as a conference paper at ICLR 2019
For gradient wrt γy, using Theorem 1, it is straight to show
VYy EqY (y,λ)[f (y)] = Eqγλ (λ) [Vγy EqYy (y | λ) [f W)] ] = %(y,λ) [GY；" ("^ [f W)]] . (15)
For gradient wrt γλ, we first have
vYλEq；(y,λ)[f (y)] = vγλEqγλ(λ) [Eqγy(y∣λ)[f(y)]].
With f (λ) = EqYy (y∣λ) [f (y)], We then apply Theorem 1 and get
Vγλ EqY(y,λ)[f (y)] = Eqγλ (λ) [GY?	[f(λ)]] ,	(16)
where Dλ[f(λ)]=[…，Dλk [f(λ)],…]T, and
Vλk f (λ),	Continous λk
f(λ-k, λk + 1) - f (λ),	Discrete λk
Next, we separately discuss the situations where λk is continuous or discrete.
B.1	FOR CONTINUOUS λk
One can directly apply Theorem 1 again, namely
Dλk [f(λ)]= Vλk EqYy (y∣λ)[f (y)]= EqYy (y∣λ)[GλY" ("^ [f Q)][	"
Substituting (17) into (16), we have
VγλEqY(y,λ)[f (y)]= EqY(y,λ) [GYYλ (λ)GλYy (ylλ)Dy [f ®)]] .	(18)
Dλk [f(λ)]，]
B.2	FOR DISCRETE λk
T . 1 ∙	1 .	1	1	TΓT, Γ P / X ∖ 1	；/、	、	. -I ∖	P / X ∖ EI 1	♦	. ∙	1
In this case, we need to calculate Dλk [f (λ)] = f(λ-k, λk + 1) - f (λ). The keys are again partial
integration and Abel transformation. For simplicity, we first assume one-dimensional y, and separately
discuss y being continuous and discrete.
For continuous y, we apply partial integration to f (λ) and get
f(λ) = EqYy (y∣λ)[f (y)] = ∕qγ y (ylλ)f (y)dy
=[f (y)Qγy (ylλ)]∣∞∞ ― / QYy (y|R Vyf ⑻dy.
Accordingly, we have
„ ʌ , ʌ , ʌ ,
Dλjf(λ)] = f(λ-k,λk + 1) - f(λ)
=/ [Qγy ⑶入)-Qγy (ylλ-k, λk + 1)] Vyf (y)dy
+ [f (y)Qγy (y∣λ-k,λk + 1)] ∣∞∞ - [f(y)Qγy (y∣λ)] ∣∞∞.
、-----------------------V------------------------}
“0”
Removing the “0” term, we have
Dλk[f(λ)] = / [Qγy(y∣λ)- Qγy (y∣λ-k,λk + 1)] Vyf (y)dy.
(19)
For discrete y, by similarly exploiting Abel transformation, we have
f(λ) = EqYy (y∣λ) [f(y)] = Xy qγy (y∣λ)f(y)
=f (∞)Qγy (∞lλ) - Xy QYy ⑶入)[f (y + 1) - f (y)].
16
Published as a conference paper at ICLR 2019
Accordingly, we get
Dλk [f(λ)] = XyhQYy (y∣λ) - Qγy (y∣λ-k,λk + 1)i f (y +1) - f (y)].	(20)
Unifying (19) for continuous y and (20) for discrete y, we have
„ ʌ , ʌ , ʌ ,
Dλk[f(λ)] = f(λ-k,λk + 1)- f(λ)
=EqYy (y∣λ-k,λk + 1)[f(y)] - EqYy (y∣λ) [f(y)]	(21)
=EqYy (y∣λ) hDy[f (y)] ∙ gλγy (ylλ)i
where we define
—qγy(y∣λ) , Qγy (ylλ) - Qγy (ylλ-k,λk + I)
9λk	,	qγym	.
Multi-dimensional y. Based on the above one-dimensional foundation, we next move on to multidi-
mensional situations. With definitions y”，{yι,…，yi} and yi.，{yi,…，yv}, where V is the
dimensionality of y, we have
„ ʌ, ʌ, ʌ,
Dλk[f(λ)] = f(λ-k,λk + 1)- f(λ)
=EqYy(y∣λ-k,λk+i)[f(y)] -EqYy(y∣λ)[f(y)]
EqYy (y2ι∣λ-k ,λk + 1) EqYy (yι ∣λ-k,λk + 1)[f (y)] - EqYy (yι∣λ)[f (y)]
(22)
+ EqYy(yι∣λ)[f(y)] -EqYy(y∣λ)[f(y)]
Apply (21) and we have
Dλk[f(λ)]= EqYy *λ-k,λk + 1)hEqYy (yι∣λ)[Dyι[f(y)]∙ gλYy ("]]
+ EqYy (yzJλ-k,λk+I) [EqYy (yιR[f(y)]] - EqYy (y|x)[f(y)]
=EqYy (y2」λ-k,λk+i)qYy (yι∣λ) hDyι[f (y)] ∙ U；："“ ) + f (T -EqYy (y∣λ)[f (y)]
Similarly, we add extra terms to the above equation to enable applying (21) again as
Dλk[f(λ)]= EqYy 5λ-k ,λk + 1)qYy (yι∣λ)[Dyι[f(y)]∙以1 (y1 lλ) + f (y)i
-EqYy 3」入-：,λk + 1)qYy (y^λ) [Dyι[f (y)] ∙ g;："	+ f (y)]
+ EqYy 3」入-：,λk + 1)qYy (y^λ) [Dyι[f (y)] ∙ g;："	+ f (y)]
-EqYy (y∣λ)[f (y)].
Accordingly, we apply (21) to the first two terms and have
Dλk[f(λ)] =EqYy MJλ-k,λk + 1)qYy (y,∣λ) [Dy2 [DyJf ( y )]gλY, 1 1	+ fW)]贰"("「
+ EqYy(y3Jλ-k,λk+1)qYy(y^λ) [Dyι[f 勿)]勺;："	+ f (T - EqYy(y|x)[f(y)]
EqYy (y3： | λ-k ,λk + 1)qYy (y :2 | λ)
Dy2 [Dyι[f(y)]gλYy(" + f(y)i gλYy(y2lλ)-
+ Dyι[f (y)]gλYy (y1lλ) + f (y)	-
-EqYy(y∣λ)[f(y)]
So forth, we summarize the pattern into the following equation as
_ - -- , ______________________________ .,
Dλk [f(λ)] = EqYy (y∣λ) [Aλk (y,v) - f (y)],
(23)
17
Published as a conference paper at ICLR 2019
where Aλk (y, V ) is iteratively calculated as
Aλk (y, 0) = f(y)
Aλk(y,v) = Dyv [Aλk(y,v - 1)]gλγy(yvlλ) + Aλk(y,v - I)
Aλk(y, V) = Dyv [Aλk(y, V - 1)]gλYy (yVlλ) + Aλk(y,v - 1).
Despite elegant structures within (23), to calculate it, one must iterate over all dimensions of y, which
is computational expensive in practice. More importantly, it is straightforward to show that deeper
models will have similar but much more complicated expressions.
B.3 AN IMPORTANCE-SAMPLING PROPOSAL TO HANDLE DISCRETE Internal VARIABLES
Next, we present an intuitive proposal that might be useful under specific situations.
The key idea is to use different extra items to enable “easy-to-use" expression for Dλk [/(λ)], namely
„ ʌ, ʌ, ʌ,
Dλk[f(λ)] = f(λ-k,λk + 1)- f(λ)
=EqYy (y∣λ-k,λk+i)[f(y)] - EqYy (y∣λ) [f (y)]
=EqYy (y∣λ-k,λk+i)[f (y)]
-EqYy(y：v-ιlλ-k,λk+1)qγy (yv»[f (y)]
+ EqYy (y：v-ιlλ-k ,λk+1)qγy (yv »[f (y)]
• ∙ ∙
EqYy (y：i-1 । λ-k,λk +I)qYy (yi： । λ) [f (y )]
+ EqYy (y：i-i lλ-k,λk+1)qYy 加」* [f (y)]
•••
-EqYy(yιlλ-k,λk+1)qYy 3：»[f (y)]
+ EqYy (yιlλ-k,λk+1)qYy 3：» [f (y)]
-EqYy (y∣λ)[f (y)].
Apply (21) to the adjacent two terms for V times, we have
Dλk [f (λ)] = EqYy (y： V-1 ∣λ-k,λk + 1)q,y (yv ∣λ) [Dyv [f (y)]贰""""']
•••
+ EqYy 3i-Jλ-k,λk+1)qYy 的：1# [DyJf WXgλY"]
+ EqY (yv∣λ)[Dyι[f (y)]gλYy("i，
where we can apply the idea of importance sampling and modify the above equation to
Dλk[f(λ)] = EqYy (y∣λ) [Dyv [f (y)]gλYy (yvlλ) qγy(y∏); λk + 1) i
y L	qYy(y: V-1|人)	」
,Ir	M	×1.qYy(yilλ)qYyW=i-∕λ-k,λk + I)I
+ EqYy (y∣λ) [Dyi[f (y)]gλky	―qj(yj∣λ) —J
•••
+ EqYy (yv∣λ) [Dyι [f (y)]gλYy ("i
EqYy (y∣λ) ]X Dyv [f (y)]或y Ma qγy"-k,λk + 1)
Lv=1	qYy (%吁1|人)
(24)
18
Published as a conference paper at ICLR 2019
Note that importance sampling may not always work well in practice (Bishop, 2006).
We further define the generalized variable-nabla as
f ~a一(H |.)νλk QYy(Uv lλ),
qγy (yv ∣λ) , I qYy (yv |人)
ggλk	J QYy (yv lλ) - QYy (yv lλ-k,λk + I) qYy Mv-∕λ-k ,λ + I)
Continuous λk
(25)
Discrete λk
qγy(yv X
qYy(y：v-iX
With the generalized variable-nabla, we unify (24) for discrete λk and (17) for continuous λk and get
Dλk[f(λ)] = EqYy(y∣λ)[XDyv[f(y)] ∙ggλγ(yvlλ)i,
XhX Dyv [f(y)]∙ ggλγ(yvlλ)i∙ ggYYλ (Ik)
kv
which apparently obeys the chain rule. Accordingly, we have the gradient for γ λ in (16) as
▽，入 EqY (y,λ)[f (y)] = Eqγ(y,λ)
One can straightforwardly verify that, with the generalized variable-nabla defined in (25), the chain
rule applies to NYEq,(y(L))[f (y(L))], where one can freely specify both leaf and internal variables
to be either continuous or discrete. The only problem is that, for discrete internal variables, the
importance sampling trick used in (24) may not always work as expected.
B.4 Strategy to Learn Discrete Internal Variables with Statistical
Back-Propagation
Practically, if one has to deal with a q,(y(I),…,y(L)) with discrete internal variables y(l), l < L,
we suggest the strategy in Figure 7, with which one should expect a close performance but enjoy
much easier implementation with statistical back-propagation in Theorem 3 of the main manuscript.
In fact, one can always add additional continuous internal variables to the graphical models to remedy
the performance loss or even boost the performance.
OOO*
(a)	(b)
Figure 7: A strategy for discrete internal variables. Blue and red circles denote continuous and discrete variables,
respectively. The centered dots represent the corresponding distribution parameters. (a) Practically, one uses a
neural network (black arrow) to connect the left variable to the parameters of the center discrete one, and then
uses another neural network to propagate the sampled value to the next. (b) Instead, we suggest “extracting” the
discrete variable as a leaf one and propagate its parameters to the next.
C Proof of Lemma 1
First, a marginal distribution q,(y) with reparameterization y = TY (e), e 〜q(e) can be expressed
as a joint distribution, namely
qY (y) = qY(y, ) = qY (y|)q(),
where q7 (y 怕)=δ(y 一 TY (e)), δ(∙) is the Dirac delta function, and TY(N) could be flexibly specified
as a injective, surjective, or bijective function.
Next, we align notations and rewrite (10) as
VYEqY (y)[f (y)] = EqY (y,e) IGYY ^/y [f®)]]
=Eq(e)忸q,(y|e)[GYY[f®)]]],
whereGY(小)=[…，gYY(yv㈤…]andgY初⑹，q⅛yVYQY®|e).
(26)
19
Published as a conference paper at ICLR 2019
With qγ (yv |) = δ(yv - [τ γ ()]v), we have
1	[τγ ()]v ≤ yv
QY(yv⑹=fθ	[τY(e)]v >y
Accordingly, we have
▽y QY (yv ⑹=V [τ γ (e)]v Qγ (yv |e) ∙ ▽) [τ Y (W)]v
=-δ([τγ(Mv - yv) ∙Vγ[τγ⑻]v
and
gYγ (yv |€)= -—-∏Vγ QY (yv 怕)=Vγ [τ γ (e)]v .
qY (yv |W)
Substituting the above equations into (26), we get
Vγ EqY (y)[f (y)] = Eq(e) ^Vγ TY (e)][Vy f (y)] ∣y=τ,(e)] ,	(27)
which is the multi-dimensional Rep gradient in (5) of the main manuscript.
D	Proof of Theorem 2
Firstly, with the internal variable λ being continuous, (10) and (11) in the main manuscript are proved
by (15) and (18) in Section B, respectively. Then, by iteratively generalizing the similar derivations
to deep models and utilizing the fact that the GO gradients with variable-nablas in expectation obey
the chain rule for models with continuous internal variables, Theorem 2 could be readily verified.
E Proofs for Corollary 1
When all qY(i) y(i) |y(i-1) s are specified as Dirac delta functions, namely
qγ(i) (y(i)∣y(iτ)) = δ(y(i) - σ(γ⑴,y(iT))),
where σ(γ(i), y(i-1)) denotes the activated values after activation functions, the objective becomes
Eqγ(y(L))[f(y(L))] = f(y(L)) = f(σ(γ(L), y(L-1)))
= f(σ(γ(L), σ(γ(L-1), y(L-1))))
(28)
=f (σ(γ(L), σ(γ(LT),…，σ(γ⑴)))
= f(γ),
where Y = {γ⑴,…，Y(N)}.
Back-Propagation. For the objective in (28), the Back-Propagation is expressed as
Vγ(i) f (Y) = [Vγ(i) y⑺][Vy(i) f (∙)],	(29)
where
Vy(i) f (∙) = [Vy(i) y(i+ I)HVy(i+1) f (∙)].
Deep GO Gradient. We consider the continuous special case, where Dy(L) f(y(L))
Vy(L) f (y(L)).
With qY(i+1) y(i+1) |y(i) s being Dirac delta functions, namely,
	qγ(i+i) (yki+1)|y(i))=	∞, 0,	[σ(Y(i+1), y(i))]k [σ(Y(i+1), y(i))]k	=y 6= y	i+1) i+1)
we have	Qγ(i+1) (yki+1)|y(i))：	= (10,,	[σ(Y(i+1), y(i))]k [σ(Y(i+1), y(i))]k	≤ yk( > yk(	i+1) i+1)
20
Published as a conference paper at ICLR 2019
Taking derivative wrt yv(i) , we got
Vyvi) Qγ(i+1) (yki+1)∣y ⑴)
=V[σ(γ(i+i),y(”kQγ(i+υ (yki+1)∣y⑴)∙Vyvi) [σ(γ(i+1), y(i))]k
=-δ([σ(γ(i+1), y⑴)]k -yki+1)) ∙Vyvi) [σ(γ(i+1), y(i))]k
Accordingly, we have
gqr)(y"lQ
yv
-1
qγ(i+i) (yki+1)|y(i))
Vyv(i) Qγ(i+1) (yk(i+1)
|y(i))
Vyv(i)[σ(γ(i+1),y(i))]k=Vyv(i)yk(i+1)
By substituting the above equation into (12) in Theorem 2, and then comparing it with(29), one can
easily verify Corollary 1.
F	Proof for Theorem 3
Based on the proofs for Theorem 1 and Theorem 2, it is clear that, if one constrains all internal
variables to be continuous, the GO gradients in expectation obey the chain rule. Therefore, one can
straightforwardly utilizing the chain rule to verify Theorem 3. Actually, Theorem 3 may be seen as
the chain rule generalized with random variables, among which the internal ones are only allowed to
be continuous.
G Derivations for Hierarchical Variational Inference
In Hierarchical Variational Inference, the objective is to maximize the evidence lower Bound (ELBO)
ELBO(θ, φ; X)= Eqφ(z∣χ)[logpθ(x, z) - log qφ(z|x)].	(30)
For the common case with Z = {z⑴，…，Z(L)}, it is obvious that Theorem 3 of the main manuscript
can be applied when optimizing φ.
Practically, there are situations where one might further put a latent variable λ in reference qφ(z∣x),
namely qφ(z∣x) = / qφz(z∣λ)qφλ(λ)dλ with φ = {φz, 0入}. Following Ranganath et al. (2016b),
we briefly discuss this situation here.
We first show that there is another unnecessary variance-injecting “0” term.
VφELBO(θ, φ; x) = /[Vφqφ(z∣x)][logp(x, z) - logqφ(z∣x)]dz
一∕qφ(z∣x)Vφ log qφ(z∣x)dz,
X---------------------------}
(31)
*{z
“0”
where the second “0” term is straightly verified as
/ qφ(z∣x)Vφ log qφ(z∣x)dz = / Vφqφ(z∣x)dz = Vφ / qφ(z∣x)dz = Vφ1 = 0.
Eliminating the “0” term from (31), one still has another problem, that is, log qφ(z∣x) is usually
non-trivial when qφ(z∣x) is marginal. For this problem, we follow Ranganath et al. (2016b) to use
another lower bound ELBO2 of the ELBO in (30).
-log qφ(z∣x) = / qφ(λ∣z, x)[- log qφ(z∣x)]dλ = / qφ(λ∣z, x)
- log
qφ(z,λlx) ]dλ
qφ(λ∣z, x)_|
Eqφ(λ∣z,χ)
≥ Eqφ(λ∣z,χ)
-log qΦ(z，入⑻ + log qΦ(入以 x) 一
r rω(λ∣Z, x)	r rω(λ∣z, x)_
1	qφ (z, λ∣x)
-log rωwrx)
21
Published as a conference paper at ICLR 2019
where rω(λ∣z, x), evaluable, is an additional variational distribution to approximate the variational
posterior qφ(λ∣z, x). Accordingly, we get the ELBO2 for Hierarchical Variational Inference as
ELBO2(θ, φ; X) = Eqφ(z,λ∣x) [ logPθ (x, Z)- log qφ(z, λ∣x) + log % (λ∣z, x)].
Note similar to (31), the unnecessary “0” term related to log qφ(z, λ∣x) should also be removed.
Accordingly, we have
VφELBO2(θ, φ; x) = / [Vφqφ (z, λ∣x)][ log pθ (x, z) - log qφ (z, λ∣x)+log T3 (λ∣z, x)]dλdz.
Obviously, Theorem 3 is readily applicable to provide GO gradients.
H	Details of Gamma and NB One-dimensional Simple Examples
We first consider illustrative one-dimensional “toy” problems, to examine the GO gradient in Theorem
1 for both continuous and discrete random variables.
The optimization objective is expressed as
max ELBO(φ) = Eqφ(z) [logp(z|x) - log qφ(z)] + log p(x),
√τ⅝	ɪ
φ
where for continuous z we assume p(z|x) = Gam(z; α0, β0) for set (α0, β0), with qφ(z) =
Gam(z; α, β) and φ = {α, β}; for discrete z we assume p(z|x) = NB(z; T0,p0) for set (T0,p0),
with qφ(z) = NB(z; T, p) and φ = {T, p}. Stochastic gradient ascent with one-sample-estimated
gradients is used to optimize the objective, which is equivalent to minimizing KL(qφ(z)kp(z∣x)).
Figure 8 shows the experimental results. For the nonnegative continuous z associated with the gamma
distribution, we compare our GO gradient with GRep (Ruiz et al., 2016), RSVI (Naesseth et al., 2016),
and their modified version using the “sticking” idea (Roeder et al., 2017), denoted as GRep-Stick and
RSVI-Stick respectively. For RSVI and RSVI-Stick, the shape augmentation parameter is set as 5 by
default. The only difference between GRep and GRep-Stick (also RSVI and RSVI-Stick) is the latter
does NOT analytically express the entropy Eqφ(z) [- log qφ(z)]. One should apply sticking because
(i) Figures 8(a)-8(c) clearly show its utility in reducing variance; and (ii) without it, GRep and RSVI
exhibit high variance that unstabilizes the optimization for small gamma shape parameters, as shown
in Figures 8(d)-8(f). We adopt the sticking approach hereafter for all the compared methods. Since
the gamma rate parameter β is reparameterizable, its gradient calculation is the same for all sticking
methods, including GO, GRep-Stick, and RSVI-Stick. Therefore, similar variances are observed in
Figures 8(b) and 8(e). Among methods with sticking, GO exhibits the lowest variance in general,
as shown in Figures 8(a) and 8(d). Note it is high variance that causes optimization issues. As a
result, GO empirically provides more stable learning curves, as shown in Figures 8(c) and 8(f). For
the discrete case corresponding to the NB distribution, GO is compared to REINFORCE (Williams,
1992). To estimate gradient, REINFORCE uses 1 sample of z and 1 evaluation of the expected
function; whereas GO uses 1 sample and 2 evaluations. To address the concern about comparison
with the same number of evaluations of the expected function, another curve of REINFORCE using
2 samples (thus 2 evaluations of the expected function) is also added, termed REINFORCE2. It is
apparent from Figures 8(g)-8(l) that, thanks to analytically removing the “0” terms, the GO gradient
has much lower variance and thus faster convergence, even in this simple one-dimensional case.
I Details of the Discrete VAE Experiment
Complementing the discrete VAE experiment of the main manuscript, we present below its experi-
mental settings, implementary details, and additional results.
Since the presented statistical back-propagation in Theorem 3 of the main manuscript cannot handle
discrete internal variables, we focus on the single-latent-layer settings (1 layer of 200 Bernoulli
random variables) for fairness, i.e.,
Pθ(x, z): X 〜Bern(NNPx∣z(z)), Z 〜Bern(PZ)
qφ(ZIX) ： Z 〜Bern(NNPz∣χ(X)).
Referring to the experimental settings in Grathwohl et al. (2017), we consider
(32)
22
Published as a conference paper at ICLR 2019
0	200	400	600	800	1000
Iteration
2 0 2
WWW
OoU」E>，PE」0
GRep
RSVI
GRep-Stick
RSVI-Stick
GO
(a)	(b)	(c)
Iteration
0	200	400	600	800	1000
Iteration
200	400	600	800	1000
Iteration
(d)
12
(e)
(f)
0 8 6 4
8U-」E>,PE」°」
0'
0	200	400	600
Iteration
800	1000
-REINFORCE
-REINFORCE2
GO_________
s20∙,°-
0。UE-」E>，PE」°d
30
-REINFORCE
-REINFORCE2
GO
0，—
0	200
800	1000
-0.8.
→-REINFORCE
→-REINFORCE2
→- GO
0	200	400	600	800	1000
Iteration
Oq山


(g)	(h)	(i)
→-REINFORCE
→-REINFORCE2
f GO
0l****^.......................*.............
0	200	400	600	800	1000
400	600	800	1000
Iteration
-REINFORCE
-REINFORCE2
GO_________

Iteration
(j)	(k)	(l)
Figure 8: Gamma (a-f) and NB (g-l) toy experimental results. Columns show the gradient variance for the
first parameter (gamma α or NB r), that for the second parameter (gamma β or NB p), and the ELBO,
respectively. The first two rows correspond to the gamma toys with posterior parameters α0 = 1, β0 = 0.5
and α0 = 0.01, β0 = 0.5, respectively. The last two rows show NB toy results with r0 = 10, p0 = 0.2 and
r0 = 0.5, p0 = 0.2, respectively. In each iteration, gradient variances are estimated with 20 Monte Carlo
samples (each sample corresponds to one gradient estimate), among which the last one is used to update
parameters. 100 Monte Carlo samples are used to calculate the ELBO in the NB toys.
• 1-layer linear model:
NNPx|z(z) = σ(WpT z +bp)
NNP z|x (x) = σ(WqTx +bq)
where σ(∙) is the sigmoid function.
• Nonlinear model:
NNPx|z(z) = σ(WpT2h(p2)+bp2),h(p2) = tanh(WpT1h(p1)+bp1), h(p1) = tanh(WpT z+bp)
NNPz|x(x) = σ(WqT2h(q2)+bq2), h(q2) =tanh(WqT1h(q1)+bq1),h(q1) =tanh(WqTx+bq)
where tanh(∙) is the hyperbolic-tangent function.
23
Published as a conference paper at ICLR 2019
The used datasets and other experimental settings, including the hyperparameter search strategy, are
the same as those in Grathwohl et al. (2017).
For such single-latent-layer settings, it is obvious that Theorem 3 (also Theorem 1) can be straightfor-
wardly applied. However, since Bernoulli distribution has finite support, as mentioned in the main
manuscript, we should analytically express some expectations for lower variance, as detailed below.
Notations of (8) and (9) of the main manuscript are used for clarity and also for generalization.
In fact, we should take a step back and start from (8) of the main manuscript, which is equivalent to
analytically express an expectation in (9), namely
VYEqY(y)[f(y)] = Xv EqY(y-v)h - Xy [VYQY(yv)][f(y-v, yv + 1) - f(y)]i,	(33)
whereQγ(yv)= 11-Pv(γ)
yv = 0
with Pv(γ) being the Bernoulli probability of Bernoulli
yv = 1
random variable yv . Accordingly, we have
VY EqY (y)[f (y)] = - Xv EqY (y-v) h[vγ QY (yv = 0)][f (y-v ,y
1) - f(y-v,yv = 0)]
XvEqY(y-v) [VYPv(γ)][f(y-v,yv = 1) - f(y-v,yv
EqY(y) hXv[VYPv(γ)][f(y-v,yv = 1) - f(y-v,yv =
(34)
For better understanding only, with abused notations VYP =[…，VYPv(Y),…]T, VPy = I,
and Vyf (y)=[…，{f (y-v, yv = 1) — f(y-v,yv = 0)},…]T, one should observe a chain rule
within the above equation.
To assist better understanding of how to practically cooperate the presented GO gradients with deep
learning frameworks like TensorFlow or PyTorch, we take (34) as an example, and present for it the
following simple algorithm.
Algorithm 1 An algorithm for (34) as an example to demonstrate how to practically cooperate GO
gradients with deep learning frameworks like TensorFlow or PyTorch. One sample is assumed for
clarity. Practically, an easy-to-use trick for changing gradients of any function h(x) is to define
h(x) = XTStoPGradient[g] + StoPGradient[h(x) — XTg] with g the desired gradients.
# Forward-Propagation
1.	γ → P (γ): Calculate Bernoulli Probabilities P (γ )
2.	P(Y) → y: Sample y 〜Bern(P(Y))	. Change gradient: VP(Y)y = I
3.	y → f (y): Calculate the loss f(y)
. Change gradient: [Vyf(y)]v = f(y-v,yv = 1) - f(y-v,yv = 0)
# Back-ProPagation
1.	Rely on the mature auto-differential software for back-ProPagating gradients
For efficient imPlementation of Dyf(y), one should exPloit the Prior knowledge of function f(y).
For examPle, f (y)s are often neural-network-Parameterized. Under that settings, one should be able
to exPloit tensor oPeration to design efficient imPlementation of Dy f (y). Again we take (34) as an
examPle, and assume f(y) has the sPecial structure
f(y) = r(ΘT h + c), h = σ(WT y + b)	(35)
where σ(∙) is an element-wise nonlinear activation function, and r(∙) is a function that takes in a
vector and outPuts a scalar. One can easily modify the above f(y) for the considered discrete VAE
exPeriment.
Since yvs are now Bernoulli random variables with suPPort {0, 1}, we have that
Dyf(y)v = f(y-v, yv = 1) - f(y-v,yv =0)
= f(y-v, yv + 1) - f(y)	yv = 0
f(y) - f(y-v, yv - 1)	yv = 1
= av [f(y-v, yv + av) - f (y)],
(36)
24
Published as a conference paper at ICLR 2019
1	yv = 0
where av =	is the v-th element of vector a.
- 1	yv = 1
-110
-130
0
-80
-115
O
q-120
LU
-125
2
4	6	8	10
Iteration	χ105
5 0 5 0
12 2 3
-1-
---REBAR train
--REBAR valid
---RELAX train
--RELAX valid
---GO train
GO valid
-135 1-------1--------1--------1-------1—
0	2000	4000	6000	8000
Time (seconds)
(b)	MNIST Linear Running-Time
-80ι-----1-----1-----1------1----
-160
0
(a) MNIST Linear Iteration
-100
O
q-120
LU
-140
4	6	8	10
Iteration	×105
(d) MNIST Nonlinear Running-Time
(c)	MNIST Nonlinear Iteration
-120
Time (seconds)
-125
-130
O
%-135
LU
---REBAR train
---REBAR valid
---RELAX train
---RELAX valid
GO train
GO valid
-140
-145
-150 Ll
0
Iteration
10
×105
-120
(f) Omniglot Linear Running-Time
-350
0
(e) Omniglot Linear Iteration
-50
-100
Oooo
5 0 5 0
12 2 3
O山
2
4	6	8	10
Iteration	×105
-50
-100
-300
-25
O O
5 O
oω1山
----REBAR train
--REBAR valid
----RELAX train
--RELAX valid
GO train
GO valid
2000	4000	6000	8000
Time (seconds)
2
4
6
8
(g) Omniglot Nonlinear Iteration	(h) Omniglot Nonlinear Running-Time
Figure 9: Training/Validation ELBOs for the discrete VAE experiments. Rows correspond to the experimental
results on the MNIST/Omniglot dataset with the 1-layer-linear/nonlinear model, respectively. Shown in the
first/second column is the ELBO curves as a function of iteration/running-time. All methods are run with the
same learning rate for 1, 000, 000 iterations. The black line represents the best training ELBO of REBAR
and RELAX. ELBOs are calculated using all training/validation data. Note GO does not suffer more from
over-fitting, as clarified in the text.
25
Published as a conference paper at ICLR 2019
Table 4: Average running time per 100 iterations for discrete variational autoencoders. Results of REBAR and
RELAX are obtained by running the released code5 from Grathwohl et al. (2017). The same computer with one
Titan Xp GPU is used.
Dataset	Model	REBAR	RELAX	GO
MNIST	Linear 1 layer	0.94s	0.95s	0.25s
	Nonlinear	0.99s	1.02s	0.54s
Omniglot	Linear 1 layer	0.89s	0.92s	0.21s
	Nonlinear	0.97s	0.98s	0.45s
Then to efficiently calculate the f(y-v , yv + av)s, we use the following batch processing procedure
to benefit from parallel computing.
•	Step 1: Define Ξy h as the matrix whose element [Ξy h]vj represents the “new” hj when
input {y-v , yv + av } in (35). Then, we have
[Ξy h]vj = σ(yT Wj + bj + av Wvj)
where W:j is the j-th column of the matrix W. Note the vth row of Ξyh, i.e., [Ξyh]v:,
happens to be the “new” hj when input {y-v , yv + av }.
•	Step 2: Similarly, we define Ξyf as the vector whose element [Ξyf]v = f(y-v , yv + av ).
Utilizing Ξyh obtained in Step 1, we have
Ξy f = r([Ξy h]" + CT),
where r(∙) is applied to each row of the matrix ([Ξyh]E + cτ).
Note the above batch processing procedure can be easily extended to deeper neural networks.
Accordingly, we have
Dyf(y) = a [Ξyf - f(y)],
where represents the matrix element-wise product.
Now we can rely on Algorithm 1 to solve the problem whose objective has its gradient expressed as
(34), for example the inference of the single-latent-layer discrete VAE in (32).
All training curves versus iteration/running-time are given in Figure 9, where it is apparent that
GO provides better performance, a faster convergence rate, and a better running efficiency in all
situations. The average running time per 100 iterations for the compared methods are given in Table
4, where GO is 2 - 4 times faster in finishing the same number of training iterations. We also quantify
the running efficiency of GO by considering its running time to achieve the best training ELBO
(within 1, 000, 000 training iterations) of RERAR/RELAX, referring to the black lines shown in
the second-column subfigures of Figure 9. It is clear that GO is approximately 5 - 10 times more
efficient than REBAR/RELAX in the considered experiments.
As shown in the second and fourth rows of Figures 9, for the experiments with nonlinear models all
methods suffer from over-fitting, which originates from the redundant complexity of the adopted
neural networks and appeals for model regularizations. We detailedly clarify these experimental
results as follows.
•	All the compared methods are given the same and only objective, namely to maximize the
training ELBO on the same training dataset with the same model; GO clearly shows its
power in achieving a better objective.
•	The “level” of over-fitting is ultimately determined by the used dataset, model, and objective;
it is independent of the adopted optimization method. Different optimization methods
just reveal different optimizing trajectories, which show different sequences of training
objectives and over-fitting levels (validation objectives).
5github.com/duvenaud/relax
26
Published as a conference paper at ICLR 2019
•	Since all methods are given the same dataset, model, and objective, they have the same
over-fitting level. Because GO has a lower variance, and thus more powerful optimization
capacity, it gets to the similar situations much faster than REBAR/RELAX. Note this does
not mean GO suffers more from over-fitting. In fact, GO provides better validation ELBOs
in all situations, as shown in Figure 9 and also Table 1 of the main manuscript. In practice,
GO can benefit from the early-stopping trick to get a better generalization ability.
J Details of the Multinomial GAN
Complementing the multinomial GAN experiment in the main manuscript, we present more details
as follows. For a quantitative assessment of the computational complexity, our PyTorch code takes
about 30 minutes to get the most challenging 4-bit task in Figs. 4 and 11, with a Titan Xp GPU.
Firstly, recall that the generatorpθ(x) of the developed multinomial GAN (denoted as MNGAN-GO)
is expressed as
e 〜N(0,I), X 〜MUlt(1, NNP(e)),
where NNP() denotes use of a neural network to project to distribution parameters P. For brevity,
we integration the generator’s parameters θ into the NN notation and do not explicitly express them.
Multinomial leaf variables x is used to describe discrete observations with a finite alphabet. To train
MNGAN-GO, the vanilla GAN loss (Goodfellow et al., 2014) is used. A deconvolutional neural
network as in Radford et al. (2015) is used to map to P in the generator. The discriminator is
constructed as a multilayer perceptron. Detailed model architectures are given in Table 5. Figure
10 illustrates the pipeline of MNGAN-GO. Note MNGAN-GO has a smaller number of parameters,
compared to BGAN (Hjelm et al., 2018).
For clarity, we briefly discuss the employed data preprocessing. Taking MNIST for an example, the
original data are 8-bit grayscale images, with pixel intensities ranging from 0 to 255. For the n-bit
experiment, we obtain the real data, such as the 2-bit one in Figure 10, by rescaling and quantizing
the pixel intensities to the range [0, 2n - 1], having 2n different states (values).
For the 1-bit special case, the multinomial distribution reduces to the Bernoulli distribution. Of
course, one could intuitively employ the redundant multinomial distribution, which is denoted as
1-bit (2-state) in Table 2. An alternative and popular approach is to adopt the Bernoulli distribution
to remove the redundancy by only modeling its probability parameters; we denote this case as 1-bit
(1-state, Bernoulli) in Table 2.
Figure 11 shows the generated samples from the compared models on different quantized MNIST. It
is obvious that MNGAN-GO provides images with better quality and wider diversity in general.
二二二
Figure 10:	Illustration of MNGAN-GO.
K DETAILS OF HVI FOR DEF AND DLDA
Complementing the HVI experiments in the main manuscript, we present more details as follows.
27
Published as a conference paper at ICLR 2019
Table 5: Model Architectures of the Multinomial GAN.
Generator	Discriminator
Gaussian noise (100 dimension) 4 × 4 conv. 256 lReLU, stride 1, zero-pad 0, BN 4 × 4 conv. 128 lReLU, stride 2, zero-pad 1, BN 4 × 4 conv. 64 lReLU, stride 2, zero-pad 2, BN 4 × 4 conv. 2bit SoftMax, stride 2, zero-pad 1, BN Multinomial Sampling. Output: 28 × 28	Input Image Linear output 512,lReLU, SN Linear output 256,lReLU, SN Linear output 128,lReLU, SN Linear output 1, Sigmoid
Table 6: Inception scores on quantized MNIST. BGAN’s results are ran with the author released code https:
//github.com/rdevon/BGAN.
bits (states)	BGAN	MNGAN-GO
1 (1, Bernoulli)	8.31 ± .06	9.10 ± .06
1 (2)	8.56 ± .04	8.40 ± .07
2 (4)	7.76 ± .04	9.02 ± .06
3 (8)	7.26 ± .03	9.26 ± .07
4 (16)	6.29 ± .05	9.27 ± .06
For a quantitative assessment of the computational complexity, the TensorFlow code used takes about
0.08 seconds per iteration (including > 40, 000 Meijer-G function calculations, with an approximate
algorithm coded also with TensorFlow).
Deep exponential families (DEF) (Ranganath et al., 2015) is expressed as
X 〜Pois(W⑴z(1)), Z(D 〜Gam(αz, αz∕w(l+1)z(l+1)), W(I)〜Gam(ao,βo),
where αz = 0.1, α0 = 0.3, and β0 = 0.1 following Ruiz et al. (2016); Naesseth et al. (2016).
Since the variables of interest, W(l) and z(l), are gamma-distributed, we design the variational
approximations as
qφz(z∣x) : Z(I)〜Gam(NNg)(X), NNg)(x)), Z(I)〜Gam(NNa)(Z(IT)), NNe)(Z(IT))),
qφw(W) ： W(I)〜Gam(αW,战),
where NN(I)(∙)s are Set to the same shapes as the corresponding z(1), OW and βW also have the
shape of W(l). We employ a simple two-layer DEF for demonstration, with Z(1) and Z(2) having 128
and 64 components, respectively. The mini-batch size is set to 200. One-sample gradient estimates
are used to train the model for the compared methods. For RSVI (Naesseth et al., 2016), the shape
augmentation parameter B is set to 5. All experimental settings, except for different ways to calculate
gradients, are the same for the compared methods.
Deep latent Dirichlet allocation (DLDA) (Zhou et al., 2015; 2016; Cong et al., 2017) is expressed as
x 〜Pois(Φ(I)Z(I)), Z(I)〜Gam(Φ(l+1)Z(l+1),c(l+1)), Z(L)〜Gam(r,c(L+1)),
Φ(I)〜Dir(ηo),c(I)〜Gam(e0,f0), r 〜Gam(γo∕K, c°),
where hyperparameters are chosen following Cong et al. (2017). Compared to DEF, DLDA is
more complicated: 1) model is constructed via the highly nonlinear Gamma shape parameters; 2)
dictionaries are described by more challenging Dirichlet distributions; 3) more interested random
variables.
The variational approximations for DLDA are designed as
qφ(Z,c∣x) :Z(I)〜Gam(NNaZ(x),NNeN)(X)),c(2)〜Gam(NNa)(Z(I)),NNβ∕(Z(I))),
Z(I)〜Gam(NNa)(Z(IT)),NNe)(Z(IT))),c(l+1) 〜Gam(NNa+”/⑷),NN&+I)(Z(I))),
qφ(Φ) @(I)〜Dir(η(I)),
qφ(r):r 〜Gam(αr,βr),
28
Published as a conference paper at ICLR 2019
7ΓO
/ 4 ⅛ I 4v /- -X-
W O 97Nsgg
，^73^,6 t2
¥ Q√ 7,79 石
5 7 Ul OQ 7 3 Z 7
夕，3?夕5q7
¾g5⅛∖,?XU /
I 夕7。I 7 $6
33x7/71，
qgd 7"夕3,
5 彳 Γ⅛ 3 993 O
/ f ,y V 7 7，3
,24 2 3<fcq
yΛ<4 9∙5√α
夕 9∕39gq7
7∕∕3∕Gaα
夕 774∕gz?
(a)
(b)
(c)
(d)
(e)
q 6 93,夕50
59479夕含4
E OQ n∕/ 3 3)/
3 I ⅛ 77
63q阡牛。/夕
G6⅛2 750 q
£ q92 q2t/ /
778gs33f
r"5√⅞677
ðvvs 77?5
/A i A £ O -¾J 0/
夕Fgs72(□9
3 4 313 / q4
g6qs2 0 4o
居 l3l 4 3「6
。O 70Q IP 夕S
3 6。7 4 346
3726?//r
1 夕 077√gs
夕帝63/730
26(943{3/
UI 7 Oo ¥ I 5 O ɛ
(f)	(g)	(h)
(i)
(j)
Figure 11:	Generated images from BGAN (top) and MNGAN-GO (bottom). Columns correspond to 1-
bit(Bernoulli), 1-bit, 2-bit, 3-bit, 4-bit tasks, respectively.
where motivated by the original upward-downward Gibbs sampler developed in Zhou et al. (2015),
We specify NNe)(')as a scaler to mimic the GibbS conditional posteriors. The other NN(∙)s and
also η(l), αr, βr have the same shapes of the corresponding random variables. A three-layer DLDA,
having 128, 64, 32 components for latent z(1), z(2) , z(3) respectively, is trained on MNIST With
mini-batches of size 200.
With the learned variational inference nets, one could efficiently project the observed x to its latent
variables z , c during testing. For applications requiring realtime processing, this is a clear advantage.
For demonstration, Figure 12 shoWs test data samples x and their reconstruction
X = φ(1)Z(I), ^(1)〜Gam(NNI，(x),NNeJ(冗))，
where one Monte Carlo sample is used to calculate Z(I).
(a)
Figure 12: (a) Test data samples and (b) their reconstruction via the learned 128-64-32 DLDA.
(b)
29
Published as a conference paper at ICLR 2019
Note for the challenging DLDA task in (37), we find it tricky to naively apply pure-gradient-based
learning methods. The main reason is: the latent code z(l)s and their gamma shape parameters
Φ(l+1)z(l+1)s are usually extremely sparse, meaning most elements are almost zero; a gamma
distribution Z 〜 Gam(α, β) with almost-zero α has an increasingly steep slope when Z approaches
zero, namely the gradient wrt z shall have an enormous magnitude that unstablize the learning
procedure. Even though it might not be sufficient to just use the first-order gradient information,
empirically the following tricks help us get the presented reasonable results.
•	Let z(l) ≥ Tz , where Tz = 1e-5 is used in the experiments;
•	Let c(l) ≥ Tc, where Tc = 1e-5;
•	Let Φ(l+1)z(l+1) ≥ Tα with Tα = 0.2;
•	Use a factor to compromise the likelihood and prior for each z(l) .
For more details, please refer to our released code. We are working on exploiting higher-order
information (such as Hessian) to help remedy this issue.
30