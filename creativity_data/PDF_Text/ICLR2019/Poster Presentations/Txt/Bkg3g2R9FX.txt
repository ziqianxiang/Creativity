Published as a conference paper at ICLR 2019
Adaptive Gradient Methods with Dynamic
B ound of Learning Rate
Liangchen Luo” Yuanhao Xiong¥ Yan Liu§, Xu SunM
*MOE Key Lab of Computational Linguistics, School of EECS, Peking University
^College of Information Science and Electronic Engineering, Zhejiang University
§Department of Computer Science, University of Southern California
,Center for Data Science, Beijing Institute of Big Data Research, Peking University
*{luolc,xusun}@pku.edu.cn ^xiongyh@zju.edu.cn §yanliu.cs@usc.edu
Ab stract
Adaptive optimization methods such as AdaGrad, RMSprop and Adam have
been proposed to achieve a rapid training process with an element-wise scaling
term on learning rates. Though prevailing, they are observed to generalize poorly
compared with Sgd or even fail to converge due to unstable and extreme learn-
ing rates. Recent work has put forward some algorithms such as AM S Grad to
tackle this issue but they failed to achieve considerable improvement over exist-
ing methods. In our paper, we demonstrate that extreme learning rates can lead
to poor performance. We provide new variants of Adam and AMSGrad, called
AdaB ound and AMSBound respectively, which employ dynamic bounds on
learning rates to achieve a gradual and smooth transition from adaptive methods to
Sgd and give a theoretical proof of convergence. We further conduct experiments
on various popular tasks and models, which is often insufficient in previous work.
Experimental results show that new variants can eliminate the generalization gap
between adaptive methods and Sgd and maintain higher learning speed early in
training at the same time. Moreover, they can bring significant improvement over
their prototypes, especially on complex deep networks. The implementation of
the algorithm can be found at https://github.com/Luolc/AdaBound.
1	Introduction
There has been tremendous progress in first-order optimization algorithms for training deep neural
networks. One of the most dominant algorithms is stochastic gradient descent (S gd) (Robbins &
Monro, 1951), which performs well across many applications in spite of its simplicity. However,
there is a disadvantage of Sgd that it scales the gradient uniformly in all directions. This may lead
to poor performance as well as limited training speed when the training data are sparse. To address
this problem, recent work has proposed a variety of adaptive methods that scale the gradient by
square roots of some form of the average of the squared values of past gradients. Examples of such
methods include Adam (Kingma & Lei Ba, 2015), AdaGrad (Duchi et al., 2011) and RMSprop
(Tieleman & Hinton, 2012). Adam in particular has become the default algorithm leveraged across
many deep learning frameworks due to its rapid training speed (Wilson et al., 2017).
Despite their popularity, the generalization ability and out-of-sample behavior of these adaptive
methods are likely worse than their non-adaptive counterparts. Adaptive methods often display faster
progress in the initial portion of the training, but their performance quickly plateaus on the unseen
data (development/test set) (Wilson et al., 2017). Indeed, the optimizer is chosen as Sgd (or with
momentum) in several recent state-of-the-art works in natural language processing and computer
vision (Luo et al., 2019; Wu & He, 2018), wherein these instances Sgd does perform better than
adaptive methods. Reddi et al. (2018) have recently proposed a variant of Adam called AMSGrad,
hoping to solve this problem. The authors provide a theoretical guarantee of convergence but only
illustrate its better performance on training data. However, the generalization ability of AMSGrad
* Equal contribution. This work was done when the first and second authors were on an internship at DiDi
AI Labs.
1
Published as a conference paper at ICLR 2019
on unseen data is found to be similar to that of Adam while a considerable performance gap still
exists between AMS Grad and Sgd (Keskar & Socher, 2017; Chen et al., 2018).
In this paper, we first conduct an empirical study on Adam and illustrate that both extremely large
and small learning rates exist by the end of training. The results correspond with the perspective
pointed out by Wilson et al. (2017) that the lack of generalization performance of adaptive methods
may stem from unstable and extreme learning rates. In fact, introducing non-increasing learning
rates, the key point in AMSGrad, may help abate the impact of huge learning rates, while it
neglects possible effects of small ones. We further provide an example of a simple convex opti-
mization problem to elucidate how tiny learning rates of adaptive methods can lead to undesirable
non-convergence. In such settings, RMSprop and Adam provably do not converge to an optimal
solution, and furthermore, however large the initial step size α is, it is impossible for ADAM to fight
against the scale-down term.
Based on the above analysis, we propose new variants of Adam and AMS Grad, named Ad-
aB ound and AMSBound, which do not suffer from the negative impact of extreme learning
rates. We employ dynamic bounds on learning rates in these adaptive methods, where the lower
and upper bound are initialized as zero and infinity respectively, and they both smoothly converge
to a constant final step size. The new variants can be regarded as adaptive methods at the beginning
of training, and they gradually and smoothly transform to Sgd (or with momentum) as time step
increases. In this framework, we can enjoy a rapid initial training process as well as good final
generalization ability. We provide a convergence analysis for the new variants in the convex setting.
We finally turn to an empirical study of the proposed methods on various popular tasks and mod-
els in computer vision and natural language processing. Experimental results demonstrate that our
methods have higher learning speed early in training and in the meantime guarantee strong gener-
alization performance compared to several adaptive and non-adaptive methods. Moreover, they can
bring considerable improvement over their prototypes especially on complex deep networks.
2	Notations and Preliminaries
Notations Given a vector θ ∈ Rd we denote its i-th coordinate by θi ; we use θk to denote element-
wise power of k and k θ k to denote its '2 -norm; for a vector θt in the t-th iteration, the i-th coordinate
ofθt is denoted as θt,i by adding a subscript i. Given two vectors v, w ∈ Rd, we use hv, wi to denote
their inner product, v w to denote element-wise product, v/w to denote element-wise division,
max(v, w) to denote element-wise maximum and min(v, w) to denote element-wise minimum. We
use S+d to denote the set of all positive definite d × d matrices. For a vector a ∈ Rd and a positive
definite matrix M ∈ Rd×d, We use a/M to denote M-1a and √M to denote M1/2. The projection
operation ΠF,M (y) for M ∈ S+d is defined as arg minx∈F kM1/2(x - y)k for y ∈ Rd. We say F
has bounded diameter D∞ if kx - yk∞ ≤ D∞ for all x, y ∈ F .
Online convex programming A flexible framework to analyze iterative optimization methods is
the online optimization problem. It can be formulated as a repeated game between a player (the
algorithm) and an adversary. At step t, the algorithm chooses an decision xt ∈ F, where F ⊂ Rd is
a convex feasible set. Then the adversary chooses a convex loss function ft and the algorithm incurs
loss ft (xt). The difference between the total loss PtT=1 ft (xt) and its minimum value for a fixed
decision is known as the regret, which is represented by RT = PtT=1 ft(xt) - minx∈F PtT=1 ft(x).
Throughout this paper, we assume that the feasible set F has bounded diameter and ∣∣Vft(χ)k∞ is
bounded for all t ∈ [T] and x ∈ F. We are interested in algorithms with little regret. Formally
speaking, our aim is to devise an algorithm that ensures RT = o(T), which implies that on average,
the model’s performance converges to the optimal one. It has been pointed out that an online op-
timization algorithm with vanishing average regret yields a corresponding stochastic optimization
algorithm (Cesa-Bianchi et al., 2002). Thus, following Reddi et al. (2018), we use online gradient
descent and stochastic gradient descent synonymously.
A generic overview of optimization methods We follow Reddi et al. (2018) to provide a generic
framework of optimization methods in Algorithm 1 that encapsulates many popular adaptive and
non-adaptive methods. This is useful for understanding the properties of different optimization
methods. Note that the algorithm is still abstract since the functions φt : Ft → Rd and ψt :
Fd → S+ have not been specified. In this paper, we refer to α as initial step size and at / √Vt as
2
Published as a conference paper at ICLR 2019
Algorithm 1 Generic framework of optimization methods
Input: x1 ∈ F, initial step size α, sequence of functions {φt , ψt}tT=1
1:	for t = 1 to T do
2:	gt = ▽%(Xt)
3：	mt = Φt(gι,…，gt) and Vt = Ψt(gι,…，gt)
4:	αt = α/ʌ/t
5：	Xt+1 = Xt - αtmt/√Vt
6：	xt+1 = πf ,√Vt(Xt+1)
7： end for
learning rate of the algorithm. Note that We employ a design of decreasing step size by at = α∕√7
for it is required for theoretical proof of convergence. However such an aggressive decay of step
size typically translates into poor empirical performance, While a simple constant step size αt =
α usually Works Well in practice. For the sake of clarity, We Will use the decreasing scheme for
theoretical analysis and the constant schemem for empirical study in the rest of the paper.
Under such a frameWork, We can summarize the popular optimization methods in Table 1.1 A
feW remarks are in order. We can see the scaling term ψt is I in SGD(M), While adaptive methods
introduce different kinds of averaging of the squared values of past gradients. Adam and RMSprop
can be seen as variants of AdaGrad, Where the former ones use an exponential moving average as
function ψt instead of the simple average used in ADAGRAD. In particular, RMSPROP is essentially
a special case of ADAM With β1 = 0. AMSGRAD is not listed in the table as it does not has a simple
expression of ψt. It can be defined as ψt = diag(Vt) where Vt is obtained by the following recursion:
vt = β2vt-1 + (1 - β2)gl and Vt = max(Vt-ι,vt) with Vo = vo = 0. The definition of φt is same
with that of Adam. In the rest of the paper we will mainly focus on Adam due to its generality but
our arguments also apply to other similar adaptive methods such as RMSprop and AMSGrad.
Table 1： An overview of popular optimization methods using the generic framework.
	Sgd	SGDM	AdaGrad	RMSprop	Adam
— φt	gt	t P γt-igi	gt	gt	t (1 - β1) P β1t-igi
		i=1	t	t	i=1 t
ψt	I	I	diag( P gi2)/t	(1-β2)diag(Pβ2t-igi2)	(1-β2)diag(Pβ2t-igi2)
			i=1	i=1	i=1
3 The Non-Convergence Caused by Extreme Learning Rate
In this section, we elaborate the primary defect in current adaptive methods with a preliminary ex-
periment and a rigorous proof. As mentioned above, adaptive methods like Adam are observed to
perform worse than Sgd. Reddi et al. (2018) proposed AMSGrad to solve this problem but re-
cent work has pointed out AMSGrad does not show evident improvement over Adam (Keskar &
Socher, 2017; Chen et al., 2018). Since AMSGrad is claimed to have a smaller learning rate com-
pared with Adam, the authors only consider large learning rates as the cause for bad performance
of Adam. However, small ones might be a pitfall as well. Thus, we speculate both extremely large
and small learning rates of Adam are likely to account for its ordinary generalization ability.
For corroborating our speculation, we sample learning rates of several weights and biases of ResNet-
34 on CIFAR-10 using ADAM. Specifically, we randomly select nine 3 × 3 convolutional kernels
from different layers and the biases in the last linear layer. As parameters of the same layer usually
have similar properties, here we only demonstrate learning rates of nine weights sampled from nine
kernels respectively and one bias from the last layer by the end of training, and employ a heatmap
to visualize them. As shown in Figure 1, we can find that when the model is close to convergence,
learning rates are composed of tiny ones less than 0.01 as well as huge ones greater than 1000.
1We ignore the debiasing term used in the original version of Adam in Kingma & Lei Ba (2015) for
simplicity. Our arguments apply to the debiased version as well.
3
Published as a conference paper at ICLR 2019
-5.8
-3.7	-3.4	-3.7
4.5
8.6	2
-1.6
wl w2 w3 w4 w5 w6 w7 w8 w9 b
Figure 1: Learning rates of sampled parameters. Each cell contains a value obtained by conducting
a logarithmic operation on the learning rate. The lighter cell stands for the smaller learning rate.
The above analysis and observation show that there are indeed learning rates which are too large or
too small in the final stage of the training process. AMS Grad may help abate the impact of huge
learning rates, but it neglects the other side of the coin. Insofar, we still have the following two
doubts. First, does the tiny learning rate really do harm to the convergence of Adam? Second, as
the learning rate highly depends on the initial step size, can we use a relatively larger initial step size
α to get rid of too small learning rates?
To answer these questions, we show that undesirable convergence behavior for Adam and RM-
Sprop can be caused by extremely small learning rates, and furthermore, in some cases no matter
how large the initial step size α is, ADAM will still fail to find the right path and converge to some
highly suboptimal points. Consider the following sequence of linear functions for F = [-1, 1]:
{—x, for t mod C = 1;
2x,	for t mod C = 2;
0, otherwise
where C ∈ N satisfies: 5βC-2 ≤ (1 — β2)/2(4 一 β2). For this function sequence, it is easy to
see that the point x = —1 provides the minimum regret. Supposing β1 = 0, we show that ADAM
converges to a highly suboptimal solution of x ≥ 0 for this setting. Intuitively, the reasoning is as
follows. The algorithm obtains a gradient —1 once every C steps, which moves the algorithm in the
wrong direction. Then, at the next step it observes a gradient 2. But the larger gradient 2 is unable to
counteract the effect to wrong direction since the learning rate at this step is scaled down to a value
much less than the previous one, and hence x becomes larger and larger as the time step increases.
We formalize this intuition in the result below.
Theorem 1. There is an online convex optimization problem where for any initial step size α, ADAM
has non-zero average regret i.e., RT/T 9 0 as T → ∞.
We relegate all proofs to the appendix. Note that the above example also holds for constant step
size αt = α. Also note that vanilla SGD does not suffer from this problem. There is a wide range
of valid choices of initial step size α where the average regret of SGD asymptotically goes to 0, in
other words, converges to the optimal solution. This problem can be more obvious in the later stage
of a training process in practice when the algorithm gets stuck in some suboptimal points. In such
cases, gradients at most steps are close to 0 and the average of the second order momentum may
be highly various due to the property of exponential moving average. Therefore, “correct” signals
which appear with a relatively low frequency (i.e. gradient 2 every C steps in the above example)
may not be able to lead the algorithm to a right path, if they come after some “wrong” signals (i.e.
gradient 1 in the example), even though the correct ones have larger absolute value of gradients.
One may wonder if using large βι helps as we usually use βι close to 1 in practice. However, the
following result shows that for any constant βι and β2 with βι < √β2, there exists an example
where ADAM has non-zero average regret asymptotically regardless of the initial step size α.
Theorem 2. For any constant β1,β2 ∈ [0,1) such that βι < √β2, there is an online convex
optimization problem where for any initial step size α, ADAM has non-zero average regret i.e.,
RT/T 9 0 asT → ∞.
Furthermore, a stronger result stands in the easier stochastic optimization setting.
Theorem 3. For any constant β1,β2 ∈ [0,1) such that βι < √β2^, there is a stochastic convex
optimization problem where for any initial step size α, ADAM does not converge to the optimal
solution.
4
Published as a conference paper at ICLR 2019
Remark. The analysis of ADAM in Kingma & Lei Ba (2015) relies on decreasing β1 over time, while
here we use constant β1. Indeed, since the critical parameter is β2 rather than β1 in our analysis, it
is quite easy to extend our examples to the case using decreasing scheme of β1.
As mentioned by Reddi et al. (2018), the condition βι < √β2 is benign and is typically satisfied
in the parameter settings used in practice. Such condition is also assumed in convergence proof of
Kingma & Lei Ba (2015). The above results illustrate the potential bad impact of extreme learning
rates and algorithms are unlikely to achieve good generalization ability without solving this problem.
4 Adaptive Moment Estimation with Dynamic B ound
In this section we develop new variants of optimization methods and provide their convergence
analysis. Our aim is to devise a strategy that combines the benefits of adaptive methods, viz. fast
initial progress, and the good final generalization properties of Sgd. Intuitively, we would like to
construct an algorithm that behaves like adaptive methods early in training and like Sgd at the end.
Algorithm 2 ADAB OUND
Input: x1 ∈ F, initial step size α, {β1t}tT=1, β2, lower bound function ηl, upper bound function ηu
1:	Set m0 = 0, v0 = 0
2:	for t = 1 to T do
3:	gt = ▽%(Xt)
4:	mt = β1tmt-1 + (1 - β1t)gt
5:	Vt = β2vt-1 + (1 — β2)g2 and Vt = diag(vt)
6:	^ = ciip(α∕√¼ ,ηι(t),ηu(t)) and η = ηt∕√t
7:	xt+1 = πf,diag(η-I)(Xt — ηt ® mt)
8:	end for
Inspired by gradient clipping, a popular technique used in practice that clips the gradients larger than
a threshold to avoid gradient explosion, we employ clipping on learning rates in Adam to propose
AdaB ound in Algorithm 2. Consider applying the following operation in Adam
Clip(α∕√Vt, ηι ,ηu),
which clips the learning rate element-wisely such that the output is constrained to be in [ηl , ηu].2
It follows that SGD(M) with α = α* can be considered as the case where η =%=α*. As
for ADAM, ηl = 0 and ηu = ∞. Now we can provide the new strategy with the following steps.
We employ ηl and ηu as functions of t instead of constant lower and upper bound, where ηl (t) is a
non-decreasing function that starts from 0 as t = 0 and converges to a* asymptotically; and ηu(t)
is a non-increasing function that starts from ∞ as t = 0 and also converges to a* asymptotically.
In this setting, AdaB ound behaves just like Adam at the beginning as the bounds have very little
impact on learning rates, and it gradually transforms to Sgd(M) as the bounds become more and
more restricted. We prove the following key result for AdaBound.
Theorem 4. Let {xt} and {vt} be the Sequences obtained from Algorithm 2, βι = β11, βιt ≤ βι
for all t ∈ [T] and β1∕√β2 < L Suppose ηι(t + 1) ≥ ηι(t) > 0, ηu(t + 1) ≤ ηu(t), ηι(t) → α*
as t → ∞, ηu(t) → a* as t → ∞, L∞ = ηι(1) and R∞ = ηu(1). Assume that ∣∣x — yk∞ ≤ D∞
for all x,y ∈ F and ∣∣Vft(x)∣ ≤ G2 for all t ∈ [T] and X ∈ F. For Xt generated using the
ADAB OUND algorithm, we have the following bound on the regret
R D d∞ √T XX ^-1 I
RT ≤ 2(T-^ i=ι ηT,i+
D∞2
2(1 — β1)
_ T _ _ d _	R 尸 2
XX βιtη-i + (2√T -1) R-G.
t=1 i=1	1 — β1
The following result falls as an immediate corollary of the above result.
Corollary 4.1. Suppose β1t = β1λt-1 in Theorem 4, we have
R ≤ D∞√T X -1 +	βιdD∞
T - 2(1 - βι) LηT，i + 2(1 — βι)(1 — λ)2L∞
+ (2√T - 1) R∞G2.
1 — β1
2Here we use constant step size for simplicity. The case using a decreasing scheme of step size is similar.
This technique was also mentioned in previous work (Keskar & Socher, 2017).
5
Published as a conference paper at ICLR 2019
It is easy to see that the regret of ADABOUND is upper bounded by O(√T). Similar to Reddi
et al. (2018), one can use a much more modest momentum decay of βιt = βι∕t and still ensure
a regret of O(√T). It should be mentioned that one can also incorporate the dynamic bound in
AMSGrad. The resulting algorithm, namely AMSBOUnd, also holds a regret of Ο(√T) and the
proof of convergence is almost same to Theorem 4 (see Appendix F for details). In next section we
will see that AMSBound has similar performance to AdaB ound in several well-known tasks.
We end this section with a comparison to the previous work. For the idea of transforming Adam
to Sgd, there is a similar work by Keskar & Socher (2017). The authors propose a measure that
uses Adam at first and switches the algorithm to Sgd at some specific step. Compared with their
approach, our methods have two advantages. First, whether there exists a fixed turning point to
distinguish Adam and Sgd is uncertain. So we address this problem with a continuous transforming
procedure rather than a “hard” switch. Second, they introduce an extra hyperparameter to decide the
switching time, which is not very easy to fine-tune. As for our methods, the flexible parts introduced
are two bound functions. We conduct an empirical study of the impact of different kinds of bound
functions. The results are placed in Appendix G for We find that the convergence target α* and
convergence speed are not very important to the final results. For the sake of clarity, we will use
ηι(t) = 0.1- (-O'+] and ηu(t) = 0.1+ q-& in the rest of the paper unless otherwise specified.
5 Experiments
In this section, we turn to an empirical study of different models to compare new variants with
popular optimization methods including Sgd(M), AdaGrad, Adam, and AMSGrad. We fo-
cus on three tasks: the MNIST image classification task (Lecun et al., 1998), the CIFAR-10 image
classification task (Krizhevsky & Hinton, 2009), and the language modeling task on Penn Treebank
(Marcus et al., 1993). We choose them due to their broad importance and availability of their archi-
tectures for reproducibility. The setup for each task is detailed in Table 2. We run each experiment
three times with the specified initialization method from random starting points. A fixed budget on
the number of epochs is assigned for training and the decay strategy is introduced in following parts.
We choose the settings that achieve the lowest training loss at the end.
Table 2: Summaries of the models utilized for our experiments.
Dataset	Network Type	Architecture
MNIST	Feedforward	1-Layer Perceptron
CIFAR-10	Deep Convolutional	DenseNet-121
CIFAR-10	Deep Convolutional	ResNet-34
Penn Treebank	Recurrent	1-Layer LSTM
Penn Treebank	Recurrent	2-Layer LSTM
Penn Treebank	Recurrent	3-Layer LSTM
5.1	Hyperparameter Tuning
Optimization hyperparameters can exert great impact on ultimate solutions found by optimization
algorithms so here we describe how we tune them. To tune the step size, we follow the method
in Wilson et al. (2017). We implement a logarithmically-spaced grid of five step sizes. If the best
performing parameter is at one of the extremes of the grid, we will try new grid points so that the
best performing parameters are at one of the middle points in the grid. Specifically, we tune over
hyperparameters in the following way.
Sgd(M) For tuning the step size of SGD(M), we first coarsely tune the step size on a logarithmic
scale from {100, 10, 1, 0.1, 0.01} and then fine-tune it. Whether the momentum is used depends on
the specific model but we set the momentum parameter to default value 0.9 for all our experiments.
We find this strategy effective given the vastly different scales of learning rates needed for different
modalities. For instance, SGD with α = 10 performs best for language modeling on PTB but for the
ResNet-34 architecture on CIFAR-10, a learning rate of 0.1 for SGD is necessary.
6
Published as a conference paper at ICLR 2019
AdaGrad The initial set of step sizes used for ADAGRAD are: {5e-2, 1e-2, 5e-3, 1e-3, 5e-4}.
For the initial accumulator value, we choose the recommended value as 0.
Adam & AMSGrad We employ the same hyperparameters for these two methods. The initial
step sizes are chosen from: {1e-2, 5e-3, 1e-3, 5e-4, 1e-4}. We turn over β1 values of {0.9, 0.99} and
β2 values of {0.99, 0.999}. We use for the perturbation value = 1e-8.
AdaBound & AMSBound We directly apply the default hyperparameters for ADAM (a learn-
ing rate of 0.001, β1 = 0.9 and β2 = 0.999) in our proposed methods.
Note that for other hyperparameters such as batch size, dropout probability, weight decay and so on,
we choose them to match the recommendations of the respective base architectures.
5.2	Feedforward Neural Network
We train a simple fully connected neural network with one hidden layer for the multiclass classifica-
tion problem on MNIST dataset. We run 100 epochs and omit the decay scheme for this experiment.
Figure 2 shows the learning curve for each optimization method on both the training and test set.
We find that for training, all algorithms can achieve the accuracy approaching 100%. For the test
part, Sgd performs slightly better than adaptive methods Adam and AMSGrad. Our two pro-
posed methods, AdaB ound and AMSBound, display slight improvement, but compared with
their prototypes there are still visible increases in test accuracy.
100.0
98.0
(a) Training Accuracy	(b) Test Accuracy
Figure 2: Training (left) and test accuracy (right) for feedforward neural network on MNIST.
5.3	Convolutional Neural Network
Using DenseNet-121 (Huang et al., 2017) and ResNet-34 (He et al., 2016), we then consider the task
of image classification on the standard CIFAR-10 dataset. In this experiment, we employ the fixed
budget of 200 epochs and reduce the learning rates by 10 after 150 epochs.
DenseNet We first run a DenseNet-121 model on CIFAR-10 and our results are shown in Figure 3.
We can see that adaptive methods such as AdaGrad, Adam and AMSGrad appear to perform
better than the non-adaptive ones early in training. But by epoch 150 when the learning rates are
decayed, SgdM begins to outperform those adaptive methods. As for our methods, AdaBound
and AMSBound, they converge as fast as adaptive ones and achieve a bit higher accuracy than
SgdM on the test set at the end of training. In addition, compared with their prototypes, their
performances are enhanced evidently with approximately 2% improvement in the test accuracy.
ResNet Results for this experiment are reported in Figure 3. As is expected, the overall per-
formance of each algorithm on ResNet-34 is similar to that on DenseNet-121. AdaB ound and
AMSBOUND even surpass SGDM by 1%. Despite the relative bad generalization ability of adap-
tive methods, our proposed methods overcome this drawback by allocating bounds for their learning
rates and obtain almost the best accuracy on the test set for both DenseNet and ResNet on CIFAR-10.
5.4	Recurrent Neural Network
Finally, we conduct an experiment on the language modeling task with Long Short-Term Memory
(LSTM) network (Hochreiter & Schmidhuber, 1997). From two experiments above, we observe that
7
Published as a conference paper at ICLR 2019
sx9En∞v u-e∙u.
100.0
97.5
95.0
92.5
(a) Training Accuracy for DenseNet-121
*XSeJnUSV≈αx
(b) Test Accuracy for DenseNet-121
(c) Training Accuracy for ResNet-34
Figure 3: Training and test accuracy for DenseNet-121 and ResNet-34 on CIFAR-10.
(d) Test Accuracy for ResNet-34
our methods show much more improvement in deep convolutional neural networks than in percep-
trons. Therefore, we suppose that the enhancement is related to the complexity of the architecture
and run three models with (L1) 1-layer, (L2) 2-layer and (L3) 3-layer LSTM respectively. We train
them on Penn Treebank, running for a fixed budget of 200 epochs. We use perplexity as the metric
to evaluate the performance and report results in Figure 4.
l0'5'0,5,°,5
0 9 9 8 8 7
dJ9d
(a) L1: 1-Layer LSTM
(b) L2: 2-Layer LSTM
(c) L3: 3-Layer LSTM
Figure 4: Perplexity curves on the test set comparing Sgd, Adam, AdaB ound and AMSBound
for the LSTM with different layers on Penn Treebank.
We find that in all models, Adam has the fastest initial progress but stagnates in worse performance
than Sgd and our methods. Different from phenomena in previous experiments on the image clas-
sification tasks, AdaBound and AMSBound does not display rapid speed at the early training
stage but the curves are smoother than that of Sgd.
8
Published as a conference paper at ICLR 2019
Comparing L1, L2 and L3, we can easily notice a distinct difference of the improvement degree.
In L1, the simplest model, our methods perform slightly 1.1% better than ADAM while in L3, the
most complex model, they show evident improvement over 2.8% in terms of perplexity. It serves as
evidence for the relationship between the model’s complexity and the improvement degree.
5.5	Analysis
To investigate the efficacy of our proposed algorithms, we select popular tasks from computer vision
and natural language processing. Based on results shown above, it is easy to find that Adam and
AMS Grad usually perform similarly and the latter does not show much improvement for most
cases. Their variants, AdaB ound and AMSBound, on the other hand, demonstrate a fast speed
of convergence compared with Sgd while they also exceed two original methods greatly with respect
to test accuracy at the end of training. This phenomenon exactly confirms our view mentioned in
Section 3 that both large and small learning rates can influence the convergence.
Besides, we implement our experiments on models with different complexities, consisting of a per-
ceptron, two deep convolutional neural networks and a recurrent neural network. The perceptron
used on the MNIST is the simplest and our methods perform slightly better than others. As for
DenseNet and ResNet, obvious increases in test accuracy can be observed. We attribute this differ-
ence to the complexity of the model. Specifically, for deep CNN models, convolutional and fully
connected layers play different parts in the task. Also, different convolutional layers are likely to be
responsible for different roles (Lee et al., 2009), which may lead to a distinct variation of gradients
of parameters. In other words, extreme learning rates (huge or tiny) may appear more frequently in
complex models such as ResNet. As our algorithms are proposed to avoid them, the greater enhance-
ment of performance in complex architectures can be explained intuitively. The higher improvement
degree on LSTM with more layers on language modeling task also consists with the above analysis.
6	Future Work
Despite superior results of our methods, there still remain several problems to explore. For example,
the improvement on simple models are not very inspiring, we can investigate how to achieve higher
improvement on such models. Besides, we only discuss reasons for the weak generalization ability
of adaptive methods, however, why Sgd usually performs well across diverse applications of ma-
chine learning still remains uncertain. Last but not least, applying dynamic bounds on learning rates
is only one particular way to conduct gradual transformation from adaptive methods to Sgd. There
might be other ways such as well-designed decay that can also work, which remains to explore.
7	Conclusion
We investigate existing adaptive algorithms and find that extremely large or small learning rates can
result in the poor convergence behavior. A rigorous proof of non-convergence for Adam is provided
to demonstrate the above problem.
Motivated by the strong generalization ability of Sgd, we design a strategy to constrain the learn-
ing rates of Adam and AMSGrad to avoid a violent oscillation. Our proposed algorithms, Ad-
aB ound and AMSBound, which employ dynamic bounds on their learning rates, achieve a
smooth transition to Sgd. They show the great efficacy on several standard benchmarks while
maintaining advantageous properties of adaptive methods such as rapid initial progress and hyper-
parameter insensitivity.
Acknowledgments
We thank all reviewers for providing the constructive suggestions. We also thank Junyang Lin and
Ruixuan Luo for proofreading and doing auxiliary experiments. Xu Sun is the corresponding author
of this paper.
9
Published as a conference paper at ICLR 2019
References
Nico Cesa-Bianchi, Alex Conconi, and Claudio Gentile. On the generalization ability of on-line
learning algorithms. In Advances in Neural Information Processing Systems 14 (NIPS), pp. 359-
366, 2002.
Xiangyi Chen, Sijia Liu, Ruoyu Sun, and Mingyi Hong. On the convergence ofa class of Adam-type
algorithms for non-convex optimization. CoRR, abs/1808.02941, 2018.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and
stochastic optimization. Journal of Machine Learning Research (JMLR), 12:2121-2159, 2011.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition
(CVPR), 2016.
Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural Comput., 9(8):1735-
1780, 1997.
Gao Huang, Zhuang Liu, Laurens van der Maaten, and Kilian Q Weinberger. Densely connected
convolutional networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2017.
Nitish Shirish Keskar and Richard Socher. Improving generalization performance by switching from
Adam to SGD. CoRR, abs/1712.07628, 2017.
Diederik P Kingma and Jimmy Lei Ba. Adam: A method for stochastic optimization. In Proceedings
of the 3rd International Conference on Learning Representations (ICLR), 2015.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. Tech-
nical report, 2009.
Yann Lecun, Leon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. In Proceedings of the IEEE, pp. 2278-2324, 1998.
Honglak Lee, Roger Grosse, Rajesh Ranganath, and Andrew Y Ng. Convolutional deep belief
networks for scalable unsupervised learning of hierarchical representations. In Proceedings of the
26th Annual International Conference on Machine Learning (ICML), pp. 609-616, 2009.
Liangchen Luo, Wenhao Huang, Qi Zeng, Zaiqing Nie, and Xu Sun. Learning personalized end-to-
end goal-oriented dialog. In Proceedings of the 33rd AAAI Conference on Artificial Intelligence
(AAAI), 2019.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a large annotated
corpus of english: The penn treebank. Comput. Linguist., 19(2):313-330, 1993.
H Brendan Mcmahan and Matthew Streeter. Adaptive bound optimization for online convex op-
timization. In Proceedings of the 23rd Annual Conference On Learning Theory (COLT), pp.
244-256, 2010.
Sashank J. Reddi, Stayen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In
Proceedings of the 6th International Conference on Learning Representations (ICLR), 2018.
Herbert Robbins and Sutton Monro. A stochastic approximation method. The Annals of Mathemat-
ical Statistics, 22(3):400-407, 1951.
Tijmen Tieleman and Geoffrey Hinton. RMSprop: Divide the gradient by a running average of its
recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26-31, 2012.
Ashia C Wilson, Rebecca Roelofs, Mitchell Stern, Nati Srebro, and Benjamin Recht. The marginal
value of adaptive gradient methods in machine learning. In Advances in Neural Information
Processing Systems 30 (NIPS), pp. 4148-4158, 2017.
Yuxin Wu and Kaiming He. Group normalization. In Proceedings of the 15th European Conference
on Computer Vision (ECCV), pp. 3-19, 2018.
10
Published as a conference paper at ICLR 2019
Appendix
A Auxiliary Lemmas
Lemma 1 (Mcmahan & Streeter (2010)). For any Q ∈ S+d and convex feasible setF ⊂ Rd, suppose
u1 = minx∈F kQ1/2(x-z1)k and u2 = minx∈F kQ1/2(x-z2)k then we have kQ1/2(u1 -u2)k ≤
kQ1/2(z1 - z2)k.
Proof. We provide the proof here for completeness. Since u1 = minx∈F Q1/2(x - z1) and
u2 = minx∈F Q1/2(x - z2) and from the property of projection operator we have the following:
hu1 - z1, Q(u2 - u1)i ≥ 0 and hu2 - z2, Q(u1 - u2)i ≥ 0.
Combining the above inequalities, we have
hz2 - z1,Q(u2 - u1)i ≥ hu2 - u1, Q(u2 - u1)i .	(1)
Also, observe the following:
hz2 - z1, Q(U2 - UI)i ≤ 2 [hu2 - u1, Q(U2 - UI)i + hz2 - z1, Q(Z2 - ZI)i] ∙
The above inequality can be obtained from the fact that
h(U2 - U1) - (Z2 - Z1), Q((U2 - U1) - (Z2 - Z1))i ≥ 0 as Q ∈ S+d
and rearranging the terms. Combining the above inequality with Equation (1), we have the required
the result.	□
Lemma 2. Suppose mt = β1 mt-1 + (1 - β1)gt with m0 = 0 and 0 ≤ β1 < 1. We have
TT
Xkmtk2 ≤Xkgtk2.
t=1	t=1
Proof. If β1 = 0, the equality directly holds due to mt = gt. Otherwise, 0 < β1 < 1. For any θ > 0
we have
kmtk2 = kβ1mt-1 k2 + k(1 - β1)gt k2 + 2hβ1mt-1, (1 - β1)gti
≤ kβιmt-ik2 + k(1 — βι)gtk2 + Θkβιmt-ik2 + 1∕θk(1 — βι)gtk2
= (1 + Θ)kβιmt-ik2 + (1 + 1∕θ)k(1 — βι)gtk2
The inequality follows from CaUchy-SchWarz and Young's inequality. In particular, let θ = 1∕βι —
1. Then we have
kmtk2 ≤ β1kmt-1k2 + (1 — β1)kgtk2.
Dividing both sides by β1t, we get
kmtk2 ≤ kmt-ik2 , (1 — βι)kgtk2
β1	≤	β1-1	+	β1
Note that m0 = 0. Hence,
kmtk2
β1
t
≤ (1-βι) X kgik2β-i.
i=1
Then multiplying both sides by β1t we obtain
t
kmtk2 ≤ (1-βι) X kgik2βt-i.
i=1
11
Published as a conference paper at ICLR 2019
Take the summation of above inequality over t = 1, 2,∙∙∙,T, we have
T	Tt
Xkmtk2 ≤ (1-β1)XXkgik2β1t-i
t=1	t=1 i=1
TT
= (1-β1)XXkgik2β1t-i
i=1 t=i
T
≤ X kgtk2.
t=1
The second inequality is due to the following fact of geometric series
N∞
X βi ≤ X βi = TT瓦，for 0 <βι < 1.
We complete the proof.
□
B Proof of Theorem 1
Proof. First, we rewrite the update of ADAM in Algorithm 1 in the following recursion form:
mt,i = β1mt-1,i + (1 - β1)gt,i and vt,i = β2vt-1,i + (1 - β2)gt2,i	(2)
where m0,i = 0 and v0,i = 0 for all i ∈ [d] and ψt = diag(vt). We consider the setting where ft
are linear functions and F = [-1, 1]. In particular, we define the following function sequence:
{—x, for t mod C = 1;
2x, for t mod C = 2;
0, otherwise
where C ∈ N satisfies the following:
5β2C-2
≤1 ∙1 — β
2 2 4 — β2
(3)
It is not hard to see that the condition hold for large constant C that depends on β2 .
Since the problem is one-dimensional, we drop indices representing coordinates from all quantities
in Algorithm 1. For this function sequence, it is easy to see that the point x = —1 provides the
minimum regret. Consider the execution of Adam algorithm for this sequence of functions with
β1 = 0. Note that since gradients of these functions are bounded, F has bounded D∞ diameter and
β12 /β2 < 1 as β1 = 0, the conditions on the parameters required for ADAM are satisfied (Kingma &
Lei Ba, 2015). The gradients have the following form:
Pfi(X)
—1,
2,
0,
for i mod C = 1;
for i mod C = 2;
otherwise.
Let τ ∈ N, τ > 1 be such that
α
——	==≤ 1,
Cct + 1 √(1 — β2)(βC + 4βC-1 + 1)
α2
(4)
,	「	---- ≤ 1,
√Ct+2 P(1 — β2)(4 + β2)-,
for all t ≥ τ . We start with the following preliminary result.
(5)
1
12
Published as a conference paper at ICLR 2019
Lemma 3. For the parameter settings and conditions assumed in Theorem 1, there is a t0 ≥ τ such
that xCt0+1 ≥ 0.
Proof by contradiction. Assume that xCt+1 < 0 for all t ≥ τ . Firstly, for t ≥ τ , we observe the
following inequalities:
vCt+1 = β2vCt + (1 - β2)
tt
= (1-β2)(1+Xβ2Ci+4Xβ2Ci-1)	(6)
i=1	i=1
≥ (1 - β2)(β2C + 4β2C-1 + 1),
vCt+1 = β2vCt + (1 - β2)
tt
= (1-β2)(Xβ2Ci+4Xβ2Ci-1)+(1-β2)
i=1	i=1
≤ (1-β2)βCi+-4f-1 + (1-β2)
≤ 5β2C-1 + (1 -β2) < 9,
tt
vCt+2=(1-β2)(Xβ2Ci+1+4Xβ2Ci)
i=0	i=0
1	βCt
= (1-β2)(4 + β2)7^C
1 - β2
≤ 4 + β2 < 9.
From the (Cτ + 1)-th update of ADAM in Equation (2), we obtain:
(7)
(8)
α1
xCτ +1 +-/c ■,	/	:
CT+ + 1 √vcτ+1
<
α1
√C++1 q(i- β2)(βc+4βc-1+1)
≤ 1.
The first inequality follows from xCt+1 < 0 and Equation (6). The last inequality follows from
Equation (4). Therefore, we have -1 ≤ xcτ +1 < Xcτ+2 < 1 and hence χcτ+2 = Xcτ+2. Then
after the (Cτ + 2)-th update, we have:
α2
XCT+3 = XCT+2-√cτ+^ √vcτ+2
α1	α2
=XCT +1 +-6 T /	1-6 C /
C++ +1 √vcτ +1	√CT÷2 √vcτ+2
≥ X +	1__________αβ2(vcτ+1 - 4vcτ)_______
― CT +1 √C+ + C √vcτ +1Vcτ+2 (√vcτ +2 + 2√Vcτ +1)
(9)
≥ XcT+1 +
√⅛8∣√⅛(VCT+1-4VCT)
≥ XcT+1 +
1	αβ2 (I 一尸2 )
√+ +1 162√T
κ
XCT+1 + /	,
++1
where K = αβ2(1 - β2)∕162√T is a constant that depends on α, β2 and C. The first inequality
follows from Equation (2). The second inequality follows from Equations (7) and (8). The last
13
Published as a conference paper at ICLR 2019
inequality is due to the following lower bound:
vCt+1 - 4vCt = β2vCt + (1 - β2) - 4vCt
= (4 - β2)
= (4 - β2)
≥ (4 - β2)
≥ (4 - β2)
1 — β2
4 - β2
1 — β2
4 - β2
1 — β2
4 — β2
1 — β2
4 — β2
- vCt
-(1 - β2)(∑βCi-1 +4∑βCi-2)
i=1	i=1
—(1-β2 J + ΓC-c)1
1 — β2	1 — β2
- 5β2C-2
≥ (4 — β2) • 2
_ 1 - β2
=2	,
1 — β2
4 — β2
where the last inequality follows from Equation (3). Therefore, We have -1 ≤ χcτ +1 < Xcτ+3 <
xcτ+2 < 1. Furthermore, since gradients Vfi(x) = 0 when i mod C = 1 or 2, we have
xCτ+4 = xCτ+3 = xCτ+3,
xCτ+5 = xCτ+4 = xCτ+4,
xC(τ +1) + 1 = xC(τ +1)+1 = xC(τ +1).
Then, following Equation (9) we have
κ
χC(τ+1)+1 - χCτ+1 ≥ √τ + J .
Similarly, we can subsequently obtain
xC (τ +2)+1 — xC (τ +1)+1
κ
≥ ,	,
— √Γ+2,
and generally
for all t ≥ τ . Therefore,
κ
xC(t+1) + 1 - χCt+1 ≥ √t+1
κκ	κ
xCt+1 ≥ xCτ +1 +-/	+-/ C + ∙∙∙ +-万
+	+	√τ + 1	√τ + 2	√t
t1
≥-1+κ X1 √n
n=τ +1
≥ —1 + K
t+1
τ+1
dx
√x
t
t
—1 + 2κ( √t + 1 — √τ + 1)
for t ≥ T. Let t0 be such that 2κ(√t0 + 1 — √τ + 1) ≥ 1, then xCt，+1 ≥ 0. ThiS contradicts the
assumption that xCt+1 < 0 for all t ≥ T. We complete the proof of this lemma.	口
We now return to the proof of Theorem 1. The following analysis focuses on iterations after Ct0 + 1
such that xCt0+1 ≥ 0. Note that any regret before Ct0 + 1 is just a constant since t0 is independent
of T and thus, the average regret is negligible as T → ∞.
Our claim is that, xk ≥ 0 for all k ∈ N, k ≥ Ct0 + 1. To prove this, we resort to the principle of
mathematical induction. Suppose for some t ∈ N, t ≥ t0, we have xCt+1 ≥ 0. Our aim is to prove
that xi ≥ 0 for all i ∈ N ∩ [Ct + 2, C(t + 1) + 1].
14
Published as a conference paper at ICLR 2019
From the (Ct + 1)-th update of ADAM in Equation (2), we obtain:
α1
xCt+2 = xCt+1 +≥ 0.
+	+	Cct + 1 √vct+i
We consider the following two cases:
1.	Suppose Xct+2 > 1, then xct+2 = ∏f(Xct+2)= min{Xct+2,1} = 1 (note that in
one-dimension, ∏f √v = ∏f is the simple Euclidean projection). After the (Ct + 2)-th
update, we have:
XCt+3 = XCt+2 —
α 2
√Ct+2 √vCt+2
α
2
≥ 1 ——,	=
一	√Ct÷2 √(1 - β2)(4 + β2)
≥ 0.
The last inequality follows from Equation (5). The first inequality follows from
tt
vCt+2 =(1 - β2)(X β2Ci+1 + 4Xβ2Ci) ≥ (1-β2)(4+ β2).
i=0	i=0
2.	Suppose Xct+2 ≤ 1, then after the (Ct + 2)-th update, similar to Equation (9), We have:
xCt+3 ≥ xCt+1 +--------------------------------/	≥ 0.
t+ 1
In both cases, Xct+3 ≥ 0, which translates to xct+3 = Xct+3 ≥ 0. Furthermore, since gradients
Vfi (x) = 0 when i mod C = 1 or 2, we have
xCt+4 = xCt+3 = xCt+3 ≥ 0,
xCt+5 = xCt+4 = xCt+4 ≥ 0,
xC(t+1) + 1 = xC(t+1) + 1 = xC(t+1) ≥ 0.
Therefore, given xCt0+1 = 0, it holds for all k ∈ N, k ≥ Ct0 + 1 by the principle of mathematical
induction. Thus, we have
CC
X fkC+i (xkC+i) - X fkC+i(-1) ≥ 0 - (-1) = 1,
i=1	i=1
where k ∈ N, k ≥ t0. Therefore, when t ≥ t0, for every C steps, ADAM suffers a regret ofat least 1.
More specifically, RT ≥ (T 一 t0)∕C. Thus, RT/T 9 0 as T → ∞, which completes the proof. □
C Proof of Theorem 2
Theorem 2 generalizes the optimization setting used in Theorem 1. We notice that the example pro-
posed by Reddi et al. (2018) in their Appendix B already satisfies the constraints listed in Theorem 2.
Here we provide the setting of the example for completeness.
Proof. Consider the setting where ft are linear functions and F = [-1, 1]. In particular, we define
the following function sequence:
ft(x)
Cx, for t mod C = 1;
-x, otherwise,
where C ∈ N, C mod 2 = 0 satisfies the following:
(1-β1)β1C-1C≤ 1-β1C-1,
β(c-2)/2C2 ≤ 1,
3(1— βι) Λ , Y (1-「)! , βC∕2-1 < C
2√T-β2(+	1 一 γ + + 1 一 βι 3 ,
15
Published as a conference paper at ICLR 2019
where Y = βι/√β2 < 1. It is not hard to see that these conditions hold for large constant C that
depends on β1 and β2. According to the proof given by Reddi et al. (2018) in their Appendix B, in
such a setting RT /T 9 0 as T → ∞, which completes the proof.
□
D Proof of Theorem 3
The example proposed by Reddi et al. (2018) in their Appendix C already satisfies the constraints
listed in Theorem 3. Here we provide the setting of the example for completeness.
Proof. Let δ be an arbitrary small positive constant. Consider the following one dimensional
stochastic optimization setting over the domain [-1, 1]. At each time step t, the function ft(x)
is chosen as follows:
ft(x)
{Cx, with probability P := C+1
-x, with probability 1 - p,
where C is a large constant that depends on β1 , β2 and δ. The expected function is F (x) = δx.
Thus the optimal point over [-1,1] is x* = -1. The step taken by ADAM is
∆ = -αt (Bιmt-1 + (I - βI) gt)
Pβ2vt-1 + (1 - β2) g2
According to the proof given by Reddi et al. (2018) in their Appendix C, there exists a large enough
C such thatE[∆t] ≥ 0, which then implies that the ADAM’s step keep drifting away from the optimal
solution x* = -1. Note that there is no limitation of the initial step size α by now. Therefore, we
complete the proof.
□
E Proof of Theorem 4
Proof. Let x* = arg minx∈F PtT=1 ft(x), which exists since F is closed and convex. We begin
with the following observation:
χt+ι = πf,diag(η-1)(Xt - ηt © mt) = m∈in llη-1/2 ©(X - (Xt - ηt © mt))k.
Using Lemma 1 with u1 = xt+1 and u2 = x*, we have the following:
∣∣η-1/2 © (χt+ι - χ*)k2 ≤ kη-1/2 © (Xt- ηt © mt - χ*)k2
=kη-1/2 © (χt - χ*)k2 + kη1/2 ©mtk2 - 2hmt,xt- χ*i
=llη-1/2 © (Xt-X*)k2 + Ilη1/2 © mtk2
- 2hβ1tmt-1 + (1 - β1t)gt, Xt - X*i.
Rearranging the above inequality, we have
hgt,Xt - X*i ≤ * ∖、llη-1/2 © (Xt - X*)k2 - llη-1/2 © (Xt+1 - X*)k2
2(1 - β1t)
+ * ∖、Ilη1/2 © mtk2 + 1 βlt hmt-i,Xt — X*i
2(1 - β1t)	t	1 - β1t
≤ s,门[、llη-1/2 © (Xt - X*)|2 - kη-1/2 © (Xt+ι - X*)|2	(IO)
2(1 - β1t)
+ 2(T⅛)lη1/2 © mtl2 + 2(1¾)lη1/2 © mt-112
+ 2(1 -tβ1t) lηt W © (Xt - X*)12.
16
Published as a conference paper at ICLR 2019
The second inequality follows from simple application of CaUchy-SchWarz and Young's inequal-
ity. We now use the standard approach of bounding the regret at each step using convexity of the
functions {ft }tT=1 in the following manner:
TT
Xft (Xt)- ft(X) ≤ X hgt,xt — x*i
t=1	t=1
T1
≤ E oTi~kη- kn-1/2 θ (Xt - x*32 - kη-1/2 θ (Xt+ι - x*32
t=1 2(1 - β1t)	(11)
+ 2(1⅛)kη1/2 θ mtk2+ 2(Γ‰kη1/2 θ mt-1k2
+ 2(1 —1β1t) kηt 1/2 θ (Xt - x*)k2 .
The first inequality is due to the convexity of functions {ft}tT=1. The second inequality follows from
the bound in Equation (10). For further bounding this inequality, we need the following intermedia
result.
Lemma 4. For the parameter settings and conditions assumed in Theorem 4, we have
T
X [2(1⅛) W2 Θ mtk2 + J W2 Θ mt-ik2] ≤ (2√T - 1)Rf.
Proof. By definition ofηt, we have
L∞ ≤ √tkηtk∞ ≤ R∞.
Hence,
T
X
t=1
1
2(I- βIt)
∣∣η1∕2 θ mtk2 +
_包_ Il„1/2
2(1 - βιt) kηt
Θ mt1I2
T
≤X
t=1
T
≤X
t=1
R∞
2(1 - β1t)√t
ImtI2 +
β1t R∞
2(1 - β1t)√t
Imt1
I2
R∞
2(1 - β1)√t
ImtI2 +
R∞
2(1 - β1)√t
Imt1I2
R∞
2(1- β1)
X k√Γ + X
t=1	t	t=1
Imt1I2
]
≤ 2(⅛ ]T ]X ML' T [X kmt-1L4][
TTT	T
≤ 2⅛ IX " X …+X "1k2 X …
R∞G2 X 1/2
≤厂而⅛
≤
The second inequality is due to β1t ≤ β1 < 1. The third inequality follows from Jensen inequality
and the fourth inequality follows from Cauchy-Schwarz inequality. The fifth inequality follows
from Lemma 2 and m0 = 0. The last inequality is due to the following upper bound:
T 1	T dt
⅛ √t ≤ 1 + L √t
2 Vt -1.
17
Published as a conference paper at ICLR 2019
We complete the proof of this lemma.
□
We now return to the proof of Theorem 4. Using the above lemma in Equation (11), we have
T
t=1
T1
≤ ∑ 2(1-βt) [旧-1/2 Θ (xt - x*)『一旧-1/2 Θ (xt+1 - x*)∣∣2
+	旧-1/2 Θ (xt - x*)∣∣2] + (2√T - 1)R∞G2
2(1 - β1t )	1 - β1
≤ 2(1-β)	旧J" Θ (xι - x*)∣∣2 + XX 卜% 1/2 Θ (xt - x*诉-旧-1/2 Θ (xt - x*)∣∣2
+ XL 2(1β1tβ) 旧-1/2 Θ (xt - x*)∣∣2 + (2√T - 1)R∞G2
1
2(1 - βι)
d	Td
X	η1-,i1(x1,i -xi*)2	+ X X(xt,i -xi*)2	ηt-,i1 - ηt--11,i
i=1	t=2	i=1
_T_ _ d_	_∣	2 尸2
+ XX βιt(χt,i-χ*)2η-i1 +(2√T - 1) R∞G2.
1 - β1
t=1 i=1	1
(12)
The second inequality use the fact that β1t ≤ β1 < 1. In order to further simplify the bound in
Equation (12), we need to use telescopic sum. We observe that, by definition ofηt , we have
ηt-,i1 ≥ ηt--11,i .
Using the D∞ bound on the feasible region and making use of the above property in Equation (12),
we have
T
Xft (xt )-ft (x*)
=1
∩2	∣_ _ d_	_ T_ _ d _「	^l _ T_ _ d _	"∖	R 尸2
≤ 2⅛¾ Xη-1 + XX 谓-η-1ι,i + XXβιtη-i1 +(2√t- 1)H
2(1 - β1) i=1 t=2 i=1	t=1 i=1	1 - β1
厂X配+ 2⅛
Td
XXβ
=1 i=1
IM-1 + (2√T - 1) R∞G2.
The equality follows from simple telescopic sum, which yields the desired result. It is easy to see
that the regret of ADABOUND is upper bounded by O(√T).
□
F AMSBound
Theorem 5. Let {xt} and {vt} be the Sequences obtained from Algorithm 3, βι = β11, βιt ≤ βι
for all t ∈ [T] and β1∕√β2 < L Suppose ηι(t + 1) ≥ ηι(t) > 0, ŋu(t + 1) ≤ ηu(t), ηι(t) → α*
as t → ∞, ηu(t) → α* as t → ∞, L∞ =ηl(1) and R∞ = ηu(1). Assume that kx - yk∞ ≤ D∞
for all x,y ∈ F and ∣∣Vft(x)k ≤ G2 for all t ∈ [T] and X ∈ F. For Xt generated using the
ADAB OUND algorithm, we have the following bound on the regret
RT ≤
« X η-,1i+
D∞
2(1 - βι)
_T_ _ d_	R 尸2
XXβιtη-i1 + (2√T - 1)R∞⅞.
t=1 i=1	1 - β1
18
Published as a conference paper at ICLR 2019
Algorithm 3 AMSBOUND
Input: x1 ∈ F, initial step size α, {β1t}tT=1, β2, lower bound function ηl, upper bound function ηu
1:	Set mo = 0, vo = 0 and Vo = 0
2:	for t = 1 to T do
3:	gt = Vft(Xt)
4:	mt = β1tmt-1 + (1 - β1t)gt
5:	vt = β2vt-1 + (1 - β2)gt2
6:	Vt = max(Vt-ι,vt) and Vt = diag(Vt)
7： η = ciip(α∕√¼, ηι (t), ηu(t)) and η = η∕√t
8:	xt+1 = ΠF,diag(ηt-1) (xt -ηt	mt)
9:	end for
The regret of AMSBound has the same upper bound with that of AdaBound.3
G Empirical S tudy on B ound Functions
Here we provide an empirical study on different kinds of bound functions. We consider the following
two key factors of the bound function: convergence speed and convergence target. The former one
affects how “fast” our algorithms transform from adaptive methods to Sgd(M), while the latter one
reflects the final step size of Sgd(M). In particular, we consider the following bound functions:
ηl⑻= (I- (1 - β)t + 1 )α*,
ηu⑴=(I+ "> )α*,
where the above functions will converge to a* and the larger β results in lower convergence speed.
5 0 5 0 5 0
9 9 B B 7 7
* Λ3eJn33ys8,L
0 5 0 5 0 5 0
9 B B 7 7 6 6
* X3ejn33vS81
(a) AdaBound with α = 0.1	(b) AdaBound with a = 1
Figure 5: Test accuracy of ADABOUND with different β using ResNet-34 on CIFAR-10.
We first investigate the impact of convergence speed. We conduct an experiment of AdaBound on
CIFAR-10 dataset with the ResNet-34 model, where β is chosen in {1 - ⅛，1 - 50，1 -忐，1 -
51o, 1 一 1000} and a* is chosen from {1,0.1}. The results are shown in Figure 5. We can see
that for a specific a*, the performances with different β are almost the same . It indicates that the
convergence speed of bound functions does not affect the final result to some extent. We find a β in
[β1 , β2] usually contributes to a strong performance across all models.
Next, we investigate the impact of convergence target and the results are displayed in Figure 6. We
test SGDM and ADABOUND with different α (or a*) with the ResNet-34 model, where α (or a")
is chosen in {1, 0.1, 0.03, 0.01, 0.003, 0.001} and β = 0.99. The results show that SGDM is very
sensitive to the hyperparameter. The best value of the step size for SGDM is 0.1 and it has large
performance gaps compared with other settings. In contrast, AdaBound has stable performance in
different final step sizes, which illustrates that it is not sensitive to the convergence target.
3One may refer to Appendix E as the process of the proof is almost the same.
19
Published as a conference paper at ICLR 2019
(a) SGDM with different α
(b) ADABOUND With different a
Figure 6: Test accuracy of SgdM/ADABOUND with different a∕α* using ResNet-34 on CIFAR-10.
The result of SGDM With α = 1 is not shown above as its performance is too poor (lower than 70%)
to be plotted together with other results in a single figure.
*A9en∞γ-səF
*A9en∞γ-səF
*A9en∞γ-səF
a-0.03
*Λuenu9γ~8F
*Λuenu9γ~8F
*Λuenu9γ~8F
0	50	100	150	200	0	50	100	150	200	0	50	100	150	200
Epoch	Epoch	Epoch
Figure 7: Comparison of test accuracy between SGDM and AdaBound with different ɑ/ɑ*.
We further directly compare the performance between SGDM and AdaBound with each α (or a*).
The results are shown in Figure 7. We can see that AdaBound outperforms SgdM for all the step
sizes. Since the form of bound functions has minor impact on the performance of AdaBound, it is
likely to beat SgdM even without carefully tuning the hyperparameters.
To summarize, the form of bound functions does not much influence the final performance of the
methods. In other words, AdaBound is not sensitive to its hyperparameters. Moreover, it can
achieve a higher or similar performance to SgdM even ifitis not carefully fine-tuned. Therefore, we
can expect a better performance by using AdaBound regardless of the choice of bound functions.
H Empirical Study on The Evolution of Learning Rates over Time
Here we provide an empirical study on the evolution of learning rates of AdaBound over time.
We conduct an experiment using ResNet-34 model on CIFAR-10 dataset with the same settings in
Section 5. We randomly choose two layers in the network. For each layer, the learning rates of its
parameters are recorded at each time step. We pick the min/median/max values of the learning rates
in each layer and plot them against epochs in Figure 8.
We can see that the learning rates increase rapidly in the early stage of training, then after a few
epochs its max/median values gradually decrease over time, and finally converge to the final step
size. The increasing at the beginning is due to the property of the exponential moving average of φt
of Adam, while the gradually decreasing indicates the transition from Adam to Sgd.
20
Published as a conference paper at ICLR 2019
Figure 8: The evolution of learning rates over time in two randomly chosen layers.
21