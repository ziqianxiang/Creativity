Published as a conference paper at ICLR 2019
Preferences Implicit in the State of the World
Rohin Shah * t
UC Berkeley
Dmitrii Krasheninnikov * * t ^
University of Amsterdam
Jordan Alexander t ^
Stanford University
Pieter Abbeel
UC Berkeley
Anca D. Dragan
UC Berkeley
Ab stract
Reinforcement learning (RL) agents optimize only the features specified in a reward
function and are indifferent to anything left out inadvertently. This means that we
must not only specify what to do, but also the much larger space of what not to do.
It is easy to forget these preferences, since these preferences are already satisfied
in our environment. This motivates our key insight: when a robot is deployed in an
environment that humans act in, the state of the environment is already optimized
for what humans want. We can therefore use this implicit preference information
from the state to fill in the blanks. We develop an algorithm based on Maximum
Causal Entropy IRL and use it to evaluate the idea in a suite of proof-of-concept
environments designed to show its properties. We find that information from the
initial state can be used to infer both side effects that should be avoided as well as
preferences for how the environment should be organized. Our code can be found
at https://github.com/HumanCompatibleAI/rlsp.
1	Introduction
Deep reinforcement learning (deep RL) has been shown to succeed at a wide variety of complex
tasks given a correctly specified reward function. Unfortunately, for many real-world tasks it can be
challenging to specify a reward function that captures human preferences, particularly the preference
for avoiding unnecessary side effects while still accomplishing the goal (Amodei et al., 2016). As a
result, there has been much recent work (Christiano et al., 2017; Fu et al., 2017; Sadigh et al., 2017)
that aims to learn specifications for tasks a robot should perform.
Typically when learning about what people want and don’t want, we look to human action as evidence:
what reward they specify (Hadfield-Menell et al., 2017), how they perform a task (Ziebart et al.,
2010; Fu et al., 2017), what choices they make (Christiano et al., 2017; Sadigh et al., 2017), or how
they rate certain options (Daniel et al., 2014). Here, we argue that there is an additional source of
information that is potentially rather helpful, but that we have been ignoring thus far:
The key insight of this paper is that when a robot is deployed in an environment
that humans have been acting in, the state of the environment is already optimized
for what humans want.
For example, consider an environment in which a household robot must navigate to a goal location
without breaking any vases in its path, illustrated in Figure 1. The human operator, Alice, asks the
robot to go to the purple door, forgetting to specify that it should also avoid breaking vases along the
way. However, since the robot has been deployed in a state that only contains unbroken vases, it can
infer that while acting in the environment (prior to robot’s deployment), Alice was using one of the
relatively few policies that do not break vases, and so must have cared about keeping vases intact.
* equal contribution
*rohinmshah@berkeley.edu, dmitrii.krasheninnikov@student.uva.nl,
jfalex@stanford.edu
^ work done at UC Berkeley
1
Published as a conference paper at ICLR 2019
Figure 1: An illustration of learning preferences from an initial state. Alice attempts to accomplish a
goal in an environment with an easily breakable vase in the center. The robot observes the state of
the environment, so, after Alice has acted for some time from an even earlier state s-τ. It considers
multiple possible human reward functions, and infers that states where vases are intact usually occur
when Alice,s reward penalizes breaking vases. In contrast, it doesn,t matter much what the reward
function says about carpets, as we would observe the same final state either way. Note that while we
consider a specific s-T for clarity here, the robot could also reason using a distribution over s-T.
The initial state s0 can contain information about arbitrary preferences, including tasks that the robot
should actively perform. For example, if the robot observes a basket full of apples near an apple
tree, it can reasonably infer that Alice wants to harvest apples. However, s0 is particularly useful for
inferring which side effects humans care about. Recent approaches avoid unnecessary side effects by
penalizing changes from an inaction baseline (Krakovna et al., 2018; Turner, 2018). However, this
penalizes all side effects. The inaction baseline is appealing precisely because the initial state has
already been optimized for human preferences, and action is more likely to ruin s0 than inaction. If
our robot infers preferences from s0, it can avoid negative side effects while allowing positive ones.
This work is about highlighting the potential of this observation, and as such makes unrealistic
assumptions, such as known dynamics and hand-coded features. Given just s0, these assumptions are
necessary: without dynamics, it is hard to tell whether some feature of s0 was created by humans or
not. Nonetheless, we are optimistic that these assumptions can be relaxed, so that this insight can be
used to improve deep RL systems. We suggest some approaches in our discussion.
Our contributions are threefold. First, we identify the state of the world at initialization as a source
of information about human preferences. Second, we leverage this insight to derive an algorithm,
Reward Learning by Simulating the Past (RLSP), which infers reward from initial state based on a
Maximum Causal Entropy (Ziebart et al., 2010) model of human behavior. Third, we demonstrate the
properties and limitations of RLSP on a suite of proof-of-concept environments: we use it to avoid
side effects, as well as to learn implicit preferences that require active action. In Figure 1 the robot
moves to the purple door without breaking the vase, despite the lack of a penalty for breaking vases.
2	Related work
Preference learning. Much recent work has learned preferences from different sources of data,
such as demonstrations (Ziebart et al., 2010; Ramachandran and Amir, 2007; Ho and Ermon, 2016;
Fu et al., 2017; Finn et al., 2016), comparisons (Christiano et al., 2017; Sadigh et al., 2017; Wirth
et al., 2017), ratings (Daniel et al., 2014), human reinforcement signals (Knox and Stone, 2009;
Warnell et al., 2017; MacGlashan et al., 2017), proxy rewards (Hadfield-Menell et al., 2017), etc. We
suggest preference learning with a new source of data: the state of the environment when the robot is
first deployed. It can also be seen as a variant of Maximum Causal Entropy Inverse Reinforcement
Learning (Ziebart et al., 2010): while inverse reinforcement learning (IRL) requires demonstrations,
or at least state sequences without actions (Edwards et al., 2018; Yu et al., 2018), we learn a reward
function from a single state, albeit with the simplifying assumption of known dynamics. This can
also be seen as an instance of IRL from summary data (KangaSraaSio and Kaski, 2018).
2
Published as a conference paper at ICLR 2019
Frame properties. The frame problem in AI (McCarthy and Hayes, 1981) refers to the issue that we
must specify what stays the same in addition to what changes. In formal verification, this manifests as
a requirement to explicitly specify the many quantities that the program does not change (Andreescu,
2017). Analogously, rewards are likely to specify what to do (the task), but may forget to say what
not to do (the frame properties). One of our goals is to infer frame properties automatically.
Side effects. An impact penalty can mitigate reward specification problems, since it penalizes
unnecessary “large” changes (Armstrong and Levinstein, 2017). We could penalize a reduction in the
number of reachable states (Krakovna et al., 2018) or attainable utility (Turner, 2018). However, such
approaches will penalize all irreversible effects, including ones that humans want. In contrast, by
taking a preference inference approach, we can infer which effects humans care about.
Goal states as specifications. Desired behavior in RL can be specified with an explicitly chosen goal
state (Kaelbling, 1993; Schaul et al., 2015; Nair et al., 2018; Bahdanau et al., 2018; Andrychowicz
et al., 2017). In our setting, the robot observes the initial state s0 where it starts acting, which is not
explicitly chosen by the designer, but nonetheless contains preference information.
3	Preliminaries
A finite-horizon Markov decision process (MDP) is a tuple M = hS, A, T, r, Ti, where S is the
set of states, A is the set of actions, T : S × A × S 7→ [0, 1] is the transition probability function,
r : S 7→ R is the reward function, and T ∈ Z+ is the finite planning horizon. We consider MDPs
where the reward is linear in features, and does not depend on action: r(s; θ) = θT f (s), where θ are
the parameters defining the reward function and f computes features of a given state.
Inverse Reinforcement Learning (IRL). In IRL, the aim is to infer the reward function r given
an MDP without reward M\r and expert demonstrations D = {τ1 , ..., τn}, where each τi =
(s0, a0, ..., sT, aT) is a trajectory sampled from the expert policy acting in the MDP. It is assumed
that each τi is feasible, so that T (sj+1 | sj , aj ) > 0 for every j .
Maximum Causal Entropy IRL (MCEIRL). As human demonstrations are rarely optimal, Ziebart
et al. (2010) models the expert as a Boltzmann-rational agent that maximizes total reward and causal
entropy of the policy. This leads to the policy πt(a | s, θ) = exp(Qt(s, a; θ) - Vt(s; θ)), where
Vt(s; θ) = ln Pa exp(Qt(s, a; θ)) plays the role of a normalizing constant. Intuitively, the expert
is assumed to act close to randomly when the difference in expected total reward across the actions
is small, but nearly always chooses the best action when it leads to a substantially higher expected
return. The soft Bellman backup for the state-action value function Q is the same as usual, and is
given by Qt(s, a; θ) = θTf(s) + Ps0 T(s0 | s, a)Vt+1(s0; θ).
The likelihood of a trajectory τ given the reward parameters θ is:
p(τ |	θ)	=	p(s0)	T (st+1	|	st, at)πt(at	|	st, θ)	πT (aT	| sT, θ).	(1)
t=0
MCEIRL finds the reward parameters θ* that maximize the log-likelihood of the demonstrations:
θ* = argmaxθ lnP(D | θ) = argmaxg ΣΣln πt(ai,t | si,t, θ).	(2)
θ* gives rise to a policy whose feature expectations match those of the expert demonstrations.
4 Reward Learning by S imulating the Past
We solve the problem of learning the reward function of an expert Alice given a single final state of
her trajectory; we refer to this problem as IRL from a single state. Formally, we aim to infer Alice’s
reward θ given an environment M\r and the last state of the expert’s trajectory s0 .
Formulation. To adapt MCEIRL to the one state setting we modify the observation model from
Equation 1. Since we only have a single end state s0 of the trajectory τ0 = (s-T , a-T , ..., s0, a0),
we marginalize over all of the other variables in the trajectory:
p(s0 | θ) =	X	p(τ0 | θ),	(3)
s-T,a-T,...s-1,a-1,a0
3
Published as a conference paper at ICLR 2019
where p(τ0 | θ) is given in Equation 1. We could invert this and sample from p(θ | s0); the resulting
algorithm is presented in Appendix C, but is relatively noisy and slow. We instead find the MLE:
θ* = argmaxθ lnp(so | θ).	(4)
Solution. Similarly to MCEIRL, we use a gradient ascent algorithm to solve the IRL from one state
problem. We explain the key steps here and give the full derivation in Appendix B. First, we express
the gradient in terms of the gradients of trajectories:
Vθ lnp(so | θ) = E p(τ-τ：-i | so,θ)Vθ lnp(τ-ro | θ).
τ-T :-1
This has a nice interpretation - compute the Maximum Causal Entropy gradients for each trajectory,
and then take their weighted sum, where each weight is the probability of the trajectory given
the evidence s0 and current reward θ. We derive the exact gradient for a trajectory instead of the
approximate one in Ziebart et al. (2010) in Appendix A and substitute it in to get:
-1
Vθ lnp(S0)
-1
Σ7-) X	P(T-T:-1, SO) X f (St) + Est+1 [Ft+1(st+1)]-
p(s0 ) τ	t T
τ-T :-1
t=-T
Ft(St)
, (5)
where we have suppressed the dependence on θ for readability. Ft (St) denotes the expected features
when starting at St at time t and acting until time 0 under the policy implied by θ.
Since we combine gradients from simulated past trajectories, we name our algorithm Reward Learning
by Simulating the Past (RLSP). The algorithm computes the gradient using dynamic programming,
detailed in Appendix B. We can easily incorporate a prior on θ by adding the gradient of the log prior
to the gradient in Equation 5.
5 Evaluation
Evaluation of RLSP is non-trivial. The inferred reward is very likely to assign state S0 maximal
reward, since it was inferred under the assumption that when Alice optimized the reward she ended
up at S0. If the robot then starts in state S0, if a no-op action is available (as it often is), the RLSP
reward is likely to incentivize no-ops, which is not very interesting.
Ultimately, we hope to use RLSP to correct badly specified instructions or reward functions. So, we
created a suite of environments with a true reward Rtrue, a specified reward Rspec, Alice’s first state
S-T, and the robot’s initial state S0, where Rspec ignores some aspect(s) of Rtrue. RLSP is used to
infer a reward θAlice from S0, which is then combined with the specified reward to get a final reward
θfinal = θAlice + λθspec. (We considered another method for combining rewards; see Appendix D for
details.) We inspect the inferred reward qualitatively and measure the expected amount of true reward
obtained when planning with θfinal, as a fraction of the expected true reward from the optimal policy.
We tune the hyperparameter λ controlling the tradeoff between Rspec and the human reward for all
algorithms, including baselines. We use a Gaussian prior over the reward parameters.
5.1	Baselines
Specified reward policy πspec. We act as if the true reward is exactly the specified reward.
Policy that penalizes deviations πdeviation. This baseline minimizes change by penalizing deviations
from the observed features f (so), giving RfinaI(S) = θTpec∕(s) + λf (s) — f(so)∣∣.
Relative reachability policy πreachability. Relative reachability (Krakovna et al., 2018) considers a
change to be negative when it decreases coverage, relative to what would have happened had the
agent done nothing. Here, coverage is a measure of how easily states can be reached from the current
state. We compare against the variant of relative reachability that uses undiscounted coverage and a
baseline policy where the agent takes no-op actions, as in the original paper. Relative reachability
requires known dynamics but not a handcoded featurization. A version of relative reachability that
operates in feature space instead of state space would behave similarly.
4
Published as a conference paper at ICLR 2019
5.2	Comparison to baselines
We compare RLSP to our baselines with the assumption of known s-T, because it makes it easier to
analyze RLSP’s properties. We consider the case of unknown s-T in Section 5.3. We summarize the
results in Table 1, and show the environments and trajectories in Figure 2.
Table 1: Performance of algorithms on environments designed to test particular properties.
	Side effects Room	EnV effect Toy train	Implicit reward Apple collection	Desirable effect Batteries		Unseen effect Far away vase
				EaSy	Hard	
πspec	X	X	X	✓	X	X
πdeviation	✓	X	X	≈	X	✓
πreachability	✓	✓	X	≈	X	✓
πRLSP	J	J	J	J	J	X
seirotcejart PSLRπ
sdna s
seirotcejart cepsπ
Figure 2: Evaluation of RLSP on our environments. Silhouettes indicate the initial position of an
object or agent, while filled in version indicate their positions after an agent has acted. The first row
depicts the information given to RLSP. The second row shows the trajectory taken by the robot when
following the policy πspec that is optimal for θspec. The third row shows the trajectory taken when
following the policy πRLSP that is optimal for θfinal = θAlice + λθspec. (a) Side effects: Room with vase
(b) Distinguishing environment effects: Toy train (c) Implicit reward: Apple collection (d) Desirable
side effect: Batteries (e) “Unseen” side effect: Room with far away vase.
Side effects: Room with vase (Figure 2a). The room tests whether the robot can avoid breaking a
vase as a side effect of going to the purple door. There are features for the number of broken vases,
standing on a carpet, and each door location. Since Alice didn’t walk over the vase, RLSP infers a
negative reward on broken vases, and a small positive reward on carpets (since paths to the top door
usually involve carpets). So, πRLSP successfully avoids breaking the vase. The penalties also achieve
5
Published as a conference paper at ICLR 2019
the desired behavior: πdeviation avoids breaking the vase since it would change the “number of broken
vases” feature, while relative reachability avoids breaking the vase since doing so would result in all
states with intact vases becoming unreachable.
Distinguishing environment effects: Toy train (Figure 2b). To test whether algorithms can distin-
guish between effects caused by the agent and effects caused by the environment, as suggested in
Krakovna et al. (2018), we add a toy train that moves along a predefined track. The train breaks if the
agent steps on it. We add a new feature indicating whether the train is broken and new features for
each possible train location. As before, the specified reward only has a positive weight on the purple
door, while the true reward also penalizes broken trains and vases.
RLSP infers a negative reward on broken vases and broken trains, for the same reason as before. It
also infers not to put any weight on any particular train location, even though it changes frequently,
because it doesn’t help explain s0. As a result, πRLSP walks over a carpet, but not a vase or a train.
πdeviation immediately breaks the train to keep the train location the same. πreachability deduces that
breaking the train is irreversible, and so follows the same trajectory as πRLSP.
Implicit reward: Apple collection (Figure 2d). This environment tests whether the algorithms can
learn tasks implicit in s0 . There are three trees that grow apples, as well as a basket for collecting
apples, and the goal is for the robot to harvest apples. However, the specified reward is zero: the robot
must infer the task from the observed state. We have features for the number of apples in baskets, the
number of apples on trees, whether the robot is carrying an apple, and each location that the agent
could be in. s0 has two apples in the basket, while s-T has none.
πspec is arbitrary since every policy is optimal for the zero reward. πdeviation does nothing, achieving
zero reward, since its reward can never be positive. πreachability also does not harvest apples. RLSP
infers a positive reward on apples in baskets, a negative reward for apples on trees, and a small
positive reward for carrying apples. Despite the spurious weights, πRLSP harvests apples as desired.
Desirable side effect: Batteries (Figure 2c). This environment tests whether the algorithms can tell
when a side effect is allowed. We take the toy train environment, remove vases and carpets, and add
batteries. The robot can pick up batteries and put them into the (now unbreakable) toy train, but
the batteries are never replenished. If the train runs for 10 timesteps without a new battery, it stops
operating. There are features for the number of batteries, whether the train is operational, each train
location, and each door location. There are two batteries at s-T but only one at s0. The true reward
incentivizes an operational train and being at the purple door. We consider two variants for the task
reward - an “easy” case, where the task reward equals the true reward, and a “hard” case, where the
task reward only rewards being at the purple door.
Unsurprisingly, πspec succeeds at the easy case, and fails on the hard case by allowing the train to
run out of power. Both πdeviation and πreachability see the action of putting a battery in the train as a side
effect to be penalized, and so neither can solve the hard case. They penalize picking up the batteries,
and so only solve the easy case if the penalty weight is small. RLSP sees that one battery is gone
and that the train is operational, and infers that Alice wants the train to be operational and doesn’t
want batteries (since a preference against batteries and a preference for an operational train are nearly
indistinguishable). So, it solves both the easy and the hard case, with πRLSP picking up the battery,
then staying at the purple door except to deliver the battery to the train.
“Unseen” side effect: Room with far away vase (Figure 2e). This environment demonstrates a
limitation of our algorithm: it cannot identify side effects that Alice would never have triggered. In
this room, the vase is nowhere close to the shortest path from the Alice’s original position to her
goal, but is on the path to the robot’s goal. Since our baselines don’t care about the trajectory the
human takes, they all perform as before: πspec walks over the vase, while πdeviation and πreachability both
avoid it. Our method infers a near zero weight on the broken vase feature, since it is not present on
any reasonable trajectory to the goal, and so breaks it when moving to the goal. Note that this only
applies when Alice is known to be at the bottom left corner at s-T: if we have a uniform prior over
s-T (considered in Section 5.3) then we do consider trajectories where vases are broken.
5.3	COMPARISON BETWEEN KNOWING s-T VS. A DISTRIBUTION OVER s-T
So far, we have considered the setting where the robot knows s-T, since it is easier to analyze what
happens. However, typically we will not know s-T, and will instead have some prior over s-T. Here,
6
Published as a conference paper at ICLR 2019
we compare RLSP in two settings: perfect knowledge of s-T (as in Section 5.2), and a uniform
distribution over all states.
Side effects: Room with vase (Figure 2a) and toy train (Figure 2b). In both room with vase and
toy train, RLSP learns a smaller negative reward on broken vases when using a uniform prior. This is
because RLSP considers many more feasible trajectories when using a uniform prior, many of which
do not give Alice a chance to break the vase, as in Room with far away vase in Section 5.2. In room
with vase, the small positive reward on carpets changes to a near-zero negative reward on carpets.
With known s-T , RLSP overfits to the few consistent trajectories, which usually go over carpets,
whereas with a uniform prior it considers many more trajectories that often don’t go over carpets, and
so it correctly infers a near-zero weight. In toy train, the negative reward on broken trains becomes
slightly more negative, while other features remain approximately the same. This may be because
when Alice starts out closer to the toy train, she has more of an opportunity to break it, compared to
the known s-T case.
Implicit preference: Apple collection (Figure 2d). Here, a uniform prior leads to a smaller positive
weight on the number of apples in baskets compared to the case with known s-T . Intuitively, this is
because RLSP is considering cases where s-T already has one or two apples in the basket, which
implies that Alice has collected fewer apples and so must have been less interested in them. States
where the basket starts with three or more apples are inconsistent with the observed s0 and so are not
considered. Following the inferred reward still leads to good apple harvesting behavior.
Desirable side effects: Batteries (Figure 2c). With the uniform prior, we see the same behavior as
in Apple collection, where RLSP with a uniform prior learns a slightly smaller negative reward on
the batteries, since it considers states s-T where the battery was already gone. In addition, due to the
particular setup the battery must have been given to the train two timesteps prior, which means that in
any state where the train started with very little charge, it was allowed to die even though a battery
could have been provided before, leading to a near-zero positive weight on the train losing charge.
Despite this, RLSP successfully delivers the battery to the train in both easy and hard cases.
“Unseen” side effect: Room with far away vase (Figure 2e). With a uniform prior, we “see” the
side effect: if Alice started at the purple door, then the shortest trajectory to the black door would
break a vase. As a result, πRLSP successfully avoids the vase (whereas it previously did not). Here,
uncertainty over the initial state s-T can counterintuitively improve the results, because it increases
the diversity of trajectories considered, which prevents RLSP from “overfitting” to the few trajectories
consistent with a known s-T and s0 .
Overall, RLSP is quite robust to the use of a uniform prior over s-T, suggesting that we do not need
to be particularly careful in the design of that prior.
5.4	Robustness to the choice of Alice’ s planning horizon
We investigate how RLSP performs when assuming the wrong value of Alice’s planning horizon
T . We vary the value of T assumed by RLSP, and report the true return achieved by πRLSP obtained
using the inferred reward and a fixed horizon for the robot to act. For this experiment, we used a
uniform prior over s-T, since with known s-T, RLSP often detects that the given s-T and s0 are
incompatible (when T is misspecified). The results are presented in Figure 3.
The performance worsens when RLSP assumes that Alice had a
smaller planning horizon than she actually had. Intuitively, if we
assume that Alice has only taken one or two actions ever, then even
if we knew the actions they could have been in service of many
goals, and so we end up quite uncertain about Alice’s reward.
When the assumed T is larger than the true horizon, RLSP correctly
infers things the robot should not do. Knowing that the vase was not
broken for longer than T timesteps is more evidence to suspect that
Alice cared about not breaking the vase. However, overestimated
T leads to worse performance at inferring implicit preferences, as
in the Apples environment. If we assume Alice has only collected
two apples in 100 timesteps, she must not have cared about them
much, since she could have collected many more. The batteries
Figure 3: Reward achieved by
πRLSP, as a fraction of the ex-
pected reward of the optimal
policy, for different values of
Alice’s planning horizon T .
7
Published as a conference paper at ICLR 2019
environment is unusual - assuming that Alice has been acting for 100 timesteps, the only explanation
for the observed s0 is that Alice waited until the 98th timestep to put the battery into the train. This is
not particularly consistent with any reward function, and performance degrades.
Overall, T is an important parameter and needs to be set appropriately. However, even when T is
misspecified, performance degrades gracefully to what would have happened if we optimized θspec by
itself, so RLSP does not hurt. In addition, if T is larger than it should be, then RLSP still tends to
accurately infer parts of the reward that specify what not to do.
6	Limitations and future work
Summary. Our key insight is that when a robot is deployed, the state that it observes has already
been optimized to satisfy human preferences. This explains our preference for a policy that generally
avoids side effects. We formalized this by assuming that Alice has been acting in the environment
prior to the robot’s deployment. We developed an algorithm, RLSP, that computes a MAP estimate of
Alice’s reward function. The robot then acts according to a tradeoff between Alice’s reward function
and the specified reward function. Our evaluation showed that information from the initial state can
be used to successfully infer side effects to avoid as well as tasks to complete, though there are cases
in which we cannot infer the relevant preferences. While we believe this is an important step forward,
there is still much work to be done to make this accurate and practical.
Realistic environments. The primary avenue for future work is to scale to realistic environments,
where we cannot enumerate states, we don’t know dynamics, and the reward function may be
nonlinear. This could be done by adapting existing IRL algorithms (Fu et al., 2017; Ho and Ermon,
2016; Finn et al., 2016). Unknown dynamics is particularly challenging, since we cannot learn
dynamics from a single state observation. While acting in the environment, we would have to learn
a dynamics model or an inverse dynamics model that can be used to simulate the past, and update
the learned preferences as our model improves over time. Alternatively, if we use unsupervised skill
learning (Achiam et al., 2018; Eysenbach et al., 2018; Nair et al., 2018) or exploration (Burda et al.,
2018), or learn a goal-conditioned policy (Schaul et al., 2015; Andrychowicz et al., 2017), we could
compare the explored states with the observed s0 .
Hyperparameter choice. While our evaluation showed that RLSP is reasonably robust to the choice
of planning horizon T and prior over s-T, this may be specific to our gridworlds. In the real world,
we often make long term hierarchical plans, and if we don’t observe the entire plan (corresponding to
a choice of T that is too small) it seems possible that we infer bad rewards, especially if we have an
uninformative prior over s-T. We do not know whether this will be a problem, and if so how bad it
will be, and hope to investigate it in future work with more realistic environments.
Conflicts between θspec and θAlice. RLSP allows us to infer θAlice from s0, which we must somehow
combine with θspec to produce a reward θfinal for the robot to optimize. θAlice will usually prefer the
status quo of keeping the state similar to s0, while θspec will probably incentivize some change to
the state, leading to conflict. We traded off between the two by optimizing their sum, but future
work could improve upon this. For example, θAlice could be decomposed into θAlice,task, which says
which task Alice is performing (“go to the black door”), and θframe, which consists of the frame
conditions (“don’t break vases”). The robot then optimizes θframe + λθspec. This requires some way of
performing the decomposition. We could model the human as pursuing multiple different subgoals,
or the environment as being created by multiple humans with different goals. θframe would be shared,
while θtask would vary, allowing us to distinguish between them. However, combination may not
be the answer - instead, perhaps the robot ought to use the inferred reward to inform Alice of any
conflicts and actively query her for more information, along the lines of Amin et al. (2017).
Learning tasks to perform. The apples and batteries environments demonstrate that RLSP can learn
preferences that require the robot to actively perform a task. It is not clear that this is desirable, since
the robot may perform an inferred task instead of the task Alice explicitly sets for it.
Preferences that are not a result of human optimization. While the initial state is optimized for
human preferences, this may not be a result of human optimization, as assumed in this paper. For
example, we prefer that the atmosphere contain oxygen for us to breathe. The atmosphere meets this
preference in spite of human action, and so RLSP would not infer this preference. While this is of
limited relevance for household robots, it may become important for more capable AI systems.
8
Published as a conference paper at ICLR 2019
Acknowledgments
We thank the researchers at the Center for Human Compatible AI for valuable feedback. This work
was supported by the Open Philanthropy Project, AFOSR, and National Science Foundation Graduate
Research Fellowship Grant No. DGE 1752814.
References
Joshua Achiam, Harrison Edwards, Dario Amodei, and Pieter Abbeel. Variational option discovery
algorithms. arXiv preprint arXiv:1807.10299, 2018.
Kareem Amin, Nan Jiang, and Satinder Singh. Repeated inverse reinforcement learning. In Advances
in Neural Information Processing Systems, pages 1815-1824, 2017.
Dario Amodei, Chris Olah, Jacob Steinhardt, Paul Christiano, John Schulman, and Dan Mane.
Concrete problems in ai safety. arXiv preprint arXiv:1606.06565, 2016.
Oana Fabiana Andreescu. Static analysis of functional programs with an application to the frame
problem in deductive verification. PhD thesis, Rennes 1, 2017.
Marcin Andrychowicz, Filip Wolski, Alex Ray, Jonas Schneider, Rachel Fong, Peter Welinder, Bob
McGrew, Josh Tobin, Pieter Abbeel, and Wojciech Zaremba. Hindsight experience replay. In
Advances in Neural Information Processing Systems, pages 5048-5058, 2017.
Stuart Armstrong and Benjamin Levinstein. Low impact artificial intelligences. arXiv preprint
arXiv:1705.10720, 2017.
Dzmitry Bahdanau, Felix Hill, Jan Leike, Edward Hughes, Pushmeet Kohli, and Edward Grefenstette.
Learning to understand goal specifications by modelling reward. arXiv preprint arXiv:1806.01946,
2018.
Yuri Burda, Harri Edwards, Deepak Pathak, Amos Storkey, Trevor Darrell, and Alexei A Efros.
Large-scale study of curiosity-driven learning. arXiv preprint arXiv:1808.04355, 2018.
Paul F Christiano, Jan Leike, Tom Brown, Miljan Martic, Shane Legg, and Dario Amodei. Deep
reinforcement learning from human preferences. In Advances in Neural Information Processing
Systems, pages 4299-4307, 2017.
Christian Daniel, Malte Viering, Jan Metz, Oliver Kroemer, and Jan Peters. Active reward learning.
In Robotics: Science and Systems, 2014.
Ashley D Edwards, Himanshu Sahni, Yannick Schroeker, and Charles L Isbell. Imitating latent
policies from observation. arXiv preprint arXiv:1805.07914, 2018.
Benjamin Eysenbach, Abhishek Gupta, Julian Ibarz, and Sergey Levine. Diversity is all you need:
Learning skills without a reward function. arXiv preprint arXiv:1802.06070, 2018.
Chelsea Finn, Sergey Levine, and Pieter Abbeel. Guided cost learning: Deep inverse optimal control
via policy optimization. In International Conference on Machine Learning, pages 49-58, 2016.
Justin Fu, Katie Luo, and Sergey Levine. Learning robust rewards with adversarial inverse reinforce-
ment learning. arXiv preprint arXiv:1710.11248, 2017.
Dylan Hadfield-Menell, Smitha Milli, Pieter Abbeel, Stuart J Russell, and Anca Dragan. Inverse
reward design. In Advances in Neural Information Processing Systems, pages 6765-6774, 2017.
Jonathan Ho and Stefano Ermon. Generative adversarial imitation learning. In Advances in Neural
Information Processing Systems, pages 4565-4573, 2016.
Leslie Pack Kaelbling. Learning to achieve goals. In IJCAI, pages 1094-1099. Citeseer, 1993.
Antti KangaSraaSio and Samuel Kaski. Inverse reinforcement learning from summary data. Machine
Learning, 107(8-10):1517-1535, 2018.
9
Published as a conference paper at ICLR 2019
W Bradley Knox and Peter Stone. Interactively shaping agents via human reinforcement: The tamer
framework. In Proceedings ofthe fifth international conference on KnoWledge capture, pages 9-16.
ACM, 2009.
Victoria Krakovna, Laurent Orseau, Miljan Martic, and Shane Legg. Measuring and avoiding side
effects using relative reachability. arXiv preprint arXiv:1806.01186, 2018.
James MacGlashan, Mark K Ho, Robert Loftin, Bei Peng, David Roberts, Matthew E Taylor, and
Michael L Littman. Interactive learning from policy-dependent human feedback. arXiv preprint
arXiv:1701.06049, 2017.
John McCarthy and Patrick J Hayes. Some philosophical problems from the standpoint of artificial
intelligence. In Readings in artificial intelligence, pages 431-450. Elsevier, 1981.
Ashvin Nair, Vitchyr Pong, Murtaza Dalal, Shikhar Bahl, Steven Lin, and Sergey Levine. Visual
reinforcement learning with imagined goals. arXiv preprint arXiv:1807.04742, 2018.
Deepak Ramachandran and Eyal Amir. Bayesian inverse reinforcement learning. Urbana, 51(61801):
1-4, 2007.
Dorsa Sadigh, Anca Dragan, Shankar Sastry, and Sanjit A Seshia. Active preference-based learning
of reward functions. In Robotics: Science and Systems (RSS), 2017.
Tom Schaul, Daniel Horgan, Karol Gregor, and David Silver. Universal value function approximators.
In International Conference on Machine Learning, pages 1312-1320, 2015.
Alex Turner. Towards a new impact measure, 2018. https://www.alignmentforum.org/
posts/yEa7kwoMpsBgaBCgb/towards-a-new-impact-measure, Last accessed on
2018-09-26.
Garrett Warnell, Nicholas Waytowich, Vernon Lawhern, and Peter Stone. Deep tamer: Interactive
agent shaping in high-dimensional state spaces. arXiv preprint arXiv:1709.10163, 2017.
Christian Wirth, Riad Akrour, Gerhard Neumann, and Johannes Furnkranz. A Survey of Preference-
Based Reinforcement Learning Methods. Journal of Machine Learning Research, 18(136):1-46,
2017. ISSN 15337928. doi: 10.1109/CIS.2008.204. URL http://jmlr.org/papers/
v18/16-634.html.
Tianhe Yu, Chelsea Finn, Annie Xie, Sudeep Dasari, Tianhao Zhang, Pieter Abbeel, and Sergey
Levine. One-shot imitation from observing humans via domain-adaptive meta-learning. arXiv
preprint arXiv:1802.01557, 2018.
Brian D Ziebart, J Andrew Bagnell, and Anind K Dey. Modeling interaction via the principle of
maximum causal entropy. 2010.
10
Published as a conference paper at ICLR 2019
A
Here, we derive an exact gradient for the maximum causal entropy distribution introduced in Ziebart
et al. (2010), as the existing approximation is insufficient for our purposes. Given a trajectory
TT = soao ... STaτ, We seek the gradient Vθ lnp(ττ). We assume that the expert has been acting
according to the maximum causal entropy IRL model given in Section 3 (where we have dropped θ
from the notation for clarity):
πt(a | s) = exp(Qt(s, a) - Vt(s)),
Vt(s) = ln	exp(Qt(s, a))
a
Qt(s,a) = θTf (s) +XT(s0 | s,a)Vt+1(s0)
s0
VT+1 (s) = 0.
for 1 ≤ t ≤ T,
for 1 ≤ t ≤ T,
In the folloWing, unless otherWise specified, all expectations over states and actions use the probability
distribution over trajectories from the above model, starting from the state and action just prior. For
example, Es0T,a0T [X(s0T,a0T)] = Ps0 ,a0 T (s0T | sT-1,aT-1)πT(a0T | s0T)X(s0T,a0T). In addition,
for all probability distributions over states and actions, We drop the dependence on θ for readability,
so the probability of reaching state sT is Written as p(sT) instead of p(sT | θ).
First, We compute the gradient of Vt(s). We have VθVT+1(s) = 0, and for 0 ≤ t ≤ T:
VθVt(st)
Vθ ln	exp(Qt(st, a0t))
a0t
1
exp(Vt(st))
exp(Qt(st,a0t))VθQt(st,a0t)
a0t
exp(V1⑶))X exP(Qt(St,at))vθ hθT f (st)+ Est+ι” (∙∣st,at) U+1(St+1)]]
a0t
=X exP(Qt(St,at) - Vt (st)) f (st) + Est+1 〜T (∙∣st ,at) [vθ Vt+1(st+1)]]
a0t
=X πt(at | st) [f (St)+ Es"T (∙∣st,at) [vθ Vt+1(st+1)]]
a0t
= f(st) + Ea0t,s0t+1 [vθVt+1(s0t+1)] .
Unrolling the recursion, We get that the gradient is the expected feature counts under the policy
implied by θ from st onWards, Which We could prove using induction. Define:
T
Ft(st) ≡ f(st) + Ea0t:T-1,s0t+1:T	X f (s0t0)
t0=t+1
Then We have:
vθVt(st) = Ft(st).
We can noW calculate the gradient We actually care about:
11
Published as a conference paper at ICLR 2019
Vθ lnP(TT)
T	T-1
= Vθ lnp(s0) +	ln πt (at | st) +	ln T (st+1 | st, at)
t=0	t=0
T
=	Vθ lnπt(at | st)	only πt depends on θ
t=0
T
=XVθ[Qt(st,at)-Vt(st)]
t=0
T
=XVθ θT f (st) + Es0t+1 Vt+1(s0t+1) - Vt(st)
t=0
T
=X f(st) + Es0t+1 VθVt+1(s0t+1) - VθVt(st) .
t=0
The last term of the summation is f(sT) + Es0 VθVT+1(s0T+1) - VθVT(sT), which simplifies
to f(sT) + 0 - FT(sT) = f(sT) - f(sT) = 0, so we can drop it. Thus, our gradient is:
T -1
Vθlnp(τT) = X f(st) + Es0t+1 Ft+1(s0t+1) -Ft(st) .	(6)
t=0
This is the gradient we will use in Appendix B, but a little more manipulation allows us to compare
with the gradient in Ziebart et al. (2010). We reintroduce the terms that we cancelled above:
Ft+1(s0t+1)	- F0(s0) + X Ft+1(st+1)
XTT-1
f(st) - F0(s0) + X Es0t+1 Ft+1(s0t+1) - Ft+1(st+1) .
t=0
Ziebart et al. (2010) states that the gradient is given by the expert policy feature expectations minus the
learned policy feature expectations, and in practice uses the feature expectations from demonstrations
to approximate the expert policy feature expectations. Assuming we have N trajectories {τi }, the
gradient would be (焉 Pi PL f (st,i)) - Es0 [F0(s0)]. The first term matches our first term
exactly. Our second term matches the second term in the limit of sufficiently many trajectories, so that
the starting states s0 follow the distributionp(s0). Our third term converges to zero with sufficiently
many trajectories, since any st , at pair in a demonstration will be present sufficiently often that the
empirical counts of st+ι will match the expected proportions prescribed by T(∙ | st,at).
In a deterministic environment, we have T (s0t+1 | st , at ) = 1[s0t+1 = st+1] since only one tran-
sition is possible. Thus, the third term is zero and even for one trajectory the gradient reduces
to PtT=0 f(st) - F0(s0). This differs from the gradient in Ziebart et al. (2010) only in that it
computes feature expectations from the observed starting state s0 instead of the MDP distribution
over initial states p(s0).
In a stochastic environment, the third term need not be zero, and corrects for the “bias” in the observed
states st+1. Intuitively, when the expert chose action at, she did not know which next state s0t+1
would arise, but the first term of our gradient upweights the particular next state st+1 that we observed.
The third term downweights the future value of the observed state and upweights the future value of
all other states, all in proportion to their prior probability T (s0t+1 | st, at).
12
Published as a conference paper at ICLR 2019
B
This section provides a derivation of the gradient Vθ lnp(s0), which is needed to solve
argmaxθ lnp(s0) with gradient ascent. We provide the results first as a quick reference:
Vθ lnp(so)
G0(s0)
P(so) ,
p(st+1) =	p(st)πt(at | st)T (st+1 | st, at),
st,at
Gt+1(st+1) =	T	(st+1	|	st, at)πt(at	|	st)	P(st)g(st, at) +	Gt(st)	,
st,at
g(st, at) ≡ f (st) + Es0t+1 Ft+1(s0t+1) - Ft(st),
Ft-1(st-1) = f(st-1) +	πt-1(a0t-1 | st-1)T (s0t | st-1, a0t-1)Ft(st).
a0t-1 ,s0t
Base cases: first, p(s-T ) is given, second, G-T (s-T ) = 0, and third, F0(s0) = f (s0).
For the derivation, we start by expressing the gradient in terms of gradients of trajectories, so that
we can use the result from Appendix A. Note that, by inspecting the final form of the gradient in
Appendix A, We can see that VP(T-T：o) is independent of a°. Then, We have:
1
Vθ lnp(s0)
p(s0)
1
Vθp(s0)
p(s0)
1
P(so)
E	Vθ P(T-Ts
s-T:-1,a-T:0
E	P(T-T：0)Vθ lnP(T-T：0)
s-T:-1,a-T:0
ɪʒ X	(P(T-T:-1, SO)Vθ lnP(T-T:O)(Xπ0(a0 | SO)))
0 s-T:-1,a-T:-1	a0
P(T-T:-1 | SO)Vθ lnP(T-T:O).
s-T:-1,a-T:-1
This has a nice interpretation - compute the gradient for each trajectory and take the weighted sum,
Where each Weight is the probability of the trajectory given the evidence s0 and current reWard θ.
We can reWrite the gradient in Equation 6 as Vθ ln p(τT) = PtT=-01 g(st, at), Where
g(st, at) ≡ f(st) + Es0t+1 Ft+1 (s0t+1) - Ft(st).
We can now substitute this to get:
Vθ lnP(SO)
P(T-T:-1 | SO)	g(St, at)
s-T:-1,a-T:-1
t=-T
P(SO)
Σ
s-T:-1,a-T:-1
-1
P(T-T:-1, SO)	g(St, at)
t=-T
P(SO)
Σ
s-T:-1,a-T:-1
-1
P(T-T:-1, SO)	g(St, at) .
t=-T
1
1
13
Published as a conference paper at ICLR 2019
Note that we can compute p(st) since we are given the distribution p(s-T) and we can use the
recursive rule p(st+1) = Pst,at p(st)πt(at | st)T (st+1 | st, at).
In order to compute g(st , at) we need to compute Ft (st), which has base case F0 (s0) = f (s0) and
recursive rule:
Ft-1(st-1)
0
=f(st-1)+Ea0t-1:-1,s0t:0	Xf(s0t0)
t0=t
f(st-1) + πt-1
a0t-1 ,s0t
f(st-1) + πt-1
a0t-1,s0t
(a0t-1 | st-1)T (s0t | st-1,a0t-1) f(s0t) +Ea
(a0t-1 | st-1)T (s0t | st-1,a0t-1)Ft(st).
0t:-1 ,s0t+1:0
X0 f(s0t0)
t0=t+1
For the remaining part of the gradient, define Gt such that Vθ lnp(so)
G0(s0):
P(SO) .
t-1
Gt(St) ≡	E	p(τ-τ：t-i,st) E g(StO,atO)
s-T:t-1,a-T:t-1	tO=-T
We now derive a recursive relation for G:
Gt+1 (St+1)
t
= E	p(τ-τ：t, st+ι) E g(StO,at0)
s-T:t,a-T:t	tO=-T
=	T(St+1 | St,at)∏t(at∣ St)P(T-T:t-i,st) g(st,at,st+ι)+ E g(st,at)
st,at s-T:t-1,a-T:t-1	tO=-T
T (St+1 | St, at)πt (at | St)
st,at
E	P(τ-T :t-l,st) g(st,at)
s-T:t-1,a-T:t-1
+ £ T(st+1 I st,at)∏t(at | St)	E	(P(T-T：t—i,St) E g(st,a#
st,at	s-T:t-1,a-T:t-1	tO=-T
T(St+1 | St, at)πt(at | St) P(St)g(St, at) + Gt(St)
st,at
For the base case, note that
G-T+1(S-T+1) =	[P(S-T, a-T, S-T +1)g(S-T, a-T, S-T+1)]
s-T,a-T
T(S-T+1 | S-T, a-T)π-T (a-T | S-T) P(S-T)g(S-T, a-T, S-T+1) .
s-T,a-T
Comparing this to the recursive rule, for the base case we can set G-T (S-T) = 0.
14
Published as a conference paper at ICLR 2019
C
Instead of estimating the MLE (or MAP if we have a prior) using RLSP, we could approximate the
entire posterior distribution. One standard way to address the computational challenges involved
with the continuous and high-dimensional nature of θ is to use MCMC sampling to sample from
p(θ | so) a p(so | θ)p(θ). The resulting algorithm resembles Bayesian IRL (Ramachandran and
Amir, 2007) and is presented in Algorithm 1.
While this algorithm is less efficient and noisier than RLSP, it gives us an estimate of the full posterior
distribution. In our experiments, we collapsed the full distribution into a point estimate by taking
the mean. Initial experiments showed that the algorithm was slower and noisier than the gradient-
based RLSP, so we did not test it further. However, in future work we could better leverage the full
distribution, for example to create risk-averse policies, to identify features that are uncertain, or to
identify features that are certain but conflict with the specified reward, after which we could actively
query Alice for more information.
Algorithm 1 MCMC sampling from the one state IRL posterior
Require: MDP M, prior p(θ), step size δ
1:	θ J random sample(p(θ))
2:	π, V = soft value iteration(M, θ)
3:	p J p(s0 | θ)p(θ)
4:	repeat
5:	θ0 J random sample(N (θ, δ))
6:	π0, V 0 = soft value iteration(M, θ0)	. The value function is initialized with V .
7:	p0 J p(s0 | θ0)p(θ0)
8:	if random SamPle(Unif(0,1)) ≤ min(1, P-) then
9:	θ J θ0; V J V0
10:	end if
11:	aPPend θ to the list of samPles
12:	until have generated the desired number of samPles
15
Published as a conference paper at ICLR 2019
Figure 4: Comparison of the Additive and Bayesian methods. We show how the percentage of
true reward obtained by πRLSP varies as we change the tradeoff between θAlice and θspec . The zero
temperature case corresponds to traditional value iteration; this often leads to identical behavior and
so the lines overlap. So, we also show the results when planning with soft value iteration, varying the
softmax temperature, to introduce some noise into the policy. Overall, there is not much difference
between the two methods. We did not include the Apples environment because θspec is uniformly
zero and the Additive and Bayesian methods do exactly the same thing.
Comparison of the methods for combining θspec and Θh
Standard deviation
D Combining the specified reward with the inferred reward
In Section 5, we evaluated RLSP by combining the reward it infers with a specified reward to get a
final reward θfinal = θAlice + λθspec. As discussed in Section 6, the problem of combining θAlice and
θspec is difficult, since the two rewards incentivize different behaviors and will conflict. The Additive
method above is a simple way of trading off between the two.
Both RLSP and the sampling algorithm of Appendix C can incorporate a prior over θ. Another
way to combine the two rewards is to condition the prior on θspec before running the algorithms. In
particular, we could replace our prior P (θAlice) with a new prior P (θAlice | θspec), such as a Gaussian
distribution centered at θspec. When we use this prior, the reward returned by RLSP can be used as
the final reward θfinal.
It might seem like this is a principled Bayesian method that allows us to combine the two rewards.
However, the conflict between the two reward functions still exists. In this formulation, it arises in
the new prior P (θAlice | θspec). Modeling this as a Gaussian centered at θspec suggests that before
knowing so, it seems likely that。卬展 is very similar to θspec. However, this is not true - Alice is
probably providing the reward θspec to the robot so that it causes some change to the state that she has
optimized, and so it will be predictably different from θspec. On the other hand, we do need to put
high probability on θspec, since otherwise θfinal will not incentivize any of the behaviors that θspec did.
Nonetheless, this is another simple heuristic for how we might combine the two rewards, that manages
the tradeoff between θspec and θAlice. We compared the Additive and Bayesian methods by evaluating
their robustness. We vary the parameter that controls the tradeoff and report the true reward obtained
by πRLSP, as a fraction of the expected true reward under the optimal policy. For the Bayesian method,
we vary the standard deviation σ of the Gaussian prior over θAlice that is centered at θspec. For the
Additive method, the natural choice would be to vary λ; however, in order to make the results more
comparable, we instead set λ = 1 and vary the standard deviation of the Gaussian prior used while
inferring θAlice, which is centered at zero instead of at θspec. A larger standard deviation allows θAlice
to become larger in magnitude (since it is penalized less for deviating from the mean of zero reward),
which effectively corresponds to a smaller λ.
While we typically create πRLSP using value iteration, this leads to deterministic policies with very
sharp changes in behavior that make it hard to see differences between methods, and so we also show
results with soft value iteration, which creates stochastic policies that vary more continuously. As
demonstrated in Figure 4, our experiments show that overall the two methods perform very similarly,
with some evidence that the Additive method is slightly more robust. The Additive method also has
the benefit that it can be applied in situations where the inferred reward and specified reward are over
different feature spaces, by creating the final reward Rfinal(s) = θAliceT fAlice(s) + λRspec(s).
16