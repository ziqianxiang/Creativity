Published as a conference paper at ICLR 2019
On the Convergence of A Class of Adam-Type
Algorithms for Non-Convex Optimization
XiangyiChent, SijiaLiur RuoyuSun§, MingyiHongt
tECE, University of Minnesota - Twin Cities
^MIT-IBM Watson AI Lab, IBM Research
§ISE, University of Illinois at Urbana-Champaign
t{chen5719,mhong}@umn.edu, ^sijia.liu@ibm.com, §ruoyus@illinois.edu
Ab stract
This paper studies a class of adaptive gradient based momentum algorithms that
update the search directions and learning rates simultaneously using past gradients.
This class, which we refer to as the “Adam-type”, includes the popular algorithms
such as Adam (Kingma & Ba, 2014) , AMSGrad (Reddi et al., 2018) , AdaGrad
(Duchi et al., 2011). Despite their popularity in training deep neural networks
(DNNs), the convergence of these algorithms for solving non-convex problems
remains an open question.
In this paper, we develop an analysis framework and a set of mild sufficient
conditions that guarantee the convergence of the Adam-type methods, with a
convergence rate of order O (log T/ √T) for non-convex stochastic optimization.
Our convergence analysis applies to anew algorithm called AdaFom (AdaGrad with
First Order Momentum). We show that the conditions are essential, by identifying
concrete examples in which violating the conditions makes an algorithm diverge.
Besides providing one of the first comprehensive analysis for Adam-type methods
in the non-convex setting, our results can also help the practitioners to easily
monitor the progress of algorithms and determine their convergence behavior.
1	Introduction
First-order optimization has witnessed tremendous progress in the last decade, especially to solve
machine learning problems (Bottou et al., 2018). Almost every first-order method obeys the following
generic form (Boyd & Vandenberghe, 2004), xt+1 = xt - αt∆t, where xt denotes the solution
updated at the tth iteration for t = 1, 2, . . . , T, T is the number of iterations, ∆t is a certain
(approximate) descent direction, and αt > 0 is some learning rate. The most well-known first-order
algorithms are gradient descent (GD) for deterministic optimization (Nesterov, 2013; Cartis et al.,
2010) and stochastic gradient descent (SGD) for stochastic optimization (Zinkevich, 2003; Ghadimi
& Lan, 2013), where the former determines ∆t using the full (batch) gradient of an objective
function, and the latter uses a simpler but more computationally-efficient stochastic (unbiased)
gradient estimate.
Recent works have proposed a variety of accelerated versions of GD and SGD (Nesterov, 2013).
These achievements fall into three categories: a) momentum methods (Nesterov, 1983; Polyak, 1964;
Ghadimi et al., 2015) which carefully design the descent direction ∆t; b) adaptive learning rate
methods (Becker et al., 1988; Duchi et al., 2011; Zeiler, 2012; Dauphin et al., 2015) which determine
good learning rates αt , and c) adaptive gradient methods that enjoy dual advantages of a) and b).
In particular, Adam (Kingma & Ba, 2014), belonging to the third type of methods, has become
extremely popular to solve deep learning problems, e.g., to train deep neural networks. Despite its
superior performance in practice, theoretical investigation of Adam-like methods for non-convex
optimization is still missing.
Very recently, the work (Reddi et al., 2018) pointed out the convergence issues of Adam even in
the convex setting, and proposed AMSGrad, a corrected version of Adam. Although AMSGrad has
made a positive step towards understanding the theoretical behavior of adaptive gradient methods,
the convergence analysis of (Reddi et al., 2018) was still very restrictive because it only works for
convex problems, despite the fact that the most successful applications are for non-convex problems.
Apparently, there still exists a large gap between theory and practice. To the best of our knowledge,
1
Published as a conference paper at ICLR 2019
the question that whether adaptive gradient methods such as Adam, AMSGrad, AdaGrad converge
for non-convex problems is still open in theory.
After the non-convergence issue of Adam has been raised in (Reddi et al., 2018), there have been
a few recent works on proposing new variants of Adam-type algorithms. In the convex setting,
reference (Huang et al., 2018) proposed to stabilize the coordinate-wise weighting factor to ensure
convergence. Reference (Chen & Gu, 2018) developed an algorithm that changes the coordinate-
wise weighting factor to achieve better generalization performance. Concurrent with this work,
several works are trying to understand performance of Adam in non-convex optimization problems.
Reference (Basu et al., 2018) provided convergence rate of original Adam and RMSprop under
full-batch (deterministic) setting, and (Ward et al., 2018) proved convergence rate of a modified
version of AdaGrad where coordinate-wise weighting is removed. Furthermore, the work (Zhou
et al., 2018) provided convergence results for AMSGrad that exhibit a tight dependency on problem
dimension compared to (Reddi et al., 2018). The works (Zou & Shen, 2018) and (Li & Orabona,
2018) proved that both AdaGrad and its variant (AdaFom) converge to a stationary point with a high
probability. The aforementioned works are independent of ours. In particular, our analysis is not only
more comprehensive (it covers the analysis of a large family of algorithms in a single framework), but
more importantly, it provides insights on how oscillation of stepsizes can affect the convergence rate.
Contributions Our work aims to build the theory to understand the behavior for a generic class of
adaptive gradient methods for non-convex optimization. In particular, we provide mild sufficient con-
ditions that guarantee the convergence for the Adam-type methods. We summarize our contribution
as follows.
• (Generality) We consider a class of generalized Adam, referred to as the “Adam-type”, and we
show for the first time that under suitable conditions about the stepsizes and algorithm parameters,
this class of algorithms all converge to first-order stationary solutions of the non-convex problem,
with O (log T/ √T) convergence rate. This class includes the recently proposed AMSGrad (Reddi
et al., 2018), AdaGrad (Duchi et al., 2011), and stochastic heavy-ball methods as well as two new
algorithms explained below.
•	(AdaFom) Adam adds momentum to both the first and the second moment estimate, but
this leads to possible divergence (Reddi et al., 2018). We show that the divergence issue
can actually be fixed by a simple variant which adds momentum to only the first moment
estimate while using the same second moment estimate as that of AdaGrad, which we call
AdaFom (AdaGrad with First Order Moment).
•	(Constant Momemtum) Our convergence analysis is applicable to the constant momentum
parameter setting for AMSGrad and AdaFom. The divergence example of Adam given in
(Reddi et al., 2018) is for constant momentum parameter, but the convergence analysis of
AMSGrad in (Reddi et al., 2018) is for diminishing momentum parameter. This discrepancy
leads to a question whether the convergence of AMSGrad is due to the algorithm form or
due to the momentum parameter choice - we show that the constant-momentum version of
AMSGrad indeed converges, thus excluding the latter possibility.
•	(Practicality) The sufficient conditions we derive are simple and easy to check in practice. They
can be used to either certify the convergence of a given algorithm for a class of problem instances, or
to track the progress and behavior of a particular realization of an algorithm.
•	(Tightness and Insight) We show the conditions are essential and “tight”, in the sense that violating
them can make an algorithm diverge. Importantly, our conditions provide insights on how oscillation
of a so-called “effective stepsize" (that we define later) can affect the convergence rate of the class of
algorithms. We also provide interpretations of the convergence conditions to illustrate why under
some circumstances, certain Adam-type algorithms can outperform SGD.
Notations We use Z = x/y to denote element-wise division if X and y are both vectors of size d;
X Θ y is element-wise product, x2 is element-wise square if X is a vector, √x is element-wise square
root if x is a vector, (x)j denotes jth coordinate of x, kxk is kxk2 if not otherwise specified. We use
[N] to denote the set {1, ∙ ∙ ∙ , N}, and use O(∙), o(∙), Ω(∙), ω(∙) as standard asymptotic notations.
2 Preliminaries and Adam-Type Algorithms
Stochastic optimization is a popular framework for analyzing algorithms in machine learning due to
the popularity of mini-batch gradient evaluation. We consider the following generic problem where
2
Published as a conference paper at ICLR 2019
we are minimizing a function f, expressed in the expectation form as follows
min f (x) = Eξ[f(x； ξ)],	(1)
x∈Rd
where ξ is a certain random variable representing randomly selected data sample or random noise.
In a generic first-order optimization algorithm, at a given time t we have access to an unbiased
noisy gradient gt of f (x), evaluated at the current iterate xt. The noisy gradient is assumed to
be bounded and the noise on the gradient at different time t is assumed to be independent. An
important assumption that we will make throughout this paper is that the function f(x) is continuously
differentiable and has Lipschitz continuous gradient, but could otherwise be a non-convex function.
The non-convex assumption represents a major departure from the convexity that has been assumed
in recent papers for analyzing Adam-type methods, such as (Kingma & Ba, 2014) and (Reddi et al.,
2018).
Our work focuses on the generic form of exponentially weighted stochastic gradient descent method
presented in Algorithm 1, for which we name as generalized Adam due to its resemblance to the
original Adam algorithm and many of its variants.
Algorithm 1. Generalized Adam
S0.	Initialize m0 = 0 and x1
Fort = 1,…，T,do
S1.	mt = β1,tmt-1 + (1 - β1,t)gt
S2.	Vt = ht(g1,g2,…，gt)
S3.	xt+ι = xt - at mt∕V^
End__________________________________
In Algorithm 1, αt is the step size at time t, β1,t > 0 is a sequence of problem parameters, mt ∈ Rd
denotes some (exponentially weighted) gradient estimate, and Vt = ht(g1,g2,…,gt) ∈ Rd takes all
the past gradients as input and returns a vector of dimension d, which is later used to inversely weight
the gradient estimate mt. And note that mt /√^t ∈ Rd represents element-wise division. Throughout
the paper, we will refer to the vector at∕√vt as the effective stepsize.
We highlight that Algorithm 1 includes many well-known algorithms as special cases. We summarize
some popular variants of the generalized Adam algorithm in Table 1.
Table 1: Variants of generalized Adam
^∖βι,t vt7<	βι,t = 0	β1,t ≤ β1,t-1 βι,t	→ b ≥ 0 t→∞	βι,t = 81
Vt = 1	SGD	N/A*	Heavy-ball method
Vt = t Pt=I g2	AdaGrad	AdaFom	AdaFom
Vt = β2Vt-1 + (1 - β2)g2, Vt = max(Vt-i,Vt)	AMSGrad	AMSGrad	AMSGrad
^t = β2Vt-i + (1 - β2)g2	RMSProP	N/A	Adam
* N/A stands for an informal algorithm that was not defined in literature.
We present some interesting findings for the algorithms presented in Table 1.
•	Adam is often regarded as a “momentum version” of AdaGrad, but it is different from
AdaFom which is also a momentum version of AdaGrad 1. The difference lies in the form of
Vt. Intuitively, Adam adds momentum to both the first and second order moment estimate,
while in AdaFom we only add momentum to the first moment estimate and use the same
second moment estimate as AdaGrad. These two methods are related in the following way:
if we let β2 = 1 - 1/t in the expression of Vt in Adam, we obtain AdaFom. We can view
AdaFom as a variant of Adam with an increasing sequence of β2, or view Adam as a variant
of AdaFom with exponentially decaying weights ofgt2. However, this small change has large
impact on the convergence: we prove that AdaFom can always converge under standard
1AdaGrad with first order momentum is also studied in (Zou & Shen, 2018) which appeared online after our
first version
3
Published as a conference paper at ICLR 2019
assumptions (see Corollary 3.2) , while Adam is shown to possibly diverge (Reddi et al.,
2018).
•	The convergence of AMSGrad using a fast diminishing β1,t such that β1,t ≤
β1,t-1, β1,t ---→ b, b = 0 in convex optimization was studied in (Reddi et al., 2018).
t→∞
However, the convergence of the version with constant β1 or strictly positive b and the ver-
sion for non-convex setting are unexplored before our work. We notice that an independent
work (Zhou et al., 2018) has also proved the convergence of AMSGrad with constant β1.
Itis also worth mentioning that Algorithm 1 can be applied to solve the popular “finite-sum” problems
whose objective is a sum of n individual cost functions. That is,
xm∈iRnd	in=1fi(x) := f(x),
(2)
where each fi : Rd → R is a smooth and possibly non-convex function. If at each time instance the
index i is chosen uniformly randomly, then Algorithm 1 still applies, with gt = Vfi(xt). It can also
be extended to a mini-batch case with gt = b Pi∈ι Vfi(Xt), Where Zt denotes the minibatch of
size b at time t. It is easy to show that gt is an unbiased estimator for Vf (x).
In the remainder of this paper, we will analyze Algorithm 1 and provide sufficient conditions under
which the algorithm converges to first-order stationary solutions with sublinear rate. We will also
discuss how our results can be applied to special cases of generalized Adam.
3	Convergence Analysis for Generalized Adam
The main technical challenge in analyzing the non-convex version of Adam-type algorithms is that
the actually used update directions could no longer be unbiased estimates of the true gradients.
Furthermore, an additional difficulty is introduced by the involved form of the adaptive learning rate.
Therefore the biased gradients have to be carefully analyzed together with the use of the inverse of
exponential moving average while adjusting the learning rate. The existing convex analysis (Reddi
et al., 2018) does not apply to the non-convex scenario we study for at least two reasons: first,
non-convex optimization requires a different convergence criterion, given by stationarity rather than
the global optimality; second, we consider constant momentum controlling parameter.
In the following, we formalize the assumptions required in our convergence analysis.
Assumptions
A1: f is differentiable and has L-Lipschitz gradient, i.e. ∀x, y, kVf (x) - Vf (y)k ≤ Lkx - yk.
It is also lower bounded, i.e. f (x*) > 一∞ where x* is an optimal solution.
A2: At time t, the algorithm can access a bounded noisy gradient and the true gradient is bounded,
i.e. kVf(xt)k ≤H,	kgtk ≤H,	∀t> 1.
A3: The noisy gradient is unbiased and the noise is independent, i.e. gt = Vf(xt) + ζt, E[ζt] = 0
and ζi is independent of ζj if i 6= j .
Reference (Reddi et al., 2018) uses a similar (but slightly different) assumption as A2, i.e., the
bounded elements of the gradient kgt k∞ ≤ a for some finite a. The bounded norm of Vf(xt) in
A2 is equivalent to Lipschitz continuity of f (when f is differentiable) which is a commonly used
condition in convergence analysis. This assumption is often satisfied in practice, for example it holds
for the finite sum problem (2) when each fi has bounded gradient, and gt = Vfi (xt) where i is
sampled randomly. A3 is also standard in stochastic optimization for analyzing convergence.
Our main result shows that if the coordinate-wise weighting term √V^t in Algorithm 1 is properly
chosen, we can ensure the global convergence as well as the sublinear convergence rate of the
algorithm (to a first-order stationary solution). First, we characterize how the effective stepsize
parameters at and Vt affect convergence of Adam-type algorithms.
Theorem 3.1. Suppose that Assumptions A1-A3 are satisfied, β1 is chosen such that β1 ≥ β1,t,
βι,t ∈ [0,1) is non-increasing, and for some constant G > 0, ∣Iatmt/√Vt∣∣ ≤ G, ∀ t. Then
4
Published as a conference paper at ICLR 2019
Algorithm 1 yields
E X αt<Vf(xt), Vf (xt)∕√Vti
t=1
T
(3)
T
≤E
C1
XIlatgj√v;Ii	+ C2 X	√α= -
t=1	t=2 vt
t=1
t=2
at-ι
√vt-T
T-1
+ C3 X
1	t=2
2
where C1, C2, C3 are constants independent of d and T, C4 is a constant independent of T, the
expectation is taken with respect to all the randomness corresponding to {gt }.
Further, let Yt := min7-∈[d] min{gi }t_ at/(√Vt)j denote the minimum possible value of effective
stepsize at time t over all possible coordinate and past gradients {gi}it=1. Then the convergence
rate of Algorithm 1 is given by
m[T]E [kVf(Xt)k2] = o(* )，	⑷
where s1(T) is defined through the upper bound of RHS of (3), namely, O(s1(T)), and PtT=1 γt =
Ω(s2(T)).	一
Proof: See Appendix 6.2.
InTheorem3.1, ∣∣atmt∕√Vtk ≤ G is a mild condition. Roughly speaking, it implies that the change
of xt at each each iteration should be finite. As will be evident later, with kgt k ≤ H, the condition
Ilatmt/√Vtk ≤ G is automatically satisfied for both AdaGrad and AMSGrad. Besides, instead of
bounding the minimum norm of Vf in (4), We can also apply a probabilistic output (e.g., select an
output XR with probability p(R = t) = PTY—) to bound E[∣∣Vf (XR) ∣∣2] (Ghadimi & Lan, 2013;
t=1 γt
Lei et al., 2017). It is worth mentioning that a small number E could be added to Vt for ensuring the
numerical stability. In this case, our Theorem 3.1 still holds given the fact the resulting algorithm is
still a special case of Algorithm 1. Accordingly, our convergence results for AMSGrad and AdaFom
that will be derived later also hold as ∣∣αtmt∕(√Vt + e)∣ ≤ ∣∣atmt∕√Vtk ≤ G when E is added to
vt. We will provide a detailed explanation of Theorem 3.1 in Section 3.1.
Theorem 3.1 implies a sufficient condition that guarantees convergence of the Adam-type methods:
s1(T) grows slower than s2(T). We will show in Section 3.2 that the rate s1(T) can be dominated
by different terms in different cases, i.e. the non-constant quantities Term A and B below
2T
αtgJ√vt	+ X √⅛-√vt-τ
αt-1
t=2
o(s1(T)),
(5)
E
|
{z
Term A
{z
Term B
where the growth of third term at LHS of (5) can be directly related to growth of Term B via the
relationship between 'ι and '2 norm or upper boundedness of (αt∕√¾)j.
3.1	Explanation of convergence conditions
From (4) in Theorem 3.1, it is evident that s1(T) = o(s2 (T)) can ensure proper convergence of the
algorithm. This requirement has some important implications, which we discuss below.
•	(The Bounds for s1(T) and s2 (T)) First, the requirement that s1(T) = o(s2(T)) implies that
E[PT=1 l∣atgt∕√Vtk2] = o(PT=ι Yt). This is a common condition generalized from SGD. TermA
in (5) is a generalization of the term PtT=1 ∣atgt∣2 for SGD (where {at} is the stepsize sequence for
SGD), and it quantifies possible increase in the objective function brought by higher order curvature.
The term PtT=1 Yt is the lower bound on the summation of effective stepsizes, which reduces to
PtT=1 at when Algorithm 1 is simplified to SGD.
•	(Oscillation OfEffective Stepsizes) Term B in (5) characterizes the oscillation OfeffeCtiVe stepsizes
at∕√vt. In our analysis such an oscillation term upper bounds the expected possible ascent in
objective induced by skewed update direction gt∕√Vt (“skewed” in the sense that E[gt∕√vt] is
not parallel with Vf (xt)), therefore it cannot be too large. Bounding this term is critical, and to
demonstrate this fact, in Section 3.2.2 we show that large oscillation can result in non-convergence of
Adam for even simple unconstrained non-convex problems.
•	(Advantage of Adaptive Gradient). One possible benefit of adaptive gradient methods can be
seen from Term A. When this term dominates the convergence speed in Theorem 3.1, it is possible
5
Published as a conference paper at ICLR 2019
that proper design of Vt can help reduce this quantity compared with SGD (An example is provided in
Appendix 6.1.1 to further illustrate this fact.) in certain cases. Intuitively, adaptive gradient methods
like AMSGrad can provide a flexible choice of stepsizes, since Vt can have a normalization effect
to reduce oscillation and overshoot introduced by large stepsizes. At the same time, flexibility of
stepsizes makes the hyperparameter tuning of an algorithm easier in practice.
3.2	Tightness of the rate bound (4)
In the next, we show our bound (4) is tight in the sense that there exist problems satisfying Assumption
1 such that certain algorithms belonging to the class of Algorithm 1 can diverge due to the high
growth rate of Term A or Term B.
3.2.1	Non-convergence of SGD and ADAM due to effect of Term A
We demonstrate the importance of Term A in this subsection. Consider a simple one-dimensional
optimization problem minx f (x), with f(x) = 100x2 if |x| <= b, and f(x) = 200b|x| - 100b2 if
|x| > b, where b = 10. In Figure 1, we show the growth rate of different terms given in Theorem
3.1, where α0 , 0, αt = 0.01 for t ≥ 1, and β1,t = 0, β2,t = 0.9 for both Adam and AMSGrad.
We observe that both SGD and Adam are not converging to a stationary solution (x = 0), which
is because PT=Illatgt/√Vt ∣∣ grows with the same rate as accumulation of effective stepsizes as
shown in the figure. Actually, SGD only converges when αt < 0.01 and our theory provides an
perspective of why SGD diverges when αt ≥ 0.01. In the example, Adam is also not converging to
0 due to Term A. From our observation, Adam oscillates for any constant stepsize within [10-4, 0.1]
for this problem and Term A always ends up growing as fast as accumulation of effective stepsizes,
which implies Adam only converges with diminishing stepsizes even in non-stochastic optimization.
In contrast to SGD and Adam, AMSGrad converges in this case since both Term A and Term B
grow slower than accumulation of effective stepsizes. For AMSGrad and Adam, Vt has a strong
normalization effect and it allows the algorithm to use a larger range ofαt. The practical benefit of this
flexible choice of stepsizes is easier hyperparameter tuning, which is consistent with the impression
of practitioners about the original Adam. We present more experimental results in Appendix 6.1.1
accompanied with more detailed discussions.
Figure 1
—Adam
-AMSGrad
SGD
0000000000
-1-2-3
10Ooo
Z=(3>一
101	102	103	1O4	105	106	1Oo 1O1	102	103	1O4	105	106
iteration T	iteration T
: A toy example to illustrate effect of Term A on Adam, AMSGrad, and SGD.
6
Published as a conference paper at ICLR 2019
3.2.2 Non-convergence of Adam due to effect of Term B
Next, we use an example to demonstrate the importance of the Term B for the convergence of
Adam-type algorithms.
Consider optimization problem minx f(x) = Pi1=1 1 fi(x) where
I[i	= 1]5.5x2 + I[i 6= 1](-0.5x2),	if |x|	≤ 1
fi(x) =	I[i	= 1](11|x| - 5.5) +I[i 6= 1](-|x|	+ 0.5),	if |x|	> 1
(6)
and I[1 = 1] = 1, I[1 = 1] = 0. It is easy to verify that the only point with Vf (x) = 0 is X = 0.
The problem satisfies the assumptions in Theorem 3.1 as the stochastic gradient gt = Vfi(Xt) is
sampled uniformly for i ∈ [11]. We now use the AMSGrad and Adam to optimize x, and the
results are given in Figure 2, where we set αt = 1, β1,t = 0, and β2,t = 0.1. We observe that
PT=Ikat/√^t — αt-1 /p^tt-ι k1 in Term B grows with the same rate as PT=I αt∕√^t for Adam,
where we recall that PT=I at/√vt is an upper bound of PT=I Yt in Theorem 3.1. As a result, we
obtain O(s1 (T)/s2 (T)) 6= o(1) in (4), implying the non-convergence of Adam. Our theoretical
analysis matches the empirical results in Figure 2. In contrast, AMSGrad converges in Figure 2
because of its smaller oscillation in effective stepsizes, associated with Term B. We finally remark
T
that the importance of the quantity Et=IIlat/.Vt — at-1 /√vt-11∣1 is also noticed by (Huang et al.,
2018). However, they did not analyze its effect on convergence, and their theory is only for convex
optimization.
103
亭/—M
102
—Adam
≡ AMSGrad
10°
10°	101	102	103	104
iteration T
彳OT  ...........  '........' ......'........
10°	101	102	103	104	105
iteration T
—Adam
—AMSGrad
i 6	8	10	12
iteration T
Figure 2: A toy example to illustrate effect of Term B on Adam and AMSGrad.
3.3	Convergence of AMSGrad and AdaFom
Theorem 3.1 provides a general approach for the design of the weighting sequence {Vt} and the
convergence analysis of Adam-type algorithms. For example, SGD specified by Table 1 with stepsizes
Qt = 1∕√t yields O (log T/ T) convergence speed by Theorem 3.1. Moreover, the explanation on
the non-convergence of Adam in (Reddi et al., 2018) is consistent with our analysis in Section 3.2.
That is, Term B in (5) can grow as fast as s2 (T) so that s1(T)/s2(T) becomes a constant. Further,
we notice that Term A in (5) can also make Adam diverge which is unnoticed before. Aside from
checking convergence of an algorithm, Theorem 3.1 can also provide convergence rates of AdaGrad
and AMSGrad, which will be given as corollaries later.
7
Published as a conference paper at ICLR 2019
Our proposed convergence rate of AMSGrad matches the result in (Reddi et al., 2018) for stochastic
convex optimization. However, the analysis of AMSGrad in (Reddi et al., 2018) is constrained to
diminishing momentum controlling parameter β1,t. Instead, our analysis is applicable to the more
popular constant momentum parameter, leading to a more general non-increasing parameter setting.
In Corollary 3.1 and Corollary 3.2, we derive the convergence rates of AMSGrad (Algorithm 3 in
Appendix 6.2.3) and AdaFom (Algorithm 4 in Appendix 6.2.4), respectively. Note that AdaFom is
more general than AdaGrad since when β1,t = 0, AdaFom becomes AdaGrad.
Corollary 3.1. Assume ∃ c > 0 such that |(g1)i | ≥ c, ∀i ∈ [d], for AMSGrad (Algorithm 3 in
Appendix 6.2.3) with βι,t ≤ βι ∈ [0,1) and βι,t is non-increasing, αt = l/ʌ/t, we have for any T,
min E[kf(xt)k2] ≤ √T (Qi + Q2 log T)	(7)
where Q1 and Q2 are two constants independent ofT.
Proof: See Appendix 6.2.3.
Corollary 3.2. Assume ∃ c > 0 such that |(g1)i| ≥ c, ∀i ∈ [d], for AdaFom (Algorithm 4 in Appendix
6.2.4) with βι,t ≤ βι ∈ [0,1) and βι,t is non-increasing, a = 1∕√t, we havefor any T,
min E [kf(Xt)k2] ≤ √T(QI + q2 logT)	⑻
where Q01 and Q02 are two constants independent ofT.
Proof: See Appendix 6.2.4.
The assumption ∣(gι)i∣ ≥ c, ∀i is a mild assumption and it is used to ensure Vi ≥ r for some
constant r. It is also usually needed in practice for numerical stability (for AMSGrad and AdaGrad, if
(gi )i = 0 for some i, division by 0 error may happen at the first iteration). In some implementations,
to avoid numerical instability, the update rule of algorithms like Adam, AMSGrad, and AdaGrad
take the form of xt+i = Xt - αtmt∕(√V^t + E) with E being a positive number. These modified
algorithms still fall into the framework of Algorithm 1 since can be incorporated into the definition
of Vt. Meanwhile, our convergence proof for Corollary 3.1 and Corollary 3.2 can go through without
assuming ∣(gι)i∣ ≥ c, ∀i because √^^t ≥ e. In addition, E can affect the worst case convergence rate
by a constant factor in the analysis.
We remark that the derived convergence rate of AMSGrad and AdaFom involves an additional log T
factor compared to the fastest rate of first order methods (1 /√T). However, such a slowdown can be
mitigated by choosing an appropriate stepsize. To be specific, the log T factor for AMSGrad would
be eliminated when we adopt a constant rather than diminishing stepsize, e.g., at = 1/√T. It is also
worth mentioning that our theoretical analysis focuses on the convergence rate of adaptive methods
in the worst case for nonconvex optimization. Thus, a sharper convergence analysis that can quantify
the benefits of adaptive methods still remains an open question in theory.
4	Empirical performance of Adam-type algorithms on MNIST
In this section, we compare the empirical performance of Adam-type algorithms, including AMSGrad,
Adam, AdaFom and AdaGrad, on training two convolutional neural networks (CNNs). In the first
example, we train a CNN of 3 convolutional layers and 2 fully-connected layers on MNIST. In the
second example, we train a CIFARNET on CIFAR-10. We refer readers to Appendix 6.1.2 for more
details on the network model and the parameter setting.
In Figure 3, we present the training loss and the classification accuracy of Adam-type algorithms
versus the number of iterations. As we can see, AMSGrad performs quite similarly to Adam
which confirms the result in (Reddi et al., 2018). The performance of AdaGrad is worse than other
algorithms, because of the lack of momentum and/or the significantly different choice of Vt. We also
observe that the performance of AdaFom lies between AMSGrad/Adam and AdaGrad. This is not
surprising, since AdaFom can be regarded as a momentum version of AdaGrad but uses a simpler
adaptive learning rate (independent on β2) compared to AMSGrad/Adam. In Figure 4, we consider to
train a larger network (CIFARNET) on CIFAR-10. As we can see, Adam and AMSGrad perform
similarly and yield the best accuracy. AdaFom outperforms AdaGrad in both training and testing,
which agrees with the results obtained in the MNIST experiment.
8
Published as a conference paper at ICLR 2019
Figure 3: Comparison of AMSGrad, Adam, AdaFom and AdaGrad under MNIST in training loss and testing
(b) Testing accuracy versus iterations
accuracy.
(a) Training loss versus iterations
Figure 4: Comparison of AMSGrad, Adam, AdaFom and AdaGrad under CIFAR in training loss and testing
accuracy.
(b) Testing accuracy versus iterations
5	Conclusion and Discussion
We provided some mild conditions to ensure convergence of a class of Adam-type algorithms, which
includes Adam, AMSGrad, AdaGrad, AdaFom, SGD, SGD with momentum as special cases. Apart
from providing general convergence guarantees for algorithms, our conditions can also be checked
in practice to monitor empirical convergence. To the best of our knowledge, the convergence of
Adam-type algorithm for non-convex problems was unknown before. We also provide insights on how
oscillation of effective stepsizes can affect convergence rate for the class of algorithms which could
be beneficial for the design of future algorithms. This paper focuses on unconstrained non-convex
optimization problems, and one future direction is to study a more general setting of constrained
non-convex optimization.
Acknowledgments
This work was supported by the MIT-IBM Watson AI Lab. Mingyi Hong and Xiangyi Chen are
supported partly by an NSF grant CMMI-1727757,and by an AFOSR grant 15RT0767.
9
Published as a conference paper at ICLR 2019
References
A. Basu, S. De, A. Mukherjee, and E. Ullah. Convergence guarantees for rmsprop and adam in non-convex
optimization and their comparison to nesterov acceleration on autoencoders. arXiv preprint arXiv:1807.06766,
2018.
S. Becker, Y. Le Cun, et al. Improving the convergence of back-propagation learning with second order methods.
In Proceedings of the 1988 Connectionist models summer school, pp. 29-37. San Matteo, CA: Morgan
Kaufmann, 1988.
J. Bernstein, Y. Wang, K. Azizzadenesheli, and A. Anandkumar. signsgd: compressed optimisation for non-
convex problems. arXiv preprint arXiv:1802.04434, 2018.
L. Bottou, F. E. Curtis, and J. Nocedal. Optimization methods for large-scale machine learning. SIAM Review,
60(2):223-311, 2018.
S. Boyd and L. Vandenberghe. Convex optimization. Cambridge university press, 2004.
C. Cartis, N. I. Gould, and P. L. Toint. On the complexity of steepest descent, newton’s and regularized
newton’s methods for nonconvex unconstrained optimization problems. Siam journal on optimization, 20(6):
2833-2852, 2010.
J. Chen and Q. Gu. Closing the generalization gap of adaptive gradient methods in training deep neural networks.
arXiv preprint arXiv:1806.06763, 2018.
Y. Dauphin, H. de Vries, and Y. Bengio. Equilibrated adaptive learning rates for non-convex optimization. In
Advances in neural information processing systems, pp. 1504-1512, 2015.
T. Dozat. Incorporating nesterov momentum into adam. 2016.
J. Duchi, E. Hazan, and Y. Singer. Adaptive subgradient methods for online learning and stochastic optimization.
Journal of Machine Learning Research, 12(Jul):2121-2159, 2011.
E. Ghadimi, H. R. Feyzmahdavian, and M. Johansson. Global convergence of the heavy-ball method for convex
optimization. In 2015 European Control Conference (ECC), pp. 310-315. IEEE, 2015.
S. Ghadimi and G. Lan. Stochastic first-and zeroth-order methods for nonconvex stochastic programming. SIAM
Journal on Optimization, 23(4):2341-2368, 2013.
S. Ghadimi and G. Lan. Accelerated gradient methods for nonconvex nonlinear and stochastic programming.
Mathematical Programming, 156(1-2):59-99, 2016.
H. Huang, C. Wang, and B. Dong. Nostalgic adam: Weighing more of the past gradients when designing the
adaptive learning rate. arXiv preprint arXiv:1805.07557, 2018.
C.	Jin, P. Netrapalli, and M. I. Jordan. Accelerated gradient descent escapes saddle points faster than gradient
descent. arXiv preprint arXiv:1711.10456, 2017.
R. Johnson and T. Zhang. Accelerating stochastic gradient descent using predictive variance reduction. In
Advances in neural information processing systems, pp. 315-323, 2013.
D.	P. Kingma and J. Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.
L. Lei, C. Ju, J. Chen, and M. I. Jordan. Non-convex finite-sum optimization via scsg methods. In Advances in
Neural Information Processing Systems, pp. 2345-2355, 2017.
X. Li and F. Orabona. On the convergence of stochastic gradient descent with adaptive stepsizes. arXiv preprint
arXiv:1805.08114, 2018.
A. Nemirovskii, D. B. Yudin, and E. R. Dawson. Problem complexity and method efficiency in optimization.
1983.
Y. Nesterov. A method for unconstrained convex minimization problem with the rate of convergence o (1∕k^2).
In Doklady AN USSR, volume 269, pp. 543-547, 1983.
Y. Nesterov. Introductory lectures on convex optimization: A basic course, volume 87. Springer Science &
Business Media, 2013.
P. Ochs, T. Brox, and T. Pock. ipiasco: Inertial proximal algorithm for strongly convex optimization. Journal of
Mathematical Imaging and Vision, 53(2):171-181, 2015.
10
Published as a conference paper at ICLR 2019
P. T. Polyak. Some methods of speeding up the convergence of iteration methods. USSR Computational
Mathematics and Mathematical Physics, 4(5):1-17, 1964.
S.	J. Reddi, A. Hefny, S. Sra, B. Poczos, and A. Smola. Stochastic variance reduction for nonconvex optimization.
In International conference on machine learning, pp. 314-323, 2016.
S.	J. Reddi, S. Kale, and S. Kumar. On the convergence of adam and beyond. In International Conference on
Learning Representations, 2018.
T.	Tieleman and G. Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent
magnitude. COURSERA: Neural networks for machine learning, 4(2):26-31, 2012.
R.	Ward, X. Wu, and L. Bottou. Adagrad stepsizes: Sharp convergence over nonconvex landscapes, from any
initialization. arXiv preprint arXiv:1806.01811, 2018.
T.	Yang, Q. Lin, and Z. Li. Unified convergence analysis of stochastic momentum methods for convex and
non-convex optimization. arXiv preprint arXiv:1604.03257, 2016.
M. D. Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.
D. Zhou, Y. Tang, Z. Yang, Y. Cao, and Q. Gu. On the convergence of adaptive gradient methods for nonconvex
optimization. arXiv preprint arXiv:1808.05671, 2018.
M. Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In Proceedings of the
20th International Conference on Machine Learning (ICML-03), pp. 928-936, 2003.
F. Zou and L. Shen. On the convergence of adagrad with momentum for training deep neural networks. arXiv
preprint arXiv:1808.03408, 2018.
11
Published as a conference paper at ICLR 2019
6	Appendix
6.1	Related Work
Momentum methods take into account the history of first-order information (Nesterov, 2013; 1983;
Nemirovskii et al., 1983; Ghadimi & Lan, 2016; Polyak, 1964; Ghadimi et al., 2015; Ochs et al.,
2015; Yang et al., 2016; Johnson & Zhang, 2013; Reddi et al., 2016; Lei et al., 2017). A well-known
method, called Nesterov’s accelerated gradient (NAG) originally designed for convex deterministic
optimization (Nesterov, 2013; 1983; Nemirovskii et al., 1983), constructs the descent direction ∆t
using the difference between the current iterate and the previous iterate. A recent work (Ghadimi
& Lan, 2016) studied a generalization of NAG for non-convex stochastic programming. Similar
in spirit to NAG, heavy-ball (HB) methods (Polyak, 1964; Ghadimi et al., 2015; Ochs et al., 2015;
Yang et al., 2016) form the descent direction vector through a decaying sum of the previous gradient
information. In addition to NAG and HB methods, stochastic variance reduced gradient (SVRG)
methods integrate SGD with GD to acquire a hybrid descent direction of reduced variance (Johnson &
Zhang, 2013; Reddi et al., 2016; Lei et al., 2017). Recently, certain accelerated version of perturbed
gradient descent (PAGD) algorithm is also proposed in (Jin et al., 2017), which shows the fastest
convergence rate among all Hessian free algorithms.
Adaptive learning rate methods accelerate ordinary SGD by using knowledge of the past gradients
or second-order information into the current learning rate αt (Becker et al., 1988; Duchi et al.,
2011; Zeiler, 2012; Dauphin et al., 2015). In (Becker et al., 1988), the diagonal elements of the
Hessian matrix were used to penalize a constant learning rate. However, acquiring the second-order
information is computationally prohibitive. More recently, an adaptive subgradient method (i.e.,
AdaGrad) penalized the current gradient by dividing the square root of averaging of the squared
gradient coordinates in earlier iterations (Duchi et al., 2011). Although AdaGrad works well when
gradients are sparse, its convergence is only analyzed in the convex world. Other adaptive learning rate
methods include Adadelta (Zeiler, 2012) and ESGD (Dauphin et al., 2015), which lacked theoretical
investigation although some convergence improvement was shown in practice.
Adaptive gradient methods update the descent direction and the learning rate simultaneously using
knowledge in the past, and thus enjoy dual advantages of momentum and adaptive learning rate
methods. Algorithms of this family include RMSProp (Tieleman & Hinton, 2012), Nadam (Dozat,
2016), and Adam (Kingma & Ba, 2014). Among these, Adam has become the most widely-used
method to train deep neural networks (DNNs). Specifically, Adam adopts exponential moving
averages (with decaying/forgetting factors) of the past gradients to update the descent direction. It
also uses inverse of exponential moving average of squared past gradients to adjust the learning rate.
The work (Kingma & Ba, 2014) showed Adam converges with at most O(1∕√T) rate for convex
problems. However, the recent work (Reddi et al., 2018) pointed out the convergence issues of Adam
even in the convex setting, and proposed a modified version of Adam (i.e., AMSGrad), which utilizes
a non-increasing quadratic normalization and avoids the pitfalls of Adam. Although AMSGrad
has made a significant progress toward understanding the theoretical behavior of adaptive gradient
methods, the convergence analysis of (Reddi et al., 2018) only works for convex problems.
6.1.1	Advantages and Disadvantages of Adaptive gradient method
In this section, we provide some additional experiments to demonstrate how specific Adam-type
algorithms can perform better than SGD and how SGD can out perform Adam-type algorithms in
different situations.
One possible benefit of adaptive gradient methods is the “sparse noise reduction” effect pointed out in
Bernstein et al. (2018). Below we illustrate another possible practical advantage of adaptive gradient
methods when applied to solve non-convex problems, which we refer to as flexibility of stepsizes.
To highlight ideas, let us take AMSGrad as an example, and compare it with SGD. First, in non-
convex problems there can be multiple valleys with different curvatures. When using fixed stepsizes
(or even a slowly diminishing stepsize), SGD can only converge to local optima in valleys with small
curvature while AMSGrad and some other adaptive gradient algorithms can potentially converge to
optima in valleys with relative high curvature (this may not be beneficial if one don’t want to converge
to a sharp local minimum). Second, the flexible choice of stepsizes implies less hyperparameter
tuning and this coincides with the popular impression about original Adam.
12
Published as a conference paper at ICLR 2019
We empirically demonstrate the flexible stepsizes property of AMSGrad using a deterministic
quadratic problem. Consider a toy optimization problem minx f (x), f(x) = 100x2, the gradient is
given by 200x. For SGD (which reduces to gradient descent in this case) to converge, we must have
αt < 0.01; for AMSGrad, Vt has a strong normalization effect and it allows the algorithm to use
larger αt's. We show the growth rate of different terms given in Theorem 3.1 for different stepsizes
in Figure A1 to Figure A4 (where we choose β1,t = 0, β2,t = 0.9 for both Adam and AMSGrad). In
Figure A1, αt = 0.1 and SGD diverges due to large αt, AMSGrad converges in this case, Adam is
oscillating between two non-zero points. In Figure A2, stepsizes αt is set to 0.01, SGD and Adam
are oscillating, AMSGrad converges to 0. For Figure A3, SGD converges to 0 and AMSGrad is
converging slower than SGD due to its smaller effective stepsizes, Adam is oscillating. One may
wonder how diminishing stepsizes affects performance of the algorithms, this is shown in Figure A4
where αt = 0.1∕√t, we can see SGD is diverging until stepsizes is small, AMSGrad is converging
all the time, Adam appears to get stuck but it is actually converging very slowly due to diminishing
stepsizes. This example shows AMSGrad can converge with a larger range of stepsizes compared
with SGD.
From the figures, we can see that the term PT=Ikatgt/√vt∣∣2 is the key quantity that limits the
convergence speed of algorithms in this case. In Figure A1, Figure A2, and early stage of Figure
A4, the quantity is obviously a good sign of convergence speed. In Figure A3, since the difference
of quantity between AMSGrad and SGD is compensated by the larger effective stepsizes of SGD
and some problem independent constant, SGD converges faster. In fact, Figure A3 provides a case
where AMSGrad does not perform well. Note that the normalization factor ʌ/vt can be understood as
imitating the largest Lipschitz constant along the way of optimization, so generally speaking dividing
by this number makes the algorithm converge easier. However when the Lipschitz constant becomes
smaller locally around a local optimal point, the stepsizes choice of AMSGrad dictates that ʌ/vt
does not change, resulting a small effective stepsizes. This could be mitigated by AdaGrad and its
momentum variants which allows Vt to decrease when gt keeps decreasing.
1Oo 1O1	1O2	103	104	105	106
iteration T
(a) PT=I at/√Vt versus T
—Adam
-AMSGrad
SGD
(b) PT=Ikatgt/√Vtk2 versus
106
T
1Oo 1O1	102	103	1O4	105	106
iteration T	wo
(C) PT=Ikat/√^t-at-ι/√vt-ι ∣∣ι versus
T
(d) kVf(XT)k2 versus T
106
—Adam
—AMSGrad
SGD
Figure A1: Comparison of algorithms with
αt = 0.1, we defined α0
0
13
Published as a conference paper at ICLR 2019
Adam
=AMSGrad
—Adam
—AMSGrad
SGD
SGD
iteration T	iteration T
(a) PT=I at/√^t versus T	(b) PT=IIlatgt/√^t∣∣2 versus T
—Adam
—AMSGrad
SGD

102	103	1O4	105	106
iteration T
O-1O-2
102	103	1O4	105	106
iteration T
—Adam
—AMSGrad
SGD
(C) PT=1 kαt/√^-αt-ι/√vt-ι k 1 versus
T
(d) kVf(xτ)k2 versus T
Figure A2: Comparison of algorithms with αt = 0.01, we defined α0 = 0
—Adam
-AMSGrad
SGD
—Adam
-AMSGrad
SGD
(b) PT=Ikat gt√t Il2versus T
(a) PT=ι at/√^ versus T
Figure A3: Comparison of algorithms with αt = 0.001, we defined α0 = 0
14
Published as a conference paper at ICLR 2019
(a) PT=1 at/√^t versus T
(b) PT=Ikatgt/√^tk2 versus T
Figure A4: Comparison of algorithms with at = 0.1∕√t, We defined a0 = 0
6.1.2 Details of experiments on MNIST and CIFAR-10
In the experiment on MNIST, we consider a convolutional neural network (CNN), which includes 3
convolutional layers and 2 fully-connected layers. In convolutional layers, we adopt filters of sizes
6 × 6 × 1 (with stride 1), 5 × 5 × 6 (with stride 2), and 6 × 6 × 12 (with stride 2), respectively. In
both AMSGrad2 and Adam, we set β1 = 0.9 and β2 = 0.99. In AdaFom, we set β1 = 0.9. We
choose 50 as the mini-batch size and the stepsize is choose to be αt = 0.0001 + 0.003e-t/2000.
The architecture of the CIFARNET that we are using is as below. The model starts with two
convolutional layers with 32 and 64 kernels of size 3 x 3, followed by 2 x 2 max pooling and dropout
with keep probability 0.25. The next layers are two convolutional layers with 128 kernels of size 3 x
3 and 2 x 2, respectively. Each of the two convolutional layers is followed by a 2 x 2 max pooling
layer. The last layer is a fully connected layer with 1500 nodes. Dropout with keep probability 0.25
is added between the fully connected layer and the convolutional layer. All convolutional layers use
ReLU activation and stride 1. The learning rate αt of Adam and AMSGrad starts with 0.001 and
decrease 10 times every 20 epochs. The learning rate of AdaGrad and AdaFom starts with 0.05 and
decreases to 0.001 after 20 epochs and to 0.0001 after 40 epochs. These learning rates are tuned so
that each algorithm has its best performance.
6.2 Convergence proof for Generalized Adam (Algorithm 1)
In this section, we present the convergence proof of Algorithm 1. We will first give several lemmas
prior to proving Theorem 3.1.
2We customized our algorithms based on the open source code https://github.com/taki0112/
AMSGrad-Tensorflow.
15
Published as a conference paper at ICLR 2019
6.2.1	Proof OF Auxiliary Lemmas
Lemma 6.1. Let xo，xι in Algorithm 1, consider the sequence
Zt = xt + [ '1= (xt - xt-1), ∀t ≥ 1.
1 - βι,t
Then thefollowing holds true
(9)
and
zt+1 - Zt
β1,t+1
1 - β1,t+1
at mt/V^
Z2 - Z1
—
β1,t
1 - β1,t
βi,t	∖
1 - β1,tJ
Θ mt-1 - atgth∕Vt,
β1,2
1 - β1,2
β1,1	ʌ
1 - β1,1J
α1 m∖/ vz^1 - a∖g∖/ V7^L
V t > 1
—
Proof. [Proof of Lemma 6.1] By the update rules S1-S3 in Algorithm 1, We have when t > 1,
xt+1 - Xt = -atmt/V^
=-αt(β1,tmt-1 + (1 - β1,t)gt)/pvt
S3.
= β1,t
Qt ʌ/ vt-1
αt-1	√vt
Θ (xt - xt-1) - αt(1 - β1,t)gt/y/vt
β1,t(xt - xt-1) + β1,t
Qt ʌ/ vt-1
αt-1	√v7
-1 ) θ (xt - xt-1) - αt(1 - β1,t)gt/ Jvt
= β1,t(xt - xt-1) - β1,t
at-1
—
^t-1
Θ mt-1 - Qt(1 - β1,t)gt/VZvL	(10)
Since xt+1 - Xt = (1 — β1,t)xt+1 + β1,t(xt+1 — Xt) — (1 — β1,t)xt,basedon(10) we have
(1 - β1,t)xt+1 + β1,t(xt+1 - xt)
=(1 - β1,t)xt + β1,t(xt - xt-1) - β1,t
—
Qt-1
/Vt-1
Θ mt-1 - Qt(1 - β1,t)gt/vz^t.
Divide both sides by 1 - β1,t, we have
xt+1 + 1 万：―(xt+1 - xt)
=xt + 1 尸 1；- (xt - xt-1) -
1 - β1,t
Define the sequence
β1,t
1 - β1,t
—
Qt-I■ ) Θ mt-1 - Qtgt/pVt.	(11)
A-1 /
Then (11) can be written as
Zt = Xt + 1 β1=	(Xt - xt-1).
1 - β1,t
Zt+1 = Zt + (—'1't+1-------^It-) (xt+1 — Xt)
t+1	t + <1 - β1,t+1	1 - β1,t) ( t+1 J
β1,t
1 - β1,t
Qt-1
Θ mt-1 - Qtgt/vz^t
β1,t+1
1 - β1,t+1
—
Qtmt V^t
β1,t	)
1 - β1,t√
Θ mt-1 - Qtgt/vz^t,
β1,t
1 - β1,t
Vt > 1,
16
Published as a conference paper at ICLR 2019
where the second equality is due to xt+ι 一 Xt = -a^mt/√vt.
For t = 1, we have z1 = x1 (due to x1 = x0), and
β1,2
Z2 — Zl =X2 + τ;——W—(X2 — Xi) — Xl
1 一 β1,2
—J βi,2
=X2 +∖1 - βi,2
βi,2
—
—
β1,1
1 ― β:
β1,1
(X2 一 X1 ) +
1 ― β1,2	1 ― β1,1
βi,2	β1,1
—
—
1 ― β1,2	1 ― β1,1
β	尸1,2	β1,1
—
1,1
(―aimi/vz^ι) +
(-αιmι∕√V7) +
1 β1,1(X2 ― Xi) ― Xi
1 ― β1,1
(T⅛ + 1 卜2 F
;--(-(Iai(I — βi,i)gi/Pv1)
1 ― βi,i
1 ― β1,2	1 ― β1,1
(aimi/，V7) ― αιgι∕，V7,
where the forth equality holds due to (S1) and (S3) of Algorithm 1.
The proof is now complete.
Q.E.D.
Without loss of generality, we initialize Algorithm 1 as below to simplify our analysis in what follows,
m0 = 0.
Lemma 6.2. Suppose that the conditions in Theorem 3.1 hold, then
6
E [f(zt+i) ― f(zi)] ≤XTi,
i=i
where
mi-ii
Ti = -E 归"a),
T2 = -E [χaihvf(zi),gi/pv)ɪil,
XhVf(Zi), (1⅛——为i
i=i	1 ― βi,i+i
T3 = E
—
1 ― βi,i
aimi∕vz^)
T4 = E
T5 = E
XX 3 L
⅛ 2
t3
X 2 L
i=i
βi,t+i
—
8i,t
1 ― βi,t+i	1 ― βi,t
atmt∕√vtn
T6 = E
Bi,i
1 一 βi,i
—
ρv⅛! θ mi-iII
二 3 Il	I∣2
X 2 L||aigi/Pvi||
i=i 2
Proof. [Proof of Lemma 6.2] By the LiPsChitZ smoothness of Vf, we obtain
f (zt+i) ≤ f(zt) + hVf(zt),dti + L kdtk2 ,
where dt = zt+i ― zt, and Lemma 6.1 together with (12) yield
dt
αtmt∕ VZvt
βi,t+i
1 — βi,t+i
—
βi,t	ʌ
1 - Bi,J
Θ mt-i - atgt/x/Vt,
∀t ≥ 1.
(12)
(13)
(14)
(15)
(16)
(17)
(18)
(19)
(20)
(21)
17
Published as a conference paper at ICLR 2019
Based on (20) and (21), we then have
t
E[f(zt+1) - f(z1)] =E Xf(zi+1)-f(zi)
i=1
t
≤E XXhVf(zi),dii + Lkdik2
i=1
-E
-E
XX hVf (Zi), 1⅜
i=1	1,i
X aihVfI(Zi},giPi
)
]
mi-1i
i=1
Xt hVf(zi),
i=1
β1,i+1	%
1 - β1,i+1	1 - β1,i
-E
L kdik2
= T1 + T2 + T3 + +E
L kdik2
(22)
—
aimi/ VZvii
where {Ti} have been defined in (14)-(19). Further, using inequality ka+ b+ck2 ≤ 3kak2 + 3kbk2 +
3kck2 and (22), we have
t
E X kdik2	≤ T4+T5+T6.
i=1
Substituting the above inequality into (22), we then obtain (13).
Q.E.D.
The next series of lemmas separately bound the terms on RHS of (13).
Lemma 6.3. Suppose that the conditions in Theorem 3.1 hold, T1 in (14) can be bounded as
TI = -E 归hVf (Zj 1-fc (√⅛ - p⅛) θ mi-1〉
≤H2
ι⅛E Is X
Proof. [Proof of Lemma 6.3] Since kgtk ≤ H, by the update rule of mt, we have kmtk ≤ H, this
can be proved by induction as below.
Recall that mt = β1,tmt-1 + (1-β1,t)gt, suppose kmt-1k ≤ H, we have
kmtk ≤ (β1,t + (1 - β1,t)) max(kgtk, kmt-1k) = max(kgtk, kmt-1k) ≤ H, (23)
then since m0 = 0, we have km0 k ≤ H which completes the induction.
≤H2
βι
1 - βι
E
where the first equality holds due to (12), and the last inequality is due to β1 ≥ β1,i.
The proof is now complete.
Q.E.D.
18
Published as a conference paper at ICLR 2019
Lemma 6.4. Suppose the conditions in Theorem 3.1 hold. For T3 in (16), we have
T3 = -E [χXIyf(Zi), (1 β1,i+1	- τ⅜h) OimiPi
i=1	1 - β1,i+1	1 - β1,i
(β1__________β1,t+1 )
V - βι	1 - β1,t+1 J
(H2 + G2)
Proof. [Proof of Lemma 6.4]
T3 ≤E
Σ
i=1
β1,i+1________%
1 - β1,i+1	1 - β1,i
β1,i+1________%
1 - β1,i+1	1 - β1,i
2 (kVf(zi)k2 + kαimi∕p^^k2)
1 (H 2 + G2)
—
β1,i+1	) 1
1 - β1,i+1 / 2
(H2 + G2)
≤ G⅛--)(H 2+G
where the first inequality is due to ha, bi ≤ 2 (Ilak2 + ∣∣b∣∣2), the second inequality is using due
to upper bound on ∣∣Vf (χt)k ≤ H and ∣∣aimi∕√^^k ≤ G given by the assumptions in Theorem
3.1, the third equality is because β1,t ≤ β1 and β1,t is non-increasing, the last inequality is due to
telescope sum.
This completes the proof.
Lemma 6.5. Suppose the assumptions in Theorem 3.1 hold. For T4 in (17), we have
32LT4=E X ∣( 1 -ex- τ⅛;) αtmt/√vt∣ #
i=1	1,t+1	1,t
≤ (-	βl,t+1 Y G2
~ V - βι	1 - β1,t+1)
Q.E.D.
Proof. [Proof of Lemma 6.5] The proof is similar to the previous lemma.
32LT4 =E
3L
Xt	(
i=1
β1,t+1
Bι,t
1 - β1,t+1	1 - β1,t
2
IIatmt∕√tk
≤E
Xt	(1
i=1
β1,t
- β1,t	1 - β1,t+1
β1
β1,t+1
1 - β1	1 - β1,t+1
≤(-Ji
β1,t+1
)Xt (1
i=1
)2G2
β1,t
β1,t+1
- β1,t	1 - β1,t+1
G2
V 1 - β1	1 - β1,t+1 )
where the first inequality is due to ∣∣atmt∕√vtk ≤ G by our assumptions, the second inequality is
due to non-decreasing property of β1,t and β1 ≥ β1,t, the last inequality is due to telescoping sum.
Q.E.D.
2
3L
This completes the proof.
Lemma 6.6. Suppose the assumptions in Theorem 3.1 hold. For T5 in (18), we have
≤
—
—
—
—
Y G2
—
19
Published as a conference paper at ICLR 2019
Proof. [Proof of Lemma 6.6]
i=2
3LT5 ≤E X「
≤ (1⅛ )2 H 2E
2
t
where the fist inequality is due to β1 ≥ β1,t and (12), the second inequality is due to kmik
This completes the proof.
Lemma 6.7. Suppose the assumptions in Theorem 3.1 hold. For T2 in (15), we have
T2 = -E
< H.
Q.E.D.
■ t
X aihVf (Zi),gi∕p^ii
i=1
t 1
≤ X xkαigi/Pvik2 + L2
i=2 2
t-1
(τ⅛) (τ⅛) E X k…k2
+ L2H2
(占)2(㈡4 EX X
j=1 i=2
i=1
d t-1
td
+ 2H2E IXX
i=2 j=1
d
—
αi-i	\
Pi-IJ j
t
+ 2H 2E Ε(αι∕√^^ j
j=1
-E
E 0“▽f(xi), Vf (xt)/√v7i .
i=1
(24)
Proof. [Proof of Lemma 6.7] Recall from the definition (9), we have
Zi - Xi = 1 βl,i (Xi - Xi-1) = - 1 "； ai-imi-i/Pvi-1
1 -β1,i	1 -β1,i
Further we have z1 = X1 by definition of z1 . We have
(25)
t t	-
T2 = - E XαihVf(Zi),gi∕p^ii
i=1
t t	-
=-E X αihVf(xi),gi∕p^i - E
i=1
The second term of (26) can be bounded as
■ t
X aihVf (Zi)- Vf(Xi),gi/pvɪi
i=1
一 t
-E X α%Nfzi) - Rf"i),gi/Pi
i=1
二 1	CI	LC
≤E £3 kVf (Zi) - Vf (xi)k2 + 2 Ilaigi∕√V7k2
≤JL T7 + 1E
■ t
X kaigi∕Pvik2
i=2
(26)
(27)
2
2
2
4
where the first inequality is because(a, b〉≤ 1 (Ilak2 + kbk2) and the fact that z1 = χ1, the second
inequality is because
kVf(zi) - Vf(xi)k ≤ LkZi- Xik= Lk βl,t ai-imi-i∕Pvi-ik,
1 - β1,t
20
Published as a conference paper at ICLR 2019
and T7 is defined as
t
T7= E X
,i=2
τβr ai-1 mi-1
1 - β1,i
(28)
We next bound the T7 in (28), by update rule mi = β1,im"1 + (1 - β1,igi), we have mi
Pk=1[(∏i=k+1 β1,ι)(1 - β1,k)gk]. Based on that, we obtain
T7 ≤ (T⅛ Y E
X X (ɑ7^ H
i=2 j = 1 ∖ √v"1 √jj
X X (X ɑi-1 (∏i,k + 1 β1,l) (I - β1,k)gk
i=2 j = 1 ∖k = 1
t d	i—1	i—1
XX X ∏ β1,ι) (i-β1,k)(gk)j
i=2 j=1 ∖ k=1 ∖l = k⅛1	)
^Z
T8
X X(X αk (∏i=1+1
i=2 j=1 ∖ k=1
β1,l )(1- β∖,k)9k
{z
T9
(29)
where the first inequality is due to β1,t ≤ β1, the second equality is by substituting expression of mt,
the last inequality is because (a + b)2 ≤ 2(∣∣α∣∣2 + IIbIl2), and we have introduced T⅛ and T9 for ease
of notation.
In (29), We first bound T8 as below
T8 =E
t d i—1 i—1
XXXX
i=2 j = 1k=1p=1
(i)
≤E
t d i—1 i—1
XXXX(βi
i=2 j = 1k=1p=1
(=)E
t d i—1
XXXDiT-k)
i=2 j = 1 k=1
(iii)
≤
1-β
(丝)1 万
——-----E
1 - β1
t d i—1
XXX(βi-1-k)
i=2 j=1 k=1
t—1 d t
XXX (βi-1-k)
k=1j=1i=k+1
t—1	d
2 t-1 d
≤	τ⅛	EXX
1 C k=1j=1
-1-P
■ i —1
∏ β1
.l=k+1
2
E
-t —1
X gigi/pvik2
i=1
(I- β1,p)
,P
(30)
A 了 E
≤2 (Λ了 E
|
+ 2 (二 了 E
I
,
1
E
2
where (i) is due to ab < ɪ(a2 + b2) and follows from β1,t ≤ β1 and β1,t ∈ [0,1), (ii) is due
to symmetry of P and k in the summation, (iii) is because of PP=Il (βiτ-p) ≤ 1⅛, (iv) is
exchanging order of summation, and the second-last inequality is due to the similar reason as (iii).
21
Published as a conference paper at ICLR 2019
For the T9 in (29), We have
2
t
<H 2E
<H 2E
<H 2E
T9 =E
(31)
where the first inequality holds due to βι,k < 1 and |(gk j| < H, the second inequality holds due to
βι,k < βι, and the last inequality applied the triangle inequality. For RHS of (31), using Lemma 6.8
(that will be proved later) with ai
—
O-1-1 , we further have
九-1 Ij
t-1	d i i
T9 <H2E l∑∑	∑βi-fc E
i=1j=1 ∖k=1 l=k+1
<H2
(占EX X
J —1 i — 2
i
ai-1
d t-1
(32)
2
2
Based on (27), (29), (30) and (32), we can then bound the second term of (26) as
■ t	,
E αi"f (Zi)- Pf(Xi),gi/Pi)
i=1
< (Γ⅛)；了E
+L2H 2 (T⅛ )2( T⅛
1 t
+ 2E Egigi/√vik2 .
(33)
,i=2
-E
t
Let us turn to the first term in (26). Reparameterize gt as gt = Vf (Xt) + δt with E[δt] = 0, we have
=E
=E
■	t	-
E ”f (xjgi∕√⅞
i=1
■	t	,
E αihVf (XiuVf(Xi) + δi)∕pi)
i=1
■	t	-
E αihVf (Xi), Vf(Xi)/pi〉+ E
i=1
■	t	-
E αiRf(Xi),δi/p^i .
i=1
(34)
E
22
Published as a conference paper at ICLR 2019
It can be seen that the first term in RHS of (34) is the desired descent quantity, the second term is a
bias term to be bounded. For the second term in RHS of (34), we have
-t	-
E X ”f(Xi),δi∕p^i
i=1
t t	-I r t
=E ^XhVf (Xi),δi Θ (αi/pvi - ai-1/PVi-I)i + E ^X αi-1hNf(Xi),δi Θ (I/PVi-Iyi
+ E hαιhVf(xι),δι∕p^1 R
一 t	d	d
≥E XhVf(Xi),δi Θ (αi∕pVi - ai-i∕PVi-1)i - 2H 2E Xα∖∕0j	(35)
i=2	j=1
where the last equation is because given Xi, ^i-ι, E [δi Θ (1∕y∕Vi-ι)∣Xi, Vi-ι] = 0 and ∣∣δik ≤ 2H
due to kgik ≤ H and kVf(Xi)k ≤ H based on Assumptions A2 and A3. Further, we have
-t	-
E XhVf (Xi),δt Θ (αi∕PVi — α∙i-∖∕pGi-I))
i=2
~ t d	-
=E XX(Vf(XiXj(δt)j(αi∕(p^i)j — αi-i/(PV^；)j)
^ t d	-
≥ — E XX ∣(Vf(Xi))jll(δt)j| ∖(αi∕(pVi)j - αi-i∕(PV-i)j)∣
i=2 j=1
^ t d	-
≥ - 2H2E ^X^X ∣(αi∕(Pvi)j - αi-l∕(Pvi-T)j) ∣	(36)
i=2 j=1
Substituting (35) and (36) into (34), we then bound the first term of (26) as
一 t
-E X aihVf(Xi),gi∕pvi)
i=1
t d	d
≤2H2E XX∣(αi∕(pv^)j - αi-i∕(PV-i)j)∣ +2H2E £(aiIGj
i=2 j=1	j=1
-t	-
-E X aihVf(Xi), Vf(Xi)∕pvi)
i=1
(37)
We finally apply (37) and (33) to obtain (24). The proof is now complete.	Q.E.D.
Lemma 6.8. For ai ≥ 0, β ∈ [0, 1), and bi = Pik=1 βi-k Pli=k+1 al, we have
X b2 ≤ ("I占YX a2
23
Published as a conference paper at ICLR 2019
Proof. [Proof of Lemma 6.8] The result is proved by following
t	ti	i	2
Xbi2=X Xβi-k X al
i=1	i=1 k=1	l=k+1
t i l-1	2 t i	l-1
(=i)X XXβi-kal	=X X βi-l+1al X βl-1-k
,≤,(占 了 X
al β i-m+1am
嗖(占)2 X X Σ LIei-m+1 2 (a2 + am)
“1⅛ J X X X βi-l+1βi-m+1a2 < (1⅛ J 占 X X S+1 a?
i=1 l=2 m=2	l=2 i=l
≤ (占)『丫 X a2
where (i) is by changing order of summation, (ii) is due to Plk-=11 βl-1-k ≤ 1-β, (iii) is by the
fact that ab ≤ 1 (a2 + b2), (iv) is due to symmetry of al and am in the summation, (v) is because
Pm=2 βi-m+1 ≤ ι-β and the last inequality is for similar reason.
This completes the proof.
Q.E.D.
6.2.2	Proof of Theorem 3.1
Proof. [Proof of Theorem 3.1] We combine Lemma 6.2, Lemma 6.3, Lemma 6.4, Lemma 6.5,
Lemma 6.6, and Lemma 6.7 to bound the overall expected descent of the objective. First, from
Lemma 6.2, we have
6
E [f(zt+1)-f(z1)] ≤XTi
i=1
-E
X hW(zi)
i=1
t
Bl,i
，1 — β1,i
—
β1,i
mi-1i -E
■ t
X aihyf (Zi ∖gi/Pi
i=1
-E
Ehw(a),
i=1
β1,i+1
1- β1,i+1	1- β1,i
αimi /∖f^i
+E
β1,t+1
+E
t3
X 3 L
J2
i=1
—
βι,t
1 - β1,t+1	1-β1,t
αtmt∕√Vt^
β1,i
1 - β1,i
X 2 L||aigi/pvi||
i=1
X 3 L
M 2
(38)
24
Published as a conference paper at ICLR 2019
Then from above inequality and Lemma 6.3, Lemma 6.4, Lemma 6.5, Lemma 6.6, Lemma 6.7, We
get
E f(zt+ι)-f(zι)]
≤H 2 i⅛ E
βι
1 - β1	1 - β1,t+1
(τ⅛) H2E E Σ
∖ H	i=2 j = 1
β1,t+1
β1
td
EE
i=2 j = 1
β1,t+1
-βι	1 - β1,t+1
2
G2
t
+ E E $L∣∣aigi∕√vi∣∣
二 1	LC	C
+ E ∑2 gigi∕v^k2 + L
i=2
β1	U
1 - β1 11-
+ L2H2
(占)「E E
,i=1
t-1	d
k=1j=1
d t-1
+ 2H2E ΣΣ
i=2 j=1
td
Qi-1
λ^ i
Vi-1 ) j
+
+
t
—
—
2
2
t
4
t
2
—
d
t
+ 2H2E Ε(αι∕√V7)j - E EaihVf (xi), Vf (xi)∕√V")
j=i
i=1
By merging similar terms in above inequality, we further have
Ε[f(zt+1)- f(zι)]
(βι -	β1,t+1 )
V - βι	1 - βι,t+ι√
(H2 + GA (I⅛
β1,t+1	)2 G2
1 - β1,t+1√
" d	-I	Γ t
+ 2H2E X(αι∕√V1)j - E X%〈▽〃&), ▽"&)/©〉
_j = 1	_|	Li=1
(39)
25
Published as a conference paper at ICLR 2019
Rearranging (39), We have
E
■ t	,
X %"f (χi), Vf (xi)/pvɔ
.i=1
1⅛ +
E
1+L2 J )2( 1⅛ ))2
2L+1+L2
βι
1 - βι ∖1 - βι
t d
XX
i=2j=1
12
—
β1,t+1	)2 g2
1 - β1,t+1√
β1
β1,t+1
1 - βι	1 - βι,t+ι
d
(H2+g2)+g⅛
+ 2H2E ^^(QI/pʃT)j	+ E [f (ZI)- f (zt+1)]
≤E
j=i	_
t	2	t
ci X ||Qtgt/Pvt|| + C2 X
i=1
i=2
Qi-1
Pvi-I
t-1
+ C3 X
1	i=2
+ C4
≤
+
+
+
—
Where
β1
1 - βι ∖1 - βι
CI, (2L+2+L2
1
2
C3 , 1 + L2
1⅛ +
J Y（。寸 H 2（。Y
1 - βιj ∖1 - βι
1⅛)(h 2+G2)+G⅛
∖1-βι
2
G2
+ 2H2E [gι∕√^7∣∣ι] + E[f(z1) - f(z*)]
and z* is an optimal of f, i.e. z* ∈ argmin% f (z).
Using the fact that (αi∕√^^)j ≥ γ⅛, Vj by definition, inequality (4) directly follows.
This completes the proof.
Q.E.D.
6.2.3	Proof OF Corollary 3.1
Proof. [Proof of Corollary 3.1]
Algorithm 3. AMSGrad
(S0)	. Define mo = 0, vo = 0, vo = 0;
For t = 1,…，T,do
(S1)	. mt = βι,tmt-i + (1 - βι,t)gt
(S2)	. vt = β2vt-1 + (1 - β2)g2
(S3)	. vt = max{vt-ι,vt}
(S4)	. xt+1 = xt - Qtmt∕√^?
End
26
Published as a conference paper at ICLR 2019
We first bound non-constant terms in RHS of (3), which is given by
E
CI X ktgj"∣2 + C2 X II √αt=-
t=1	t=2	vt
αt-1
T-1
+ C3 X
t=2
+ C4 .
1
For the term with Ci, assume min7-∈[d] (√v1)j ≥ c > 0 (this is natural since if it is 0, division by 0
error will happen), we have
_T_ II	一∣∣2
E χ∣αtgjPv^∣∣
t=1
T
≤E X kαtgt∕ck2
t=1
T1
≤H2∕c2 X 1 ≤ H2∕c2(1 + logT)
t=1
E XII "I= E
2
kgtk2
where the first inequality is due to (Vt)j ≥ (Vt-i)j, and the last inequality is due to PT=I 1/t ≤
1+logT.
For the term with C2 , we have
E
≤E
dT
Xj=1Xt=2
d
X
j =1
(40)
where the first equality is due to(Vtj ≥ (Vt-i)j and at ≤ αt-ι, and the second equality is due to
telescope sum.
For the term with C3 , we have
where the first inequality is due to ∣(at∕√vt - at-i/y∕^∑1')j| ≤ 1∕c.
Then we have for AMSGRAD,
E Ci X IIαtwp<+C2 XI √⅛- p⅛
≤C1H2∕c2(1+logT) + C2d∕c + C3(d∕c)2 +C4
T-i
+ C3 X
t=2
+ C4
(41)
Now we lower bound the effective stepsizes, since ^ is exponential moving average of g2 and
IlgtIl ≤ H, we have (Vt)j ≤ H2, we have
α∕(pvt)j ≥ H√t
i
27
Published as a conference paper at ICLR 2019
And thus
■ T
E X”f(xt), Vf(Xt)/p^ti
t=1
工 1	J	√T	.	…
≥ E XH√tkVf(χt)k2 ≥ HT-m[T]E [kvf(Xt)k2]
t=1	(42)
Then by (3), (41) and (42), we have
ɪ√T min E [kVf(xt)k2] ≤ CiT2∕c2(1 + logT) + C?d/c + C3d∕c2 + C4
H	t∈[T]
which is equivalent to
min E [kVf(xt)k2
t∈[T]
T
≤ √^ (CiT /c (1 + logT) + C2d∕c + C3d∕c + C4)
=√T (QI + q2 log T)
One more thing is to verify the assumption ∣∣atmt∕√vtk ≤ G in Theorem 3.1, since
αt+ι∕(√^t+ι)j ≤ αt∕(√vt)j and αι∕(√^1)j ≤ 1∕c in the algorithm, we have IIatmt∕√^t∣ ≤
∣mt∣∕c ≤ T∕c.
This completes the proof.	Q.E.D.
6.2.4 Proof of Corollary 3.2
Proof. [Proof of Corollary 3.2]
Algorithm 4. AdaFom
(S0)	. Define m0 = 0, Vo = 0;
For t = 1,…，T,do
(S1)	. mt = β1,tmt-1 + (1 - β1,t)gt
(S2)	. Vt = (1 - 1∕t)vt-ι + (1∕t)g2
(S3)	. xt+i = Xt - amt∕√Vt
End
The proof is similar to proof for Corollary 3.1, first let’s bound RHS of (3) which is
E
T	2	T
CI XMgt/臼 + C2 Xi √v= —
αt-i
T-i
+ C3 X
t=2
+ C4
i
We recall from Table 1 that in AdaGrad, Vt = t Pt=i g2. Thus, when at = 1∕√t, We ob-
tain at∕√Vt = 1/Pt=ιg2. We assume min7-∈[d] |(gij| ≥ c > 0, which is equivalent to
min7∙∈[d] (√^1)j ≥ c > 0 (a requirement of the AdaGrad). For Ci term we have
E "x "T=U IqPh J=E &X ⅛ 1
≤E X (1 — log((gi)2) + log X(gt)2!j ≤ d(1 — log(c2) + 2 log T + log T)
where the third inequality used Lemma 6.9 and the last inequality used ∣gt ∣ ≤ T and
minj∈[d] |(gi)j| ≥ c > 0.
28
Published as a conference paper at ICLR 2019
For C2 term we have
For C3 term we have
where the first inequality is due to ∣(αt∕√^ - αt-ι/y∕^-1')j| ≤ 1/c.
Now We lower bound the effective stepsizes αt∕(√^),
αt =	1	≥ ɪ
(G qpt=i(gi)2 - H√t'
where we recall that at = 1∕√t and ∣∣gtk ≤ H. Following the same argument in the proof of
Corollary 3.1 and the previously derived upper bounds, we have
√T
匕 min E [∣Nf (Xt)Il2] ≤ Cιd(1 - log(c2) + 2logH + logT) + C2d∕c + C3d∕c2 + C4
H t∈[T]
which yields
min E [kvf(xt )k2]
t∈[T]
H
≤ √^ (Cιd(1 -Iog(C )+2 log H + log T) + C2d∕c + C3d∕c + C4)
=√t (QI + Q2log T)
The last thing is to verify the assumption ∣∣atmt∕√vtk ≤ G in Theorem3.1, since at+∖∕( yJV+∖ )j ≤
at∕(√vt)j and a∖∕(√v7)j ≤ 1∕c in the algorithm, we have ∣∣atmt∕√7^t∣∣ ≤ ∣mt∣∕c ≤ H∕c.
This completes the proof.	Q.E.D.
Lemma 6.9. For at ≥ 0 and Pit=1 ai 6= 0, we have
TT
P PTt— ≤ 1 - log aι + log E ai.
t=1	i=1 ai	i=1
Proof. [Proof of Lemma 6.9] We will prove itby induction. Suppose
T-1	T-1
P P^一 ≤ 1 - log aι + log E a，i,
t=1	i=1 ai	i=1
we have
T	T-1	T-1
XPa-=+ + XPa- ≤ + + 1 - log aι + log X ai.
t=1	i=1 ai	i=1 ai	t=1	i=1 ai	i=1 ai	i=1
29
Published as a conference paper at ICLR 2019
Applying the definition of concavity to log(x), with f (z) , log(z), we have f(z) ≤ f (z0) +
f0(z0)(z - z0), then substitute z = x - b, z0 = x, we have f(x - b) ≤ f(x) + f0(x)(-b) which is
equivalent to log(x) ≥ log(x - b) + b/x for b < x, using x = PiT=1 ai, b = aT, we have
T	T-1
log ai ≥ log ai +
i=1	i=1
aT
P= a
and then
T	T -1	T
Xat	aT
P~~— ≤ P——-+ 1 - log ai + log 2 a ≤ 1 - log ai + log 与 a ∙
Now it remains to check first iteration. We have
a1
a1
1 ≤ 1 - log(a1) + log(a1) = 1
This completes the proof.
Q.E.D.
30