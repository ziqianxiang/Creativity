Published as a conference paper at ICLR 2019
Generative predecessor models for sample-
EFFICIENT IMITATION LEARNING
Yannick Schroecker*
College of Computing
Georgia Institute of Technology
Atlanta, USA
yannickschroecker@gatech.edu
Mel Vecerik & Jonathan Scholz
DeepMind
London, United Kingdom
{vec,jscholz}@google.com
Ab stract
We propose Generative Predecessor Models for Imitation Learning (GPRIL), a
novel imitation learning algorithm that matches the state-action distribution to the
distribution observed in expert demonstrations, using generative models to reason
probabilistically about alternative histories of demonstrated states. We show that
this approach allows an agent to learn robust policies using only a small number of
expert demonstrations and self-supervised interactions with the environment. We
derive this approach from first principles and compare it empirically to a state-
of-the-art imitation learning method, showing that it outperforms or matches its
performance on two simulated robot manipulation tasks and demonstrate signifi-
cantly higher sample efficiency by applying the algorithm on a real robot.
1	Introduction
Training or programming agents to act intelligently in unstructured and sequential environments is
a difficult and central challenge in the field of artificial intelligence. Imitation learning provides
an avenue to tackle this challenge by allowing agents to learn from human teachers, which consti-
tutes a natural way for experts to describe the desired behavior and provides an efficient learning
signal for the agent. It is thus no surprise that imitation learning has enabled great successes on
robotic (Chernova and Thomaz, 2014) as well as software domains (e.g. Aytar et al. (2018)). Yet,
key challenges in the field are diverse and include questions such as how to learn from observations
alone (e.g. Aytar et al. (2018)), learning the correspondence between the expert’s demonstrations
and the agent’s observations (e.g. Sermanet et al. (2017)) as well as the question of how to integrate
imitation learning with other approaches such as reinforcement learning (e.g. Vecerik et al. (2017)).
However, at the core of the imitation learning problems lies the challenge of utilizing a given set
of demonstrations to match the expert’s behavior as closely as possible. In this paper, we approach
this problem considering the setting where the set of expert demonstrations is given up-front and the
dynamics of the environment can only be observed through interaction.
In principle, imitation learning could be seen as a supervised learning problem, where the demon-
strations are used to learn a mapping from observed states to actions. This solution approach is
known as behavioral cloning. However, it has long been known that the sequential structure of the
task admits more effective solutions. In particular, the assumptions made in supervised learning are
restrictive and don’t allow the agent to reason about the effect of its actions on it’s future inputs. As
a result, errors and deviations from demonstrated behavior tend to accumulate over time as small
mistakes lead the agent to parts of the observation space that the expert has not explored (Ross and
Bagnell, 2010). In this work, we propose a novel imitation learning algorithm, Generative Prede-
cessor Models for Imitation Learning (GPRIL), based on a simple core insight: Augmenting the
training set with state-action pairs that are likely to eventually lead the agent to states demonstrated
by the expert is an effective way to train corrective behavior and to prevent accumulating errors.
Recent advances in generative modeling, such as Goodfellow et al. (2014); Kingma and Welling
(2013); Van Den Oord et al. (2016b;a); Dinh et al. (2016), have shown great promise at model-
ing complex distributions and can be used to reason probabilistically about such state-action pairs.
*This work was carried out at DeePMind.
1
Published as a conference paper at ICLR 2019
Specifically, we propose to utilize Masked Autoregressive Flows (Papamakarios et al., 2017) to
model long-term predecessor distributions, i.e. distributions over state-action pairs which are condi-
tioned on a state that the agent will see in the future. Predecessor models have a long history in rein-
forcement learning (e.g. Peng and Williams (1993)) with recent approaches using deep networks to
generate off-policy transitions (Edwards et al., 2018; Pan et al., 2018) or to reinforce behavior lead-
ing to high-value states (Goyal et al., 2018). Here, we use predecessor models to derive a principled
approach to state-distribution matching and propose the following imitation learning loop:
1.	Interact with the environment and observe state, action as well as a future state. To encode
long-term corrective behavior, these states should be multiple steps apart.
2.	Train a conditional generative model to produce samples like the observed state-action pair
when conditioned on the observed future state.
3.	Train the agent in a supervised way, augmenting the training set using data drawn from the
model conditioned on demonstrated states. The additional training data shows the agent
how to reach demonstrated states, enabling it to recover after deviating from expert behav-
ior.
In the above, we laid out the sketch ofan algorithm that intuitively learns to reason about the states it
will observe in the future. In section 3, we derive this algorithm from first principles as a maximum
likelihood approach to matching the state-action distribution of the agent to the expert’s distribu-
tion. In section 4, we compare our approach to a state-of-the-art imitation learning method (Ho and
Ermon, 2016) and show that it matches or outperforms this baseline on our domains while being
significantly more sample efficient. Furthermore, we show that GPRIL can learn using demon-
strated states alone, allowing for a wider variety of methods to be used to record demonstrations.
Together these properties are sufficient to allow GPRIL to be applied in real-world settings, which
we demonstrate in section 4.3. To our knowledge this is the first instance of dynamic, contact-rich
and adaptive behavior being taught solely using the kinesthetic-teaching interface of a collaborative
robot, without resorting to tele-operation, auxiliary reward signals, or manual task-decomposition.
2 Background
2.1 Markov decision processes without rewards
As is usual, we model the problem as a Markov decision process without reward. That is, given
state and action sets S , A, the agent is observing states s ∈ S and taking actions a ∈ A. In this
work, We use S and a to refer to states and actions observed during self-supervision and S ∈ S
and a ∈ A to refer to target and demonstration states and actions. We furthermore use superscripts
s(i),a(i) to refer to specific instances, e.g. specific demonstrated state-action pairs, and subscripts,
e.g. st, at, to indicate temporal sequences. The observed transitions are guided by the Markovian
dynamics of the environment and the probability of transitioning from state s to state s0 by taking
action a is denoted as p(st+1 = s0|st = s, at = a). The agent’s behavior is defined by a station-
ary parametric policy ∏θ(a|s) while the expert,s behavior is modeled by a stationary distribution
∏*(a∣s). We denote as d∏(S) the probability of observing state S at time-step t when following
policy π. Under the usual ergodicity assumptions, each such policy induces a unique stationary
distribution of observed states dπ (S) = limt→∞ dtπ (S) as well as a stationary joint state-action dis-
tribution ρπ(s, a) := π(a∣s)dπ(s). Furthermore, we use q∏ to refer to the dynamics of the time
reversed Markov chain induced by a particular policy π at time-step t
qt (2 * * st = s,at = a|st+1 = S ) = dt+1 (s ) dt(s)π(at∖st)p(st+1 = S |st = s,at = a)	(1)
and define qπ(St = S, at = a|St+1 = S0) := limt→∞ qtπ (St = S, at = a|St+1 = S0). For the
purposes of this work, we handle the episodic case with clear termination conditions by adding
artificial transitions from terminal states to initial states. This creates a modified, ergodic MDP with
identical state-distribution and allows us to assume arbitrarily large t such that qtπ = qπ . Finally, we
extend this notation to multi-step transitions by writing qπ(St = S, at = a∖St+j = S0).
2.2 Imitation learning
In this work, we are considering two settings of imitation learning. In the first setting, the
agent is given a set of observed states s(1), s(2), ∙ ∙ ∙ , s(n) and observed corresponding actions
2
Published as a conference paper at ICLR 2019
a(1),a(2),…，a(N) as expert demonstrations. The goal in this setting is to learn a policy ∏θ that
matches the expert’s behavior as closely as possible. In the second setting, the agent is given the
states observed by the expert but is not aware of the actions the expert has taken. Recent years have
seen heightened interest in a related setting where to goal is to track expert state trajectories (Zhu
et al., 2018; Peng et al., 2018; Pathak et al., 2018). These approaches do not learn general policies
that can adapt to unseen situations. A straightforward approach to train general policies in the first
setting, usually referred to as behavioral cloning, is to treat the task as a supervised learning problem
(e.g. Pomerleau (1989)). However, as outlined in section 1, predictions made by ∏θ(a|s) influence
future observations thus violating a key assumption of supervised learning, which states that inputs
are drawn from an i.i.d. distribution. This has formally been analyzed by Ross et al. who introduce
a family of algorithms (e.g. Ross and Bagnell (2010); Ross et al. (2011)) that provably avoid this
issue. However, these approaches require the expert to continuously provide demonstrations and
thus are not applicable when the set of demonstrations is assumed to be fixed. A popular avenue
of research that considers this setting is inverse reinforcement learning (IRL). Inverse reinforcement
learning (Ng and Russell, 2000) aims to learn a reward function for which ∏* is optimal and thus
captures the intent of the expert. The arguably most successful approach to IRL aims to match the
state-action distribution to that of the demonstrations (Ziebart et al., 2008) with recent approaches
extending these ideas to the model free case (Boularias et al., 2011; Finn et al., 2016; Fu et al., 2018).
However, inverse reinforcement learning is indirect and ill-defined as many reward functions induce
the same behavior. Recently, methods have been proposed that aim to match state-action distribu-
tions directly and achieve state-of-the-art result without learning a reward function first. Generative
Adversarial Imitation Learning (GAIL) (Ho and Ermon, 2016) uses an adversarial objective, training
a discriminator to identify demonstrations and using TRPO to train a policy that fools the discrim-
inator. While GAIL is able to achieve impressive results, the adversarial objective can make the
learning procedure unstable and unpredictable. This is especially true when parts of the state-space
are not under the agent’s control, yielding a setting resembling a conditional GAN (Mirza and Osin-
dero, 2014), which are prone to issues such mode collapse (Odena et al., 2017). We compare our
approach with GAIL in section 4. State Aware Imitation Learning (SAIL) (Schroecker and Isbell,
2017) is an alternative method that aims to learn the gradient of the state-action distribution using
a temporal-difference update rule. This approach is able to avoid instabilities prompted by the ad-
versarial learning rule but is only applicable to policies with a small number of parameters where
learning a representation of the gradient is feasible. In this work, we follow a gradient descent
approach similar to SAIL but estimate the gradient without representing it explicitly by a neural net-
work. These methods can also be used to match state-distributions without actions. While the order
of states is unspecified and the induced policy is therefore not unique, including transition informa-
tion such as velocities can allow the agent to learn solely from expert state trajectories nonetheless.
2.3 Generative models
Recent years have seen great advances in deep generative models. A variety of approaches such as
Generative Adversarial Networks (Goodfellow et al., 2014), Variational Auto Encoders (Kingma
and Welling, 2013), autoregressive networks (e.g. Germain et al. (2015); Van Den Oord et al.
(2016b;a) and normalizing flows (Dinh et al., 2016) have been proposed which enable us to learn
complex distributions and efficiently generate samples. In this work, we use generative mod-
els to model the distribution of long-term predecessor state-action pairs. While the approach
we propose is model agnostic, we choose to model this distribution using masked autoregressive
flows (Papamakarios et al., 2017) (MAF). MAFs are trained using a maximum likelihood ob-
jective, which allows for a stable and straight-forward training procedure. Autoregressive mod-
els are capable of representing complex distributions p(x); x ∈ Rn by factoring the distribution
p(x) = p1(x1) QiN=-11 pi+1(xi+1 |x1, . . . , xi) and learning a model for each pi. In this paper, we
model each Xi to be distributed by Xi 〜 N(∙∣μi, σi) where each μ% and σi is a function of x±i-ι.
Masked autoencoders (Germain et al., 2015) provide a straight-forward approach to parameter shar-
ing and allow representing these functions using a single network. MAFs stack multiple autoregres-
sive models with different orderings and thus avoid the strong inductive bias imposed by the order
of variables. Using the reparameterization trick, the autoregressive model can be seen as a determin-
istic and invertible transformation of a random variable: X = f (Z) := μ + σz; Z 〜 N(∙∣0,1). The
change of variable formula then allows us to calculate the density of X:
log p(X) = log pN (f -1 (X)) + logdet(|J(f-1(X))|)	(2)
3
Published as a conference paper at ICLR 2019
Algorithm 1 Generative Predecessor Models for Imitation Learning (GPRIL)
1:	function GPRIL(NB, Nn ,B (batch Size))
2:	for i _ 0..#Iterations do
3:	for k - 0..Nb do
4:	for n _ 0..B do
5:	Sample s(tn) , a(tn) from replay buffer
6:	Sample j 〜Geom(I — Y)
7:	Sample s(tn+)j from replay buffer
8:	Update ωs using gradient Pn=O Vωs log BS(Stn) ∣s(+j)
9:	Update ωa using gradient Pn=O Vωa log Baa (atn)∣stn), s(+j)
10:	for k - 0..N∏ do
11:	for n - 0..B do
12:	Sample s(n), a(n) from expert demonstrations
13:	Sample s(n) ~Bωs (•|s(n)), a(n) ~Baa (∙∣s(n), s(n))
14:	Update θ using gradient PB=O β∏Vθ log∏θ(a(n)|s(n)) + βdVθ log∏θ(a(n)|s(n))
Where the autoregressive nature of f in eq. 2 allows for tractable computation of the second term.
MAFs chain multiple such transformations to derive highly expressive explicit density models able
to model complex dynamics between target states and long-term predecessor state-action pairs.
3 GPRIL
In section 1, we provided an intuitive framework for using predecessor models to augment our train-
ing set and achieve robust imitation learning from few samples. In this section, we will derive this
algorithm based on state-action distribution matching. To this end, we first derive the gradient of
the logarithmic state distribution based on samples from a long-term predecessor distribution that
we will define below. In section 3.2, we describe how to train a generative model of the predecessor
distribution, which will allow us to evaluate this gradient. Ascending on this gradient evaluated
at demonstrated states leads the agent to stick to those states and thus provides a corrective mea-
sure (Schroecker and Isbell, 2017). Furthermore, reproducing the states of the expert can be suffi-
cient to achieve the correct behavior if the state-space is chosen appropriately as we will show in
section 4. We will show how to use this gradient to match state-action-distributions in section 3.3.
3.1	Estimating the gradient of the state distribution
Here, we will show that the samples drawn from a long-term predecessor distribution conditioned on
S enable US to estimate the gradient of the logarithmic state distribution Vθ log dπθ (S) and, later, to
match the agent’s state-action-distribution to that of the expert. To achieve this goal, we can utilize
the fact that the stationary state distribution of a policy can be defined recursively in terms of the
state distribution at the previous time step, similar to Morimura et al. (2010):
dπθ (S)
J dπθ (s)∏θ(a∣s)p(st+ι = S|St = s, at = a)ds, a.
(3)
Taking the derivative shows that this notion extends to the gradient as well as its logarithm:
Vθ dπθ (S) = / ρπθ (s,a)p(st+ι =
Vθ log dπθ (S) = / qπθ (St = s,at
S|St = s, at = a)(Vθ log dπθ (s) + Vθ log∏θ(a∣S)) dS, a
a∣st+ι = S)(Vθ log dπθ (S) + Vθ log∏θ(a∣s)) ds,a
(4)
(5)
The recursive nature of this gradient then allows us to unroll the gradient indefinitely. However, this
process is cumbersome and will be left for appendix A. We arrive at the following equality:
Vθ log dπθ (S)
T
Tl→im∞ Xj=0 qπθ(
S,at = a∣St+j+ι = S)Vθ log ∏(a∣S)dS,
(6)
a
The derivation of our approach now rests on two key insights: First, in ergodic Markov chains, such
as the ones considered in our setting, decisions that are made at time t affect the probability of seeing
4
Published as a conference paper at ICLR 2019
state S at time t + j more strongly if j is small. In the limit, as j → ∞, the expectation of the gradient
Vθlog∏θ(at∣st) vanishes and the decision at time t only adds variance to the gradient estimate.
Introducing a discount factor γ similar to common practice in reinforcement learning (Sutton and
Barto, 1998) places more emphasis on decisions that are closer in time and can thus greatly reduce
variance. We explore this interpretation further in appendix C. Second, by introducing a discount
factor, the effective time-horizon is now finite. This allows us to replace the sum over all states and
actions in each trajectory with a scaled expectation over state-action pairs. Formally, we can write
this as follows and arrive at our main result:
Vθ log dπθ (S)
Z∞
X γjqπθ (St
j=0
s, at = a∣st+j+ι = S)Vθ log ∏(a∣s)ds.
(7)
a
H Es,a〜B∏θ(∙,∙∣S) [Vθ log∏θ(a|s)]
where Bπθ corresponds to the long-term predecessor distribution modeling the distribution of states
and actions that, under the current policy ∏θ , will eventually lead to the given target state S:
∞
Bπθ(s, a|s) ：= (1 — Y) XYjqπθ(St = s,at = a∣st+j+ι = S)	(8)
j=0
3.2	Long-term generative predecessor models
In the previous section, we derived the gradient of the logarithm of the stationary state distribution
as approximately proportional to the expected gradient of the log policy, evaluated at samples ob-
tained from the long-term predecessor distribution Bπθ . In this work, we propose to train a model
Bωθ to represent Bπθ and use its samples to estimate Vθ log dπθ (S). However, rather than unrolling
a time-reversed Markov model in time, which is prone to accumulated errors, we propose to use a
generative model to directly generate jumpy predictions. We have furthermore found that impos-
ing a sensible order on autoregressive models achieves good results and thus propose to use two
conditional MAFs (Papamakarios et al., 2017) Bωs , Bωa in a factored representation:
Bωθ (S,a∣S) := BωS (S∣S)B^a (a∣S,S).	(9)
To train this model, we collect training data using self-supervised roll-outs: We sample states, ac-
tions and target-states where the separation in time between the state and target-state is selected
randomly based on the geometric distribution parameterized by Y as a training set for Bωπθ .
Training data for Bωs s , Bωaa are obtained by executing the current policy to obtain a sequence
so, ao, S1,a1, •…，which We store in a replay buffer. In practice, We store data from multiple it-
erations in this buffer in order to decrease the variance of the gradient. While our algorithm does not
explicitly account for off-policy samples, we found empirically that a short replay buffer does not
degrade final performance while significantly improving sample efficiency. To obtain a training sam-
ple, We first pick S = St and a = at for a random t. We now select a future state S = st+j+ι from
that sequence. For any particular st+j+ι we now have s, a 〜 q∏θ(St = ∙, at = ∙∖st+j+ι = S) ≈
qπθ (St = ∙, at = ∙∖St+j+ι = S). Note that in the episodic case, we can add transitions from terminal
to initial states and pick t to be arbitrarily large such that the approximate equality becomes exact
(as outlined in section 2.1). In non-episodic domains, we find the approximation error to be small
for most t. Finally, we choose j at random according to a geometric distribution j 〜Geom(I 一 γ)
and have a training triple s, a, S that can be used to train B2a and B^s as it obeys
∞
S,a 〜(I-Y) X Yjqπθ (St = ∙,at = ∙|St+j+1=S)= Bπθ (∙, ∙∖S).	(10)
j=0
3.3 Matching state-action distributions with GPRIL
State-action distribution matching has been a promising approach to sample-efficient and robust
imitation learning (see section 2.2). While each policy induces a unique distribution of states and
behavioral cloning would therefore be sufficient in the limit, it is sub-optimal the case of limited
data. Matching the joint-distribution directly ensures that we minimize discrepancies between ev-
erything we observed from the expert and the behavior the agent exhibits. In this work, we propose
5
Published as a conference paper at ICLR 2019
(a)
名E」SS①Jns
1.0 I ,	—
----GPRIL
0.8- ----- GAIL
-巴 ssəjns
(b)
Number of self-supervised episodes	Number of demonstrations
(c)	(d)
Figure 1: a) Depiction of the clip-insertion task. b) Median final success rate and interquartile range
out of 100 roll-outs over 8 seeds. GPRIL achieves the highest success rate followed by GAIL. c)
Median final success rate and IQR on clip insertion comparing sample efficiency. GPRIL is able to
solve the task using several orders of magnitude fewer environment interactions. d) Comparison on
clip insertion trained on states alone. Learning from states alone only slightly affects performance.
a maximum likelihood based approach, ascending on the estimated gradient of the joint distribution:
▽o log ρπθ (s,a) = Vθ log ∏θ (a|s) + Vθ log dπθ (s).	(11)
where Vθ log πθ (a|s) can be computed directly by taking the gradient of the policy using the demon-
strated state-action pairs and Vθ log dπθ (S) can be evaluated using samples drawn from BJθ (∙, ∙∣s)
according to equation 7. We introduce scaling factors βπ and βd to allow for finer control, interpo-
lating between matching states only (βπ = 0) and behavioral cloning (βd = 0) and have:
▽o log ρπθ (s, a) ≈ β∏ log ∏o(a|s) + βdEs,a〜B∏θ "•⑸[▽ log ∏θ(a|s)].	(12)
Here, higher values of βπ provide more supervised guidance while lower values aim to prevent ac-
cumulating errors. This gives rise to the full-algorithm: We fill the replay buffer by asynchronously
collecting experience using the current policy. Simultaneously, we repeatedly draw samples from the
replay buffer to update the predecessor models and use expert samples in combination with an equal
number of artificial samples to update the policy. This procedure is described fully in algorithm 1.
4	Experiments
To evaluate our approach, we use a range of robotic insertion tasks similar to the domains introduced
by Vecerik et al. (2017) but without access to a reward signal or, in some cases, expert actions.
We choose these domains both for their practical use, and because they highlight challenges faced
when applying imitation learning to the real world. Specifically, collecting experience using a robot
arm is costly and demands efficient use of both demonstrations and autonomously gathered data.
Furthermore, insertion tasks typically require complex searching behavior and cannot be solved by
open-loop tracking ofa given demonstration trajectory when the socket position is variable. We first
compare against state-of-the-art imitation learning methods on a simulated clip insertion task, then
explore the case of extremely sparse demonstrations on a simulated peg insertion task and finally,
demonstrate real-world applicability on its physical counterpart.
4.1	Clip insertion
In the first task, a simulated robot arm has to insert an elastic clip into a plug, which requires the robot
to first flex the clip in order to be able to insert it (see figure 1a). In real-world insertion tasks, the
6
Published as a conference paper at ICLR 2019
(a)
①E SS①ɔɔrɪs
0.2-
0.8-
6 4
• •
O O
SS①uɔns
0.2	0.4	0.6	0.8	1.0
Iterations (TRPO)	×104
1.0
0.2 -
0.8-
0.2	0.4	0.6	0.8
Iterations (gradient descent) ×106
0.0
0.0
(b)
(d)
(e)
Figure 2: a) Depiction of the peg insertion task b) Average success rate and 95% confidence in-
terval of GAIL with 25 demonstrations across 10 runs (evaluated over 100 roll-outs). c) Average
success rate of GPRIL across 5 seeds. Unlike GAIL, the performance of GPRIL doesn’t drop off
when provided with only final states. d) Average success rate and confidence interval of GPRIL.
Final performance after 106 iterations increases steadily as the number of demonstrated trajectory
increases but is unaffected by dropping steps from each demonstration. e) Median length and IQR of
trajectories that are successfully inserting the peg. Providing only final states is significantly faster.
f) Best seed performance on both variations of peg insertion on the real robot.
(c)
SS①8ns P①①SjS①ω
Number of self-supervised episodes X103
⑴
pose of the robot, the socket, or the grasped object may vary. We capture this variability by mounting
the socket on a pan-tilt unit, which is randomized by ±0.8 (pan) and ±0.2 radians (tilt). To perform
this behavior, the robot observes proprioceptive features, specifically joint position, velocity and
torques as well as the position of the end-effector and the socket orientation as a unit quaternion.
The task terminates when the robot leaves the work-space, reaches the goal, or after 50 seconds.
For comparative evaluation, we train a policy network to predict mean and variance, modelling a
multivariate normal distribution over target velocities and train it using GPRIL, GAIL as well as be-
havioral cloning. We record expert demonstrations using tele-operation and normalize observations
based on the recorded demonstrations. We then train GPRIL using a single asynchronous simulation
and compare against the open source implementation of GAIL1 for which we use 16 parallel simu-
lations. We select the best hyper parameters for GAIL found on a grid around the hyperparameters
used by Ho and Ermon (2016) but lower the batch size to 256 as it increases the learning speed and
accounts for the significantly slower simulation of the task. We furthermore enable bootstrapping
regardless of whether or not the episode terminated. As all discriminator rewards are positive, han-
dling terminal transitions explicitly can induce a bias towards longer episodes. This is beneficial in
the domains used by Ho and Ermon but harmful in domains such as ours where the task terminates
on success. A detailed list of hyper-parameters can be found in appendix B.
We report final results after convergence and can see in figure 1b that both GAIL and GPRIL out-
perform behavioral cloning, indicating that generalizing over state-action trajectories requires fewer
demonstrations than generalizing over actions alone. Furthermore, we observe a higher success rate
using GPRIL and find that policies trained using GPRIL are more likely to retry insertion if the
robot slides the clip past the insertion point. To compare sample efficiency of GPRIL to GAIL, we
limit the rate at which the asynchronous actor is collecting data. While sample efficiency of GAIL
could be increased by decreasing batch size or increasing various learning rates, we found that this
can lead to unstable learning performance while reducing the amount of samples required by only
a small amount. As can be seen in figure 1c, GPRIL requires several orders of magnitudes fewer
environment interactions to learn this task. Finally, we evaluate the case where the expert’s actions
1https://github.com/openai/baselines/tree/master/baselines/gail
7
Published as a conference paper at ICLR 2019
are unknown. Since the state-space includes information about joint velocities as well as positions,
we find that matching the state-distribution is sufficient to solve the task. GPRIL can achieve this by
setting βd = 1 and βπ = 0 . As can be seen in figure 1d, performance deteriorates only marginally
with a similar difference in performance between both methods.
4.2	Peg insertion with partial demonstrations
The second task is a simulated version of the peg-insertion task depicted in figure 2a. In this task, the
robot has to insert the peg into the hole, which is again mounted on a pan-tilt that randomly assumes
pan and tilt angles varying by 0.4 and 0.1 respectively. Hyperparameters are largely identical and
we report minor differences in appendix B. Observation and action space are identical with the
exception of the omission of torques from the observation space as they are not necessary to solve
this task. We use this task to evaluate the performance of GAIL and GPRIL when learning from
only a very limited set of demonstrated states. To this end, we compare three different scenarios in
which the demonstrations are sparsified to varying degrees: In the first case, the agent has access
to the full state-trajectories of the expert, in the second only every tenth state is available and in the
third the agent sees only the final state of each of the 25 trajectories. Being able to learn from only
partial demonstrations is a useful benchmark for the effectiveness of imitation learning methods but
can also provide a convenient way of providing demonstrations and can free the agent to find more
optimal trajectories between states (see for example Akgun et al. (2012); Schroecker et al. (2016)).
As can be seen in figures 2d and 2e, GPRIL achieves similar final success rates in all three scenarios
while being able to learn a significantly faster insertion policy when learning from final states alone.
We find that in the first two scenarios, this holds for GAIL as well as can been in figure 2b while in
the third case, GAIL becomes highly unstable and the resulting performance can vary wildly, leading
to a low average success rate. We hypothesize that these instabilities are a result of the discriminator
overfitting to the very small amount of negative samples in its training data.
4.3	Peg insertion on a physical system
In previous sections we demonstrated sample-efficiency that indicates applicability of GPRIL to
real-world physical systems. To test this, we evaluate our approach on two variations of the physi-
cal peg-insertion task depicted in figure 2a, involving a physical pan-tilt unit which is fixed in one
scenario and has pan and tilt angles varying by 0.1 and 0.02 radians in the second scenario. For
each scenario, we provide 20 demonstrations using kinesthetic teaching, which constitutes a natural
way of recording demonstrations but provides state-trajectories only (Chernova and Thomaz, 2014).
Hyper-parameters are altered from section 4.2 to trade off a small margin of accuracy for higher
learning speeds and are reported in appendix B. Note, however, that tuning hyper-parameters pre-
cisely is very difficult on a physical system. As can be seen in figure 2f, GPRIL is able to learn a
successful insertion policy that generalizes to unseen insertion angles using just a few hours of envi-
ronment interactions2. We report best-seed performance as we observe a high amount of variability
due to factors outside the agent’s control, such as the pan-tilt unit not reporting accurate information
after physical contact with the robot. However, we wish to point out that the increased difficulty due
to less predictable control is also likely to introduce additional variance that could be reduced fur-
ther with careful design of exploration noise and other hyper-parameters. We furthermore provide a
video of the training procedure and final policy to highlight the efficiency of our method3.
5	Conclusion
We introduced GPRIL, a novel algorithm for imitation learning which uses generative models to
model multi-step predecessor distributions and to perform state-action distribution matching. We
show that the algorithm compares favorably with state-of-the-art imitation learning methods, achiev-
ing higher or equivalent performance while requiring several orders of magnitude fewer environment
samples. Importantly, stability and sample-efficiency of GPRIL are sufficient to enable experiments
on a real robot, which we demonstrated on a peg-insertion task with a variable-position socket.
2Total time to collect and train on 2000 roll-outs was 18.5 and 16.5 hours on the fixed and changing versions
of the task respectively. However, GPRIL converged to good policies significantly sooner.
3https://youtu.be/Dm0OCNujEmE
8
Published as a conference paper at ICLR 2019
References
Akgun, B., M. Cakmak, J. W. Yoo, and A. L. Thomaz
2012. Trajectories and keyframes for kinesthetic teaching: a human-robot interaction perspective.
In International Conference on Human-Robot Interaction, Pp. 391-398.
Aytar, Y., T. Pfaff, D. Budden, T. L. Paine, Z. Wang, and N. de Freitas
2018. Playing hard exploration games by watching YouTube. arXiv preprint arXiv:1805.11592.
Boularias, A., J. Kober, and J. Peters
2011.	Relative entropy inverse reinforcement learning. In Proceedings of the Fourteenth Interna-
tional Conference on Artificial Intelligence and Statistics, Pp. 182-189.
Chernova, S. and A. L. Thomaz
2014.	Robot learning from human teachers. Synthesis Lectures on Artificial Intelligence and
Machine Learning, 8(3):1-121.
Dinh, L., J. Sohl-Dickstein, and S. Bengio
2016. Density estimation using Real NVP. arXiv preprint arXiv:1605.08803.
Edwards, A. D., L. Downs, and J. C. Davidson
2018. Forward-backward reinforcement learning. arXiv preprint arXiv:1803.10227.
Finn, C., S. Levine, and P. Abbeel
2016. Guided cost learning: Deep inverse optimal control via policy optimization. In Interna-
tional Conference on Machine Learning, Pp. 49-58.
Fu, J., K. Luo, and S. Levine
2018. Learning robust rewards with adverserial inverse reinforcement learning. In International
Conference on Learning Representations.
Germain, M., K. Gregor, I. Murray, and H. Larochelle
2015.	Made: Masked autoencoder for distribution estimation. In International Conference on
Machine Learning, Pp. 881-889.
Goodfellow, I., J. Pouget-Abadie, M. Mirza, B. Xu, D. Warde-Farley, S. Ozair, A. Courville, and
Y. Bengio
2014. Generative adversarial nets. In Advances in Neural Information Processing Systems,
Pp. 2672-2680.
Goyal, A., P. Brakel, W. Fedus, T. Lillicrap, S. Levine, H. Larochelle, and Y. Bengio
2018. Recall traces: Backtracking models for efficient reinforcement learning. arXiv preprint
arXiv:1804.00379.
Ho, J. and S. Ermon
2016.	Generative adversarial imitation learning. In Advances in Neural Information Processing
Systems, Pp. 4565-4573.
Kingma, D. P. and M. Welling
2013. Auto-encoding variational bayes. CoRR, abs/1312.6114.
Mirza, M. and S. Osindero
2014. Conditional generative adversarial nets. arXiv preprint arXiv:1411.1784.
Morimura, T., E. Uchibe, J. Yoshimoto, J. Peters, and K. Doya
2010. Derivatives of logarithmic stationary distributions for policy gradient reinforcement learn-
ing. Neural computation, 22(2):342-376.
Ng, A. and S. Russell
2000. Algorithms for inverse reinforcement learning. In International Conference on Machine
Learning, Pp. 663-670.
Odena, A., C. Olah, and J. Shlens
2017.	Conditional image synthesis with auxiliary classifier GANs. In International Conference
on Machine Learning, Pp. 2642-2651.
9
Published as a conference paper at ICLR 2019
Pan, Y., M. Zaheer, A. White, A. Patterson, and M. White
2018.	Organizing experience: a deeper look at replay mechanisms for sample-based planning in
continuous state domains. In International Joint Conference OnArtificial Intelligence, Pp. 4794-
4800.
Papamakarios, G., I. Murray, and T. Pavlakou
2017.	Masked autoregressive flow for density estimation. In Advances in Neural Information
Processing Systems, Pp. 2335-2344.
Pathak, D., P. Mahmoudieh, G. Luo, P. Agrawal, D. Chen, Y. Shentu, E. Shelhamer, J. Malik, A. A.
Efros, and T. Darrell
2018.	Zero-shot visual imitation. In International Conference on Learning Representations.
Peng, J. and R. J. Williams
1993. Efficient learning and planning within the dyna framework. Adaptive Behavior, 1(4):437-
454.
Peng, X. B., P. Abbeel, S. Levine, and M. van de Panne
2018. Deepmimic: Example-guided deep reinforcement learning of physics-based character
skills. arXiv preprint arXiv:1804.02717.
Pomerleau, D. A.
1989. Alvinn: An autonomous land vehicle in a neural network. In Advances in Neural Informa-
tion Processing Systems, Pp. 305-313.
Ross, S. and D. Bagnell
2010.	Efficient reductions for imitation learning. In International Conference on Artificial Intel-
ligence and Statistics, Pp. 661-668.
Ross, S., G. Gordon, and D. Bagnell
2011.	A reduction of imitation learning and structured prediction to no-regret online learning. In
International Conference on Artificial Intelligence and Statistics, Pp. 627-635.
Schroecker, Y., H. Ben Amor, and A. Thomaz
2016.	Directing policy search with interactively taught via-points. In International Conference
on Autonomous Agents & Multiagent Systems, Pp. 1052-1059.
Schroecker, Y. and C. L. Isbell
2017.	State aware imitation learning. In Advances in Neural Information Processing Systems,
Pp. 2915-2924.
Sermanet, P., C. Lynch, Y. Chebotar, J. Hsu, E. Jang, S. Schaal, and S. Levine
2017.	Time-contrastive networks: self-supervised learning from video. arXiv preprint
arXiv:1704.06888.
Sutton, R. S. and A. G. Barto
1998.	Reinforcement learning: An introduction. MIT press.
Sutton, R. S., D. A. McAllester, S. P. Singh, Y. Mansour, and Others
1999.	Policy Gradient Methods for Reinforcement Learning with Function Approximation. In
Advances in Neural Information Processing Systems, Pp. 1057-1063.
Tsitsiklis, J. N. and B. Van Roy
1997.	Analysis of temporal-diffference learning with function approximation. In Advances in
Neural Information Processing Systems, Pp. 1075-1081.
Van Den Oord, A., S. Dieleman, H. Zen, K. Simonyan, O. Vinyals, A. Graves, N. Kalchbrenner,
A. Senior, and K. Kavukcuoglu
2016a. Wavenet: A generative model for raw audio. arXiv preprint arXiv:1609.03499.
Van Den Oord, A., N. Kalchbrenner, and K. Kavukcuoglu
2016b. Pixel recurrent neural networks. arXiv preprint arXiv:1601.06759.
10
Published as a conference paper at ICLR 2019
Vecerik, M., T. Hester, J. Scholz, F. Wang, O. PietqUin, B. Piot, N. Heess, T. RothorL T. Lampe, and
M. A. Riedmiller
2017.	Leveraging demonstrations for deep reinforcement learning on robotics problems with
sparse rewards. CoRR, abs/1707.08817.
Zhu, Y., Z. Wang, J. Merel, A. Rusu, T. Erez, S. Cabi, S. Tunyasuvunakool, J. Kramar, R. HadselL
N. de Freitas, et al.
2018.	Reinforcement and imitation learning for diverse visuomotor skills. arXiv preprint
arXiv:1802.09564.
Ziebart, B. D., A. L. Maas, J. A. Bagnell, and A. K. Dey
2008.	Maximum entropy inverse reinforcement learning. In AAAI Conference on Artificial Intel-
ligence ,Pp. 1433-1438.
A Derivation of equation 6
Here, We derive equation 6 which unrolls the recursive definition of Vθ log dπθ (S) and rewrites it
such that it can be replaced by an expectation over states and actions along trajectories leading to
the state S. In section 3.1, we derive a recursive definition of Vθ log dπθ (S) which we will restate in
more detail:
/
Z
Z
Vθ dπθ (S)
dπθ (s)Vθ log dπθ (S)
Vθ log dπθ (S)
Vθρπθ(S)P(St+1 = S∣St = S, at = a)dS,a
ρπθ(S,a)p(St+ι = S∣St = S, at = a)Vθ logρπθ(S,a)dS,a
qπθ (St = S,at = a∣St+ι = S)(Vθ log dπθ (S) + Vθ log ∏(a∣S)) dS, a
We can now unroll this definition:
Vθ log dπθ (S) = / qπθ (St = S,at = a∣St+ι = S)(Vθ log dπθ (s) + Vθ log ∏(a∣S)) dS, a
“	_ T-2
= Tlim	I qπθ(St+T-ι,at+T-i|St+T = s) ɪɪ qπθ(St+j,at+j|St+j+i)
→∞	j=0
(13)
T
Vθ log ∏θ (at+j ∣St+j) dSt：t+T-1 ,at：t+T-ι +
j=0
/ qπθ (St = S,at = a∣St+T = S)Vθ log dπθ (S)dS,a
Note that limT→∞ qπθ(St = s, at = a∣St+T = S) = ρπθ(s, a) due to Markov chain mixing and,
therefore, the second term of the above sum reduces to 0 as
J dπθ (S)π(a∣S)Vθ log dπθ (S)dS,a = 0.
(14)
By pulling out the sum, we can now marginalize out most variables and shift indices to arrive at the
desired conclusion:
_	T r	_
Vθ log dπθ (S) =IimT	qπθ (st+j = s,at+j = a∣St+T +ι = s)Vθ log∏(a∣s)ds,a
T→∞
j=0
T r	_
= IimT	qπθ (st = s,at = a∣St+T +ι-j = S)Vθ log ∏(a∣s)ds, a (15)
T→∞
j=0
=lim	J^qπθ (st = s,at = a∣st+j+ι = S)Vθ log∏(a∣s)ds, a
→∞ j=0
11
Published as a conference paper at ICLR 2019
B Hyperparameters
General parameters	
Total iterations	2e6
Batch size B	^^56
Y	-09
Replay memory size	50000
F	15000
Nn	5000
Bs and Ba		
Stacked autoencoders	2
Hidden layers	500, 500
Optimizer	Adam
Learning rate	2 ∙ 105
Burnin	50000 iterations
L2-regularization	10-2
min(σi)	ɪi
Gradient clip, L2 norm	100
Policy ∏θ	
Hidden layers	300, 200	
Optimizer	Adam
Learning rate	"l04
σ bounds	(0.01,0.1)
(a) GPRIL parameters for clip insertion
General parameters	
Total iterations	1e4
#PrOCeSSeS	16
Batch size B	16 ∙256-
Actor steps per iteration	
Discriminator steps per iteration	π
Y	0.995
Actor	
Hidden layers	300, 200
KL step size σ bounds	^001 (0.01,0.1)
Discriminator	
Hidden layers	150,100
Optimizer	Adam
Learning rate	^Γ04
Entropy regularization	
Optimizer	Adam
Critic	
Hidden layers	300, 200
Optimizer	Adam
Learning rate	5 ∙ 103
(b) GAIL parameters for clip insertion
General parameters	
Total iterations	5e6
Batch size B	"^56
Hidden layers	300,200-
σ bounds	(0.01,0.1)
Optimizer	Adam
Learning rate	^T04
L2-regularization	10-4
(c) BC parameters for clip insertion
		Simulation	Real robot
General parameters		
Batch size B	256		
Y	0.9	0.7
Replay memory size	10000	-	50000	-
F	10000		
Nn	1000	5000
Bs and Ba			
Stacked autoencoders	2	
Hidden layers	500,500	—	
Optimizer	Adam	
Learning rate	10-5	3∙10-5
Burnin	0		
L2-regularization	10-2	10-3
min(σi)	0.1	一	0.01	-
Gradient clip (L2)	100		
Policy ∏θ	]		
Hidden layers	300,200		
Optimizer	Adam	
Learning rate	10-4	
σ bounds	(0.01,0.1)	一	
(d) GPRIL parameters for peg insertion
General parameters	
#Processes	16
Batch size B	16 ∙256-
Actor steps/iteration	
Discriminator steps/iteration	π
Y	0.995
Actor	
Hidden layers	300, 200
KL step size σ bounds	^001 (0.01,0.1)
Discriminator	
Hidden layers	150,100
Optimizer	Adam
Learning rate	10-4
Entropy regularization	1
Optimizer	Adam
Critic	
Hidden layers	300, 200
Optimizer	Adam
Learning rate	5∙10-3
(e) GAIL parameters for simulated peg insertion
12
Published as a conference paper at ICLR 2019
C Relation to the Policy Gradient Theorem
In this section, we outline the relation between the policy gradient theorem (Sutton et al., 1999)
and the state-action-distribution gradient derived in section A and show equivalence of the discount
factor used in reinforcement learning and the discount factor γ introduced in this work. We first show
that the state-action distribution gradient is equal to the policy gradient in the average reward case
using a specific reward function. We then derive the γ-discounted approximation of the state-action-
distribution gradient presented in section 3.1 from the policy gradient in the discounted reward
framework using γ as a discount factor. While this derivation is more cumbersome than the one
presented in the body of the paper, it allows us to gain a better understanding of the meaning of γ
since discounting in the reinforcement learning setting is well understood. For notational simplicity,
we assume that the state space S and action space A are countable. Note that this is a common
assumption made in the field (Tsitsiklis and Van Roy, 1997) and considering that any state-action
space is countable and finite when states and actions are represented using a finite number of bits
makes it apparent that this assumption does not constitute a simplification in the practical sense.
In this work We propose to follow the gradient Vθ log ρπθ evaluated at demonstrated states and
actions, consider thus the gradient evaluated at S, a：
Vθ log ρπθ (S,a)= π ,1 _. Vθ X ρπθ (s,α)1(s = Ma = a)
ρθ (S，a)	SM∈A	(16)
=VθEs,a〜ρπ [R(s, a)] =: Vθ J(∏θ)
As we can see, the gradient is equivalent to the policy gradient using the reward function
R(S, a)
1(s=S,a=a)
ρ∏(S⑸
ʌ
in the average reward framework where θ corresponds to the parameters of
the policy at the current iteration. This reward function is not practical as it can be infinitely sparse
and furthermore depends on the unknown stationary distribution. However, it allows us to derive the
policy gradient using this reward function in the discounted reward setting which constitutes a well
understood approximation of the average-reward scenario. Following the notation in Sutton et al.
(1999), we have：
Vθ J (∏θ ) = Esj,aj 〜ρπ
vθ log πθ (aj lsj )ESj+ιg+ι,…
∞
X
t=0
γ t R(St+j , at+j )|
πθ , Sj , aj
(17)
We can now replace the expectation over the stationary distribution by an expectation over the path
of the agent. This yields a double sum whose order of summation can be changed：
vθ J (πθ )=τlimo τE
TT
Evθ log πθ( aj |sj) EYtR(St+j 皿+彳 )iπθ
j=0	t=0
lim LE
T →∞ T
TT
ΣΣVθ log ∏θ (aj ∣Sj )γt-j R(st, at)∖∏θ
(18)
lim LE
T →∞ T
Tt
ΣΣγt-jVθlogπθ(aj∖Sj)R(St, at)∖πθ
After changing the order of summation we can replace the outer sum with the expectation over the
stationary distributions and use the special nature of the chosen reward function to write the gradient
as a conditional expectation：
t
VθJ(πθ) = lim E Xγt-jVθlogπθ(aj∖Sj)R(St,at)∖πθ
→∞ j=0
lim E
t→∞
t
E γt-j Vθ log ∏θ (aj ∖sj )∖∏θ, St = Mat = a
j=0
(19)
13
Published as a conference paper at ICLR 2019
Finally, we notice that this equation constitutes the discounted version of equation 15, thus we can
immediately obtain our estimate of the state-action-distribution gradient:
Vθ J (∏θ)
----Es,a~Bπθ
1-γ
(∙,∙∣s) [Vθ log ∏θ(a|s)] + Vθ log ∏(a|s) ≈ Vθ log ρπθ (s, a)
(20)
While this derivation is less direct than the derivation used in section A, it draws a connection be-
tween the problem of matching state-action-distributions and the reinforcement learning problem
with a reward that is positive for demonstrated state-action pairs and 0 otherwise. This indicates
that the role of the discount factor is similar in both settings: Lower values of γ trade-off accurate
matching of distributions for lower variance and as expedience. Agents with low γ will learn poli-
cies that recover and reach demonstrated states quicker over policies that are matching the experts
state-action distribution more accurately long-term. Furthermore, the long history of successes in
reinforcement learning validates the use of γ as an approximation to the true objective which is often
more accurately described by the average-reward objective.
14