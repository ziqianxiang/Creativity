Published as a conference paper at ICLR 2019
Predict then Propagate: Graph Neural
Networks meet Personalized PageRank
Johannes Gasteiger, Aleksandar Bojchevski & Stephan Gunnemann
Technical University of Munich, Germany
{j.gasteiger,a.bojchevski,guennemann}@in.tum.de
Ab stract
Neural message passing algorithms for semi-supervised classification on graphs
have recently achieved great success. However, for classifying a node these meth-
ods only consider nodes that are a few propagation steps away and the size of this
utilized neighborhood is hard to extend. In this paper, we use the relationship be-
tween graph convolutional networks (GCN) and PageRank to derive an improved
propagation scheme based on personalized PageRank. We utilize this propagation
procedure to construct a simple model, personalized propagation of neural predic-
tions (PPNP), and its fast approximation, APPNP. Our model’s training time is on
par or faster and its number of parameters on par or lower than previous models.
It leverages a large, adjustable neighborhood for classification and can be easily
combined with any neural network. We show that this model outperforms several
recently proposed methods for semi-supervised classification in the most thorough
study done so far for GCN-like models. Our implementation is available online. 1
1	Introduction
Graphs are ubiquitous in the real world and its description through scientific models. They are
used to study the spread of information, to optimize delivery, to recommend new books, to suggest
friends, or to find a party’s potential voters. Deep learning approaches have achieved great success
on many important graph problems such as link prediction (Grover & Leskovec, 2016; Bojchevski
et al., 2018), graph classification (Duvenaud et al., 2015; Niepert et al., 2016; Gilmer et al., 2017)
and semi-supervised node classification (Yang et al., 2016; Kipf & Welling, 2017).
There are many approaches for leveraging deep learning algorithms on graphs. Node embedding
methods use random walks or matrix factorization to directly train individual node embeddings,
often without using node features and usually in an unsupervised manner, i.e. without leveraging
node classes (Perozzi et al., 2014; Tang et al., 2015; Nandanwar & Murty, 2016; Grover & Leskovec,
2016; Qiu et al., 2018). Many other approaches use both graph structure and node features in a
supervised setting. Examples for these include spectral graph convolutional neural networks (Bruna
et al., 2014; Defferrard et al., 2016), message passing (or neighbor aggregation) algorithms (Kearnes
et al., 2016; Kipf & Welling, 2017; Hamilton et al., 2017; Pham et al., 2017; Monti et al., 2017;
Gilmer et al., 2017), and neighbor aggregation via recurrent neural networks (Scarselli et al., 2009;
Li et al., 2016; Dai et al., 2018). Among these categories, the class of message passing algorithms
has garnered particular attention recently due to its flexibility and good performance.
Several works have been aimed at improving the basic neighborhood aggregation scheme by using
attention mechanisms (Kearnes et al., 2016; Hamilton et al., 2017; VeIickovic et al., 2018), random
walks (Abu-El-Haija et al., 2018a; Ying et al., 2018; Li et al., 2018), edge features (Kearnes et al.,
2016; Gilmer et al., 2017; Schlichtkrull et al., 2018) and making it more scalable on large graphs
(Chen et al., 2018; Ying et al., 2018). However, all of these methods only use the information of a
very limited neighborhood for each node. A larger neighborhood would be desirable to provide the
model with more information, especially for nodes in the periphery or in a sparsely labelled setting.
Increasing the size of the neighborhood used by these algorithms, i.e. their range, is not trivial
since neighborhood aggregation in this scheme is essentially a type of Laplacian smoothing and too
1https://www.kdd.in.tum.de/ppnp
1
Published as a conference paper at ICLR 2019
many layers lead to oversmoothing (Li et al., 2018). Xu et al. (2018) highlighted the same problem
by establishing a relationship between the message passing algorithm termed Graph Convolutional
Network (GCN) by Kipf & Welling (2017) and a random walk. Using this relationship we see that
GCN converges to this random walk’s limit distribution as the number of layers increases. The limit
distribution is a property of the graph as a whole and does not take the random walk’s starting (root)
node into account. As such it is unsuited to describe the root node’s neighborhood. Hence, GCN’s
performance necessarily deteriorates for a high number of layers (or aggregation/propagation steps).
To solve this issue, in this paper, we first highlight the inherent connection between the limit distri-
bution and PageRank (Page et al., 1998). We then propose an algorithm that utilizes a propagation
scheme derived from personalized PageRank instead. This algorithm adds a chance of teleport-
ing back to the root node, which ensures that the PageRank score encodes the local neighborhood
for every root node (Page et al., 1998). The teleport probability allows us to balance the needs of
preserving locality (i.e. staying close to the root node to avoid oversmoothing) and leveraging the
information from a large neighborhood. We show that this propagation scheme permits the use of
far more (in fact, infinitely many) propagation steps without leading to oversmoothing.
Moreover, while propagation and classification are inherently intertwined in message passing, our
proposed algorithm separates the neural network from the propagation scheme. This allows us to
achieve a much higher range without changing the neural network, whereas in the message passing
scheme every additional propagation step would require an additional layer. It also permits the in-
dependent development of the propagation algorithm and the neural network generating predictions
from node features. That is, we can combine any state-of-the-art prediction method with our prop-
agation scheme. We even found that adding our propagation scheme during inference significantly
improves the accuracy of networks that were trained without using any graph information.
Our model achieves state-of-the-art results while requiring fewer parameters and less training time
compared to most competing models, with a computational complexity that is linear in the number of
edges. We show these results in the most thorough study (including significance testing) of message
passing models using graphs with text-based features that has been done so far.
2	Graph convolutional networks and their limited range
We first introduce our notation and explain the problem our model solves. Let G = (V, E) be a
graph with nodes V and edges E. Let n denote the number of nodes and m the number of edges.
The nodes are described by the feature matrix X ∈ Rn×f, with the number of features f per node,
and the class (or label) matrix Y ∈ Rn×c, with the number of classes c. The graph G is described by
the adjacency matrix A ∈ Rn×n. A = A + In denotes the adjacency matrix with added self-loops.
One simple and widely used message passing algorithm for semi-supervised classification is the
Graph Convolutional Network (GCN). In the case of two message passing layers its equation is
ZGCN = Softmax (A ReLU (AxW°) Wι) ,	(1)
^	〜—1/2 ~ 〜—1/2
where Z ∈ Rn×c are the predicted node labels, A = D AD is the symmetrically normal-
ized adjacency matrix with self-loops, with the diagonal degree matrix Dij = k Aik δij, and W0
and W1 are trainable weight matrices (Kipf & Welling, 2017).
With two GCN-layers, only neighbors in the two-hop neighborhood are considered. There are es-
sentially two reasons why a message passing algorithm like GCN cannot be trivially expanded to use
a larger neighborhood. First, aggregation by averaging causes oversmoothing if too many layers are
used. It, therefore, loses its focus on the local neighborhood (Li et al., 2018). Second, most common
aggregation schemes use learnable weight matrices in each layer. Therefore, using a larger neigh-
borhood necessarily increases the depth and number of learnable parameters of the neural network
(the second aspect can be circumvented by using weight sharing, which is typically not the case,
though). However, the required neighborhood size and neural network depth are two completely
orthogonal aspects. This fixed relationship is a strong limitation and leads to bad compromises.
We will start by concentrating on the first issue. Xu et al. (2018) have shown that for a k-
layer GCN the influence score of node X on y, I(χ,y) = Pi Pj IXXyi, is proportional in
2
Published as a conference paper at ICLR 2019
Figure 1: Illustration of (approximate) personalized propagation of neural predictions (PPNP,
APPNP). Predictions are first generated from each node’s own features by a neural network and
then propagated using an adaptation of personalized PageRank. The model is trained end-to-end.
expectation to a slightly modified k-step random walk distribution starting at the root node x,
Prw’ (x → y, k). Hence, the information of node x spreads to node y in a random walk-like
manner. If we take the limit k → ∞ and the graph is irreducible and aperiodic, this random
walk probability distribution Prw’ (x → y, k) converges to the limit (or stationary) distribution
^
Plim(→ y). This distribution can be obtained by solving the equation nɪim = A∏iim. Obviously, the
result only depends on the graph as a whole and is independent of the random walk’s starting (root)
node x. This global property is therefore unsuitable for describing the root node’s neighborhood.
3	Personalized propagation of neural predictions
From message passing to personalized PageRank. We can solve the problem of lost focus by
recognizing the connection between the limit distribution and PageRank (Page et al., 1998). The
only differences between these two are the added self-loops and the adjacency matrix normalization
^	1
in A. Original PageRank is calculated via ∏pr = Arw∏pr, with Arw = AD 1. Having made this
connection we can now consider using a variant of PageRank that takes the root node into account
一 personalized PageRank (Page et al., 1998). We define the root node X via the teleport vector iχ,
which is a one-hot indicator vector. Our adaptation of personalized PageRank can be obtained for
^
node x using the recurrent equation ∏ppr(iχ) = (1 - α) Anppr (iχ) + αiχ, with the teleport (or restart)
probability α ∈ (0, 1]. By solving this equation, we obtain
πppr(ix) = α In - (1 - α)A	ix .	(2)
Introducing the teleport vector ix allows us to preserve the node’s local neighborhood even in the
limit distribution. In this model the influence score of root node x on node y, I(x, y), is proportional
to the y-th element of our personalized PageRank πppr(ix). This value is different for every root
node. How fast it decreases as we move away from the root node can be adjusted via α. By sub-
stituting the indicator vector ix with the unit matrix In we obtain our fully personalized PageRank
^∖-1
matrix Πppr = α(In - (1 - α)A) 1, whose element (yx) specifies the influence score of node X
on node y, I(x, y) H Πpprx). Note that due to symmetry Πpprx) = ΠpXry), i.e. the influence of X on y
is equal to the influence of y on x. This inverse always exists since i-a > 1 and therefore cannot
^
be an eigenvalue of A (see Appendix A).
Personalized propagation of neural predictions (PPNP). To utilize the above influence scores for
semi-supervised classification we generate predictions for each node based on its own features and
then propagate them via our fully personalized PageRank scheme to generate the final predictions.
This is the foundation of personalized propagation of neural predictions. PPNP’s model equation is
Zppnp = softmax (α (In - (1 - α)A) H) , Hi ： = fθ(Xi,：),	(3)
3
Published as a conference paper at ICLR 2019
where X is the feature matrix and fθ a neural network with parameter set θ generating the pre-
dictions H ∈ Rn×c. Note that fθ operates on each node’s features independently, allowing for
^
parallelization. Furthermore, one could substitute A With any propagation matrix, such as 4w∙
As a consequence, PPNP separates the neural network used for generating predictions from the
propagation scheme. This separation additionally solves the second issue mentioned above: the
depth of the neural netWork is noW fully independent of the propagation algorithm. As We saW
When connecting GCN to PageRank, personalized PageRank can effectively use even infinitely many
neighborhood aggregation layers, Which is clearly not possible in the classical message passing
frameWork. Furthermore, the separation gives us the flexibility to use any method for generating
predictions, e.g. deep convolutional neural netWorks for graphs of images.
While generating predictions and propagating them happen consecutively during inference, it is
important to note that the model is trained end-to-end. That is, the gradient floWs through the
propagation scheme during backpropagation (implicitly considering infinitely many neighborhood
aggregation layers). Adding these propagation effects significantly improves the model’s accuracy.
Efficiency analysis. Directly calculating the fully personalized PageRank matrix Πppr, is com-
putationally inefficient and results in a dense Rn×n matrix. Using this matrix Would lead to a
computational complexity and memory requirement of O(n2) for training and inference.
^∖-1
To solve this issue, reconsider the equation Z = α(In, - (1 - α)A) 1H. Instead of viewing this
equation as a combination of a dense fully personalized PageRank matrix With the prediction ma-
trix, we can also view it as a variant of topic-sensitive PageRank, with each class corresponding to
one topic (Haveliwala, 2002). In this view every column of H defines an (unnormalized) distribu-
tion over nodes that acts as a teleport set. Hence, we can approximate PPNP via an approximate
computation of topic-sensitive PageRank.
Approximate personalized propagation of neural predictions (APPNP). More precisely, APPNP
achieves linear computational complexity by approximating topic-sensitive PageRank via power
iteration. While PageRank’s power iteration is connected to the regular random walk, the power
iteration of topic-sensitive PageRank is related to a random walk with restarts. Each power iteration
(random walk/propagation) step of our topic-sensitive PageRank variant is, thus, calculated via
Z(0) = H = fθ(X),
Z(k+1) = (1 - α)AZ⑹ + αH,	(4)
Z(K) = softmax ((1 — a)Az(KT) + αH),
where the prediction matrix H acts as both the starting vector and the teleport set, K defines the
number of power iteration steps and k ∈ [0, K-2]. Note that this method retains the graph’s sparsity
and never constructs an Rn×n matrix. The convergence of this iterative scheme can be shown by
investigating the resulting series (see Appendix B).
Note that the propagation scheme of this model does not require any additional parameters to train
一 as opposed to models like GCN, which typically require more parameters for each additional
propagation layer. We can therefore propagate very far with very few parameters. Our experiments
show that this ability is indeed very beneficial (see Section 6). A similar model expressed in the
message passing framework would therefore not be able to achieve the same level of performance.
The reformulation of PPNP via fixed-point iterations illustrates a connection to the original graph
neural network (GNN) model (Scarselli et al., 2009). While the latter uses a learned fixed-point
iteration, our approach uses a predetermined iteration (adapted personalized PageRank) and applies
a learned feature transformation before propagation.
In both PPNP and APPNP, the size of the neighborhood influencing each node can be adjusted via
the teleport probability α. The freedom to choose α allows us to adjust the model for different types
of networks, since varying graph types require the consideration of different neighborhood sizes, as
shown in Section 6 and described by Grover & Leskovec (2016) and Abu-El-Haija et al. (2018b).
4
Published as a conference paper at ICLR 2019
Table 1: Dataset statistics. Shortest path length is denoted by SP.
Dataset	Type	Classes	Features	Nodes	Edges	Label rate	Avg. SP
Citeseer	Citation	6	3703^^	2110	3668	0.036	9.31
Cora-ML	Citation	7	2879	2810	7981	0.047	5.27
PubMed	Citation	3	500	19 717	44 324	0.003	6.34
MS Academic	Co-author	15	6805	18 333	81 894	0.016	5.43
4	Related work
Several works have tried to improve the training of message passing algorithms and increase the
neighborhood available at each node by adding skip connections (Li et al., 2016; Pham et al., 2017;
Hamilton et al., 2017; Ying et al., 2018). One recent approach combined skip connection with ag-
gregation schemes (Xu et al., 2018). However, the range of these models is still limited, as apparent
in the low number of message passing layers used. While it is possible to add skip connections in
the neural network used by our algorithm, this would not influence the propagation scheme. Our
approach to solving the range problem is therefore unrelated to these models.
Li et al. (2018) facilitated training by combining message passing with co- and self-training. The im-
provements achieved by this combination are similar to results reported with other semi-supervised
classification models (Buchnik & Cohen, 2018). Note that most algorithms, including ours, can be
improved using self- and co-training. However, each additional step used by these methods corre-
sponds to a full training cycle and therefore significantly increases the training time.
Deep GNNs that avoid the oversmoothing issue have been proposed in recent works by combining
residual (skip) connections with batch normalization (Kawamoto et al., 2018; Chen et al., 2019).
However, our model solves this issue by simplifying the architecture via decoupling prediction and
propagation and does not rely on ad-hoc techniques that further complicate the model and intro-
duce additional hyperparameters. Furthermore, since PPNP increases the range without introducing
additional layers and parameters it is easier and faster to train compared to a deep GNN.
5	Experimental setup
Recently, many experimental evaluations have suffered from superficial statistical evaluation and
experimental bias from using varying training setups and overfitting. The latter is caused by exper-
iments using a single training/validation/test split, by not distinguishing clearly between the vali-
dation and test set, and by finetuning hyperparameters to each dataset or even data split separately.
Message-passing algorithms are very sensitive to both data splits and weight initialization (as clearly
shown by our evaluation). Thus, a carefully designed evaluation protocol is extremely important.
Our work aims to establish such a thorough evaluation protocol. First, we run each experiment 100
times on multiple random splits and initializations. Second, we split the data into a visible and a test
set, which do not change. The test set was only used once to report the final performance; and in
particular, has never been used to perform hyperparameter and model selection. To further prevent
overfitting we use the same number of layers and hidden units, dropout rate d, L2 regularization
parameter λ, and learning rate l across datasets, since all datasets use bag-of-words as features. To
prevent experimental bias we optimized the hyperparameters of all models individually using a grid
search on CITESEER and CORA-ML and use the same early stopping criterion across models.
Finally, to ensure the statistical robustness of our experimental setup, we calculate confidence in-
tervals via bootstrapping and report the p-values of a paired t-test for our main claims. To our
knowledge, this is the most rigorous study on GCN-like models which has been done so far. More
details about the experimental setup are provided in Appendix C.
Datasets. We use four text-classification datasets for evaluation. CITESEER (Sen et al., 2008),
CORA-ML (McCallum et al., 2000; Bojchevski & Gunnemann, 2018) and PUBMED (Namata et al.,
2012) are citation graphs, where each node represents a paper and the edges represent citations
between them. In the Microsoft Academic graph (Shchur et al., 2018) edges represent co-
authorship. We use the largest connected component of each graph. All graphs use a bag-of-words
representation of the papers’ abstracts as features. While large graphs do not necessarily have a
5
Published as a conference paper at ICLR 2019
Table 2: Average accuracy with uncertainties showing the 95 % confidence level calculated by boot-
strapping. Previously reported improvements vanish on our rigorous experimental setup, while
PPNP and APPNP significantly outperform the compared models on all datasets.
Model	Citeseer	CORA-ML	PubMed	MS Academic
V. GCN	73.51 ± 0.48	82.30 ± 0.34	77.65 ± 0.40	91.65 ± 0.09
GCN	75.40 ± 0.30	83.41 ± 0.39	78.68 ± 0.38	92.10 ± 0.08
N-GCN	74.25 ± 0.40	82.25 ± 0.30	77.43 ± 0.42	92.86 ± 0.11
GAT	75.39 ± 0.27	84.37 ± 0.24	77.76 ± 0.44	91.22 ± 0.07
JK	73.03 ± 0.47	82.69 ± 0.35	77.88 ± 0.38	91.71 ± 0.10
Bt. FP	73.55 ± 0.57	80.84 ± 0.97	72.94 ± 1.00	91.61 ± 0.24
PPNP*	75.83 ± 0.27	85.29 ± 0.25	-	-
APPNP	75.73 ± 0.30	85.09 ± 0.25	79.73 ± 0.31	93.27 ± 0.08
* out of memory on PubMed, MS Academic (see efficiency analysis in Section 3)				
Citeseer	Cora-ML	PubMed MS Academic
THT
一—一
THTt
τ≡ττ
T⅛MT1*
TRT
一 •二
4 2 0
9 9 9
TaT
tλht
τππτi
TH T
THnT
IHT
τm⅝l
τ⅛τ
TT
TBl ♦
TBiI
TT
TBi ♦
τ±≡τ I
一 ■一一
5 0 5
8 8 7
一 ■ 一
TBlI
TnT
一 ∙■;
TBi ♦
TBIl ♦
TXHT ♦
(氏)Xɔomɔɔv
dNddV
dNdd
dH -S
Xf
IV0
Zo0—N
Zo0
NDO.A
dNddV
dNdd
dH -S
Xf
IV0
Zo0—N
Zo0
NDO.A
dNddV
dNdd
dH -S
Xf
IV0
Zo0—N
Zo0
NDO.A
dNddV
dNdd
dH -S
Xf
IV0
Zo0—N
Zo0
NDO.A
Figure 2: Accuracy distributions of different models. The high standard deviation between data
splits and initializations shows the importance of a rigorous evaluation, which is often omitted.
larger diameter (Leskovec et al., 2005), note that these graphs indeed have average shortest path
lengths between 5 and 10 and therefore a regular two-layer GCN cannot cover the entire graph.
Table 1 reports the dataset statistics.
Baseline models. We compare to five state-of-the-art models: GCN (Kipf & Welling, 2017), net-
work of GCNs (N-GCN)(AbU-El-Haija et al., 2018a), graph attention networks (GAT)(VelickoVic
et al., 2018), bootstrapped feature propagation (bt. FP) (Buchnik & Cohen, 2018) and jumping
knowledge networks with concatenation (JK) (XU et al., 2018). For GCN we also show the resUlts
of the (Unoptimized) Vanilla Version (V. GCN) to demonstrate the strong impact of early stopping
and hyperparameter optimization. The hyperparameters of all models are listed in Appendix D.
Model hyperparameters. To ensUre a fair model comparison we Used a neUral network for PPNP
that is strUctUrally Very similar to GCN and has the same nUmber of parameters. We Use two layers
with h = 64 hidden Units. We apply L2 regUlarization with λ = 0.005 on the weights of the first
layer and Use dropoUt with dropoUt rate d = 0.5 on both layers and the adjacency matrix. For
APPNP, adjacency dropoUt is resampled for each power iteration step. For propagation we Use the
teleport probability α = 0.1 and K = 10 power iteration steps for APPNP. We Use α = 0.2 on
the Microsoft Academic graph dUe to its strUctUral difference (see FigUre 5 and its discUssion).
The combination of this shallow neUral network with a comparatiVely high nUmber of power iteration
steps achieved the best results during hyperparameter optimization (see Appendix G).
6 Results
Overall accuracy. The results for the accuracy (micro F1-score) are summarized in Table 2. Similar
trends are observed for the macro F1-score (see Appendix E). Both models significantly outperform
the state-of-the-art baseline models on all datasets. Our rigorous setup might understate the improve-
ments achieved by PPNP and APPNP - this result is statistically significant P < 0.05, as tested via a
paired t-test (see Appendix F). This thorough setup furthermore shows that the advantages reported
by recent works practically vanish when training is harmonized, hyperparameters are properly op-
6
Published as a conference paper at ICLR 2019
Table 3: Average training time per epoch. PPNP and APPNP are only slightly slower than GCN and
much faster than more sophisticated methods like GAT.
Graph	V. GCN GCN N-GCN GAT JK	Bt.FP* PPNP**	APPNP
CITESEER	37.6 ms	35.3 ms	115.9 ms	187.0 ms	57.5 ms	-	49.2 ms	43.3 ms
CORA-ML	32.4 ms	36.5 ms	118.9 ms	217.4 ms	43.6 ms	-	55.3 ms	42.7 ms
PUBMED	48.6 ms	48.3 ms	342.6 ms	1029.8 ms	77.8 ms	-	-	64.1 ms
MS ACADEMIC 45.5 ms	39.2 ms	328.5 ms	772.2 ms	61.9 ms	-	-	59.8 ms
*not applicable, since core method not trainable	**oUt of memory on PubMed, MS Academic (see efficiency analysis in Section 3)
V.GC V. GCN ■ GCN N-GCN GAT JK Bt. FP - PPNP APPNP
U80
70 70
5ι	5	10	20	30	40	60
ntrain, per class
Figure 3: Accuracy for different training set sizes (number oflabeled nodes per class) on Cora-ML.
PPNP,s dominance increases further for smaller training set sizes.
timized and multiple data splits are considered. A simple GCN with optimized hyperparameters
outperforms several recently proposed models on our setup.
Figure 2 shows how broad the accuracy distribution of each model is. This is caused by both random
initialization and different data splits (train / early stopping / test). This demonstrates how crucial
a statistically rigorous evaluation is for a conclusive model comparison. Moreover, it shows the
sensitivity (robustness) of each method, e.g. PPNP, APPNP and GAT typically have lower variance.
Training time per epoch. We report the average training time per epoch in Table 3. We decided
to only compare the training time per epoch since all hyperparameters were solely optimized for
accuracy and the used early stopping criterion is very generous. Obviously, (exact) PPNP can only
be applied to moderately sized graphs, while APPNP scales to large data. On average, APPNP is
around 25 % slower than GCN due to its higher number of matrix multiplications. It scales similarly
with graph size as GCN and is therefore significantly faster than other more sophisticated models
like GAT. This is observed even though our implementation improved GAT’s training time roughly
by a factor of 2 compared to the reference implementation.
Training set size. Since the labeling rate is often very small for real world datasets, investigat-
ing how the models perform with a small number of training samples is very important. Figure 3
shows how the number of training nodes per class ntrain, per class impacts the accuracy on CORA-ML
(for other datasets see Appendix H). The dominance of PPNP and APPNP increases further in this
sparsely labelled setting. This can be attributed to their higher range, which allows them to better
propagate the information further away from the (few) training nodes. We see further evidence for
this when comparing the accuracy of APPNP and GCN depending on the distance between a node
and the training set (in terms of shortest path). Appendix I shows that the performance gap between
APPNP and GCN tends to increase for nodes that are far away from the training nodes. That is,
nodes further away from the training set benefit more from the increase in range.
(岸)"EJnOOV
Citeseer
76
75
74
84
82
Cora-ML	PubMed
80
79
78
90
85
MS Academic
Propagation
♦ GCN-like
A APPNP
0 10 20	∞	0 10 20	∞	0 10 20	∞	0 10 20	∞
KKKK
Figure 4: Accuracy depending on the number of propagation steps K . The accuracy breaks down for
the GCN-like propagation (α = 0), while it increases and stabilizes when using APPNP (α = 0.1).
7
Published as a conference paper at ICLR 2019
α
α
α
α
Figure 5: Accuracy depending on teleport probability α.
[0.05, 0.2], but changes for different types of datasets.
The optimum typically lies within α ∈
CiteSeer
Cora-ML
PUbMed
Jll
80
70
国
_JJE*11
MS Academic
Propagation
Never
Training
Inference
Inf. & Training
Figure 6: Accuracy of APPNP with propagation used only during training/inference. Best results
are achieved with full propagation, but propagating only during inference also achieves good results.
Number of power iteration steps. Figure 4 shows how the accuracy depends on the number of
power iterations for two different propagation schemes. The first mimics the standard propagation
as known from GCNs (i.e. α = 0 in APPNP). As clearly shown the performance breaks down as we
increase the number of power iterations K (since we approach the global PageRank solution). How-
ever, when using personalized propagation (with α = 0.1) the accuracy increases and converges to
exact PPNP with infinitely many propagation steps, thus demonstrating the personalized propagation
principle is indeed beneficial. As also shown in the figure, it is enough to use a moderate number of
power iterations (e.g. K = 10) to effectively approximate exact PPNP. Interestingly, we,ve found
that this number coincides with the highest shortest path distance of any node to the training set.
Teleport probability a. Figure 5 shows the effect of the hyperparameter α on the accuracy on the
validation set. While the optimum differs slightly for every dataset, we consistently found a teleport
probability of around α ∈ [0.05,0.2] to perform best. This probability should be adjusted for the
dataset under investigation, since different graphs exhibit different neighborhood structures (Grover
& Leskovec, 2016; Abu-El-Haija et al., 2018b). Note that a higher α improves convergence speed.
Neural network without propagation. PPNP and APPNP are trained end-to-end, with the propa-
gation scheme affecting (i) the neural network fθ during training, and (ii) the classification decision
during inference. Investigating how the model performs without propagation shows if and how valu-
able this addition is. Figure 6 shows how propagation affects both training and inference. ”Never”
denotes the case where no propagation is used; essentially we train and apply a standard multilayer
perceptron (MLP) fθ using the features only. "Training" denotes the case where we use APPNP
during training to learn fθ; at inference time, however, only fθ is used to predict the class labels.
"Inference”, in contrast, denotes the case where fθ is trained without APPNP (i.e. standard MLP on
features). This pretrained network with fixed weights is then used with APPNP,s propagation for
inference. Finally, "Inf. & Training” denotes the regular APPNP, which always uses propagation.
The best results are achieved with regular APPNP, which validates our approach. However, on most
datasets the accuracy decreases surprisingly little when propagating only during inference. Skipping
propagation during training can significantly reduce training time for large graphs as all nodes can
be handled independently. This also shows that our model can be combined with pretrained neural
networks that do not incorporate any graph information and still significantly improve their accuracy.
Moreover, Figure 6 shows thatjust propagating during training can also lead to large improvements.
This indicates that our model can also be applied to online/inductive learning where only the features
and not the neighborhood information of an incoming (previously unobserved) node are available.
8
Published as a conference paper at ICLR 2019
7 Conclusion
In this paper we have introduced personalized propagation of neural predictions (PPNP) and its fast
approximation, APPNP. We derived this model by considering the relationship between GCN and
PageRank and extending it to personalized PageRank. This simple model decouples prediction and
propagation and solves the limited range problem inherent in many message passing models with-
out introducing any additional parameters. It uses the information from a large, adjustable (via the
teleport probability α) neighborhood for classifying each node. The model is computationally effi-
cient and outperforms several state-of-the-art methods for semi-supervised classification on multiple
graphs in the most thorough study which has been done for GCN-like models so far.
For future work it would be interesting to combine PPNP with more complex neural networks used
e.g. in computer vision or natural language processing. Furthermore, faster or incremental approx-
imations of personalized PageRank (Bahmani et al., 2010; 2011; Lofgren et al., 2014) and more
sophisticated propagation schemes would also benefit the method.
Acknowledgements
This research was supported by the German Research Foundation, grant GU 1409/2-1.
References
Sami Abu-El-Haija, Amol Kapoor, Bryan Perozzi, and Joonseok Lee. N-GCN: Multi-scale Graph
Convolution for Semi-supervised Node Classification. In International Workshop on Mining and
Learning with Graphs (MLG), 2018a.
Sami Abu-El-Haija, Bryan Perozzi, Rami Al-Rfou, and Alex Alemi. Watch Your Step: Learning
Node Embeddings via Graph Attention. In NeurIPS, 2018b.
Bahman Bahmani, Abdur Chowdhury, and Ashish Goel. Fast Incremental and Personalized PageR-
ank. VLDB, 2010.
Bahman Bahmani, Kaushik Chakrabarti, and Dong Xin. Fast Personalized PageRank on MapRe-
duce. In SIGMOD, 2011.
Aleksandar BCjchevski and StePhan Gunnemann. Deep Gaussian Embedding of Graphs: UnsUPer-
vised Inductive Learning via Ranking. ICLR, 2018.
Aleksandar Bojchevski, Oleksandr Shchur, Daniel ZUgner, and Stephan GUnnemann. NetGAN:
Generating Graphs via Random Walks. In ICML, 2018.
Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann LeCun. Spectral Networks and Deep
Locally Connected Networks on Graphs. ICLR, 2014.
Eliav Buchnik and Edith Cohen. Bootstrapped Graph Diffusions: Exposing the Power of Nonlinear-
ity. Proceedings of the ACM on Measurement and Analysis of Computing Systems (POMACS), 2
(1):1-19, April 2018.
Jie Chen, Tengfei Ma, and Cao Xiao. FastGCN: Fast Learning with Graph Convolutional Networks
via Importance Sampling. ICLR, 2018.
Zhengdao Chen, Lisha Li, and Joan Bruna. Supervised Community Detection with Line Graph
Neural Networks. In ICLR, 2019.
Hanjun Dai, Zornitsa Kozareva, Bo Dai, Alexander J. Smola, and Le Song. Learning Steady-States
of Iterative Algorithms over Graphs. In ICML, 2018.
Michael Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional Neural Networks on
Graphs with Fast Localized Spectral Filtering. In NIPS, 2016.
David K. Duvenaud, Dougal Maclaurin, Jorge Aguilera-Iparraguirre, Rafael Gomez-Bombarelli,
Timothy Hirzel, Alan Aspuru-Guzik, and Ryan P. Adams. Convolutional Networks on Graphs for
Learning Molecular Fingerprints. In NIPS, 2015.
9
Published as a conference paper at ICLR 2019
Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol Vinyals, and George E. Dahl. Neural
Message Passing for Quantum Chemistry. In ICML, 2017.
Xavier Glorot and Yoshua Bengio. Understanding the difficulty of training deep feedforward neural
networks. In AISTATS, 2010.
Aditya Grover and Jure Leskovec. node2vec: Scalable Feature Learning for Networks. In KDD,
2016.
William L. Hamilton, Zhitao Ying, and Jure Leskovec. Inductive Representation Learning on Large
Graphs. In NIPS, 2017.
Taher H. Haveliwala. Topic-sensitive PageRank. In WWW, 2002.
Tatsuro Kawamoto, Masashi Tsubaki, and Tomoyuki Obuchi. Mean-field theory of graph neural
networks in graph partitioning. In NeurIPS, 2018.
Steven M. Kearnes, Kevin McCloskey, Marc Berndl, Vijay S. Pande, and Patrick Riley. Molecular
graph convolutions: moving beyond fingerprints. Journal of Computer-Aided Molecular Design,
30(8):595-608, 2016.
Diederik P. Kingma and Jimmy Ba. Adam: A Method for Stochastic Optimization. ICLR, 2015.
Thomas N. Kipf and Max Welling. Semi-Supervised Classification with Graph Convolutional Net-
works. ICLR, 2017.
Jure Leskovec, Jon Kleinberg, and Christos Faloutsos. Graphs over Time: Densification Laws,
Shrinking Diameters and Possible Explanations. In KDD, 2005.
Qimai Li, Zhichao Han, and Xiao-Ming Wu. Deeper Insights Into Graph Convolutional Networks
for Semi-Supervised Learning. In AAAI, 2018.
Yujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard S. Zemel. Gated Graph Sequence Neural
Networks. In ICLR, 2016.
Peter Lofgren, Siddhartha Banerjee, Ashish Goel, and Seshadhri Comandur. FAST-PPR: scaling
personalized pagerank estimation for large graphs. In KDD, 2014.
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S.
Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, An-
drew Harp, Geoffrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz Kaiser, Man-
junath Kudlur, Josh Levenberg, Dandelion Mane, Rajat Monga, Sherry Moore, Derek Murray,
Chris Olah, Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul
Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden,
Martin Wattenberg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. TensorFlow: Large-Scale
Machine Learning on Heterogeneous Systems, 2015.
Andrew Kachites McCallum, Kamal Nigam, Jason Rennie, and Kristie Seymore. Automating the
construction of internet portals with machine learning. Information Retrieval, 3(2):127-163,
2000.
Federico Monti, Davide Boscaini, Jonathan Masci, Emanuele Rodola, Jan Svoboda, and Michael M.
Bronstein. Geometric Deep Learning on Graphs and Manifolds Using Mixture Model CNNs. In
CVPR, 2017.
Galileo Namata, Ben London, Lise Getoor, and Bert Huang. Query-driven Active Surveying for Col-
lective Classification. In International Workshop on Mining and Learning with Graphs (MLG),
2012.
Sharad Nandanwar and M. N. Murty. Structural Neighborhood Based Classification of Nodes in a
Network. In KDD, 2016.
Mathias Niepert, Mohamed Ahmed, and Konstantin Kutzkov. Learning Convolutional Neural Net-
works for Graphs. In ICML, 2016.
10
Published as a conference paper at ICLR 2019
Lawrence Page, Sergey Brin, Rajeev Motwani, and Terry Winograd. The pagerank citation ranking:
Bringing order to the web. Technical report, Stanford InfoLab, 1998.
Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. DeepWalk: online learning of social representa-
tions. In KDD, 2014.
Trang Pham, Truyen Tran, Dinh Q. Phung, and Svetha Venkatesh. Column Networks for Collective
Classification. In AAAI, 2017.
Jiezhong Qiu, Yuxiao Dong, Hao Ma, Jian Li, Kuansan Wang, and Jie Tang. Network Embedding
as Matrix Factorization: Unifying DeepWalk, LINE, PTE, and node2vec. In ACM International
Conference on Web Search and Data Mining (WSDM), 2018.
F. Scarselli, M. Gori, Ah Chung Tsoi, M. Hagenbuchner, and G. Monfardini. The Graph Neural
Network Model. IEEE Transactions on Neural Networks, 20(1):61-80, January 2009.
Michael Sejr Schlichtkrull, Thomas N. Kipf, Peter Bloem, Rianne van den Berg, Ivan Titov, and Max
Welling. Modeling Relational Data with Graph Convolutional Networks. In Extended Semantic
Web Conference (ESWC), 2018.
Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Gallagher, and Tina Eliassi-Rad.
Collective Classification in Network Data. AI Magazine, 29(3):93-106, 2008.
Oleksandr Shchur, Maximilian Mumme, Aleksandar Bojchevski, and StePhan Gunnemann. Pitfalls
of Graph Neural Network Evaluation. In Relational Representation Learning Workshop (R2L
2018), NeurIPS, 2018.
Jian Tang, Meng Qu, Mingzhe Wang, Ming Zhang, Jun Yan, and Qiaozhu Mei. LINE: Large-scale
Information Network Embedding. In WWW, 2015.
Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua
Bengio. GraPh Attention Networks. ICLR, 2018.
Keyulu Xu, Chengtao Li, Yonglong Tian, Tomohiro Sonobe, Ken-ichi Kawarabayashi, and Stefanie
Jegelka. RePresentation Learning on GraPhs with JumPing Knowledge Networks. In ICML, 2018.
Zhilin Yang, William W. Cohen, and Ruslan Salakhutdinov. Revisiting Semi-SuPervised Learning
with GraPh Embeddings. In ICML, 2016.
Rex Ying, Ruining He, Kaifeng Chen, Pong Eksombatchai, William L. Hamilton, and Jure
Leskovec. GraPh Convolutional Neural Networks for Web-Scale Recommender Systems. KDD,
2018.
A EXISTENCE OF ΠPPR
The matrix
(5)


~ ~ ~ ~
exists iff the determinant det(In - (1 - α) A) = 0, which is the case iff det(A - ɪ-ɑIn) = 0, i.e.
1	^	^
iff i-ɑ is not an eigenvalue of A. ThiS value is always larger than 1 since the teleport probability
a ∈ (0,1]. Furthermore, the symmetrically normalized matrix A has the same eigenvalues as the
row-stochastic matrix Arw. This can be shown by multiplying the eigenvalue equation Av = λv
——1/2	——1/2	~
with D from left and substituting w = D v . This also shows that the eigenvectors of A
1/2
are the eigenvectors of Arw scaled by D . The largest eigenvalue of a row-stochastic matrix is
1, as can be proven using the Gershgorin circle theorem. Hence, ɪ―α cannot be an eigenvalue and
Πppr always exists.
11
Published as a conference paper at ICLR 2019
B	Convergence of APPNP
APPNP uses the iterative equation
Z(k+1) = (1 - α)AZ(k) + αH.	(6)
After the k-th propagation step, the resulting predictions are
Z(k) =((1 - α)k Ak + α XX(1 - α)i A) H.	(7)
If we take the limit k → ∞ the left term tends to 0 and the right term becomes a geometric series.
^	^
The series converges since α ∈ (0,1] and A is symmetrically normalized and therefore det( A) ≤ 1,
resulting in
ZC) = α (In -(1 - α)A)T H,	⑻
which is the equation for calculating (exact) PPNP.
C Experimental details
Visible	Test
Validation Training^ Early stopping	
Figure 7: Illustration of the node sampling procedure.
The sampling procedure is illustrated in Figure 7. The data is first split into a visible and a test
set. For the visible set 1500 nodes were sampled for the citation graphs and 5000 for Microsoft
Academic. The test set contains all remaining nodes. We use three different label sets in each
experiment: A training set of 20 nodes per class, an early stopping set of 500 nodes and either a
validation or test set. The validation set contains the remaining nodes of the visible set. We use
20 random seeds for determining the splits. These seeds are drawn once and fixed across runs to
facilitate comparisons. We use one set of seeds for the validation splits and a different set for the
test splits. Each experiment is run with 5 random initializations on each data split, leading to a total
of 100 runs per experiment.
The early stopping criterion uses a patience of p = 100 and an (unreachably high) maximum of
n = 10 000 epochs. The patience is reset whenever the accuracy increases or the loss decreases on
the early stopping set. We choose the parameter set achieving the highest accuracy and break ties by
selecting the lowest loss on this set. This criterion was inspired by GAr (VeIickoVic et al., 2018).
We used TensorFlow (Martin Abadi et al., 2015) for all experiments except bootstrapped feature
propagation. All uncertainties and confidence intervals correspond to a confidence level of95 % and
were calculated by bootstrapping with 1000 samples.
We use the Adam optimizer with a learning rate of l = 0.01 and cross-entropy loss for all models
(Kingma & Ba, 2015). Weights are initialized as described in Glorot & Bengio (2010). The feature
matrix is L1 normalized per row.
12
Published as a conference paper at ICLR 2019
D	Baseline hyperparameters
Vanilla GCN uses the original settings of two layers with h = 16 hidden units, no dropout on the
adjacency matrix, L2 regularization parameter λ = 5 × 10-4 and the original early stopping with a
maximum of 200 steps and a patience of 10 steps based on the loss.
The optimized GCN uses two layers with h = 64 hidden units, dropout on the adjacency matrix
with d = 0.5 and L2 regularization parameter λ = 0.02.
N-GCN uses h = 16 hidden units, R = 4 heads per random walk length and random walks of up
to K - 1 = 4 steps. It uses L2 regularization on all layers with λ = 1 × 10-5 and the attention
variant for merging the predictions (Abu-El-Haija et al., 2018a). Note that this model effectively
uses RKh = 320 hidden units, which is 5 times as many units compared to GCN, GAT, and PPNP.
For GAT we use the (well optimized) original hyperparameters, except the L2 regularization param-
eter λ = 0.001 and learning rate l = 0.01. As opposed to the original paper, we do not use different
hyperparameters on PubMed, as described in our experimental setup.
Bootstrapped feature propagation uses a return probability of α = 0.2, 10 propagation steps, 10
bootstrapping (self-training) steps with r = 0.1n training nodes added per step. We add the training
nodes with the lowest entropy on the predictions. The number of nodes added per class is based
on the class proportions estimated using the predictions. Note that this model does not include any
stochasticity in its initialization. We therefore only run it once per train/early stopping/test split.
For the jumping knowledge networks we use the concatenation variant with three layers and h = 64
hidden units per layer. We apply L2 regularization with λ = 0.001 on all layers and perform dropout
with d = 0.5 on all layers but not on the adjacency matrix.
E F1 score
Table 4: Average macro F1 score with uncertainties showing the 95 % confidence level calculated
by bootstrapping. PPNP achieves the highest F1 score on all datasets investigated.
Model	Citeseer	CORA-ML	PubMed	MS Academic
V. GCN	0.7002 ± 0.0043	0.8205 ± 0.0027	0.7801 ± 0.0038	0.9000 ± 0.0008
GCN	0.7065 ± 0.0037	0.8289 ± 0.0030	0.7883 ± 0.0032	0.9045 ± 0.0008
N-GCN	0.7021 ± 0.0035	0.8183 ± 0.0024	0.7773 ± 0.0040	0.9144 ± 0.0012
GAT	0.7062 ± 0.0029	0.8359 ± 0.0025	0.7777 ± 0.0040	0.8917 ± 0.0007
JK	0.6914 ± 0.0043	0.8202 ± 0.0026	0.7799 ± 0.0039	0.8985 ± 0.0012
Bt. FP	0.6789 ± 0.0055	0.8026 ± 0.0082	0.7448 ± 0.0079	0.8997 ± 0.0018
PPNP*	0.7102 ± 0.0041	0.8454 ± 0.0021	-	-
APPNP	0.7105 ± 0.0038	0.8429 ± 0.0022	0.7966 ± 0.0031	0.9184 ± 0.0009
*out of memory on PubMed, MS Academic (See efficiency analysis in Section 3)				
F PAIRED t-TEST
Table 5: p-value of the paired t-test with respect to accuracy.
Model	Citeseer	Cora-ML	PubMed	MS Academic
PPNP APPNP	1.02 X 10-3^^5.96 × 10-14	-	- 1.77 × 10-2	4.27 × 10-9	2.19 × 10-15	5.93 × 10-13
Table 6: p-value of the paired t-test with respect to F1 score.
Model	Citeseer	Cora-ML	PubMed	MS Academic
PPNP APPNP	4.49 × 10-2^^4.50 × 10-14	-	- 2.32 × 10-2	1.07 × 10-8	8.70 × 10-14	1.99 × 10-8
13
Published as a conference paper at ICLR 2019
G Number of neural network layers
PUbMed
MS Academic
CiteSeer
Cora-ML
70
60
(岸)AOEJnOOV
Figure 8: Validation accuracy of APPNP for varying numberS of neural network (NN) layerS. Deep
NNS do not improve the accuracy, which iS probably due to the Simple bag-of-wordS featureS and
the Small training Set Size.
1 2 3 4 5 6 7 8
Layers
1 2 3 4 5 6 7 8
Layers
1 2 3 4 5 6 7 8
Layers
1 2 3 4 5 6 7 8
Layers
H Training set size
V. GCN ■ GCN N-GCN GAT JK Bt. FP - PPNP APPNP
Figure 9: Accuracy for different training set sizes on CITESEER.
ntrain, per class
Figure 10: Accuracy for different training set sizes on PubMed.
Figure 11: Accuracy for different training set sizes on Microsoft Academic.
14
Published as a conference paper at ICLR 2019
I Accuracy depending on distance from training nodes
(卓)AOEJnOOV /
J J J y「
Distance
J J y知
Distance
J J J J y 却
Distance
Figure 12: ∆ Accuracy (%) denotes the average improvement in percentage points of APPNP over
GCN depending on the distance (number of hops) from the training nodes on Cora-ML. n denotes
the average number of nodes at each distance. The improvement increases with distance.
PUbMed	MS Academic
CiteSeer
Cora-ML
(卓)AOEJnSV /
1.0
1234567+
fκV o2θ √Λ cJ×- rʌ q⅞, &
万校茨区厚步
?/〃///////，瓷J
1 2 3 4 5 6 7+	1 2 3 4 5 6 7+
ʌ rb ∩/ ¾ ɔ) ɔ) rb	况 rb∩∕∩∕6Arb
c>∙<^∙⅛⅛¾⅞⅜∙	⅛∙9SV‰⅛⅛∙	、
/〃/ 〃/《小小 /〃/ 〃/，小 QNN
<0> <0> ʌ ʌ ʌ ʌ	<0> <0> ʌ ʌ
0.5
0.0
1 2 3 4 5 6 7+
r % CwV 八 q<
7	E〉// //
〃 〃 〃，「小ι
Distance
Distance
Distance
Distance
Figure 13: ∆ Accuracy (%) denotes the average improvement in percentage points of APPNP over
GCN depending on the distance (number of hops) from the training nodes on different graphs. n
denotes the average number of nodes at each distance over different splits.
15