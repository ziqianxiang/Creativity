Published as a conference paper at ICLR 2019
On the Universal Approximability and
Complexity Bounds of Quantized ReLU
Neural Networks
Yukun Ding1, Jinglan Liu1, Jinjun Xiong2, Yiyu Shi1
1	University of Notre Dame
2	IBM Thomas J. Watson Research Center
{yding5,jliu16,yshi4}@nd.edu, jinjun@us.ibm.com
Ab stract
Compression is a key step to deploy large neural networks on resource-constrained
platforms. As a popular compression technique, quantization constrains the num-
ber of distinct weight values and thus reducing the number of bits required to
represent and store each weight. In this paper, we study the representation power
of quantized neural networks. First, we prove the universal approximability of
quantized ReLU networks on a wide class of functions. Then we provide upper
bounds on the number of weights and the memory size for a given approximation
error bound and the bit-width of weights for function-independent and function-
dependent structures. Our results reveal that, to attain an approximation error
bound of , the number of weights needed by a quantized network is no more
than O log5 (1/) times that of an unquantized network. This overhead is of
much lower order than the lower bound of the number of weights needed for the
error bound, supporting the empirical success of various quantization techniques.
To the best of our knowledge, this is the first in-depth study on the complexity
bounds of quantized neural networks.
1	Introduction
Various deep neural networks deliver state-of-the-art performance on many tasks such as object
recognition and natural language processing using new learning strategies and architectures (Chen
et al., 2017; He et al., 2016; Kumar et al., 2016; Ioffe & Szegedy, 2015; Vaswani et al., 2017).
Their prevalence has extended to embedded or mobile devices for edge intelligence, where security,
reliability or latency constraints refrain the networks from running on servers or in clouds. However,
large network sizes with the associated expensive computation and memory consumption make edge
intelligence even more challenging (Cheng et al., 2018; Sandler et al., 2018).
In response, as will be more detailed in Section 2, substantial effort has been made to reduce the
memory consumption of neural networks while minimizing the accuracy loss. The memory con-
sumption of neural networks can be reduced by either directly reducing the number of weights or
decreasing the number of bits (bit-width) needed to represent and store each weight, which can be
employed on top of each other (Choi et al., 2016). The number of weights can be reduced by pruning
(Han et al., 2015b), weight sparsifying (Liu et al., 2015), structured sparsity learning (Wen et al.,
2016) and low rank approximation (Denton et al., 2014). The bit-width is reduced by quantization
that maps data to a smaller set of distinct levels (Sze et al., 2017). Note that while quantization may
stand for linear quantization only (Li et al., 2017; Gysel et al., 2016) or nonlinear quantization only
(Han et al., 2015a; Choi et al., 2016) in different works, our discussion will cover both cases.
However, as of today quantization is still only empirically shown to be robust and effective to com-
press various neural network architectures (Hubara et al., 2016; Zhou et al., 2017b; Zhuang et al.,
2017). Its theoretical foundation still remains mostly missing. Specifically, many important ques-
tions remain unanswered. For example:
1
Published as a conference paper at ICLR 2019
•	Why even binarized networks, those most extremely quantized with bit-width down to one,
still work well in some cases?
•	To what extent will quantization decrease the expressive power of a network? Alterna-
tively, what is the overhead induced by weight quantization in order to maintain the same
accuracy?
In this paper, we provide some insights into these questions from a theoretical perspective. We focus
on ReLU networks, which is among the most widely used in deep neural networks (Xu et al., 2015).
We follow the idea from Yarotsky (2017) to prove the complexity bound by constructing a network,
but with new and additional construction components essential for quantized networks. Specifically,
given the number of distinct weight values λ and a target function f, we construct a network that can
approximate f with an arbitrarily small error bound to prove the universal approximability. The
memory size of this network then naturally serves as an upper bound for the minimal network size.
The high-level idea of our approach is to replace basic units in an unquantized network with quan-
tized sub-networks 1 that approximate these basic units. For example, we can approximate a con-
nection with any weight in an unquantized network by a quantized sub-network that only uses a
finite number of given weight values. Even though the approximation of a single unit can be made
arbitrarily accurate in principle with unlimited resources (such as increased network depth), in prac-
tice, there exists some inevitable residual error at every approximation, all of which could propagate
throughout the entire network. The challenge becomes, however, how to mathematically prove that
we can still achieve the end-to-end arbitrary small error bound even if these unavoidable residual
errors caused by quantization can be propagated throughout the entire network. This paper finds a
solution to solve the above challenge. In doing so, we have to propose a number of new ideas to
solve related challenges, including judiciously choosing the proper finite weight values, constructing
the approximation sub-networks as efficient as possible (to have a tight upper bound), and striking a
good balance among the complexities of different approximation steps.
Based on the bounds derived, we compare them with the available results on unquantized neural
networks and discuss its implications. In particular, the main contributions of this paper include:
•	We prove that even the most extremely quantized ReLU networks using two distinct weight
values are capable of representing a wide class of functions with arbitrary accuracy.
•	Given the number of distinct weights and the desired approximation error bound, we pro-
vide upper bounds on the number of weights and the memory size. We further show that our
upper bounds have good tightness by comparing them with the lower bound of unquantized
ReLU networks established in the literature.
•	We show that, to attain the same approximation error bound , the number of weights
needed by a quantized network is no more than O log5(1/) times that of an unquantized
network. This overhead is of much lower order compared with even the lower bound of the
number of weights needed for the error bound. This partially explains why many state-of-
the-art quantization schemes work well in practice.
•	We demonstrate how a theoretical complexity bound can be used to estimate an optimal
bit-width, which in turn enables the best cost-effectiveness for a given task.
The remainder of the paper is organized as follows. Section 2 reviews related works. Section 3 lays
down the models and assumptions of our analysis. We prove the universal approximability and the
upper bounds with function-independent structure in Section 4 and extend it to function-dependent
structure in Section 5. We analyze the bound-based optimal bit-width in Section 6. Finally, Section
7 discusses the results and gets back to the questions raised above.
2	Related Works
Quantized Neural Networks: There are rich literatures on how to obtain quantized networks, either
by linear quantization or nonlinear quantization (Zhou et al., 2017a; Leng et al., 2017; Shayar et al.,
1Throughout this paper, we use “sub-network” to denote a network that is used as a part of the final network
that approximates a target function.
2
Published as a conference paper at ICLR 2019
2017). Linear quantization does mapping with a same distance between contiguous quantization
levels and is usually implemented by storing weights as fixed-point numbers with reduced bit-width
(Li et al., 2017; Gysel et al., 2016). Nonlinear quantization maps the data to quantization levels that
are not uniformly distributed and can be either preselected or learned from training. Then the weights
are stored using lossless binary coding (the index to a lookup table) instead of the actual values (Han
et al., 2015a; Choi et al., 2016). It is reported that a pruned AlexNet can be quantized to eight bits
and five bits in convolutional layers and fully connected layers, respectively, without any loss of
accuracy. Similar results are also observed in LENET-300-100, LENET-5, and VGG-16 (Han et al.,
2015a). One may argue that some of these benchmark networks are known to have redundancy.
However, recent works show that quantization works well even on networks that are designed to
be extremely small and compact. SqueezeNet, which is a state-of-the-art compact network, can be
quantized to 8-bit while preserving the original accuracy (Gysel et al., 2016; Iandola et al., 2016).
There are some representative works that can achieve little accuracy loss on ImageNet classification
even using binary or ternary weights (Courbariaux et al., 2015; Rastegari et al., 2016; Li et al.,
2016; Zhu et al., 2016). More aggressively, some works also reduce the precision of activations,
e.g. (Hubara et al., 2016; Rastegari et al., 2016; Faraone et al., 2018). Although the classification
accuracy loss can be minimized, the universal approximation property is apparently lost, as with
limited output precision the network cannot achieve arbitrary accuracy. Accordingly, we do not
include them in the discussion of this paper. The limit of quantization is still unknown while the
state-of-the-art keeps getting updated. For example, VGG-16 is quantized to 3-bit while maintaining
the original accuracy (Leng et al., 2017). Motivated by the great empirical success, the training of
quantized neural networks has been analyzed theoretically, but not the network capacity (Li et al.,
2017; Choi et al., 2016).
Universal Approximability and Complexity Bounds: The universal approximability of ReLU net-
works is proved in Mhaskar & Micchelli (1992) and revisited in (Sonoda & Murata, 2017). Recently,
Hanin (2017) discusses the expressive power of ReLU networks with bounded width and proves that
a ReLU network with width d+1 can approximate any continuous convex function ofd variables ar-
bitrarily well. Shaham et al. (2016) construct a sparsely-connected depth-4 ReLU network and prove
its error bound. Liang & Srikant (2016) prove that, for a large class of piecewise smooth functions,
a network with ReLU and binary step units can provide an error bound with O(1/) layers and
O(poly log(1/)) neurons. The universal approximation property of low displacement rank (LDR)
neural networks has been proved by Zhao et al. (2017) under a mild condition on the displacement
operator, which is the result of another effective technique of neural network compression.
3	Models and Assumptions
Throughout this paper, we define ReLU networks as feedforward neural networks with the ReLU
activation function σ(x) = max(0, x). The ReLU network considered includes multiple input units,
a number of hidden units, and one output unit. Without loss of generality, each unit can only connect
to units in the next layer. Our conclusions on ReLU networks can be extended to any other networks
that use piecewise linear activation functions with finite breakpoints such as leaky ReLU and ReLU-
6 immediately, as one can replace a ReLU network by an equivalent one using these activation
functions while only increasing the number of units and weights by constant factors (Yarotsky,
2017).
We denote the finite number of distinct weight values as λ (λ ∈ Z+ and λ ≥ 2), for both lin-
ear quantization and nonlinear quantization. For linear quantization, without loss of generality,
We assume the finite number of distinct weight values are given as {-1,1, λ,..., λ-1}, where
{1, λ,..., λ-1} are uniformly spaced (hence called “linear”) in (0,1) and -1 is used to obtain the
negative weight values. For nonlinear quantization, we assume the finite number of distinct weight
values are not constrained to any specific values, i.e., they can take any values as needed. To store
each weight, we only need log(λ) 2 bits to encode the index, i.e. the bit-width is log(λ). The over-
head to store sparse structures can be ignored because it varies depending on the implementation and
can be easily reduced to the same order as the weight storage using techniques such as compressed
sparse row (CSR) for nonlinear quantization. The number of bits needed to store the codebook can
also be ignored because it has lower order of complexity.
2Throughout this paper, we omit base 2 for clarity of presentation
3
Published as a conference paper at ICLR 2019
We consider any function f in the Sobolev space: f ∈ Wn,∞([0, 1]d) and
max ess sup |Dnf(x)| ≤ 1.	(1)
mM≤nx∈[0,1]d
The space Wn,∞ consists of all locally integrable function f : Ω → R such that Dnf ∈ L∞(Ω),
where |n| ≤ n and Ω is an open set in Rd. We denote this function space as Fdn in this paper.
Note that we only assume weak derivatives up to order n exist where n can be as small as 1 where
the function is non-differentiable. We also only assume the Lipschitz constant to be no greater than
1 for the simplicity of the derivation. When the Lipschitz constant is bigger than 1, as long as it
is bounded, the whole flow of the proof remains the same though the bound expression will scale
accordingly.
When constructing the network to approximate any target function f, we consider two scenarios for
deriving the bounds. The first scenario is called function-dependent structure, where the constructed
network topology and their associated weights are all affected by the choice of the target function.
In contrast, the second scenario is called function-independent structure, where the constructed net-
work topology is independent of the choice of the target function in f ∈ Fd,n with a given . The
principle behind these design choices (the network topology constructions and the choice of weights)
is to achieve a tight upper bound as much as possible.
One might consider that we can transform an unquantized network within the error bound to a quan-
tized one in a straightforward way by approximating every continuous-value weight with a combi-
nation of discrete weights with arbitrary accuracy. However, the complexity of such approximation
(number of discrete weights needed) depends on the distribution of those continuous-value weights
(e.g., their min and max), which may vary depending on the training data and network structure
and a closed-form expression for the upper bounds is not possible. As such, a more elegant ap-
proach is needed. Below we will establish a constructive approach which allows us to bound the
approximation analytically.
4	Function-independent Structure
We start our analysis with function-independent structure, where the network topology is fixed for
any f ∈ Fd,n and a given . We first present the approximation of some basic functions by sub-
networks in Section 4.1. We then present the sub-network that approximates any weight in Section
4.2, and finally the approximation of general functions and our main results are in Section 4.3.
4.1	Approximation of s quaring/multiplication
Proposition 1. Denote the design parameter that determines the approximation error bound as r.
Let fS be a ReLU sub-network with only two weight values 2 and 一 2. The function fs(x) = x2
on the segment [0, 1] can be approximated by fsr, such that (i) if x = 0, fsr (x) = 0; (ii) the
approximation error s ≤ 2-2(r+1); (iii) the depth is O (r); (iv) the width is a constant; (v) the
number of weight is O (r).
The proof and the details of the sub-network constructed are included in Appendix A.1. Once
the approximation to squaring function is obtained, we get Proposition 2 by the fact that 2xy =
(x + y)2 一 x2 一 y2.
Proposition 2. Denote the design parameter that determines the approximation error bound as r.
Given X ∈ [一1,1], y ∈ [一1,1], and only two weight values ɪ and — 2, there is a ReLU sub-network
with two input units that implements a function ×0: R2 7→ R, such that (i) if x = 0 or y = 0, then
×0(x, y) = 0; (ii)for any X, y, the error e×× = | ×0 (x, y) — xy| ≤ 6 ∙ 2-2(r+1); (iii) the depth is
O (r); (iv) the width is a constant; (v) the number of weights is O (r).
Proof. Build three sub-networks fsr as described in Proposition 1 and let
×0 (X, y) = 2 (fsr (|X + y|/2) 一 fsr (|X|/2) 一 fsr (|y|/2)).	(2)
Then the statement (i) is followed by property (i) of Proposition 1. Using the error bound in Propo-
sition 1 and Equation (2), we get the error bound of ×0 :
e×o ≤ 6 ∙ 2-2(r+1).	(3)
4
Published as a conference paper at ICLR 2019
Since a sub-network Babs that computes σ(x) + σ(-x) can be constructed to get the absolute value
of x trivially, we can construct ×0(x, y) as a linear combination of three parallel fsr and feed them
with lχl, l2l, and lx++yl. Then claims of statement (iii), (iv), and (V) are also obtained.	□
4.2	Approximation of weights
Proposition 3. Denote the design parameter that determines the approximation error bound as t. A
connection with any weight w ∈ [-1, 1] can be approximated by a ReLU sub-network that has only
λ ≥ 2 distinct weights, such that (i) the sub-network is equivalent to a connection with weight w0
while the approximation error is bounded by 2-t i.e., ∣w0 一 w| < 2-t;(ii) the depth is O (λtλ-1);
(iii) the width is O(t);(iv) the number ofweights is O (λt占+1).
Proof. Consider that we need a weight w to feed the input x to a unit in the next layer as wx. With
a limited number of distinct weight values, we can construct the weight we need by cascade and
combination.
For clarity, we first consider w ≥ 0 and x ≥ 0, and relax these assumptions later. The connections
with w = 0 can be seen as an empty sub-network while w = 1 can be easily implemented by 4 units
with weight 11. Now We show how to represent all integral multiples of 2-t from 2-t to 1 一 2-t,
which will lead to the statement (i) by choosing the nearest one from w as w0 . Without loss of
generality, we assume t λ-1 is an integer. We use λ weights that include 一 1 and W:
1	2	λ — 2
W , {2-1,2-tλ-1,2-tE ,…，2-tλ-1}.	(4)
We first construct all w from Wc which is defined as
Wc，{2-1, 2-2,…，2-(t-1)}.	(5)
Similar to a numeral system with radix equal to t 占,any Wi ∈ Wc can be obtained by concatenating
weights from W while every weights in W is used no greater than tλ-1 一 1 times.
After that, all integral multiples of 2-t from 2-t to 1 - 2-t can be represented by a binary expansion
on Wc. Note that connections in the last layer for binary expansion use weight 11, thus additional
2-1 is multiplied to scale the resolution from 2-(t-1) to 2-t . Since for any weight in Wc we need
to concatenate no more than λ (t 占 一 1)weights in a straight line, the sub-network has no greater
than λ (tλ-1 ― 1)+1 layers, and no greater than 4tλ (t 占一1)+8t + 4 weights.
We now relax the assumption w ≥ 0. When w < 0, the sub-network can be constructed as w = |w|,
while we use 一 ɪ instead of 11 in the last layer. To relax the assumption X ≥ 0, we can make a
duplication of the sub-network. Let all the weights in the first layer of the sub-network be 11 for one
and 一 2 for the other. Here we are utilizing the gate property OfReLU.In this way, one sub-network
is activated only when x > 0 and the other is activated only when x < 0. The sign of the output
can be adjusted by flipping the sign of weights in the last layer. Note that the configuration of the
sub-network is solely determined by W and works for any input x.	□
The efficiency of the weight approximation is critical to the overall complexity. Compared with the
weight selection as {2-1,2-t占,2-tλ-1,..., 2-t~λ-1~}, our approximation reduces the number
λ 一 2
of weights by a factor of tλ-1.
4.3 Approximation of general functions
With the help of Proposition 2 and Proposition 3, we are able to prove the upper bound for general
functions.
Theorem 1.	For any f ∈ Fd,n , given λ distinct weights, there is a ReLU network with
fixed structure that can approximate f with any error ∈ (0, 1), such that (i) the depth is
5
Published as a conference paper at ICLR 2019
O (λ log λ--1 (1/e) + log (1/e)); (ii) the number of weights is O (λ logλ-1+1 (1∕c)(1∕c)n); (iii)
the numberofbits needed to store the network is O (λ log (λ) logλ--1+1 (l/e)(l/t)n).
The complete proof and the network constructed can be found in Appendix A.2. We first approxi-
mate f by f2 using the Taylor polynomial of order n - 1 and prove the approximation error bound.
Note that even when f is non-differentiable (only first order weak derivative exists), the Taylor
polynomial of order 0 at X = m can still be used, which takes the form of Pm = f (m).Then We
approximate f2 by a ReLU network that is denoted as f0 with bounded error. After that, we present
the quantized ReLU network that implements f0 and the complexity.
The discussion above focuses on nonlinear quantization which is a more general case compared to
linear quantization. For linear quantization, which strictly determines the available weight values
once λ is given, we can use the same proof for nonlinear quantization except for a different sub-
network for weight approximation with width t and depth ιogλ+1. Here we give the theorem and
the proof is included in Appendix A.3.
Theorem 2.	For any f ∈ Fd,n , given weight maximum precision 1, there is a ReLU network
with fixed structure that can approximate f with any error ∈ (0, 1), such that (i) the depth is
O (log (1∕e)); (ii) the number of weights is O ( (log (1∕e) + IOgogT)) (1∕e尸)；(iii) the number
of bits needed to store the network is O ((log(λ)log(1∕c) + log2 (1∕e)) (1∕c)n).
5	Function-dependent Structure
The network complexity can be reduced if the network topology can be set according to a specific
target function, i.e. function-dependent structure. In this section, we provide an upper bound for
function-dependent structure when d = 1 and n = 1, which is asymptotically better than that of a
fixed structure. Specifically, we first define an approximation to f(x) as f(x) that has special prop-
erties to match the peculiarity of quantized networks. Then we use piecewise linear interpolation
and “cached” functions (Yarotsky, 2017) to approximate f(x) by a ReLU network.
5.1	Function Transformation
While simply using piecewise linear interpolation at the scale of can satisfy the error bound with
O (1∕) weights, the complexity can be reduced by first doing interpolation at a coarser scale and
then fill the details in the intervals to make the error go down to . By assigning a “cached” function
to every interval depending on specific function and proper scaling, the number of weights is reduced
to O log-1 (1∕) 1∕ when there is no constraint on weight values (Yarotsky, 2017).
The key difficulty in applying this approach to quantized ReLU networks is that the required linear
interpolation at T exactly where i = 1, 2,…，T is not feasible because of the constraint on weight
selection. To this end, we transform f(x) to f(x) such that the approximation error is bounded; the
Lipschitz constant is preserved; f (T) are reachable for the network under the constraints of weight
selection without increasing the requirement on weight precision. Then we can apply the interpo-
lation and cached function method on f(x) and finally approximate f(x) with a quantized ReLU
network. Formally, we get the following proposition and the proof can be found in Appendix A.4.
Proposition 4. For any f ∈ F1,1, t ∈ Z+, and T ∈ Z+, there exists a function f(x) such that
(i) f(x) is a continuous function with Lipschitz constant 1; (ii) f( T)二 ∖Tf (T) ∕2-t] 2-t; (iii)
lf(χ) - f(χ)l < 2τt.
5.2	Approximation by ReLU Networks
With the help of Proposition 4 and the weight construction method described in Section 4.2, we are
able to apply the interpolation and cached function approach. Denoting the output of the network as
f 00 (x), we have |f (x) -f00(x)| = |f (x) -f (x)|+|f (x)-f 00(x)| ≤ by choosing appropriate hyper-
parameters which are detailed in Appendix A.5 and the network complexity is obtained accordingly.
6
Published as a conference paper at ICLR 2019
Theorem 3. For any f ∈ F1,1 , given λ distinct weights, there is a ReLU network
with function-dependent structure that can approximate f with any error ∈ (0, 1), such
that (i) the depth is O (λ(loglog(1/e))λ-1 +log(1∕c)); (ii) the number of weights is
O (λ (log log (1/e))λ-1+1 + (1/e)) (iii) the number of bits needed to store the network is
O Gogλ (λ (Ioglog (1∕e))λ-1+1 + (1/e))).
Using the different weight construction approach as in the case of function-independent structure,
we have the result for linear quantization:
Theorem 4. For any f ∈ F1,1, given weight maximum precision λ, there is a ReLU network with
function-dependent structure that can approximate f with any error ∈ (0, 1), such that (i) the
depth is O (log (1/)); (ii) the number of weights is O (1/); (iii) the number of bits needed to store
the network is O (log(λ)/).
6	B ound-based Optimal B it-width
In this section, we first introduce the optimal bit-width problem and then show how a theoretical
bound could potentially be used to estimate the optimal bit-width of a neural network.
Because of the natural need and desire of comparison with competitive approaches, most quanti-
zation techniques are evaluated on some popular reference networks, without modification of the
network topology. On the one hand, the advancement of lossless quantization almost stalls at a
bit-width between two and six (Han et al., 2015a; Choi et al., 2016; Sze et al., 2017; Blott et al.,
2017; Su et al., 2018; Faraone et al., 2018). A specific bit-width depends on the compactness of
the reference network and the difficulty of the task. On the other hand, the design space, especially
the different combinations of topology and bit-width, is largely underexplored because of the com-
plexity, resulting in sub-optimal results. A recent work by Su et al. (2018) empirically validates the
benefit of exploring flexible network topology during quantization. That work adds a simple vari-
able of network expanding ratio, and shows that a bit-width of four achieves the best cost-accuracy
trade-off among limited options in {1, 2, 4, 8, 16, 32}. Some recent effort on using reinforcement
learning to optimize the network hyper-parameters (He et al., 2018) could potentially be used to
address this issue. But the current design space is still limited to a single variable per layer (such as
the pruning ratio based on a reference network). How to estimate an optimal bit-width for a target
task without training could be an interesting research direction in the future.
The memory bound expression as derived in this paper helps us to determine whether there is an
optimal λ that would lead to the lowest bound and most compact network (which can be translated
to computation cost in a fully connected structure) for a given target function. For example, by drop-
ping the lower-order term and ignoring the rounding operator, our memory bound can be simplified
as
M(λ) = θιλlog(λ) logλ-ι+1(3n2d∕e)	(6)
where θ1 is a constant determined by , n, and d. We can find an optimal λ that minimizes M (λ):
λopt = argmin M(λ)	(7)
λ
As is detailed in Appendix B, we prove that there exists one and only one local minimum (hence
global minimum) in the range of [2, ∞) whenever e < 11. We also show that λ°pt is determined by
log 3n2d/ , which can be easily dominated by d. Based on such results, we quantitatively evaluate
the derivative of M (λ), and based on which the optimal bit-width log(λopt) under various settings
in Figure 1a and Figure 1b, respectively. In Figure 1b, we also mark the input dimension of a few
image data sets. It is apparent to see that the optimal bit width derived from M(λ) is dominated by
d and lies between one and four for a wide range of input size. This observation is consistent with
most existing empirical research results, hence showing the potential power of our theoretical bound
derivation.
Since the bounds are derived for fully connected networks and depend on the construction approach,
the interesting proximity between log(λopt) and the empirical results cannot be viewed as a strict
theoretical explanation. Regardless, we show that the complexity bound may be a viable approach
7
Published as a conference paper at ICLR 2019
(BY)MOI q⅛E Jlq pmxq⅛o
1.5
100
28x28 (MNIST)
256x256x166 (ADNI MRD
32x32x3 (CIFAR-10)
102	104	106
input dimention d
256x256x3 (ImageNet)
0 0 0 1 3
Ooooo
Illll
-----
n n n n n
-30............................................
100	101	102	103
λ
(a) Scaled derivative of M(λ)
(b) Optimal bit-width
Figure 1: Quantitative evaluation of the derivative of M(λ) and the optimal bit-width log(λopt).
-λ	d	-λ	d
The derivative is scaled by logλ-1 (3n2d) to fit in the same range. logλ-1 (3n2d) is a positive
monotonically increasing function and thus does not affect the trends too much. Note that λ is the
number of distinct weight values and thus log(λ) is the corresponding bit-width. It can be seen that
and n only affect log(λopt) when d is small (< 102). We also mark the input dimension d of various
image data set and their corresponding log(λopt). It shows that the optimal bit-width increases very
slowly with d.
to understand the optimal bit-width problem, thus potentially accelerating the hyper-parameter op-
timization of deep neural networks. We defer such a thorough investigation of the optimal bit-width
or optimal hybrid bit-width configuration across the network to our future work.
7 Discussion
In this section, we further discuss the bound of nonlinear quantization with a function-independent
structure as the generality of nonlinear quantization. The availability of unquantized function-
independent structures in literature also makes it an excellent reference for comparison.
Comparison with the Upper Bound: The quality of an upper bound lies on its tightness. Compared
with the most recent work on unquantized ReLU networks (Yarotsky, 2017), where the upper bound
on the number of weights to attain an approximation error e is given by O (log(1∕e) (1/e) d), our
result for a quantized ReLU network is given by O (λ (logλ-1+1(1∕e)) (1/e) nd^, which translates
to an increase by a factor of λ (logλ-1 (1/e)). Loosely speaking, this term reflects the loss of
expressive power because of weight quantization, which decreases quickly as λ increases.
Comparison with the Lower Bound: We also compare our bound with the lower bound of the
number of weights needed to attain an error bound of e to have a better understanding on the tightness
of the bound. We use the lower bound for unquantized ReLU networks from (Yarotsky, 2017), as it
is also a natural lower bound for quantized ReLU networks. Under the same growth rate of depth, the
lower bound is given by Ω(log-3(1∕e) (1/e)d/n), while our upper bound is, within a polylog factor
when λ is a constant, O(λlogλ-1+1(1/e)(1/e)d/n). The comparison validates the good tightness
of our upper bound.
The Upper Bound of Overhead: More importantly, the above comparison yields an upper bound
on the possible overhead induced by quantization. By comparing the expressions of two bounds
while treating λ as a constant, we can show that, to attain the same approximation error bound e,
the number of weights needed by a quantized ReLU network is no more than O(log5(1/e)) times
that needed by an unquantized ReLU network. Note that this factor is of much lower order than
the lower bound C(log-3(1/e) (1/e)d/n). This little overhead introduced by weight quantization
explains in part the empirical success on network compression and acceleration by quantization and
8
Published as a conference paper at ICLR 2019
also answers in part the questions as raised in Section 1. Given the significant benefits of quantization
in term of memory and computation efficiency, we anticipate that the use of quantization networks
will continue to grow, especially on resource-limited platforms.
Future Work: There remain many other avenues for future investigation. For example, although
we derived the first upper bound of quantized neural networks, the lower bound is still missing. If a
tight lower bound of the network size is established, it could be combined with the upper bound to
give a much better estimation of required resources and the optimal bit-width. We believe the trends
associated with the bounds can also be useful and deserve some further investigation. For example,
the trend may help hardware designers in their early stage of design exploration without the need of
lengthy training. While we assume a uniform bit-width across all layers, another area of research is
to allow different bit-widths in different layers, which could achieve better efficiency and potentially
provide theoretical justifications on the emerging trend of hybrid quantization (Zhang et al., 2017;
Wang et al., 2018).
References
Michaela Blott, Thomas B Preuβer, Nicholas Fraser, Giulio Gambardella, Kenneth O'Brien, Yaman
Umuroglu, and Miriam Leeser. Scaling neural network performance through customized hard-
ware architectures on reconfigurable logic. In Computer Design (ICCD), 2017 IEEE International
Conference on,pp. 419-422. IEEE, 2017.
Guobin Chen, Wongun Choi, Xiang Yu, Tony Han, and Manmohan Chandraker. Learning efficient
object detection models with knowledge distillation. In Advances in Neural Information Process-
ing Systems, pp. 742-751, 2017.
Jian Cheng, Pei-song Wang, Gang Li, Qing-hao Hu, and Han-qing Lu. Recent advances in effi-
cient computation of deep convolutional neural networks. Frontiers of Information Technology &
Electronic Engineering, 19(1):64-77, 2018.
Yoojin Choi, Mostafa El-Khamy, and Jungwon Lee. Towards the limit of network quantization.
arXiv preprint arXiv:1612.01543, 2016.
Matthieu Courbariaux, Yoshua Bengio, and Jean-Pierre David. Binaryconnect: Training deep neural
networks with binary weights during propagations. In Advances in Neural Information Processing
Systems, pp. 3123-3131, 2015.
Emily L Denton, Wojciech Zaremba, Joan Bruna, Yann LeCun, and Rob Fergus. Exploiting linear
structure within convolutional networks for efficient evaluation. In Advances in Neural Informa-
tion Processing Systems, pp. 1269-1277, 2014.
Julian Faraone, Nicholas Fraser, Michaela Blott, and Philip HW Leong. Syq: Learning symmet-
ric quantization for efficient deep neural networks. In Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition, pp. 4300-4309, 2018.
Philipp Gysel, Mohammad Motamedi, and Soheil Ghiasi. Hardware-oriented approximation of
convolutional neural networks. arXiv preprint arXiv:1604.03168, 2016.
Song Han, Huizi Mao, and William J Dally. Deep compression: Compressing deep neural networks
with pruning, trained quantization and huffman coding. arXiv preprint arXiv:1510.00149, 2015a.
Song Han, Jeff Pool, John Tran, and William Dally. Learning both weights and connections for
efficient neural network. In Advances in Neural Information Processing Systems, pp. 1135-1143,
2015b.
Boris Hanin. Universal function approximation by deep neural nets with bounded width and relu
activations. arXiv preprint arXiv:1708.02691, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. In European Conference on Computer Vision, pp. 630-645. Springer, 2016.
Yihui He, Ji Lin, Zhijian Liu, Hanrui Wang, Li-Jia Li, and Song Han. Amc: Automl for model
compression and acceleration on mobile devices. In Proceedings of the European Conference on
Computer Vision (ECCV), pp. 784-800, 2018.
9
Published as a conference paper at ICLR 2019
Itay Hubara, Matthieu Courbariaux, Daniel Soudry, Ran El-Yaniv, and Yoshua Bengio. Quantized
neural networks: Training neural networks with low precision weights and activations. arXiv
preprint arXiv:1609.07061, 2016.
Forrest N Iandola, Song Han, Matthew W Moskewicz, Khalid Ashraf, William J Dally, and Kurt
Keutzer. SqUeezenet: Alexnet-level accuracy with 50x fewer parameters andj 0.5 mb model size.
arXiv preprint arXiv:1602.07360, 2016.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015.
Ankit Kumar, Ozan Irsoy, Peter Ondruska, Mohit Iyyer, James Bradbury, Ishaan Gulrajani, Victor
Zhong, Romain Paulus, and Richard Socher. Ask me anything: Dynamic memory networks for
natural language processing. In International Conference on Machine Learning, pp. 1378-1387,
2016.
Cong Leng, Hao Li, Shenghuo Zhu, and Rong Jin. Extremely low bit neural network: Squeeze the
last bit out with admm. arXiv preprint arXiv:1707.09870, 2017.
Fengfu Li, Bo Zhang, and Bin Liu. Ternary weight networks. arXiv preprint arXiv:1605.04711,
2016.
Hao Li, Soham De, Zheng Xu, Christoph Studer, Hanan Samet, and Tom Goldstein. Training
quantized nets: A deeper understanding. In Advances in Neural Information Processing Systems,
pp. 5811-5821, 2017.
Shiyu Liang and R Srikant. Why deep neural networks for function approximation? arXiv preprint
arXiv:1610.04161, 2016.
Baoyuan Liu, Min Wang, Hassan Foroosh, Marshall Tappen, and Marianna Pensky. Sparse convolu-
tional neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 806-814, 2015.
Hrushikesh N Mhaskar and Charles A Micchelli. Approximation by superposition of sigmoidal and
radial basis functions. Advances in Applied mathematics, 13(3):350-373, 1992.
Mohammad Rastegari, Vicente Ordonez, Joseph Redmon, and Ali Farhadi. Xnor-net: Imagenet
classification using binary convolutional neural networks. In European Conference on Computer
Vision, pp. 525-542. Springer, 2016.
Mark Sandler, Andrew Howard, Menglong Zhu, Andrey Zhmoginov, and Liang-Chieh Chen. In-
verted residuals and linear bottlenecks: Mobile networks for classification, detection and segmen-
tation. arXiv preprint arXiv:1801.04381, 2018.
Uri Shaham, Alexander Cloninger, and Ronald R Coifman. Provable approximation properties for
deep neural networks. Applied and Computational Harmonic Analysis, 2016.
Oran Shayar, Dan Levi, and Ethan Fetaya. Learning discrete weights using the local reparameteri-
zation trick. arXiv preprint arXiv:1710.07739, 2017.
Sho Sonoda and Noboru Murata. Neural network with unbounded activation functions is universal
approximator. Applied and Computational Harmonic Analysis, 43(2):233-268, 2017.
Jiang Su, Nicholas J Fraser, Giulio Gambardella, Michaela Blott, Gianluca Durelli, David B
Thomas, Philip HW Leong, and Peter YK Cheung. Accuracy to throughput trade-offs for reduced
precision neural networks on reconfigurable logic. In Applied Reconfigurable Computing. Archi-
tectures, Tools, and Applications: 14th International Symposium, ARC 2018, Santorini, Greece,
May 2-4, 2018, Proceedings, volume 10824, pp. 29. Springer, 2018.
Vivienne Sze, Yu-Hsin Chen, Tien-Ju Yang, and Joel Emer. Efficient processing of deep neural
networks: A tutorial and survey. arXiv preprint arXiv:1703.09039, 2017.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Infor-
mation Processing Systems, pp. 6000-6010, 2017.
10
Published as a conference paper at ICLR 2019
Junsong Wang, Qiuwen Lou, Xiaofan Zhang, Chao Zhu, Yonghua Lin, and Deming Chen. Design
flow of accelerating hybrid extremely low bit-width neural network in embedded fpga. arXiv
preprint arXiv:1808.04311, 2018.
Wei Wen, Chunpeng Wu, Yandan Wang, Yiran Chen, and Hai Li. Learning structured sparsity in
deep neural networks. In Advances in Neural Information Processing Systems, pp. 2074-2082,
2016.
Bing Xu, Naiyan Wang, Tianqi Chen, and Mu Li. Empirical evaluation of rectified activations in
convolutional network. arXiv preprint arXiv:1505.00853, 2015.
Dmitry Yarotsky. Error bounds for approximations with deep ReLU networks. Neural Networks,
94:103-114, 2017.
Xiaofan Zhang, Xinheng Liu, Anand Ramachandran, Chuanhao Zhuge, Shibin Tang, Peng Ouyang,
Zuofu Cheng, Kyle Rupnow, and Deming Chen. High-performance video content recognition
with long-term recurrent convolutional network for fpga. In Field Programmable Logic and Ap-
plications (FPL), 2017 27th International Conference on, pp. 1-4. IEEE, 2017.
Liang Zhao, Siyu Liao, Yanzhi Wang, Jian Tang, and Bo Yuan. Theoretical properties for neural
networks with weight matrices of low displacement rank. arXiv preprint arXiv:1703.00144, 2017.
Aojun Zhou, Anbang Yao, Yiwen Guo, Lin Xu, and Yurong Chen. Incremental network quantiza-
tion: Towards lossless cnns with low-precision weights. arXiv preprint arXiv:1702.03044, 2017a.
Yiren Zhou, Seyed-Mohsen Moosavi-Dezfooli, Ngai-Man Cheung, and Pascal Frossard. Adaptive
quantization for deep neural network. arXiv preprint arXiv:1712.01048, 2017b.
Chenzhuo Zhu, Song Han, Huizi Mao, and William J Dally. Trained ternary quantization. arXiv
preprint arXiv:1612.01064, 2016.
Bohan Zhuang, Chunhua Shen, Mingkui Tan, Lingqiao Liu, and Ian Reid. Towards effective low-
bitwidth convolutional neural networks. arXiv preprint arXiv:1711.00205, 2017.
11
Published as a conference paper at ICLR 2019
A	Proofs
A.1 The proof of Proposition 1
Proposition 1. Denote the design parameter that determines the approximation error bound as r.
Let fS be a ReLU sub-network with only two weight values 2 and 一 2. The function fs(x) = x2
on the segment [0, 1] can be approximated by fsr, such that (i) if x = 0, fsr (x) = 0; (ii) the
approximation error s ≤ 2-2(r+1); (iii) the depth is O (r); (iv) the width is a constant; (v) the
number of weight is O (r).
Proof. For fs(x) = x2, let fsr be the piecewise linear interpolation of f with 2r + 1 uniformly
distributed breakpoints 2r ,k = 0,..., 2r. We have fr (2k)=(分)2, k = 0,..., 2r and the
approximation error e5 = ||f； (x)-fs(x)∣∣∞ ≤ 2-2(r+1). We can use the function g : [0,1] → [0,1]
to obtain fsr :
g3 = {2Xi-x) x≥ 2,	⑻
r
fS (X) = X - X 2-2ig°i (x)	(9)
i=1
where g。IX) is the i-th iterate of g(χ). Since g(χ) can be implemented by a ReLU sub-network
as g(x) = 2σ(x) 一 4σ(x - 2), gor (x) can be obtained by concatenating such implementa-
tion of g(χ) for r times. Now, to implement fS(x) based on gor (x), all We need are weights
{2-2, 2-4,…,2-2(r-1), 2-2r}, which can be easily constructed with additional 2r layers and the
weight 1.
Note that a straightforward implementation will have to scale g。IX) separately (multiply by differ-
ent numbers of 11) before subtracting them from X because each g。IX) have a different coefficient.
Then the width of the network will be Θ(r). Here we use a “pre-scale” method to reduce the net-
work width from Θ(r) to a constant. The network constructed is shown in Figure 2. The one-layer
sub-network that implements g(X) and the one-layer sub-network that scales the input by 4 are de-
noted as Bg and Bm respectively. Some units are copied to compensate the scaling caused by 11.
The intermediate results g。' (x) are computed by the concatenation of Bg atthe (i + 1)-th layer. The
first Bm takes X as input and multiply it by 4. The output of i-th Bm is subtracted by g°i(X) and
then fed to the next Bm to be multiplied by 4 again. There are r layers of Bm and all g°i(X) are
scaled by 22(r-i) respectively. As a result, we obtain 22rX - PS=ι 22(r-i)goi(x) after the last Bm.
Then it is scaled by 2-2r in the later 2r layers to get fS (x). In this way, we make all g。' (x) sharing
the same scaling link and a constant width can be achieved.
□
2r
Figure 2: A qunatized ReLU network that implements fsr (X). In the interest of clarity, we depict
the sub-networks with different functions as different colored blocks. A connection from or to a
block indicates connections from or to all units in the block. Details of block Bm and block Bg are
depicted on the left. b and w denote bias and weight respectively.
12
Published as a conference paper at ICLR 2019
A.2 The proof of Theorem 1
Theorem 1. For any f ∈ Fd,n , given λ distinct weights, there is a ReLU network with
fixed structure that can approximate f with any error ∈ (0, 1), such that (i) the depth is
O (λ log λ--1 (1/e) + log (1/e)); (ii) the number of weights is O (λ log 占+1 (1∕c)(1∕c)n); (iii)
the numberofbits needed to store the network is O (λ log (λ) logλ--1+1 (1∕e) (1∕e)行).
Proof. The proof is composed of four steps. We first approximate f by f2 using the Taylor poly-
nomial of order n - 1 and prove the approximation error bound. Note that even when f is non-
differentiable (only first order weak derivative exist), the Taylor polynomial of order 0at X = n can
still be used, which takes the form of Pm = f (m).Then We approximate f2 by a ReLU network
that is denoted as f0 with bounded error. After that, we present the quantized ReLU network that
implements the network f0 and the complexity of the network.
We use a partition of unity on [0,1]d: Pm ψm(x) ≡ 1, X ∈ [0,1]d where m = (mi,…，md) ∈
{0,1,…，N}d, and h(χ) is defined as follows:
d
ψm(X) = Y h(3N xk - 3mk),	(10)
k=1
where N is a constant and
f1
h(x) =	2 - |x|
10
Note that supp ψm ⊂ {x ： ∣Xk - mNk∖ < N∀k}.
polynomial for the function f at X = N as
|x| ≤ 1
1 < |X| <2.	(11)
|X| ≥ 2
For all m, we have the order n - 1 Taylor
Pm(X)
Σ
n:|n|<n
Dnf∖
n! ∖x= Nm
(12)
To get a more realizable approximation for quantized networks, we define Pm0 (X)
Pn:|n|<n βm,n (X - N)n where βm,n 13 * is
Dnf ∖
n! ∖χ= Nm
rounded to the nearest integral multiple of
n (N)n-|n|. Then we get an approximation to f using Pm and ψm as f2，Pm∈{0,…,N}d ΨmPm.
Then the approximation error of f2 is bounded by Equation (13).
|f(X)-f2(X)|=|	ψm(X)(f (X) - Pm0 (X))|
m
≤	|f(X) - Pm0 (X)|
m： | Xk- mNk | < NN ∀k
≤ 2d max
m:|xk-mNk |<N∀k
If(X)- Pm(X)1 + 2d m：|xW< N ∀klPm(X)- Pm (X)I
≤
(X -
n
≤ 2d (Nd ∏1+⅛
max ess sup IDnf(X)I + 2d
n:|n|=n X∈[0,1]d
max
n:|n|<n
(13)
The second step follows ψm(X) = 0 when X ∈∕ suppψm. In the third step we turn the sum to
multiplication, because for any X there are up to 2d terms ψm(X) that are not equal to zero. The
fourth step uses a Lagrange’s form of the Taylor remainder. The fifth step follows different round
13
Published as a conference paper at ICLR 2019
precision of βm,n in different order and the fact that the number of terms with order i is not greater
than di .
We rewrite f2 as
f2(x) =	X X βm,nfm,n(x),	(14)
m∈{0,…,N}d n:|n|<n
where
mn
fm,n(x) = Ψm (x - N) .	(15)
Note that βm,n is a constant and thus f2 is a linear combination of at most dn(N + 1)d terms of
fm,n(x). Note that when d = 1, the number of terms should be n(N+ 1)d instead; but for simplicity
of presentation we loosely use the same expression as they are on the same order.
We define an approximation to fm,n(x) as fm0 ,n(x). The only difference between fm,n(x) and fm0 ,n(x)
is that all multiplication operations are approximated by ×0 as discussed in Proposition 2. Consider
that if we construct our function ×0 with | ×0 (x, y) - xy| < ×0 = 2-2(r+1), then
| ×0 (x, y) -xz| ≤ |x(y - z)| +×0.	(16)
Applying Equation (16) to |fm0 ,n(x) - fm,n(x)| repeatedly, we bound it to Equation (17).
fm0 ,n(x) - fm,n(x) =
×0 (h(3Nx1 - 3mI),…，×0 (h(3Nxd - 3md), ×0 ((xiι---N) , ×0 (…，(xi|n|---NI)))))
-(h(3Nχ1	- 3m1) (h(3Nχ2 -	3m2)	∙ ∙ ∙ (h(3Nχd -	3md)	((xiι-N-)…(χi∣n∣---Nl)))))
≤ (d + lnl)e×0	i1,…，i|n| ∈ 口，2,…，d}
(17)
Finally, we define our approximation to f(x) as f0(x):
f0(x) ,	X X	βm,nfm0 ,n(x).
m∈{0,…，N}d n:0<|n|<n
Using Equation (17), we get the error bound of the approximation to f2(x) as in Equation (19).
If0(x) - f2(x)I = I X X βm,n (fm,n(X)- fm,n(x)) I
m∈{0,…,N}d n:|n|<n
=I X X βm,n (fm,n(X)- fm,n(x)) I
mx∈suppψm n: ∣n∣ <n	I
≤ 2d	max X Ifm0,n(x) - fm,n(x)I
m=x∈suppψm
n:|n|<n
(18)
(19)
≤ 2ddn(d+n- 1)×0.
The second line follows again the support property and statement (i) of Proposition 2. The third line
uses the bound ∣βm,n∣ ≤ 1. The fourth line is obtained by inserting Equation (17).
Then the final approximation error bound is as follows:
|f0(x)-f(x)| ≤ |f 0(x) - f2(x)| + |f (x) - f2(x)|
≤ 2ddn(d + n - 1) e×0 + 2d+1 (N
n
(20)
Using statement (ii) of Proposition 2 and choosing r as r
error turns to
log(6N n(d+n-1))
- 1, the approximation
If0(x) - f(x)l≤ 3 ∙ 2d 1N
(21)
2
n
14
Published as a conference paper at ICLR 2019
Figure 3: A qunatized ReLU network that implements f0 (x). The connections of all Bfmn are the
same. Every connection from BN to other blocks has no greater than two weights.
Table 1: Block configuration for function-independent structure
block	function	width	depth
Bw	construct weights	t	~λ(tλ-1 — 1)+1 ~
BN	ConStrUCt N,…,N-I	2N	1
Babs	get absolute values	4	1
Bs	scale by 3N	4	log 3N
Bh	implement h(x)	12	1
B×0	implement x0(x,y)	60	3r + 1
Therefore, for any f ∈ Fd,n and ∈ (0, 1), there is a ReLU network f0 that approximate f with
error bound e if We choose N ≥(3 ∙ 2ddn∕ e”.
We now present the construction of the network for f0(x). If every fm0 ,n(x) can be computed by a
sub-netWork, then f0(x) is simply a Weighted sum of all outputs of fm0 ,n(x). By Proposition 3, We
can implement the needed weights βm,n by choosing t = log nNn. Then We simplify the task to
constructing fm0 ,n(x).
×0 can be implemented as discussed in Proposition 2. For h((3N (Xi - m)),noticing that
h(x) = h(-x), we can first compute |xi - mNi| as σ(xi - mNi) + σ(mNi — Xi) and then scale it
to 3N (|xi - mNi |). The implementation of h(x) can thus be simplified as 1 - σ(x - 1) + σ(x - 2)
since the input is nonnegative. Furthermore, by choosing N as Cd where C ∈ N and c > 1, N is an
integral multiple of 1 (N)n if n > 1. When n = 1, N is an integral multiple of (1 (N)n) . As
discussed in Proposition 3, we build a weight construction network Bw in the way that all integral
multiples of the minimal precision can be obtained. Therefore, all 爷 can be obtained in the same
way as βm,n, except that we need to concatenate two weight construction sub-networks.
Now we analyze the complexity of the network. The implementation of f0(X) is shown in Figure 3.
The function and size of blocks are listed in Table 1. Then we are able to obtain the complexity of
the network. While we can write the complexity of the network in an explicit expression, here we
use the O notation for clarity. Let Nd, Nw, Nb be the depth, the number of weights, and the number
of bits required respectively. The weight construction blocks Bw have the highest order of number
of weights and we have Nw = O (λt 占+1Nd). Meanwhile, we get Nd = O (λt 占 + log N).
Inserting t = log n-Nn and N = O ((1/e)n), we get Nd = O (λlog占(1/e) + log(1∕e)) and
Nw = O (λlog占+1 (1∕e)(1∕e)d). Multiplying Nw by logλ, NbiS obtained. This concludes
the proof of Theorem 1.
□
15
Published as a conference paper at ICLR 2019
Figure 4: An example to illustrate the relationship between f (x), f+ and fe(x).
A.3 The proof of Theorem 2
Theorem 2. For any f ∈ Fd,n , given weight maximum precision 1, there is a ReLU network
with fixed structure that can approximate f with any error ∈ (0, 1), such that (i) the depth is
O (log(1∕e)); (ii) the number of weights is O ( (log (1/e)+ Iogog/)) (1/e尸)；(iii) the number
of bits needed to store the network is O ((log(λ)log(1∕e) + log2 (1/e)) (1∕e)n).
With λ distinct values, a linearly quantized network has a minimal resolution of 1. The proof for
the approximability of linear quantization can be done in the same way as Theorem 1 except for a
different sub-network for weight approximation. We still construct Wc in Proposition 3 first and any
weight value from Wc can be obtained by multiply at most Wλ weights. ThUS the width and depth
of the weight approximation network will be t and -ogλ + 1 respectively. Updating the Bw in Table
1, we obtain the complexity accordingly.
A.4 The proof of Proposition 4
Proposition 4. For any f ∈ F1,1, t ∈ Z+, and T ∈ Z+, there exists a function f(x) such that
(i) f(x) is a continuous function with Lipschitz constant 1; (ii) f( T) = ∖Tf (T) /2-t] 2-t; (iii)
lf(χ) - f(χ)l < 2τ-.
Proof. We first divide [0, 1] into T intervals uniformly and define f+ (x) as
f+(x) , f(x) + (1f (dτTxe) /2-t] 2Tt - f (dTxe)) .	(22)
Note that f +(T) = ∖Tf (T) /2-t]筝 and df+(x)
Then, we define f (x):
f(0)，[T^
dd(χ) on( T, i+T1) where, i = 1, 2, ∙∙∙, T.
2-t
T
(23)
df(X) , JSgn(f+(x) - f(x))
dx
fe(x) 6= f+ (x)
~.. ,..
fe(x) = f+ (x).
(24)
f +(x) is parallel with f (x) on any given interval (T, i+1 ] and is shifted to let f+ (T) be an inte-
2-t	i	i	2-t
gral multiple of 2r~∙ f (T) is f (T) rounded up to an integral multiple of 2r~∙ Meanwhile, f (x)
approaches f(x) with fixed slope whenever they are not equal. An example is shown in Figure 4.
Statement (i) follows the definition of f(x) directly. We give a proof for statement (ii) by contra-
diction and induction. If f (T) = f +(T), then f (x) = f +(x) on (T, i+1 ]. The proof idea for
f (T) > f +(T) and f (T) < f +(T) are basically the same thus we present the proof of the latter
for brevity. We first assume f (T) = [Tf (T) /2-t] 2Tt, which is satisfied by Equation (23) when
16
Published as a conference paper at ICLR 2019
i i+1
i = 0. Since f (x) = f +(x) after the first intersection on (T, i+1 ], if f (x) and f +(x) have no
intersection on (T, i+1 ], then f (i+1) < f +(i++1) because f (T) < f +(T). Meanwhile, we have
_ ~,.
dfe(x) = 1, and
dx	,
i+1
f∖T
T df(x) dx
dx
Tf (T) /2-t
2-t	1
7 + T
τ(f(T)+T)/2-t
2-t
丁
(25)
≥
≥ f+
/2-t
2-t
丁





一.	一.	一 _	一 ≈, √ I -1 .	ʌ ,	, √ I -1 . 一	T, .	一 一 ， ，	、	.	√ ,	一.
This contradicts the fact that f (i+1) < f +(i+1). Thus f (x) and f +(x) intersect on (0, T] and m
-t
turn guarantee that f (i+1) = Tff (i+1) /2 t] 2τ-. By induction, We prove that f (x) and f +(x)
intersect on every interval (T, i++1 ]. This implies statement (ii).
i	i	2-t
Now we prove the statement (iii). Note that we have 0 ≤ f (T) - f (T) ≤ 2r~ by statement
(ii). In every interval (T, i+1), f (x) = f +(x) after the their intersection. Therefore we have 0 ≤
|f +(x) - f (x)| ≤ 2Tt by Equation (22). Before the intersection, if f(0) < f +(0), d(f(X)C-f +(x)) ≥
+
0. Since dfdX-) = f) on (TT, i+1), wePaVe d(f( d-f())≥ 0, thus 0 ≤ f(TT) - f(TT) ≤
f (x) - f (x) ≤ f +(x) - f (x) ≤ 2-t. If f (TT) ≥ f +(T), apply the same logic and we obtain
0 ≤ f +(x) - f (x) ≤ f (x) - f (x) ≤ f (T) - f(T) ≤ 2Tt. This implies statement (iii) and
concludes the proof.	□
A.5 The proof of Theorem 3
Theorem 3.	For any f ∈ F1,1 , given λ distinct weights, there is a ReLU network
with function-dependent structure that can approximate f with any error ∈ (0, 1), such
that (i) the depth is O (λ(loglog(1/e))λ-1 +log(1∕c)); (ii) the number of weights is
O (λ (log log (1/e))λ-τ+1 + (1/e)) (iii) the number of bits needed to store the network is
O Gogλ (λ (Ioglog (1/e))λ-τ+1 + (1/e))).
Proof. We first transform f to f00 with Proposition 4. Then we apply the interpolation and cached
function method from [35] while using the weight construction method described in Proposition
3. Denoting the output of the network as f 00 (x), we have |f (x) - f00 (x)| = |f (x) - f (x)| +
|f (x) - f00 (x)| ≤ by choosing the hyper-parameters as m
de log(1∕e)e
T
d1 Iog(I∕e)^I, t = dlog me, δ = 8m
The approximation network is shown in Figure 5. The sizes of blocks are given in Table 2 where fT
is the uniform linear interpolation function of f with T -1 breakpoints, f * is the sum of the selected
cached functions, Φ(x) is a filtering function. The inputs connections to Bf * and the connections
inside Bm have higher order to the number of weights than others. Then the complexity can be
obtained accordingly.	□
A.6 The proof of Theorem 4
Theorem 4.	For any f ∈ F1,1, given weight maximum precision 1, there is a ReLU network with
function-dependent structure that can approximate f with any error ∈ (0, 1), such that (i) the
17
Published as a conference paper at ICLR 2019
Figure 5: A qunatized ReLU network that implements f00(x). Illustration only, details are omitted.
For example, arrows between blocks can represent more than one connection in the network and
there are short-cut connections that allow scaling only part of the inputs.
Table 2: Block configuration for function-dependent structure. Terms with lower order are omitted.
block	function	width	depth
BT	construct 1,2,… ,T	log T	logT
Bδ	construct δ	1	λ(tλ-1)
Bm	construct —,…,m—1 mm	t	λ(t 占)
BfT	implement fT (x)	T	1
BΦ	implement Φ(x)	4T	1
Bs1	scale by T	4	logT
Bs2	scale by *	1	logT
Bs3	scale by 1	4	log m
BfI	first layer of f *	T	1
Bf	second layer of f *	3m	1
Bf3	third layer of f *	m3m	1
Bf00	implement f 00(x)	4	1
depth is O (log (1/)); (ii) the number of weights is O (1/); (iii) the number of bits needed to store
the network is O (log(λ)/).
Proof. The proof for the approximability of linear quantization can be done in the same way as
Theorem 3 except for a different sub-network for weight approximation. We still construct Wc in
Proposition 3 first and any weight value from Wc can be obtained by multiply at most ιogλ weights.
Thus the width and depth of the weight approximation network will be t and iogʌ + 1 respectively.
Updating the Bδ and Bm in Table 2, we obtain the complexity accordingly.	□
B The existence of an optimal bit-width
In this section, we prove the statement in Section 6 that there exists one and only one local minimum
(hence global minimum) for M(λ) in the range of [2, ∞) whenever e < 2. Denote log(3n2d∕e) as
θ2 and we get the derivative of M(λ) as:
dM
"dλ
λ
θ λ 一 1
1
+ m2
- ln(θ2 )
λ log(λ))
(I-T)2 )
(26)
Let Ms(λ) = log(λ) + 焉-lnQ) ：；—(y. Since。11 > 0, We have Sgn(Ms) = sgn ^dM
We have
dMs	1
---=—+
dλ λ +
1 -λ + log(λ) + λ log(λ)
(λ-1)3
> 0,	∀λ ≥ 2
(27)
Ms(2) = 1 + ml2 - 2in(θ2) < 0 given e < 1, and limλ→∞ Ms(λ) = ∞. Itis clear that there exist a
λopt determined by θ2 such that sgn(Ms(λ)) = -1 on [2, λopt) and sgn(Ms(λ)) = 1 on (λopt, ∞).
18
Published as a conference paper at ICLR 2019
Remember that sgn(Ms)
M(λ) on [2, ∞).
dM
sgn( lλ )then λ
λopt is the one and only one local minimum of
19