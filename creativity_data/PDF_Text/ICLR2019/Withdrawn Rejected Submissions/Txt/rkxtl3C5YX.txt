Under review as a conference paper at ICLR 2019
Understanding & Generalizing AlphaGo Zero
Anonymous authors
Paper under double-blind review
Ab stract
AlphaGo Zero (AGZ) (Silver et al., 2017b) introduced a new tabula rasa rein-
forcement learning algorithm that has achieved superhuman performance in the
games of Go, Chess, and Shogi with no prior knowledge other than the rules of the
game. This success naturally begs the question whether it is possible to develop
similar high-performance reinforcement learning algorithms for generic sequential
decision-making problems (beyond two-player games), using only the constraints
of the environment as the “rules.” To address this challenge, we start by taking
steps towards developing a formal understanding of AGZ. AGZ includes two key
innovations: (1) it learns a policy (represented as a neural network) using super-
vised learning with cross-entropy loss from samples generated via Monte-Carlo
Tree Search (MCTS); (2) it uses self-play to learn without training data.
We argue that the self-play in AGZ corresponds to learning a Nash equilibrium
for the two-player game; and the supervised learning with MCTS is attempting to
learn the policy corresponding to the Nash equilibrium, by establishing a novel
bound on the difference between the expected return achieved by two policies in
terms of the expected KL divergence (cross-entropy) of their induced distributions.
To extend AGZ to generic sequential decision-making problems, we introduce a
robust MDP framework, in which the agent and nature effectively play a zero-sum
game: the agent aims to take actions to maximize reward while nature seeks state
transitions, subject to the constraints of that environment, that minimize the agent’s
reward. For a challenging network scheduling domain, we find that AGZ within
the robust MDP framework provides near-optimal performance, matching one of
the best known scheduling policies that has taken the networking community three
decades of intensive research to develop.
1 Introduction
In 2016, AlphaGo (Silver et al., 2016) became the first program to defeat the world champion in the
game of Go. Soon after, another program, AlphaGo Zero (AGZ) (Silver et al., 2017b), achieved even
stronger performance despite learning the game from scratch given only the rules. Starting tabula
rasa, AGZ mastered the game of Go entirely through self-play using a new reinforcement learning
algorithm. The same algorithm was recently shown to achieve superhuman performance in Chess and
Shogi (Silver et al., 2017a). The goal of this paper is to develop a formal understanding of AGZ’s
learning algorithm, and to extend it to sequential decision problems beyond two-player games.
Overview of AGZ. AGZ is designed for a two-player zero-sum game such as Go. The core idea of
AGZ is to generate training data from games of self-play, and use this data to train the policy via
supervised learning. Specifically, AGZ uses a combined policy and value network architecture, i.e., a
single neural network gθ with parameters θ. The input to the network is the state s, which encodes
both the current player and the state of the game (e.g. board configuration in Go). The network
then outputs gθ(s) = (∏θ,vθ), where the vector ∏θ(∙∣s) represents a probability distribution over the
possible moves, and vθ is a scalar value representing the probability of the current player winning.
To generate the training data, AGZ simulates the game multiple times (starting with empty board in
Go). During each simulation, AGZ plays the game against itself. That is, for each player’s turn, it
uses the current policy network gθ aided by a Monte-Carlo tree search (MCTS) (KocSiS & Szepesvari,
2006; Kocsis et al., 2006; Browne et al., 2012) to generate the next move. Specifically, for the current
player and state, MCTS outputs a distribution ∏(∙∣s) over all possible actions, and AGZ picks an
action by randomly sampling from this distribution. This generates a training data point (s, π(∙∣s), z),
1
Under review as a conference paper at ICLR 2019
where z is a reward assigned retroactively based on whether the player taking the action won (+1) or
lost (-1) that particular game.
With the training data obtained as above, the neural network parameters θ are continuously updated
with a mini-batch of data M , sampled uniformly among all time-steps of the most recent game(s) of
self-play. In particular, the parameters θ are optimized by stochastic gradient descent on the following
'2-regularized loss function that sums over mean-squared error and cross-entropy loss respectively,
loss = (Z - vθ)2 - ∏(∙∣s)log∏θ(∙∣s) + λ ∣∣θk2,	(1)
where the quantity ∏(∙∣s) log∏θ(∙∣s) represents the cross-entropy or KL divergence between the two
distributions. The pseudocode describing the above algorithm is provided in Appendix A.
In (Silver et al., 2017b), authors refer to MCTS as a “strong policy improvement operator”. The
intuition is that, starting with the current policy, MCTS produces a better target policy for the current
state. Thus training the neural network to minimize cross entropy loss with respect to the target policy
on the current state is a form of policy iteration (Sutton & Barto, 1998), which will hopefully improve
the neural network policy. Although this explanation seems natural, and is intuitively appealing, it is
not at all clear why this MCTS-driven policy iteration should work.
The questions. We are interested in three key unanswered questions about AGZ:
Question 1. What is the optimal policy that AGZ is trying to learn?
We would like a formal model to understand how learning via self-play impacts the policy to which
AGZ converges.
Question 2. Why is minimizing cross-entropy (or KL divergence) the right objective?
We seek to precisely characterize the distribution under which cross-entropy should be evaluated, and
derive quantitative performance guarantees that explain what optimizing for this metric achieves.
Question 3. How does AGZ extend to generic sequential decision-making problems?
In generic sequential decision-making, the agent chooses actions and earns rewards while the state
evolves per the environment. This is different from two-player zero-sum games for which AGZ was
designed.
Summary of results. As the main contribution of this work, we answer all of the above questions.
AGZ’s optimal policy is a Nash equilibrium. We study AGZ’s learning algorithm under the formalism
of two-player Markov games. The notion of self-play naturally defines the optimal policy as a
Nash equilibrium for the two-player zero-sum game. That is, AGZ is attempting to learn this Nash
equilibrium. See Section 2 and Section 4 for the details.
KL divergence bounds distance to optimal reward. AGZ uses the cross-entropy (or KL divergence)
metric as a loss function for the supervised learning. To justify this theoretically, we develop a novel
bound on the difference between the reward associated with two policies in terms of the cross-entropy
distance between them. Specifically, let π = (π1, π2) denote game-playing policy, where π1 and π2
are the policies of the respective players (e.g. the Black player and the White player in Go). We
bound the difference between the cumulative discounted reward (i.e., the “return”) achieved with an
arbitrary policy π(∙∣s) compared to the optimal policy π*(∙∣s) (i.e., Nash equilibrium) in terms of
the expected KL divergence between ∏(∙∣s) and ∏*(∙∣s). The expectation is with respect to states
sampled according to rollouts with the optimal policy ∏*. The bound has the following form:
∣R(∏) - R(∏*) I ≤ C JEs 〜ρ∏*[DKL(∏M)(∙∣s)k∏i(s)(∙∣s))i,	(2)
where R(∏) and R(∏*) are the returns for policies ∏ and ∏* respectively, C is a constant, I(S)
denotes the player to play at state s, and p∏* (s) is the appropriately normalized state visit frequencies
when actions are taken according to policy ∏*. See Section 3 for precise definitions and details. In
the process, we establish an invariant for Markov games that is equivalent to the result by (Kakade &
Langford, 2002) established for the MDP setting (see Appendix D).
This result provides an immediate justification for AGZ’s core learning algorithm. Notice that if the
expected KL divergence between a given policy and the optimal policy (i.e. Nash equilibrium) goes
2
Under review as a conference paper at ICLR 2019
to 0, then the return for that policy must approach that of the optimal policy. Therefore, if MCTS
produces reasonable estimates of the optimal policy for the states that are sampled, then supervised
learning with cross entropy loss for states sampled via the MCTS target policy should ideally converge
to the desired optimal policy (i.e. Nash equilibrium). Interestingly enough, prior work has shown that
MCTS asymptotically converges to the optimal actions in both two-player zero-sum games (Kocsis
et al., 2006) as well as discounted MDPs (Chang et al., 2005; Kocsis & SzepesvE, 2006).
Robust MDP as a two-player game. To extend AGZ beyond the two-player game setting, we introduce
a robust MDP framework. As in a standard MDP, the agent chooses an action given the current state
to earn a reward, and the state makes a transition according to the environment. In a traditional MDP,
state transitions occur as per an (un)known fixed Markov kernel. In the robust MDP, the transition
of state is decided by “nature,” a separate decision maker that selects state transitions subject to
environmental constraints. The goal of the agent is to choose actions to maximize the long-term
reward, while the goal of nature is to choose state transitions (subject to environmental constraints)
to minimize the long-term reward earned by the agent. In effect, robust MDP is a two-player zero-
sum game between the agent and nature. By transforming generic sequential decision-making to a
two-player game, we can apply AGZ to a much broader class of problems. We note that a similar
adversarial view has been explored recently to model reinforcement learning as simultaneous games
(Pinto et al., 2017). Our theoretical results provide new insights about such adversarial approaches in
both turn-based and simultaneous game models.
Empirical results. Is the robust MDP framework useful in practice? To answer this question, we
consider the challenging problem of learning a scheduling algorithm for an input-queued switch,
see McKeown (1999); McKeown et al. (1999); Giaccone et al. (2002); Shah & Wischik (2006);
Shah et al. (2012); Maguluri & Srikant (2016). Like a traffic junction, the role of an input-queued
switch is to schedule the transfer of incoming packets to outgoing ports, e.g. across a network switch
or a data center. In an input-queued switch with n incoming/outgoing ports, scheduling involves
selecting one of the n! possible matchings between inputs and outputs. The goal is to transfer as many
packets as possible across the switch while minimizing the packet delay. Scheduling algorithms for
input-queued switches have been the subject of intensive research effort in the networking community,
including attempts using approximate dynamic programming Moallemi et al. (2008). This is because
on one hand, input-queued switch is like the E-coli of network scheduling; progress on scheduling
input-queued switches has provided many insights about more general network scheduling problems.
On the other hand, the problem is of great importance in its own right in practice.
We utilize the framework of robust MDP along with the AGZ algorithm to find a scheduling policy
that attempts to minimize the average packet delay for any admissible packet arrival process to the
switch. The resulting policy performs nearly as well as the best known policy in the literature (cf.
Shah & Wischik (2006); Shah et al. (2012); Maguluri & Srikant (2016)) and provides performance
that is close to the fundamental lower bound. This is remarkable especially given that an equivalent
policy was discovered after an intensive effort by experts spanning over three decades of research.
See Section 5 for details.
In summary, this paper serves as a first attempt towards a principled understanding of AGZ under
minimal assumptions. Given the large body of prior work in the context of decision making, we
provided a brief overview of the most closely related previous work, and defer additional discussion
of related work to Appendix B.
2 Two-player game, Robust MDP & Nash equilibrium
We introduce a formal model to capture the essence of AlphaGo Zero (AGZ). In particular, we
introduce the setting of two-player zero-sum game for which AGZ is primarily designed. Next, we
shall explain how a generic MDP can be reduced to the setting of the two-player zero-sum game.
For the setting of two-player game, the ideal solution is given by the Nash Equilibrium. We posit
that AGZ, in effect, is trying to learn this Nash equilibrium. The transformation of generic MDP to
the setting of two-player zero-sum game allows us to extend AGZ for the setup of generic decision
making. Therefore, it is sufficient to study the performance of AGZ for the setting of two-player
zero-sum game to understand it’s efficacy for generic setting as well.
3
Under review as a conference paper at ICLR 2019
Two-player zero-sum game. Most games, including Go, exhibit a “turn-based” feature: players take
turns to make decisions. To capture this feature, we consider a two-player turn-based Markov game,
where the two players alternatively take an action. Note that in general, turn-based Markov games
can be viewed as a special class of stochastic games (a.k.a. Markov games) by assigning a dummy
action, in each step, to the player who does not play in that step. We retain the turn-based formulation
in the main text, since it is more closely aligned with the Go setting. Extension to the general Markov
games is straightforward and is discussed in detail in Appendix E.
For simplicity, we denote the two players, player 1 and player 2, by P1 and P2. This game can be
expressed as the tuple (S1, S2, A1, A2, r, P, γ). S1 and S2 are the set of states controlled by P1 and
P2, respectively. For example, in Go, the two sets could be the board configurations whose current
players are the Black player and the White player, respectively. Accordingly, Ai (s) is the set of
feasible actions for player i in any given state s ∈ Si . For turn-based games such as Go, it is typical
to assume that Si ∩S2 = 0 1. Let Us denote by S = Si ∪S2 the entire state space of the game.
For each state s ∈ S, let I(s) ∈ {1, 2} indicate the current player to play. At state s, upon taking
action a by the corresponding player I(s), player i ∈ {1, 2} receives a reward ri (s, a). In most
two-player games such as Go and Chess, the two players play against each other, and the reward a
player receives is equal to the negative reward (i.e., loss) of the other player. To reflect such structures,
we henceforth focus on two-player zero-sum games where ri(s, a) = -r2(s, a). Without loss of
generality, we let P1 be our reference and use the notation r(s, a) , ri (s, a) for later definitions of
value functions. The reward function is assumed to be uniformly bounded by some constant CR . In
addition, let P (s, a) be the distribution of the new state after playing action a, in state s, by player
I (s). Note that in Go/Chess, the state transitions are deterministic.
For each i ∈ {1,2}, let ∏ be the policy for player i, where ∏i(∙∣s) is a probability distribution over
Ai(s). Denote by Πi the set of all policies of player i, and let Π = Πi × Π2 be the set of all polices
for the game. Given a policy π = (πi, π2), the total discounted reward R(π) is given by
∞
R(π) = Eso~P0,at~∏i(st)(∙∣st),st+ι~P(st,at) X ：γ r(st, at) ,	(3)
t=0
where ρ0 : S → [0, 1] is the distribution of the initial state s0, and γ ∈ (0, 1) is the discount factor.
We use the following standard definition of the value function in games:
∞
Vπ
1,π2 (s) = Eat,st+1,at+1,...	γ k r(st+k, at+k)|st = s ,
k=0
where aι 〜 ∏i(s∕(∙∣sι) and si+i 〜 P(Sl, aι). That is, V∏1,∏2 (S) is the expected total discounted
reward for P1 if the game starts from state s, players P1 and P2 respectively use the policies πi and
π2 . A two-player zero-sum game can be seen as player P1 aiming to maximize the accumulated
discounted reward while P2 attempting to minimize it.
Robust MDP as a two-player zero-sum game. We introduce setting of “robust” MDP to extend
AGZ for generic decision making. Typically, the generic sequential decision making framework
is captured through tuple (S, A, r, γ, P): S is the set of all states, A is the set of all actions agent
can take, r : S × A → R denotes the reward function, γ ∈ (0, 1) is discount factor, and for each
(S, a) ∈ S × A, Ps,a : S → [0, 1] denotes the Markov transition kernel with Ps,a(S0) being the
probability of transitioning into state S0 ∈ S from state S given action a. At each time instance
t, given state St ∈ S, agent takes action at which leads to reward r(St, at) and the nature makes
the state transition to St+i ∈ S as per the Markov transition kernel Pst,at . Given such a setting,
traditionally there are two popular approaches. One, the Markov Decision Process (MDP), where one
assumes the prior knowledge of nature, i.e. P, and solves for optimal policy for the agent defined
through Bellman’s equations and dynamic programming. This includes approaches such as policy
iteration, value iteration or its variants, cf. Bertsekas et al. (2005); Bertsekas & Tsitsiklis (1995).
Second, the reinforcement learning (RL) where P is assumed to be unknown but aspects of it are
learnt along-side of the optimal policy using approximate dynamic programming such as Q-learning.
1This is a reasonable assumption in general in any setting when only one player is taking a “turn” to play,
since one may incorporate the “turn” of the player as part of the state, and thus by definition a player 1’s state
space (i.e. when it is player 1’s turn) is disjoint from that of player 2’s turn.
4
Under review as a conference paper at ICLR 2019
In contrast, here we model nature as an adversary. Precisely, we model the decision making as a
game between agent and nature. Agent is P1 and nature is P2. The agent is trying to chose action
with the aim of maximizing reward while nature is trying to make state transition so that agent’s
reward is minimized. Of course, if nature can make arbitrary transitions then it will result into a
degenerate setting where nature will always set state to the one that leads to minimal reward. In
reality, there are constraints per which state can transition. Specifically, let C(s, a) ⊂ S be the set
of all allowable states the transition is feasible. And nature tries to choose action a0 ∈ A2 (s, a) that
leads to state s0 ∈ C(s, a) to minimize (future) reward of the agent.
Now, we can view this as a two-player zero-sum game. The player P1 is agent with possible
actions A1 = A with states S1 = S, and denote by f (s, a) the state after selecting action a
in state s. The player P2 is the nature with states S2 = {f (s, a)|s ∈ S, a ∈ A} and actions
A2 = ∪s∈S,a∈AA2 (s, a). When player P1 takes action a ∈ A given state s ∈ S, the system
transition to intermediate state f(s, a) and reward generated for P1 is r1 (s, a). The player P2
receives reward r2(s, a) = -r1 (s, a). Then given state f(s, a), P2 takes action a0 ∈ A2(s, a), the
state transitions to s0 ∈ S1, reward generated for player P2 is r2 (f (s, a), a0) and reward for P1 is
r1 (f (s, a), a0) = -r2(f (s, a), a0). Let r(s, a) , r1 (s, a) + r1 (f (s, a), a0). We denote by st the
states that are observed and at ∈ A1 be the actions taken by player P1 at time t. Then the cumulative
discounted reward earned by player P1 is precisely Pt∞=0 γtr(st, at). Thus, reward of player P1
precisely matches that of the original decision making agent and the setting of decision making is
precisely converted into a zero-sum game between two players, agent and nature.
Given the above transformation, in the remainder of this work, we will focus on two-player zero-sum
game with interest in both the classical turn-based game as well as the robust MDP setup described.
The analysis of AGZ in the two-player zero-sum game naturally will apply to the generic decision
making setting through the above described transformation.
Nash equilibrium. In the game setting, we are interested in the minimax equilibrium solutions. To
describe this concept, we view the value function Vπ1,π2 as a vector in R|S|. Given two vectors U
and W, we use the notation U ≤ W to indicate element-wise comparisons. Recall that P1 is the
reward maximizer while P2 is the minimizer.
Definition 1. (Optimal Counter Policy) Fix a policy π2 ∈ Π2 for P2. A policy π1 for P1 is said to be
an optimal counter-policy against π2, if and only if
Vπ1,π2 ≥ Vπ10,π2, ∀π10 ∈Π1.
Similarly, a policy π2 ∈ Π2 for P2 is said to be an optimal counter-policy against a fix policy π1 ∈ Π1
for P1, if and only if
Vπ1,π2 ≤ Vπ1,π20, ∀π20 ∈Π2.
In a two-player zero-sum game, it has been shown that the pairs of optimal policies coincide with
the Nash equilibrium of this game (Patek, 1997; Hansen et al., 2013; Perolat et al., 2015). In
particular, a pair of policies (∏↑,∏2') is called an equilibrium solution of the game, if ∏ is an
optimal counter policy against ∏2 and ∏g is an optimal counter policy against ∏↑. The value function
of the optimal policy, V∏*,π*, is the unique fixed point of a γ-contraction operator Hansen et al.
(2013). Consequently, the value of the equilibrium solution, R(∏1,∏2) = Es0〜ρ° [V∏*,π* (so)] (cf.
Equation (3)) is unique. In the sequel, We will simply refer to the strategy ∏* = (∏j,∏g) as the
optimal policy. Using our key result Theorem 2, in Section 4, we shall argue that AGZ in effect is
trying to learn this Nash equilibrium.
3	Key Theorem
As our key result, we establish a novel bound on the difference of the expected rewards of any policy
and that of the optimal one (i.e., Nash equilibrium) in terms of the KL divergence (i.e., cross entropy)
of these two policies. This will play a crucial role in justifying AGZ trying to learning the Nash
equilibrium as argued in Section 4.
Define ρπ(s) as the unnormalized discounted visit frequencies for state s under policy π = (π1 , π2):
ρπ(s) = P(s0 = s) +γP(s1 = s) +γ2P(s2 = s) + . . .,	(4)
5
Under review as a conference paper at ICLR 2019
where so 〜 ρo and actions at are taken according to policy ∏i(s∕. Note that 5∑s∈s P∏(S)=
1/(1 - γ); let Pn = (1 - γ)ρ∏ be the normalized probability distribution. It is easy to see that as
Y → 1, ρ∏ approaches μ∏, the stationary distribution induced by the policy π; in particular, p∏*
approaches μ* for large enough discount factor.
Theorem 2. Given a two-player zero-sum game, for any policy π = (π1, π2) and Nash equilibrium
π* = (πt,π2),
lR(π) - R(n* ) | ≤ C ʌ/Es 〜P∏* hD KL (πI(s)3s)kπI(s)3sT,	⑸
where C is a constant depending only on γ and CR.
We remark that the above bound in fact holds for any pair of policies ∏ and ∏. The inequality (5)
corresponds to taking π = π*. The proof of Theorem 2 is provided in Appendix D.
4	AlphaGo Zero Learns Nash Equilibrium
Using Theorem 2, we shall argue that AGZ tries to approximate an ideal policy for learning the Nash
equilibrium. To that end, we first describe this ideal policy suggested by Theorem 2 and then we
discuss how AGZ approximates it.
4.1	Ideal Policy for learning Nash equilibrium
Consider a parametrized class of policies {(∏θι ,∏θ2 )∣θι ∈ Rm1,θ2 ∈ Rm2} such that there exists
θ* = (θι,θ2) so that (∏θ*,∏θ* ) = (∏1,∏2), the desired Nash equilibrium. We shall assume that such
a θ* is unique that We wish to find. Theorem 2 suggests that such θ* can be found by minimizing the
right-hand side of (5). To that end, define
f(θ) = Es〜ρ∏* [DKL(∏I(s)(∙∣s)k∏θi(s)(∙∣s))i .	(6)
The gradient algorithm for finding θ* would suggest iteratively update θ as
θ J θ - aVθf (θ).	(7)
Assuming f does not have spurious stationary points, the algorithm (with appropriately decaying
constants a) will converge to θ*.
This is an ideal policy. Because it requires calculating Vθf(θ) which involves computing expectation
with respect to ρ∏*, the normalized stationary distribution with respect to optimal policy. Next, we
argue that AGZ implements stochastic approximation to (7).
4.2	AGZ’s approximations of Ideal policy
AGZ implements idealized policy in (7) through a sequence of approximations that we describe next.
As a consequence, if all the approximations work out, then AGZ would end up finding the optimal
policy, i.e the Nash equilibrium.
Optimal policy oracle via MCTS. To evaluate Vθf(θ) or f(θ), it is sufficient to have access to an
oracle that given a state s, it provides n；(s)(，|s). Because, once we have access to such an oracle,
starting with s° 〜ρo, we can sample states st, t ≥ 1 iteratively as follows: given st, obtain action
at 〜∏j(st)(∙∣st), observe a new state st+ι. Then, with respect to randomness over sampling of at
and resulting randomness in state transitions
EhX DKL(πI(st) (1s)kπθi(st) (Is))] IX f(θ), and
t≥0
EhXVθDkl(∏I(s,)(∙∣s)k∏θi(st)(∙∣s))i xVθf(θ).	(8)
Therefore, with access to the oracle described, stochastic approximation of (7) can be implemented.
The pseudocode of this ideal algorithm, together with addition discussions on the form of the updates,
may be found in Appendix F.
6
Under review as a conference paper at ICLR 2019
In principle, any approximate oracle with reasonable theoretical guarantees can be applied to replace
the optimal oracle in practice. AGZ uses Monte Carlo Tree Search (MCTS) to obtain such an
approximate oracle (Chang et al., 2005; Kocsis & SzePesvdri, 2006; Kocsis et al., 2006). MCTS
has many variants; the basic version, known as UCT (UCB applied to Trees), uses ideas from UCB
(Upper Confidence Bounds) algorithm to guide the tree search. For this algorithm, it has been shown
that the probability of taking suboptimal actions converges to zero (Kocsis & Szepesvdri, 2006),
and hence, the empirical action distribution eventually converges to the optimal action distribution
∏*(∙∣s). We also note that in AGZ's network, it has a value function component as its output. This
value function is only used during the MCTS phase to guide the search (in particular, to evaluate the
newly expanded nodes), rather than directly applied to select actions. That is, we could view this
UCT style search, aided by the value function, as a variant of MCTS with the hope of obtaining a
more efficient approximate oracle than the vanilla MCTS.
Stochastic gradient descent. A naive stochastic approximation to (7) as mentioned above may obtain
many samples of the random variable on the left-hand side in (8). However, that may require a lot
more simulations and could be wasteful. Alternatively, the Stochastic Gradient Descent (SGD) would
suggest making bolder updates: compute and update the gradient continually. And this is precisely
what AGZ implements.
Existence of and convergence to θ*. For the ideal gradient algorithm (7) to be able to find optimal
policy, there are two key assumptions made: (1) there exists θ* so that ∏* = ∏θ* , and (2) the gradient
algorithm finds such a θ* starting from any initial parameter θ. The implicit assumption made in
AGZ implementation is that the policy neural network utilized is flexible enough that (1) is expected
to satisfy. The assumption (2) is the mystery behind the success of any generic neural network based
solution. And AGZ(-like) implementation hopes that (2) works out through various cleverness in
terms of architecture choice and learning algorithm.
5	AGZ for Robust MDP — A Case-study
AGZ has been successful in the context of two-player games. The robust MDP formulation makes
it applicable to the setting of generic sequential decision making. To understand how well AGZ
does when applied to robust MDP, we consider a challenging networking problem as a case-study:
scheduling transfer of packets in an input-queued switch.
Background. A router or a switch in Internet or a data center has several input ports and output
ports. A data transmission cable is attached to each of these ports. Packets arrive at the input ports.
The function of the switch is to work out which output port each packet should go to, and to transfer
packets to the correct output ports. This last function is called switching. There are a number of
possible architectures; we will consider the commercially popular input-queued switch architecture.
The switch operates in discrete time. At each time slot, the switch fabric can transmit a number of
packets from input ports to output ports, subject to the two constraints that each input can transmit at
most one packet, and that each output can receive at most one packet. In other words, at each time slot
the switch can choose a matching from inputs to outputs. In general, for an n-port switch, there are
N = n2 queues. Packets arriving at input k destined for output ` are stored at input port k, in queue
Qk,'. The schedule σ ∈ R+n×n is given by σk,' = 1 if input port k is matched to output port' in a
given time slot, and σk,' = 0 otherwise. By the matching constraints, the corresponding schedule set
S is defined to be {σ ∈ {0,1}n×n : Pm=I σk,m ≤ 1, Pm=I σm,' ≤ 1,1 ≤ k,' ≤ n}. Suppose
data packets arrive at queue (k,') at rate λk,' for 1 ≤ k,' ≤ n. Then, the effective load induced on
the system, ρ(λ), is given by ρ(λ) = maxι≤k,'≤n P Pm=I λkm Pm=I λm,'}.
Robust MDP for scheduling. The robust MDP corresponding to scheduling can be formulated
as follows. At each time, agent wishes to choose schedule σ ∈ S based on the system state
Q = [Qk,'] ∈ R+n×n and earns reward equal to the negative of the sum of all queues. This reward
guides the agent to minimize the average queue size.
The nature, on the other hand, determines new packet arrivals leading to changes in the system state
(i.e., the queue occupancies). We restrict nature by requiring that the arrivals, or change in queue-size,
belongs to set Λ(x) = {λ ∈ R+n×n : ρ(λ) ≤ x} for some fixed x ∈ (0, 1).
7
Under review as a conference paper at ICLR 2019
The constraint x < 1 is an example of an environmental constraint imposed on the nature. This
constraint is required for the packet arrival process to be admissible. Specifically, for x > 1, there is
no scheduling policy that can stabilize the switch queues, because at most on packet can get serviced
from any input or output port.
Evaluation. Given the robust MDP formulation as explained above, we apply AGZ to the corre-
sponding transformed two-player zero-sum game, and evaluate the performance of the resulting
policy. Details of our experiments can be found in Appendix G. We compare the performance of
AGZ with respect to the standard SARSA policy (Rummery & Niranjan, 1994). We also compare it
with Maximum Weight Matching scheduling algorithm parameterized by a parameter α > 0 denoted
as MWM-α. MWM is a classical scheduling algorithm. Specifically, MWM-α chooses schedule
σ ∈ S such that σ ∈ arg max万∈s Pk ` σk,'Qα`. The MWM-1 algorithm was proposed in 1990s
McKeown et al. (1999) and was shown to be within factor 2 of the fundamental lower bound recently
Maguluri & Srikant (2016). It has also been argued that MWM-α improves performance as α → 0+
(Shah & Wischik, 2006).
1.0
Empirical CDF of Avg Queue Size
0.8
0.2
0.0
S04
O 0.6
T8
Figure 1: Empirical CDF of the avg queue size.
Avg. Queue Size vs Load
0.10	0.25	0.50	0.75	0.90	0.95	0.97	0.99
Load
Figure 2: Avg queue size vs. different loads.
Our evaluation results are shown in Figures 1 and 2. We evaluate the AGZ scheduling policy on 80
different arrival traffic scenarios, each with load equal to 0.9. Figure 1 shows the empirical CDF of
the average queue sizes on these 80 evaluations. As can be seen, the AGZ policy (called AdvMCTS)
outperforms vanilla SARSA. It also outperforms MWM-1 and performs nearly as well as MWM-0.1.
A similar conclusion is observed in Figure 2 where we compare performance of algorithms in terms
of the average queue size at different loads varying between 0 and 1, averaged over 16 traffic arrival
patterns. We note that the dashed line in both plots represents the fundamental lower bound, cf. Shah
et al. (2012). This performance of AGZ is remarkable given the fact that it has taken three decades
of research to arrive at similar performing algorithms in the literature.
6	Conclusion
Motivated to explain the success of AlphaGo Zero (AGZ), in this paper, we provide a formal
framework to study AGZ. Specifically, we explain that AGZ attempts to learn the Nash equilibrium
for two-player zero-sum games. In the process, we establish a novel bound on difference of reward
earned under two different policies in terms of cross-entropy between the two policies for the setting
of two-player games. By formulating generic sequential decision making through the framework of
robust Markov Decision Process, we show how to view these problems as a two-player zero-sum
game. This allows extending AGZ beyond games. We present a case-study for performance of
AGZ for robust MDP in the context of input-queued switch scheduling. We find that AGZ performs
remarkably well and its performance is nearly as good as the best-known scheduling policies.
8
Under review as a conference paper at ICLR 2019
References
Dimitri P Bertsekas and John N Tsitsiklis. Neuro-dynamic programming: an overview. In Proceedings
of the 34th IEEE Conference on Decision and Control, volume 1, pp. 560-564. IEEE PUbL
Piscataway, NJ, 1995.
Dimitri P Bertsekas, Dimitri P Bertsekas, Dimitri P Bertsekas, and Dimitri P Bertsekas. Dynamic
programming and optimal control, volume 1. Athena scientific Belmont, MA, 2005.
Cameron B Browne, Edward Powley, Daniel Whitehouse, Simon M Lucas, Peter I Cowling, Philipp
Rohlfshagen, Stephen Tavener, Diego Perez, Spyridon Samothrakis, and Simon Colton. A survey
of monte carlo tree search methods. IEEE Transactions on Computational Intelligence and AI in
games, 4(1):1-43, 2012.
Hyeong Soo Chang, Michael C Fu, Jiaqiao Hu, and Steven I Marcus. An adaptive sampling algorithm
for solving markov decision processes. Operations Research, 53(1):126-139, 2005.
Remi Coulom. Efficient selectivity and backup operators in monte-carlo tree search. In International
conference on computers and games, pp. 72-83. Springer, 2006.
Yonathan Efroni, Gal Dalal, Bruno Scherrer, and Shie Mannor. How to combine tree-search methods
in reinforcement learning. arXiv preprint arXiv:1809.01843, 2018.
Paolo Giaccone, Balaji Prabhakar, and Devavrat Shah. Towards simple, high-performance schedulers
for high-aggregate bandwidth switches. In INFOCOM 2002. Twenty-First Annual Joint Conference
of the IEEE Computer and Communications Societies. Proceedings. IEEE, volume 3, pp. 1160-
1169. IEEE, 2002.
Evan Greensmith, Peter L Bartlett, and Jonathan Baxter. Variance reduction techniques for gradient
estimates in reinforcement learning. Journal of Machine Learning Research, 5(Nov):1471-1530,
2004.
Thomas Dueholm Hansen, Peter Bro Miltersen, and Uri Zwick. Strategy iteration is strongly
polynomial for 2-player turn-based stochastic games with a constant discount factor. J. ACM, 60
(1):1:1-1:16, February 2013. ISSN 0004-5411.
Max Jaderberg, Volodymyr Mnih, Wojciech Marian Czarnecki, Tom Schaul, Joel Z Leibo, David
Silver, and Koray Kavukcuoglu. Reinforcement learning with unsupervised auxiliary tasks. arXiv
preprint arXiv:1611.05397, 2016.
Daniel R Jiang, Emmanuel Ekwedike, and Han Liu. Feedback-based tree search for reinforcement
learning. arXiv preprint arXiv:1805.05935, 2018.
Sham Kakade and John Langford. Approximately optimal approximate reinforcement learning. In
ICML, volume 2, pp. 267-274, 2002.
Sham M Kakade. A natural policy gradient. In Advances in neural information processing systems,
pp. 1531-1538, 2002.
Levente Kocsis and Csaba SzePesvðri. Bandit based monte-carlo planning. In European conference
on machine learning, pp. 282-293. Springer, 2006.
Levente Kocsis, Csaba Szepesvdri, and Jan Willemson. Improved monte-carlo search. Univ. Tartu,
Estonia, Tech. Rep, 2006.
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint arXiv:1509.02971, 2015.
Michael L Littman. Markov games as a framework for multi-agent reinforcement learning. In
Machine Learning Proceedings 1994, pp. 157-163. Elsevier, 1994.
Siva Theja Maguluri and R Srikant. Heavy traffic queue length behavior in a switch under the
maxweight algorithm. Stochastic Systems, 6(1):211-250, 2016.
9
Under review as a conference paper at ICLR 2019
Peter Marbach and John N Tsitsiklis. Simulation-based optimization of markov reward processes.
IEEE Transactions on Automatic Control, 46(2):191-209, 2001.
Nick McKeown. The islip scheduling algorithm for input-queued switches. IEEE/ACM Transactions
on Networking (TON), 7(2):188-201, 1999.
Nick McKeown, Adisak Mekkittikul, Venkat Anantharam, and Jean Walrand. Achieving 100%
throughput in an input-queued switch. IEEE Transactions on Communications, 47(8):1260-1267,
1999.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control
through deep reinforcement learning. Nature, 518(7540):529, 2015.
Ciamac C Moallemi, Sunil Kumar, and Benjamin Van Roy. Approximate and data-driven dynamic
programming for queueing networks. Submitted for publication, 2008.
Stephen D Patek. Stochastic Shortest Path Games: Theory and Algorithms. PhD dissertation,
Massachusetts Institute of Technology, 1997.
Julien Perolat, Bruno Scherrer, Bilal Piot, and Olivier Pietquin. Approximate dynamic programming
for two-player zero-sum markov games. In Proceedings of the 32nd International Conference on
Machine Learning, pp. 1321-1329, 2015.
Lerrel Pinto, James Davidson, Rahul Sukthankar, and Abhinav Gupta. Robust adversarial reinforce-
ment learning. arXiv preprint arXiv:1703.02702, 2017.
Gavin A Rummery and Mahesan Niranjan. On-line Q-learning using connectionist systems, vol-
ume 37. University of Cambridge, Department of Engineering Cambridge, England, 1994.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region
policy optimization. In International Conference on Machine Learning, pp. 1889-1897, 2015a.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional
continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438,
2015b.
Marwin HS Segler, Mike Preuss, and Mark P Waller. Planning chemical syntheses with deep neural
networks and symbolic ai. Nature, 555(7698):604, 2018.
Devavrat Shah and Damon Wischik. Optimal scheduling algorithms for input-queued switches. In
Proceedings of the 25th IEEE International Conference on Computer Communications: INFOCOM
2006, pp. 1-11. IEEE Computer Society, 2006.
Devavrat Shah, Neil Walton, and Yuan Zhong. Optimal queue-size scaling in switched networks.
ACM SIGMETRICS Performance Evaluation Review, 40(1):17-28, 2012.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche,
Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering
the game of go with deep neural networks and tree search. nature, 529(7587):484-489, 2016.
David Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez,
Marc Lanctot, Laurent Sifre, Dharshan Kumaran, Thore Graepel, et al. Mastering chess and shogi
by self-play with a general reinforcement learning algorithm. arXiv preprint arXiv:1712.01815,
2017a.
David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez,
Thomas Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of go without
human knowledge. Nature, 550(7676):354, 2017b.
Wen Sun, Geoffrey J Gordon, Byron Boots, and J Andrew Bagnell. Dual policy iteration. arXiv
preprint arXiv:1805.10755, 2018.
Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction, volume 1. MIT
press Cambridge, 1998.
10
Under review as a conference paper at ICLR 2019
Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient meth-
ods for reinforcement learning with function approximation. In Advances in neural information
processing Systems,pp. 1057-1063, 2000.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. In Reinforcement Learning, pp. 5-32. Springer, 1992.
11
Under review as a conference paper at ICLR 2019
Appendices
A Pseudocode for AlphaGo Zero
We provide the pseudocode for AlghaGo Zero in Algorithm 1, which concisely summarizes the
overview in the Introduction.
Algorithm 1 Training Algorithm for Each Episode
1:	Sampling: Suppose that the current episode ends in L steps.
2:	for each step t = 0, 1, . . . , L do
3:	run MCTS for some time (1600 simulations), with state st as the root and the current player
taking the first action; obtain the action distribution ∏t(∙∣st) based on empirical visit counts.
4:	sample an action at 〜∏t(∙∣st) and observe a new state st+ι for the other player to play.
5:	end for
6:	Store Data: the episode terminates and an reward rL ∈ {-1, 1} is observed. Then, the data
for each time step t = 0,1,...,T is stored as (st, ∏t(∙, |st), zt), where Zt = ±rτ is the game
winner from the perspective of the current player at step t.
7:	Update Parameters: when decide to update the parameters θ, sample a mini-batch M and run
gradient descent:
θ 一 θ - αVθ hX -π(∙∣s)log∏θ(∙∣s) + (z - vθ)2 + λ |向|2 ]
B Related works
In the recent years, deep reinforcement learning has emerged as a generic yet effective learning
method, achieving remarkable performance across a variety of fields ranging from game playing
(Mnih et al., 2015; Jaderberg et al., 2016; Silver et al., 2017b;a), simulated physical tasks (Lillicrap
et al., 2015; Schulman et al., 2015b) to chemistry (Segler et al., 2018). An important instantiation,
self-play reinforcement learning, has been integrated with other techniques—including MCTS and
supervised learning— to achieve superhuman performance in games without human knowledge;
as exemplified by the AlphaGo Zero. The success of AlpahGo Zero has inspired some recent RL
algorithms (Jiang et al., 2018; Efroni et al., 2018; Sun et al., 2018). However, exactly capturing
AlphaGo Zero and understanding the success of it is very limited beyond natural intuitions. To our
best knowledge, this is the first attempt towards a principled and theoretical understanding for its
underlying ingredients, under minimal assumptions.
The ideal variant of AlphaGo Zero falls into the general category of policy-based methods for
reinforcement learning (Williams, 1992; Sutton et al., 2000; Marbach & Tsitsiklis, 2001; Kakade,
2002; Greensmith et al., 2004; Schulman et al., 2015a), a line of research that receives considerable
interest due to its advantage of directly parameterizing the policy. Most of the prior algorithms were
obtained via directly optimizing the expected return R(πθ) of a parameterized policy. For example,
the classical REINFORCE algorithm (Williams, 1992) attempts to maximize the return by gradient
ascent with unbiased estimator of the gradient VR(πθ). The recent TRPO algorithm (Schulman et al.,
2015a) attempts to maximize a lower bound of R(π). In contrast, the algorithm of AlphaGo Zero
that we study approaches the problem indirectly: it minimizes the KL divergence (or cross entropy)
between current policy ∏ and optimal policy ∏*; in this work, we argue that this step corresponds to
minimizes a valid upper bound on the difference between R(∏) and the optimal R(∏*).
In the practical version of the algorithm, idealized oracle is replaced with MCTS, which, by itself,
is a well studied and widely applicable technique (Chang et al., 2005; Coulom, 2006; Kocsis &
Szepesvdri, 2006; Kocsis et al., 2006; Browne et al., 2012). In particular, MCTS has been shown to
asymptotically converge to the optimal actions in both discounted MDPs (Chang et al., 2005; Kocsis
& Szepesvdri, 2006) and two-player zero-sum games (Kocsis et al., 2006). However, the interplay
between policy-based learning methods and MCTS, investigated in this paper, is new.
12
Under review as a conference paper at ICLR 2019
We note that our results are applicable in the context of the two-player stochastic games which have
been extensively studied in the literature, see (Littman, 1994; Patek, 1997; Hansen et al., 2013;
Perolat et al., 2015).
C Preliminary Facts
The following inequalities are used for developing our technical results:
Jensen’s Inequality: Let X be a random variable and φ be a convex function, then φ(E[X]) ≤
E[φ(X)].
Pinsker's Inequality: Let μ and V be two probability distributions, then the total variation distance
TV(μ, V) and the KL divergences DκL(μ∣∣μ) satisfies
TV(μ,ν) ≤
y2 Dkl (μ, ν)
Note that if μ and V are discrete distributions, then TV(μ, V) = 2 Pω∈Ω ∣μ(ω) - V(ω)∣.
D Proof of Theorem 2
We define the state-action value or Q function associated with policy π = (π1, π2) as follows: for
each s ∈ S , a ∈ A,
∞
Qπ1,π2 (s, a) = Est+1,at+1,... X γ r(st+k, at+k)|st = s, at = a .
k=0
Define the corresponding advantage function Aπ1,π2 : for each s ∈ S, a ∈ A,
Aπ1 ,π2 (s, a) = Qπ1 ,π2 (s, a) - Vπ1 ,π2 (s)	(9)
Recall that the reward function r(∙, ∙) is assumed to be uniformly bounded by some constant Cr. An
immediate consequence is that for any policy π = (π1, π2), s ∈ S, a ∈ A,
| A∏1 ,∏2 (S,a) | = lQ∏1,π2 (s, a) - Vπ1 ,π2 (s)|
≤ --— max ∣r(s0,a0)∣ = R .
1 - γ s0∈S,a0∈A	1 - γ
That is, ∣A∏1,∏2 (s, a)| ≤ CA = 2CR for each S ∈ S and a ∈ A.
For two policies ∏ = (∏1,∏2) and ∏ = (∏1, ∏2), we can express the difference in policy performance
R(Π) - R(∏), as a sum of per-timestep advantages over ∏, in the same fashion as Kakade and
Langford’s result (Kakade & Langford, 2002) for MDP. This is done in the following lemma, whose
proof is given in Appendix D.1.
Lemma 3. Given any two policies π = (∏1,∏2) and ∏ = (∏1,∏2), we have
∞
R(∏) = R(∏) + ET 〜π X YtAn(St,at) ,	(10)
t=0
where the expectation is taken over trajectories T := (s0, a0, s1 ,a1...), and the notation ET〜∏[∙]
indicates that actions are SamPledfrOm policy π = (∏1,∏2) to generate τ.
Using definition of unnormalized visit frequency (cf. (4)) we can rewrite (10) as follows:
∞
R(∏) = R(∏) + XX P (St = s∣∏) X ∏i(s) (a∣s)γ tA∏(s,a)
t=0 s	a
∞
= R(π) + XXYtP(St =s1n) X∏i(s)(a∣s)A∏ (s,a)
s t=0	a
=R(π) + X Pn(S) X πι(s)(alS)An(S,a).	(II)
sa
13
Under review as a conference paper at ICLR 2019
We are now ready to prove Theorem 2. We shall focus on proving the inequality (5) for the optimal
policy π*. The proof for a general policy π can be done by replacing π* with π. We shall use π as a
“reference” policy in the remainder of the proof.
By taking π = π* and π = π in (11), we obtain
R(π*) = R(π) + Xρ∏* (s) Xn；(s)(a|s)A#(s, a).	(12)
S	a
By taking π = π and π = π in (11), we obtain
R(π) = R(π) + X Pn ⑶ X∏I (s)(α∣s)A∏ (s,a).	(13)
Sa
Therefore, we have
∣R(π) - R(π*)∣
=EE(Pn(S)πI(s) (a|S)-Pπ* (S)πI(s)(alS))An (S,a)
≤Ca XX
Pπ (S)nI (s)(a|S) - Pn*(S)n；(S) (a|S) |
=CA XX | Pπ (S)nI (s)(a|S) - Pπ*(s)πI(s) (a|s) + Pπ* (s)πI(s)(a|s) - Pπ* (s)πI(s)(a|s) |
Sa
≤CA ΣΣnI(s)(a|S)IPn(S) - Pπ* (S) I + CAΣΣPn* (s) 1 ∏I(s)(a]S) - n；(s)(a|S) 1
=CA X Pn (S) - Pn* (S) + CA XX
Pn*(S) | nI(s)(a|S)- n；(s)(a|S) 1	(14)
First term in R.H.S. of (14): We can rewrite Pn as follows
∞
Pn (s) = P(S0 = s) + X YtP(St = S|n)
t=1
∞	「	一
=P (So = s) + X Yt X P(St = S|n, St-1 = S0)P (St-1 = S0 |n)
t=ι	L s0	-
∞	「	一
=P(S0 = s) + XYt X(X皿3乂豕0)P(SISIa))P(St-I = SIn)
「∞	一
=P(S0 = s) + XXnI3)(a|s0)P(SISia) XYtP(St-I = SIn)
S0 a	t=1
=P (So = S)+ γ XX
nI(s0)(a|s0)P (s|s0,a)Pn (s0).
As a consequence, we have
1 Pn (s) - Pn* (S)I = Y ΣΣnI3)(a|S0)P(SIS0,a)Pn (s') - £ EnI(S0)(a|S0)P(SIS0,a)Pn*(s0) |
≤Y	∏I(s0)(a|s0)P(s|s0,a)Pn(s0) -E£nI3)(a|s0)P(s|s0, a)Pn*(s0) |
+Y XXnI(s0)(a|S0)P(S|s0, a)Pn* (s0) - XX nI(s，)(a|S0)P(S|s0, a)Pn* (s0)
≤ YEEnI(so )(a|S0)P(SIS0,a) | Pn (S0)-Pn*(s0) |
+Y XX
P(s|s0,a)Pn* (s0) | nI3)(a|s0) - n；(s,)(a|s0) | .
14
Under review as a conference paper at ICLR 2019
Summation over S ∈ S on both sides yields
E ∣Pπ(s) - Pπ*(s)∣ ≤ YEEEnI(S0)(小/)P(SlSIa)∣Pπ (s') - Pπ* (s') |
S	s	s0 a
+ Y XXX P(S |s', a" (S') InI(S0)⑷S') - πI(s0)⑷ S') I
s s0 a
=Y X I Pπ(s') - Pπ* (s') 1 [ X nI(s0)(αls ,)(X P(SISi a))
s0	a a	S-
+ Y XX P∏* (s 0) 1 nI(s0) (a|s/) - nI(s0) (a|s/) 1 ( X P(S|s', a))
=Yɪp 1 Pn(SO)- Pπ*(s0)| + YΣΣPπ*(s0) 1 nI(s0)(αls0) -nI(s，)(a|s/) 1 .
To conclude, we have
XI PK (S)- Pπ*(S) 1 ≤ 1-— XX Pπ*(s') 1 nI(s0)(a|s/) - nI(s，)(a|s/) | ∙	(15)
S	Y s0 a
Concluding proofof Theorem 2: Substituting (15) into (14) yields
IR(∏) - R(∏*) I≤ B XXPπ* (s) i πI(s)(a|s) - n；(s)(a|s) I
=(1 C-AY)2 X(1 - Y)P∏*(S) X 1 nI(s)(a|S) - nI(s)(a|S) I
=(12CA )2 Es~ρ∏* [TV (nI(s)('|s)knI(s)('|s))]
(a) ʌ/ɔe
≤ (1 - y)2 ES~P∏* [VDKL(n；(s)(-|s)knI(s)('|s))]
(≤) (IZ-CA)2 JES〜ρ∏* [DKL(n；(s)(・|s)knI(s)(・|s))],
where (a) follows from Pinker,s inequality and (b) follows from Jensen,s inequality. This concludes
the proof of Theorem 2.
D.1 Proof of Lemma 3
By the definition of the advantage function (cf. 9), for each policy π = (∏ι, π2),
An (s, a) = Qn (s, a) - Vπ (s)
=EsAP(s,a) [r(s, a) + YVn (s/) - V∏ (s)].
Therefore,
∞
Ein EYtAn(st, at)
_t=0	.
∞
X Yt (r(st, at) + YVn (st+1) - Vn (St))
.t=0
^ ∞	一
XYtr(St,at) - Vn (S0))
.t=0	_
^ ∞	^^l
X Ytr(St,at) - ES0 [κ(S0)]
.t=0	_|
(16)
R(π) — R(π).
In above, (16) is the result of telescoping summation.
15
Under review as a conference paper at ICLR 2019
E Stochastic Games
A Stochastic Game (SG) (also called Markov Games) is a generalization of an MDP to a n-player
setting. SGs are widely used to model sequential decision making in multi-agent systems. Each
player controls the SG through a set of actions. In the case of a turn-based game—we use it to model
the game of Go—each state is controlled by a single player. In a general SG, at each step of the game,
all players simultaneously choose an action. The reward each player gets after one step depends on
the state and the joint action of all players. Furthermore, the transition kernel of the SG is controlled
jointly by all the players.
Consider a zero-sum two-player SG. We use the same notation for the two players as the turn-based
game, i.e., P1 and P2 for player 1 and player 2, respectively. This game can be described by a
tuple (S, A1, A2, P, r, ρ0, γ) where A1(s) and A2(s) are the set of actions player 1 and player 2
can take in state s respectively; P : S × A1 × A2 × S → R is the state transition probability;
r : S × A1 × A2 → R is the reward for both players; ρ0 is the distribution of the initial state s0 and
γ is the discounted factor. Let πi : S × Ai → [0, 1] denote the randomized policy of player i, with
∏i(a∣s) denoting the probability of taking action a given state s. This formulation has been used to
model adversarial reinforcement learning Pinto et al. (2017).
At each timestep t, both players observe the state St and take actions a；〜∏1 (∙∣st) and a；〜∏2 (∙∣st).
In the zero-sum game, without loss of generosity we assume that P1 gets a reward rt1 = rt =
r(st, at1, at2) while P2 gets a reward rt2 = -rt. If P1 and P2 respectively use the stationary policies
π1 and π2, the cumulative reward for P1 is given by
∞
R1 (π1, π2) = R(π1, π2) = E	S0 ~P0	γtr(st, at1 , at2 ) .
a1~πι(Tst)	t=o
a2 〜∏2(∙∣st)
st+ι~P (∙lst,a1,a2)
Each player tries to maximize his discounted cumulative reward. In this formulation, P1 aims to
maximize R1 (π1 , π2) while the goal of P2 is to minimize it. In a zero-sum two player SG, it has
been shown that the pairs of optimal policies conincide with the Nash equilibrium of this game. That
is, the value attained at the minimax equilibrium is the optimal value:
R* = min max R1(∏1,∏2) = max min R1(∏1, ∏2).
π1 π2	π2 π1
Let ∏* = (∏ι,∏2') denote the pair of optimal policies that attain the optimal value.
The result for two-player stochastic game setting is a similar upper bound as in the turn-based game
case.
Theorem 4. In a two-player zero-sum SG, for a policy pair π = (π1, π2 ),
lR(π1,π2) - R(πl,π2)1 ≤ C jEs 〜ρπ* [DKL(πf (IS)kπ13s)) + DKL(n4|s)kn2(IS))] . (17)
where C is a constant depending only on γ and CR.
The proof of Theorem 4 follows the same line of argument as that of Theorem 2. We use the
following standard definitions of the state-action value function Qπ1,π2, the value function Vπ1,π2
and the advantage function Aπ1 ,π2 :
∞
Qπ1 ,π2 (S, a, a ) = Est+1 ,at+1 ,a0t+1 ...	γ r(St+k, at+k, at+k)|St = S, at = a, at = a ,
k=0
∞
Vπ
1,π2 (S) = Eat,st+1,at+1,...	γkr(St+k, at+k, a0t+k)|St = S ,
k=0
Aπ1 ,π2 (S, a, a ) = Qπ1 ,π2 (S, a, a ) - Vπ1 ,π2 (S).
Like in the setting of turn-based games, the advantage function is uniformly bounded. Specifically,
for any policy π = (π1 , π2 ), S ∈ S , a ∈ A, a0 ∈ A,
। A∏1,∏2 (s,a,a∕) । = lQ∏ι,∏2(S, a, a ) - V∏ι,∏2 (S)I ≤	maX |r(s, a, a ) । =	.
1 - γ s∈S,a∈A,a0∈A	1 - γ
16
Under review as a conference paper at ICLR 2019
Similar to the turn-based game setting, We can express the difference in policy performance R(Π)-
R(π) as a sum of per-timestep advantages over π, as stated in the following lemma. The proof is
similar to that of Lemma 3 and is omitted here.
Lemma 5. Given any two policies π = (∏1,∏2) and ∏ = (∏1,∏2), we have
∞
R(Π) = R(π) + ET 〜∏ X γtA∏ (st,at,at)	(18)
t=0
where the expectation is taken over trajectories T := (so, a0, s1,a1...), and the notation ET〜∏[∙]
indicates that actions are SamPledfrOm policy π to generate τ.
Let ρπ be the unnormalized discounted visit frequencies, defined the same as (4):
ρπ(s) = P(s0 = s) + γP(s1 = s) + γ2P(s2 = s) + . . . ,
Consistently, let ρ∏ be the corresponding normalized probability distribution. Then, analogous to the
turn-based game setting, We can reWrite (18) as folloWs:
∞
R(Π) = R(π) + XX
P(St = SIn)IXX π1 ⑷S)n2(aIS)Y tA∏ (s,a aO)
t=0 s	a a0
∞
=R(n) + XX YtP(St = s|n) XX ∏1(a∣s)∏2(a0∣s)A∏(s, a, a0)
s t=0	a a0
=R(∏) + X Pn (s) XX ∏1(a∣S)∏2(a0∣S)A∏ (S,a, a0).	(19)
s	a a0
Now (19) implies equalities similar to (12) and (13). Using a policy n as the reference policy, we can
bound R(n) - R(n*) as follows:
R(π) - R(π*)∣
=(R(∏)- R(∏)) -(R(∏*)- R(∏))∣
= EEE (Pn(S)∏1(a∣S)∏2(a0|s) - ρ∏*(S)∏i(a∣S)n;(a0∣S))An(s, a,a0)
s a a0
≤CaEEE IPn(S)∏1(a∣S)∏2(a0∣S) - ρ∏(S)∏1(a∣S)∏2(a0∣S)
s a a0
+ ρ∏(S)∏1(a∣S)∏2(a0∣S) - ρ∏*(S)∏ι(a∣S)∏2(a0∣S)∣
≤Ca X ∣ρ∏ (s) - ρ∏* (s)∣ + CA XXX ρ∏* (S)∣∏1(a∣S)∏2(a0∣S) - ∏1(a∣S)∏2(a0∣S)∣ (20)
s	s a a0
Following identical steps of arguments utilized to bound R.H.S. of (14) in the proof of Theorem 2,
we can obtain the bound on the first term in the R.H.S. of (20) as follows:
X ∣∣
Pn(S)-Pn* (S) ∣ ≤ 1-- XXX ρn* (SO)InI (a|SO)n2(a0|SO)- n；(a|S0)n； (a0 | sO) ∣ ∙ (21)
s	Y s0 a a0
For each S ∈ S, a ∈ A1, aO ∈ A2 , we use the notation
n(a, aO|S) = n1(a|S)n2(aO|S)
17
Under review as a conference paper at ICLR 2019
to represent the joint action distribution of the two players under the policy (π1, π2). Substituting
(21) into (20) yields
∣R(π)-R(π*)∣ ≤ 1C-AγXXXρ∏*(S)InI⑷S)n2(aIS)-n；⑷S)n2(aIS)I
Ca
(1-tF
(1 -γ)ρ∏*(S)^ξ>ι(a∣S)∏2(a0∣S)-∏;(水)城(昨)|
=(T-A^Es~ρ∏* [TV(∏*(∙, ∙∣S)k∏(∙,忖)]
(a) λ∕2Cλ	「 i----------------------
≤ (T-γ^Es~ρ∏* ['DκL(∏*(∙,∙∣S)k∏(∙,∙∣S))
≤) (1-CA2，Es〜ρ∏* [DκL(∏*(∙,∙∣S)k∏(∙,∙∣S))]
二(1-CAɪ，Es〜ρ∏* [DκL(∏K∙∣S)k∏ι(∙∣S)) + DκL(∏4∣S)k∏2(∙∣S))],
where (a) follows from Pinker’s inequality and (b) follows from Jensen’s inequality. This concludes
the proof of Theorem 4.
F Additional Discussions on Theorem 2 and the Ideal Algorithm
Theorem 2 translates the distance between a trained policy π and the optimal one to the distance
of their expected rewards. It reinforces the intuition that if the expected κL divergence for the two
policies is small, then the difference of respected rewards should also be small. Crucially, note that
the expectation is taken with respect to ρ∏*. This fact allows one to use Monte Carlo methods to
run stochastic gradient descent (SGD) for policy optimization (i.e., the upper bound), and hence,
obtain a higher expected reward. The following pseudocode summarizes the ideal learning algorithm
discussed in Section 4.1, which is suggested by our Theorem 2.
Algorithm 2 Supervised Policy Optimization (theoretical)
1:	Optimizing a parameterized policy (πθ1 , πθ2 )
2:	for each step t = 0, 1, 2, . . . do
3:	query an oracle O at state St , which returns the optimal policy at state St , i∙e∙, n；(s)(.|St)
4:	run SGD to optimize the KL divergence between 开；(§)(，厢)and ∏θi(s) (∙∣s)
θI(st) J θI(st) - αt^θ DKL (π∕(st)(.加州成⑸)(I%))	(22)
5:	sample an action at 〜n；⑶)(∙∣St) and observe a new state St+ι
6:	end for
To better appreciate the power of Algorithm 2 and Theorem 2, let us consider two closely related
metrics that also upper bound |R(n) 一 R(n*) |. Interchanging the roles of n* and n in (5) gives the
bound
∣R(∏) — R(∏*)∣ ≤ CJEs〜p」DKL(n；(s)(・|S)kn；(s)(・|S))],
which suggests optimizing the metric Es〜ρπ [Dkl (∏∕(s)(∙∣S)k∏∕(s)(∙∣S))] ∙ Doing so is, however, of
little use: since optimal policy ∏7(s)(∙∣S) is supported only on the optimal actions, the divergence
DKL(nʃ(s)(∙∣s)∣∣∏7(s)(∙∣s)) is always +∞ unless ∏i(s)(∙∣s) is also optimal.
Another possibility is to use the bound
∣R(n) 一 R(n*)∣ ≤ C/Es〜p」DKL(n；(s)(・|S)kn；(s)(・|S))],	(23)
which follows from the same arguments as for Theorem 2. This bound differs from (5) in that the
expectation is taken with respect to Pn rather than p∏*. Therefore, to minimize the R.H.S. of (23), one
18
Under review as a conference paper at ICLR 2019
would run SGD to update θ by sampling from the current policy ∏θ rather than from the optimal ∏.
As the minimization of DKL W(S)(∙∣s)k∏θi(s) (∙∣s)) can be done only approximately, it is important
to focus on those states s frequently visited by the optimal policy—these are important states that
tend to have higher values and hence have a larger impact on the return of a policy. Therefore,
optimizing the R.H.S. of (5) as done in Algorithm 2, rather than that of (23), is more likely to require
less samples and produce a solution with better generalization performance.
Additionally, we note that the bound (5) is no longer valid if ρ∏* is replaced by an arbitrary
distribution ρ. As an example, pick a particular state s°, and assume that ρ(s0) = 1. Suppose
that ∏ equals ∏* at so, but otherwise takes extremely bad actions. One sees that in this case
Es〜P [Dkl(∏∕(s)(∙∣s)k∏/(s)(∙∣s))] = 0, but R(∏) may be very far from R(∏*). This observation
further demonstrates the delicacy of the bound in Theorem 2 and the importance of sampling from
ρπ* .
Before closing, let us remark on a subtle difference between the upper bound of Theorem 2 and
what is actually optimized by the ideal algorithm, Algorithm 2. Note that based on Theorem 2, we
are interested in minimizing Es 〜ρπ*
[DκL(∏∣(s)(∙∣s)k∏Ks)(∙∣s))]
That is, if one was to use SGD,
the state should be sampled from the discounted visit frequencies p∏*. In contrast, Algorithm 2
samples actions from μ*; that is, states are sampled under the distribution induced by ∏ without
discounting. However, this difference can be essentially ignored as we argue now. Let μ* be the
stationary distribution under policy π*, i.e., μ*(s) = limt→∞ P(St = s). Notice that as Y → 1, by
the definition of ρ∏* (s) in (4), p∏* (S)，(1 - γ)ρ∏*(s) → μ*(s). In practice, large Y (γ ≈ 1) is
used. Therefore, the difference between the two is very minimal, which justifies that the procedure
used in Algorithm 2 is a valid approximation.
Finally, as discussed in Section 4.2, in practice, the optimal oracle is replaced with an approximate
version, with MCTS being one particular example. In addition, We also note that in developing such
an algorithm, one could have parametrized the two policies separately in the form π = (πθ1 , πθ2), as
presented in the ideal algorithm above, by using for example one neural network for each player’s
policy. Depending on current player I(s) at state s, one of the networks is chosen and the output is
∏i(s)(∙∣s). However, it is also valid if we add I(S) into the input, that is, one can use only one neural
network: the input to it is (s,I(S)) and the output is interpreted as ∏θ(∙∣s, I(s)), the policy for player
I(S) at state S. The theory still holds provided the network is expressive enough. The two polices π1
and π2 now share the same parameters θ. Such a joint parametrization corresponds to the self-play
setting in AlphaGo Zero, where a single network is used and the input to it is both the current board
and the player to play.
G	Switch Scheduling
G.1 Basic Setup
Switch scheduling is a classical problem where at each time slot, a controller selects a matching
between the n input ports and the n output ports to transmit packets. Figure 3 illustrates an example
of an input-queued switch with three input ports and three output ports. Packets arriving at input
k destined for output ' are stored at input port k, in queue Qk,', thus there are N = 9 queues in
total. We consider the case where the new data packets are arriving at queue (k, l) at rate λk,l for
1 ≤ k, l ≤ n, according to Bernoulli distributions. That is, the number of packets arriving at queue
Qij is a Bernoulli random variable with mean λij . We call the matrix λ the traffic matrix, and let
us denote by Λ(x) the set of traffic matrices with effective load less than or equal to x. Overall, the
queue length for each queue evolves according to:
Qij(t +1)= max {Qij(t)-。切(t), 0} + Ber(λj(t)),	(24)
where σ is the matching selected by the controller.
To train a robust controller, we model the nature, i.e., the arrival processes that determine the
state transitions, as the adversary (the second player), whose action determines the packets’ arrival
rates. With this two-player setup, we now introduce the relevant quantities used during training: (a)
Naturally, the state S of the switch is the current queue lengths, i.e., S = {Qij }1≤i,j≤N . (b) The
action a of the controller is a matching σ between the input ports and the output ports. For any state
19
Under review as a conference paper at ICLR 2019
Figure 3: An input-queued switch, and two example matchings of inputs to outputs. Packets arriving
at input k destined for output' are stored at input port k, in queue Qk,', thus With three input ports
and three output ports, there are N = 9 queues in total.
S, the set of feasible actions for the controller, A(S), is exactly the set of possible matchings. (c)
The action a of the adversary is a traffic matrix λ, and the set of actions of the adversary is the set
of traffic matrices With load less than or equal to x, i.e., Ad(S) = Λ(x). (d) At state S, the reWard
r1 (S, A) for the controller is the negative total queue lengths after an action A (played either by
the controller or the nature) is applied, i.e., r(S, A) , - Pi,j (qij of state S0), Where S0 is the state
after an action is applied. Naturally, this reWard function encourages the controller to keep queues
small and hence, smaller packet delay. On the other hand, the adversary’s goal is to compete With
the controller by increasing the average queue size. The reWard r2 (S, A) for the adversary is alWays
equal to -r1 (S, A).
As a proof of concept, We consider a 3-port instance in our experiment. This means that We have 9
queues in total. We also restrict the maximum queue size to be 100. At first glance, n = 3 may seem
small. HoWever, the system actually has a huge state space With 1018 configurations. Overall the
scheduling problem is hard, even for seemingly small instances. When n = 3, there are 6 matchings,
from Which the controller can choose to play. To match the number of controller’s actions, We also
choose 6 random traffic matrices as the possible actions for the adversary. To make sure the system is
stable, the 6 traffic matrices are all doubly-stochastic matrices With load x < 1.
G.2 Training Robust Controller
The overall training process proceeds as implied by our theoretical result. The controller, P1, and
the adversary/nature, P2, take turns to pick an action: the controller schedules packets by picking
one of the 6 matchings, σ, and then the state evolves to max(S - σ, 0); the adversary adds packets
by selecting one of the 6 traffic matrices, λ. The number of arriving packets for each queue is then
sampled according to a Bernoulli distribution With mean given by the corresponding entry in λ, and
the state evolves to (S0 + Ber(λ)); the above process continues. Each action, either from P1 or P2,
is chosen by first running a finite-time MCTS and then playing the optimal action according to the
resulting policy from MCTS. The policy netWork of each player is trained by supervised learning
With cross-entropy loss. The optimal actions returned from MCTS serves as the training data.
Policy and value networks. We train tWo policy netWorks: one for the controller P1 and one for the
adversary P2. Additionally, similar to AGZ, We also train a value netWork Vθ to help With MCTS,
i.e., the optimal oracle is approximated by running a finite-time oracle that combines MCTS and
a value netWork together. Note that this choice is largely motivated by the nature of the problem.
Unlike AGZ, Which is essentially an episodic game, the sWitch scheduling problem is a continuing
task, Where the system runs forever to schedule queued packets and receive neW packets. The trees
need to be very deep in order for the system to operate in stationary states. With the value netWork,
one could quickly evaluate neW nodes and update the statistics during tree search. This might speed
up the MCTS process and hopefully, lead to a more efficient approximation for the optimal oracle.
Note that only one value netWork is needed. In a zero-sum game, the value of the controller should
be the negative value of the adversary. Finally, We remark that this overall setup indeed aligns With
20
Under review as a conference paper at ICLR 2019
our theory. Only the policy networks are trained to take actions: the value network is merely used to
guide our MCTS search to generate training data for the policy networks.
Training. The networks are all feed-forward neural networks. Each neural network has 2 hidden
layers with 24 ReLU units each. The input to these networks is a 3 × 3 state vector, i.e., the
configuration of the 9 queues. Policy networks have a softmax layer at the end with 6 output units
representing a probability distribution over the 6 possible actions. After each action, the networks
are trained immediately (i.e., batch size = 1). The policy networks are trained to minimize the
cross-entropy loss between its output (i.e., the predicted distribution over actions) and the policy
obtained from MCTS. As elaborated before, the switch scheduling problem is posed as a continuing
RL task. For such problems, minimizing the average reward is a more suitable measure. We train
the value network using the differential semi-gradient SARSA (Sutton & Barto, 1998) algorithm. In
particular, at each time after the controller receives a reward r at a state S, the network is updated.
We use Adam as our optimizer with a learning rate of 10-4.
MCTS. In each state that is either controlled by the scheduler or the adversary, an MCTS search is
executed, guided by the value function Vθ. The overall MCTS process is similar to the one used in
AGZ. For each state controlled by the scheduler, it performs multiple iterations of MCTS. In each
iteration, the basic search process uses a UCT (Kocsis et al., 2006) style approach to select the moves
to traverse the tree. As in AGZ, once a new node is expanded, its value is evaluated using the value
function Vθ and then propagated upwards to update the value estimates for all nodes on the search path.
The path traversed during each iteration of the MCTS search tree alternates between the controller
picking an action that maximizes its estimated average reward and the adversary minimizing it. At
the end of the final iteration, the action from the root that has the maximum value is chosen to be
the controller’s action for the current step. Note that this action becomes the training data for the
policy network of the controller. For each state controlled by the adversary P2, it also performs a
similar MCTS, using -Vθ as its value function to guide the search, and selects the traffic matrix
with the maximum value from its point of view in the end. For both the controller and the adversary,
we perform 500 iterations of MCTS search at each step. The MCTS search tree is restricted to a
maximum depth of 10.
21