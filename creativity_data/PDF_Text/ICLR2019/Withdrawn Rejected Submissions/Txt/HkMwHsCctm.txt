Under review as a conference paper at ICLR 2019
Principled Deep Neural Network Training
through Linear Programming
Anonymous authors
Paper under double-blind review
Abstract
Deep Learning has received significant attention due to its impressive performance in many
state-of-the-art learning tasks. Unfortunately, while very powerful, Deep Learning is not
well understood theoretically and in particular only recently results for the complexity of
training deep neural networks have been obtained. In this work we show that large classes
of deep neural networks with various architectures (e.g., DNNs, CNNs, Binary Neural
Networks, and ResNets), activation functions (e.g., ReLUs and leaky ReLUs), and loss
functions (e.g., Hinge loss, Euclidean loss, etc) can be trained to near optimality with desired
target accuracy using linear programming in time that is exponential in the input data and
parameter space dimension and polynomial in the size of the data set; improvements of
the dependence in the input dimension are known to be unlikely assuming P , NP, and
improving the dependence on the parameter space dimension remains open. In particular,
we obtain polynomial time algorithms for training for a given fixed network architecture.
Our work applies more broadly to empirical risk minimization problems which allows us
to generalize various previous results and obtain new complexity results for previously
unstudied architectures in the proper learning setting.
1	Introduction
Deep Learning is a powerful tool for modeling complex learning tasks. Its versatility allows for nuanced
architectures that capture various setups of interest and has demonstrated a nearly unrivaled performance on
state-of-the-art learning tasks across many domains. At the same time, the fundamental behavior of Deep
Learning methods is not well understood. One particular aspect that recently gained significant interest is the
computational complexity of training such networks. The basic training problem is usually formulated as an
empirical risk minimization problem (ERM) that can be phrased as
1D i i
min ∩ 5λ'(f (∙χi, φ), yi),
φ∈Φ D
i=1
(1)
where ' is some loss function, (xl, yi)D=i is an i.i.d. sample from some data distribution D, and f is a
neural network architecture parameterized by φ ∈ Φ with Φ being the parameter space of the considered
architecture (e.g., network weights). The empirical risk minimization problem is solved in lieu of the general
risk minimization problem (GRM) minφ ∈Φ E(x,y)∈D [`( f (x, φ), y)] which is usually impossible to solve due to
the inaccessibility of D . Several works have studied the training problem for specific architectures, both in
the proper and improper learning setup. In the former, the resulting “predictor” obtained from (1) is always
of the form f (∙, φ) for some φ ∈ Φ, whereas in the latter, the predictor is allowed to be outside the class of
1
Under review as a conference paper at ICLR 2019
functions {f (∙, φ) : φ ∈ Φ} as long as it satisfies certain approximation guarantee to the solution of (1)i. In
both cases, all results basically establish trainability in time that is exponential in the network parameters but
polynomial in the amount of data. In this work we complement and significantly extend previous work by
providing a principled method to convert the empirical risk minimization problem in (1) associated with the
learning problem for various architectures into a linear programming problem (LP) in the proper learning
setting. The obtained linear programming formulations are of size roughly exponential in the input dimension
and in the parameter space dimension and linear in the size of the data-set. This result provides new bounds
on the computational complexity of the training problem. For an overview on Complexity Theory we refer the
reader to Arora and Barak (2009).
Related Work
Our work is most closely related to Goel et al. (2017), Zhang et al. (2016), and Arora et al. (2018). In Zhang
et al. (2016) the authors show that `1 -regularized networks can be learned improperly in polynomial time in
the size of the data (with a possibly exponential architecture dependent constant) for networks with ReLU-like
activations (but not actual ReLUs) and an arbitrary number of layers k . These results were then generalized in
Goel et al. (2017) to actual ReLU activations. In both cases the improper learning setup is considered, i.e.,
the learned predictor is not a neural network itself and the learning problem is solved approximately for a
given target accuracy. In contrast to these works, Arora et al. (2018) considered proper and exact learning
however only for k = 2 (i.e., one hidden layer).
In relation to these works, we consider the proper learning setup for an arbitrary number of layers k and a
wide range of activations, loss functions, and architectures. As previous works, except for Arora et al. (2018),
we consider the approximate learning setup as we are solving the empirical risk minimization problem and we
also establish generalization of our so-trained models. Our approach makes use of Bienstock and Munoz
(2018) that allows for reformulating non-convex optimization problems with small treewidth and discrete as
well as continuous decision variables as an approximate linear programming formulations.
To the best of our knowledge, there are no previous papers that propose LP-based approaches for training
neural networks. There are, however, proposed uses of Mixed-Integer and Linear Programming technology in
other aspects of Deep Learning. Some examples of this include feature visualization (Fischetti and Jo, 2018),
generating adversarial examples (Cheng et al., 2017; Anonymous, 2019a; Fischetti and Jo, 2018), counting
linear regions of a Deep Neural Network (Serra et al., 2017), performing inference (Amos et al., 2017) and
providing strong convex relaxations for trained neural networks (Anderson et al., 2018).
Contribution
We first establish a general framework that allows us to reformulate (regularized) ERM problems arising in
Deep Learning (among others!) into approximate linear programs with explicit bounds on their complexity.
The resulting methodology allows for providing complexity upper bounds for specific setups simply by
plugging-in complexity measures for the constituting elements such as layer architecture, activation functions,
and loss functions. In particular our approach overcomes limitations of previous approaches in terms of
handling the accuracy of approximations of non-linearities used in the approximation functions to achieve the
overall target accuracy.
Principled Training through LPs. If > 0 is arbitrary, then for any sample size D there exists a data-
independent linear program, i.e., the LP can be written down before seeing the data, with the following
properties:
1In the case of Neural Networks, for example, improper learning could lead to a predictor that does not correspond to
a Neural Network, but that might behave closely to one.
2
Under review as a conference paper at ICLR 2019
Solving the ERM problem to -optimality. The linear program describes a polyhedron P such that for every
realized data set (X, Y) = (X： yi)D=i there is a face FXY ⊆ P such that optimizing certain linear function over
FX, Y solves (1) to E-OPtimaIity returning a feasible parametrization φ ∈ Φ which is part of our hypothesis
class (i.e., We consider proper learning). The face FXY ⊆ P is simply obtained from P by fixing certain
variables of the linear program using the values of the actual sample; equivalently, by Farkas’ lemma, this
can be achieved by modifying the objective function to ensure optimization over the face belonging to the
data. As such, the linear program has a build-once-solve-many feature. We will also show that a possible
data-dependent LP formulation is meaningless (see Appendix B).
Size of the linear program. The size, measured as bit complexity, of the linear program is roughly
O((2L/E)N+n+m D) where L is a constant depending on `, f , and Φ that we will introduce later, n, m are
the dimensions of the data points, i.e., XZ ∈ Rn and yi ∈ Rm for all i ∈ [D], and N is the dimension of
the parameter space Φ. The overall learning algorithm is obtained then by formulating and solving the
linear program, e.g., with the ellipsoid method whose running time is polynomial in the size of the input
Grotschel et al. (2012). Even sharper size bounds can be obtained for specific architectures assuming network
structure (see Appendix F) and our approach immediately extends to regularized ERMs (see Appendix E). It
is important to mention that the constant L measures a certain Lipschitzness of the ERM training problem.
While not exactly requiring Lipschitz continuity in the same way, Lipschitz constants have been used before
for measuring complexity in the improper learning framework (see Goel et al. (2017)) and more recently have
been shown to be linked to generalization in Gouk et al. (2018).
Generalization. Additionally, we establish that the solutions obtained for the ERM problem via our linear
programming approach generalize, utilizing techniques from stochastic optimization. We also show that using
our approach one can obtain a significant improvement on the results of Goel et al. (2017) when approximating
the general risk minimization problem. Due to space limitations, however, we relegate this discussion to
Appendix I.
Throughout this work we assume both data and parameters to be well-scaled, which is a common assumption
and mainly serves to simplify the representation of our results; the main assumption is the reasonable
boundedness, which can be assumed without significant loss of generality as actual computations assume
boundedness in any case (see also Liao et al. (2018) for arguments advocating the use of normalized
coefficients in neural networks). More specifically, we assume Φ ⊆ [-1,1]N as well as (x, y)〜D satisfies
(X, y) ∈ [-1, 1]n × [-1, 1]m. We point out three important features of our results. First, we provide a solution
method that has provable optimality guarantees for the ERM problem, ensures generalization, and linear
dependency on the data (in terms of the complexity of the LP) without assuming convexity of the optimization
problem. To the best of our knowledge, the only result presenting optimality guarantees in a proper learning,
non-convex setting is that of Arora et al. (2018). Second, the linear program that we construct for a given
sample size D is data-independent in the sense that it can be written down before seeing the actual data
realization and as such it encodes reasonable approximations of all possible data sets that can be given as an
input to the ERM problem. This in particular shows that our linear programs are not simply discretizing space:
if one considers a discretization of data contained in [-1, 1]n × [-1, 1]m, the total number of possible data sets
of size D is exponential in D, which makes the linear dependence on D of the size of our LPs a remarkable
feature. Finally, our approach can be directly extended to handle commonly used regularizers as we show in
Appendix E; for ease of presentation though we omit regularizers throughout our main discussions.
Complexity results for various network architectures. We apply our methodology to various well-known
neural network architectures and either generalize previous results or provide completely new results. We
provide an overview of our results in Table 1, where k is the number of layers, w is width of the network,
n/m are the input/output dimensions and N is the total number of parameters. We use G to denote the
directed graph defining the neural network and ∆ the maximum vertex in-degree in G. In all results the node
3
Under review as a conference paper at ICLR 2019
	Table 1: Summary of results for various architectures
Type	Loss Function	SizeofLP	Remarks
Fully connected DNN	Absolute/Quadratic/Hinge O mwO(k2)/	D	N = |E(G)|
Fully connected DNN	Cross-Entropy + Soft-Max O m log(m)wO(k2)/	D N = |E(G)|
Convolutional NN	Absolute/Quadratic/Hinge O mwO(k2)/	D	N	|E(G) |
ResNet	2	n+m+ N Absolute/Quadratic/Hinge O m∆O(k )/	D
ResNet	Cross-Entropy + Soft-Max O m log(m)∆O(k2)/	D
computations are linear with bias term and normalized coefficients, and activation functions with Lipschitz
constant at most 1 and with 0 as a fixed point; these include ReLU, Leaky ReLU, eLU, Tanh, among others.
We would like to point out that certain improvements in the results in Table 1 can be obtained by further
specifying if the ERM problem corresponds to regression or classification. For example, the choice of loss
functions and the nature of the output data y (discrete or continuous) typically rely on this. We can exploit
such features in the construction of the LPs (see the proof of Theorem 3.1) and provide a sharper bound on
the LP size. Nonetheless, these improvements are not especially significant and in the interest of clarity and
brevity we prefer to provide a unified discussion on ERM. Missing proofs have been relegated to the appendix
due to space limitations.
The complexity of the training problem for the Fully Connected DNN case is arguably the most studied and,
to the best of our knowledge, all training algorithms with approximation or optimality guarantees have a
polynomial dependency on D only after fixing the architecture (depth, width, input dimension, etc.). In our
setting, once the architecture is fixed, we obtain a polynomial dependence in both D and 1/ . Moreover, our
results show that in the bounded case one can obtain a training algorithm with polynomial dependence on D
across all architectures, assuming very little on the specific details of the network (loss, activation, etc). This
answers an open question left by Arora et al. (2018) regarding the possibility of a training algorithm with
polynomial dependence on D. In addition, we show that a uniform LP can be obtained without compromising
that dependence on D.
The reader might wonder if the exponential dependence on the other parameters of our LP sizes can be
improved, namely the input dimension n + m and the parameter space dimension N (we are ignoring for the
moment the exponent involving the depth k, as it will be typically dominated by N). The dependence on
the input dimension is unlikely to be improved due to the NP-hardness result in Blum and Rivest (1992),
whereas obtaining a polynomial dependence on the parameter space dimension remains open (see Arora
et al. (2018)). A recent paper Anonymous (2019b) provides an NP-hard DNN training problem that becomes
polynomially solvable when the input dimension is fixed. However, this result considers a fixed architecture,
thus the parameter space dimension is a constant and the running time is measured with respect to D.
2	Preliminaries
In the following let [n] {1, . . . , n} and [n]0 {0, . . . , n}. Given a graph H, we will use V(H) and E(H) to
denote the vertex-set and edge-set of H, respectively, and δH (u) will be the set of edges incident to vertex u.
We will need:
4
Under review as a conference paper at ICLR 2019
Definition 2.1. For a function g : K ⊆ Rn → R, we denote its Lipschitz constant with respect to the p-norm
over K as Lp(g), satisfying |g(x) - g(y)| ≤ Lp(g)kx - ykp for all x, y ∈ K (whenever it exists).
Moreover, in the following let Eω ∈ω [∙] and Vω ∈ω [∙] denote the expectation and variance with respect to the
random variable ω ∈ Ω, respectively.
2.1	Empirical Risk Minimization
The basic ERM problem is typically of the form(1), where ' is some loss function, (xcl, yi)D=i is an i.i.d. sample
from some data distribution D that we have reasonable sampling access to, and f is a model that is parametrized
by φ ∈ Φ. We consider the proper learning setting here, where the computed solution to the ERM problem
has to belong to the hypothesis class induced by Φ; for a detailed discussion see Appendix A.2. We next
define the Lipschitz constant of an ERM problem with respect to the infinity norm.
Definition 2.2. Consider the ERM problem (1) with parameters D, Φ, `, f . We define the Architecture
Lipschitz Constant L(D, Φ, `, f ) as
L(D, Φ,',f 厂 L∞('(f (∙,∙),∙))	(2)
over the domain K = [-1, 1]n × Φ × [-1, 1]m.
We emphasize that in (2) we are considering the data-dependent entries as variables as well, and not only the
parameters Φ as it is usually done in the literature. This is because we will construct data-independent LPs, a
subtlety that will become clear later.
2.2	Neural Networks
A neural network can be understood as a function f defined over a directed graph that maps inputs x ∈ Rn
to f(x ) ∈ Rm . The directed graph G = (V, E), which represents the network architecture, often naturally
decomposes into layers V = IJi∈[k]0 Vi With Vi ⊆ V, where V) is referred to as the input layer and Vk as the
output layer. To all other layers we refer to as hidden layers. These graphs do neither have to be acyclic (as
in the case of recurrent neural networks) nor does the layer decomposition imply that arcs are only allowed
between adjacent layers (as in the case of ResNets). In feed-forward networks, however, the graph is assumed
to be acyclic. For the unfamiliar reader we provide a more formal definition in Appendix A.3.
2.3	Binary Optimization problems with small treewidth
We will introduce the key concepts that we need to formulate and solve binary optimization problems with
small treewidth, which will be the main workhorse behind our results. The treewidth of a graph is a parameter
used to measure how tree-like a given graph is. Among all its equivalent definitions, the one we will use in
this work is the following:
Definition 2.3. Let G be an undirected graph. A tree-decomposition (Robertson and Seymour (1986)) of G
is a pair (T, Q) where T is a tree and Q = {Qt : t ∈ V(T)} is a family of subsets of V(G) such that
(i)	For all v ∈ V (G), the set {t ∈ V(T) : v ∈ Qt} forms a sub-tree Tv of T, and
(ii)	For each {u, v} ∈ E(G) there is a t ∈ V(T) such that {u, v} ⊆ Qt , i.e., t ∈ Tu ∩ Tv .
The width of the decomposition is defined as max {|Qt | : t ∈ V(T)} - 1. The treewidth ofG is the minimum
width over all tree-decompositions of G.
5
Under review as a conference paper at ICLR 2019
We refer to the Qt as bags as customary. An example of a tree-decomposition is given in Figure 2 in
Appendix A.1. In addition to width, another important feature of a tree-decomposition (T, Q) we use is the
size of the tree-decomposition given by |V (T)|.
Consider a problem of the form
(BO) : min cTx + dTy
s.t.	fi(x)	≥	0,	i ∈	[m]	gj (x)	=	yj,	j ∈	[p]
x ∈ {0, 1}n, y ∈ Rp,
where the fi and gj are arbitrary functions that we access via a function value oracle, i.e., an oracle that returns
the function upon presentation with an input. We will further use the concept of intersection graph.
Definition 2.4. The intersection graph Γ[I] for an instance I of BO is the undirected graph which has a
vertex for each x variable and an edge for each pair of x variables that appear in any common constraint.
Note that in the above definition we have ignored the y variables which will be of great importance later. The
sparsity of a problem is now given by the treewidth of its intersection graph and we obtain:
Theorem 2.5. Consider an instance I of problem BO. If Γ[I] has a tree-decomposition (T, Q) of width ω,
there is an exact linear programming reformulation of I with O (2ω (|V(T)| + p)) variables and constraints.
Theorem 2.5 is an immediate generalization of a theorem in Bienstock and Munoz (2018) distinguishing the
variables y , which do not need to be binary in nature, but are fully determined by the binary variables x .
The proof is omitted as it is almost identical to the proof in Bienstock and Munoz (2018). For the sake of
completeness, we include a proof sketch in Appendix C.1.
3 Approximation to ERM via data-independent LPs
We will now show how we can obtain an approximate LP formulation for the ERM problem. A notable feature
is that our LP formulation is data-independent in the sense that we can write down the LP, for a given sample
size D, before having seen the actual data; the LP is later specialized to a given data set by fixing some of its
variables. This subtlety is extremely important as it prevents trivial solutions, where some non-deterministic
guess provides a solution to the ERM problem for a given data set and then simply writes down a small LP
that outputs the network configuration; such an LP would be of small size (the typical notion of complexity
used for LPs) however not efficiently computable. By making the construction independent of the data we
circumvent this issue; we provide a short discussion in Appendix B and refer the interested reader to Braun
et al. (2016; 2015); Braun and Pokutta (2018+) for an in-depth discussion of this subtlety. Slightly simplifying,
we might say for now that in the same way we do not want algorithms to be designed for a fixed data set, we
do not want to construct LPs for a specific data set but for a wide range of data sets.
As mentioned before, We assume Φ ⊆ [-1,1]N as well as (羽 y)〜D satisfies (羽 y) ∈ [-1,1]n × [-1,1]m as
normalization to simplify the exposition. Since the BO problem only considers linear objective functions, we
begin by reformulating the ERM problem (1) in the following equivalent form:
1D
min L d
φ ∈φlD d=
Ld = '(f (Xam yd) ∀ d ∈ [D]j
(4)
3.1	Approximation of the feasible region via an -grid
Motivated by this reformulation, we study an approximation to the following set:
S(D,φ,',f) =	{(X1,...,Xd,y1,...,yd,φ,L) ∈ [-1,1](n+m)D ×Φ× RD	:	Ld	=	'(f(xd,φ),yd)0	⑸
6
Under review as a conference paper at ICLR 2019
The variables (xi, yi)iD=1 denote the data variables, that will be assigned values upon a specification of a data
set of sample size D.
Let r ∈ R with -1 ≤ r ≤ 1. Given γ ∈ (0, 1) we can approximate r as a sum of inverse powers of 2, within
additive error proportional to γ. For Nγ	dlog2 γ-1e there exist values zh ∈ {0, 1} with h ∈ [Nγ], so that
Nγ	Nγ
-1 + 2 ∙ S 2-hZh ≤ r ≤ -1 + 2 ∙ S 2-hZh + 2γ ≤ 1.	(6)
h=1	h=1
Our strategy is now to approximately represent the x, y, φ variables via these binary approximations, i.e., as
T + 2 ∙ 2L= ι 2-hZh where each Zh is a (new) binary variable. Define W = 2γL, where L = L(D, Φ,', f) is
the architecture Lipschitz constant defined in (2), and consider the following approximation of S(D, Φ, `, f):
Se (D, Φ,',f) ± {(X1,..., X d, y1,..., yD,φ, L) ∈ [-1,1](n+m)D × Φ × RD : z ∈ {0,1} NY (N+Dn+Dm)
Nγ
Ld =	'(f (Xd,	φ),	yd),	d ∈	[D]	φi	=	—1	+ 2 S 2-hZzφh,	i ∈	[N]
h=1
Nγ	Nγ
yd = -1 + 2 S 2-hZyh, d ∈ [D], i ∈ [m]	xd = -1 + 2 S 2-hZXd, d ∈ [D], i ∈ [n]}.
h=1	h=1
We can readily describe the error of the approximation of S(D, Φ, `, f) by S (D, Φ, `, f) in the ERM problem
(1) induced by the discretization:
Lemma 3.1. For any (x 1,..., XD, y1,..., yD, φ, L) ∈ S(D, Φ,', f) there is (X1,..., XD, y1,..., yD, φ,L) ∈
Se(d, φ,', f) such that ID Zd=ILd - D 4 Ldd∣ ≤ w
By substituting out the X, y, φ by means of the equations of S (D, Φ, `, f), we obtain a feasible region as BO.
3.2 Linear reformulation of the binary approximation
So far, we have phrased the ERM problem (1) in terms of a binary optimization problem using a discretization
of the continuous variables. This in and of itself is neither insightful nor useful. In this section we will
perform the key step, reformulating the convex hull of S (D, Φ, `, f) as a moderate-sized linear program by
means of Theorem 2.5 exploiting small treewidth of the ERM problem.
After replacing the (X, y, φ) variables in S (D, Φ, `, f) using the Z variables, we can see that the intersection
graph of S (D, Φ, `, f) is given by Figure 1a, where we use (X, y, φ) as stand-ins for corresponding the binary
variables Zx, Zy, Zφ . Recall that the intersection graph does not include the L variables. It is not hard to see that
a valid tree-decomposition for this graph is given by Figure 1b. This tree-decomposition has size D and width
Nγ(n + m + N) - 1 (much less than the Nγ(N + Dn + Dm) binary variables). This yields our main theorem:
Main Theorem 3.1. LetD ∈ N be a given sample size. Then conv(S (D, Φ, `, f)) admits a linear programming
formulation with the following properties:
(a)	The linear program has no more than 4D (2L /W)n+m+N variables and 2D(2 (2L /W)n+m+N + 1) constraints.
We refer to the resulting polytope as PS .
(b)	The linear program can be constructed in time O((2L/W)n+m+N D) plus the time required for
O((2L/W)n+m+N) evaluations of ` and f.
7
Under review as a conference paper at ICLR 2019
(a) Intersection Graph of S (D, Φ, `, f )
(b) Valid Tree-Decomposition
Figure 1: Intersection Graph and Tree-Decomposition of S (D, Φ, `, f )
(c)	Fix any data set (JX, Y^) = (j^l, yi )3 ofsize D, with j^l ∈ [-1,1]n and yi ∈ [-1,1]m. There exists a face
FX Y of PSe SUCh that
(D ELL
φ ∈ argmin
φ,L
(φ, L) ∈ Proj(FXY)
φ, L ,
)
satisfies ID 2D=] ['(f (∙X1, φ*), y^l) - '(f (X]φ), yi)] ∣ ≤ 2β, where φ* ∈ [-1,1]N is an optimal solution to
the ERM problem (1) with input data (X, Y). This means that solving an LP using an appropriate face of
PSe solves the ERM problem (1) within an additive error 2.
(d)	The face FXY arises by substituting in actual data for the data-variables x, y, which determine the
approximations zx, zy and is used to fixed additional variables of the LP.
Proof. The proof of part (a) follows directly from Theorem 2.5 using Nγ = dlog(2L/)e along with the
tree-decomposition of Figure 1b, which implies |V (T 0)| + p = 2D in this case. Parts (b), (c) and (d) rely on
the explicit construction for Theorem 2.5 and they are given in Appendix D.
Observe that equivalently, by Farkas’ lemma, optimizing over the face can be also achieved by modifying
the objective function in a straightforward way. Also note that the number of evaluations of ` and f is
independent of D. We would like to further point out that we can provide an interesting refinement of the
theorem from above: if Φ has an inherent network structure (as in the case of Neural Networks) one can
exploit treewidth-based sparsity of the network itself in order to obtain a smaller linear program with the same
approximation guarantees as before. This allows us to reduce the exponent in the exponential term of the LP
size to an expression that depends on the sparsity of the network, instead of its size. For brevity of exposition,
we relegate this discussion to Appendix F. Another improvement can be obtained by using more information
about the input data. Assuming extra structure on the input, one could potentially improve the n + m exponent
on the LP size. We relegate the discussion of this feature to Remark D.1 in the Appendix, as it requires the
explicit construction of the LP, which we also provide in the Appendix. 4
4 Complexity for Specific Architectures
4.1 Fully-connected layers with ReLU activations and normalized coefficients
We consider a DeeP Neural Network f : Rn → Rm with k layers given by f = Tk ◦ σ ◦•••◦ T? ◦ σ ◦ T], where
σ is the ReLU activation function σ(x) max{0, x} applied component-wise and each Tl : Rwi-1 → Rwi
is an affine linear function. Here w0 = n is the dimension of the inPut data and wk = m is the dimension
of the outPut of the network. We write Tl(z) = Alz + bl for i ∈ [k] and assume kAl k∞ ≤ 1, kbl k∞ ≤ 1 via
8
Under review as a conference paper at ICLR 2019
t ∙	1 ∙ mi	∙ r∙	t ∙ t	∙	11	t	1	r∙	t ∙	∙ r,Ir	^T l'
normalization. Thus, if V is a node in layer i, the node computation performed in V is of the form a Z + b,
where a^ is a row of Ai and b is a component of bi. Note that in this case the dimension of the parameter space
Φ is exactly the number of edges of the network. Hence, we use N to represent the number of edges as well.
We begin with a short technical Lemma, with which we can immediately establish the following corollary.
Lemma 4.1. For every i ∈ [k - 1]o define Ui = [i= WW. If ∣∣z∣∣∞ ≤ Ui then kTi+ι(z)k∞ ≤ Ui+ι.
Corollary 4.2. If Φ is the class of Neural Networks with k layers, N edges, ReLU activations,
and normalized coefficients, then conv(S (D, Φ, `, f )) can be formulated via a linear program of size
O((2L∞(')wO(k22/e)n+m+ND), where W = maxi∙∈[k-i]0 Wi and L∞(') is the Lipschitz constant of '(∙, ∙) over
[-Uk, Uk]m × [-1,1]m. The linear program can be constructed in time O((2L∞(')wo(k2)∕β)n+m+ND) Plus
the time requiredfor O((2L∞(')wO(k2)∕6)n+m+N) evaluations of' and f.
Proof. Proving that the architecture Lipschitz constant is L∞(')wO(k2) suffices. Note that all node computations
take the form h(z, a, b) = zT a + b for a ∈ [-1, 1]w and b ∈ [-1, 1]. The only difference is made in the domain
ofz, which varies from layer to layer. The 1-norm of the gradient ofh is at most kzk1 + kak1 + 1 ≤ kzk1 + W + 1
which, in virtue of Lemma 4.1, implies that a node computation on layer i (where the weights are considered
variables as well) has Lipschitz constant at most ∑lj-=0 Wj + W + 1 ≤ ∑lj∙=o 2wj = 2 Ww--I ≤ 2wi+1. On
the other hand, for k(a, b) - (a0, b0)k∞ ≤ γ and z ∈ [-Ui, Ui], it holds that | h(z, a, b) - h(z0, a0, b0)| ≤
2Wi+1 k(z - z0, a - a0, b - b0)k∞ ≤ 2Wi+1 max{kz - z0 k∞, γ}, which shows that the Lipschitz constants can be
multiplied layer-by-layer to obtain the overall architecture Lipschitz constant. Since ReLUs have Lipschitz
constant equal to 1, and nk=ι 2w'+1 = WO(k2), whenever W ≥ 2, we conclude the architecture Lipschitz
constant is L∞(')WO(k2).	□
The reader might have noticed that a sharper bound for the Lipschitz constant above could have been used,
however we chose simpler bounds for the sake of presentation. It is worthwhile to compare the previous
lemma to the following closely related result.
Theorem 4.3. (Arora et al., 2018, Theorem 4.1) Let Φ be the class of Neural Networks with 1 hidden layer
(k = 2), convex loss function `, ReLU activations and output dimension m = 1. There exists an algorithm to
find a global optimum of the ERM problem in time O(2w Dnw poly(D, n, W)).
Remark 4.4. We point out a few key differences of this result with the algorithm we can obtain from solving
the LP in Corollary 4.2: (a) One advantage of our result is the benign dependency on D. An algorithm that
solves the training problem using our proposed LP has polynomial dependency on the data-size regardless of
the architecture. (b) As we have mentioned before, our approach is able to construct an LP before seeing
the data. (c) The dependency on W of our algorithm is also polynomial. To be fair, we are including an
extra parameter N —the number of edges of the Neural Network—on which the size of our LP depends
exponentially. (d) We are able to handle any output dimension m and any number of layers k . (e) We do not
assume convexity of the loss function `, which causes the resulting LP size to depend on how well behaved `
is in terms of its Lipschitzness. (f) The result of Arora et al. (2018) has two advantages over our result: there
is no boundedness assumption on the coefficients, and they are able to provide a globally optimal solution
instead of an -approximation.
4.2 ResNets, CNNs, and alternative activations
Corollary 4.2 can be directly generalized to handle other architectures as well, as the key features we used
before are the acyclic structure of a standard Neural Network and the well behaved Lipschitz constant of the
ReLU function. These features are present in many other architectures, and yield the following result.
9
Under review as a conference paper at ICLR 2019
Lemma 4.5. Let Φ denote the class of feed-forward Neural Networks with k layers, as defined in Section
2.2, N edges, affine node computations, activation functions ai : R → R with Lipschitz constant at most
1 and such that a(0) = 0, and normalized coefficients. Then conv(S (D, Φ, `, f )) can be formulated via a
linear program ofsize O ((2L∞(')∆O(k )/e )n+m+N D), where ∆ denotes the maximum vertex in-degree ofthe
network and L∞(') is the Lipschitz constant of '(∙, ∙) over [- Uk, Uk]m × [-1,1]m. The linear program can
be constructed in time O((2L∞(')∆o(k2)∕β)n+m+N D) plus the time requiredfor O((2L∞(')∆o(k2)∕β)n+m+N)
evaluations of` and f .
Corollary 4.6. The ERM problem (1) over Deep Residual Networks (ResNets) with 1-Lipschitz activations
can be solved to -optimality in time poly(∆, 1/, D) whenever the network size and number of layers are fixed.
Another interesting point can be made with respect to Convolutional Neural Networks (CNN). In these,
convolutional layers are included which help to significantly reduce the number of parameters involved in the
neural network. From a theoretical perspective, a CNN can be obtained by simply enforcing certain parameters
of a fully-connected DNN to be equal. This implies that Lemma 4.5 can also be applied to CNNs, with the key
difference residing in parameter N , which is the dimension of the parameter space and does not correspond to
the number of edges in a CNN. In Table 1 we provide explicit LP sizes for common architectures. These
results can be directly obtained from Lemma 4.5, using the specific Lipschitz constants of the loss functions.
We provide explicit computations in Appendix G.
5 Conclusion and Final remarks
We have presented a novel framework which shows that training a wide variety of neural networks can be done
in time which depends polynomially on the data set size, while satisfying a predetermined arbitrary optimality
tolerance. Our approach is realized by approaching training through the lens of linear programming. Moreover,
we show that training using a particular data set is closely related to the face structure of a data-independent
polytope.
Our contributions not only improve the best known algorithmic results for neural network training with
optimality/approximation guarantees, but also shed new light on (theoretical) neural network training by
bringing together concepts of graph theory, polyhedral geometry, and non-convex optimization as a tool for
Deep Learning.
While the LPs we are constructing are large, and likely to be difficult to solve by straightforward use of our
formulation, we strongly believe the theoretical foundations we lay here can also have practical implications
in the Machine Learning community. First of all, we emphasize that all our architecture dependent terms
are worst-case bounds, which can be improved by assuming more structure in the corresponding problems.
Additionally, the history of Linear Programming has provided many interesting cases of extremely large LPs
that can be solved to near-optimality without necessarily generating the complete LP description. In these
cases the theoretical understanding of the LP structure is crucial to drive the development of incremental
solution strategies.
Finally, we would like to point out an interesting connection between the way our approach works and the
current most practically effective training algorithm: stochastic gradient descent. Our LP approach implicitly
"decomposes" the problem for each data point, and the LP merges them back together without losing any
information nor optimality guarantee, even in the non-convex setting. This is the core reason why our LP has
a linear dependence on D, and bears close resemblance to SGD where single data points (or batches of those)
are used in a given step. As such, our results might provide a new perspective, through low treewidth, on why
the current practical algorithms work so well, and perhaps hints at a synergy between the two approaches. We
believe this can be an interesting path to bring our ideas to practice.
10
Under review as a conference paper at ICLR 2019
References
S. Ahmed. A Graduate Course on Stochastic Programming. preprint, 2017.
B. Amos, L. Xu, and J. Z. Kolter. Input convex neural networks. In International Conference on Machine
Learning, pages 146-155, 2017.
R. Anderson, J. Huchette, C. Tjandraatmadja, and J. P. Vielma. Strong convex relaxations and mixed-integer
programming formulations for trained neural networks. arXiv preprint arXiv:1811.01988, 2018.
Anonymous. Combinatorial attacks on binarized neural networks. In Submitted to International Conference
on Learning Representations, 2019a. URL https://openreview.net/forum?id=S1lTEh09FQ. under
review.
Anonymous. Complexity of training relu neural networks. In Submitted to International Conference on
Learning Representations, 2019b. URL https://openreview.net/forum?id=HyVbhi0cYX. under
review.
R.	Arora, A. Basu, P. Mianjy, and A. Mukherjee. Understanding deep neural networks with rectified linear
units. to appear in Proceedings of ICLR 2018, arXiv preprint arXiv:1611.01491, 2018.
S.	Arora and B. Barak. Computational Complexity - A Modern Approach. Cambridge University Press, 2009.
ISBN 978-0-521-42426-4. URL http://www.cambridge.org/catalogue/catalogue.asp?isbn=
9780521424264.
A. Atserias. On digraph coloring problems and treewidth duality. European Journal of Combinatorics, 29(4):
796-820, 2008.
D. Bienstock. On embedding graphs in trees. Journal of Combinatorial Theory, Series B, 49(1):103-136,
1990.
D. Bienstock and G. Munoz. LP formulations for polynomial optimization problems. SIAM Journal on
Optimization, 28(2):1121-1150, 2018.
A. L. Blum and R. L. Rivest. Training a 3-node neural network is np-complete. Neural Networks, 5
(1):117 - 127, 1992. ISSN 0893-6080. doi: https://doi.org/10.1016/S0893-6080(05)80010-3. URL
http://www.sciencedirect.com/science/article/pii/S0893608005800103.
G. Braun and S. Pokutta. Extended formulations: survey and introduction. Manuscript, 2018+.
G. Braun, S. Pokutta, and D. Zink. Inapproximability of combinatorial problems via small lps and sdps. In
Proceedings of the forty-seventh annual ACM symposium on Theory of computing, pages 107-116. ACM,
2015.
G. Braun, S. Fiorini, and S. Pokutta. Average case polyhedral complexity of the maximum stable set problem.
Mathematical Programming, 160(1-2):407-431, 2016.
G. Calinescu, C. G. Fernandes, and B. Reed. Multicuts in unweighted graphs and digraphs with bounded
degree and bounded tree-width. In Proceedings of the 6th Conference on Integer Programming and
Combinatorial Optimization (IPCO). Citeseer, 1998.
C.-H. Cheng, G. Nuhrenberg, and H. Ruess. Maximum resilience of artificial neural networks. In International
Symposium on Automated Technology for Verification and Analysis, pages 251-268. Springer, 2017.
11
Under review as a conference paper at ICLR 2019
M. Courbariaux, I. Hubara, D. Soudry, R. El-Yaniv, and Y. Bengio. Binarized neural networks: Training deep
neural networks with weights and activations constrained to+ 1 or-1. arXiv preprint arXiv:1602.02830,
2016.
M. Fischetti and J. Jo. DeeP neural networks and mixed integer linear optimization. Constraints, pages 1-14,
2018.
S. Goel, V. Kanade, A. Klivans, and J. Thaler. Reliably learning the relu in polynomial time. In Conference
on Learning Theory, pages 1004-1042, 2017.
H. Gouk, E. Frank, B. Pfahringer, and M. Cree. Regularisation of neural networks by enforcing lipschitz
continuity. arXiv preprint arXiv:1804.04368, 2018.
M. Grotschel, L. Lovasz, and A. Schrijver. Geometric algorithms and combinatorial optimization, volume 2.
Springer Science & Business Media, 2012.
D. J. Harvey and D. R. Wood. The treewidth of line graphs. Journal of Combinatorial Theory, Series B, 2018.
Q. Liao, B. Miranda, A. Banburski, J. Hidary, and T. Poggio. A surprising linear relationship predicts test
performance in deep networks. arXiv preprint arXiv:1807.09659, 2018.
P. Manurangsi and D. Reichman. The computational complexity of training relu (s). arXiv preprint
arXiv:1810.04207, 2018.
N. Robertson and P. D. Seymour. Graph minors II: Algorithmic aspects of tree-width. Journal of Algorithms,
7:309 - 322, 1986.
T. Serra, C. Tjandraatmadja, and S. Ramalingam. Bounding and counting linear regions of deep neural
networks. arXiv preprint arXiv:1711.02114, 2017.
A. Shapiro, D. Dentcheva, and A. Ruszczynski. Lectures on stochastic programming: modeling and theory.
SIAM, 2009.
Y. Zhang, J. D. Lee, and M. I. Jordan. l1-regularized neural networks are improperly learnable in polynomial
time. In International Conference on Machine Learning, pages 993-1001, 2016.
12
Under review as a conference paper at ICLR 2019
G(D(D
(a) Graph G
(b) A tree-decomposition of G of width 2, with the sets Qt
indicated inside each node of the tree.
Figure 2: Example of graph and valid tree-decomposition
A Further definitions
A.1 Complementary discussion on Treewidth
The concept of treewidth is an important concept in the context of solving optimization problems with ‘sparse’
structure. An alternative definition to Definition 2.3 of treewidth that the reader might find useful is the
following; recall that a chordal graph is a graph where every induced cycle has length exactly 3.
Definition A.1. An undirected graph G = (V, E) has treewidth ≤ ω if there exists a chordal graph H = (V, E0)
with E ⊆ E 0 and clique number ≤ ω + 1.
H in the definition above is sometimes referred to as a chordal completion of G. In Figure 2 we present
an example of a graph and a valid tree-decomposition. The reader can easily verify that the conditions of
Definition 2.3 are met in this example. Moreover, using Definition A.1 one can verify that the treewidth of the
graph in Figure 2 is exactly 2.
Two important folklore results we use in Section C.1 and Section F are the following.
Lemma A.2. Let G be a graph with a valid tree-decomposition (T, Q) of width ω. Then there exists a valid
tree-decomposition (T0, Q0) of width at most ω such that |V (T 0)| ∈ O(|V (G)|).
Lemma A.3. Let G be a graph with a valid tree-decomposition (T, Q) and K ⊆ V(G) a clique of G. Then
there exists t ∈ T such that K ⊆ Qt.
A.2 Proper vs. improper learning
An important distinction is the type of solution to the ERM that we allow. In proper learning we require the
solution to satisfy φ ∈ Φ, i.e., the model has to be from the considered model class induced by Φ and takes
the form f (∙, φ*) for some φ* ∈ Ω, with
D 2 `(f( K φ*),力 ≤ m∈φ D ∑ `(f(优 φ), y i),
i=1	i=1
and this can be relaxed to -approximate (proper) learning by allowing for an additive error > 0 in the above.
In contrast, in improper learning we allow for a model g(∙), that cannot be obtained as f (∙, φ) with φ ∈ Φ,
satisfying
1D	1D
D ∑'(g( x), yi )≤ miφ D Σ'( f (xl,φ), yi),
i=1	i=1
with a similar approximate version. As we mentioned in the main body, this article considers the proper
learning setup.
13
Under review as a conference paper at ICLR 2019
A.3 Neural Networks
In a Neural Network, the graph G defining the network can be partitioned in layers. This means that
V(G) = IJk=0 Vi for some sets Vi —the layers of the network. Each vertex V ∈ Vi with i ∈ [k]o has an
associated set of in-nodes denoted by δ+(v) ⊆ V, so that (w, v) ∈ E for all w ∈ δ+(v) and an associated set of
out-nodes δ-(v) ⊆ V defined analogously. Ifi = 0, then δ+(v) are the inputs (from data) and ifi = k, then
δ-(v) are the outputs of the network. Moreover, each node v ∈ V performs a node computation gi(δ+(v)),
where gi : Rlδ+(V)I → R with i ∈ [k] is typically a smooth function (often these are linear or affine linear
functions) and then the node activation is computed as ai(gi(δ+(v))), where ai : R → R with i ∈ [k] is a
(not necessarily smooth) function (e.g., ReLU activations of the form ai(x) = max{0, x}) and the value on
all out-nodes w ∈ δ-(v) is set to ai (gi (δ+ (v))) for nodes in layer i ∈ [k]. In feed-forward networks, we can
further assume that if v ∈ Vi, then δ+(v) ⊆ ∪ij-=10Vj, i.e., all arcs move forward in the layers.
B Further discussion
Data-dependent vs. independent LPs
As mentioned before, the assumption that the construction of the LP is independent of the specific data is
important and reasonable as it basically prevents us from constructing an LP for a specific data set, which
would be akin to designing an algorithm for a specific data set in ERM problem (1). To further illustrate the
point, suppose we would do the latter, then a correct algorithm would be a simple print statement of the
optimal configuration φ. Clearly this is nonsensical and We want the algorithm to work for all types of data
sets as inputs. We have a similar requirement for the construction of the LP, with the only difference that
number of data points D has to be known at time of construction. As such LPs more closely resemble a
circuit model of computation (similar to the complexity class P/poly); see Braun et al. (2016; 2015); Braun
and Pokutta (2018+) for details.
The curious reader might still wonder how our main result changes if we allow the LPs in Theorem 3.1 to be
data-dependent, i.e., if we construct a specific linear program after we have seen the data set:
Remark B.1. To obtain a data-dependent linear program we can follow the same approach as in Section
3 and certainly produce an LP that will provide the same approximation guarantees for a fixed data set.
Moreover, since the construction of Theorem 2.5 explained in Appendix C.1 involves an enumeration over
a discretization of Φ ⊆ [-1, 1]N, one can compute the (approximately) optimal solution in advance and
solve this data-dependent ERM problem as a trivial LP with N constraints, each constraint simply fixing a
variable to a value; the analog to the print statement from above. The time needed to generate such an LP is
O((2L/)N) (the number of possible discretized configurations) via at most O((2L/)N D) evaluations of`
and f (one per each enumerated configuration and data-point).
This result is not particularly insightful, as it is based on a straight-forward enumeration which takes a
significant amount of time, considering that it only serves one data set. On the other hand, our result shows
that by including the input data as a variable, we do not induce an exponential term in the size of the data set
D and we can keep the number function evaluations to be roughly the same.
Similarities with SGD-based training
Our approach shares some similarities with stochastic gradient descent (SGD) based training: data points are
considered separately (or in small batches) and the method (in case of SGD) or the LP (in our case) ensure
that the information gained from a single data point is integrated into the overall ERM solution. In the case of
SGD this happens through sequential updates of the form Xt+ι J Xt - 〃Vf ' (Xt), where i is a random function
corresponding to a training data point (Xi, Yi) from the ERM problem. In our case, it is the LP that ‘glues
14
Under review as a conference paper at ICLR 2019
together’ solutions obtained from single training data points by means of leveraging the low treewidth. This is
reflected in the linear dependence in D in the problem formulation size.
C Missing proofs
ProofofLemma 3.1. Choose binary values 7 so as to attain the approximation for variables 羽 y, φ as in (6)
and define J^, y, φ, L from 7 according to the definition of S€(D, Φ,', f). Since
∣∣(Xd, yd, φ) -(Xd yd,倒∣∞ ≤ 2γ = L d ∈[D]
by Lipschitzness We obtain |Ld - Ld| ≤ R The result then follows.	□
Proof of Lemma 4.1. The result can be verified directly, since for a ∈ [-1, 1]w and b ∈ [-1, 1] it holds
|7Ta + b| ≤ wk7k∞ + 1.	□
Proof of Lemma 4.5. The proof follows almost directly from the proof of Corollary 4.2. The two main
differences are (1) the input dimension of a node computation, which can be at most ∆ instead of w and (2)
the fact that an activation function a with Lipchitz constant 1 and that a(0) = 0 satisfies |a(7)| ≤ |7|, thus
the domain of each node computation computed in Lemma 4.1 applies. The layer-by-layer argument can be
applied as the network is feed-forward.	□
C.1 Proof of Theorem 2.5
Let us recall the definition of BO:
(BO) : min cT X + dT y
subject to : fi(X) ≥ 0	i ∈ [m]
gj(X) = yj	j ∈ [p]
X ∈ {0, 1}n,
We sketch the proof of
Theorem 2.5. Consider an instance I of problem BO. If Γ[I] has a tree-decomposition (T, Q) of width ω,
there is an exact linear programming reformulation ofI with O (2ω (|V(T)| + p)) variables and constraints.
Proof. Since the support of each fi induces a clique in the intersection graph, there must exist a bag Q such
that supp(fi) ⊆ Q (Lemma A.3). The same holds for each gj. We modify the tree-decomposition to include
the yj variables the following way:
•	For each j ∈ [p], choose abag Q containing supp(gj) and add anew bag Q0(j) consisting of Q ∪ {yj}
and connected to Q.
•	We do this for every j ∈ [p], with a different Q0(j) for each different j. This creates a new
tree-decomposition (T0, Q0) of width at most ω + 1, which has each variable yj contained in a single
bag Q0(j) which is a leaf.
•	The size of the tree-decomposition is |T0| = |T| + p.
From here, we proceed as follows:
15
Under review as a conference paper at ICLR 2019
•	For each t ∈ T0, if Qt0 3 yj for some j ∈ [p], then we construct
Ft {(x, y) ∈ {0, 1}Qt × R : y = gj(x), fi(x) ≥ 0forsupp(fi) ⊆ Qt0}
otherwise we simply construct
Ft	{x ∈ {0, 1}Qt : fi(x) ≥ 0forsupp(fi) ⊆ Qt0}.
Note that these sets have size at most 2|Q0t |.
•	We define variables X[Y, N] where Y,N form a partition of Qt01 ∩ Qt02. These are at most 2ω |V (T 0)|.
•	For each t ∈ T0 and v ∈ Ft, we create a variable λv. These are at most 2ω |V(T 0)|.
We formulate the following linear optimization problem
(LBO) : min cTx + dTy
subject to :	λv = 1
v∈Ft
Xu, N ]=2 λv 口 Vi n(i-vi)
v∈Ft	i∈Y	i∈N
λv ≥ 0
xi
λvvi
v∈Ft
yj =	λvgj(v)
v ∈ FQ0(j)
∀t ∈ T0
∀(u, N) ⊆ Qt0, t ∈ T0
∀v ∈ Ft , t ∈ T 0
∀i ∈ Qt0 ∩ [n], t ∈ T0
∀j ∈ [p]
Note that the notation in the last constraint is justified since by construction supp(gj) ⊆ Q0(j). The proof of
the fact that LBO is equivalent to BO follows from the arguments in Bienstock and Munoz (2018). The key
difference justifying the addition of the y variables relies in the fact that they only appear in leaves of the tree
decomposition (T0, Q0), and thus in no intersection of two bags. The gluing argument using variables X[u, N]
then follows directly, as it is then only needed for the x variables to be binary.
We can substitute out the x and y variables and obtain an LP whose variables are only λv and X [u, N]. This
produces an LP with at most 2 ∙ 2ω| V(T0)∣ variables and (2 ∙ 2ω + 1)|V(T0)∣ constraints. This proves the size
of the LP is O(2ω(| V(T)| + P)) as required.	□
D Data-dependent Faces and Construction Time
D.1 Construction Time in Theorem 3.1
In this Section we show how to construct the polytope in Theorem 3.1. We first recall the following definition:
S(D, Φ,', f) = {(X1,..., XD, y1,..., yD,φ, L) ∈ [-1, i](n+m)×D × φ × RD : Ld = '(f (Xd, φ), yd)}
and recall that S (D, Φ, `, f) is a discretized version of the set mentioned above. From the tree-decomposition
detailed in Section 3.2, we see that data-dependent variables X, y, L are partitioned in different bags for each
16
Under review as a conference paper at ICLR 2019
data d ∈ [D]. Let us index the bags using d. Since all data variables have the same domain, the sets Fd
we construct in the proof of Theorem 2.5 will be the same for all d ∈ [D]. Using this observation, we can
construct the LP as follows:
1.	Fix, say, d = 1 and enumerate all binary vectors corresponding to the discretization of x1, y1, φ.
2.	Compute `( f (x1, φ), y1). This will take O((2L/)n+m+N) function evaluations of f and `. This
defines the set F1 .
3.	Duplicate this set D times, and associate each copy with a bag indexed by d ∈ [D].
4.	For each d ∈ [D], and each v ∈ Fd create a variable λv .
5.	For each d ∈ [D - 1], create variables X[Y, N] corresponding to the intersection of bags d and
d + 1. This will create O((2L/)N) variables, since the only variables in the intersections are the
discretized φ variables.
6.	Formulate LBO.
The only evaluations of ` and f are performed in the construction of F1 . As for the additional computations,
the bottleneck lies in creating all λ variables, which takes time O((2L/)n+m+N D).
Remark D.1. Note that in step 1 of the LP construction we are enumerating all possible discretized values of
x1, y1, i.e., we are implicitly assuming all points in [-1, 1]n+m are possible inputs. This is reflected in the
(2L/)n+m term in the LP size estimation. If one were to use another discretization method (or a different
“point generation” technique) using more information about the input data, this term could be improved and
the explicit exponential dependency on the input dimension of the LP size could be alleviated significantly.
However, note that in a fully-connected neural network we have N ≥ n + m and thus an implicit exponential
dependency on the input dimension could remain unless more structure is assumed. This is in line with the
NP-hardness results. We leave the full development of this potential improvement for future work.
D.2 Data-dependent faces of the data-independent polytope
Consider a fixed data set (X, Y) = (xcl, yi )3 and let φ* be an optimal solution to the ERM problem with input
data (X, Y). Consider now binary variables Zx, Zy to attain the approximation (6) and define x, y from Zx, Zy,
i.e., Xd = -1 + 2 ZNYI 2-hZXh and similarly for y. Define the set
S (X, Y, Φ,', f) = {(φ, L )∈ Φ X RD : L d ='(f (Xd, φ), yd)}
and similarly as before define S (X, Y, Φ, `, f) to be the discretized version (on variables φ). The follow-
ing Lemma shows the quality of approximation to the ERM problem obtained using S(X, Y, Φ, `, f) and
subsequently Se(X, Y, Φ,', f).
Lemma D.2. For any (φ, L) ∈ S(X, Y, Φ,', f) there exists (φ0, L0) ∈ Se(X, Y, Φ,', f) such that
D Σ Ld - D Σ Ld ≤ C
d=1	d=1
Additionally,for every φ ∈ Φ ,there exists (φ0, L0) ∈ Se (X, Y, Φ,', f) such that
1 D	1 D
DΣ`(f(Xd,φ),yd)-DΣLd ≤c
d=1	d=1
Proof. The first inequality follows from the same proof as in Lemma 3.1. For the second inequality, let φ0 be
the binary approximation to φ, and L0 defined by Ld = '(f (Xd, φ0), yd). Since X, y, φ0 are approximations to
17
Under review as a conference paper at ICLR 2019
戈,y, φ, by LiPschitzness We know that
∣'( f (J^d, φ), yd) - L d∣ = i`( f (xd, φ), yd) - `(f (xd, φ0), yd )∣
≤ 2Lγ =

Corollary D.3. Let (φ, L) defined as
1D
(φ, L) ∈ argmin — >, Ld
φ,L D d=1
s.t (φ, L )∈ S € (X, Y, φ,',f)
Then
1 D	1 D
D 2 `(f(χd, φ*), yd) - D 2 `(f(χd, Φ), yd) ≤ 2e
d=1	d=1
Proof. Since φ ∈ Φ, and φ* is a “true” optimal solution to the ERM problem, We immediately have
D 2 `(f (χd, φ*), yd )≤ D 2 `(f (χd, φ), yd)
D d=1	D d=1
On the other hand, by the previous Lemma we know there exists (φ0, L0) ∈ S (X, Y, Φ, `, f) such that
1D ≤ D J>( f (χ^ d,Φ*), yd) d=1	1D -D 2 L d d=1	
1D ≤ D J>( f (χ^ d,Φ*), yd) d=1	1D -D 2 L d d=1	(optimality of L)
1D =D J>( f (Xi yd) D d=1	1D -D J>( f (χd,Φ), yd) D d=1	
1D ≤ D J>( f (χ^ d,Φ*), yd) d=1	1D -D »( f (χd,Φ), yd) + C d=1	(Lipschitzness)
Note that since the objective is linear, the optimization problem in the previous Corollary is equivalent if
we replace S (X, Y, Φ, `, f) by its convex hull. Therefore the only missing link to the face property of the
data-independent polytope is the following:
Lemma D.4. conv(Se (X, Y, Φ,', f)) is aface of conv(Se(D, Φ,', f)).
Proof. The proof follows from simply fixing variables in the corresponding LBO that describes
conv(S (D, Φ, `, f)). For every d ∈ [D] and v ∈ Fd, we simply need to make λv = 0 whenever the (x, y)
components of v do not correspond to X, Y. We know this is well defined, since X, Y are already discretized,
thus there must be some v ∈ Fd corresponding to them.
The structure of the resulting LP is the same as LBO, so the fact that it is exactly conv(S (X, Y, Φ, `, f))
follows. The fact that it is a face of conv(S (D, Φ, `, f)) follows from the fact that the procedure simply fixed
some inequalities to be tight.
18
Under review as a conference paper at ICLR 2019
E Regularized ERM
A common practice to avoid over-fitting is the inclusion of regularizer terms in (1). This leads to problems of
the form
miΦ D S `(f( χ^,Φi yi)+λ R(0),	(9)
φ∈ D i=1
where R(∙) is a function, typically a norm, and λ > 0 is a parameter to control the strength of the regularization.
Regularization is generally used to promote generalization and discourage over-fitting of the obtained ERM
solution. The reader might notice that our arguments in Section 3 regarding the epigraph reformulation of the
ERM problem and the tree-decomposition of its intersection graph can be applied as well, since the regularizer
term does not add any extra interaction between the data-dependent variables.
The previous analysis extends immediately to the case with regularizers after appropriate modification of the
architecture Lipschitz constant L to include R(∙).
Definition E.1. Consider a regularized ERM problem (9) with parameters D, Φ, £, f, R, and λ. We define its
Architecture Lipschitz Constant L(D, Φ, £, f, R, λ) as
L(D, Φ, £, f, R, λ) ÷ L∞('(f (∙, ∙), ∙) + λR(∙))	(10)
over the domain K = [-1, 1]n × Φ × [-1, 1]m.
F ERM under Network Structure
So far we have considered general ERM problems exploiting only the structure of the ERM induced by the
finite sum formulations. We will now study ERM under Network Structure, i.e., specifically ERM problems
as they arise in the context of Neural Network training. We will see that in the case of Neural Networks, we
can exploit the sparsity of the network itself to obtain better LP formulations of conv(S (D, Φ, £, f)).
Suppose the network is defined by a graph G, and recall that in this case, Φ ⊆ [-1, 1]E(G). By using additional
auxiliary variables s representing the node computations and activations, we can describe S(D, Φ, £, f) in the
following way:
S(D, Φ, £, f) =(x1, . . .,xD,y1,. . .,yD,φ,L) ∈ [-1, 1](n+m)D × Φ× RD :
Ld = £(sk,d, yd)
svi,d = av(gv(si-1,d, φ(δ+(v))) ∀v ∈ Vi,i ∈ [k]
S0,d = xd }.
The only difference with our original description of S(D, Φ, £, f) in (5) is that we explicitly “store” node
computations in variables s. These new variables will allow us to better use the structure of G.
Assumption F.1. To apply our approach in this context we need to further assume Φ to be the class of Neural
Networks with normalized coefficients and bounded node computations. This means that we restrict to the
case when s ∈ [-1, 1] |V(G) |D.
Under Assumption F.1 we can easily derive an analog description of S (D, Φ, £, f) using this node-based
representation of S (D, Φ, £, f). In such description we also include a binary representation of the auxiliary
variables s. Let Γ be the intersection graph of such a formulation of S (D, Φ, £, f) and Γφ be the sub-graph of
Γ induced by variables φ. Using a tree-decomposition (T, Q) of Γφ we can construct a tree-decomposition of
Γ the following way:
1. We duplicate the decomposition D times (Ti, Qi)iD=1, where each (Ti, Qi) is a copy of (T, Q).
19
Under review as a conference paper at ICLR 2019
2.	We connect the trees Ti in a way that the resulting graph is a tree (e.g., they can be simply concatenated
one after the other).
3.	To each bag Qit with t ∈ Ti and i ∈ [D], we add all the data-dependent variables Ld and the
binary variables associated with the discretization of Xd, s,∙d, and yd. This adds Nγ(|V(G)| + n + m)
additional variables to each bag, as there is only one variable sper data point per vertex of G .
It is not hard to see that this is a valid tree-decomposition of Γ, of size |T| ∙ D ——since the bags were duplicated
D times— and width Nγ(tw(Γφ) + |V(G)| + n + m).
We now turn to providing a bound to tw(Γφ ). To this end we observe the following:
1.	The architecture variables φ are associated to edges of G. Moreover, two variables φe, φf , with
e, f ∈ E appear in a common constraint if and only if there is a vertex v such that e, f ∈ δ+(v).
2.	This implies that Γφ is a sub-graph of the line graph of G . Recall that the line graph of a graph G is
obtained by creating a node for each edge of G and connecting two nodes whenever the respective
edges share a common endpoint.
The treewidth of a line graph is related to the treewidth of the base graph (see Bienstock (1990); Calinescu
et al. (1998); Atserias (2008); Harvey and Wood (2018)). More specifically, tw(Γφ) ∈ O(tw(G)∆(G)) where
∆ denotes the maximum vertex degree. Addititionally, using Lemma A.2 we may assume |T| ≤ |E(G)|, since
Γφ has at most |E(G)| nodes. Putting everything together we obtain:
Lemma F.2. If there is an underlying network structure G in the ERM problem and the node computations
are bounded, then conv(S (D, Φ, `, f )) admits a linear programming formulation with no more than
(2L O O(tw(G)∆(G)+∣V (G) ∣+n+m)
2D(E(G)I + 1) E
2L O(tw(G)∆(G)+∣V(G)∣+n+m)
and D(IE(G)I + 1) 12 I—j	+ 1
variables and constraints, respectively. Moreover, given a tree-decomposition of the network G, the linear
program can be constructed in time O
(D ∣ E(G)∣ (2L/e )θ(tw(G)A(G)+∣v (G)∣+n+m)) PluS 如. required for
O (∣E(G)∣ (2L/e)°(tw(G)A(G)+ ∣v(G)∣+n+m)) evaluations of ' and f.
G Explicit Lipschitz constants of common Loss Functions
In Section 4 we specified our results ——the size of the data-independent LPs—— for feed-forward networks with
1-Lipschitz activation functions. However, We kept as a parameter L∞('); the Lipschitz constant of '(∙, ∙) over
[-Uk, Uk]m × [-1,1]m, with Uk = 2；=0 Wj a valid bound on the output of the node computations, as proved
in Lemma 4.1. Note that Uk ≤ wk+1.
In this Section we compute this Lipschitz constant for various common loss functions. It is important
to mention that we are interested in the Lipschitznes of ` with respect to both the output layer and the
data-dependent variables as well ——not a usual consideration in the literature. Note that a bound on the
Lipschitz constant L∞(') is given by supay ∣∣V'(z, y)kι.
•	Quadratic Loss `(z, y) = kz - yk22. In this case it is easy to see that
kV'(z, y)kι = 4∣∣z - ykι ≤ 4m(Uk + 1) ≤ 4m(wk+1 + 1)
•	Absolute Loss `(z, y) = k z- yk1. In this case we can directly verify that the Lipschitz constant with
respect to the infinity norm is at most 2m.
20
Under review as a conference paper at ICLR 2019
•	Cross Entropy Loss with Soft-max Layer. In this case we include the Soft-max computation in the
definition of `, therefore
m
'(z, y) = - 2 yi iog( S (Z )i)
i=1
where S(z) is the Soft-max function defined as
A folklore result is
∂'(z, y)
∂ Zi
Additionally,
S(z)i =
W=I ezj.
= S(Z)i - yi ⇒
∂'(z, y)
∂ yi
∂'( Z, y)
= - log(S(Z)i)
≤2
which in principle cannot be bounded. Nonetheless, since we are interested in the domain [-Uk, Uk]
of Z , we obtain
S(Z)i = ∑⅛7 ≥ m e-2Uk ⇒
j=1 e j m
∂'(z, y)
∂ yi
= - log(S(Z)i ) ≤ log(m) + 2Uk
which implies that L∞ (`) ≤ 2m(log(m) + 2Uk ) ≤ 2m(log(m) + 2wk+1 ).
•	Hinge Loss '(Z, y) = max{1 - ZTx, 0}. Using a similar argument as for the Quadratic Loss, one
can easily see that the Lipschitz constant with respect to the infinity norm is at most m(Uk + 1) ≤
m(wk+1 + 1).
H Binarized Neural Networks
A Binarized activation unit (BiU) is parametrized by p + 1 values b, a1, . . ., ap. Upon a binary input vector
Z1, Z2, . . . , Zp the output is binary value y defined by:
y = 1 if aTZ > b, and y = 0 otherwise.
Now suppose we form a network using BiUs, possibly using different values for the parameter p. In terms of
the training problem we have a family of (binary) vectors x1, . . . , xD in Rn and binary labels and corresponding
binary label vectors y1, . . . , yD in Rm , and as before we want to solve the ERM problem (1). Here, the
parametrization φ refers to a choice for the pair (a, b) at each unit. In the specific case of a network with 2
nodes in the first layer and 1 node in the second layer, and m = 1, Blum and Rivest (1992) showed that it is
NP-hard to train the network so as to obtain zero loss, when n = D. Moreover, the authors argued that even if
the parameters (a, b) are restricted to be in {-1, 1}, the problem remains NP-Hard. See Courbariaux et al.
(2016) for an empirically efficient training algorithm for BiUs.
In this section we apply our techniques to the ERM problem (1) to obtain an exact polynomial-size data-
independent formulation for each fixed network (but arbitrary D) when the parameters (a, b) are restricted to
be in {-1, 1}.
We begin by noticing that we can reformulate (1) using an epigraph formulation as in (4). Moreover, since
the data points in a BiU are binary, if we keep the data points as variables, the resulting linear-objective
optimization problem is a binary optimization problem as BO. This allows us to claim the following:
21
Under review as a conference paper at ICLR 2019
Theorem H.1. Consider a graph G, p ∈ N and D ∈ N. There exists a linear program of size
O(2p|V(G)|D),
such that any BiU ERM problem of the form (1) is equivalent to optimizing a linear function over a face
of P, where P is the polytope defined by the linear program. Constructing the linear program takes time
O(2p |V(G) | D) plus the time required for O(2p |V(G) |) evaluations of f and `.
Proof. The result follows from applying Theorem 2.5 directly to the epigraph formulation of BiU keeping
x and y as variables. In this case an approximation is not necessary. The construction time and the
data-independence follow along the same arguments used in the approximate setting before.
The following corollary is immediate.
Corollary H.2. The ERM problem (1) over BiUs can be solved in polynomial time for any D, whenever p
and the network structure G are fixed.
I Linear Programming-based Training Generalizes
In this section we will show that the ERM solutions obtained via Linear Programming generalize to the
General Risk Minimization problem. Here we show generalization as customary in stochastic optimization,
exploiting the Lipschitzness of the model to be trained; we refer the interested reader to Ahmed (2017);
Shapiro et al. (2009) for an in-depth discussion. In a first step, we further precise notation as required for
our analysis. To this end, recall that the General Risk Minimization (GRM) is defined as minφ ∈Φ GRM(φ)
minφ ∈Φ E(x,y)∈D [`( f (x, φ), y)], where ` is some loss function, f is a neural network architecture with
parameter space Φ, and (x, y) ∈ Rn+m drawn from the distribution D . We solve the finite sum problem,
i.e., the empirical risk minimization problem min ° ∈φ ERMχ,γ (φ) = min° ∈φ -D 2 3 '(f (Xl, φ), yl), instead,
where (X, Y) = (xi, yi )iD=1 is an i.i.d. sample from data distribution D of size D. We will show in this section,
for any 1 > α > 0, > 0, we can choose a (reasonably small!) sample size D, so that with probability 1 - α it
holds:
GRM(φ) ≤ min GRM(φ) + 66,
φ∈Φ
where φ ≤ max°∈φ ERMχ,γ(φ) + 6 isan 6-approximate solution to ERMχ,γ for i.i.d.-sampled data (X, Y)〜D.
As the size of the linear program that we use for training only linearly depends on the number of data points,
this also implies that we will have a linear program of reasonable size as a function of α and 6.
The following proposition summaries the generalization argument used in stochastic programming as presented
in Ahmed (2017) (see also Shapiro et al. (2009)):
Proposition I.1. Consider the optimization problem
min Eω ∈ω [F(X,γ(ω))],
x∈X
where γ(ω) is a random parameter with ω ∈ Ω a set of parameters, X ⊆ Rn a finite set, and F : X × Ω → R
is a function. Given i.i.d. samples γ1, . . . , γD of γ(ω), consider the finite sum problem
minɪ Y F(x,γι).	(11)
x∈X D
l∈[D ]
If X ∈ X is an 6-approximate solution to (11), i.e.,方 £ ∈[θ] F(jc, γι) ≤ minχ ∈χ -D 2 ∈[d] F(x, γι) + 6 and
D ≥ 4⅛ 区,
62	α
22
Under review as a conference paper at ICLR 2019
where a > 0 and σ2 = maxχ ∈χ Vω ∈ω [F(羽 γ(ω))], then with probability 1 - a it holds:
Eω ∈ω [F(x, γ(ω))] ≤ miX Eω∈ω [F(x, γ(ω))] + 22∙
Let σ2 = maxφ ∈Φ V(x,y) ∈D [`( f (x, φ), y)]. We will now establish generalization by means of Proposition I.1
and a straightforward discretization argument. By assumption from above Φ ⊆ [-1, 1]N for some N ∈ N. Let
Φν ⊆ Φ ⊆ [-1,1]N be a ν-net of Φ, i.e., for all φ ∈ Φ there exists φ ∈ Φν with kφ - φk∞ ≤ ν. Furthermore
let L the be architecture Lipschitz constant, as defined in (2) (or (10)).
Theorem I.2. [Generalization] Let φ ∈ Φ be an w-approximate solution to min°∈φ ERMχ,γ(φ) with e > 0,
i.e., ERMχ,γ(φ) ≤ min°∈φ ERMχ,γ(φ)	+ w. If D	≥ 好 log	"(^Lae)	，with	L and σ2 as above, then
with probability 1 - a it holds GRM(O)	≤ min° ∈φ	GRM(φ) +	6w, i.e.,	φ is a	6w-approximate solution to
minφ∈φGRM(φ).
Proof. Let φ be as above. With the choice ν	w/L, there exists φ ∈ φν, so that kφ - φk∞ ≤ ν and hence by
Lipschitzness,
| ERMχ,γ(φ)- ERMχ,γ(d)∣ ≤ w,
so that ERMχ,γ(<φ) ≤ min°∈φν ERMχ,γ(φ) + 2w. As D ≥ 誓 log (QL/)，With probability 1 - a we have
GRM(d) ≤ min° ∈φν GRM(φ) + 4w by Proposition I.1. If now Φg = argmin° ∈φ GRM(φ) and Φg ∈ Φν with
kΦg - Φgk∞ ≤ ν, by Lipschitzness we have | GRM(Φg) - GRM(Φg)| ≤ w. Now
GRM(φ) ≤ min GRM(φ) + 4w
φ∈φν
≤ GRM(AG) + 4w	(by optimality)
≤ GRM(Φg) + 5w	(by Lipschitzness).
Together with | GRM(φ) - GRM(φ) ≤ W as kφ - φk∞ ≤ V it follows
GRM(φ) ≤ GRM(Φg) + 6w = min GRM(φ) + 6w,
φ∈φ
which completes the proof.
We are ready to formulate the following corollary combining Theorem I.2 and Main Theorem 3.1.
Corollary I.3 (LP-based Training for General Risk Minimization). Let D be a data distribution as above.
Further, let 1 > α > 0 and w > 0, then there exists a linear program with the following properties:
(a)	The linear program has size O
n+m+N
log 包MN
and can be constructed in time
O ((2L∕w)n+m+N (4σ2 log (QLoe) )) plus the time required for O ((2L∕w)n+m+N) evaluations of '
and f , where L and σ2 as above.
(b)	With probability (1 - α) it holds GRM(S) ≤ min° ∈φ GRM(φ) + 6w, where φ is an optimal solution to the
linear program obtained for the respective sample of D of size 等 log ((2L/e) .
Similar corollaries hold, combining Theorem I.2 with the respective alternative statements from Section 4. Of
particular interest for what follows is the LP size in the case of a neural network with k layers with width w,
which becomes
O ((2L∞(')w3k2)∕w)n+m*卜σ2∕w2) log((2L∞(')wo(k2)∕w)N∕α)j .	(12)
23
Under review as a conference paper at ICLR 2019
A closely related result regarding an approximation to the GRM problem for neural networks is provided by
Goel et al. (2017) in the improper learning setting. The following corollary to (Goel et al., 2017, Corollary
4.5) can be directly obtained, rephrased to match our notation:
Theorem I.4 (Goel et al. (2017)). There exists an algorithm that outputs φ such that with probability 1 - α,
for any distribution D and loss function ' which is convex, L-Lipschitz in the first argument and b bounded on
[-2√w, √w], GRM(。)≤ minφ ∈φ GRM(φ) + W, where Φ is the class ofneural networks with k hidden layers,
width w, output dimension m = 1, ReLU activations and normalized weights. The algorithm runs in time at
most
n O(I) 2((L+1)wk °keT)klog(1∕α)
(13)
Remark I.5. In contrast to the above result of Goel et al. (2017), note that in our paper we consider the proper
learning setting, where we actually obtain a neural network. In addition we point out several key differences
between Theorem I.4 and the algorithmic version of our result when solving the LP in Corollary I.3 of size
as (12): (a) In (13), the dependency on the input dimension is better than in (12). (b) The dependency on
the Lipschitz constant is significantly better in (12), although we have to point out that we are relying on the
Lipschitz constant with respect to all inputs of the loss function and in a potentially larger domain. (c) The
dependency on W is also better in (12). (d) We are not assuming convexity of ` and we consider general m.
(e) The dependency on k in (12) is much more benign than the one in (13), which is doubly exponential.
Remark I.6. Since the first submission of this article, a manuscript by Manurangsi and Reichman (2018)
was published which extended the results by Goel et al. (2017). This work provides an algorithm with
similar characteristics to the one by Goel et al. (2017) but in the proper learning setting, for depth-2 ReLU
networks with convex loss functions. The running time of the algorithm (rephrased to match our notation) is
(n/α)O(I)2(w/e)O(I). Analogous to the comparison in Remark I.5, We obtain a much better dependence with
respect to W and we do not rely on convexity of the loss function or on constant depth of the neural network.
24