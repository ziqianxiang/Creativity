Figure 1:	A single 8-puzzle state as a 9x15 matrix, representing 9 objects of 15 features. The first 9features are the tile numbers and the other 6 features are the 1-hot x/y-coordinates.
Figure 2:	An example Blocksworld transition. Each state has a perturbation from the jitter in thelight positions and the ray-tracing noise. Objects have the different sizes, colors, shapes and sur-face materials. Regions corresponding to each object in the environment are extracted according tothe bounding box information included in the dataset generator output, but is ideally automaticallyextracted by object recognition methods such as YOLO (Redmon et al., 2016). Other objects mayintrude the extracted regions.
Figure 3:	The visualizations of the Blocksworld state input (left), its reconstruction (middle) andtheir pixel-wise difference (right). From the left, each three columns represent (a) the traditionalcross entropy H, (b) Set Cross Entropy SH, (c) directed set average of the cross entropy A1H and(d) the directed Hausdorff measure of the cross entropy H1H. The proposed (b) Set Cross Entropycorrectly reconstructs the input.
Figure 4:	The implementation of the encoder for feature selection, which outputs a 8 × 8 × 16 tensor.
Figure 5:	The implementation of the decoder for feature selection.
Figure 6: (Left) An example plan in a set-of-object-vector form, decoded from its binary latent rep-resentation using the permutation-invariant autoencoder (the plan is executed from top to bottom).
Figure 7: An example of a problem instance. (Left) The initial state. (Right) The goal state. Theplanner should unpolish a green cube and move the blocks to the appropriate goal position, whilealso following the environment constraint that the blocks can move or polished only when it is ontop of a stack (including the floor itself).
Figure 8: An example of a successful plan execution, returned by Latplan using the AE trainedby the proposed Set Cross Entropy method. The AE is used for encoding the object-vector inputinto a binary space that is suitable for Dijkstra search. While the problem was generated by a 7-steprandom walk from the goal state, Latplan found a shorter, optimal solution because of the underlyingoptimal search algorithm (Dijkstra).
Figure 9: The decoded solution found by Latplan for the same instance, where the AE is trained bySetAverage, which had a higher mean square error for the reconstruction. As a result, not only theinitial state is invalid, but also, at the second step, two blocks are simultaneously moved in a singleaction, which is an invalid state transition.
