Published as a conference paper at ICLR 2019
Meta-Learning Update Rules for Unsuper-
vised Representation Learning
Luke Metz
Google Brain
lmetz@google.com
Niru Maheswaranathan
Google Brain
nirum@google.com
Brian Cheung
University of California, Berkeley
bcheung@berkeley.edu
Jascha Sohl-Dickstein
Google Brain
jaschasd@google.com
Ab stract
A major goal of unsupervised learning is to discover data representations that are
useful for subsequent tasks, without access to supervised labels during training.
Typically, this involves minimizing a surrogate objective, such as the negative
log likelihood of a generative model, with the hope that representations useful
for subsequent tasks will arise as a side effect. In this work, we propose instead
to directly target later desired tasks by meta-learning an unsupervised learning
rule which leads to representations useful for those tasks. Specifically, we target
semi-supervised classification performance, and We meta-learn an algorithm -
an unsupervised weight update rule - that produces representations useful for
this task. Additionally, We constrain our unsupervised update rule to a be a
biologically-motivated, neuron-local function, which enables it to generalize to
different neural network architectures, datasets, and data modalities. We show that
the meta-learned update rule produces useful features and sometimes outperforms
existing unsupervised learning techniques. We further show that the meta-learned
unsupervised update rule generalizes to train networks with different widths, depths,
and nonlinearities. It also generalizes to train on data with randomly permuted
input dimensions and even generalizes from image datasets to a text task.
1	Introduction
Supervised learning has proven extremely effective for many problems where large amounts of
labeled training data are available. There is a common hope that unsupervised learning will prove
similarly powerful in situations where labels are expensive, impractical to collect, or where the
prediction target is unknown during training. Unsupervised learning however has yet to fulfill this
promise. One explanation for this failure is that unsupervised representation learning algorithms
are typically mismatched to the target task. Ideally, learned representations should linearly expose
high level attributes of data (e.g. object identity) and perform well in semi-supervised settings.
Many current unsupervised objectives, however, optimize for objectives such as log-likelihood of a
generative model or reconstruction error, producing useful representations only as a side effect.
Unsupervised representation learning seems uniquely suited for meta-learning (Hochreiter et al.,
2001; Schmidhuber, 1995). Unlike most tasks where meta-learning is applied, unsupervised learning
does not define an explicit objective, which makes it impossible to phrase the task as a standard
optimization problem. It is possible, however, to directly express a meta-objective that captures the
quality of representations produced by an unsupervised update rule by evaluating the usefulness
of the representation for candidate tasks. In this work, we propose to meta-learn an unsupervised
update rule by meta-training on a meta-objective that directly optimizes the utility of the unsupervised
representation. Unlike hand-designed unsupervised learning rules, this meta-objective directly targets
the usefulness of a representation generated from unlabeled data for later supervised tasks.
By recasting unsupervised representation learning as meta-learning, we treat the creation of the
unsupervised update rule as a transfer learning problem. Instead of learning transferable features,
1
Published as a conference paper at ICLR 2019
we learn a transferable learning rule which does not require access to labels and generalizes across
both data domains and neural network architectures. Although we focus on the meta-objective
of semi-supervised classification here, in principle a learning rule could be optimized to generate
representations for any subsequent task.
2	Related Work
2.1	Unsupervised Representation Learning
Unsupervised learning is a topic of broad and diverse interest. Here we briefly review several
techniques that can lead to a useful latent representation of a dataset. In contrast to our work,
each method imposes a manually defined training algorithm or loss function whereas we learn the
algorithm that creates useful representations as determined by a meta-objective.
Autoencoders (Hinton and Salakhutdinov, 2006) work by first compressing and optimizing recon-
struction loss. Extensions have been made to de-noise data (Vincent et al., 2008; 2010), as well as
compress information in an information theoretic way (Kingma and Welling, 2013). Le et al. (2011)
further explored scaling up these unsupervised methods to large image datasets.
Generative adversarial networks (Goodfellow et al., 2014) take another approach to unsupervised
feature learning. Instead of a loss function, an explicit min-max optimization is defined to learn a
generative model of a data distribution. Recent work has shown that this training procedure can
learn unsupervised features useful for few shot learning (Radford et al., 2015; Donahue et al., 2016;
Dumoulin et al., 2016).
Other techniques rely on self-supervision where labels are easily generated to create a non-trivial
‘supervised’ loss. Domain knowledge of the input is often necessary to define these losses. Noroozi
and Favaro (2016) use unscrambling jigsaw-like crops of an image. Techniques used by Misra et al.
(2016) and Sermanet et al. (2017) rely on using temporal ordering from videos.
Another approach to unsupervised learning relies on feature space design such as clustering. Coates
and Ng (2012) showed that k-means can be used for feature learning. Xie et al. (2016) jointly
learn features and cluster assignments. Bojanowski and Joulin (2017) develop a scalable technique
to cluster by predicting noise. Other techniques such as Schmidhuber (1992), Hochreiter and
Schmidhuber (1999), and Olshausen and Field (1997) define various desirable properties about
the latent representation of the input, such as predictability, complexity of encoding mapping,
independence, or sparsity, and optimize to achieve these properties.
2.2	Meta Learning
Most meta-learning algorithms consist of two levels of learning, or ‘loops’ of computation: an inner
loop, where some form of learning occurs (e.g. an optimization process), and an outer loop or meta-
training loop, which optimizes some aspect of the inner loop, parameterized by meta-parameters.
The performance of the inner loop computation for a given set of meta-parameters is quantified by
a meta-objective. Meta-training is then the process of adjusting the meta-parameters so that the
inner loop performs well on this meta-objective. Meta-learning approaches differ by the computation
performed in the inner loop, the domain, the choice of meta-parameters, and the method of optimizing
the outer loop.
Some of the earliest work in meta-learning includes work by Schmidhuber (1987), which explores
a variety of meta-learning and self-referential algorithms. Similarly to our algorithm, Bengio et al.
(1990; 1992) propose to learn a neuron local learning rule, though their approach differs in task and
problem formulation. Additionally, Runarsson and Jonsson (2000) meta-learn supervised learning
rules which mix local and global network information. A number of papers propose meta-learning
for few shot learning (Vinyals et al., 2016; Ravi and Larochelle, 2016; Mishra et al., 2017; Finn et al.,
2017; Snell et al., 2017), though these do not take advantage of unlabeled data. Others make use
of both labeled and unlabeld data (Ren et al., 2018). Hsu et al. (2018) uses a task created with no
supervision to then train few-shot detectors. Garg (2018) use meta-learning for unsupervised learning,
primarily in the context of clustering and with a small number of meta-parameters.
2
Published as a conference paper at ICLR 2019
SSed PJeMJOLΦPOIΛI φωrom
χL∣∙∙J∙] MLP(XL e a∣∙∙ ∙∙]i
xl-1。工。) MLP(Xl. θ) IOc)OO) hL-1
X1 loo.oo) MLP(XI ；⑶[oooo]hι
X0 QO'θθ) MLP(X。; 0 QOe)O) ho
=SSed PJeMXUeg= PΦUJBΦ-1
Figure 1: Left: Schematic for meta-learning an unsupervised learning algorithm. The inner loop
computation consists of iteratively applying the UnsupervisedUpdate to a base model. During meta-
training the UnsupervisedUpdate (parameterized by θ) is itself updated by gradient descent on the
MetaObjective. Right: Schematic of the base model and UnsupervisedUpdate. Unlabeled input data,
x0 , is passed through the base model, which is parameterised by W and colored green. The goal of
the UnsupervisedUpdate is to modify W to achieve a top layer representation xL which performs
well at few-shot learning. In order to train the base model, information is propagated backwards
by the UnsupervisedUpdate in a manner analogous to backprop. Unlike in backprop however, the
backward weights V are decoupled from the forward weights W . Additionally, unlike backprop,
there is no explicit error signal as there is no loss. Instead at each layer, and for each neuron, a
learning signal is injected by a meta-learned MLP parameterized by θ, with hidden state h. Weight
updates are again analogous to those in backprop, and depend on the hidden state of the pre- and post-
synaptic neurons for each weight.
To allow easy comparison against other existing approaches, we present a more extensive survey of
previous work in meta-learning in table form in Table 1, highlighting differences in choice of task,
structure of the meta-learning problem, choice of meta-architecture, and choice of domain.
To our knowledge, we are the first meta-learning approach to tackle the problem of unsupervised
representation learning, where the inner loop consists of unsupervised learning. This contrasts with
transfer learning, where a neural network is instead trained on a similar dataset, and then fine tuned or
otherwise post-processed on the target dataset. We additionally believe we are the first representation
meta-learning approach to generalize across input data modalities as well as datasets, the first to
generalize across permutation of the input dimensions, and the first to generalize across neural
network architectures (e.g. layer width, network depth, activation function).
3	Model Design
We consider a multilayer perceptron (MLP) with parameters φt as the base model. The inner loop of
our meta-learning process trains this base model via iterative application of our learned update rule.
See Figure 1 for a schematic illustration and Appendix A for a more detailed diagram.
In standard supervised learning, the ‘learned’ optimizer is stochastic gradient descent (SGD). A
supervised loss l (x, y) is associated with this model, where x is a minibatch of inputs, and y
are the corresponding labels. The parameters φt of the base model are then updated iteratively
by performing SGD using the gradient 讥∂φy ∙ ThiS supervised update rule Can be written as
φt+1 = SupervisedUpdate(φt, xt, yt; θ), where t denotes the inner-loop iteration or step. Here θ are
the meta-parameters of the optimizer, whiCh Consist of hyper-parameters suCh as learning rate and
momentum.
In this work, our learned update is a parametriC funCtion whiCh does not depend on label information,
φt+1 = UnsupervisedUpdate(φt , xt ; θ). This form of the update rule is general, it enCompasses
many unsupervised learning algorithms and all methods in SeCtion 2.1.
In traditional learning algorithms, expert knowledge or a simple hyper-parameter searCh determines
θ, whiCh Consists of a handful of meta-parameters suCh as learning rate and regularization Constants.
In Contrast, our update rule will have orders of magnitude more meta-parameters, inCluding the
3
Published as a conference paper at ICLR 2019
Method	Inner loop updates	Outer loop updates, meta-			Generalizes to
		parameters	objective	optimizer	
Hyper parameter optimization Jones (2001); Snoek et al. (2012); Bergstra et al. (2011); Bergstra and Bengio (2012)	many steps of optimization	optimization hyper- parameters	training or validation set loss	Baysian methods, random search, etc	test data from a fixed dataset
Neural architecture search Stanley and Miikkulainen (2002); Zoph and Le (2017); Baker et al. (2017); Zoph et al. (2018); Real et al. (2017)	supervised SGD training using meta-learned architecture	architecture	validation set loss	RL or evolution	test loss within similar datasets
Task-specific optimizer (eg for quadratic function identification) (Hochreiter et al., 2001)	adjustment of model weights by an LSTM	LSTM weights	task loss	-SGD	similar domain tasks
Learned optimizers Jones (2001); Maclaurin et al. (2015); Andrychowicz et al. (2016); Chen et al. (2016); Li and Malik (2017); Wichrowska et al. (2017); Bello et al. (2017)	many steps of optimization of a fixed loss function	parametric optimizer	average or final loss	SGD or RL	new loss functions (mixed success)
Prototypical networks Snell et al. (2017)	apply a feature extractor to a batch of data and use soft nearest neighbors to compute class probabilities	weights of the feature extractor	few shot performance	-SGD	new image classes within similar dataset
MAML Finn etal. (2017)	one step of SGD on training loss starting from a meta-learned network	initial weights of neural network	reward or training loss	-SGD	new goals, similar task regimes with same input domain
Evolved Policy Gradient Houthooft et al. (2018)	performing gradient descent on a learned loss	parameters of a learned loss function	reward	Evolutionary Strategies	new environment configurations, both in and not in meta-training distribution.
Few shot learning (Vinyals et al., 2016; Ravi and Larochelle, 2016; Mishra et al., 2017)	application of a recurrent model, e.g. LSTM, Wavenet.	recurrent model weights	test loss on training tasks	-SGD	new image classes within similar dataset.
Meta-unsupervised learning for clustering Garg (2018)	run clustering algorithm or evaluate binary similarity function	clustering algorithm + hy- perparameters, binary similarity function	empirical risk mini- mization	varied	new clustering or similarity measurement tasks
Learning synaptic learning rules (Bengio et al., 1990; 1992)	run a synapse-local learning rule	parametric learning rule	supervised loss, or similarity to biologically- motivated network	gradient descent, simulated annealing, genetic algorithms	similar domain tasks
Our work — metalearning for unsupervised representation learning	many applications of an unsupervised update rule	parametric update rule	few shot classifica- tion after unsuper- vised pre- training	-SGD	new base models (width, depth, nonlinearity), new datasets, new data modalities
Table 1: A comparison of published meta-learning approaches.
4
Published as a conference paper at ICLR 2019
weights of a neural network. We train these meta-parameters by performing SGD on the sum of the
MetaObjective over the course of (inner loop) training in order to find optimal parameters θ*,
θ = argmin WtaSk
θ
MetaObjective(φt) ,
t
(1)
that minimize the meta-objective over a distribution of training tasks. Note that φt is a function of θ
since θ affects the optimization trajectory.
In the following sections, we briefly review the main components of this model: the base model,
the UnsupervisedUpdate, and the MetaObjective. See the Appendix for a complete specification.
Additionally, code and meta-trained parameters θ for our meta-learned UnsupervisedUpdate is
available1.
3.1	Base model
Our base model consists of a standard fully connected multi-layer perceptron (MLP), with batch
normalization (Ioffe and Szegedy, 2015), and ReLU nonlinearities. We chose this as opposed to a
convolutional model to limit the inductive bias of convolutions in favor of learned behavior from
the UnsupervisedUpdate. We call the pre-nonlinearity activations z1,…，zL, and post-nonlinearity
activations χ0,…，xL, where L is the total number of layers, and χ0 ≡ X is the network input (raw
data). The parameters are φ = {W 1, b1, V 1, •…，WL, bL, VL}, where Wl and bl are the weights
and biases (applied after batch norm) for layer l, and Vl are the corresponding weights used in the
backward pass.
3.2	Learned update rule
We wish for our update rule to generalize across architectures with different widths, depths, or
even network topologies. To achieve this, we design our update rule to be neuron-local, so that
updates are a function of pre- and post- synaptic neurons in the base model, and are defined for
any base model architecture. This has the added benefit that it makes the weight updates more
similar to synaptic updates in biological neurons, which depend almost exclusively on local pre- and
post-synaptic neuronal activity (Whittington and Bogacz, 2017). In practice, we relax this constraint
and incorporate some cross neuron information to decorrelate neurons (see Appendix G.5 for more
information).
To build these updates, each neuron i in every layer l in the base model has an MLP, referred to
as an update network, associated with it, with output hlbi = MLP xlbi, zbil, V l+1, δl+1; θ where
b indexes the training minibatch. The inputs to the MLP are the feedforward activations (xl & zl)
defined above, and feedback weights and an error signal (Vl and δl, respectively) which are defined
below.
All update networks share meta-parameters θ. Evaluating the statistics of unit activation over a batch
of data has proven helpful in supervised learning (Ioffe and Szegedy, 2015). It has similarly proven
helpful in hand-designed unsupervised learning rules, such as sparse coding and clustering. We
therefore allow hlbi to accumulate statistics across examples in each training minibatch.
During an unsupervised training step, the base model is first run in a standard feed-forward fashion,
populating xlbi, zbli. As in supervised learning, an error signal δbli is then propagated backwards
through the network. Unlike in supervised backprop, however, this error signal is generated by the
corresponding update network for each unit. It is read out by linear projection of the per-neuron
hidden state h, δbli = lin hlbi , and propogated backward using a set of learned ‘backward weights’
(Vl)T, rather than the transpose of the forward weights (Wl)T as would be the case in backprop
(diagrammed in Figure 1). This is done to be more biologically plausible (Lillicrap et al., 2016).
Again as in supervised learning, the weight updates (∆Wl) are a product of pre- and post-synaptic sig-
nals. Unlike in supervised learning however, these signals are generated using the per-neuron update
1https://github.com/tensorflow/models/tree/master/research/learning_
unsupervised_learning
5
Published as a conference paper at ICLR 2019
networks: ∆Wilj = func hlbi, hlb-j 1, Wij . The full weight update (which involves normalization
and decorrelation across neurons) is defined in Appendix G.5.
3.3	Meta-objective
The meta-objective determines the quality of the unsupervised representations. In order to meta-train
via SGD, this loss must be differentiable. The meta-objective we use in this work is based on fitting a
linear regression to labeled examples with a small number of data points. In order to encourage the
learning of features that generalize well, we estimate the linear regression weights on one minibatch
{xa, ya} ofK data points, and evaluate the classification performance on a second minibatch {xb, yb}
also with K datapoints,
V = argmin (Ilya — VTxL∣∣2 + λ ||v『),	MetaObjective(∙; φ) = CosDist (yb,VTXL) ,	(2)
v
where xaL , xbL are features extracted from the base model on data xa , xb, respectively. The target
labels ya, yb consist of one hot encoded labels and potentially also regression targets from data
augmentation (e.g. rotation angle, see Section 4.2). We found that using a cosine distance, CosDist,
rather than unnormalized squared error improved stability. Note this meta-objective is only used
during meta-training and not used when applying the learned update rule. The inner loop computation
is performed without labels via the UnsupervisedUpdate.
4	Training the Update Rule
4.1	Approximate Gradient Based Training
We choose to meta-optimize via SGD as opposed to reinforcement learning or other black box
methods, due to the superior convergence properties of SGD in high dimensions, and the high
dimensional nature of θ. Training and computing derivatives through long recurrent computation
of this form is notoriously difficult (Pascanu et al., 2013). To improve stability and reduce the
computational cost We approximate the gradients d[MetaO；jective] via truncated backprop through time
(Shaban et al., 2018). Many additional design choices were also crucial to achieving stability and
convergence in meta-learning, including the use of batch norm, and restricting the norm of the
UnsupervisedUpdate update step (a full discussion of these and other choices is in Appendix B).
4.2	Meta-training Distribution and Generalization
Generalization in our learned optimizer comes from both the form of the UnsupervisedUpdate
(Section 3.2), and from the meta-training distribution. Our meta-training distribution is composed of
both datasets and base model architectures.
We construct a set of training tasks consisting of CIFAR10 (Krizhevsky and Hinton, 2009) and
multi-class classification from subsets of classes from Imagenet (Russakovsky et al., 2015) as Well
as from a dataset consisting of rendered fonts (Appendix H.1.1). We find that increased training
dataset variation actually improves the meta-optimization process. To reduce computation We restrict
the input data to 16x16 pixels or less during meta-training, and resize all datasets accordingly.
For evaluation, We use MNIST (LeCun et al., 1998), Fashion MNIST (Xiao et al., 2017), IMDB
(Maas et al., 2011), and a hold-out set of Imagenet classes. We additionally sample the base model
architecture. We sample number of layers uniformly betWeen 2-5 and the number of units per layer
logarithmically betWeen 64 to 512.
As part of preprocessing, We permute all inputs along the feature dimension, so that the
UnsupervisedUpdate must learn a permutation invariant learning rule. Unlike other Work, We focus
explicitly on learning a learning algorithm as opposed to the discovery of fixed feature extractors that
generalize across similar tasks. This makes the learning task much harder, as the UnsupervisedUpdate
has to discover the relationship betWeen pixels based solely on their joint statistics, and cannot “cheat”
and memorize pixel identity. To provide further dataset variation, We additionally augment the data
With shifts, rotations, and noise. We add these augmentation coefficients as additional regression
targets for the meta-objective-e.g. rotate the image and predict the rotation angle as well as the image
class. For additional details, see Appendix H.1.1.
6
Published as a conference paper at ICLR 2019
4.3	Distributed Implementation
We implement the above models in distributed TensorFlow (Abadi et al., 2016). Training uses 512
workers, each of which performs a sequence of partial unrolls of the inner loop UnsupervisedUpdate,
and computes gradients of the meta-objeCtive asynchronously. Training takes ~8 days, and consists
of ~200 thousand updates to θ with minibatch size 256. Additional details are in Appendix C.
5	Experimental Results
First, we examine limitations of existing unsupervised and meta learning methods. Then, we show
meta-training and generalization properties of our learned optimizer and finally we conclude by
visualizing how our learned update rule works. For details of the experimental setup, see Appendix
H.
5.1	Objective Function Mismatch and Existing Meta-Learning Methods
To illustrate the negative consequences of objective function mismatch in unsupervised learnin al-
gorithms, we train a variational autoencoder on 16x16 CIFAR10. Over the course of training we
evaluate classification performance from few shot classification using the learned latent representa-
tions. Training curves can be seen in Figure 2. Despite continuing to improve the VAE objective
throughout training (not shown here), the classification accuracy decreases sharply later in training.
To demonstrate the reduced generalization that results from learning transferable features rather than
an update algorithm, we train a prototypical network (Snell et al., 2017) with and without the input
shuffling described in Section 4.2. As the prototypical network primarily learns transferrable features,
performance is significantly hampered by input shuffling. Results are in Figure 2.
Training Steps
k-shot Image Classification
(Prototypical Networks)
Number of examples per class (k)
Figure 2: Left: Standard unsupervised learning approaches suffer from objective function missmatch.
Continuing to optimize a variational auto-encoder (VAE) hurts few-shot accuracy after some number
of steps (dashed line). Right: Prototypical networks transfer features rather than a learning algorithm,
and perform poorly if tasks don’t have consistent data structure. Training a prototypical network with
a fully connected architecture (same as our base model) on a MiniImagenet 10-way classification task
with either intact inputs (light purple) or by permuting the pixels before every training and testing task
(dark purple). Performance with permuted inputs is greatly reduced (gray line). Our performance is
invariant to pixel permutation.
5.2	Meta-Optimization
While training, we monitor a rolling average of the meta-objective averaged across all datasets, model
architectures, and the number of unrolling steps performed. In Figure 3 the training loss is continuing
to decrease after 200 hours of training, which suggests that the approximate training techniques still
produce effective learning. In addition to this global number, we measure performance obtained by
rolling out the UnsupervisedUpdate on various meta-training and meta-testing datasets. We see that
on held out image datasets, such as MNIST and Fashion Mnist, the evaluation loss is still decreasing.
However, for datasets in a different domain, such as IMDB sentiment prediction (Maas et al., 2011),
we start to see meta-overfitting. For all remaining experimental results, unless otherwise stated, we
use meta-parameters, θ, for the UnsupervisedUpdate resulting from 200 hours of meta-training.
7
Published as a conference paper at ICLR 2019
211111111
3>lo2qo,elφIΛI
2 LIoo
①>10&q0—Bl ① ∣Λ∣
Hours
Figure 3: Training curves for the training and evaluation task distributions. Our train set consists
of MiniImagenet, Alphabet, and MiniCIFAR. Our test sets are Mini Imagenet Test, Tiny Fashion
MNIST, Tiny MNIST and IMDB. Error bars denote standard deviation of evaluations with a fixed
window of samples evaluated from a single model. Dashed line at 200 hours indicates model used for
remaining experiments unless otherwise stated. For a bigger version of this figure, see Appendix E.
5.3	Generalization
The goal of this work is to learn a general purpose unsupervised representation learning algorithm.
As such, this algorithm must be able to generalize across a wide range of scenarios, including tasks
that are not sampled i.i.d. from the meta-training distribution. In the following sections, we explore a
subset of the factors we seek to generalize over.
Generalizing over datasets and domains
In Figure 4, we compare performance on few shot classification with 10 examples per class. We
evaluate test performance on holdout datasets of MNIST and Fashion MNIST at 2 resolutions: 14×14
and 28×28 (larger than any dataset experienced in meta-training). On the same base model archi-
tecture, our learned UnsupervisedUpdate leads to performance better than a variational autoencoder,
supervised learning on the labeled examples, and random initialization with trained readout layer.
0.8
S'0-6
≡
8 0∙4
<
0.2
0.0
TinyMnist
TinyFashionMnist
Mnist FashionMnist

30 hours
200 hours
0	1000	2000	3000	4000	5000
Training Steps
Figure 4: Left: The learned UnsupervisedUpdate generalizes to unseen datasets. Our learned
update rule produces representations more suitable for few shot classification than those from random
initialization or a variational autoecoder and outperforms fully supervised learning on the same
labeled examples. Error bars show standard error. Right: Early in meta-training (purple), the
UnsupervisedUpdate is able to learn useful features on a 2 way text classification data set, IMDB,
despite being meta-trained only from image datasets. Later in meta-training (red) performance drops
due to the domain mismatch. We show inner-loop training, consisting of 5k applications of the
UnsupervisedUpdate evaluating the MetaObjective each iteration. Error bars show standard error
across 10 runs.
To further explore generalization limits, we test our learned optimizer on data from a vastly different
domain. We train on a binary text classification dataset: IMDB movie reviews (Maas et al., 2011),
encoded by computing a bag of words with 1K words. We evaluate using a model 30 hours and 200
hours into meta-training (see Figure 4). Despite being trained exclusively on image datasets, the 30
hour learned optimizer improves upon the random initialization by almost 10%. When meta-training
for longer, however, the learned optimizer “meta-overfits” to the image domain resulting in poor
performance. This performance is quite low in an absolute sense, for this task. Nevertheless, we find
8
Published as a conference paper at ICLR 2019
this result very exciting as we are unaware of any work showing this kind of transfer of learned rules
from images to text.
Generalizing over network architectures
We train models of varying depths and unit counts with our learned optimizer and compare results
at different points in training (Figure 5). We find that despite only training on networks with 2 to 5
layers and 64 to 512 units per layer, the learned rule generalizes to 11 layers and 10,000 units per
layer.
Aoe∙lnoQ41" UW 寸 LXbL
I	I	I	I	Γ-
2 4	6	8 10
Number of Layers
Figure 5: Left: The learned UnsUPervisedUPdate is capable of optimizing base models with hidden
sizes and depths outside the meta-training regime. As We increase the number of units per layer, the
learned model can make use of this additional capacity despite never having experienced it during
meta-training. Right: The learned UnsupervisedUpdate generalizes across many different activation
functions not seen in training. We show accuracy over the course of training on 14x14 MNIST.
Next we look at generalization over different activation functions. We apply our learned optimizer
on base models with a variety of different activation functions. Performance evaluated at different
points in training (Figure 5). Despite training only on ReLU activations, our learned optimizer is able
to improve on random initializations in all cases. For certain activations, leaky ReLU (Maas et al.,
2013) and Swish (Ramachandran et al., 2017), there is little to no decrease in performance. Another
interesting case is the step activation function. These activations are traditionally challenging to train
as there is no useful gradient signal. Despite this, our learned UnsupervisedUpdate is capable of
optimizing as it does not use base model gradients, and achieves performance double that of random
initialization.
5.4	How it Learns and How it Learns to Learn
To analyze how our learned optimizer functions, we analyze the first layer filters over the course
of meta-training. Despite the permutation invariant nature of our data (enforced by shuffling input
image pixels before each unsupervised training run), the base model learns features such as those
shown in Figure 6, which appear template-like for MNIST, and local-feature-like for CIFAR10.
Early in training, there are coarse features, and a lot of noise. As the meta-training progresses, more
interesting and local features emerge.
In an effort to understand what our algorithm learns to do, we fed it data from the two moons dataset.
We find that despite being a 2D dataset, dissimilar from the image datasets used in meta-training, the
learned model is still capable of manipulating and partially separating the data manifold in a purely
unsupervised manner (Figure 6). We also find that almost all the variance in the embedding space is
dominated by a few dimensions. As a comparison, we do the same analysis on MNIST. In this setting,
the explained variance is spread out over more of the principal components. This makes sense as the
generative process contains many more latent dimensions - at least enough to express the 10 digits.
9
Published as a conference paper at ICLR 2019
Figure 6: Left: From left to right we show first layer base model receptive fields produced by
our learned UnsupervisedUpdate rule over the course of meta-training. Each pane consists of first
layer filters extracted from φ after 10k applications of UnsupervisedUpdate on MNIST (top) and
CIFAR10 (bottom). For MNIST, the optimizer learns image-template-like features. For CIFAR10,
low frequency features evolve into higher frequency and more spatially localized features. For
more filters, see Appendix D. Center: Visualization of learned representations before (left) and
after (right) training a base model with our learned UnsupervisedUpdate for two moons (top) and
MNIST (bottom). The UnsupervisedUpdate is capable of manipulating the data manifold, without
access to labels, to separate the data classes. Visualization shows a projection of the 32-dimensional
representation of the base network onto the top three principal components. Right: Cumulative
variance explained using principal components analysis (PCA) on the learned representations. The
representation for two moons data (red) is much lower dimensional than MNIST (blue), although
both occupy a fraction of the full 32-dimensional space.
6	Discussion
In this work we meta-learn an unsupervised representation learning update rule. We show performance
that matches or exceeds existing unsupervised learning on held out tasks. Additionally, the update rule
can train models of varying widths, depths, and activation functions. More broadly, we demonstrate an
application of meta-learning for learning complex optimization tasks where no objective is explicitly
defined. Analogously to how increased data and compute have powered supervised learning, we
believe this work is a proof of principle that the same can be done with algorithm design-replacing
hand designed techniques with architectures designed for learning and learned from data via meta-
learning.
Acknowledgments
We would like to thank Samy Bengio, David Dohan, Keren Gu, Gamaleldin Elsayed, C. Daniel
Freeman, Sam Greydanus, Nando de Freitas, Ross Goroshin, Ishaan Gulrajani, Eric Jang, Hugo
Larochelle, Jeremy Nixon, Esteban Real, Suharsh Sivakumar, Pavel Sountsov, Alex Toshev, George
Tucker, Hoang Trieu Trinh, Olga Wichrowska, Lechao Xiao, Zongheng Yang, Jiaqi Zhai and the rest
of the Google Brain team for extremely helpful conversations and feedback on this work.
10
Published as a conference paper at ICLR 2019
References
Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent. In
International Conference on Artificial Neural Networks, pages 87-94. Springer, 2001.
Juergen Schmidhuber. On learning how to learn learning strategies. 1995.
Geoffrey E Hinton and Ruslan R Salakhutdinov. Reducing the dimensionality of data with neural networks.
science, 313(5786):504-507, 2006.
Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol. Extracting and composing
robust features with denoising autoencoders. In Proceedings of the 25th international conference on Machine
learning, pages 1096-1103. ACM, 2008.
Pascal Vincent, Hugo Larochelle, Isabelle Lajoie, Yoshua Bengio, and Pierre-Antoine Manzagol. Stacked
denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion.
Journal of Machine Learning Research, 11(Dec):3371-3408, 2010.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.
Quoc V Le, Marc’Aurelio Ranzato, Rajat Monga, Matthieu Devin, Kai Chen, Greg S Corrado, Jeff Dean,
and Andrew Y Ng. Building high-level features using large scale unsupervised learning. arXiv preprint
arXiv:1112.6209, 2011.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron
Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural information processing
systems, pages 2672-2680, 2014.
Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep convolutional
generative adversarial networks. arXiv preprint arXiv:1511.06434, 2015.
Jeff Donahue, Philipp Krahenbuhl, and Trevor Darrell. Adversarial feature learning. arXiv preprint
arXiv:1605.09782, 2016.
Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Alex Lamb, Martin Arjovsky, Olivier Mastropietro, and Aaron
Courville. Adversarially learned inference. arXiv preprint arXiv:1606.00704, 2016.
Mehdi Noroozi and Paolo Favaro. Unsupervised learning of visual representations by solving jigsaw puzzles. In
European Conference on Computer Vision, pages 69-84. Springer, 2016.
Ishan Misra, C Lawrence Zitnick, and Martial Hebert. Shuffle and learn: unsupervised learning using temporal
order verification. In European Conference on Computer Vision, pages 527-544. Springer, 2016.
Pierre Sermanet, Corey Lynch, Jasmine Hsu, and Sergey Levine. Time-contrastive networks: Self-supervised
learning from multi-view observation. arXiv preprint arXiv:1704.06888, 2017.
Adam Coates and Andrew Y Ng. Learning feature representations with k-means. In Neural networks: Tricks of
the trade, pages 561-580. Springer, 2012.
Junyuan Xie, Ross Girshick, and Ali Farhadi. Unsupervised deep embedding for clustering analysis. In
International conference on machine learning, pages 478-487, 2016.
Piotr Bojanowski and Armand Joulin. Unsupervised learning by predicting noise. arXiv preprint
arXiv:1704.05310, 2017.
Jurgen Schmidhuber. Learning factorial codes by predictability minimization. Neural Computation, 4(6):
863-879, 1992.
Sepp Hochreiter and Jurgen Schmidhuber. Feature extraction through lococode. Neural Computation, 11(3):
679-714, 1999.
Bruno A Olshausen and David J Field. Sparse coding with an overcomplete basis set: A strategy employed by
v1? Vision research, 37(23):3311-3325, 1997.
Jurgen Schmidhuber. Evolutionary principles in self-referential learning, or on learning how to learn: the
meta-meta-... hook. PhD thesis, Technische Universitat Munchen, 1987.
Yoshua Bengio, Samy Bengio, and Jocelyn Cloutier. Learning a SynaPtic learning rule. UniVerSit6 de Montreal,
DCpartement d,informatique et de recherche op6rationnelle, 1990.
11
Published as a conference paper at ICLR 2019
Samy Bengio, Yoshua Bengio, Jocelyn Cloutier, and Jan Gecsei. On the optimization of a synaptic learning rule.
In Preprints Conf. Optimality in Artificial and Biological Neural Networks, pages 6-8. Univ. of Texas, 1992.
Thomas Philip Runarsson and Magnus Thor Jonsson. Evolution and design of distributed learning rules. In
Combinations of Evolutionary Computation and Neural Networks, 2000 IEEE Symposium on, pages 59-63.
IEEE, 2000.
Oriol Vinyals, Charles Blundell, Tim Lillicrap, koray kavukcuoglu, and Daan Wierstra. Matching networks for
one shot learning. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett, editors, Advances in
Neural Information Processing Systems 29, pages 3630-3638. Curran Associates, Inc., 2016. URL http://
papers.nips.cc/paper/6385- matching- networks- for- one- shot- learning.pdf.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. International Conference on
Learning Representations, 2016.
Nikhil Mishra, Mostafa Rohaninejad, Xi Chen, and Pieter Abbeel. Meta-learning with temporal convolutions.
arXiv preprint arXiv:1707.03141, 2017.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep
networks. In Doina Precup and Yee Whye Teh, editors, Proceedings of the 34th International Conference on
Machine Learning, volume 70 of Proceedings of Machine Learning Research, pages 1126-1135, International
Convention Centre, Sydney, Australia, 06-11 Aug 2017. PMLR. URL http://proceedings.mlr.
press/v70/finn17a.html.
Jake Snell, Kevin Swersky, and Richard Zemel. Prototypical networks for few-shot learning. In Advances in
Neural Information Processing Systems, pages 4080-4090, 2017.
Mengye Ren, Eleni Triantafillou, Sachin Ravi, Jake Snell, Kevin Swersky, Joshua B Tenenbaum, Hugo
Larochelle, and Richard S Zemel. Meta-learning for semi-supervised few-shot classification. arXiv preprint
arXiv:1803.00676, 2018.
Kyle Hsu, Sergey Levine, and Chelsea Finn. Unsupervised learning via meta-learning. arXiv preprint
arXiv:1810.02334, 2018.
Vikas Garg. Supervising unsupervised learning. In Advances in Neural Information Processing Systems, pages
4996-5006, 2018.
Donald R Jones. A taxonomy of global optimization methods based on response surfaces. Journal of global
optimization, 21(4):345-383, 2001.
Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine learning
algorithms. In Advances in neural information processing systems, pages 2951-2959, 2012.
James S Bergstra, R6mi Bardenet, YOshua Bengio, and Balgzs K6gl. Algorithms for hyper-parameter optimization.
In Advances in neural information processing systems, pages 2546-2554, 2011.
James Bergstra and Yoshua Bengio. Random search for hyper-parameter optimization. Journal of Machine
Learning Research, 13(Feb):281-305, 2012.
Kenneth O Stanley and Risto Miikkulainen. Evolving neural networks through augmenting topologies. Evolu-
tionary computation, 10(2):99-127, 2002.
Barret Zoph and Quoc V. Le. Neural architecture search with reinforcement learning. International Conference
on Learning Representations, 2017. URL https://arxiv.org/abs/1611.01578.
Bowen Baker, Otkrist Gupta, Nikhil Naik, and Ramesh Raskar. Designing neural network architectures using
reinforcement learning. International Conference on Learning Representations, 2017.
Barret Zoph, Vijay Vasudevan, Jonathon Shlens, and Quoc V Le. Learning transferable architectures for scalable
image recognition. Proceedings of the IEEE conference on computer vision and pattern recognition, 2018.
Esteban Real, Sherry Moore, Andrew Selle, Saurabh Saxena, Yutaka Leon Suematsu, Quoc Le, and Alex
Kurakin. Large-scale evolution of image classifiers. arXiv preprint arXiv:1703.01041, 2017.
Dougal Maclaurin, David Duvenaud, and Ryan Adams. Gradient-based hyperparameter optimization through
reversible learning. In International Conference on Machine Learning, pages 2113-2122, 2015.
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, and Nando
de Freitas. Learning to learn by gradient descent by gradient descent. In Advances in Neural Information
Processing Systems, pages 3981-3989, 2016.
12
Published as a conference paper at ICLR 2019
Yutian Chen, Matthew W Hoffman, Sergio G6mez Colmenarejo, Misha Denil, Timothy P Lillicrap, Matt
Botvinick, and Nando de Freitas. Learning to learn without gradient descent by gradient descent. arXiv
preprint arXiv:1611.03824, 2016.
Ke Li and Jitendra Malik. Learning to optimize. International Conference on Learning Representations, 2017.
Olga Wichrowska, Niru Maheswaranathan, Matthew W Hoffman, Sergio Gomez Colmenarejo, Misha Denil,
Nando de Freitas, and Jascha Sohl-Dickstein. Learned optimizers that scale and generalize. International
Conference on Machine Learning, 2017.
Irwan Bello, Barret Zoph, Vijay Vasudevan, and Quoc Le. Neural optimizer search with reinforcement learning.
2017. URL https://arxiv.org/pdf/1709.07417.pdf.
Rein Houthooft, Richard Y Chen, Phillip Isola, Bradly C Stadie, Filip Wolski, Jonathan Ho, and Pieter Abbeel.
Evolved policy gradients. arXiv preprint arXiv:1802.04821, 2018.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing
internal covariate shift. In Francis Bach and David Blei, editors, Proceedings of the 32nd International
Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pages 448-456,
Lille, France, 07-09 Jul 2015. PMLR. URL http://Proceedings.mlr.press∕v37∕ioffe15.
html.
James CR Whittington and Rafal Bogacz. An approximation of the error backpropagation algorithm in a
predictive coding network with local hebbian synaptic plasticity. Neural computation, 29(5):1229-1262,
2017.
Timothy P Lillicrap, Daniel Cownden, Douglas B Tweed, and Colin J Akerman. Random synaptic feedback
weights support error backpropagation for deep learning. Nature communications, 7:13276, 2016.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural networks. In
International Conference on Machine Learning, pages 1310-1318, 2013.
Amirreza Shaban, Ching-An Cheng, Nathan Hatch, and Byron Boots. Truncated back-propagation for bilevel
optimization. arXiv preprint arXiv:1810.10667, 2018.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej
Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. ImageNet Large Scale
Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 115(3):211-252, 2015. doi:
10.1007/s11263-015-0816-y.
Yann LeCun, L6on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
Han Xiao, Kashif Rasul, and Roland Vollgraf. Fashion-mnist: a novel image dataset for benchmarking machine
learning algorithms, 2017.
Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts.
Learning word vectors for sentiment analysis. In Proceedings of the 49th Annual Meeting of the Association
for Computational Linguistics: Human Language Technologies, pages 142-150, Portland, Oregon, USA,
June 2011. Association for Computational Linguistics. URL http://www.aclweb.org/anthology/
P11-1015.
Martin Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay
Ghemawat, Geoffrey Irving, Michael Isard, et al. Tensorflow: A system for large-scale machine learning. In
OSDI, volume 16, pages 265-283, 2016.
Andrew L Maas, Awni Y Hannun, and Andrew Y Ng. Rectifier nonlinearities improve neural network acoustic
models. In Proc. icml, volume 30, page 3, 2013.
Prajit Ramachandran, Barret Zoph, and Quoc Le. Searching for activation functions. 2017.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. Understanding the exploding gradient problem. CoRR,
abs/1211.5063, 2012.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980,
2014.
13
Published as a conference paper at ICLR 2019
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and
Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.
Barak Pearlmutter. An investigation of the gradient descent process in neural networks. PhD thesis, Carnegie
Mellon University Pittsburgh, PA, 1996.
Samuel S Schoenholz, Justin Gilmer, Surya Ganguli, and Jascha Sohl-Dickstein. Deep information propagation.
arXiv preprint arXiv:1611.01232, 2016.
14
Published as a conference paper at ICLR 2019
A More Detailed System Diagram
a.) Meta-Training / Outer Loop
IVPψT∣ .…- →[]Γ]_SGD
________一 一
b.) Meta-Objective Calculation
θt+1
θt
r
φ1
MetaObjeCtive(Φ, Labeled Data)
UnsUPerVisedUPdate( ∙ ; θ)
—铲14+i L
口 ∂[MetaObjective]
ɪʃ ∂θ
φT
F
Φ φt
φo →
Activations
e.) Parameterization of the Weight Updates
Neural Network
Upper Error
SignaI
Other
'PΦ7P
δ1

Figure App.1: Schematic for meta-learning an unsupervised learning algorithm. We show the hi-
erarchical nature of both the meta-training procedure and update rule. a) Meta-training, where
the meta-parameters, θ, are updated via our meta-optimizer (SGD). b) The gradients of the
MetaObjective with respect to θ are computed by backpropagation through the unrolled application
of the UnsupervisedUpdate. c) UnsupervisedUpdate updates the base model parameters (φ) using
a minibatch of unlabeled data. d) Each application of UnsupervisedUpdate involves computing a
forward and “backward” pass through the base model. The base model itself is a fully connected
network producing hidden states xl for each layer l. The “backward” pass through the base model
uses an error signal from the layer above, δ, which is generated by a meta-learned function. e.) The
weight updates ∆φ are computed using a convolutional network, using δ and x from the pre- and
post-synaptic neurons, along with several other terms discussed in the text.
B Stabilizing gradient based meta-learning training
Training and computing derivatives through recurrent computation of this form is notoriously difficult
Pascanu et al. (2013). Training parameters of recurrent systems in general can lead to chaos. We
used the usual techniques such as gradient clipping (Pascanu et al., 2012), small learning rates, and
adaptive learning rate methods (in our case Adam (Kingma and Ba, 2014)), but in practice this
15
Published as a conference paper at ICLR 2019
was not enough to train most UnsupervisedUpdate architectures. In this section we address other
techniques needed for stable convergence.
When training with truncated backprop the problem shifts from pure optimization to something
more like optimizing on a Markov Decision Process where the state space is the base-model weights,
φ, and the ‘policy’ is the learned optimizer. While traversing these states, the policy is constantly
meta-optimized and changing, thus changing the distribution of states the optimizer reaches. This
type of non-i.i.d training has been discussed at great length with respect to on and off-policy RL
training algorithms (Mnih et al., 2013). Other works cast optimizer meta-learning as RL (Li and
Malik, 2017) for this very reason, at a large cost in terms of gradient variance. In this work, we
partially address this issue by training a large number of workers in parallel, to always maintain a
diverse set of states when computing gradients.
For similar reasons, the number of steps per truncation, and the total number of unsupervised training
steps, are both sampled in an attempt to limit the bias introduced by truncation.
We found restricting the maximum inner loop step size to be crucial for stability. Pearlmutter (1996)
studied the effect of learning rates with respect to the stability of optimization and showed that as the
learning rate increases gradients become chaotic. This effect was later demonstrated with respect to
neural network training in Maclaurin et al. (2015). If learning rates are not constrained, we found that
they rapidly grew and entered this chaotic regime.
Another technique we found useful in addressing these problems is the use of batch norm in both
the base model and in the UnsupervisedUpdate rule. Multi-layer perceptron training traditionally
requires very precise weight initialization for learning to occur. Poorly scaled initialization can make
learning impossible (Schoenholz et al., 2016). When applying a learned optimizer, especially early in
meta-training of the learned optimizer, it is very easy for the learned optimizer to cause high variance
weights in the base model, after which recovery is difficult. Batch norm helps solve this issues by
making more of the weight space usable.
C Distributed Implementation
We implement the described models in distributed Tensorflow (Abadi et al., 2016). We construct a
cluster of 512 workers, each of which computes gradients of the meta-objective asynchronously. Each
worker trains on one task by first sampling a dataset, architecture, and a number of training steps.
Next, each worker samples k unrolling steps, does k applications of the UnsupervisedUpdate(∙; θ),
computes the MetaObjective on each new state, computes d[MetaObjeCtive] and sends this gradient to a
parameter server. The final base-model state, φ, is then used as the starting point for the next unroll
until the specified number of steps is reached. These gradients from different workers are batched
and θ is updated with asynchronous SGD. By batching gradients as workers complete unrolls, we
eliminate most gradient staleness while retaining the compute efficiency of asynchronous workers,
especially given heterogeneous workloads which arise from dataset and model size variation. An
overview of our training can be seen in algorithm F. Due to the small base models and the sequential
nature of our compute workloads, we use multi core CPUs as opposed to GPUs. Training occurs over
the course of ~8 days with ~200 thousand updates to θ with minibatch size 256.
16
Published as a conference paper at ICLR 2019
D More Filters Over Meta-Training
Figure App.2: More filters extracted over the course of meta-training. Note, due to implementation
reasons, the columns do not represent the same point / same iteration of θ . Each filter is extracted
after 10k inner loop optimization steps, at φ10k. From top to bottom we show: MNIST, Tiny MNIST,
Alphabet, CIFAR10, and Mini CIFAR10. Filters shift from noise at initialization to more local
features later in meta-training.
17
Published as a conference paper at ICLR 2019
E Meta-Training curves
Minilmagenet Test
Minilmagenet
MiniCifar
Alphabet
Tiny Fashion Mnist
Tiny Mnist
Figure App.3: Training curves for the meta-training and meta-evaluation task distributions. Our
meta-train set consists of Mini Imagenet, Alphabet, and MiniCIFAR10. Our meta-test sets are Mini
Imagenet Test, Tiny Fashion MNIST, Tiny MNIST and IMDB. Error bars denote standard deviation
of evaluations with a fixed window of samples evaluated from a single model.
F	Learning algorithm
Initialize UnsupervisedUpdates parameters, θ0 .
Initialize meta-training step count V — 0.
Initialize shared gradient state S
Initialize R to be max meta-training steps.
while r < R on 512 workers in parallel do
Sample supervised task, D
Sample base model f (∙; φ) and initialize φ0 randomly
Sample K truncated iterations
Initialize learner iteration count: t — 0
for k = 1 to K do
Sample U unroll iterations
for u = 0 to U do
Sample data, x, from D
φt+u+1 = UnsupervisedUpdate(x, φt+u; θr)
end for
Initialize MetaObjective accumulator J — 0
for u = 1 to U do
for m = 1 to M (number of MetaObjective evaluations per iteration) do
Sample 2 batches of data, x,x0 , and labels, y,y0 from D for both training and testing.
J = J + UM MetaObjeCtiVe(x, y, x0 ,y0 ,φt+u)
end for
end for
Compute J for the last U steps and store in S
Update current unroll iteration: t — t + U
if size of S > meta-batch-size then
Take averaged batch of gradients G from S
θr+1 = θr - AdamUpdate(G)
r — r + 1
end if
end for
end while
Algorithm 1: Distributed Training Algorithm
18
Published as a conference paper at ICLR 2019
G Model specification
In this section we describe the details of our base model and learned optimizer. First, we describe the
inner loop, and then we describe the meta-training procedure in more depth.
In the following sections, λname denotes a hyper-parameter for the learned update rule.
The design goals of this system are stated in the text body. At the time of writing, we were unaware of
any similar systems, so as such the space of possible architectures was massive. Future work consists
of simplifying and improving abstractions around algorithmic components.
An open source implementation of the UnsupervisedUpdate can be found at https:
//github.com/tensorflow/models/tree/master/research/learning_
unsupervised_learning.
G.1 Inner Loop
The inner loop computation consists of iterative application of the UnsupervisedUpdate on a Base
Model parameterized by φ,
φt+ι = UnsUPervisedUPdate(∙, φt; θ),	(App.1)
where φ consists of forward weights, Wl, biases, bl, parameterizing a multi-layer perceptron as well
as backward weights, V l Used by UnsUpervisedUpdate when inner-loop training.
This compUtation can be broken down fUrther as a forward pass on an Unlabeled batch of data,
x0 〜D	(App.2)
{x1..xL, z1..zL} = f(x0; φt),	(App.3)
where zl, and xl are the pre- and post-activations on layer l, and x0 is inpUt data. We then compUte
weight Updates:
{(∆W1 …L)t, (∆b1 …L)t, (∆V1 …L)t} = ComPuteDeltaWeight(x0 …XL, z1 …ZL, φt; θ)
(App.4)
Finally, the next set of φ forward weights (Wl), biases (bl), and backward weights (Vl), are compUted.
We Use an SGD like Update bUt with the addition of a decay term. EqUivalently, this can be seen as
setting the weights and biases to an exponential moving average of the ∆Wl , ∆Vl, and ∆bl terms.
Wtl+1 = Wtl (1 - λφlr) + ∆Wl λφlr	(App.5)
Vtl+1 = Vtl (1 - λφlr) + ∆Vl λφlr	(App.6)
blt+1 = blt (1 - λφlr) + ∆blλφlr	(App.7)
We Use λφlr = 3e - 4 in oUr work. ∆Wl, ∆Vl, ∆bl are compUted via meta-learned fUnctions
(parameterized by θ).
In the following sections, we describe the fUnctional form of the base model, f, as well as the
functional form of ComPuteDeltaWeight (∙; θ).
G.2 Base Model
The base model, the model our learned update rule is training, is an L layer multi layer perception
with batch norm. We define φ as this model’s parameters, consisting of weights (Wl) and biases
(bl) as well as the backward weights (Vl) used only during inner-loop training (applications of
UnsupervisedUpdate). We define N1..NL to be the sizes of the layers of the base model and N0 to
be the size of the input data.
φ= {W1..WL, V1..VL, b1..bL},	(App.8)
19
Published as a conference paper at ICLR 2019
where
Wl ∈ RN j,Nl	(App.9)
Vl ∈ RN"-'Nl	(App.10)
bl ∈ RNl	(App.11)
where Nl is the hidden size of the network, N0 is the input size of data, and NL is the size of the
output embedding. In this work, we fix the output layer: NL = 32 and vary the remaining the
intermediate N 1..(L-1) hidden sizes.
The forward computation parameterized by φ, consumes batches of unlabeled data from a dataset D:
x0 ~D,x0 ∈ RB,N0	(App.12)
Zl = BatchNorm (XlTWl) + bl	(App.13)
xl = ReLU(zl)	(App.14)
for l = 1..L.
We define f(x; φ) as a function that returns the set of internal pre- and post-activation function hidden
states as well as f (x; φ) as the function returning the final hidden state:
f(x, φ) = {z1...zL, x0..xL, φ}	(App.15)
f(x, φ) = XL	(App.16)
G.3 MetaObjective
We define the MetaObjective to be a few shot linear regression. To increase stability and avoid
undesirable loss landscapes, we additionally center, as well as normalize the predicted target before
doing the loss computation. The full computation is as follows:
MetaObjective(X,y,x0,y0,φ)二(RB,n0, RB,nclasses, RB,n0, RB,nclasses, Φ) → R1, (App.17)
where N classes is the number of classes, and y, y0 are one hot encoded labels.
First, the inputs are converted to embeddings with the base model,
XL = f(x; φ)	(App.18)
X0L = f(X; φ)	(App.19)
Next, we center and normalize the prediction targets. We show this for y, but y0 is processed
identically.
B N classes
y — BN classes X X yij	(App.20)
ij
yij
yij - y
J 1
N classes
kyiak2
(App.21)
We then solve for the linear regression weights in closed form with features: XL and targets: y. We
account for a bias by concatenating a 1’s vector to the features.
A = [xl;1]	(App.22)
C = ((AtA) + Iλridge)-1 At y	(App.23)
We then use these inferred regression weights C to make a prediction on the second batch of data,
normalize the resulting prediction, and compute a final loss,
p=	=C [x0l ;1]	(App.24)
p^bi =	_ Pbi kPbk2	(App.25)
MetaObjective(∙) =	1B 二 B EkPb — ybk2. b	(App.26)
20
Published as a conference paper at ICLR 2019
Note that due to the normalization of predictions and targets, this corresponds to a cosine distance
(up to an offset and multiplicative factor).
G.4 UnsupervisedUpdate
The learned update rule is parameterized by θ. In the following section, we denote all instances of θ
with a subscript to be separate named learnable parameters of the UnsupervisedUpdate. θ is shared
across all instantiations of the unsupervised learning rule (shared across layers). It is this weight
sharing that lets us generalize across different network architectures.
The computation is split into a few main components: first, there is the forward pass, defined in
f (x; φ). Next, there is a “backward” pass, which operates on the hidden states in a reverse order to
propagate an error signal δl back down the network. In this process, a hidden state hl is created for
each layer. These h are tensors with a batch, neuron and feature index: hl ∈ RB,Nl,λhdims where
λhdims = 64. Weight updates to Wl and bl are then readout from these hl and other signals found
both locally, and in aggregate along both batch and neuron.
G.4. 1 Backward error propagation
In backprop, there exists a single scalar error signal that gets backpropagated back down the network.
In our work, this error signal does not exist as there is no loss being optimized. Instead we have a
learned top-down signal, dL, at the top of the network. Because we are no longer restricted to the
form of backprop, we make this quantity a vector for each unit in the network, rather than a scalar,
x0 〜D,x0 ∈ RB,Nχ	(App.27)
{z1...zL, x0..xL, φ} = f(x; φ)	(App.28)
dL = TopD(xL ; θtopD)	(App.29)
(App.30)
where dl ∈ RB,Nl,λdeitadims. In this work We set 入&匕1弋&&诏"=32. The architecture of ToPD is a
neural network that operates along every dimension of xL . The specification can be found in G.7.
We structure our error propagation similarly to the structure of the backpropagated error signal in a
standard MLP with contributions to the error at every layer in the network,
λhdims
δiljd = dlijd	σ(ziljd) + X (θerrorP ropW )kd hijk + (θerrorP ropB )d	(App.31)
k
where δl has the same shape as dl, and θerrorPropW ∈ λhdi^m^^λdλtadi^m^a and θerrorPropB ∈
λd^^tad;i,msms. Note both θerrorPropW and θerrorPropB are shared for all layers l.
In a similar way to backprop, we move this signal down the network via multiplying by a backward
weight matrix (Vl). We do not use the previous weight matrix transpose as done in backprop, instead
we learn a separate set of weights that are not tied to the forward weights and updated along with
the forward weights as described in G.5. Additionally, we normalize the signal to have fixed second
moment,
Nl+1
dimd = X δij+d (V + )mj	(App.32)
j
-1
C]	λteltatims	∖ 2
λ	X :	dima j	(APP.33)
deltadims a
The internal hl ∈ ^N^,λl,λhtims vectors are computed via:
h = ComPuteH (dl,xl,zl; θcomputeH)	(App.34)
The architecture of ComPuteH is a neural network that operates on every dimension of all the inputs.
It can be found in G.8. These definitions are recursive, and are computed in order: hL, hL-1 ∙ ∙ ∙ h1,h0.
With these computed, weight updates can be read out (Section G.5). When the corresponding symbols
are not defined (e.g. z0) a zeros tensor with the correct shape is used instead.
21
Published as a conference paper at ICLR 2019
G.5 Weight Updates
The following is the implementation of ComPuteDeltaWeight(x0 …xL,z1 …zL,φ; θ)
For a given layer, l, our weight updates are a mixture of multiple low rank readouts from hl and hl-1.
These terms are then added together with a learnable weight, in θ to form a final update. The final
update is then normalized mixed with the previous weights. We update both the forward, Wl, and the
backward, V l, using the same update rule parameters θ. We show the forward weight update rule
here, and drop the backward for brevity.
For convenience, we define a low rank readout function LowRR that takes hl like tensors, and outputs
a single lower rank tensor.
LoWRR (ha, hb; Θ) ::	(App.35)
(IRJB ,N01 ,λhdims ɪ[ɪB ,n' ,λhdims)→ RN-a,Nb	(App.36)
Here, Θ, is a placehoder for the parameters of the given readout. LoWRR is defined as:
Θ = {Pa, Pb} where Pa ∈ λhdhms^λgrsdcdc and pb ∈ J^λhdims ,λgradc (App.37)
riajp = X hiajkPkap	(App.38)
k
ribjp = X hibjkPkbp	(App.39)
k
B λgradc	1
LoWRR(∙) jp =XX
rij k ripk R X	(App.40)
B λhdims
where λgradc = 4 and is the rank of the readout matrix (per batch element).
G.5.1 Local terms
This sequence of terms allow the weight to be adjusted as a function of state in the pre- and post-
synaptic neurons. They should be viewed as a basis function representation of the way in which
the weight changes as a function of pre- and post-synaptic neurons, and the current weight value.
We express each of these contributions to the weight update as a sequence of weight update planes,
with the ith plane written ∆W∕ ∈ RNl 1×Nl. Each of these planes will be linearly summed, with
coefficients generated as described in Equation App.57, in order to generate the eventual weight
update.
∆W3l = LoWRR(hl-1, hl; θzero)
∆W4 = exp(-(Wbl)2) Θ LowRR(hl-1, hl; θ^)
∆W5l = Wbl LoWRR(hl-1, hl; θf irst)
(App.41)
(App.42)
(App.43)
(App.44)
(App.45)
(App.46)
(App.47)
T
1B
∆W6 = B X
b
xlb0
G.5.2 Decorrelation terms
Additional weight update planes are designed to aid units in remaining decorrelated from each other’s
activity, and in decorrelating their receptive fields. Without terms like this, a common failure mode
22
Published as a conference paper at ICLR 2019
is for many units in a layer to develop near-identical representations. Here, S	il indicates a scratch
matrix associated with weight update plane i and layer l.	
S7 = / ］ Zj= LoWRR(h ,, h ,θ θlinLowerSymm) Nl-1	(App.48)
△w7 = √ ［卜7 + S)t) θ (i-ι)i Wl	(App.49)
S8 = / ［十 LoWRR(h ,, h ,θ θsqrLowerSymm) Nl-1	(App.50)
∆W8l = √ h(s8 + (s8 )T) θ (i -1)i (jι + (Wl)2 -1)	(App.51)
S9 = i	L LoWRR(h, h , θlinUpperSymm) Nl	(App.52)
△w9 = √Wl ［卜9 + (s9)t) θ (i - i)i	(App.53)
S10 = i L LoWRR(h , h , θsqrUpperSymm) Nl	(App.54)
△w1o = √ (jι + (Wl)2 -1) h(sl0 + (S［o)t) θ (1 - I)i	(App.55)
	(App.56)
G.6 Application of the weight terms in the optimizer
We then normalize, re-weight, and merge each of these weight update planes into a single term, which
will be used in the weight update step,
~ ,
∆Wil
∆Wil
1B
(△Wmerge)jk = B ɪ2 (θmergeW )i^Wiijk,
(App.57)
(App.58)
where θmergeW ∈ R10 (as We have 10 input planes).
To prevent pathologies during training, we perform two post processing steps to prevent the learned
optimizer from cheating, and increasing its effective learning rate, leading to instability. We only
allow updates which do not decrease the weight matrix magnitude,
∆Wθrth = ∆Wmerge - Wl ReLU(∆Wmerge ∙ Wl),	(App.59)
where Wl is Wl scaled to have unit norm, and we normalize the length of the update,
∆Wflina
∆Wolrth
/1 + NT-INT PNlT PN KWorth∖
(App.60)
To compute changes in the biases, we do a readout from hl. We put some constraints on this update to
prevent the biases from pushing all units into the linear regime, and minimizing learning. We found
this to be a possible pathology.
1 B λhdims
∆blbase = ⅛ΣΣ(θBreadout)k hlijk	(App.61)
/	1 N l	∖
△^constrained = ∆bbase - ReLU I - N E Gblbase) i ) ,	(APP∙62)
23
Published as a conference paper at ICLR 2019
where θBreadout ∈ Rλhdims .
We then normalize the update via the second moment:
∆bfinal = L P∆drained	(App.63)
Nl ʌ/i (2"i"constrained )i
Finally, we define ComputeDeltaWeight as all layer’s forward weight updates, and backward weight
updates, and bias updates.
ComPuteDeltaWeight(x0 …χL,zι …zL, φt；	=。WfinL.ι, Xbfinai, AvfinLi) (App.64)
G.7 ToPD
This function performs various convolutions over the batch dimension and data dimension. For ease
of notation, we use m as an intermediate variable. Additionally, we drop all convolution and batch
norm parameterizations. They are all separate elements of θtopD. We define two 1D convolution
operators that act on rank 3 tensors: ConvBatch which performs convolutions over the zeroth index,
and ConvUnit which performs convolutions along the firs index. We define the S argument to be
size of hidden units, and the K argument to be the kernel size of the 1D convolutions. Additionally,
we set the second argument of BatchNorm to be the axis normalized over.
TopD (XL; θtopD)二 Bb^nL → b{bl,LMtadams	(App.65)
First, we reshape to add another dimension to the end of xL, in pseudocode:
m0 = [xL]	(App.66)
Next, a convolution is performed on the batch dimension with a batch norm and a ReLU non linearity.
This starts to pull information from around the batch into these channels.
m1 = ConvBatch (m0, S = λtopdeitasize, K = 5)	(App.67)
m2 = ReLU (BatchNorm (m1 , [0, 1]))	(App.68)
(App.69)
We set λtopdeitasize = 64. Next, a series of unit convolutions (convolutions over the last dimension)
are performed. These act as compute over information composed from the nearby elements of the
batch. These unit dimensions effectively rewrite the batch dimension. This restricts the model to
operate on a fixed size batch.
m3 = ConvUnit (m2, S = B, K = 3)
m4 = ReLU (BatchNorm (m3, [0, 1]))
m5 = ConvUnit (m4, S = B, K = 3)
m6 = ReLU (BatchNorm (m5, [0, 1]))
(App.70)
(App.71)
(App.72)
(App.73)
Next a series of 1D convolutions are performed over the batch dimension for more compute capacity.
m7	ConvBatch (m6, S	= λtopdeitasize, K =	3)	(App.74)
m8	ReLU (BatchNorm	(m7, [0, 1]))		(App.75)
m9	ConvBatch (m8, S	= λtopdeitasize, K =	3)	(App.76)
m10	ReLU (BatchNorm	(m9, [0, 1]))		(App.77)
Finally, we convert the representations to the desired dimensions and output.
m11 = ConvBatch (m10 , S = λdeitadims , K = 3) (App.78)
TopD (xL; θtopD) = mil	(App.79)
24
Published as a conference paper at ICLR 2019
G.8 ComputeH
This is the main computation performed while transfering signals down the network and the output is
directly used for weight updates. It is defined as:
ComPuteH (d∖x∖zl.Wl, W l+1,bl; θcomputeH)：：
(R B,N l,λdeltadims , RB,N : RB，N : RN ，N : RN 1，N 卡, RN → (R B，N'，Ε，)(App.80)
The outputs of the base model, (xl , zl), plus an additional positional embeddings are stacked then
concatenated with d, to form a tensor in RB,nl,(4+λdeitadims):
(PO) ij = Sin ( Nj∏∏Γ )
(PI)j=Cos(INf)
mo = [xl,zl,p0,p1] where m° ∈ RB,",4
m1 = [m0; dl]
(App.81)
(App.82)
(App.83)
(App.84)
Statistics across the batch and unit dimensions, 0 and 1, are computed. We define a Statsi function
bellow. We have 2 instances for both the zeroth and the first index, shown bellow is the zeroth index
and the first is omitted.
StatsO (w) ：： RK ,K → RK ,4
(Sli)j = Ko Xabs(wij) i	
(sl2)j = t	VT^ Ko X(Wij )2 i
(sμ)j = K	1	K0 押 EWij i
(sσ)j = t StatSO (W) = [sli, Sl2 , Sμ, Sσ]	I	K0 KO X((Sμ)i - Wij)2 i
(App.85)
(App.86)
(App.87)
(App.88)
(App.89)
(App.90)
We the compute statistics of the weight matrix below, and above. We tile the statistics to the
appropriate dimensions and concatenate with normalized inputs as well as with the bias (also tiled
appropriately).
(so)ijk = (StatsO (Wl, 0))j
(SI)ijk = (StatsI (Wl+1, 1))i
m2 = BatchNorm(m1, [0, 1])
bijk = bj where b ∈ RB,nl,1
m3 = [so； si; m2； b] where m3 ∈ kb,nι,4+4+(4+λdeltadims)+1
(App.91)
(App.92)
(App.93)
(App.94)
(App.95)
25
Published as a conference paper at ICLR 2019
With the inputs prepared, we next perform a series of convolutions on batch and unit dimensions, (0,
1).
m4	ConvBatch (m3, S	= λcomputehsiz e , K	= 3)	(App.96)
m5	ReLU (BatchNorm	(m4, [0, 1]))		(App.97)
m6	ConvUnit (m5, S =	λcomputehsize, K =	3)	(App.98)
m7	ReLU (BatchNorm	(m6, [0, 1]))		(App.99)
m8	ConvBatch (m7, S	= λcomputehsiz e , K = 3)		(App.100)
m9	ReLU (BatchNorm	(m8, [0, 1]))		(App.101)
m10	ConvUnit (m9, S =	λcomputehsize, K =	3)	(App.102)
m11	ReLU (BatchNorm	(m10, [0, 1]))		(App.103)
The result is then output.
ComPuteH (∙; θcomputed = mil	(App.104)
We set λcomputehsize = 64 which is the inner computation size.
H	Experimental details
H. 1 Meta Training
H.1.1 Training Data Distribution
We trained on a data distribution consisting of tasks sampled uniformly over the following datasets.
Half of our training tasks where constructed off of a dataset consisting of 1000 font rendered
characters. We resized these to 14x14 black and white images. We call this the glyph dataset.
"Alphabet" is an example of such a dataset consisting of alphabet characters. We used a mixture
10, 13, 14, 17, 20, and 30 way classification problems randomly sampled, as well as sampling from
three 10-way classification problems sampled from specific types of images: letters of the alphabet,
math symbols, and currency symbols. For half of the random sampling and all of the specialized
selection we apply additional augmentation. This augmentation consists of random rotations (up to
360 degrees) and shifts up to +-5 pixels in the x and y directions. The parameters of the augmentation
were inserted into the regression target of the MetaObjective as a curriculum of sorts and to provide
diverse training signal.
In addition to the the glyph set, we additionally used Cifar10, resized to 16x16, as well as 10, 15,
20, and 25 way classification problems from imagenet. Once again we resized to 16x16 for compute
reasons.
With a dataset selected, we apply additional augmentation with some probability consisting of the
following augmentations. A per task dropout mask (fixed mask across all images in that task). A per
example dropout mask (a random mask per image). A permutation sampled from a fixed number of
pre created permutations per class. A per image random shift in the x direction each of image. All of
these additional augmentations help with larger domain transfer.
H.2 Meta-Optimization
We employ Adam (Kingma and Ba, 2014) as our meta-optimizer. We use a learning rate schedule of
3e-4 for the first 100k steps, then 1e-4 for next 50k steps, then 2e-5 for remainder of meta-training.
We use gradient clipping of norm 5 on minibatchs of size 256.
We compute our meta-objective by averaging 5 evaluation of the linear regression. We use a ridge
penalty of 0.1 for all this work.
When computing truncated gradients, we initially sample the number of unrolled applications of
the UnsupervisedUpdate in a uniform distribution of [2,4]. This is the number of steps gradients
are backpropogated through. Over the course of 50k meta-training steps we uniformly increase this
to [8,15]. This increases meta-training speed and stability as large unrolls early in training can be
unstable and don’t seem to provide any value.
26
Published as a conference paper at ICLR 2019
For sampling the number of truncated steps (number of times the above unrolls are performed), we
use a shifted normal distribution - a normal distribution with the same mean and standard deviation.
We chose this based on the expected distribution of the training step, φ iteration number, across the
cluster of workers. We initially set the standard deviation low, 20, but slowly increased it over the
course of 5000 steps to 20k steps. This slow increase also improved stability and training speed.
H.3 Experimental setup
For each experimental figure, we document the details.
H.3.1 Objective Function Mismatch
The VAE we used consists of 3 layers, size 128, with ReLU activations and batch norm between
each layer. We then learn a projection to mean and log std of size 32. We sample, and use the
inverse architecture to decode back to images. We use a quantized normal distribution (once again
parameterized as mean and log std) as a posterior. We train with Adam with a learning rate of 1e-4.
To isolate the effects of objective function mismatch and overfitting, we both train on the unlabeled
training set and evaluate on the labeled training set instead of a validation set.
H.3.2 Generalization: Dataset and Domain
We use a 4 layer, size 128 unit architecture with a 32 layer embedding for all models. We select
performance at 100k training steps for the VAE, and 3k for our learned optimizer.
Our supervised learning baseline consists of the same architecture for the base model but with an
additional layer that outputs log probabilities. We train with cross entropy loss on a dataset consisting
of only 10 examples per class (to match the other numbers). Surprisingly, the noise from batch norm
acts as a regularizer, and allowing us to avoid needing a complex early stopping scheme as test set
performance simply plateaus over the course of 10k steps. We train with Adam with a learning
rate of 3e-3, selected via a grid over learning rate on test set performance. In this setting, having a
true validation set would dramatically lower the amount of labeled data available (only 100 labeled
examples) and using the test set only aids in the this baseline’s performance.
For the IMDB experiments, we tokenized and selected the top 1K words with an additional set of
tokens for unknown, sentence start, and sentence end. Our encoding consisted of a 1 if the word
is present, otherwise 0. We used the same 4 layer, 128 hidden unit MLP with an addition layer
outputting a 32 dimensional embedding.
H.3.3 Generalization: Network Architecture
We used ReLU activations and 4 layers of size 128 with an additional layer to 32 units unless
otherwise specified by the specific experiment.
H.3.4 Existing meta learning models
We trained prototypical networks (Snell et al., 2017) on either intact or shuffled mini-Imagenet
images. For shuffled images, we generated a fixed random permutation for the inputs independently
for every instantiation of the base network (or ’episode’ in the meta-learning literature (Vinyals et al.,
2016; Ravi and Larochelle, 2016)). The purpose of shuffling was to demonstrate the inductive bias of
this type of meta-learning, namely that they do not generalize across data domain. Note that the base
network trained was the same fully connected architecture like that used in this paper (3 layers, size
128, with ReLU activations and batch normalization between layers). Though the original paper used
a convolutional architecture, here we swapped it with the fully connected architecture because the
tied weights in a convolutional model do not make sense with shuffled pixels.
27