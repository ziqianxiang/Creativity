Published as a conference paper at ICLR 2018
On the convergence of Adam and Beyond
Sashank J. Reddi, Satyen Kale & Sanjiv Kumar
Google New York
New York, NY 10011, USA
{sashank,satyenkale,sanjivk}@google.com
Ab stract
Several recently proposed stochastic optimization methods that have been suc-
cessfully used in training deep networks such as RMSprop, Adam, Adadelta,
Nadam are based on using gradient updates scaled by square roots of exponential
moving averages of squared past gradients. In many applications, e.g. learning
with large output spaces, it has been empirically observed that these algorithms
fail to converge to an optimal solution (or a critical point in nonconvex settings).
We show that one cause for such failures is the exponential moving average used
in the algorithms. We provide an explicit example of a simple convex optimiza-
tion setting where Adam does not converge to the optimal solution, and describe
the precise problems with the previous analysis of Adam algorithm. Our anal-
ysis suggests that the convergence issues can be fixed by endowing such algo-
rithms with “long-term memory” of past gradients, and propose new variants of
the Adam algorithm which not only fix the convergence issues but often also lead
to improved empirical performance.
1	Introduction
Stochastic gradient descent (Sgd) is the dominant method to train deep networks today. This method
iteratively updates the parameters of a model by moving them in the direction of the negative gra-
dient of the loss evaluated on a minibatch. In particular, variants of Sgd that scale coordinates
of the gradient by square roots of some form of averaging of the squared coordinates in the past
gradients have been particularly successful, because they automatically adjust the learning rate on
a per-feature basis. The first popular algorithm in this line of research is Adagrad (Duchi et al.,
2011; McMahan & Streeter, 2010), which can achieve significantly better performance compared to
vanilla S gd when the gradients are sparse, or in general small.
Although Adagrad works well for sparse settings, its performance has been observed to deteriorate
in settings where the loss functions are nonconvex and gradients are dense due to rapid decay of the
learning rate in these settings since it uses all the past gradients in the update. This problem is
especially exacerbated in high dimensional problems arising in deep learning. To tackle this issue,
several variants of Adagrad, such as RMSprop (Tieleman & Hinton, 2012), Adam (Kingma
& Ba, 2015), Adadelta (Zeiler, 2012), Nadam (Dozat, 2016), etc, have been proposed which
mitigate the rapid decay of the learning rate using the exponential moving averages of squared past
gradients, essentially limiting the reliance of the update to only the past few gradients. While these
algorithms have been successfully employed in several practical applications, they have also been
observed to not converge in some other settings. It has been typically observed that in these settings
some minibatches provide large gradients but only quite rarely, and while these large gradients
are quite informative, their influence dies out rather quickly due to the exponential averaging, thus
leading to poor convergence.
In this paper, we analyze this situation in detail. We rigorously prove that the intuition conveyed
in the above paragraph is indeed correct; that limiting the reliance of the update on essentially only
the past few gradients can indeed cause significant convergence issues. In particular, we make the
following key contributions:
•	We elucidate how the exponential moving average in the RMSPROP and ADAM algorithms
can cause non-convergence by providing an example of simple convex optimization prob-
1
Published as a conference paper at ICLR 2018
lem where RMSprop and Adam provably do not converge to an optimal solution. Our
analysis easily extends to other algorithms using exponential moving averages such as
Adadelta and Nadam as well, but we omit this for the sake of clarity. In fact, the
analysis is flexible enough to extend to other algorithms that employ averaging squared
gradients over essentially a fixed size window (for exponential moving averages, the influ-
ences of gradients beyond a fixed window size becomes negligibly small) in the immediate
past. We omit the general analysis in this paper for the sake of clarity.
•	The above result indicates that in order to have guaranteed convergence the optimization
algorithm must have “long-term memory” of past gradients. Specifically, we point out a
problem with the proof of convergence of the Adam algorithm given by Kingma & Ba
(2015). To resolve this issue, we propose new variants of Adam which rely on long-term
memory of past gradients, but can be implemented in the same time and space requirements
as the original Adam algorithm. We provide a convergence analysis for the new variants
in the convex setting, based on the analysis of Kingma & Ba (2015), and show a data-
dependent regret bound similar to the one in Adagrad.
•	We provide a preliminary empirical study of one of the variants we proposed and show
that it either performs similarly, or better, on some commonly used problems in machine
learning.
2	Preliminaries
Notation. We use Sd+ to denote the set of all positive definite d × d matrices. With slight abuse of
notation, for a vector a ∈ Rd and a positive definite matrix M ∈ Rd × Rd , we use a/M to denote
M-1a, ∣∣Mik2 to denote '2-norm of ith row of M and √M to represent M1/2. Furthermore, for
any vectors a, b ∈ Rd, we use √a for element-wise square root, a2 for element-wise square, a/b
to denote element-wise division and max(a, b) to denote element-wise maximum. For any vector
θi ∈ Rd, θi,j denotes its jth coordinate where j ∈ [d]. The projection operation ΠF,A(y) for A ∈ S+d
is defined as arg minx∈F kA1/2(x - y)k for y ∈ Rd. Finally, we say F has bounded diameter D∞
if kx - y k∞ ≤ D∞ for all x, y ∈ F.
Optimization setup. A flexible framework to analyze iterative optimization methods is the online
optimization problem in the full information feedback setting. In this online setup, at each time
step t, the optimization algorithm picks a point (i.e. the parameters of the model to be learned)
xt ∈ F, where F ∈ Rd is the feasible set of points. A loss function ft (to be interpreted as
the loss of the model with the chosen parameters in the next minibatch) is then revealed, and the
algorithm incurs loss ft(xt). The algorithm’s regret at the end of T rounds of this process is given
by RT = PiT=1 ft(xt) - minx∈F PiT=1 ft(x). Throughout this paper, we assume that the feasible
set F has bounded diameter and ∣∣Vft(χ)k∞ is bounded for all t ∈ [T] and X ∈ F.
Our aim to is to devise an algorithm that ensures RT = o(T), which implies that on average,
the model’s performance converges to the optimal one. The simplest algorithm for this setting is
the standard online gradient descent algorithm (Zinkevich, 2003), which moves the point xt in the
opposite direction of the gradient gt = Vft(xt) while maintaining the feasibility by projecting onto
the setF via the update rule xt+1 = ΠF(xt - αtgt), where ΠF (y) denotes the projection ofy ∈ Rd
onto the set F i.e., ∏f(y) = minχ∈F ∣∣x 一 y∣, and at is typically set to a∕√t for some constant
α. The aforementioned online learning problem is closely related to the stochastic optimization
problem: minx∈F Ez [f(x, z)], popularly referred to as empirical risk minimization (ERM), where z
is a training example drawn training sample over which a model with parameters x is to be learned,
and f(x, z ) is the loss of the model with parameters x on the sample z . In particular, an online
optimization algorithm with vanishing average regret yields a stochastic optimization algorithm for
the ERM problem (Cesa-Bianchi et al., 2004). Thus, we use online gradient descent and stochastic
gradient descent (Sgd) synonymously.
Generic adaptive methods setup. We now provide a framework of adaptive methods that gives
us insights into the differences between different adaptive methods and is useful for understanding
the flaws in a few popular adaptive methods. Algorithm 1 provides a generic adaptive framework
that encapsulates many popular adaptive methods. Note the algorithm is still abstract because the
2
Published as a conference paper at ICLR 2018
Algorithm 1 Generic Adaptive Method Setup
Input: x1 ∈ F, step size {αt > 0}tT=1, sequence of functions {φt, ψt}tT=1
for t = 1 to T do
gt = Nft(Xt)
mt = φt(gι,... ,gt) and Vt = ψt(gι,... ,gt)
Xt+ι = Xt 一 αtm"√Vt
χt+ι = πf,√V t(Xt+1)
end for
“averaging” functions φt and ψt have not been specified. Here φt : Ft → Rd and ψt : F t → S+d .
For ease of exposition, We refer to at as step size and at VtT/2 as learning rate of the algorithm and
furthermore, restrict ourselves to diagonal variants of adaptive methods encapsulated by Algorithm 1
Where Vt = diag(vt) . We first observe that standard stochastic gradient algorithm falls in this
frameWork by using:
φt (g1 , . . . , gt) = gt and ψt (g1 , . . . , gt) = I,	(S GD)
and at = α∕√7 for all t ∈ [T]. While the decreasing step size is required for convergence, such an
aggressive decay of learning rate typically translates into poor empirical performance. The key idea
of adaptive methods is to choose averaging functions appropriately so as to entail good convergence.
For instance, the first adaptive method Adagrad (Duchi et al., 2011), Which propelled the research
on adaptive methods, uses the folloWing averaging functions:
φt(g1,...,gt) = gt and ψt(gι,...,gt) = diag(pi=1 gi),	(ADAGRAD)
and step size at = α∕√7 for all t ∈ [T]. In contrast to a learning rate of ɑ∕√t in Sgd, such a setting
effectively implies a modest learning rate decay of a/^^∕p-gi2j^ for j ∈ [d]. When the gradients are
sparse, this can potentially lead to huge gains in terms of convergence (see Duchi et al. (2011)).
These gains have also been observed in practice for even feW non-sparse settings.
Adaptive methods based on Exponential Moving Averages. Exponential moving average vari-
ants of Adagrad are popular in the deep learning community. RMSprop, Adam, Nadam, and
Adadelta are some prominent algorithms that fall in this category. The key difference is to
use an exponential moving average as function ψt instead of the simple average function used in
Adagrad. Adam1, a particularly popular variant, uses the folloWing averaging functions:
tt
φt(g1, . . . ,gt) = (1 - β1) Xβ1t-igi and ψt(g1, . . . ,gt) = (1 - β2)diag(Xβ2t-igi2), (ADAM)
i=1	i=1
for some β1, β2 ∈ [0, 1). This update can alternatively be stated by the folloWing simple recursion:
mt,i = β1mt-1,i + (1 - β1)gt,i and vt,i = β2vt-1,i + (1 - β2)gt2,i (1)
and m0,i = 0 and v0,i = 0 for all i ∈ [d]. and t ∈ [T]. A value of β1 = 0.9 and β2 = 0.999
is typically recommended in practice. We note the additional projection operation in Algorithm 1
in comparison to ADAM. When F = Rd , the projection operation is an identity operation and
this corresponds to the algorithm in (Kingma & Ba, 2015). For theoretical analysis, one requires
at = 1/y/t for t ∈ [T], although, a more aggressive choice of constant step size seems to work well
in practice. RMSprop, Which appeared in an earlier unpublished Work (Tieleman & Hinton, 2012)
is essentially a variant of ADAM with β1 = 0. In practice, especially in deep learning applications,
the momentum term arising due to non-zero β1 appears to significantly boost the performance.
We will mainly focus on Adam algorithm due to this generality but our arguments also apply to
RMSprop and other algorithms such as Adadelta, Nadam.
1Here, for simplicity, we remove the debiasing step used in the version of Adam used in the original paper
by Kingma & Ba (2015). However, our arguments also apply to the debiased version as well.
3
Published as a conference paper at ICLR 2018
3 The Non-Convergence of Adam
With the problem setup in the previous section, we discuss fundamental flaw in the current exponen-
tial moving average methods like Adam. We show that Adam can fail to converge to an optimal
solution even in simple one-dimensional convex settings. These examples of non-convergence con-
tradict the claim of convergence in (Kingma & Ba, 2015), and the main issue lies in the following
quantity of interest:
This quantity essentially measures the change in the inverse of learning rate of the adaptive method
with respect to time. One key observation is that for SGD and ADAGRAD, Γt 0 for all t ∈
[T]. This simply follows from update rules of SGD and ADAGRAD in the previous section. In
particular, update rules for these algorithms lead to “non-increasing” learning rates. However, this
is not necessarily the case for exponential moving average variants like Adam and RMSprop i.e.,
Γt can potentially be indefinite for t ∈ [T] . We show that this violation of positive definiteness can
lead to undesirable convergence behavior for Adam and RMSprop. Consider the following simple
sequence of linear functions for F = [-1, 1]:
Cx,
ft(x) =
-x,
for t mod 3 = 1
otherwise,
where C > 2. For this function sequence, it is easy to see that the point x = -1 provides the
minimum regret. Suppose β1 = 0 and β2 = 1/(1 + C2). We show that ADAM converges to a
highly suboptimal solution of x = +1 for this setting. Intuitively, the reasoning is as follows. The
algorithm obtains the large gradient C once every 3 steps, and while the other 2 steps it observes the
gradient -1, which moves the algorithm in the wrong direction. The large gradient C is unable to
counteract this effect since it is scaled down by a factor of almost C for the given value of β2, and
hence the algorithm converges to 1 rather than -1. We formalize this intuition in the result below.
Theorem 1.	There is an online convex optimization problem where ADAM has non-zero average
regret i.e., RT/T 9 0 as T → ∞.
We relegate all proofs to the appendix. A few remarks are in order. One might wonder if adding a
small constant in the denominator of the update helps in circumventing this problem i.e., the update
for ADAM in Algorithm 1 of Xt+ι is modified as follows:
Xt+1 = Xt - αtmt/√Vt + eI.	(3)
The algorithm in (Kingma & Ba, 2015) uses such an update in practice, although their analysis
does not. In practice, selection of the parameter appears to be critical for the performance of the
algorithm. However, we show that for any constant > 0, there exists an online optimization setting
where, again, Adam has non-zero average regret asymptotically (see Theorem 6 in Section F of the
appendix).
The above examples of non-convergence are catastrophic insofar that Adam and RMSprop con-
verge to a point that is worst amongst all points in the set [-1, 1]. Note that above example also
holds for constant step size αt = α. Also note that classic SGD and ADAGRAD do not suffer from
this problem and for these algorithms, average regret asymptotically goes to 0. This problem is espe-
cially aggravated in high dimensional settings and when the variance of the gradients with respect to
time is large. This example also provides intuition for why large β2 is advisable while using ADAM
algorithm, and indeed in practice using large β2 helps. However the following result shows that
for any constant βι and β2 with βι < √β2, We can design an example where ADAM has non-zero
average rate asymptotically.
Theorem 2.	For any ConStant β1,β2 ∈ [0,1) such that βι < √β2, there is an online convex
optimization problem where ADAM has non-zero average regret i.e., RT/T 9 0 asT → ∞.
The above results show that with constant βι and β2, momentum or regularization via E will not help
in convergence of the algorithm to the optimal solution. Note that the condition βι < √β2 is benign
and is typically satisfied in the parameter settings used in practice. Furthermore, such condition is
assumed in convergence proof of Kingma & Ba (2015). We can strengthen this result by providing
a similar example of non-convergence even in the easier stochastic optimization setting:
4
Published as a conference paper at ICLR 2018
Algorithm 2 AMS GRAD
Input: x1 ∈ F, step size {αt}tT=1, {β1t}tT=1, β2
Set mo = 0, vo = 0 and Vo = 0
for t = 1 to T do
gt = Nft(Xt)
mt = β1tmt-1 + (1 - β1t )gt
vt = β2vt-1 + (1 - β2)gt2
Vt = max(Vt-ι,Vt) and Vt = diag(Vt)
xt+ι = ∏f √^(Xt 一 α±mt∕√Vt)
end for
Theorem 3.	For any constant β1,β2 ∈ [0,1) such that βι < √β2, there is a stochastic convex
optimization problem for which ADAM does not converge to the optimal solution.
These results have important consequences insofar that one has to use “problem-dependent” , β1
and β2 in order to avoid bad convergence behavior. In high-dimensional problems, this typically
amounts to using, unlike the update in Equation (3), a different , β1 and β2 for each dimension.
However, this defeats the purpose of adaptive methods since it requires tuning a large set of pa-
rameters. We would also like to emphasize that while the example of non-convergence is carefully
constructed to demonstrate the problems in Adam, it is not unrealistic to imagine scenarios where
such an issue can at the very least slow down convergence.
We end this section with the following important remark. While the results stated above use constant
β1 and β2, the analysis of ADAM in (Kingma & Ba, 2015) actually relies on decreasing β1 over time.
It is quite easy to extend our examples to the case where β1 is decreased over time, since the critical
parameter is β2 rather than β1 , and as long as β2 is bounded away from 1, our analysis goes through.
Thus for the sake of clarity, in this paper we only prove non-convergence of Adam in the setting
where β1 is held constant.
4 A New Exponential Moving Average Variant: AMSGrad
In this section, we develop a new principled exponential moving average variant and provide its
convergence analysis. Our aim is to devise a new strategy with guaranteed convergence while pre-
serving the practical benefits of Adam and RMSprop. To understand the design of our algorithms,
let us revisit the quantity Γt in (2). For ADAM and RMSPROP, this quantity can potentially be nega-
tive. The proof in the original paper of ADAM erroneously assumes that Γt is positive semi-definite
and is hence, incorrect (refer to Appendix D for more details). For the first part, we modify these
algorithms to satisfy this additional constraint. Later on, we also explore an alternative approach
where Γt can be made positive semi-definite by using values of β1 and β2 that change with t.
AMS Grad uses a smaller learning rate in comparison to Adam and yet incorporates the intuition
of slowly decaying the effect of past gradients on the learning rate as long as Γt is positive semi-
definite. Algorithm 2 presents the pseudocode for the algorithm. The key difference of AMSGrad
with ADAM is that it maintains the maximum of all vt until the present time step and uses this
maximum value for normalizing the running average of the gradient instead of vt in ADAM. By
doing this, AMSGrad results in a non-increasing step size and avoids the pitfalls of Adam and
RMSPROP i.e., Γt 0 for all t ∈ [T] even with constant β2 . Also, in Algorithm 2, one typi-
cally uses a constant β1t in practice (although, the proof requires a decreasing schedule for proving
convergence of the algorithm).
To gain more intuition for the updates of AMSGrad, it is instructive to compare its update with
ADAM and ADAGRAD. Suppose at particular time step t and coordinate i ∈ [d], we have vt-1,i >
gt2,i > 0, then ADAM aggressively increases the learning rate, however, as we have seen in the
previous section, this can be detrimental to the overall performance of the algorithm. On the other
hand, Adagrad slightly decreases the learning rate, which often leads to poor performance in
practice since such an accumulation of gradients over a large time period can significantly decrease
the learning rate. In contrast, AMSGrad neither increases nor decreases the learning rate and
furthermore, decreases vt which can potentially lead to non-decreasing learning rate even if gradient
5
Published as a conference paper at ICLR 2018
Figure 1: Performance comparison of ADAM and AMS GRAD on synthetic example on a simple one dimen-
sional convex problem inspired by our examples of non-convergence. The first two plots (left and center) are
for the online setting and the the last one (right) is for the stochastic setting.
is large in the future iterations. For rest of the paper, we use g1:t = [g1 . . . gt] to denote the matrix
obtained by concatenating the gradient sequence. We prove the following key result for AMSGrad.
Theorem 4. Let {xt} and {vt} be the sequences obtainedfrom Algorithm 2, αt = ɑ/ʌ/t, βι = β11,
βιt ≤ βι for all t ∈ [T] and Y = β1∕√β2 < L Assume that F has bounded diameter D∞
and ∣∣Vft(x)k∞ ≤ G∞ for all t ∈ [T] and X ∈ F. For Xt generated using the AMSGRAD
(Algorithm 2), we have the following bound on the regret
RT ≤
d∞√ X v^ι/2+	d∞	X X β1tvt∣i +_____________α√1 + log T___________
α(I - βI) i=1 T，i 2(I - βI) t=1 =	αt	(1 — βι)2(1 — γ)p(1 - β2)
d
E kg1：T,ik2.
i=1
The following result falls as an immediate corollary of the above result.
Corollary 1. Suppose β1t = β1λt-1 in Theorem 4, then we have
RT ≤
D∞ √T 'X "/2 +	BlD∞G∞
α(1 — βι) = vT，i + 2(1 — βι)(1 — λ)2
α √1 + log T
(I — βI)2(1 — Y)P(I — Bz)
d
E kg1：T,ik2.
i=1
+
The above bound can be considerably better than O(√dT) regret of SGD when Pd=I VT7《√d
and Pd=I ∣∣gLT,i∣∣2《√dT (DUchi et al., 2011). Furthermore, in Theorem 4, one can use a much
more modest momentum decay of Bit = βι∕t and still ensure a regret of O(√T). We would
also like to point out that one could consider taking a simple average of all the previous values
of vt instead of their maximum. The resulting algorithm is very similar to ADAGRAD except for
normalization with smoothed gradients rather than actual gradients and can be shown to have similar
convergence as Adagrad.
5 Experiments
In this section, we present empirical results on both synthetic and real-world datasets. For our
experiments, we study the problem of multiclass classification using logistic regression and neural
networks, representing convex and nonconvex settings, respectively.
Synthetic Experiments: To demonstrate the convergence issue of ADAM, we first consider the
following simple convex setting inspired from our examples of non-convergence:
ft(X)
1010X,
—10X,
for t mod 101 = 1
otherwise,
with the constraint set F = [—1, 1]. We first observe that, similar to the examples of non-
convergence we have considered, the optimal solution is X = —1; thus, for convergence, we expect
the algorithms to converge to X = —1. For this sequence of functions, we investigate the regret and
the value of the iterate Xt for ADAM and AMSGRAD. To enable fair comparison, we set B1 = 0.9
and B2 = 0.99 for ADAM and AMSGRAD algorithm, which are typically the parameters settings
used for ADAM in practice. Figure 1 shows the average regret (Rt∕t) and value of the iterate (Xt) for
6
Published as a conference paper at ICLR 2018
Iterations
1000
2000 3000 4000
Iterations
Figure 2: Performance comparison of ADAM and AMSGRAD for logistic regression, feedforward neural
network and Cifarnet. The top row shows performance of Adam and AMSGrad on logistic regression
(left and center) and 1-hidden layer feedforward neural network (right) on MNIST. In the bottom row, the two
plots compare the training and test loss of Adam and AMSGrad with respect to the iterations for Cifarnet.
this problem. We first note that the average regret of ADAM does not converge to 0 with increasing
t. Furthermore, its iterates xt converge to x = 1, which unfortunately has the largest regret amongst
all points in the domain. On the other hand, the average regret of AMS GRAD converges to 0 and its
iterate converges to the optimal solution. Figure 1 also shows the stochastic optimization setting:
ft(x) =
1010x,
-10x,
with probability 0.01
otherwise.
Similar to the aforementioned online setting, the optimal solution for this problem is x = -1. Again,
we see that the iterate xt of ADAM converges to the highly suboptimal solution x = 1.
Logistic Regression: To investigate the performance of the algorithm on convex problems, we
compare AM S Grad with Adam on logistic regression problem. We use MNIST dataset for this
experiment, the classification is based on 784 dimensional image vector to one of the 10 class labels.
The step size parameter at is set to α∕√t for both ADAM and AMSGRAD in for our experiments,
consistent with the theory. We use a minibatch version of these algorithms with minibatch size set
to 128. We set β1 = 0.9 and β2 is chosen from the set {0.99, 0.999}, but they are fixed throughout
the experiment. The parameters α and β2 are chosen by grid search. We report the train and test
loss with respect to iterations in Figure 2. We can see that AMSGrad performs better than Adam
with respect to both train and test loss. We also observed that AM S Grad is relatively more robust
to parameter changes in comparison to Adam.
Neural Networks: For our first experiment, we trained a simple 1-hidden fully connected layer
neural network for the multiclass classification problem on MNIST. Similar to the previous experi-
ment, we use β1 = 0.9 and β2 is chosen from {0.99, 0.999}. We use a fully connected 100 rectified
linear units (ReLU) as the hidden layer for this experiment. Furthermore, we use constant αt = α
throughout all our experiments on neural networks. Such a parameter setting choice of Adam is
consistent with the ones typically used in the deep learning community for training neural networks.
A grid search is used to determine parameters that provides the best performance for the algorithm.
Finally, we consider the multiclass classification problem on the standard CIFAR-10 dataset, which
consists of 60,000 labeled examples of 32 × 32 images. We use CIFARNET, a convolutional neu-
ral network (CNN) with several layers of convolution, pooling and non-linear units, for training a
multiclass classifer for this problem. In particular, this architecture has 2 convolutional layers with
64 channels and kernel size of 6 × 6 followed by 2 fully connected layers of size 384 and 192.
The network uses 2 × 2 max pooling and layer response normalization between the convolutional
layers (Krizhevsky et al., 2012). A dropout layer with keep probability of 0.5 is applied in between
the fully connected layers (Srivastava et al., 2014). The minibatch size is also set to 128 similar
to previous experiments. The results for this problem are reported in Figure 2. The parameters for
Adam and AMSGrad are selected in a way similar to the previous experiments. We can see that
7
Published as a conference paper at ICLR 2018
AMS Grad performs considerably better than Adam on train loss and accuracy. Furthermore, this
performance gain also translates into good performance on test loss.
5.1	Extension: AdamNc algorithm
An alternative approach is to use an increasing schedule of β2 in ADAM. This approach, unlike
Algorithm 2 does not require changing the structure of ADAM but rather uses a non-constant β1 and
β2 . The pseudocode for the algorithm, ADAMNC, is provided in the appendix (Algorithm 3). We
show that by appropriate selection of β1t and β2t, we can achieve good convergence rates.
Theorem 5. Let {xt} and {vt} be the sequences obtainedfrom Algorithm 3, αt = ɑ/ʌ/t, βι = βn
and βιt ≤ βι for all t ∈ [T ]. Assume that F has bounded diameter D∞ and ∣∣Vft(x)k∞ ≤ G∞ for
allt ∈ [T] and x ∈ F. Furthermore, let {β2t} be such that the following conditions are satisfied:
1.	OT qPj=ι πk=jιβ2(t-k+i)(I—陶)j,i ≥ ι qPj=ι gjforSOme ζ > 0 and all t ∈ [T],
j ∈ [d].
1/2	1/2
7；	' ʃ	7；	' ʃ	_
2.	-,i^- ≥ α-1,i for all t ∈ {2,…，T} and i ∈ [d].
Then for xt generated using the ADAMNC (Algorithm 3), we have the following bound on the regret
2	d	2 T d	1/2	d
D	D∞	V 斤 1/2 , D∞	V「β1tvt,i	2ζ	Il
RT ≤ 20LJ 3 7TvT，i + 20-11)之 g 丁 + IW ∑ kg1:T，ik2.
The above result assumes selection of {(αt, β2t)} such that Γt 占 0 forall t ∈ {2, ∙ ∙ ∙ ,T}. However,
one can generalize the result to deal with the case where this constraint is violated as long as the
violation is not too large or frequent. Following is an immediate consequence of the above result.
Corollary 2. Suppose β1t = β1λt-1 and β2t = 1 - 1/t in Theorem 5, then we have
D∞ XX IHj ʃ I i , β1D∞ G∞	2	2ζ	χX∣∣,, TlL
2α(1-βι) ⅛ kg1：T，ik2 + 2(1-βι)(1- λ)2 + (T-W ⅛ 两1"回
The above corollary follows from a trivial fact that vt，i = Ptj=1 gj2，i/t for all i ∈ [d] when
β2t = 1 - 1/t. This corollary is interesting insofar that such a parameter setting effectively yields
a momentum based variant of Adagrad. Similar to Adagrad, the regret is data-dependent and
can be considerably better than O(√dT) regret of SGD when Pd=IIlgi：T，i k 2《 √dT (DUchi et al.,
2011). It is easy to generalize this result for setting similar settings of β2t. Similar to Corollary 1,
one can use a more modest decay of βιt = βι∕t and still ensure a data-dependent regret of O(√T).
6 Discussion
In this paper, we study exponential moving variants of Adagrad and identify an important flaw
in these algorithms which can lead to undesirable convergence behavior. We demonstrate these
problems through carefully constructed examples where RMSprop and Adam converge to highly
suboptimal solutions. In general, any algorithm that relies on an essentially fixed sized window of
past gradients to scale the gradient updates will suffer from this problem.
We proposed fixes to this problem by slightly modifying the algorithms, essentially endowing the
algorithms with a long-term memory of past gradients. These fixes retain the good practical perfor-
mance of the original algorithms, and in some cases actually show improvements.
The primary goal of this paper is to highlight the problems with popular exponential moving average
variants of Adagrad from a theoretical perspective. RMSprop and Adam have been immensely
successful in development of several state-of-the-art solutions for a wide range of problems. Thus,
it is important to understand their behavior in a rigorous manner and be aware of potential pitfalls
while using them in practice. We believe this paper is a first step in this direction and suggests good
design principles for faster and better stochastic optimization.
8
Published as a conference paper at ICLR 2018
References
Peter Auer and Claudio Gentile. Adaptive and self-confident on-line learning algorithms. In Pro-
Ceedings of the 13th Annual Conference on Learning Theory, pp. 107-117, 2000.
Nicolo Cesa-Bianchi, Alex Conconi, and ClaUdio Gentile. On the generalization ability of on-line
learning algorithms. IEEE Transactions on Information Theory, 50:2050-2057, 2004.
Timothy Dozat. Incorporating Nesterov MomentUm into Adam. In Proceedings of 4th International
Conference on Learning Representations, Workshop Track, 2016.
John C. DUchi, Elad Hazan, and Yoram Singer. Adaptive sUbgradient methods for online learning
and stochastic optimization. Journal of Machine Learning Research, 12:2121-2159, 2011.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In Proceedings
of 3rd International Conference on Learning Representations, 2015.
Alex Krizhevsky, Ilya SUtskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
lUtional neUral networks. In Advances in Neural Information Processing Systems 25, pp. 1097-
1105, 2012.
H. Brendan McMahan and Matthew J. Streeter. Adaptive boUnd optimization for online convex
optimization. In Proceedings of the 23rd Annual Conference On Learning Theory, pp. 244-256,
2010.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya SUtskever, and RUslan SalakhUtdinov.
DropoUt: A simple way to prevent neUral networks from overfitting. Journal of Machine Learning
Research, 15:1929-1958, 2014.
T. Tieleman and G. Hinton. RmsProp: Divide the gradient by a rUnning average of its recent mag-
nitUde. COURSERA: NeUral Networks for Machine Learning, 2012.
Matthew D. Zeiler. ADADELTA: An Adaptive Learning Rate Method. CoRR, abs/1212.5701, 2012.
Martin Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In
Proceedings of the 20th International Conference on Machine Learning, pp. 928-936, 2003.
9
Published as a conference paper at ICLR 2018
Appendix
A Proof of Theorem 1
Proof. We consider the setting where ft are linear functions and F = [-1, 1]. In particular, we
define the following function sequence:
Cx,
ft(x) =
-x,
for t mod 3 = 1
otherwise,
where C ≥ 2. For this function sequence, it is easy to see that the point x = -1 provides the
minimum regret. Without loss of generality, assume that the initial point is x1 = 1. This can
be assumed without any loss of generality because for any choice of initial point, we can always
translate the coordinate system such that the initial point is x1 = 1 in the new coordinate system
and then choose the sequence of functions as above in the new coordinate system. Also, since
the problem is one-dimensional, we drop indices representing coordinates from all quantities in
Algorithm 1. Consider the execution of Adam algorithm for this sequence of functions with
β1 = 0, β2
1α
1+C2 and αt = √t
where α < √1 - β2. Note that since gradients of these functions are bounded, F has bounded
L∞ diameter and β2∕√β2 < 1. Hence, the conditions on the parameters required for ADAM are
satisfied (refer to (Kingma & Ba, 2015) for more details).
Our main claim is that for iterates {xt }t∞=1 arising from the updates of ADAM, we have xt > 0 for
all t ∈ N and furthermore, x3t+1 = 1 for all t ∈ N∪ {0}. For proving this, we resort to the principle
of mathematical induction. Since x1 = 1, both the aforementioned conditions hold for the base
case. Suppose for some t ∈ N ∪ {0}, we have xi > 0 for all i ∈ [3t+1] and x3t+1 = 1. Our aim is
to prove that x3t+2 and x3t+3 are positive and x3t+4 = 1. We first observe that the gradients have
the following form:
C, for i mod 3 = 1
Pfi(X) = S 1 ʌ
-1, otherwise
From (3t + 1)th update of ADAM in Equation (1), we obtain
x3t+2 = x3t+1 -
αC
-/	二=1 —
p (3t + I)(β2v3t + (1 — β2)C2)
αC
p (3t + I)(β2v3t + (1 — β2)C2)
The equality follows from the induction hypothesis. We observe the following:
αC
αC
,	≤	,
p(3t + 1)(β2v3t + (1 - β2)c2)	p(3t + 1)(1 - β2)c2
α
=—/	== < 1.
，(3t + I)(I - β2)
(4)
The second inequality follows from the step size choice that α < √1 — β2. Therefore, We have
0 < X3t+2 < 1 and hence χ3t+2 = X3t+2 > 0. Furthermore, after the (3t + 2)th and (3t + 3)th
updates of Adam in Equation (1), we have the following:
x3t+3 = x3t+2 +
X3t+4 = x3t+3 +
α
p(3t + 2)(β2v3t+1 + (1 — β2))
α
P(3t + 3)(β2v3t+2 + (1 - β2))
Since x3t+2 > 0, it is easy to see that x3t+3 > 0. To complete the proof, we need to show
that χ3t+4 = 1. In order to prove this claim, we show that X3t+4 ≥ 1, which readily translates
to χ3t+4 = 1 because χ3t+4 = ∏f(X3t+4) and F = [—1,1] here ∏f is the simple Euclidean
projection (note that in one-dimension, ∏f,√v = ∏f). We observe the following:
X3t+4 = min(x3t+3, 1) +
α
P(3t + 3)(β2v3t+2 + (1 - β2))
The above equality is due to the fact that X3t+3 > 0 and property of projection operation onto the
set F = [—1, 1]. We consider the following two cases:
10
Published as a conference paper at ICLR 2018
1.	Suppose X3t+3 ≥ 1, then it is easy to see from the above equality that X3t+4 > 1.
2.	Suppose X3t+3 < 1, then We have the following:
α
+	+	P(3t + 3)(β2V3t+2 + (1- β2))
αα
=x3t+2 +	-Z	=	+ -Z	=
P (3t +	2)(β2v3t+1	+ (1 — β2)) p (3t +	3)(β2v3t+2	+ (1 — β2))
αC	α
=1----,	二 +-.
P (3t + 1)(β2v3t + (1 — β2)C2)	p (3t + 2)(β2v3t+1 + (1 — β2))
α
P(3t + 3)(β2v3t+2 + (1 - β2))
The third equality is due to the fact that χ3t+2 = X3t+2. Thus, to prove X3t+4 > 1, it is
enough to the prove:
αC	α
,	≤ t
ʌ/ (3t + 1)(β2v3t + (1 — β2)C2)	a/ (3t + 2)(β2v3t+1 + (1 — β2))
'-----------{z----------}
T1
α
p (3t + 3)(β2v3t+2 + (1 — β2))
'--------------{z-----------}
T2
We have the following bound on term T1 from Equation (4):
Ti ≤ -ʒ=====
p (3t +1)(1 — β2))
Furthermore, we lower bound T2 in the following manner:
p(3t + 2)(β2v3t+1 + (1 — β2))	p(3t + 3)(β2v3t+2 + (1 — β2))
≥ L α	( ɪ + ɪ )
Pβ2c2 + (1 — β2) ∖√3t + 2	√3t +3J
≥	, α	(,	1	+ ,	1	_!
PβC2 + (1 一伪) 卜p2(3t+1)	p2(3t+ I) J
=/	√2α	=	, α = ≥ Ti.
P(3t + 1)(β2C2 + (1 - β2))	p(3t + 1)(1 — β2 )
(5)
(6)
The first inequality is due to the fact that vt ≤ C2 for all t ∈ N. The last inequality follows
from inequality in Equation (5). The last equality is due to following fact:

β2C2 + (1 — β2)
2
71-^2
for the choice of β2 = 1/(1 + C2). Therefore, we have T2 ≥ Ti and hence, X3t+4 ≥ 1.
Therefore, from both the cases, we see that x3t+4 = 1. Therefore, by the principle of mathematical
induction it holds for all t ∈ N ∪ {0}. Thus, we have
f3t+i (x3t+i)+f3t+2 (x3t+2)+f3t+2 (x3t+2)—f3t+i (—1)—f3t+2 (—1)—f3t+3 (—1) ≥ 2C—4 = 2C —4.
Therefore, for every 3 steps, ADAM suffers a regret of at least 2C — 4. More specifically, RT ≥
(2C — 4)T /3. Since C ≥ 2, this regret can be very large and furthermore, RT /T 9 0 as T → ∞,
which completes the proof.	口
11
Published as a conference paper at ICLR 2018
B Proof of Theorem 2
Proof. The proof generalizes the optimization setting used in Theorem 1. Throughout the proof,
We assume βι < √β2, which is also a condition (Kingma & Ba, 2015) assume in their paper. In
this proof, we consider the setting where ft are linear functions and F = [-1, 1]. In particular, we
define the following function sequence:
Cx,
ft(x) =
-x,
for t mod C = 1
otherwise,
where C ∈ N, C mod 2 = 0 satisfies the following:
(1 - β1)β1C-1C ≤ 1-β1C-1,
β(C-2"2C2 ≤ 1,
3(1-β1) (1 + γ(l-γc-1) ʌ + ⅛±1 <C	⑺
2√τ≡w V + -i-^~+ + T-IT H,	(7)
where Y = βι∕√β2 < 1. It is not hard to see that these conditions hold for large constant C
that depends on β1 and β2 . Since the problem is one-dimensional, we drop indices representing
coordinates from all quantities in Algorithm 1. For this function sequence, it is easy to see that
the point x = -1 provides the minimum regret since C ≥ 2. Furthermore, the gradients have the
following form:
C, for t mod C = 1
Pfi(X) = S 1 ʌ
-1, otherwise
Our first observation is that mkC ≤ 0 for all k ∈ N ∪ {0}. For k = 0, this holds trivially due to our
initialization. For the general case, observe the following:
mkc+c = -(1 — βι) — (1 — βι )βι — ••• 一 (1 - βι)βC-2 + (1 — βι)βC-1C + β(C mkc (8)
= -(1 -β1C -1)+(1 -β1)β1C -1C+β1CmkC.	(9)
If mkC ≤ 0, it can be easily shown that mkC+C ≤ 0 for our selection ofC in Equation (7) by using
the principle of mathematical induction. With this observation we continue to the main part of the
proof. Let T0 be such that t + C ≤ τ2t for all t ≥ T0 where τ ≤ 3/2. All our analysis focuses on
iterations t ≥ T0. Note that any regret before T0 is just a constant because T0 is independent of T
and thus, the average regret is negligible as T → ∞. Consider an iterate at time step t of the form
kC after T0. Our claim is that
xt+C ≥ min{xt + ct, 1}
(10)
for some ct > 0. To see this, consider the updates of ADAM for the particular sequence of functions
we considered are:
α (1 - β()C + β(mt
xt+1 = πF Vt - √t p(1-β2)C2 + β2Vt )
α -(1 - β( ) + β(mt+i-(
xt+i = πF L1 - √7TT-i √(1 - β2)+β2Vt+i-1
For i ∈ {2,…，C}, we use the following notation:
α (1 — β( )C + β(mt
√t √(1 - β2)c2 + 12V
α	-(I - βI) + β1mt+i for i ∈ {1
√+ √(1-β2) + β2Vt+i	I
for i ∈ {2,…，C}.
,C-1}.
Note that if δt+j ≥ 0 for some j ∈ {1,…，C - 1} then δt+ι ≥ 0 for all l ∈ {j,…，C - 1}. This
follows from the fact that the gradient is negative for all time steps i ∈ {2,…，C}. Using Lemma 6
for {xt+i,…,xt+c} and {δt,…,δt+c-(}, we have the following:
)
xt+C ≥ min
t+C -1
1,xt+	δi
i=t
12
Published as a conference paper at ICLR 2018
Let i0 = C/2. In order to prove our claim in Equation (10), we need to prove the following:
t+C-1
δ = X δi > 0.
i=t
To this end, we observe the following:
t+C-1	C-1
X δi = X -
i=t+1	i=1
α -(I - βI) + β1mt+i
√+ √(1 - β2) + β不
X	α -(I- βI) + (I- βι) [Pj=1 βj(-I)i+(I- βI)βi 1C + βimt
=√t + i - 1	√(1 - β2)+ β2vt+i-i
〉X α (1 - βι) + (1 - βι) [Pj=1 βji - (1 - βι)βi-1C
≥ = √t + i - 1	√(1 - β2) + β2vt+i-i
〉X ʌ (1-βι) + (1-βι)[pj=1 βj
― = T√	√(1 - β2) + β2Vt+i-1
α (1-βι) + (1-βι)[Pj=1 βj]
T√t ~√(1 - β2) + β2Vt+~l-
X α	(I - βι)βi 1C
i=2 √t q(1 - 肉)+Ierl(I - 的)。2
C
≥X
i=2
α γ(1 - βι)(1 - YCT)
√ (I - Y) √(1 - β2)
≥ α	(C -i0 - βi0-∖ - α γ(1-βι)([-γc])
-τ√t√T+β2〈	1 - βι)	√t (1 - γ)√(1 - β2)
The first equality follows from the definition of mt+i+1. The first inequality follows from the fact
that mt ≤ 0 when tmod C =0 (see Equation (9) and arguments based on it). The second inequality
follows from the definition of τ that t+ C ≤ τ2 tfor all t≥ T0. The third inequality is due to the
fact that vt+i-1 ≥ (1 - β2 )β2i-2C2. The last inequality follows from our choice of C. The fourth
inequality is due to the following upper bound that applies for all i0 ≤ i ≤ C :
t+i-1
vt+i-1	=(1 - β2) X β2t+i-1-jgj2
j=1
k	t+i-1
≤ (1 -β2) Xβ2t+i-1-hCC2+ X β2t+i-1-j
h=1	j=1
k-1
≤ (1 - β2) βi0-1C2 XβhC + r-r
h=0	1 - β2
≤ (1 - β2 )
βi0-1C2 .	1
1 — βC	1 - β
≤ 2.
The first inequality follows from online problem setting for the counter-example i.e., gradient is C
once every C iterations and -1 for the rest. The last inequality follows from the fact that β2i0-1C2 ≤
13
Published as a conference paper at ICLR 2018
1 and β2C ≤ β2 . Furthermore, from the above inequality, we have
t+C-1
X δi ≥ δt +	「 ɑ
士	T √t√1 + β2
α Y(I - βI)(I - YCT)
√t (1 -Y)PT-W^
α (I - βι)C + βιmt + α (C i	β1 1 !
√t √(i - β2)c2 + β2vt τ√t√rτβ2 \ — — 1 - β1)
α Y(1 - β1)(1 - YC-I)
——...-------,	―
Vt (1 - Y)√(1 - β2)
α (I - β1)C	.____α_____ (C - i - βi 1 !__α Y(I - β1 )(1 - yC-1 )
飞 √(1 - β2)c2	τ√t√r+~β2 \ — ― 1 - βι) √ √t (1 - Y)√r-βy
C - β?T - 3(1- βι) (1 + Y(1- YCT) M = j
3	1 - βι	2√1 - β2 V 1 - Y ) √	√t
Note that from our choice of C, it is easy to see that λ ≥ 0. Also, observe that λ is independent of
t. Thus, xt+c ≥ min{1, Xt + λ/√t}. From this fact, We also see the following:
1.	If xt = 1, then xt+C = 1 for all t ≥ T 0 such that t mod C = 0.
2.	There exists constant T10 ≥ T 0 such that xT0 = 1 where T10 mod C = 0.
The first point simply follows from the relation xt+c ≥ min{1, Xt + λ∕√7}. The second point is
due to divergent nature of the sum P= 1 / √t. Therefore, we have
CC
X f(kC+i) (xkC+i) - X f(kC+i) (-1) ≥ 2C - 2(C - 1) = 2.
i=1	i=1
where kC ≥ T10 . Thus, when t ≥ T10, for every C steps, ADAM suffers a regret of at least 2. More
specifically, RT ≥ 2(T - T0)/C. Thus, RT/T 9 0 as T → ∞, which completes the proof. □
C Proof of Theorem 3
Proof. Let δ be an arbitrary small positive constant, and C be a large enough constant chosen as a
function of β1 , β2 , δ that will be determined in the proof.
Consider the following one dimensional stochastic optimization setting over the domain [-1, 1]. At
each time step t, the function ft(x) is chosen i.i.d. as follows:
ft(x)
{Cx with probability P := CC+δ1
-x with probability 1 - p
The expected function is F(x) = δx; thus the optimum point over [-1, 1] is x? = -1. At each time
step t the gradient gt equals C with probability p and -1 with probability 1 -p. Thus, the step taken
by Adam is
∆ = -αt(β1mt-1 + (1 - βι)gt)
√β2vt-1 + (1 - β2)g2
We now show that for a large enough constant C, E[∆t] ≥ 0, which implies that the ADAM’s steps
keep drifting away from the optimal solution x? = -1.
Lemma 1. For a large enough constant C (as a function of β1, β2, δ), we have E[∆t] ≥ 0.
14
Published as a conference paper at ICLR 2018
Proof. Let Et[∙] denote expectation conditioned on all randomness UP to and including time t - 1.
Taking conditional expectation of the step, we have
ɪEt∆t] = p ∙ Temt-1 + (I - βI)C) +(1 - P) ∙ Telmt- - (I - βI))
αt	pβ2vt-1 + (1 - β2)c2	pβ2vt-1 + (1 — β2
-(βlmt-1 + (I - BI)C) ∣∕1 ʌ	-βlmt-1	Ifl 1	1 - βl
—/	=—+(1 — P) • —/	+(1 — p) • —/
pβ2vt-1 + (1 - β2)C2	pβ2vt-1 + (1 - β2)	pβ2vt-1 + (1 - β2)
-----------V---------}	'--------{--------}	'--------{--------}
T1	T2	T3
(11)
We will bound the expectation of the terms T1 , T2 and T3 above separately.
First, for T1, we have
-(β1C +(I- βι)c)、	1
T 1 ≥ -----,	--- ≥-----, 二.
一	P(1 - β2)C2	— √τ-w
(12)
Next, We bound E[T2]. Define k = dlOg(C+β1) ]. This choice of k ensures that βkC ≤ 1 - βk. Now,
note that
t-1
mt-1 = (1 -β1 )Xβ1t-1-igi.
i=1
Let E denote the event that for every i = t - 1, t - 2, . . . , max{t - k, 1}, gi = -1. Note that
Pr[E] ≥ 1 - kP. Assuming E happens, we can bound mt-1 as follows:
t-1	max{t-k,1}-1
mt-1 ≤ (1-β1)	X	βt-1-i∙-1+(1-βι)	X	βt-1-i∙C ≤-(1-βk)+βkC ≤ 0,
i=max{t-k,1}	i=1
and so T2 ≥ 0.
With probability at most kP, the event E doesn’t happen. In this case, we bound T2 as follows. We
first bound mt-1 in terms of vt-1 using the Cauchy-Schwarz inequality as follows:
t-1	1	"
mt-1=(1-β1 )Xβ1t-1-igi≤(1-β1 )	Pit=-11β2t-1-igi2	Pit=-11
i=1
t-1-i
≤ (1 - β1 )
β2
(1 - β2)(β2 - β2)
|
{z
A
Thus, vt-1 ≥ mt2-1/A2. Thus, we have
-β1mt-1	≥	-β1 Imt-Il	=	-β1(1 - β1)
pβ2vt-1 + (1 - β2)	qβ2(m2-1∕A2)	p(1 - β2)(β2 - β2)
Hence, we have
E[T2] ≥ 0 ∙ (1 — kp) +
-β1(1 - β1)
p(1 - β2)(β2 - β2)
• kp
-βι(1 - βι)kp
p(1 - β2)(β2 - β2)
(13)
Finally, we lower bound E[T3] using Jensen,s inequality applied to the convex function √1χ:
E[T3] ≥	/ (I - β1)	≥	/ (I - β1)	-.
一 √β2E[vt-i] + (1 - β2) — √β2(1 + δ)C2 + (1 - β2)
The last inequality follows by using the facts vt-1 = (1 - β2 ) Pit=-11 β2t-1-igi2, and the random
variables g12 , g22 , . . . , gt2-1 are i.i.d., and so
E[vt-1] = (1-β2t-1 )E[g12] = (1-β2t-1 )(C2p+(1-p)) = (1-β2t-1 )(1+δ )C-δ ≤ (1+δ)C. (14)
15
Published as a conference paper at ICLR 2018
Combining the bounds in (12), (13), and (14) in the expression for Adam’s step, (11), and plugging
in the values of the parameters k and p we get the following lower bound on E[∆t]:
- 1 + δ ∙ ( , 1	+ -β1(1 - βI) dlOg(C+β1)e ʌ + (1 - 1 + δ ) ∙	,	(1 - βι)
C + 1	]√1	- β	p∕(1	- β2)(β2	- β2)	y ∖ C +1 J	p∕β2(1 + δ)C	+ (1 -	β2)
It is evident that for C large enough (as a function of δ, β1 , β2), the above expression can be made
non-negative.	□
For the sake of simplicity, let us assume, as is routinely done in practice, that we are using a version
of ADAM that doesn’t perform any projection steps2. Then the lemma implies that E[xt+1] ≥ E[xt].
Via a simple induction, we conclude that E[xt] ≥ x1 for all t. Thus, if we assume that the starting
point x1 ≥ 0, then E[xt] ≥ 0. Since F is a monotonically increasing function, we have E[F (xt)] ≥
F(0) = 0, whereas F (-1) = -δ. Thus the expected suboptimality gap is always δ > 0, which
implies that ADAM doesn't converge to the optimal solution.	□
D Proof of Theorem 4
The proof of Theorem 4 presented below is along the lines of the Theorem 4.1 in (Kingma &
Ba, 2015) which provides a claim of convergence for Adam. As our examples showing non-
convergence of Adam indicate, the proof in (Kingma & Ba, 2015) has problems. The main issue in
their proof is the incorrect assumption that Γt defined in their equation (3) is positive semidefinite,
and we also identified problems in lemmas 10.3 and 10.4 in their paper. The following proof fixes
these issues and provides a proof of convergence for AMSGrad.
Proof. We begin with the following observation:
xt+1 = ∏f√^(Xt - atVtT/2mt) = min IlVt1/4(X - (Xt - aM-"mt))k.
Furthermore, nʃ √^(x*) = x* for all x* ∈ F. In this proof, We will use x* to denote the ith
coordinate of x*. Using Lemma4 with uι = χt+ι and u2 = x*, we have the following:
k%"(xt+ι - x*)k2 ≤ k%1"(Xt- ɑt%-"mt - x*)∣∣2
=∣Vt1/4(Xt- x*)k2 + a2∣∣VtT∕4mtk2 - 2athmt,Xt - x*i
=k Vt"4 (xt - x*)k2 + a2k Vt 1/4 mtk2 - 2at hβ1tmt-1 + (1 - β1t)gt, xt - x*i
Rearranging the above inequality, we have
hgt,xt-x*i≤ 2at(11-βιt)
1
- 2at(1 - β1t)
U 匕1/4(Xt- x*)k2-k 匕1/4(xt+i- X*)k2]
+ 1 β1t	hmt-i,xt - x*i
1 - β1t
at
2(1 - β1t)
陀-1/4mtk2
[∣M"(xt - x*)k2 -∣M”(xt+ι - x*)k[ + 2(1 atβt) 陀-1/4mtk2
βlt
2(1 - β1t)
at∣M-" mt-ik2 +
βιt
2at(1 - β1t)
IM1/4(xt-x*)k2.
(15)
+
+
The second inequality follows from simple application of Cauchy-Schwarz and Young’s inequality.
We now use the standard approach of bounding the regret at each step using convexity of the function
2Projections can be easily handled with a little bit of work but the analysis becomes more messy.
16
Published as a conference paper at ICLR 2018
ft in the following manner:
TT
X ft(Xt)- ft(X) ≤ χhgt,xt- x*i
T
≤ X ?	) [k%"(xt -x*)k2 -kVt1/4(Xt+i -x*)k2i +	αt	kVt-1/4mtk
t=1 2αt(1 - β1t)	t	t	2(1 - β1t)	t
βιt
2(I- βIt)
αt∣M-"mt-ik2 +
βιt
2αt(1 - βIt)
-x*)k2
(16)
The first inequality is due to convexity of function ft. The second inequality follows from the bound
in Equation (15). For further bounding this inequality, we need the following intermediate result.
Lemma 2. For the parameter settings and conditions assumed in Theorem 4, we have
T
X αt∣MT∕4mtk2 ≤
t=1
α √1 + log T
(1 - β1 )(1 - Y)P(I -尸2)
d
X kg1:T,ik2
i=1
Proof. We start with the following:
T	T-1	d 2
X 以花-"『=X "5+αTX Pl
T-1
≤ X atIlVtT/4mtk2 + ατ
t=1
X mT,i
=√vTi
T-1	d
≤ X atIMT/4mtk2 + a X
t=1	i=1
(PT=ι(1-βj )∏T-jβi(τ-k+i)gj,i )2
qτ((1 - β2) PT=1 βT-jg2,i)
The first inequality follows from the definition of VT,i, which is maximum of all vτ,i until the current
time step. The second inequality follows from the update rule of Algorithm 2. We further bound the
above inequality in the following manner:
+
T	T-1	d
X atkVt-1/4mtk2 ≤ X at∣M-1∕4mtk2 + a X
t=1	t=1	i=1
(PT=I ∏T-jβl(T-k+1))(PT=1 ∏T-jβl(T-k+1)gj,i)
qτ ((1-β2) pT=ι βτ-gj,i)
T-1	d
≤ X at 陀τ∕4mtk2 + a X
t=1	i=1
T-1
≤ X以陀-1/4口『+
t=1
(PT=1 βT-j )(PT = 1 βT-j g2,i)
qτ ((1-β2) PT=I βτ-g2,i)
dT
XX
i=1 j =1
βT -j gj,i
qβT-%
T-1
≤ X atk-mtk2 +
t=1
d
a
1 - βι 工
1 i=1
T-1
≤ X atk%τ∕4mtk2 +
t=1
dT
XX YT-jM∣
i=1 j =1
(17)
The first inequality follows from Cauchy-Schwarz inequality. The second inequality is due to the
fact that β1k ≤ β1 for all k ∈ [T]. The third inequality follows from the inequality PjT=1 β1T -j ≤
1/(1 - β1 ). By using similar upper bounds for all time steps, the quantity in Equation (17) can
17
Published as a conference paper at ICLR 2018
further be bounded as follows:
T
X αt∣L4mtk2
t=1
T	dt
≤X —α	X X YjjM
t=1(I- βI)Pt(I- β) i=1 j=1	,
dT	t
-----α	XX 上 X Yt-j M
(i-βι )PO-127 士 士 √ j=1
α
(I - βI) P(1 - β2)
d T	T j-t	d T
≤ (1-βι)pɪ-ɪiXX lgt,i| X W ≤ (1 -βι)P0-12) XX lgt,i| (1-Y)√
_________α_______ x II II X 1^ _____2 1 + log T_ x II II
一(i-βι)(1-Y)PT-βj iyE:TMl2t A t - (1 - βι)(i - Y)p1-β2) "E"12
The third inequality follows from the fact that PjT=t Yj-t ≤ 1/(1 - Y). The fourth inequality is
due to simple application of Cauchy-Schwarz inequality. The final inequality is due to the following
bound on harmonic sum: PtT=1 1/t ≤ (1 + logT). This completes the proof of the lemma.
We now return to the proof of Theorem 4. Using the above lemma in Equation (16) , we have:
TT
Xft(xt) - ft(x*) ≤ X 2 a 8 )[∣M1∕4(xt - x*)k2 -IM 1∕4(xt+ι - x*)k[
t=1	t=1 2αt(1 - β1t)
+
201IM" (χt-x* )k2
α √1 + log T
(1 - β1)2 (1 - Y)P(I -伪)
d
Ig1:T,iI2
i=1
+
- 2αι(1 - βι)
T
M/4(χi*)k2 + 2O→1) X
IM1∕4(xt-x*)k2	k%1∕4(xt-x*)k2
αt
αt-1
T
+X
t=1
β1t
2αt(1 - β1)
IM"
-χ*)k2
α √1+log T
(1 - βl)2(1 - Y)P(I -尸2)
d
Ig1:T,i I2
i=1
1
—
+
d	Td
J X v1/i"if*)2+J X X(
xt,i - xi)2
1∕2	1∕2
tt,j	- vt-1,i
αt	αt-1
1	^X ∕β1t(xt,i - Xxl ?Gtli
+ 2(r-β) t=1 ⅛1	α
α √1+log T
(I -尸1)2(1 - Y)P(1 -尸2)
d
Ig1:T,i I2 .
i=1
(18)
+
The first inequality and second inequality use the fact that β1t ≤ β1. In order to further simplify the
bound in Equation (18), We need to use telescopic sum. We observe that, by definition of Vt,i, We
have
1∕2	1∕2
VtL ≥ vt-1,i
αt	αt-1
Using the L∞ bound on the feasible region and making use of the above property in Equation (18),
We have:
T	d	Td
X ft(χt) - ft(χ*) ≤ 2O1⅛1) XvYi2D∞+」X X D∞
v
1∕2
—
v
1∕2
t-1,i
αt αt-1
1 X X D∞βιtV1,/2
2TF L ⅛ αt
+
α √1 + log T
(1 - βl)2(1 - Y)P(1 - β2)
d
X Ig1:T,iI2
i=1
D∞
2ατ(1 - βι)
d
X vT∕i2 +
i=1
D∞
2(1 - βι)
Td
XX
t=1 i=1
+
α √1+log T
(1 - βl)2(1 - Y)P(I -尸2)
d
Ig1:T,i I2.
i=1
18
Published as a conference paper at ICLR 2018
Algorithm 3 ADAMNC
Input: x1 ∈ F, step size {αt > 0}tT=1, {(β1t, β2t)}tT=1
Set m0 = 0 and v0 = 0
for t = 1 to T do
gt = Nft(Xt)
mt = β1tmt-1 + (1 - β1t )gt
Vt = β2tVt-1 + (1 — β2t)g2 and Vt = diag(vt)
xt+1 = ∏F,√vt (Xt — atmt∕√Vt)
end for
The equality follows from simple telescopic sum, which yields the desired result. One important
point to note here is that the regret of AMSGRAD can be bounded by O(G∞ √T). This can be easily
seen from the proof of the aforementioned lemma where in the analysis the term PT=I ∣gt,i∣∕√t can
also be bounded by O(G∞√T). Thus, the regret of AMSGRAD is upper bounded by minimum of
O(G∞Tt) and the bound in the Theorem 4 and therefore, the worst case dependence of regret on
T in our case is O(√T).	□
E Proof of Theorem 5
Proof. Using similar argument to proof of Theorem 4 until Equation (15), we have the following
hgt,xt -x*i ≤ 2α(1-βt) [k匕1/4(xt -x*)k2 Tk1∕4(xt+1 -x*)k2i + 2(1 αtβt) kV-14mtk2
+ , β1t 、αt∣∣VT"mt-ik2 + —性~-∣∣V1/4(Xt - x*)∣2.
+ 2(1-βιt) tk t t 1k +2αt(1-βιt)k t ( t 川
(19)
The second inequality follows from simple application of Cauchy-Schwarz and Young’s inequality.
We now use the standard approach of bounding the regret at each step using convexity of the function
ft in the following manner:
TT
Xft(Xt)- ft(X*) ≤ χhgt,xt — x*i
T
≤ X - 、[∣k"(xt — x*)k2 -Ik"(xt+1 — x*)k2i + αt	IkT/4mtk2
t=1 2αt(1 - β1t)	t	t	2(1 - β1t)	t
+ -τ-^β1t--αt∣Vtτ∕4mt-i∣∣2 + —性~-∣∣V1/4(Xt — x*)∣2 .
+ 2(1 — βιt) tk t t 1k +2ɑt(1 — βιt)k t ( t 川
(20)
The inequalities follow due to convexity of function ft and Equation (19). For further bounding this
inequality, we need the following intermediate result.
Lemma 3. For the parameter settings and conditions assumed in Theorem 5, we have
T
Xαtkv-1∕4mtIl2 ≤
t=1
2Z
(1 — βι)2
d
Ig1:T,iI2.
i=1
Proof. We start with the following:
T	T-1	d 2
X atl∣vΓ1∕4mtll2 = X αt∣∣vtT∕4mtll2 + ατ X √v=
\-	∣∣τ^-1∕4	∣∣2 l	(Pj=I(I- β1j)πk=jβ1(T-k+1)gj,i)2
≤ * X atkVt	mtk+ ατ X q(Pτ=1 ∏τ-jβ2(T-k + 1)(1—β2j 砥)
19
Published as a conference paper at ICLR 2018
The first inequality follows from the update rule of Algorithm 2. We further bound the above in-
equality in the following manner:
T-1
X αtkVt-"mtk2 ≤ X αtkVt-"mtk2 + ατ X
t=1
t=1
i=1
(PT=I ∏T=jβl(T-k+1))(PT=i ∏T=jβl(T-k+1)gj,i)
qj ∏T=jβ2(T-k+1)(1-β2j Wi
T
d
/G	U./4	“2, X	(PT=I βT-)(PT=i β厂j)
≤ TatkVt	mtk + a» r~^ Ti	。
t=1	i=1 VzPj = I πk=1 β2(T-k + 1)(1 - β2j )gj,i
≤ V atkVtτ∕4mtk2 + X	PT=I βT-jj	二
t=1	1 - β1 i=1 qj ∏T=jβ2(T-k+1)(1-β2j )g2,i
≤ Σ atk「mtk2 + τ⅛ X PqPeTj
t=1	1 i=1	j=1 gj2，i
T-1	d T	T-j2
≤ X αtkVτ∕4mtk2 +	XX	β1	gj，i
≤	1-βι ⅛ M qj^
(21)
The first inequality follows from Cauchy-Schwarz inequality. The second inequality is due to the
fact that β1k ≤ β1 for all k ∈ [T]. The third inequality follows from the inequality PjT=1 β1T-j≤
1/(1 - β1 ). Using similar argument for all time steps, the quantity in Equation (21) can be bounded
as follows:
X IlVT/4 I∣2< Z	X X PT=Oj β1 gj，i
XɑtkVt	mtk≤ EXXMZ
Z Z G G	g2，i	Z	2Z	…Il
— di)2 g Σ qPΓ-Γι ―(1-βl)2 之 kg1"2.
The final inequality is due to Lemma 5. This completes the proof of the lemma.
Using the above lemma in Equation (20) , we have:
T
T
1
Eft(Xt)- ft(χ*) ≤E
t=1
t=1
2α1(1 - β1t)
IVt1/4(Xt - X*)I2 - IVt1/4(Xt+1 - X*)I2
β1t
2αt(1 - β1t)
k匕1/4(Xt- x*)k2
- 2α1(1 - βI)
T
M/4(X—)k2 + 2^ X
T
+X
t=1
β1t
2αt(1 - β1)
kVt1/4(xt -
In1/4(Xt- x*)k2
x*)k2
d	Td
201(⅛) Xa) + 2(1⅛ XX(
i=1	t=2 i=1
Td
十布-而X X
αt
d
kg1:T,i k2
i=1
k匕Y4(xt-1- x*)k2
αt
+ (1 "β1)3 X kg1：T，ik2
Xt,i - Xi*)2
1/2
vt,i
αt
1/2
v-1,i
αt-1
β1t(xt,i - χ*)2v1,/2 +
αt
2ζ
(1 - β1)3
d
XIg1:T,iI2.	(22)
i=1
+
+ f
1
—
—
The first inequality and second inequality use the fact that β1t ≤ β1. Furthermore, from the theorem
statement, we know that that {(αt.β2t)} are selected such that the following holds:
1/2	1/2
vt，i	vt-1，i
----≥ --------.
αt	αt-1
20
Published as a conference paper at ICLR 2018
Using the L∞ bound on the feasible region and making use of the above property in Equation (22),
we have:
T	d	Td
X ft(χt) - ft(χ*) ≤ 2αi(⅛ X v1? D∞+2(1⅛ X X D∞
1/2
t,i
1/2
t-1,i
αt	αt-1
l 1 X X D∞βιtv1,/2
2(1-βι) L ⅛ S
2Z
(1 - βι)3
d
X kg1:T,i k2
i=1
D∞	X 1/2 +	D∞	X X βltvt,/ +	2Z
2ατ(1 - βι) = T +2(1 - βι) = =	at	+ (1 -员)3
The equality follows from simple telescopic sum, which yields the desired result.
F Proof of Theorem 6
Theorem 6. For any > 0, ADAM with the modified update in Equation (3) and with parameter
setting such that all the conditions in (Kingma & Ba, 2015) are satisfied can have non-zero average
regret i.e., RT/T 9 0 as T → ∞ for convex {fi}∞=ι with bounded gradients on a feasible set F
having bounded D∞ diameter.
Proof. Let Us first consider the case where E = 1 (in fact, the same setting works for any E ≤ 1). The
general E case can be proved by simply rescaling the sequence of functions by a factor of √E. We
show that the same optimization setting in Theorem 1 where ft are linear fUnctions andF = [-1, 1],
hence, we only discuss the details that differ from the proof of Theorem 1. In particular, we define
the following function sequence:
ft(x)
Cx,
-x,
for t mod 3 = 1
otherwise,
where C ≥ 2. Similar to the proof of Theorem 1, we assume that the initial point is x1 = 1 and the
parameters are:
2a
βl=0,β2 =(1 + C2)C2 and αt = √t
where a < √1 - β2. The proof essentially follows along the lines of that of Theorem 1 and is
through principle of mathematical induction. Our aim is to prove that x3t+2 and x3t+3 are positive
and x3t+4 = 1. The base case holds trivially. Suppose for some t ∈ N ∪ {0}, we have xi > 0 for all
i ∈ [3t+ 1] and x3t+1 = 1. For (3t+ 1)th update, the only change from the update ofin Equation (1)
is the additional E in the denominator i.e., we have
x3t+2 = x3t+1 -
αC
P(3t + 1)(β2v3t + (1 - β2)C2 + E)
aC
≥ 1 ——/	---- ≥ 0.
P(3t + 1)(β2v3t + (1 - β2)C2)
The last inequality follows by simply dropping v3t term and using the relation that a < √1--β2.
Therefore, We have 0 < X3t+2 < 1 and hence χ3t+2 = X3t+2 > 0. Furthermore, after the (3t + 2)th
and (3t + 3)th updates of ADAM in Equation (1), we have the following:
x3t+3 = x3t+2 +
a
p(3t + 2)(β2v3t+1 + (1 - β2) + E)
x3t+4 = x3t+3 +
a
p(3t + 3)(β2v3t+2 + (1 - β2) + E)
Since x3t+2 > 0, it is easy to see that x3t+3 > 0. To complete the proof, we need to show
that x3t+4 = 1. The only change here from the proof of Theorem 1 is that we need to show the
v
—
□
21
Published as a conference paper at ICLR 2018
following:
αα
p(3t + 2)(β2v3t+1 + (1 - β2) + e)	p(3t + 3)(β2v3t+2 + (1 - β2) + ∈)
≥ L	。	( ɪ + ɪ )
pβ2 C2	+	(1	— β2)+ e	∖ √3t + 2	√3t + 3 )
≥ L	α	( ɪ	I	ɪ	!
pβ2C2	+	(1	- β2)+ e	k p2(3t +	1) p2(3t +	1) J
√2a	αC
P(3t + 1)(β2C2 + (1 - β2) + E)	P(3t + 1)((1 - β2)C2 + E)
αC
≥	)	.
P(3t + 1)(β2v3t + (1 - β2)C2 + E)
(23)
The first inequality is due to the fact that vt ≤ C2 for all t ∈ N. The last equality is due to following
fact:
r β2C +21- β2)=r1- 包+C2.
for the choice of β2=	2/[(1 + C2)C2] and E=	1. Therefore, we see that x3t+4 =	1. Therefore, by
the principle of mathematical induction it holds for all t ∈ N ∪ {0}. Thus, we have
f3t+1 (x3t+1) + f3t+2(x3t+2) + f3t+2(x3t+2) — f3t+1(—1) — f3t+2(—1) — f3t+3(—1) ≥ 2C — 4.
Therefore, for every 3 steps, ADAM suffers a regret of at least 2C — 4. More specifically, RT ≥
(2C — 4)T /3. Since C ≥ 2, this regret can be very large and furthermore, RT /T 9 0 as T → ∞,
which completes the proof of the case where E= 1. For the general E case, we consider the following
sequence of functions:
ft(x)
(C √χ,
[-√ex,
for t mod 3= 1
otherwise,
The functions are essentially rescaled in a manner so that the resultant updates of Adam correspond
to the one in the optimization setting described above. Using essentially the same argument as above,
it is easy to show that the regret RT ≥ (2C 一 4)√T∕3 and thus, the average regret is non-zero
asymptotically, which completes the proof.	□
G Auxiliary Lemma
Lemma 4 ((McMahan & Streeter, 2010)). For any Q ∈ S+d and convex feasible set F ⊂ Rd,
suppose uι = minχ∈F ||Q1/2(x —zι)k andu2 = minχ∈F ||Q1/2(x —z2)k then we have kQ1/2(ui —
u2)k ≤ kQ1/2(z1 一 z2)k.
Proof. We provide the proof here for completeness. Since u1 = minx∈F |Q1/2(x — z1)| and
u2 = minx∈F |Q1/2(x — z2)| and from the property of projection operator we have the following:
hz1 — u1, Q(z2 — z1)i ≥ 0 and hz2 — u2, Q(z1 — z2)i ≥ 0.
Combining the above inequalities, we have
hu2 —	u1,	Q(z2	—	z1)i ≥	hz2	— z1,	Q(z2	— z1)i.	(24)
Also, observe the following:
hu2 一 u1, Q(z2 一 z1)i ≤ 2[hu2 一 u1, Q(u2 一 u1)i + hz2 一 z1, Q(z2 一 z1)i]
The above inequality can be obtained from the fact that h(u2 — u1) — (z2 — z1), Q((u2 — u1) —
(z2 一 z1))i ≥ 0 as Q ∈ S+d and rearranging the terms. Combining the above inequality with
Equation (24), We have the required result.	□
22
Published as a conference paper at ICLR 2018
Lemma 5 ((AUer & Gentile, 2000)). For any non-negative real numbers yι, ∙∙∙ ,yt, the following
holds:	_____
t	ut
XqPa ≤ 2tX yi.
i=1	j=1 yj	i=1
Lemma 6. Suppose F = [a, b] for a, b ∈ R and
yt+1 = ΠF (yt + δt)
for all the t ∈ [T], y1 ∈ F and furthermore, there exists i ∈ [T] such that δj ≤ 0 for all j ≤ i and
δj > 0 for all j > i. Then we have,
T
yT+1 ≥ min{b, y1 +	δj }.
Proof. It is first easy to see that yi+1 ≥ y1 + Pij =1 δj since δj ≤ 0 for all j ≤ i. FUrthermore, also
observe that yT+1 ≥ min{b, yi+1 + PjT=i+1 δj } since δj ≥ 0 for all j > i. Combining the above
two inequalities gives us the desired result.	□
23