Under review as a conference paper at ICLR 2018
Robust Task Clustering for Deep and Diverse
Multi-Task and Few- S hot Learning
Anonymous authors
Paper under double-blind review
Ab stract
We investigate task clustering for deep learning-based multi-task and few-shot
learning in the settings with large numbers of tasks. Our method measures task
similarities using cross-task transfer performance matrix. Although this matrix
provides us critical information regarding similarities between tasks, the uncertain
task-pairs, i.e., the ones with extremely asymmetric transfer scores, may collectively
mislead clustering algorithms to output an inaccurate task-partition. Moreover,
when the number of tasks is large, generating the full transfer performance matrix
can be very time consuming. To overcome these limitations, we propose a novel
task clustering algorithm to estimate the similarity matrix based on the theory
of matrix completion. The proposed algorithm can work on partially-observed
similarity matrices based on only sampled task-pairs with reliable scores, ensuring
its efficiency and robustness. Our theoretical analysis shows that under mild
assumptions, the reconstructed matrix perfectly matches the underlying “true”
similarity matrix with an overwhelming probability. The final task partition is
computed by applying an efficient spectral clustering algorithm to the recovered
matrix. Our results show that the new task clustering method can discover task
clusters that benefit both multi-task learning and few-shot learning setups for
sentiment classification and dialog intent classification tasks.
1	Introduction
This paper leverages knowledge distilled from a large number of learning tasks (Barzilai & Crammer,
2015; van Seijen et al., 2017), or MAny Task Learning (MATL), to achieve the goal of (i) improving
the overall performance of all tasks, as in multi-task learning (MTL); and (ii) rapid-adaptation to a
new task by using previously learned knowledge, similar to few-shot learning (FSL) and transfer
learning. Previous work on multi-task learning and transfer learning used small numbers of related
tasks (usually 〜10) picked by human experts. By contrast, MATL tackles hundreds or thousands of
tasks (Barzilai & Crammer, 2015; van Seijen et al., 2017), with unknown relatedness between pairs
of tasks, introducing new challenges such as task diversity and model inefficiency.
MATL scenarios are increasingly common in a wide range of machine learning applications with
potentially huge impact. Examples include reinforcement learning for game playing - where many
numbers of sub-goals are treated as tasks by the agents for joint-learning, e.g. van Seijen et al. (2017)
achieved the state-of-the-art on the Ms. Pac-Man game by using a multi-task learning architecture
to approximate rewards of over 1,000 sub-goals (reward functions). Another important example is
enterprise AI cloud services - where many clients submit various tasks/datasets to train machine
learning models for business-specific purposes. The clients could be companies who want to know
opinion from their customers on products and services, agencies that monitor public reactions to policy
changes, and financial analysts who analyze news as it can potentially influence the stock-market.
Such MATL-based services thus need to handle the diverse nature of clients’ tasks.
Challenges on Handling Diverse (Heterogeneous) Tasks Previous multi-task learning and few-
shot learning research usually work on homogeneous tasks, e.g. all tasks are binary classification
problems, or tasks are close to each other (picked by human experts) so the positive transfer between
tasks is guaranteed. However, with a large number of tasks in a MATL setting, the above assumption
may not hold, i.e. we need to be able to deal with tasks with larger diversity. Such diversity can be
reflected as (i) tasks with varying numbers of labels: when tasks are diverse, different tasks could
1
Under review as a conference paper at ICLR 2018
have different numbers of labels; and the labels might be defined in different label spaces without
relatedness. Most of the existing multi-task and few-shot learning methods will fail in this setting;
and more importantly (ii) tasks with positive and negative transfers: since tasks are not guaranteed
to be similar to each other in the MATL setting, they are not always able to help each other when
trained together, i.e. negative transfer (Yosinski et al., 2014) between tasks. For example, in dialog
services, the sentences “What fast food do you have nearby” and “Could I find any Indian food”
may belong to two different classes “fast_food” and “indian_food” for a restaurant recommendation
service in a city; while for a travel-guide service for a park, those two sentences could belong to
the same class “food_options”. In this case the two tasks may hurt each other when trained jointly
with a single representation function, since the first task turns to give similar representations to both
sentences while the second one turns to distinguish them in the representation space.
A Task Clustering Based Solution To deal with the second challenge above, we propose to partition
the tasks to clusters, making the tasks in each cluster more likely to be related. Common knowledge
is only shared across tasks within a cluster, thus the negative transfer problem is alleviated. There
are a few task clustering algorithm proposed mainly for convex models (Kumar & Daume III, 2012;
Kang et al., 2011; Crammer & Mansour, 2012; Barzilai & Crammer, 2015), but they assume that the
tasks have the same number of labels (usually binary classification). In order to handle tasks with
varying numbers of labels, we adopt a similarity-based task clustering algorithm. The task similarity
is measured by cross-task transfer performance, which is a matrix S whose (i, j)-entry Sij is the
estimated accuracy by adapting the learned representations on the i-th (source) task to the j -th (target)
task. The above task similarity computation does not require the source task and target task to have
the same set of labels, as a result, our clustering algorithm could naturally handle tasks with varying
numbers of labels.
Although cross-task transfer performance can provide critical information of task similarities, directly
using it for task clustering may suffer from both efficiency and accuracy issues. First and most
importantly, evaluation of all entries in the matrix S involves conducting the source-target transfer
learning O(n2) times, where n is the number of tasks. For a large number of diverse tasks where the
n can be larger than 1,000, evaluation of the full matrix is unacceptable (over 1M entries to evaluate).
Second, the estimated cross-task performance (i.e. some Sij or Sji scores) is often unreliable due to
small data size or label noises. When the number of the uncertain values is large, they can collectively
mislead the clustering algorithm to output an incorrect task-partition.
To address the aforementioned challenges, we propose a novel task clustering algorithm based on the
theory of matrix completion (Candes & Tao, 2θ10). Specifically, We deal with the huge number of
entries by randomly sample task pairs to evaluate the Sij and Sji scores; and deal with the unreliable
entries by keeping only task pairs (i, j) with consistent Sij and Sji scores. Given a set of n tasks, we
first construct an n × n partially-observed matrix Y, where its observed entries correspond to the
sampled and reliable task pairs (i, j) with consistent Sij and Sji scores. Otherwise, if the task pairs
(i, j ) are not sampled to compute the transfer scores or the scores are inconsistent, we mark both Yij
and Yji as unobserved. Given the constructed partially-observed matrix Y, our next step is to recover
an n × n full similarity matrix using a robust matrix completion approach, and then generate the
final task partition by applying spectral clustering to the completed similarity matrix. The proposed
approach has a 2-fold advantage. First, our method carries a strong theoretical guarantee, showing
that the full similarity matrix can be perfectly recovered if the number of observed correct entries
in the partially observed similarity matrix is at least O(n log2 n). This theoretical result allows us
to only compute the similarities of O(n log2 n) instead of O(n2) pairs, thus greatly reduces the
computation when the number of tasks is large. Second, by filtering out uncertain task pairs, the
proposed algorithm will be less sensitive to noise, leading to a more robust clustering performance.
The task clusters allow us to handle (i) diverse MTL problems, by model sharing only within clusters
such that the negative transfer from irrelevant tasks can be alleviated; and (ii) diverse FSL problems,
where a new task can be assigned a task-specific metric, which is a linear combination of the metrics
defined by different clusters, such that the diverse few-shot tasks could derive different metrics
from the previous learning experience. Our results show that the proposed task clustering algorithm,
combined with the above MTL and FSL strategies, could give us significantly better deep MTL and
FSL algorithms on sentiment classification and intent classification tasks.
2
Under review as a conference paper at ICLR 2018
2	Related Work
Task/Dataset Clustering on Model Parameters This class of task clustering methods measure
the task relationships in terms of model parameter similarities on individual tasks. Given the
parameters of convex models, task clusters and cluster assignments could be derived via matrix
decomposition (Kumar & Daume III, 2012) or k-means based approach (Kang et al., 2011). The
parameter similarity based task clustering method for deep neural networks (Yang & Hospedales,
2016) applied low-rank tensor decomposition of the model layers from multiple tasks. This method
is infeasible for our MATL setting because of its high computation complexity with respect to
the number of tasks and its inherent requirement on closely related tasks because of its parameter-
similarity based approach.
Task/Dataset Clustering with Clustering-Specific Training Objectives Another class of task
clustering methods joint assign task clusters and train model parameters for each cluster that min-
imize training loss within each cluster by K-means based approach (Crammer & Mansour, 2012)
or minimize overall training loss combined with sparse or low-ranker regularizers with convex opti-
mization (Barzilai & Crammer, 2015; Murugesan et al., 2017). Deep neural networks have flexible
representation power and they may overfit to arbitrary cluster assignment if we consider training loss
alone. Also, these methods require identical class label sets across different tasks, which does not
hold in most of the real-world MATL settings.
Few Shot Learning FSL (Li et al., 2006; Miller et al., 2000) aims to learn classifiers for new classes
with only afew training examples per class. Bayesian Program Induction (Lake et al., 2015) represents
concepts as simple programs that best explain observed examples under a Bayesian criterion. Siamese
neural networks rank similarity between inputs (Koch, 2015). Matching Networks (Vinyals et al.,
2016) maps a small labeled support set and an unlabeled example to its label, obviating the need for
fine-tuning to adapt to new class types. These approaches essentially learn one metric for all tasks,
which is sub-optimal when the tasks are diverse. An LSTM-based meta-learner (Ravi & Larochelle,
2017) learns the exact optimization algorithm used to train another learner neural-network classifier
for the few-shot setting. However, it requires uniform classes across tasks. Our FSL approach can
handle the challenges of diversity and varying sets of class labels.
Figure 1: The convolutional neural networks used in this work: (a) a single-task CNN. The encoder
component takes the sentence as input and outputs a fixed-length sentence embedding vector; the
classifier component predicts class labels with the sentence embedding. (b) the evaluation on transfer
performance from task i to j, where the encoder of task i was taken to encode task j’s sentences and
then predict task j’s labels (dashed arcs).
3	Methodology
Let T = {Tι, T2, ∙∙∙ , Tn} be the set of n tasks to be clustered, and each task Ti consists of a
train/validation/test data split Ditrain , Divalid, Ditest . We consider text classification tasks, com-
prising labeled examples {x, y}, where the input x is a sentence or document (a sequence of words)
and y is the label. We first train each classification model Mi on its training set Ditrain , which yields
a set of models M = {Mι, M2,…，Mn}. We use convolutional neural network (CNN), which
has reported results near state-of-the-art on text classification (Kim, 2014; Johnson & Zhang, 2016).
3
Under review as a conference paper at ICLR 2018
CNNs also train faster than recurrent neural networks (Hochreiter & Schmidhuber, 1997), making
large-n MATL scenarios more feasible. Figure 1 shows the CNN architecture. Following (Collobert
et al., 2011; Kim, 2014), the model consists of a convolution layer and a max-pooling operation over
the entire sentence. The model has two parts: an encoder part and a classifier part. Hence each model
Mi = {Mienc, Micls}. The above broad definitions encompasses other classification tasks (e.g. image
classification) and other classification models (e.g. LSTMs (Hochreiter & Schmidhuber, 1997)).
We propose a task-clustering framework for both multi-task learning (MTL) and few-shot learning
(FSL) settings. In this framework, we have the MTL and FSL algorithms summarized in Section 3.3
& 3.4, where our task-clustering framework serves as the initial step in both algorithms. Figure 2
gives an overview of our idea and an example on how our task-clustering algorithm helps MTL.
Figure 2: Overview of the idea of our Robust Clustering method with multi-task learning as an
example application. (a) an illustration of the sparse cross-tasks transfer-performance matrix with
unobserved entries (white blocks) and unreliable values (top-right and bottom-left corners), where red
colors indicate positive transfer and blue colors indicate negative transfer; (b) the constructed binary
partially-observed matrix with low-rank constraint for matrix completion and clustering (see Section
3.2 for the detailed mathematics); (c) a multi-task Convolutional Neural Network (MTL-CNN)
architecture trained on a task cluster (tasks 1, 2 and 3 in the example).
3.1	Cross-Task Transfer-Performance Matrix Estimation
Using single-task models, we can compute performance scores sij by adapting each Mi to each
task Tj (j 6= i). This forms an n × n pair-wise classification performance matrix S, called the
transfer-performance matrix. Note that S is asymmetric since usually Sij 6= Sji .
When all tasks have identical label sets, we can directly evaluate the model Mi on the training set
of task j , Djtrain , and use the accuracy as the cross-task transfer score Sij .
When tasks have different label sets, we freeze the encoder Mienc from Mi , on top of which we use
Djtrain to train a classifier layer. This gives us a new task j model, and we test this model on Djvalid
to get the accuracy as the transfer-performance Sij . The score shows how the representations learned
on task i can be adapted to task j , thus indicating the similarity between tasks.
Task Pair Sampling: When the number of tasks n is very large, the evaluation of O(n2) entries is
time-consuming. Thus we sample n0 pairs of tasks {i, j} (i 6= j), with n0 n. Then we set Sij and
Sji as the transfer performance defined above when {i, j} is in the n0 samples, otherwise the entry is
marked as “unobserved” 1.
3.2	Robust Task Clustering by Matrix Completion
As discussed in the introduction, directly generating the full matrix S and partitioning tasks based
on it has the following disadvantages: (i) there are too many entries to evaluate when the number
of tasks is large; (ii) some task pairs are uncertain, thus can mislead the clustering algorithm to
1We set all Sii = L
4
Under review as a conference paper at ICLR 2018
Algorithm 1: ROBUSTTC: Robust Task Clustering based on Matrix Completion
Input : A set of n tasks T = {Tι, T2, •…,Tn}, number of task clusters K
Output : K task clusters C1:K
1	Learning of Single-Task Models: train single-task models Mi for each task Ti
2	Evaluation of Transfer-Performance Matrix: get performance matrix S (Section 3.1)
3	Score Filtering: Filter the uncertain scores in S and construct the symmetric matrix Y using Eq. (1)
4	Matrix Completion: Complete the similar matrix X from Y using Eq. (2)
5	Task Clustering: C1:K = SpectralClustering(X, K)
output an incorrect task-partition; and (iii) S is asymmetric, thus cannot be directly analyzed by
many conventional clustering methods. We address the first issue by randomly sample some task
pairs to evaluate, as described in Section 3.1. Besides, we address the other issues by constructing a
symmetric similarity matrix and only consider the reliable task relationships, as will be introduced in
Eq. (1). Below, we describe our method (summarized in Algorithm 1) in detail.
First, we use only reliable task pairs to generate a partially-observed similarity matrix Y. Specifically,
if Sij and Sji are high enough, then it is likely that tasks {i, j} belong to a same cluster and share
significant information. Conversely, if Sij and Sji are low enough, then they tend to belong to
different clusters. To this end, we need to design a mechanism to determine if a performance is high
or low enough. Since different tasks may vary in difficulty, a fixed threshold is not suitable. Hence,
we define a dynamic threshold using the mean and standard deviation of the target task performance,
i.e., μj = mean(Sj) and σj = Std(Sj), where Sj is the j-th column of S. We then introduce two
positive parameters pi and p2, and define high and low performance as Sij greater than μj + p`θj or
lower than μj - p?Oj, respectively. When both Sij and Sji are high and low enough, We set their
pairwise similarity as 1 and 0, respectively. Other task pairs are treated as uncertain task pairs and
are marked as unobserved, and will have no influence to our clustering method. This leads to a
partially-observed symmetric matrix Y, i.e.,
{1	if	Sij	>	μj + pισj	and	Sji	> μi + pm
0	if	Sij	<	μj -	p2σj	and	Sji	< μi - p2σi	(I)
unobserved otherwise
Given the partially observed matrix Y, we then reconstruct the full similarity matrix X ∈ Rn×n . We
first note that the similarity matrix X should be of low-rank (proof deferred to appendix). Additionally,
since the observed entries of Y are generated based on high and low enough performance, it is safe
to assume that most observed entries are correct and only a few may be incorrect. Therefore, we
introduce a sparse matrix E to capture the observed incorrect entries in Y. Combining the two
observations, Y can be decomposed into the sum of two matrices X and E, where X is a low rank
matrix storing similarities between task pairs, and E is a sparse matrix that captures the errors in Y.
The matrix completion problem can be cast as the following convex optimization problem:
min kχ∣∣*+λ∣∣Ekι	⑵
X, E
s.t.	Pω(X + E) = Pω(Y),
where ||。|| * denotes the matrix nuclear norm, the convex surrogate of rank function. Ω is the set of
observed entries in Y, and Pω : Rn×n → Rn×n is a matrix projection operator defined as
[Pc(A)]ij = [ AijiffSj)∙∈ ω
L ∖八 ij3	0 0 otherwise
The following theorem shows the perfect recovery guarantee for the problem (2). The proof is
deferred to Appendix.
Theorem 3.1. Let X* ∈ Rn×n be a rank k matrix with a singular value decomposition X* = UΣV>,
where U = (u1 , . . . , uk) ∈ Rn×k and V = (v1, . . . , vk) ∈ Rn×k are the left and right singular
vectors ofX*, respectively. Similar to many related works of matrix completion, we assume that the
following two assumptions are satisfied:
1. The row and column spaces of X have coherence bounded above by a positive number μo.
2. Max absolute value in matrix UV> is bounded above by μι√r∕n for a positive number μι.
5
Under review as a conference paper at ICLR 2018
Suppose that mi entries of X* are observed with their locations sampled uniformly at random, and
among the m1 observed entries, m2 randomly sampled entries are corrupted. Using the resulting
partially observed matrix as the input to the problem (2), then with a probability at least 1 - n-3,
the underlying matrix X* can be perfectly recovered, given
L μ(E)ξ(X) ≤ 4k+5,
2	ξ(X)-(2k-1嚅)ξ2(x) <λ< i-(4k+5)μ(E尸X)
3	. mi — m2 ≥ C[max(μo, μ1)]4nlog2 n,
where C is a positive constant; ξ(o) and μ(o) denotes the low-rank and sparsity incoherence (Chan-
drasekaran et al., 2011).
Theorem 3.1 implies that even if some of the observed entries computed by (1) are incorrect, problem
(2) can still perfectly recover the underlying similarity matrix X* if the number of observed correct
entries is at least O(n log2 n). For MATL with large n, this implies that only a tiny fraction of
all task pairs is needed to reliably infer similarities over all task pairs. Moreover, the completed
similarity matrix X is symmetric, due to symmetry of the input matrix Y. This enables analysis by
similarity-based clustering algorithms, such as spectral clustering.
3.3	Multi-Task Learning Based on Tasks Clusters
Algorithm 2: ROBUSTTC-MTL: Multi-Task Learning based on Task Clustering
Input : A set of n tasks T = {Tι, T2, •…,Tn}; number of clusters K
Output: K task clusters Ci：K and cluster-models Λ = {Λ1, Λ2, •…，Λk}
1 Robust Task Clustering: C1:K = ROBUSTTC(T,K) (Algorithm 1)
2 Cluster-Model Training: Train one multi-task model Λi on each task cluster Ci (Section 3.3)
For each cluster Ck , we train a model Λk with all tasks in that cluster to encourage parameter sharing.
We call Λk the cluster-model. When evaluated on the MTL setting, with sufficient data to train
a task-specific classifier, we only share the encoder part and have distinct task-specific classifiers
(Figure 1(b)). These task-specific classifiers provide flexibility to handle varying number of labels.
3.4	Few- S hot Learning Based on Tasks Clusters
Algorithm 3: ROBUSTTC-FSL: Task Clustering for Few-Shot Learning
Input : N training tasks T = {Ti, T2, •…,Tn }; number of clusters K; target few-shot learning task Ttrg
Output :A classification model for the target task Mtrg, K task clusters C1：K and cluster-models
Λ = {Λι, Λ2,…，Λk}
1	Learning Cluster-Models on Training Tasks: Ci：K, Λ = ROBUSTTC-MTL(T,K) (Algorithm 2)
2	Few-Shot Learning on Cluster-models: Train a model Mtrg on task Ttrg with the method in Section 3.4.
We only have access to a limited number of training samples in few-shot learning setting, so it is
impractical to train well-performing task-specific classifiers as in the multi-task learning setting.
Instead, we make the prediction of a new task by linearly combining prediction from learned clusters.
p(y|x) = X a P(y|x; Ak).	(3)
k
where Λk is the learned (and frozen) model of the k-th cluster, {αk}kK=i are adaptable parameters.
We use some alternatives to train cluster-models Λk , which could better suit (and is more consistent
to) the above FSL method.2 When all tasks have identical label sets, we train a single classification
2We also tried these alternatives under the MTL settings, which perform worse than MTL-CNN.
6
Under review as a conference paper at ICLR 2018
model on all the tasks like in previous work (Barzilai & Crammer, 2015), the predictor P (y|x; Λk) is
directly derived from this cluster-model. When tasks have different label sets , we train a metric-
learning model like (Vinyals et al., 2016) among all the tasks in Ck, which consist a shared encoding
function Λeknc aiming to make each example closer to examples with the same label compared to the
ones with different labels.
Then we use the encoding function to derive the predictor by
P(y = yl|x; Λk) =
exp {Λknc(xι)>Λknc(x)}
P exp {Λknc(x10)>Λknc(x)}
(4)
where xl is the corresponding training sample for label yl .
4	Experiments
4.1	Experiment Setup
Data Sets We test our methods by conducting experiments on three text classification data sets. In
the data-preprocessing step we used NLTK toolkit3 for tokenization. For MTL setting, all tasks are
used for clustering and model training. For FSL setting, the task are divided into training tasks and
testing tasks (target tasks), where the training tasks are used for clustering and model training, the
testing tasks are few-shot learning ones used to for evaluating the method in Eq. (3).
1.	Amazon Review Sentiment Classification First, following Barzilai & Crammer (2015),
we construct a multi-task learning setting with the multi-domain sentiment classifica-
tion (Blitzer et al., 2007) data set. The dataset consists of Amazon product reviews for 23
types of products (see Appendix 3 for the details). For each domain, we construct three
binary classification tasks with different thresholds on the ratings: the tasks consider a review
as positive if it belongs to one of the following buckets =5 stars, >=4 stars or >=2 stars 4
These review-buckets then form the basis of the task-setup for MATL, giving us 23 × 3 = 69
tasks in total. For each domain we distribute the reviews uniformly to the three tasks. For
evaluation, we select tasks from 4 domains (Books, DVD, Electronics, Kitchen) as the target
tasks (12 tasks) out of all 23 domains. For FSL evaluation, we create five-shot learning
tasks on the selected target tasks. The cluster-models for this evaluation are standard CNNs
shown in Figure 1(a), and we share the same output layer to evaluate the probability in Eq.
(3) as all tasks have the same number of labels.
2.	Diverse Real-World Tasks: User Intent Classification for Dialog System The second
dataset is from an on-line service which trains and serves intent classification models to
various clients. The dataset comprises recorded conversations between human users and
dialog systems in various domains, ranging from personal assistant to complex service-
ordering or a customer-service request scenarios. During classification, intent-labels5 are
assigned to user utterances (usually sentences). We use a total of 175 tasks from different
clients, and randomly sample 10 tasks from them as our target tasks. For each task, we
randomly sample 64% data into a training set, 16% into a validation set, and use the rest as
the test set (see Appendix 3 for details). The number of labels for these tasks vary from 2 to
100. Hence, to adapt this to a FSL scenario, we keep one example for each label (one-shot),
plus 20 randomly picked labeled examples to create our training data. We believe this is a
fairly realistic estimate of labeled examples one client could provide easily. Since we deal
with various number of labels in the FSL setting, we chose matching networks (Vinyals
et al., 2016) as the cluster-models.
3.	Extra-Large Number of Real-World Tasks Similar to the second dataset, we further
collect 1,491 intent classification tasks from the on-line service. This setting is mainly
used to verify the robustness of our task clustering method, since it is difficult to estimate
the full transfer-performance matrix S in this setting (1,4912=2.2M entries). Therefore, in
3http://www.nltk.org/
4Data downloaded from http://www.cs.jhu.edu/~mdredze/datasets/sentiment/, in
which the 3-star samples were unavailable due to their ambiguous nature (Blitzer et al., 2007).
5In conversational dialog systems, intent-labels are used to guide the dialog-flow.
7
Under review as a conference paper at ICLR 2018
order to extract task clusters, we randomly sample task pairs from the data set to obtain
100,000 entries in S, which means that only about 100K/2.2M ≈ 4.5% of the entries in S
are observed. The number of 100,000 is chosen to be close to n log2 n in our theoretical
bound in Theorem 3.1, so that we could also verify the tightness of the bound empirically.
To make the best use of the sampled pairs, in this setting we modified the Eq. 1, so that each
entry Yij = Yji = 1 if Sij ≥ μj or Sji ≥ μ% and Yij = 0 otherwise. In this way We could
have determined number of entries in Y as well, since all the sampled pairs will correspond
to observed (but noisy) entries in Y. We only run MTL setting on this data set.
Baselines For MTL setting, we compare our method to the following baselines: (1) single-task
CNN: training a CNN model for each task individually; (2) holistic MTL-CNN: training one MTL-
CNN model (Figure 1b) on all tasks; (3) holistic MTL-CNN (target only): training one MTL-CNN
model on all the target tasks. For FSL setting, the baselines consist of: (1) single-task CNN: training a
CNN model for each task individually; (2) single-task FastText: training one FastText model (Joulin
et al., 2016) with fixed embeddings for each individual task; (3) Fine-tuned the holistic MTL-CNN:
fine-tuning the classifier layer on each target task after training initial MTL-CNN model on all
training tasks; (4) Matching Network: a metric-learning based few-shot learning model trained on
all training tasks. We initialize all models with pre-trained 100-dim Glove embeddings (trained on
6B corpus) (Pennington et al., 2014).
As the intent classification tasks usually have various numbers of labels, to our best knowledge the
proposed method is the only one supporting task clustering in this setting; hence we only compare with
the above baselines. Since sentiment classification involves binary labels, we compare our method
with the state-of-the-art logistic regression based task clustering method (ASAP-MT-LR) (Barzilai
& Crammer, 2015). We also try another approach where we run our MTL/FSL methods on top of the
(ASAP-Clus-MTL/FSL) clusters (as their entire formulation is only applicable to convex models).
Hyper-Parameter Tuning In all experiments, we set both p1 and p2 parameters in (1) to 0.5.
This strikes a balance between obtaining enough observed entries in Y, and ensuring that most of
the retained similarities are consistent with the cluster membership. For MTL settings, we tune
parameters like the window size and hidden layer size of CNN, learning rate and the initialization of
embeddings (random or pre-trained) based on average accuracy on the union of all tasks’ dev sets,
in order to find the best identical setting for all tasks. Finally we have the CNN with window size
of 5 and 200 hidden units. The learning rate is selected as 0.001; and all MTL models use random
initialized word embeddings on sentiment classification and use Glove embeddings as initialization
on intent classification, which is likely because the training sets of the intent tasks are usually small.
We also used the early stopping criterion based on the previous condition.
For the FSL setting, hyper-parameter selection is difficult since there is no validation data (which is a
necessary condition to qualify as a k-shot learning). So, in this case we preselect a subset of training
tasks as validation tasks and tune the learning rate and training epochs (for the rest we follow the
best setting from the MTL experiments) on the validation tasks. During the testing phase (i.e. model
training on the target FSL tasks), we fix the selected hyper-parameter values for all the algorithms.
Out-of-Vocabulary in Transfer-Performance Evaluation In text classification tasks, transferring
an encoder with fine-tuned word embeddings from one task to another may not work as there can be
a significant difference between the vocabularies. Hence, while learning the single-task models (line
1 of Algorithm 1) we always use the CNNs with fixed set of pre-trained embeddings.
4.2	Sentiment Classification on Amazon Product Reviews
Improving Observed Tasks (MTL Setting) Table 1 shows the results of the 12 target tasks when
all 69 tasks are used for training. Since most of the tasks have a significant amount of training data,
the single-task baselines achieve good results. Because the conflicts among some tasks (e.g. the
2-star bucket tasks and 5-star bucket tasks require opposite labels on 4-star examples), the holistic
MTL-CNN does not show accuracy improvements compared to the single-task methods. It also
lags behind the holistic MTL-CNN model trained only on 12 target domains, which indicates that
the holistic MTL-CNN cannot leverage large number of background tasks. Our RobustTC-MTL
method based on task clustering achieves a significant improvement over all the baselines.
8
Under review as a conference paper at ICLR 2018
Table 1: Accuracy on the 12 target sentiment classification tasks.
(a) MTL setting (i.e. training on all 69 tasks).		(b) Few-shot learning setting (five-shot	).
Model Single-task CNN ASAP-MTLR (BarZilai & Crammer, 2015) Holistic MTL-CNN HOliStiC MTL-CNN (target Only)	Avg Acc 85.51 85.17 85.23 85.71	Model	Avg Acc
		Single-task CNN w/ pre-trained emb Single-task FastText w/ pre-trained emb Fine-tuned the holistic MTL-CNN Matching Network (Vinyals et al., 2016)	65.92- 63.05 76.56 65.73
-RorttstT C-IVTTT obust C-		ROBUSTTC-FSL	一	
clus=5 clus=10 ASAP-Clus-MTL clus=5 clus=10	86.13 86.73 86.07 85.60	clus=5 clus=10 CluS=num_of_tasks (no clustering)	83.12- 81.96 78.85
		ASAP-Clus-FSL	
		clus=5 clus=10	-82.65- 81.44
The ASAP-MTLR (best score achieved with five clusters) could improve single-task linear models
with similar merit of our method. However, it is restricted by the representative strength of linear
models so the overall result is lower than the deep learning baselines.
Adaptation to New Tasks (FSL Setting) Table 1(b) shows the results on the 12 five-shot tasks by
leveraging the learned knowledge from the 57 previously observed tasks. Due to the limited training
resources, all the baselines perform poorly. Our RobustTC-FSL gives far better results compared to
all baselines (>6%). It is also significantly better than applying Eq. (3) without clustering (78.85%),
i.e. using single-task model from each task instead of cluster-models for P (y|x; ∙).
Comparison to the ASAP Clusters Our clustering-based MTL and FSL approaches also work
for the ASAP clusters, in which we replace our task clusters with the task clusters generated by
ASAP-MTLR. In this setting we get a slightly lower performance compared to the RobustTC-based
ones on both MTL and FSL settings, but overall it performs better than the baseline models. This
result shows that, apart from the ability to handle varying number of class labels, our RobustTC
model can also generate better clusters for MTL/FSL of deep networks, even under the setting where
all tasks have the same number of labels.
It is worth to note that from Table 1(a), training CNNs on the ASAP clusters gives better results
compared to training logistic regression models on the same 5 clusters (86.07 vs. 85.17), despite
that the clusters are not optimized for CNNs. Such result further emphasizes the importance of task
clustering for deep models, when better performance could be achieved with such models.
4.3	User Intent Classification from Diverse Real-World Online Services
Table 2: Accuracy on the 10 dialog intent classification tasks.
(b) FSL setting (one-shot + 20 examples).
(a) MTL setting (i.e. training on all	175 tasks).	Model	Avg Acc
1VΓπHp1 ode	Avo A pp	Single-task CNN w/pre-trained emb	-34.46-
Single-task CNN	vg cc 58.47-	Single-task FastText w/pre-trained emb Fine-tuned holistic MTL-CNN	23.87 30.36
Holistic MTL-CNN Holistic MTL-CNN (target only)	62.42 62.45	Matching Network (Vinyals et al., 2016) RCRτταTrrrI Ij1QT RobustTC-FSL	25.14
ROBUSTTC-MTL	一			
			^^34:64-
clus=10	-64.41-	cus= clus=20	37.59
clus=20	68.11	clus=30	36.82
clus=30	66.74	clus=num_of_tasks (no clustering)	34.43
		AdaPtive ROBUSTTC-FSL (CIUS=20)一	42.97
Table 2(a) & (b) show the MTL & FSL results on dialog intent classification, which demonstrates
trends similar to the sentiment classification tasks. Note that the holistic MTL methods achieve
much better results compared to single-task CNNs. This is because the tasks usually have smaller
training and development sets, and both the model parameters learned on training set and the hyper-
parameters selected on development set can easily lead to over-fitting. RobustTC-MTL achieves
9
Under review as a conference paper at ICLR 2018
large improvement (5.5%) over the best MTL baseline, because the tasks here are more diverse than
the sentiment classification tasks and task-clustering greatly reduces conflicts from irrelevant tasks.
Although our RobustTC-FSL improves over baselines under the FSL setting, the margin is smaller.
This is because of the huge diversity among tasks - by looking at the training accuracy, We found
several tasks failed because none of the clusters could provide a metric that suits the training examples.
To deal With this problem, We hope that the algorithm can automatically decide Whether the neW
task belongs to any of the task-clusters. If the task doesn’t belong to any of the clusters, it Would
not benefit from any previous knoWledge, so it should fall back to single-task CNN. The neW task
is treated as “out-of-cluster” When none of the clusters could achieve higher than 20% accuracy
(selected on dev tasks) on its training data. We call this method Adaptive RobustTC-FSL, and it
gives more than 5% performance boost over the best RobustTC-FSL result.
Discussion on Clustering-Based FSL The single metric based FSL method (Matching NetWork)
achieved success on homogeneous feW-shot tasks like Omniglot and miniImageNet (Vinyals et al.,
2016) but performs poorly in both of our experiments. This indicates that it is important to maintain
multiple metrics for feW-shot learning problems With more diverse tasks, similar to the feW-shot NLP
problems investigated in this paper. Our clustering-based FSL approach maintains diverse metrics
While keeping the model simple With only K parameters to estimate. It is WorthWhile to study hoW
and Why the NLP problems make feW-shot learning more difficult/heterogeneous; and hoW Well our
method can generalize to non-NLP problems like miniImageNet. We Will leave these topics for future
Work.
4.4 Large-Scale User Intent Classification with Task-Pair Sampling
Table 3 shoWs the MTL results on the extra-large dialog intent classification dataset. Compared
to the results on the 175 tasks, the holistic MTL-CNN achieves larger improvement (6%) over the
single-task CNNs, Which is a stronger baseline. Similar as the observation on the 175 tasks, here the
main reason for its improvement is the consistent development and test performance due to holistic
multi-task training approach: both the single-task and holistic multi-task model achieve around 66%
average accuracy on development sets. Unlike the experiments in Section 4.3, We did not evaluate the
full transfer-performance matrix S due to time considerations. Instead, We only use the information
of 〜4.5% of all the task-pairs, and our algorithm still achieves a significant improvement over the
baselines. Note that this result is obtained by only sampling about n log2 n task pairs, it not only
confirms the empirical advantage of our multi-task learning algorithm, but also verifies the correctness
of our theoretical bound in Theorem 3.1.
Table 3: Accuracy of Multi-Task Learning on the 1,491 dialog intent classification tasks.
Model		Avg Acc
Single-task CNN	60.49-
Holistic MTL-CNN	66.42
RobustTC-MTL
clus=30	69.62
clus=40	70.50
clus=50	69.87
5 Conclusion
In this paper, We propose a robust task-clustering method that not only has strong theoretical
guarantees but also demonstrates significantly empirical improvements When equipped by our MTL
and FSL algorithms. Our empirical studies verify that (i) the proposed task clustering approach is
very effective in the many-task learning setting especially When tasks are diverse; (ii) our approach
could efficiently handle large number of tasks as suggested by our theory; and (iii) cross-task transfer
performance can serve as a poWerful task similarity measure. Our Work opens up many future
research directions, such as supporting online many-task learning With incremental computation on
task similarities, and combining our clustering approach With the recent learning-to-learn methods
(e.g. (Ravi & Larochelle, 2017)), to enhance our MTL and FSL methods.
10
Under review as a conference paper at ICLR 2018
References
Aviad Barzilai and Koby Crammer. Convex multi-task learning by clustering. In AISTATS, 2015.
John Blitzer, Mark Dredze, and Fernando Pereira. Biographies, bollywood, boom-boxes and blenders:
Domain adaptation for sentiment classification. In ACL, volume 7, pp. 440-447, 2007.
Emmanuel J CandeS and Terence Tao. The power of convex relaxation: Near-optimal matrix
completion. IEEE Transactions on Information Theory, 56(5):2053-2080, 2010.
Venkat Chandrasekaran, Sujay Sanghavi, Pablo A Parrilo, and Alan S Willsky. Rank-sparsity
incoherence for matrix decomposition. SIAM Journal on Optimization, 21(2):572-596, 2011.
Ronan Collobert, Jason Weston, Leon Bottou, Michael Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
Natural language processing (almost) from scratch. Journal of Machine Learning Research, 12
(Aug):2493-2537, 2011.
Koby Crammer and Yishay Mansour. Learning multiple tasks using shared hypotheses. In Advances
in Neural Information Processing Systems, pp. 1475-1483, 2012.
Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 9(8):
1735-1780, 1997.
Rie Johnson and Tong Zhang. Supervised and semi-supervised text categorization using one-hot lstm
for region embeddings. stat, 1050:7, 2016.
Armand Joulin, Edouard Grave, Piotr Bojanowski, and Tomas Mikolov. Bag of tricks for efficient
text classification. arXiv preprint arXiv:1607.01759, 2016.
Zhuoliang Kang, Kristen Grauman, and Fei Sha. Learning with whom to share in multi-task feature
learning. In Proceedings of the 28th International Conference on Machine Learning (ICML-11),
pp. 521-528, 2011.
Yoon Kim. Convolutional neural networks for sentence classification. In EMNLP, pp. 1746-1751,
Doha, Qatar, October 2014. Association for Computational Linguistics.
Gregory Koch. Siamese neural networks for one-shot image recognition. PhD thesis, University of
Toronto, 2015.
Abhishek Kumar and Hal Daume III. Learning task grouping and overlap in multi-task learning. In
Proceedings of the 29th International Conference on Machine Learning (ICML-12), 2012.
Brenden M Lake, Ruslan Salakhutdinov, and Joshua B Tenenbaum. Human-level concept learning
through probabilistic program induction. Science, 350(6266):1332-1338, 2015.
Fei-Fei Li, Rob Fergus, and Pietro Perona. One-shot learning of object categories. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 28(4):594-611, 2006.
Erik G Miller, Nicholas E Matsakis, and Paul A Viola. Learning from one example through shared
densities on transforms. In Computer Vision and Pattern Recognition, 2000. Proceedings. IEEE
Conference on, volume 1, pp. 464-471. IEEE, 2000.
Keerthiram Murugesan, Jaime Carbonell, and Yiming Yang. Co-clustering for multitask learning.
arXiv preprint arXiv:1703.00994, 2017.
Jeffrey Pennington, Richard Socher, and Christopher D Manning. Glove: Global vectors for word
representation. In EMNLP, volume 14, pp. 1532-1543, 2014.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. In International
Conference on Learning Representations, volume 1, pp. 6, 2017.
Harm van Seijen, Mehdi Fatemi, Joshua Romoff, Romain Laroche, Tavian Barnes, and Jeffrey Tsang.
Hybrid reward architecture for reinforcement learning. arXiv preprint arXiv:1706.04208, 2017.
Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra, et al. Matching networks for one shot
learning. In Advances in Neural Information Processing Systems, pp. 3630-3638, 2016.
11
Under review as a conference paper at ICLR 2018
Yongxin Yang and Timothy Hospedales. Deep multi-task representation learning: A tensor factorisa-
tion approach. arXiv preprint arXiv:1605.06391, 2016.
Jason Yosinski, Jeff Clune, Yoshua Bengio, and Hod Lipson. How transferable are features in deep
neural networks? In Advances in neural information processing systems, pp. 3320-3328, 2014.
12
Under review as a conference paper at ICLR 2018
APPENDIX A:	PROOF OF LOW-RANKNESS OF MATRIX X
We first prove that the full similarity matrix X ∈ Rn×n is of low-rank. To see this, let A =
(a1, . . . , ak) be the underlying perfect clustering result, where k is the number of clusters and
ai ∈ {0, 1}n is the membership vector for the i-th cluster. Given A, the similarity matrix X is
computed as
kk
X=Xaiai>=XBi
i=1	i=1
where Bi = aiai> is a rank one matrix. Using the fact that rank(X) ≤ Pik=1 rank(Bi) and rank(Bi) =
1, we have rank(X) ≤ k, i.e., the rank of the similarity matrix X is upper bounded by the number of
clusters. Since the number of clusters is usually small, the similarity matrix X should be of low rank.
Appendix B:	Proof of Theorem 4.1
We then prove our main theorem. First, we define several notations that are used throughout the proof.
Let X = UΣV> be the singular value decomposition of matrix X, where U = (u1, . . . , uk) ∈ Rn×k
and V = (v1, . . . , vk) ∈ Rn×k are the left and right singular vectors of matrix X, respectively.
Similar to many related works of matrix completion, we assume that the following two assumptions
are satisfied:
1.	A1: the row and column spaces of X have coherence bounded above by a positive number
μo, i.e., vzn∕r maxi l∣Pu (e∕k ≤ μo and n^r/m maxi ∣∣Pv(ei)∣∣ ≤ μo, where PU = UU>,
PV = VV>, and ei is the standard basis vector, and
2.	A2: the matrix UV> has a maximum entry bounded by μι√r∕n in absolute value for a
positive number μι.
Let T be the space spanned by the elements of the form uiy> and xvi>, for 1 ≤ i ≤ k, where x and
y are arbitrary n-dimensional vectors. Let T ⊥ be the orthogonal complement to the space T , and let
PT be the orthogonal projection onto the subspace T given by
PT (Z) =PUZ+ZPV-PUZPV.
The following proposition shows that for any matrix Z ∈ T , it is a zero matrix if enough amount of
its entries are zero.
Proposition 1. Let Ω be a setof m entries sampled uniformly at randomfrom [1,...,n] X [1,...,n],
and P ω( Z) projects matrix Z onto the subset Ω .If m > m0, where m° = CR μornβ log n with
β > 1 and Cr being a positive constant, then for any Z ∈ T with P ω( (Z) = 0, we have Z = 0 with
probability 1 - 3n-β.
Proof. According to the Theorem 3.2 in Candes & Tao (2010), for any Z ∈ T, with a probability at
least 1 - 2n2-2β, we have
2
IIPt(Z)IIf - δ∣Z∣F ≤ — ∣PτPqPt(Z)IIF = 0	(5)
m
where δ = m0∕m < 1. Since Z ∈ T, we have PT (Z) = Z. Then from (5), we have IZIF ≤ 0 and
thus Z = 0.	□
In the following, we will develop a theorem for the dual certificate that guarantees the unique optimal
solution to the following optimization problem
min ∣χk*+λ∣E∣ι	(6)
X, E
s.t.	Pω(X + E) = Pω(Y).
13
Under review as a conference paper at ICLR 2018
Theorem 1. Suppose we observe m1 entries of X with locations sampled uniformly at random,
denoted by Ω. Wefurther assume that m2 entries randomly SamPledfrOm mi observed entries are
corrupted, denoted by ∆. Suppose that P ω( Y) = P ω( X + E) and the number of observed correct
entries mi — m2 > mo = CRμornβ log n. Then, for any β > 1, with a probability at least 1 一 3n-β,
the underlying true matrices (X, E) is the unique optimizer of (6) if both assumptions A1 and A2
are satisfied and there exists a dual Q ∈ Rn×n such that (a) Q = Pω(Q),(b) Pt(Q) = UV>,(c)
kPT>(Q)k < 1, (d) P∆(Q) = λ sgn(E), and (e) kP∆c(Q)k∞ < λ.
Proof. First, the existence of Q satisfying the conditions (a) to (e) ensures that (X, E) is an optimal
solution. We only need to show its uniqueness and we prove it by contradiction. Assume there exists
another optimal solution (X + Nχ, E + Ne), where Pω(Nx + NE) = 0. Then We have
kX + Nχk* + λ∣∣E + Ne∣∣i	≥	∣∣X∣∣* + λ∣∣E∣∣ι +〈Qe, NEi + hQx,Nχi
where QE and QX satisfying P∆(QE) = λ sgn(E), kP∆c (QE)k∞ ≤ λ, PT(QX) = UV> and
kPT⊥(QX)k ≤ 1. As a result, we have
λ∣∣E + Ne∣∣i + kX + Nχk.
≥ λkEkI + ∣∣Xk* + hQ + P∆c (QE)- P∆c (Q), NEi + hQ + PT ⊥ (QX)- PT ⊥ (Q), NXi
=λkEkI + ∣∣Xk* + hQ, NE + NXi + hp∆c (QE)- P∆c (Q), NEi + hpτ ⊥ (QX)- PT ⊥ (Q), NXi
=λkEkI + ∣∣Xk* + hp∆c (QE)- P∆c (Q), P∆c (NE)i + hPT⊥ (QX)- PT⊥ (Q), PT⊥ (NX)i
We then choose P∆c(QE) and PT⊥ (QX) to be such that hP∆c(QE), P∆c (NE)i = λkP∆c (NE)ki and
hPT⊥(Qx),PT⊥(NX)i = kPT⊥(NX)k*∙Wethus have
λkE + Ne∣∣i + kX + NxII*
≥ λ∣E∣ι + ∣∣Xk* + (λ - kP∆c(Q)k∞)kP∆c(Ne)Ii + (1 - kPT⊥(Q)k)kPT⊥(Nχ)k*
Since (X + Nχ,E + Ne) is also an optimal solution, we have ∣∣PΩc(NE)ki = kPT⊥ (Nx)k*, leading
to PΩc(Ne) = PT⊥ (Nx) = 0, or Nχ ∈ T. Since PΩ(Nχ + NE) = 0, we have Nχ = NE + Z,
where Ρω(Z) = 0 and Pq。(NE) = 0. Hence, Pωc∩ω(Nx) = 0, where ∣Ωc ∩ Ω∣ = mi - m2.
Since mi - m2 > m0, according to Proposition 1, we have, with a probability 1 - 3n-β, NX = 0.
Besides, since Pω(Nx + NE) = Pω(Ne) = 0 and ∆ ⊂ Ω, we have Pδ(Ne) = 0. Since NE =
Pδ (Ne) + P∆c (Ne), we have NE = 0, which leads to the contradiction.	□
Given Theorem 1, we are now ready to prove Theorem 3.1.
Proof. The key to the proof is to construct the matrix Q that satisfies the conditions (a)-(e) specified
in Theorem 1. First, according to Theorem 1, when mi — m2 > m0 = CRμ0rnβ log n, with a
probability at least 1 - 3n-β, mapping PTPqPt (Z) : T → T is an one to one mapping and therefore
its inverse mapping, denoted by (PTPqPt)-i is well defined. Similar to the proof of Theorem 2
in Chandrasekaran et al. (2011), we construct the dual certificate Q as follows
Q = λ sgn(E) + e∆ + PδPt(PtPωPt)-i(UV> + eτ)
where T ∈ T and ∆ = P∆(∆). We further define
H = PωPt(Pt PωPt )
F = PωPt(Pt PωPt )
-i
-i
(UV>)
(T)
Evidently, we have Pω(Q) = Q since ∆ ⊂ Ω, and therefore the condition (a) is satisfied. To satisfy
the conditions (b)-(e), we need
PT (Q) = UV>
kPT⊥(Q)k <1
P∆(Q) = λ sgn(E)
∣P∆c(Q)∣∞ <λ
→
→
→
→
T = -PT (λ sgn(E) + ∆)
μ(E) (λ + kT∞) + ∣Pt⊥(H)k + ∣Pt⊥(F)k < 1
∆ = -P∆(H + F)
ξ(X)(1+kTk)<λ
(7)
(8)
(9)
(10)
Below, we will first show that there exist solutions T ∈ T and ∆ that satisfy conditions (7) and (9).
We will then bound ∣∣eω∣∣∞, k6τk, ∣Pt⊥(H)k,and ∣Pt⊥(F)k to show that with sufficiently small
μ(E) and ξ(X), and appropriately chosen λ, conditions (8) and (10) can be satisfied as well.
14
Under review as a conference paper at ICLR 2018
First, we show the existence of ∆ and T that obey the relationships in (7) and (9). It is equivalent to
show that there exists T that satisfies the following relation
eτ = -Pτ(λ Sgn(E)) + PTP∆(H) + PTPδPt(PtPqPt)-1(eτ)
or
PTPω∖δPt(PtPωPt)-1(eτ) = -Pτ(λ Sgn(E)) + PTP∆(H),
where Ω \ ∆ indicates the complement set of set ∆ in Ω and ∣Ω \ ∆∣ denotes its cardinality.
Similar to the previous argument, when ∣Ω \ ∆∣ = mi - m2 > m0, with a probability 1 - 3n-β,
PTPω∖δPt(Z) : T → T is an one to one mapping, and therefore (PTPω∖δPt(Z))T is well defined.
Using this result, we have the following solution to the above equation
T = Pt Pω Pt (Pt Pω∖δPt )-i (-Pτ(λ sgn(E)) + PT Pδ(H))
We now bound kTk and k∆ k∞. Since kTk ≤ kTkF, we bound kT kF instead. First, according
to Corollary 3.5 in CandeS & Tao (2010), when β = 4, with a probability 1 - n-3, for any Z ∈ T,
we have
∣∣Pt⊥PωPt(PtPωPt)-1(Z)∣∣f ≤ kZkF.
Using this result, we have
k∆k∞ ≤ ξ(X) (kHk + kFk)
≤ ξ(X) (1 + kPT ⊥ (H)kF + kTk + kPT ⊥ (F)kF)
≤ ξ(X)(2+kTk+kTkF)
≤ ξ(X)[2+(2k+1)kTk]
In the last step, we use the fact that rank(T) ≤ 2k if T ∈ T. We then proceed to bound kTk as
follows
I® k ≤ μ(E)(λ + kT∞)
Combining the above two inequalities together, we have
∣∣eτ k	≤ ξ(X)μ(E)(2k +1)∣∣eτ k +2ξ(X)μ(E) + λμ(E)
K∆k∞	≤ ξ(X) [2 + (2k +1)μ(E)(λ + k6∆k∞),
which lead to
kTk ≤
k∆k∞	≤
λμ(E) + 2ξ(X)μ(E)
1 -(2k +1)ξ(X)μ(E)
2ξ(X) + (2k + 1)λξ(X)μ(E)
1 - (2k +1)ξ(X)μ(E)
Using the bound for k∆ k∞ and kT k, we now check the condition (8)
1	> μ(E) (λ + ^^£) + 2 + 2∣∣eτk
or
λ< 1-ξ(X)μ(E)(4k + 5)
For the condition (10), we have
λ>ξ(X)+ξ(X)kTk
or
ξ(X)-(2k - 1)ξ2(X)μ(E)
1 - 2(k + 1)ξ(X)μ(E)
To ensure that there exists λ ≥ 0 satisfies the above two conditions, we have
1 - 5(k + 1)ξ(X)μ(E) + (10k2 + 21k + 8)[ξ(X)μ(E)]2 > 0
and
1 - ξ(X)μ(E)(4k + 5) ≥ 0
Since the first condition is guaranteed to be satisfied for k ≥ 1, we have
£(X)〃(E) ≤ 4⅛.
Thus we finish the proof.
□
15
Under review as a conference paper at ICLR 2018
Appendix C: Data Statistics
We listed the detailed domains of the sentiment analysis tasks in Table 4. We removed the mu-
sical_instruments and tools_hardware domains from the original data because they have too few
labeled examples. The statistics for the 10 target tasks of intent classification in Table 5
Table 4: Statistics of the Multi-Domain Sentiment Classification Data.
Domains	#train	#Validation	#test
apparel	7398	926	928
automotive	601	69	66
baby	3405	437	414
beauty	2305	280	299
books	19913	2436	2489
Camera_photo	5915	744	749
CelLPhones_service	816	109	98
ComPuter_video_games	2201	274	296
dvd	19961	2624	2412
electronics	18431	2304	2274
gourmet_food	1227	182	166
grocery	2101	268	263
health_personal_care	5826	687	712
jewelry_watches	1597	188	196
kitchen_housewares	15888	1978	1990
magazines	3341	427	421
music	20103	2463	2510
office_ProduCts	337	54	40
outdoor_living	1321	143	135
software	1934	254	202
SPortS_outdoors	4582	566	580
toys_games	10634	1267	1246
video	19941	2519	2539
Table 5: Statistics of the User Intent Classification Data.
Dataset ID	#labeled instances	#labels
1	497	-∏-
2	3071	14
3	305	21
4	122	7
5	110	11
6	126	12
7	218	45
8	297	10
9	424	4
10		110		17
16