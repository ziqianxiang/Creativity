Published as a conference paper at ICLR 2018
Smooth Loss Functions for Deep Top-k
Classification
Leonard Berrada1, Andrew Zisserman1 and M. Pawan Kumar1,2
1 Department of Engineering Science
University of Oxford
2Alan Turing Institute
{lberrada,az,pawan}@robots.ox.ac.uk
Ab stract
The top-k error is a common measure of performance in machine learning and
computer vision. In practice, top-k classification is typically performed with deep
neural networks trained with the cross-entropy loss. Theoretical results indeed
suggest that cross-entropy is an optimal learning objective for such a task in the limit
of infinite data. In the context of limited and noisy data however, the use of a loss
function that is specifically designed for top-k classification can bring significant
improvements. Our empirical evidence suggests that the loss function must be
smooth and have non-sparse gradients in order to work well with deep neural
networks. Consequently, we introduce a family of smoothed loss functions that are
suited to top-k optimization via deep learning. The widely used cross-entropy is a
special case of our family. Evaluating our smooth loss functions is computationally
challenging: a naive algorithm would require O( Cn)) operations, where n is the
number of classes. Thanks to a connection to polynomial algebra and a divide-
and-conquer approach, we provide an algorithm with a time complexity of O(kn).
Furthermore, we present a novel approximation to obtain fast and stable algorithms
on GPUs with single floating point precision. We compare the performance of the
cross-entropy loss and our margin-based losses in various regimes of noise and
data size, for the predominant use case of k = 5. Our investigation reveals that our
loss is more robust to noise and overfitting than cross-entropy.
1	Introduction
In machine learning many classification tasks present inherent label confusion. The confusion
can originate from a variety of factors, such as incorrect labeling, incomplete annotation, or some
fundamental ambiguities that obfuscate the ground truth label even to a human expert. For example,
consider the images from the ImageNet data set (Russakovsky et al., 2015) in Figure 1, which
illustrate the aforementioned factors. To mitigate these issues, one may require the model to predict
the k most likely labels, where k is typically very small compared to the total number of labels. Then
the prediction is considered incorrect if all of its k labels differ from the ground truth, and correct
otherwise. This is commonly referred to as the top-k error. Learning such models is a longstanding
task in machine learning, and many loss functions for top-k error have been suggested in the literature.
In the context of correctly labeled large data, deep neural networks trained with cross-entropy have
shown exemplary capacity to accurately approximate the data distribution. An illustration of this
phenomenon is the performance attained by deep convolutional neural networks on the ImageNet
challenge. Specifically, state-of-the-art models trained with cross-entropy yield remarkable success on
the top-5 error, although cross-entropy is not tailored for top-5 error minimization. This phenomenon
can be explained by the fact that cross-entropy is top-k calibrated for any k (Lapin et al., 2016), an
asymptotic property which is verified in practice in the large data setting. However, in cases where
only a limited amount of data is available, learning large models with cross-entropy can be prone to
over-fitting on incomplete or noisy labels.
To alleviate the deficiency of cross-entropy, we present a new family of top-k classification loss
functions for deep neural networks. Taking inspiration from multi-class SVMs, our loss creates a
1
Published as a conference paper at ICLR 2018
Figure 1: Examples of images with label confusion, from the validation set of ImageNet. The top-left
image is incorrectly labeled as “red panda”, instead of “giant panda”. The bottom-left image is
labeled as “strawberry”, although the categories “apple”, “banana” and “pineapple” would be
other valid labels. The center image is labeled as “indigo bunting”, which is only valid for the lower
bird of the image. The right-most image is labeled as a cocktail shaker, yet could arguably be a
part of a music instrument (for example with label “cornet, horn, trumpet, trump”). Such examples
motivate the need to predict more than a single label per image.
margin between the correct top-k predictions and the incorrect ones. Our empirical results show that
traditional top-k loss functions do not perform well in combination with deep neural networks. We
believe that the reason for this is the lack of smoothness and the sparsity of the derivatives that are
used in backpropagation. In order to overcome this difficulty, we smooth the loss with a temperature
parameter. The evaluation of the smooth function and its gradient is challenging, as smoothing
increases the naive time complexity from O(n) to O((k)). With a connection to polynomial algebra
and a divide-and-conquer method, we present an algorithm with O(kn) time complexity and training
time comparable to cross-entropy in practice. We provide insights for numerical stability of the
forward pass. To deal with instabilities of the backward pass, we derive a novel approximation. Our
investigation reveals that our top-k loss outperforms cross-entropy in the presence of noisy labels
or in the absence of large amounts of data. We further confirm that the difference of performance
reduces with large correctly labeled data, which is consistent with known theoretical results.
2	Related Work
Top-k Loss Functions. The majority of the work on top-k loss functions has been applied to
shallow models: Lapin et al. (2016) suggest a convex surrogate on the top-k loss; Fan et al. (2017)
select the k largest individual losses in order to be robust to data outliers; Chang et al. (2017)
formulate a truncated re-weighted top-k loss as a difference-of-convex objective and optimize it with
the Concave-Convex Procedure (Yuille & Rangarajan, 2002); and Yan et al. (2017) propose to use a
combination of top-k classifiers and to fuse their outputs.
Closest to our work is the extensive review of top-k loss functions for computer vision by Lapin et al.
(2017). The authors conduct a study of a number of top-k loss functions derived from cross-entropy
and hinge losses. Interestingly, they prove that for any k, cross-entropy is top-k calibrated, which
is a necessary condition for the classifier to be consistent with regard to the theoretically optimal
top-k risk. In other words, cross-entropy satisfies an essential property to perform the optimal top-k
classification decision for any k in the limit of infinite data. This may explain why cross-entropy
performs well on top-5 error on large scale data sets. While thorough, the experiments are conducted
on linear models, or pre-trained deep networks that are fine-tuned. For a more complete analysis,
we wish to design loss functions that allow for the training of deep neural networks from a random
initialization.
Smoothing. Smoothing is a helpful technique in optimization (Beck & Teboulle, 2012). In work
closely related to ours, Lee & Mangasarian (2001) show that smoothing a binary SVM with a
temperature parameter improves the theoretical convergence speed of their algorithm. Schwing et al.
(2012) use a temperature parameter to smooth latent variables for structured prediction. Lapin et al.
(2017) apply Moreau-Yosida regularization to smooth their top-k surrogate losses.
2
Published as a conference paper at ICLR 2018
Smoothing has also been applied in the context of deep neural networks. In particular, Zheng et al.
(2015) and Clevert et al. (2016) both suggest modifying the non-smooth ReLU activation to improve
the training. Gulcehre et al. (2017) suggest to introduce “mollifyers” to smooth the objective function
by gradually increasing the difficulty of the optimization problem. Chaudhari et al. (2017) add a local
entropy term to the loss to promote solutions with high local entropy. These smoothing techniques are
used to speed up the optimization or improve generalization. In this work, we show that smoothing is
necessary for the neural network to perform well in combination with our loss function. We hope that
this insight can also help the design of losses for tasks other than top-k error minimization.
3	TOP-K SVM
3.1	Background: Multi-Class SVM
In order to build an intuition about top-k losses, we start with the simple case of k = 1, namely
multi-class classification, where the output space is defined as Y = {1, ..., n}. We suppose that a
vector of scores per label s ∈ Rn, and a ground truth label y ∈ Y are both given. The vector s is
the output of the model we wish to learn, for example a linear model or a deep neural network. The
notation 1 will refer to the indicator function over Boolean statements (1 if true, 0 if false).
Prediction. The prediction is given by any index with maximal score:
P(s) ∈ argmax s.	(1)
Loss. The classification loss incurs a binary penalty by comparing the prediction to the ground
truth label. Plugging in equation (1), this can also be written in terms of scores s as follows:
Λ(s, y), 1(y 6= P (s)) = 1(mj∈aYx sj >sy).
(2)
Surrogate. The loss in equation (2) is not amenable to optimization, as it is not even continuous in
s. To overcome this difficulty, a typical approach in machine learning is to resort to a surrogate loss
that provides a continuous upper bound on Λ. Crammer & Singer (2001) suggest the following upper
bound on the loss, known as the multi-class SVM loss:
l(s, y) = max	max {sj + 1} - sy, 0
(3)
In other words, the surrogate loss is zero if the ground truth score is higher than all other scores by a
margin of at least one. Otherwise it incurs a penalty which is linear in the difference between the
score of the ground truth and the highest score over all other classes.
Rescaling. Note that the value of 1 as a margin is an arbitrary choice, and can be changed to α for
any α > 0. This simply entails that we consider the cost Λ of a misclassification to be α instead of
1. Moreover, we show in Proposition 8 of Appendix D.2 how the choices of α and of the quadratic
regularization hyper-parameter are interchangeable.
3.2	Top-k Classification
We now generalize the above framework to top-k classification, where k ∈ {1, ..., n - 1}. We use
the following notation: forp ∈ {1, ..., n}, s[p] refers to the p-th largest element of s, and s\p to the
vector (s1, ..., sp-1, sp+1, ..., sn) ∈ Rn-1 (that is, the vector s with the p-th element omitted). The
term Y (k) denotes the set of k-tuples with k distinct elements of Y . Note that we use a bold font for a
tuple y ∈ Y(k) in order to distinguish it from a single label y ∈ Y.
Prediction. Given the scores s ∈ Rn, the top-k prediction consists of any set of labels correspond-
ing to the k largest scores:
Pk(S) ∈ {y ∈ Y(k) : ∀ i ∈{1,.., k}, Syi ≥ S[k]} .	(4)
3
Published as a conference paper at ICLR 2018
Loss. The loss depends on whether y is part of the top-k prediction, which is equivalent to comparing
the k-largest score with the ground truth score:
Λk (s, y) , 1(y ∈/ Pk (s)) = 1(s[k] > sy).	(5)
Again, such a binary loss is not suitable for optimization. Thus we introduce a surrogate loss.
Surrogate. As pointed out in Lapin et al. (2015), there is a natural extension of the previous
multi-class case:
lk(s,y) , max {(s∖y + l)[k] - Sy, 0} ∙
(6)
This loss creates a margin between the ground truth and the k-th largest score, irrespectively of the
values of the (k - 1)-largest scores. Note that we retrieve the formulation of Crammer & Singer
(2001) fork = 1.
Difficulty of the Optimization. The surrogate loss lk of equation (6) suffers from two disadvan-
tages that make it difficult to optimize: (i) it is not a smooth function of S - it is continuous but not
differentiable - and (ii) its weak derivatives have at most two non-zero elements. Indeed at most two
elements of S are retained by the (・)向 and max operators in equation (6). All others are discarded
and thus get zero derivatives. When lk is coupled with a deep neural network, the model typically
yields poor performance, even on the training set. Similar difficulties to optimizing a piecewise
linear loss have also been reported by Li et al. (2017) in the context of multi-label classification. We
illustrate this in the next section.
We postulate that the difficulty of the optimization explains why there has been little work exploring
the use of SVM losses in deep learning (even in the case k = 1), and that this work may help remedy
it. We propose a smoothing that alleviates both issues (i) and (ii), and we present experimental
evidence that the smooth surrogate loss offers better performance in practice.
3.3	Smooth Surrogate Loss
Reformulation. We introduce the following notation: given a label y ∈ Y, Y；k) is the subset of
tuples from Y(k) that include y as one of their elements. For y ∈ Y(k) and y ∈ Y, we further define
△k(y, y)，1(y ∈ y). Then, by adding and subtracting the k - 1 largest scores of s\y as well as Sy,
we obtain:
Ik (s,y) = max {(S\y + l)[k] - Sy, 0},
max
y∈Y(k)
△k(y,y) + ESj
j∈yy
- max
yy∈Yy(k)
X Sj I .
j ∈yy	
(7)
We give a more detailed proof of this in Appendix A.1. Since the margin can be rescaled without loss
of generality, we rewrite lk as:
Ik (s,y) = maχλ ∖ ∆k (y,y) + 1 X Sj
yy∈Y(k)	k
j∈yy
- max
yy∈Yy(k)
k x Sj
j ∈yy
(8)
Smoothing. In the form of equation (8), the loss function can be smoothed with a temperature
parameter τ > 0:
Lk,τ (S, y) = τlog	exp
yy∈Y(k)
1
△k(y, y) + T
k
j∈yy
Note that we have changed the notation to use Lk,τ to refer to the smooth loss. In what follows,
we first outline the properties of Lk,τ and its relationship with cross-entropy. Then we show the
empirical advantage of Lk,τ over its non-smooth counter-part lk.
4
Published as a conference paper at ICLR 2018
Properties of the Smooth Loss. The smooth loss Lk,τ has a few interesting properties. First,
for any τ > 0, Lk,τ is infinitely differentiable and has non-sparse gradients. Second, under mild
conditions, when τ → 0+ , the non-maximal terms become negligible, therefore the summations
collapse to maximizations and Lk,τ → lk in a pointwise sense (Proposition 2 in Appendix A.2).
Third, Lk,τ is an upper bound on lk if and only if k = 1 (Proposition 3 in Appendix A.3), but Lk,τ is,
up to a scaling factor, an upper bound on Λk (Proposition 4 in Appendix A.4). This makes it a valid
surrogate loss for the minimization of Λk .
Relationship with Cross-Entropy. We have previously seen that the margin can be rescaled by
a factor of α > 0. In particular, if we scale ∆ by α → 0+ and choose a temperature τ = 1, it can
be seen that L1,1 becomes exactly the cross-entropy loss for classification. In that sense, Lk,τ is
a generalization of the cross-entropy loss to: (i) different values of k ≥ 1, (ii) different values of
temperature and (iii) higher margins with the scaling α of ∆. For simplicity purposes, we will keep
α = 1 in this work.
Experimental Validation. In order to show how smoothing helps the training, we train a DenseNet
40-12 on CIFAR-100 from Huang et al. (2017) with the same hyper-parameters and learning rate
schedule. The only difference with Huang et al. (2017) is that we replace the cross-entropy loss with
L5,τ for different values of τ. We plot the top-5 training error in Figure 2a (for each curve, the value
of τ is held constant during training):
(a) Top-5 training error for different values of τ. The
dashed line y = 0.95 represents the base error for ran-
dom predictions. The successive drops in the curves
correspond to the decreases of the learning rate at
epochs 150 and 225.
(b) Proportion of non (numerically) zero elements in
the loss derivatives for different values of τ. These
values are obtained with the initial random weights of
the neural network, and are averaged over the training
set.
Figure 2: Influence of the temperature τ on the learning of a DenseNet 40-12 on CIFAR-100. We
confirm that smoothing helps the training of a neural network in Figure 2a, where a large enough
value of τ greatly helps the performance on the training set. In Figure 2b, we observe that such
high temperatures yield gradients that are not sparse. In other words, with a high temperature, the
gradient is informative about a greater number of labels, which helps the training of the model.
We remark that the network exhibits good accuracy when τ is high enough (0.01 or larger). For τ
too small, the model fails to converge to a good critical point. When τ is positive but small, the
function is smooth but the gradients are numerically sparse (see Figure 2b), which suggests that the
smoothness property is not sufficient and that non-sparsity is a key factor here.
5
Published as a conference paper at ICLR 2018
4	Computational Challenges and Efficient Algorithms
4.1	Challenge
Experimental evidence suggests that it is beneficial to use Lk,τ rather than lk to train a neural network.
However, at first glance, Lk,τ may appear prohibitively expensive to compute. Specifically, there are
summations over Y(k) and Yyk, which have a cardinality of (j) and (_-J respectively. For instance
for ImageNet, we have k = 5 and n = 1, 000, which amounts to nk ' 8.1012 terms to compute and
sum over for each single sample, thereby making the approach practically infeasible. This is in stark
contrast with lk, for which the most expensive operation is to compute the k-th largest score of an
array of size n, which can be done in O(n). To overcome this computational challenge, we will now
reframe the problem and reveal its exploitable structure.
For a vector e ∈ Rn and i ∈ {1, .., n}, we define σi(e) as the sum of all products of i distinct
elements of e. Explicitly, σi(e) can be written as σi(e) = P1≤j <...<j ≤n ej1 ...eji. The terms σi
are known as the elementary symmetric polynomials. We further define σ0(e) = 1 for convenience.
We now re-write Lk,τ using the elementary symmetric polynomials, which appear naturally when
separating the terms that contain the ground truth from the ones that do not:
Lk,τ(s,y) = T log	E exp(∆k(y,y)∕τ) ɪɪ eXp(Sj/kτ)
-	y∈γ(k)	j∈y	-
-	τ log	exp(Sj /k τ) ,
Ly∈γyk) j∈y	」
= τ log Σ ∏ exp(sj∕kτ) + exp (1∕τ)	exp(Sj /kτ)
Ly∈γyk) j∈y	y∈γ(k)∖γyk) j∈y	」
-	τ log X Y exp(Sj ∕k τ) ,	(10)
Ly∈γyk) j∈y	」
=τ log exp(sy∕kτ)σk-i(exp(s∖y∕kτ)) +exp(1∕τ) σk(exp(s∖y∕kτ))
一τlog exp(sy∕kτ)σk-i(exp(s∖y∕kτ)).
Note that the application of exp to vectors is meant in an element-wise fashion. The last equality of
equation (10) reveals that the challenge is to efficiently compute σk-1 and σk, and their derivatives
for the optimization.
While there are existing algorithms to evaluate the elementary symmetric polynomials, they have
been designed for computations on CPU with double floating point precision. For the most recent
work, see Jiang et al. (2016). To efficiently train deep neural networks with Lk,τ, we need algorithms
that are numerically stable with single floating point precision and that exploit GPU parallelization.
In the next sections, we design algorithms that meet these requirements. The final performance is
compared to the standard alternative algorithm in Appendix B.3.
4.2	Forward Computation
We consider the general problem of efficiently computing (σk-1, σk). Our goal is to compute σk(e),
where e ∈ Rn and k《n. Since this algorithm will be applied to e = exp(s∖y ∕kτ) (see equation
(10)), we can safely assume ei 6= 0 for all i ∈ J1, nK.
The main insight of our approach is the connection of σi (e) to the polynomial:
P , (X + e1)(X + e2)...(X + en).	(11)
Indeed, if we expand P to α0 + α1X + ... + αnXn, Vieta’s formula gives the relationship:
∀i ∈ J0, nK,	αi = σn-i(e).	(12)
6
Published as a conference paper at ICLR 2018
Therefore, it suffices to compute the coefficients αn-k to obtain the value of σk(e). To compute the
expansion of P, we can use a divide-and-conquer approach with polynomial multiplications when
merging two branches of the recursion.
This method computes all (σi)1≤i≤n instead of the only (σi)k-1≤i≤k that we require. Since we do
not need σi(e) for i > k, we can avoid computations of all coefficients for a degree higher than n - k.
However, typically k	n. For example, in ImageNet, we have k = 5 and n = 1, 000, therefore we
have to compute coefficients up to a degree 995 instead of 1,000, which is a negligible improvement.
n
To turn k《 n to our advantage, We notice that σi(e) = σn(e)σn-i(1∕e). Moreover, σn(e) = Q ei
i=1
can be computed in O(n). Therefore We introduce the polynomial:
Q , σn(e)(X +------)(X +----) …(X +----).	(13)
e1	e2	en
Then if We expand Q to β0 + β1 X + ... + βnXn , We obtain With Vieta’s formula again:
∀i ∈ JO,nK, βi = σn(e)σn-i(1∕e) = σi(e).	(14)
Subsequently, in order to compute σk (e), We only require the k first coefficients of Q, Which is
very efficient When k is small in comparison With n. This results in a time complexity of O(kn)
(Proposition 5 in Appendix B.1). Moreover, there are only O(log(n)) levels of recursion, and since
every level can have its operations parallelized, the resulting algorithm scales very Well With n When
implemented on a GPU (see Appendix B.3.2 for practical runtimes).
The algorithm is described in Algorithm 1: step 2 initializes the polynomials for the divide and
conquer method. While the polynomial has not been fully expanded, steps 5-6 merge branches
by performing the polynomial multiplications (Which can be done in parallel). Step 10 adjusts
the coefficients using equation (14). We point out that We could obtain an algorithm With a time
complexity of O(n log(k)2) if We Were using Fast Fourier Transform for polynomial multiplications
in steps 5-6. Since We are interested in the case Where k is small (typically 5), such an improvement
is negligible.
Algorithm 1 Forward Pass
Require: e ∈ (R1)n, k ∈ N*
1:	t — 0
2:	Pi(It - (1,1∕ei) for i ∈ J1,nK . Initialize n polynomials to X + ± (encoded by coefficients)
3:	P J n	. Number of polynomials
4:	while p > 1 do	. Merge branches With polynomial multiplications
5:	P(t+1) j Pf) * P2(t)	. Polynomial multiplication up to degree k
...
6:	P((p(-+11))//2 J Pp(-()1 * Pp(()
7:	t J t + 1
8:	p J (p - 1)∕∕2
9:	end while
n
10:	P ((+1) J P (() × Q ei
i=1
11:	return P ((+1)
. Polynomial multiplication up to degree k
. Update number of polynomials
. Recover σi(e) = σn-i(1∕e)σn(e)
Obtaining numerical stability in single floating point precision requires special attention: the use of
exponentials With an arbitrarily small temperature parameter is fundamentally unstable. In Appendix
B.2.1, We describe hoW operating in the log-space and using the log-sum-exp trick alleviates this
issue. The stability of the resulting algorithm is empirically verified in Appendix B.3.3.
4.3 Backward Computation
A side effect of using Algorithm 1 is that a large number of buffers are allocated for automatic
differentiation: for each addition in log-space, We apply log and exp operations, each of Which needs
to store values for the backWard pass. This results in a significant amount of time spent on memory
allocations, Which become the time bottleneck. To avoid this, We exploit the structure of the problem
7
Published as a conference paper at ICLR 2018
and design a backward algorithm that relies on the results of the forward pass. By avoiding the
memory allocations and considerably reducing the number of operations, the backward pass is then
sped up by one to two orders of magnitude and becomes negligible in comparison to the forward pass.
We describe our efficient backward pass in more details below.
First, we introduce the notation for derivatives:
∂σ (e)
For i ∈ J1,nK, 1 ≤ j ≤ k,	δj,i , -------.	* (15)
∂ei
We now observe that:
δj,i = σj-1 (e\i).	(16)
In other words, equation (16) states that δj,i, the derivative of σj (e) with respect to ei, is the sum of
product of all (j - 1)-tuples that do not include e%. One way of obtaining σj-ι (e" is to compute
a forward pass for e\i, which we would need to do for every i ∈ J1, nK. To avoid such expensive
computations, we remark that σj (e) can be split into two terms: the ones that contain ei (which can
expressed as eiσ7∙-ι(e∖i)) and the ones that do not (which are equal to σj(e\i) by definition). This
gives the following relationship:
σj(e\i) = σj(e) - ei°j-i(e\i).	(17)
Simplifying equation (17) using equation (16), we obtain the following recursive relationship:
δj,i = σj-1 (e) - eiδj-1,i .	(18)
Since the (σj(e))1≤i≤k have been computed during the forward pass, we can initialize the induction
with δ1,i = 1 and iteratively compute the derivatives δj,i for j ≥ 2 with equation (18). This is
summarized in Algorithm 2.
Algorithm 2 Backward Pass
Require: e, (σ7-(e))ι≤j≤k, k ∈ N*	. (σj(e))ι≤j≤k have been computed in the forward pass
1:	δ1,i = 1 for i ∈ J1, nK
2:	for j ∈ J1, kK do
3:	δj,i = σj-1 (e) - eiδj-1,i for i ∈ J1, nK
4:	end for
Algorithm 2 is subject to numerical instabilities (Observation 1 in Appendix B.2.2). In order to
avoid these, one solution is to use equation (16) for each unstable element, which requires numerous
forward passes. To avoid this inefficiency, we provide a novel approximation in Appendix B.2.2: the
computation can be stabilized by an approximation with significantly smaller overhead.
5 Experiments
Theoretical results suggest that Cross-Entropy (CE) is an optimal classifier in the limit of infinite
data, by accurately approximating the data distribution. In practice, the presence of label noise makes
the data distribution more complex to estimate when only a finite number of samples is available. For
these reasons, we explore the behavior of CE and Lk,τ when varying the amount of label noise and
the training data size. For the former, we introduce label noise in the CIFAR-100 data set (Krizhevsky,
2009) in a manner that would not perturb the top-5 error of a perfect classifier. For the latter, we vary
the training data size on subsets of the ImageNet data set (Russakovsky et al., 2015).
In all the following experiments, the temperature parameter is fixed throughout training. This choice
is discussed in Appendix D.1. The algorithms are implemented in Pytorch (Paszke et al., 2017) and
are publicly available at https://github.com/oval-group/smooth-topk. Experiments
on CIFAR-100 and ImageNet are performed on respectively one and two Nvidia Titan Xp cards.
5.1 CIFAR- 1 00 with noise
Data set. In this experiment, we investigate the impact of label noise on CE and L5,1. The CIFAR-
100 data set contains 60,000 RGB images, with 50,000 samples for training-validation and 10,000 for
testing. There are 20 “coarse” classes, each consisting of 5 “fine” labels. For example, the coarse
8
Published as a conference paper at ICLR 2018
class “people” is made up of the five fine labels “baby”, “boy”, “girl”, “man” and “woman”. In this
set of experiments, the images are centered and normalized channel-wise before they are fed to the
network. We use the standard data augmentation technique with random horizontal flips and random
crops of size 32 × 32 on the images padded with 4 pixels on each side.
We introduce noise in the labels as follows: with probability p, each fine label is replaced by a
fine label from the same coarse class. This new label is chosen at random and may be identical to
the original label. Note that all instances generated by data augmentation from a single image are
assigned the same label. The case p = 0 corresponds to the original data set without noise, and p = 1
to the case where the label is completely random (within the fine labels of the coarse class). With this
method, a perfect top-5 classifier would still be able to achieve 100 % accuracy by systematically
predicting the five fine labels of the unperturbed coarse label.
Methods. To evaluate our loss functions, we use the architecture DenseNet 40-40 from Huang
et al. (2017), and we use the same hyper-parameters and learning rate schedule as in Huang et al.
(2017). The temperature parameter is fixed to one. When the level of noise becomes non-negligible,
We empirically find that CE suffers from over-fitting and significantly benefits from early stopping -
which our loss does not need. Therefore we help the baseline and hold out a validation set of 5,000
images, on Which We monitor the accuracy across epochs. Then We use the model With the best top-5
validation accuracy and report its performance on the test set. Results are averaged over three runs
With different random seeds.
Table 1: Testing performance on CIFAR-100 with different levels of label noise. With noisy labels,
L5,1 consistently outperforms CEon both top-5 and top-1 accuracies, with improvements increasingly
significant with the level of noise. For reference, a model making random predictions would obtain
1% top-1 accuracy and 5% top-5 accuracy.
Noise Level	Top-1 Accuracy (%)		Top-5 Accuracy (%)	
	CE	L5,1	CE	L5,1
0.0	76.68	-^69.33	94.34	94.29
0.2	68.20	71.30	87.89	90.59
0.4	61.18	70.02	83.04	87.39
0.6	52.50	67.97	79.59	83.86
0.8	35.53	55.85	74.80	79.32
1.0	14.06	15.28	67.70	72.93
Results. As seen in Table 1, L5,1 outperforms CE on the top-5 testing accuracy When the labels
are noisy, With an improvement of over 5% in the case p = 1. When there is no noise in the labels,
CE provides better top-1 performance, as expected. It also obtains a better top-5 accuracy, although
by a very small margin. Interestingly, L5,1 outperforms CE on the top-1 error When there is noise,
although L5,1 is not a surrogate for the top-1 error. For example When p = 0.8, L5,1 still yields an
accuracy of 55.85%, as compared to 35.53% for CE. This suggests that When the provided label is
only informative about top-5 predictions (because of noise or ambiguity), it is preferable to use L5,1.
5.2 ImageNet
Data set. As shoWn in Figure 1, the ImageNet data set presents different forms of ambiguity and
noise in the labels. It also has a large number of training samples, Which alloWs us to explore different
regimes up to the large-scale setting. Out of the 1.28 million training samples, We use subsets of
various sizes and alWays hold out a balanced validation set of 50,000 images. We then report results
on the 50,000 images of the official validation set, Which We use as our test set. Images are resized so
that their smaller dimension is 256, and they are centered and normalized channel-Wise. At training
time, We take random crops of 224 × 224 and randomly flip the images horizontally. At test time, We
use the standard ten-crop procedure (Krizhevsky et al., 2012).
We report results for the folloWing subset sizes of the data: 64k images (5%), 128k images (10%),
320k images (25%), 640k images (50%) and finally the Whole data set (1.28M - 50k = 1.23M
images for training). Each strict subset has all 1,000 classes and a balanced number of images per
class. The largest subset has the same slight unbalance as the full ImageNet data set.
9
Published as a conference paper at ICLR 2018
Methods. In all the following experiments, we train a ResNet-18 (He et al., 2016), adapting the
protocol of the ImageNet experiment in Huang et al. (2017). In more details, we optimize the model
with Stochastic Gradient Descent with a batch-size of 256, for a total of 120 epochs. We use a
Nesterov momentum of 0.9. The temperature is set to 0.1 for the SVM loss (we discuss the choice
of the temperature parameter in Appendix D.1). The learning rate is divided by ten at epochs 30,
60 and 90, and is set to an initial value of 0.1 for CE and 1 for L5,0.1. The quadratic regularization
hyper-parameter is set to 0.0001 for CE. For L5,0.1, it is set to 0.000025 to preserve a similar relative
weighting of the loss and the regularizer. For both methods, training on the whole data set takes about
a day and a half (it is only 10% longer with L5,0.1 than with CE). As in the previous experiments,
the validation top-5 accuracy is monitored at every epoch, and we use the model with best top-5
validation accuracy to report its test error.
Probabilities for Multiple Crops. Using multiple crops requires a probability distribution over
labels for each crop. Then this probability is averaged over the crops to compute the final prediction.
The standard method is to use a softmax activation over the scores. We believe that such an approach
is only grounded to make top-1 predictions. The probability of a label y being part of the top-5
prediction should be marginalized over all combinations of 5 labels that include y as one of their
elements. This can be directly computed with our algorithms to evaluate σk and its derivative. We
refer the reader to Appendix C for details. All the reported results of top-5 error with multiple crops
are computed with this method. This provides a systematic boost ofat least 0.2% for all loss functions.
In fact, it is more beneficial to the CE baseline, by up to 1% in the small data setting.
Table 2: Top-5 accuracy (%) on ImageNet using training sets of various sizes. Results are reported
on the official validation set, which we use as our test set.
% Data Set	Number of Images	CE	L5,0.1
100%	1.23M	90.67	90.61
50%	640k	87.57	87.87
25%	320k	82.62	83.38
10%	128k	71.06	73.10
5%	64k	58.31	60.44
Results. The results of Table 2 confirm that L5,0.1 offers better top-5 error than CE when the
amount of training data is restricted. As the data set size increases, the difference of performance
becomes very small, and CE outperforms L5,0.1 by an insignificant amount in the full data setting.
6 Conclusion
This work has introduced a new family of loss functions for the direct minimization of the top-k error
(that is, without the need for fine-tuning). We have empirically shown that non-sparsity is essential
for loss functions to work well with deep neural networks. Thanks to a connection to polynomial
algebra and a novel approximation, we have presented efficient algorithms to compute the smooth
loss and its gradient. The experimental results have demonstrated that our smooth top-5 loss function
is more robust to noise and overfitting than cross-entropy when the amount of training data is limited.
We have argued that smoothing the surrogate loss function helps the training of deep neural networks.
This insight is not specific to top-k classification, and we hope that it will help the design of other
surrogate loss functions. In particular, structured prediction problems could benefit from smoothed
SVM losses. How to efficiently compute such smooth functions could open interesting research
problems.
Acknowledgments
This work was supported by the EPSRC grants AIMS CDT EP/L015987/1, Seebibyte EP/M013774/1,
EP/P020658/1 and TU/B/000048, and by Yougov. Many thanks to A. Desmaison and R. Bunel for
the helpful discussions.
10
Published as a conference paper at ICLR 2018
References
Amir Beck and Marc Teboulle. Smoothing and first order methods: A unified framework. SIAM
Journal on Optimization, 2012.
Xiaojun Chang, Yao-Liang Yu, and Yi Yang. Robust top-k multiclass SVM for visual category
recognition. International Conference on Knowledge Discovery and Data Mining, 2017.
Pratik Chaudhari, Anna Choromanska, Stefano Soatto, and Yann LeCun. Entropy-SGD: Biasing
gradient descent into wide valleys. International Conference on Learning Representations, 2017.
Djork-Arne Clevert, Thomas Unterthiner, and SePP Hochreiter. Fast and accurate deep network
learning by exponential linear units (ELUs). International Conference on Learning Representations,
2016.
Koby Crammer and Yoram Singer. On the algorithmic imPlementation of multiclass kernel-based
vector machines. Journal of Machine Learning Research, 2001.
Yanbo Fan, Siwei Lyu, Yiming Ying, and Bao-Gang Hu. Learning with average toP-k loss. Neural
Information Processing Systems, 2017.
Caglar Gulcehre, Marcin Moczulski, Francesco Visin, and Yoshua Bengio. Mollifying networks.
International Conference on Learning Representations, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. DeeP residual learning for image
recognition. Conference on Computer Vision and Pattern Recognition, 2016.
Gao Huang, Zhuang Liu, Kilian Q Weinberger, and Laurens van der Maaten. Densely connected
convolutional networks. Conference on Computer Vision and Pattern Recognition, 2017.
Hao Jiang, Stef Graillat, Roberto Barrio, and Canqun Yang. Accurate, validated and fast evaluation of
elementary symmetric functions and its aPPlication. Applied Mathematics and Computation, 2016.
Alex Krizhevsky. Learning multiple layers of features from tiny images, 2009.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deeP convolu-
tional neural networks. Neural Information Processing Systems, 2012.
Maksim LaPin, Matthias Hein, and Bernt Schiele. ToP-k multiclass SVM. Neural Information
Processing Systems, 2015.
Maksim LaPin, Matthias Hein, and Bernt Schiele. Loss functions for toP-k error: Analysis and
insights. Conference on Computer Vision and Pattern Recognition, 2016.
Maksim LaPin, Matthias Hein, and Bernt Schiele. Analysis and oPtimization of loss functions
for multiclass, toP-k, and multilabel classification. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 2017.
Yuh-Jye Lee and Olvi L Mangasarian. SSVM: A smooth suPPort vector machine for classification.
Computational optimization and Applications, 2001.
Yuncheng Li, Yale Song, and Jiebo Luo. ImProving Pairwise ranking for multi-label image classifica-
tion. Conference on Computer Vision and Pattern Recognition, 2017.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
Pytorch. NIPS Autodiff Workshop, 2017.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang,
Andrej KarPathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. ImageNet
Large Scale Visual Recognition Challenge. International Journal of Computer Vision, 2015.
Alexander G. Schwing, Tamir Hazan, Marc Pollefeys, and Raquel Urtasun. Efficient structured
Prediction with latent variables for general graPhical models. International Conference on Machine
Learning, 2012.
11
Published as a conference paper at ICLR 2018
Caixia Yan, Minnan Luo, Huan Liu, Zhihui Li, and Qinghua Zheng. Top-k multi-class svm using
multiple features. Information Sciences, 2017.
Alan L. Yuille and Anand Rangarajan. The concave-convex procedure (CCCP). Neural Information
Processing Systems, 2002.
Hao Zheng, Zhanlei Yang, Wenju Liu, Jizhong Liang, and Yanpeng Li. Improving deep neural
networks using softplus units. International Joint Conference on Neural Networks, 2015.
12
Published as a conference paper at ICLR 2018
Appendix
A	Surrogate Losses: Properties	14
A.1 Reformulation ............................................................. 14
A.2 Point-wise Convergence .................................................... 14
A.3 Bound on Non-Smooth Function .............................................. 15
A.4 Bound on Prediction Loss .................................................. 16
B	Algorithms: Properties & Performance	18
B.1	Time Complexity ......................................................... 18
B.2	Numerical Stability ..................................................... 19
B.2.1	Forward Pass ..................................................... 19
B.2.2	Backward Pass .................................................... 19
B.3	A Performance Comparison with the Summation Algorithm ................... 20
B.3.1	Summation Algorithm .............................................. 20
B.3.2	Speed ............................................................ 21
B.3.3	Stability ........................................................ 21
C Top-k Prediction: Marginalization with the Elementary Symmetric Polynomials 22
D Hyper-Parameters & Experimental Details	23
D.1 The Temperature Parameter ................................................. 23
D.1.1 Optimization and Learning .......................................... 23
D.1.2 Illustration on CIFAR-100 .......................................... 23
D.1.3 To Anneal or Not To Anneal ......................................... 23
D.1.4 Practical Methodology .............................................. 23
D.2	The Margin .............................................................. 24
D.2.1 Relationship with Squared Norm Regularization ...................... 24
D.2.2 Experiment on ImageNet ............................................. 25
D.3	Supplementary Details ................................................... 25
13
Published as a conference paper at ICLR 2018
A Surrogate Losses: Properties
In this section, we fix n the number of classes. We let τ > 0 and k ∈ {1, ..., n - 1}. All following
results are derived with a loss lk defined as in equation (8):
lk (s, y)
max 1 1ss∖y + 1)同
- 1 Sy, 0}.
(19)
A. 1 Reformulation
Proposition 1. We can equivalently re-write lk as:
lk (s, y) = max
y∈Y(k)
△k (y ,y)
1
+ ⅛Σ
j∈y
- max
y∈γyk)
1 X Sj
j∈y
(20)
Proof.
lk(s,y)
max
1 s∖y + 1)
k	[k]
- 1Sy, 0},
max
1 s∖y + 1)
k	[k]
- 1 Sy, 0}+ ( 1 X S[j]
+ 1Sy
k-1
1 X
j=1
S[j]
+ 1Sy
max
1 s∖y + 1)
1	[k]
1 k-1	1 k-1
k X s[j],⅛ X Sj] +
j=1	j=1
1
7sy
y
k-1
k X Sj] +
j=1
ksy
1 + 7 X Sj > , max
1 j	Y(k)
j∈y	y y∈Yy
1 XSj )- ymYX) {1
Sj
j∈y
max max
I y∈Y(k)∖γyk)
- max
y∈γ(k)
1 X Sj
j∈y
+
—
—
(21)
□
A.2 Point-wise Convergence
Lemma 1. Let n ≥ 2 and e ∈ Rn. Assume that the largest element of e is greater than its second
largest element: e[1] > e[2]. Then lim τ log P exp(ei /τ) = e[1].
ττ→>00	i=1
Proof. For simplicity of notation, and without loss of generality, we suppose that the elements of e
are sorted in descending order. Then for i ∈ {2, ..n}, we have ei - e1 ≤ e2 - e1 < 0 by assumption,
and thus ∀ i ∈{2,..n}, lim exp((ei — eι)∕τ)=0. Therefore:
τ→0
τ>0
nn
lim	exp((ei - e1)∕τ) = lim exp((ei - e1)∕τ) = 1.	(22)
τ>0 i=1	i=1 τ>0
And thus:
lim τ log
τ→0
τ>0
exp((ei - e1)∕τ)	= 0.
(23)
14
Published as a conference paper at ICLR 2018
The result follows by noting that:
T log (X exp(ei∕τ)
eι + τ log (X exp((ei - eι)∕τ)
(24)
□
Proposition 2. Assume that s[k-1]
lim Lk,τ (s, y) = lk(s, y).
τ→0
τ>0
> s[k] and that s[k] > s[k+1] or ksy > 1 + ks[k]*
Then
Proof. From s[k] > s[k+i] or 1 Sy > 1 + 1 s[k]
strict maximum. Similarly, from s[k-1] > s[k] ,
Since Lk,τ can be Written as:
,one can see that max [∆k (y, y) + ɪ P Sj O is a
y∈Y(k) I	k j∈y J
We have that max ∖ - P Sjj is a strict maximum.
y∈γyk) Ik j∈y j
Lk,τ (s,y) = T log	X exp ((∆k (y,y) + 1 X s，/T
y∈Y(k)	'	j∈y
(25)
y∈γ!
(k)
j∈y
y
the result folloWs by tWo applications of Lemma 1.
□
A.3 B ound on Non-Smooth Function
Proposition 3. Lk,τ is an upper bound on lk if and only ifk = 1.
Proof. Suppose k = 1. Let S ∈ Rn and y ∈ Y. We introduce y* = argmax{∆ι(y, y) + sy}. Then
y∈Y
We have:
lι(s,y) = ∆1(y*,y) + sy* - Sy,
=τ log(exp((∆ι(y*,y) + Sy* )∕τ) - T logexp(sy∕τ),	〜、
(26)
≤ T log(fexp((∆ι(y,y) + Sy)∕τ) - T log exp(Sy∕τ) = Lι,τ(s,y)
y∈Y
NoW suppose k ≥ 2. We construct an example (s, y) such that Lk,τ (s, y) < lk(s, y). For simplicity,
We set y = 1. Then let S1 = α, Si = β for i ∈ {2, ..., k + 1} and Si = -∞ for i ∈ {k + 2, ..., n}.
The variables α and β are our degrees of freedom to construct the example. Assuming infinite values
simplifies the analysis, and by continuity of Lk,τ and lk, the proof Will hold for real values sufficiently
small. We further assume that 1 + 1 (β - α) > 0. Then can write lk(s, y) as:
lk(s,y) = 1 + 1(β - α).	(27)
k
Exploiting the fact that exp(Si ∕T) = 0 for i ≥ k + 2, we have:
X Y exp((1 + Sj)∕kT) = exp (1+β) ,	(28)
y∈Y (k)∖γyk) j∈y	∖	/
And:
X exp ((k X Sj)∕T )= k exp (α⅛≡).	(29)
y∈Yyk)	、 j∈y J	、	J
15
Published as a conference paper at ICLR 2018
This allows us to write Lk,τ as:
Lk,τ(s,y) = τ log (k exp (。+ (二"β) + exp (1+β)) — T log (k exp (。+(；； "β
=T log ( 1 + —μp(kJ
∖ k exp( *β
=T log 1 +
exp (1)
k exp(⅛
=T log(1+IeXP β(1+1(β—
(30)
We introduce X = 1 + 1 (β — α). Then we have:
Lk,τ (s, y) = T log (1 + 1 exp
(31)
And:
Ik (s, y) = x∙
For any value x > 0, we can find (α, β) ∈ R2 such that X
(32)
1 +1 (β — α) and that all our hypotheses
are verified. Consequently, We only have to prove that there exists x > 0 such that:
∆(x)，τ log (1 + ； exp
—x < 0.
(33)
We show that lim ∆(x) < 0, which will conclude the proof by continuity of ∆.
x-∞
∆(x) = τ log (1 + ； exp
=τ log (1 + 1 exp
—x,
=τ log exp
x
—T log(exp(-)),
τ
+ ɪ ) ----> T log(ɪ) < 0 since k ≥ 2.
k ) χ→∞	k
(34)
A.4 BOUND ON PREDICTION LOSS
Lemma 2. Let (p, q) ∈ N2 such that P ≤ q — 1 and q ≥ 1. Then (P) ≤ q (J 1).
Proof.
(P)	= (q — P — 1)!(p +1)!
(「A) —	(q- p)!P!
(P+ 1)
(35)
q—P
This is a monotonically increasing function of P ≤ q — 1, therefore it is upper bounded by its maximal
value at P = q — 1:
(36)
(P)	— (P + 1) V
UJ = ^Z^ ≤q.
□
□
16
Published as a conference paper at ICLR 2018
Lemma 3. Assume that y ∈/ Pk (s). Then we have:
1 X exp (X j) ≤ X exp (X j).	(37)
y∈γyk) V∈y ) y∈Y (k)∖γ(k)	V∈y )
Proof. Let j ∈ J0,k - 1K. We introduce the random variable Uj, whose probability distribution is
uniform over the set Uj，{y ∈ Yyk) : y ∩ Pk(S)= j}. Then Vj is the random variable such that
Vj |Uj replaces y from Uj With a value draWn uniformly from Pk(s). We denote by Vj the set of
values taken by Vj With non-zero probability. Since Vj replaces the ground truth score by one of the
values of Pk(S), it can be seen that:
Vj = {y ∈ Y(k)∖γyk) ： y ∩ Pk(s) = j + i}.
(38)
Furthermore, We introduce the scoring function f : y ∈ Y(k) → exp(春 P Sj). Since Pk (S) is the
set of the k largest scores and y ∈/ Pk (s), we have that:
j∈y
f(Vj|Uj) ≥ f(Uj )
Therefore We also have that:
EVj|Ujf(Vj) ≥ f(Uj)
This finally gives us:
with probability 1.
with probability 1.
(39)
(40)
EUjEVj|Ujf(Vj) ≥ EUjf(Uj),
EVjf(Vj) ≥ EUjf(Uj).
Making the (uniform) probabilities explicit, We obtain:
(41)
W VXj f(v) ≥
普 VXjf(V) ≥
ι⅛ Xf (u),
j u∈Uj
X f (u).
u∈Uj
(42)
To derive the set cardinalities, We reWrite Uj and Vj as:
Uj = {y ∈ Yyk) : y ∩ Pk(S) = j} = {y} × Pk(S)⑶ × (Y∖({y} ∪ Pk(S))(IT),
Vj = {y ∈ Y(k)\Yyk) ： y ∩ Pk(S) = j + i} = Pk(S)(j+1) × (Y∖({y} ∪ Pk(S))(IT).
Therefore We have that:
|Uj|= {y} ×Pk(S)(j) × (Y\({y} ∪ Pk(S))(k-j-1)
=kjnk--kj--ii,
And:
∣Vj∣ = Pk(S)(j+1) × (Y\({y} ∪ Pk(S))(k-j-1)
k	k-i
= j+i	j-i .
(44)
(45)
Therefore:
%	j )(n-j-1) ― (k)<k	by Lemma 2
∣Vj∣ = j+J(n-3) = (j+1)≤ by
Combining With equation (42), We obtain:
k X f(v) ≥ X f (u).
v∈Vj
u∈Uj
(46)
(47)
17
Published as a conference paper at ICLR 2018
We sum over j ∈ J0, k - 1K, which yields:
k-1	k-1
kXXf(v)≥XXf(u).	(48)
Finally, we note that {Uj}0≤j≤k-1 and {Vj}0≤j≤k-1 are respective partitions of Yy(k) and Y(k)\Yy(k),
which gives us the final result:
k X	f(v) ≥ X f(u).	(49)
v∈γ(k)∖γyk)	u∈γyk)
□
Proposition 4. Lk,τ is, up to a scaling factor, an upper bound on the prediction loss Λk:
Lk,τ (s, y) ≥ (1 - τ log(k))Λk(s, y).	(50)
Proof. Suppose that Λk (s, y) = 0. Then the inequality is trivial because Lk,τ (s, y) ≥ 0. We now
assume that Λk(s, y) = 1. Then there exist at least k higher scores than sy. To simplify indexing,
we introduce Zy(k) = Y (k)\Yy(k) and Tk the set of k labels corresponding to the k-largest scores. By
assumption, y ∈/ Tk since y is misclassified. We then write:
exp eχpOCy,y"τ) ɪɪuj = eχp(I/t) E Πuj+ E Πuj.	(51)
y∈Y(k)	j∈y	y∈z(k) j∈y	y∈γ(k) j∈y
Thanks to Lemma 3, we have:
XYuj ≥ k χ Yu^.	(52)
y∈zyk) j∈y	y∈γ(k) j∈y
Injecting this back into (51):
X exp (∆(y,y)∕τ) Y uj ≥ (1 + 1exp(1∕τ)) X Y uj,	(53)
y∈Y(k)	j∈y	y∈Y(k) j∈y
And back to the original loss:
Lk,τ(s,y) ≥ Tlog (1 + 1exp
(1/T))	uj - Tlog	uj
yy∈Yy(k) j∈yy
T log(1 + IeXP(I/T)) ≥ T log(IeXP(I/T))
yy∈Yy(k) j∈yy
T log(1) + 1 = 1 - T log(k).
k
(54)
□
B	Algorithms: Properties & Performance
B.1 Time Complexity
Lemma 4. Let P and Q be two polynomials of degree p and q. The time complexity of obtaining the
first r coefficients of PQ is O(min{r, p} min{r, q}).
Proof. The multiplication of two polynomials can be written as the convolution of their coefficients,
which can be truncated at degree r for each polynomial.	□
Proposition 5. The time complexity of Algorithm 1 is O(kn).
18
Published as a conference paper at ICLR 2018
Proof. Let N = log2 (n), or equivalently n = 2N. With the divide-and-conquer algorithm, the
complexity of computing the k first coefficients of P can be written as:
T(k,n)=2T(k, W)+min{k,n}2.	(55)
Indeed we decompose P = Q1Q2, with each Qi of degree n/2, and for these we compute their k
first coefficients in T(n2). Then given the k first coefficients of Qi and Q2, the k first coefficients of
P are computed in O(min{k, n}2) by Lemma 4. Then we can write:
T(k, n) = 2T(k, ^) + min{k, n}2,
(56)
2NTT(k, 2NLT)= 2NT{(M} +2NT min {k,尹鲁:
2N O(1)=O(n)
N-1	n 2
By summing these terms, we obtain T(k, n) = 2NT(k, 1) + £ 2j min < k, — > . Let n0
j=0	2j
∈N
n	n	2n0
such that -~~-τ < k ≤ --. In loose notation, We have k——
2n0+1	2n0	n
O(1). Then we can write:
N-1	n0	N-1
X 2j min {k, 2o = X2j min {k, 2o + χ 2j min {k, 2o,
j=0	j=0	j=n0+1
n0	N-1	2
=X 2j k2 + X 2j (2) ,	(57)
j=0	j=n0+1
= (2n0+1 - 1)k2 +n2(2-n0-1 - 2-N),
= O(kn).
Thus finally:
T(k, n) = 2NT(k, 1)+X 2j min {k,卷}2,
j=0	(58)
= O(n) + O(kn),
= O(kn).
□
B.2 Numerical Stability
B.2. 1 Forward Pass
In order to ensure numerical stability of the computation, we maintain all computations in the log
space: for a multiplication exp(x1) exp(x2), we actually compute and store x1 + x2; for an addition
exp(x1) + exp(x2) we use the “log-sum-exp” trick: we compute m = max{x1, x2}, and store
m + log(exp(x1 - m) + exp(x2 - m)), which guarantees stability of the result. These two operations
suffice to describe the forward pass.
B.2.2 Backward Pass
Observation 1. The backward recursion of Algorithm 2 is unstable when ei	1 and ei	max{ep}.
p6=i
n
Sketch of Proof. To see that, assume that when we compute ( P ep ) - ei , we make a numerical error
p=1
in the order of (e.g ' 10-5 for single floating point precision). With the numerical errors, we
19
Published as a conference paper at ICLR 2018
obtain approximate δ as follows:
△
<⅛ = 1,
n
62,i = σ1(e) - eiδ1,i = ɪ2 eP - ei = δ2,i + O(E),
p=1
63,i = σ2(e) - eiδ2,i = σ2(e) - ei(δ2,i + O(E)) = δ3,i + O(eiE)),
(59)
k-1
δk,i = σk-1 (e) - eiδk-1,i = ... = δk,i + O(ei	E)).
Since e%>1, We quickly obtain unstable results.	□
Definition 1. For p ∈ {0, ..., n - k}, we define the p-th order approximation to the gradient as:
δkp) , XX (-1)j σj.	(60)
j=0	ei
Proposition 6. If we approximate the gradient by its p-th order approximation as defined in equation
(60), the absolute error is:
Ki- 猾=σk++≠.	(61)
Proof. We remind equation (18), Which gives a recursive relationship for the gradients:
δj,i = σj-1(e) - eiδj-1,i.
This can be re-Written as:
δj-1,i = — (σj-1(e) - δj,i) .	(62)
ei
We write σk+p(e∖i) = δk+p+ι,i, and the result follows by repeated applications of equation (62) for
j ∈{k + 1, k + 2,…,k + P +1}.	□
Intuition. We have seen in Observation 1 that the recursion tends to be unstable for δj,i when ei
is among the largest elements. When that is the case, the ratio σk+p+e∖i)
decreases quickly with p.
This has two consequences: (i) the sum of equation (60) is stable to compute because the summands
have different orders of magnitude and (ii) the error becomes small. Unfortunately, it is difficult to
upper-bound the error of equation (61) by a quantity that is both measurable at runtime (without
expensive computations) and small enough to be informative. Therefore the approximation error
is not controlled at runtime. In practice, we detect the instability of δk,i : numerical issues arise
if subtracted terms have a very small relative difference. For those unstable elements we use the
p-th order approximation (to choose the value of p, a good rule of thumb is p ' 0.2k). We have
empirically found out that this heuristic works well in practice. Note that this changes the complexity
of the forward pass to O((k + p)n) since we need p additional coefficients during the backward. If
p ' 0.2k, this increases the running time of the forward pass by 20%, which is a moderate impact.
B.3 A Performance Comparison with the Summation Algorithm
B.3.1	S ummation Algorithm
The Summation Algorithm (SA) is an alternative to the Divide-and-Conquer (DC) algorithm for the
evaluation of the elementary symmetric polynomials. It is described for instance in (Jiang et al.,
2016). The algorithm can be summarized as follows:
Implementation. Note that the inner loop can be parallelized, but the outer one is essentially
sequential. In our implementation for speed comparisons, the inner loop is parallelized and a buffer
is pre-allocated for the σj,i .
20
Published as a conference paper at ICLR 2018
Algorithm 3 Summation Algorithm		
Re 1 2 3 4 5 6 7 8 9 10 11	quire: e ∈ Rn, k ∈ N* σo,i J 1 for 1 ≤ i ≤ n σj,i J 0 for i < j : σ1,1 J e1 : for i ∈ J2, nK do :	m J max{1, i + k - n} :	M J min{i, k} :	for i ∈ Jm, M K do :	σj,i J σj,i-1 + eiσj-1,i-1 :	end for : end for : return σk,n	. σj,i = σj (e1 , . . . , ei) . Do not define values for i < j (meaningless) . Initialize recursion
B.3.2	Speed
We compare the execution time of the DC and SA algorithms on a GPU (Nvidia Titan Xp). We use
the following parameters: k = 5, a batch size of 256 and a varying value of n. The following timings
are given in seconds, and are computed as the average of 50 runs. In Table 3, we compare the speed
of Summation and DC for the evaluation of the forward pass. In Table 4, we compare the speed of the
evaluation of the backward pass using Automatic Differentiation (AD) and our Custom Algorithm
(CA) (see Algorithm 2).
Table 3: Execution time (s) of the forward pass. The Divide and Conquer (DC) algorithm offers
nearly logarithmic scaling with n in practice, thanks to its parallelization. In contrast, the runtime of
the Summation Algorithm (SA) scales linearly with n.
n	100	1,000	10,000	100,000
SA	0.006	0.062	0.627	6.258
DC	0.011	0.018	0.024	0.146
We remind that both algorithms have a time complexity of O(kn). SA provides little parallelization
(the parallelizable inner loop is small for k n), which is reflected in the runtimes. On the other hand,
DC is a recursive algorithm with O(log(n)) levels of recursion, and all operations are parallelized at
each level of the recursion. This allows DC to have near-logarithmic effective scaling with n, at least
in the range {100 - 10, 000}.
Table 4: Execution time (s) of the backward pass. Our Custom Backward (CB) is faster than Automatic
Differentiation (AD).
n	100	1,000	10,000	100,000
DC (AD)	0.093	0.139	0.194	0.287
DC (CB)	0.007	0.006	0.020	0.171
These runtimes demonstrate the advantage of using Algorithm 2 instead of automatic differentiation.
In particular, we see that in the use case of ImageNet (n = 1, 000), the backward computation
changes from being 8x slower than the forward pass to being 3x faster.
B.3.3	Stability
We now investigate the numerical stability of the algorithms. Here we only analyze the numerical
stability, and not the precision of the algorithm. We point out that compensation algorithms are
useful to improve the precision of SA but not its stability. Therefore they are not considered in this
discussion.
Jiang et al. (2016) mention that SA is a stable algorithm, under the assumption that no overflow or
underflow is encountered. However this assumption is not verified in our use case, as we demonstrate
below. We consider that the algorithm is stable if no overflow occurs in the algorithm (underflows
21
Published as a conference paper at ICLR 2018
are not an issue for our use cases). We stress out that numerical stability is critical for our machine
learning context: if an overflow occurs, the weights of the learning model inevitably diverge to infinite
values.
To test numerical stability in a representative setting of our use cases, we take a random mini-batch
of 128 images from the ImageNet data set and forward it through a pre-trained ResNet-18 to obtain a
vector of scores per sample. Then we use the scores as an input to the SA and DC algorithms, for
various values of the temperature parameter τ . We compare the algorithms with single (S) and double
(D) floating point precision.
Table 5: Stability on forward pass. A setting is considered stable if no overflow has occurred.
τ	101	100	10-1	10-2	10-3	10-4
SA (S)	XT~	X	-^X^^	X	X	X
SA (D)	X	X	X	X	X	X
DC log (S)	X	X	X	X	X	X
DC log (D)	X	X	X	X	X	X
By operating in the log-space, DC is significantly more stable than SA. In this experimental setting,
DC log is stable in single floating point precision until τ = 10-36.
C Top-k Prediction: Marginalization with the Elementary
S ymmetric Polynomials
We consider the probability of label i being part of the final top-k prediction. To that end, we
marginalize over all k-tuples that contain i as one of their element. Then the probability of selecting
label i for the top-k prediction can be written as:
p(k)(X X eχp(X Sj).
y∈γ(k)	j∈y
(63)
Proposition 7. The unnormalized probability can be computed as:
(k)
pi
(X dlogσi(eχP(S))
dsi
(64)
Proof.
p(k) X exp(si)σk-i(exp(s∖i)),
) d"χp(S))
P( id exp(si) ,
dσi(exp(S))
dsi	.
(65)
Finally we can rescale the unnormalized probability pi(k) by σk(exp(S)) since the latter quantity is
independent of i. We obtain:
p (k)	1	dσi (exp(s))
Pi	(X σk(exp(s))	dsi
dlogσi(exp(S))
dsi
(66)
□
NB. We prefer to use d log σi(exP(S)) rather than dσi(exp(S)) for stability reasons. Once the
dsi	dsi
unnormalized probabilities are computed, they can be normalized by simply dividing by their sum.
22
Published as a conference paper at ICLR 2018
D	Hyper-Parameters & Experimental Details
D. 1 The Temperature Parameter
In this section, we discuss the choice of the temperature parameter. Note that such insights are not
necessarily confined to a top-k minimization: we believe that these ideas generalize to any loss that is
smoothed with a temperature parameter.
D.1.1 Optimization and Learning
When the temperature τ has a low value, propositions 3 and 4 suggest that Lk,τ is a sound learning ob-
jective. However, as shown in Figure 2a, optimization is difficult and can fail in practice. Conversely,
optimization with a high value of the temperature is easy, but uninformative about the learning: then
Lk,τ is not representative of the task loss we wish to learn.
In other words, there is a trade-off between the ease of the optimization and the quality of the
surrogate loss in terms of learning. Therefore, it makes sense to use a low temperature that still
permits satisfactory optimization.
D.1.2 Illustration on CIFAR- 1 00
In Figure 2a, we have provided the plots of the training objective to illustrate the speed of convergence.
In Table 6, we give the training and validation accuracies to show the influence of the temperature:
Table 6: Influence of the temperature parameter on the training accuracy and testing accuracy.
Temperature	Training Accuracy (%)	Testing Accuracy (%)
0	10:01	10:38
10-3	17.40	18.19
10-2	98.95	91.35
10-1	99.73	91.70
100	99.78	91.52
101	99.62	90.92
102	99.42	90.46
D.1.3 To Anneal or Not To Anneal
The choice of temperature parameter can affect the scale of the loss function. In order to preserve
a sensible trade-off between regularizer and loss, it is important to adjust the regularization hyper-
parameter(s) accordingly (the value of the quadratic regularization for instance). Similarly, the energy
landscape may vary significantly for a different value of the temperature, and the learning rate may
need to be adapted too.
Continuation methods usually rely on an annealing scheme to gradually improve the quality of the
approximation. For this work, we have found that such an approach required heavy engineering and
did not provide substantial improvement in our experiments. Indeed, we have mentioned that other
hyper-parameters depend on the temperature, thus these need to be adapted dynamically too. This
requires sensitive heuristics. Furthermore, we empirically find that setting the temperature to an
appropriate fixed value yields the same performance as careful fine-tuning of a pre-trained network
with temperature annealing.
D.1.4 Practical Methodology
We summarize the methodology that reflects the previous insights and that we have found to work
well during our experimental investigation. First, the temperature hyper-parameter is set to a low
fixed value that allows for the model to learn on the training data set. Then other hyper-parameters,
such as quadratic regularization and learning rate are adapted as usual by cross-validation on the
validation set. We believe that the optimal value of the temperature is mostly independent of the
architecture of the neural network, but is greatly influenced by the values of k and n (see how these
impact the number of summands involved in Lk,τ, and therefore its scale).
23
Published as a conference paper at ICLR 2018
D.2 The Margin
D.2.1 Relationship with S quared Norm Regularization
In this subsection, we establish the relationship between hyper-parameters of the margin and of the
regularization with a squared norm. Typically the regularizing norm is the Frobenius norm in deep
learning, but the following results will follow for any norm k ∙ k. Although We prove the result for our
top-k loss, we also point out that these results easily generalize to any linear latent structural SVM.
First, we make explicit the role of α in lk with an overload of notation:
Ik(s,y,α) = max {(s∖y + αl)[k] -Sy, θ} ,	(67)
where α is a non-negative real number. Now consider the problem of learning a linear top-k SVM on
a dataset (xi, yi)ι≤i≤N ∈ (Rd X {1,…，n})N. We (hyper-)parameterize this problem by λ and α:
(Pλ,α) ：	min λ∣∣wk2 + ɪ XIk(WTXi,yi,α).	(68)
w∈Rd×n 2	N
i=1
Definition 2. Let λ1 , λ2, α1, α2 ≥ 0. We say that (Pλ1,α1) and (Pλ2,α2) are equivalent if there exists
γ > 0, ν ∈ R such that:
W ∈ Rd×n is a solution of (Pλ1,ɑ1) ^⇒ (YW + V) is a solution of (Pλ2,ɑ2)	(69)
Justification. This definition makes sense because for γ > 0, ν ∈ R, (γw + ν) has the same
decision boundary as W. In other words, equivalent problems yield equivalent classifiers.
Proposition 8. Let λ, α ≥ 0.
1.	Ifα > 0 and λ > 0, then problem (Pλ,α) is equivalent to problems (Pαλ,1) and (P1,αλ).
2.	Ifα = 0 or λ = 0, then problem (Pλ,α) is equivalent to problem (P0,0).
Proof. Let W ∈ Rd×n . We introduce a constant β > 0. Then we can successively write:
W is a solution to (Pλ,α)
^⇒	w is a solution to min λ∣∣w∣2 + ɪ XIk(wtXi,yi,α), w∈Rd×n 2	N i=1
^⇒	w is a solution to min ^kwk2 + ɪ Xmax ∣ (WTχ + αl)	— wTXi, θl , w∈Rd×n 2	N	\y	[k]	y
^⇒	λ	1N	1	α	1 W is a SOIUtiOn to Wmid×n	2β kwk	+ N Σmax∣ (βw∖y xi	+ β 1)[k]-	βwy	xi,	0 j ,
^⇒	W is asolution to wmid×n βλk βwk2 + N Xmax { (1 wTyχi + α 1) [k] - 1 wTχi, 0},
^⇒	1W is a solution to min βλ kwk2 + ɪ X max < (WT^Xi + α 1 )	— wTXi, 0 ∖ , β	w∈Rd×n 2	N i=1	\y	β	[k]	y
^⇒	ɪw is a solution to (Pβλ,α). (70)
This holds for any β > 0.
If α > 0 and λ > 0, we show equivalence with (Pαλ,1) by setting β to α and with (P1,αλ) by setting
β to 1.
If α = 0, then j = 0 for any β > 0 and we can choose β as small as needed to make βλ arbitrarily
24
Published as a conference paper at ICLR 2018
small.
If λ = 0, βλ = 0 for any β > 0 and We can choose β as large as needed to make β arbitrarily small.
Note that we do not need any hypothesis on the norm ∣∣ ∙ ∣∣, the result makes only use of the positive
homogeneity property.	口
Consequence On Deep Networks. Proposition 8 shows that for a deep network trained with lk,
one can fix the value of α to 1, and treat the quadratic regularization of the last fully connected layer
as an independent hyper-parameter. By doing this rather than tuning α, the loss keeps the same scale
which may make it easier to find an appropriate learning rate.
When using the smooth loss, there is no direct equivalent to Proposition 8 because the log-sum-
exp function is not positively homogeneous. However one can consider that with a low enough
temperature, the above insight can still be used in practice.
D.2.2 Experiment on ImageNet
In this section, we provide experiments to qualitatively assess the importance of the margin by running
experiments with a margin of either 0 or 1. The following results are obtained on our validation set,
and do not make use of multiple crops.
Top-1 Error. As we have mentioned before, the case (k, τ, α) = (1, 1, 0) corresponds exactly to
Cross-Entropy. We compare this case against the same loss with a margin of 1: (k, τ, α) = (1, 1, 1).
We obtain the following results:
Margin Top-1 Accuracy (%)
0	71.03
1	71.15
Table 7:	Influence of the margin parameter on top-1 performance.
Top-5 Error. We now compare (k, τ, α) = (5, 0.1, 0) and (k, τ, α) = (5, 0.1, 1):
Margin
0
1
Top-5 Accuracy (%)
8912
89.45
Table 8:	Influence of the margin parameter on top-5 performance.
D.3 Supplementary Details
In the main paper, we report the average of the scores on CIFAR-100 for clarity purposes. Here, we
also detail the standard deviation of the scores for completeness.
Table 9: Testing performance on CIFAR-100 with different levels of label noise. We indicate the mean
and standard deviation (in parenthesis) for each score.
Noise Level	Top-1 Accuracy (%)		Top-5 Accuracy (%)	
	CE	L5,1	CE	L5,1
-00-	76.68 (0.38)	69.33 (0.27)	94.34 (0.09)	94.29 (0.10)
0.2	68.20 (0.50)	71.30 (0.79)	87.89 (0.08)	90.59 (0.08)
0.4	61.18 (0.97)	70.02 (0.40)	83.04 (0.38)	87.39 (0.23)
0.6	52.50 (0.27)	67.97 (0.51)	79.59 (0.36)	83.86 (0.39)
0.8	35.53 (0.79)	55.85 (0.80)	74.80 (0.15)	79.32 (0.25)
1.0	14.06 (0.13)	15.28 (0.39)	67.70 (0.16)	72.93 (0.25)
25