Published as a conference paper at ICLR 2018
Skip RNN: Learning to Skip State Updates in
Recurrent Neural Networks
Victor Campos#, Brendan Joul Xavier GirO-i-Nieto§, Jordi TorresI Shih-Fu Changr
,Barcelona SUPercomPUting Center, "Google Inc,
§Universitat Politecnica de Catalunya,「Columbia University
{victor.campos, jordi.torres}@bsc.es, bjou@google.com,
xavier.giro@upc.edu, shih.fu.chang@columbia.edu
Ab stract
Recurrent Neural Networks (RNNs) continue to show outstanding Performance
in sequence modeling tasks. However, training RNNs on long sequences often
face challenges like slow inference, vanishing gradients and difficulty in caPturing
long term dePendencies. In backProPagation through time settings, these issues
are tightly couPled with the large, sequential comPutational graPh resulting from
unfolding the RNN in time. We introduce the SkiP RNN model which extends
existing RNN models by learning to skiP state uPdates and shortens the effective
size of the comPutational graPh. This model can also be encouraged to Perform
fewer state uPdates through a budget constraint. We evaluate the ProPosed model
on various tasks and show how it can reduce the number of required RNN uPdates
while Preserving, and sometimes even imProving, the Performance of the baseline
RNN models. Source code is Publicly available at https://imatge-upc.
github.io/skiprnn-2017-telecombcn/.
1	Introduction
Recurrent Neural Networks (RNNs) have become the standard aPProach for Practitioners when ad-
dressing machine learning tasks involving sequential data. Such success has been enabled by the
aPPearance of larger datasets, more Powerful comPuting resources and imProved architectures and
training algorithms. Gated units, such as the Long Short-Term Memory (Hochreiter & Schmidhu-
ber, 1997) (LSTM) and the Gated Recurrent Unit (Cho et al., 2014) (GRU), were designed to deal
with the vanishing gradients Problem commonly found in RNNs (Bengio et al., 1994). These ar-
chitectures have been PoPularized, in Part, due to their imPressive results on a variety of tasks in
machine translation (Bahdanau et al., 2015), language modeling (Zaremba et al., 2015) and sPeech
recognition (Graves et al., 2013).
Some of the main challenges of RNNs are in their training and dePloyment when dealing with
long sequences, due to their inherently sequential behaviour. These challenges include throughPut
degradation, slower convergence during training and memory leakage, even for gated architectures
(Neil et al., 2016). Sequence shortening techniques, which can be seen as a sort of conditional
comPutation (Bengio et al., 2013; Bengio, 2013; Davis & Arel, 2013) in time, can alleviate these
issues. The most common aPProaches, such as croPPing discrete signals or reducing the samPling
rate in continuous signals, are based on heuristics and can be suboPtimal. In contrast, we ProPose
a model that is able to learn which samPles (i.e., elements in the inPut sequence) need to be used
in order to solve the target task. Consider a video understanding task as an examPle: scenes with
large motion may benefit from high frame rates, whereas only a few frames are needed to caPture
the semantics of a mostly static scene.
The main contribution of this work is a novel modification for existing RNN architectures that al-
lows them to skiP state uPdates, decreasing the number of sequential oPerations Performed, without
requiring any additional suPervision signal. This model, called SkiP RNN, adaPtively determines
whether the state needs to be uPdated or coPied to the next time steP. We show how the network can
*Work done while Victor Campos was a visiting scholar at Columbia University.
1
Published as a conference paper at ICLR 2018
be encouraged to perform fewer state updates by adding a penalization term during training, allow-
ing us to train models under different computation budgets. The proposed modification can generally
be integrated with any RNN and we show, in this paper, implementations with well-known RNNs,
namely LSTM and GRU. The resulting models show promising results on a series of sequence mod-
eling tasks. In particular, we evaluate the proposed Skip RNN architecture on six sequence learning
problems: an adding task, sine wave frequency discrimination, digit classification, sentiment analy-
sis in movie reviews, action classification in video, and temporal action localization in video1.
2	Related work
Conditional computation has been shown to gradually increase model capacity without proportional
increases in computational cost by exploiting certain computation paths for each input (Bengio et al.,
2013; Liu & Deng, 2017; Almahairi et al., 2016; McGill & Perona, 2017; Shazeer et al., 2017). This
idea has been extended in the temporal domain, such as in learning how many times an input needs
to be ”pondered” before moving to the next one (Graves, 2016) or designing RNN architectures
whose number of layers depend on the input data (Chung et al., 2017). Other works have addressed
time-dependent computation in RNNs by updating only a fraction of the hidden states based on the
current hidden state and input (Jernite et al., 2017), or following periodic patterns (Koutnik et al.,
2014; Neil et al., 2016). However, due to the inherently sequential nature of RNNs and the parallel
computation capabilities of modern hardware, reducing the size of the matrices involved in the
computations performed at each time step generally has not accelerated inference as dramatically
as hoped. The proposed Skip RNN model can be seen as form of conditional computation in time,
where the computation associated to the RNN updates may or may not be executed at every time
step. This idea is related to the UPDATE and COPY operations in hierarchical multiscale RNNs
(Chung et al., 2017), but applied to the whole stack of RNN layers at the same time. This difference
is key to allowing our approach to skip input samples, effectively reducing sequential computation
and shielding the hidden state over longer time lags. Learning whether to update or copy the hidden
state through time steps can be seen as a learnable Zoneout mask (Krueger et al., 2017) which is
shared between all the units in the hidden state. Similarly, it can be interpreted as an input-dependent
recurrent version of stochastic depth (Huang et al., 2016).
Selecting parts of the input signal is similar in spirit to the hard attention mechanisms that have
been applied to image regions (Mnih et al., 2014), where only some patches of the input image
are attended in order to generate captions (Xu et al., 2015) or detect objects (Ba et al., 2014). Our
model can be understood as generating a hard temporal attention mask on-the-fly given previously
seen samples, deciding which time steps should be attended and operating on a subset of input sam-
ples. Subsampling input sequences has been explored for visual storylines generation (Sigurdsson
et al., 2016b), although jointly optimizing the RNN weights and the subsampling mechanism is often
computationally infeasible and they use an Expectation-Maximization algorithm instead. Similar re-
search has been conducted for video analysis tasks, discovering minimally needed evidence for event
recognition (Bhattacharya et al., 2014) and training agents that decide which frames need to be ob-
served in order to localize actions in time (Yeung et al., 2016; Su & Grauman, 2016). Motivated by
the advantages of training recurrent models on shorter subsequences, efforts have been conducted
on learning differentiable subsampling mechanisms (Raffel & Lawson, 2017), although the com-
putational complexity of the proposed method precludes its application to long input sequences.
In contrast, our proposed method can be trained with backpropagation and does not degrade the
complexity of the baseline RNNs.
Accelerating inference in RNNs is difficult due to their inherently sequential nature, leading to the
design of Quasi-Recurrent Neural Networks (Bradbury et al., 2017) and Simple Recurrent Units
(Lei & Zhang, 2017), which relax the temporal dependency between consecutive steps. With the
goal of speeding up RNN inference, LSTM-Jump (Yu et al., 2017) augments an LSTM cell with
a classification layer that will decide how many steps to jump between RNN updates. Despite its
promising results on text tasks, the model needs to be trained with REINFORCE (Williams, 1992),
which requires defining a reasonable reward signal. Determining these rewards are non-trivial and
may not necessarily generalize across tasks. Moreover, the number of tokens read between jumps,
1Experiments on sine wave frequency discrimination, sentiment analysis in movie reviews and action clas-
sification in video are reported in the appendix due to space limitations.
2
Published as a conference paper at ICLR 2018
the maximum jump distance and the number of jumps allowed all need to be chosen in advance.
These hyperparameters define a reduced set of subsequences that the model can sample, instead of
allowing the network to learn any arbitrary sampling scheme. Unlike LSTM-Jump, our proposed
approach is differentiable, thus not requiring any modifications to the loss function and simplifying
the optimization process, and is not limited to a predefined set of sample selection patterns.
3	Model Description
An RNN takes an input sequence x = (x1, . . . , xT) and generates a state sequence s = (s1, . . . , sT)
by iteratively applying a parametric state transition model S from t = 1 to T :
st = S(st-1, xt)	(1)
We augment the network with a binary state update gate, ut ∈ {0, 1}, selecting whether the state of
the RNN will be updated (ut = 1) or copied from the previous time step (ut = 0). At every time
step t, the probability Ut+ι ∈ [0,1] of performing a state update at t + 1 is emitted. The resulting
architecture is depicted in Figure 1 and can be characterized as follows:
ut = fbinarize (Ut)	(2)
St = Ut ∙ S(st-1, Xt) + (1 - Ut) ∙ st-1	(3)
∆Ut = σ(WpSt + bp)	(4)
Ut+1 = Ut ∙ ∆Ut + (1 — Ut) ∙ (Ut + min(∆Ut, 1 — Ut))	(5)
where Wp is a weights vector, bp is a scalar bias, σ is the sigmoid function and fbinarize : [0, 1] →
{0, 1} binarizes the input value. Should the network be composed of several layers, some columns
of Wp can be fixed to 0 so that ∆Ut depends only on the states of a subset of layers (see Section
4.3 for an example with two layers). We implement fbinarize as a deterministic step function Ut =
round(Ut), although a stochastic sampling from a Bernoulli distribution Ut 〜BemOUlli(Ut) would
be possible as well.
The model formulation encodes the observation that the likelihood of requesting a new input to
update the state increases with the number of consecutively skipped samples. Whenever a state
update is omitted, the pre-activation of the state update gate for the following time step, Ut+ι, is
incremented by ∆Ut. On the other hand, if a state update is performed, the accumulated value is
flushed and Ut+ι = ∆Ut.
The number of skipped time steps can be computed ahead of time. For the particular formulation
used in this work, where fbinarize is implemented by means of a rounding function, the number of
skipped samples after performing a state update at time step t is given by:
Nskip(t) = min{n : n ∙ ∆Ut ≥ 0.5} — 1	(6)
where n ∈ Z+ . This enables more efficient implementations where no computation at all is per-
formed whenever Ut = 0. These computational savings are possible because ∆Ut = σ(WpSt+bp)=
σ(WpSt-ι + bp) = ∆Ut-ι when Ut = 0 and there is no need to evaluate it again, as depicted in
Figure 1d.
There are several advantages in reducing the number of RNN updates. From the computational
standpoint, fewer updates translates into fewer required sequential operations to process an input
signal, leading to faster inference and reduced energy consumption. Unlike some other models that
aim to reduce the average number of operations per step (Neil et al., 2016; Jernite et al., 2017),
ours enables skipping steps completely. Replacing RNN updates with copy operations increases
the memory of the network and its ability to model long term dependencies even for gated units,
since the exponential memory decay observed in LSTM and GRU (Neil et al., 2016) is alleviated.
During training, gradients are propagated through fewer updating time steps, providing faster con-
vergence in some tasks involving long sequences. Moreover, the proposed model is orthogonal to
recent advances in RNNs and could be used in conjunction with such techniques, e.g. normalization
(Cooijmans et al., 2017; Ba et al., 2016), regularization (Zaremba et al., 2015; Krueger et al., 2017),
variable computation (Jernite et al., 2017; Neil et al., 2016) or even external memory (Graves et al.,
2014; Weston et al., 2014).
3
Published as a conference paper at ICLR 2018
(a)	(b)
(c)	(d)
Figure 1: Model architecture of the proposed Skip RNN. (a) Complete Skip RNN architecture,
where the computation graph at time step t is conditioned on ut . (b) Architecture when the state
is updated, i.e. ut = 1. (c) Architecture when the update step is skipped and the previous state is
copied, i.e. Ut = 0. (d) In practice, redundant computation is avoided by propagating ∆Ut between
time steps when ut = 0.
3.1	Error gradients
The whole model is differentiable except for fbinarize , which outputs binary values. A common
method for optimizing functions involving discrete variables is REINFORCE (Williams, 1992), al-
though several estimators have been proposed for the particular case of neurons with binary outputs
(Bengio et al., 2013). We select the straight-through estimator (Hinton, 2012; Bengio et al., 2013),
which consists of approximating the step function by the identity when computing gradients during
the backward pass:
narize
(x)
∂x
(7)
1
This yields a biased estimator that has proven more efficient than other unbiased but high-variance
estimators such as REINFORCE (Bengio et al., 2013) and has been successfully applied in different
works (Courbariaux et al., 2016; Chung et al., 2017). By using the straight-through estimator as
the backward pass for fbinarize, all the model parameters can be trained to minimize the target loss
function with standard backpropagation and without defining any additional supervision or reward
signal.
3.2	Limiting computation
The Skip RNN is able to learn when to update or copy the state without explicit information about
which samples are useful to solve the task at hand. However, a different operating point on the
trade-off between performance and number of processed samples may be required depending on
the application, e.g. one may be willing to sacrifice a few accuracy points in order to run faster on
machines with a low computational power, or to reduce energy impact on portable devices. The
4
Published as a conference paper at ICLR 2018
proposed model can be encouraged to perform fewer state updates through additional loss terms, a
common practice in neural networks with dynamically allocated computation (Liu & Deng, 2017;
McGill & Perona, 2017; Graves, 2016; Jernite et al., 2017). In particular, we consider a cost per
sample condition
T
Lbudget = λ ∙
ut,
t=1
(8)
where Lbudget is the cost associated to a single sequence, λ is the cost per sample and T is the
sequence length. This formulation bears a similarity to weight decay regularization, where the
network is encouraged to slowly converge toward a solution where the norm of the weights is small.
Similarly, in this case the network is encouraged to converge toward a solution where fewer state
updates are required.
Although the above budget formulation is extensively studied in our experiments, other budget loss
terms can be used depending on the application. For instance, a specific number of samples may
be encouraged by applying a L1 or L2 loss between the target value and the number of updates per
sequence, PtT=1 ut .
4	Experiments
In the following section, we investigate the advantages of adding this state skipping to two common
RNN architectures, LSTM and GRU, for a variety of tasks. In addition to the evaluation metric for
each task, we report the number of RNN state updates (i.e., the number of elements in the input
sequence used by the model) and the number of floating point operations (FLOPs) as measures of
the computational load for each model. Since skipping an RNN update results in ignoring its corre-
sponding input, we will refer to the number of updates and the number of used samples (i.e. elements
in a sequence) interchangeably. With the goal of studying the effect of skipping state updates on the
learning capability of the networks, we also introduce a baseline which skips a state update with
probability pskip . We tune the skipping probability to obtain models that perform a similar number
of state updates to the Skip RNN models.
Training is performed with Adam (Kingma & Ba, 2014), learning rate of 10-4, β1 = 0.9, β2 =
0.999 and = 10-8 on batches of 256. Gradient clipping (Pascanu et al., 2013) with a threshold of
1 is applied to all trainable variables. Bias bp in Equation 4 is initialized to 1, so that all samples are
used at the beginning of training2. The initial hidden state so is learned during training, whereas Uo
is set to a constant value of 1 in order to force the first update at t = 1.
Experiments are implemented with TensorFlow3 and run on a single NVIDIA K80 GPU.
4.1	Adding Task
We revisit one of the original LSTM tasks (Hochreiter & Schmidhuber, 1997), where the network is
given a sequence of (value, marker) tuples. The desired output is the addition of only two values that
are marked with a 1, whereas those marked with a 0 need to be ignored. We follow the experimental
setup in Neil et al. (2016), where the first marker is randomly placed among the first 10% of samples
(drawn with uniform probability) and the second one is placed among the last half of samples (drawn
with uniform probability). This marker distribution yields sequences where at least 40% of the
samples are distractors and provide no useful information at all. However, it is worth noting that in
this task the risk of missing a marker is very large as compared to the benefits of working on shorter
subsequences.
2In practice, forcing the network to use all samples at the beginning of training improves its robustness
against random initializations of its weights and increases the reproducibility of the presented experiments. A
similar behavior was observed in other augmented RNN architectures such as Neural Stacks (Grefenstette et al.,
2015).
3https://www.tensorflow.org
5
Published as a conference paper at ICLR 2018
Model	Task solved	State updates	Inference FLOPs
LSTM	Yes	100.0% ± 0.0%	2.46 × 106
LSTM (pskip = 0.2)	No	80.0% ± 0.1%	1.97 × 106
LSTM (pskip = 0.5)	No	50.1% ± 0.1%	1.23 × 106
Skip LSTM, λ = 0	Yes	81.1% ± 3.6%	2.00 × 106
Skip LSTM, λ = 10-5	Yes	53.9% ± 2.1%	1.33 × 106
GRU	Yes	100.0% ± 0.0%	1.85 × 106
GRU (pskip = 0.02)	No	98.0% ± 0.0%	1.81 × 106
GRU (pskip = 0.5)	No	49.9% ± 0.6%	9.25 × 105
Skip GRU, λ = 0	Yes	97.9% ± 3.2%	1.81 × 106
Skip GRU, λ = 10-5	Yes	50.7% ± 2.6%	9.40 × 105
Table 1: Results for the adding task, displayed as mean ± std over four different runs. The task
is considered to be solved if the MSE is at least two orders of magnitude below the variance of the
output distribution.
We train RNN models with 110 units each on sequences of length 50, where the values are uniformly
drawn from U (-0.5, 0.5). The final RNN state is fed to a fully connected layer that regresses the
scalar output. The model is trained to minimize the Mean Squared Error (MSE) between the output
and the ground truth. We consider that a model is able to solve the task when its MSE on a held-out
set of examples is at least two orders of magnitude below the variance of the output distribution.
This criterion is a stricter version of the one followed by Hochreiter & Schmidhuber (1997).
While all models learn to solve the task, results in Table 1 show that Skip RNN models are able to
do so with roughly half of the updates of their corresponding counterparts. We observed that the
models using fewer updates never miss any marker, since the penalization in terms of MSE would
be very large (see Section B.1 for examples). This is confirmed by the poor performance of the
baselines that randomly skip state updates, which are not able to solve the tasks even when the
skipping probability is low. Skip RNN models learn to skip most of the samples in the 40% of the
sequence where there are no markers. Moreover, most updates are skipped once the second marker
is found, since all the relevant information in the sequence has already been seen. This last pattern
provides evidence that the proposed models effectively learn whether to update or copy the hidden
state based on the input sequence, as opposed to learning biases in the dataset only. As a downside,
Skip RNN models show some difficulties skipping a large number of updates at once, probably due
to the cumulative nature of Ut.
4.2	MNIST Classification from a Sequence of Pixels
The MNIST handwritten digits classification benchmark (LeCun et al., 1998) is traditionally ad-
dressed with Convolutional Neural Networks (CNNs) that efficiently exploit spatial dependencies
through weight sharing. By flattening the 28 × 28 images into 784-d vectors, however, it can be
reformulated as a challenging task for RNNs where long term dependencies need to be leveraged
(Le et al., 2015b). We follow the standard data split and set aside 5,000 training samples for valida-
tion purposes. After processing all pixels with an RNN with 110 units, the last hidden state is fed
into a linear classifier predicting the digit class. All models are trained for 600 epochs to minimize
cross-entropy loss.
Table 2 summarizes classification results on the test set after 600 epochs of training. Skip RNNs are
not only able to solve the task using fewer updates than their counterparts, but also show a lower
variation among runs and train faster (see Figure 2). We hypothesize that skipping updates make
the Skip RNNs work on shorter subsequences, simplifying the optimization process and allowing
the networks to capture long term dependencies more easily. A similar behavior was observed
for Phased LSTM, where increasing the sparsity of cell updates accelerates training for very long
sequences (Neil et al., 2016). However, the drop in performance observed in the models where the
state updates are skipped randomly suggests that learning which samples to use is a key component
in the performance of Skip RNN.
6
Published as a conference paper at ICLR 2018
Model	Accuracy	State updates	Inference FLOPs
LSTM	0.910 ± 0.045	784.00 ± 0.00	3.83 × 107
LSTM (pskip = 0.5)	0.893 ± 0.003	392.03 ± 0.05	1.91 × 107
Skip LSTM, λ = 10-4	0.973 ± 0.002	379.38 ± 33.09	1.86 × 107
GRU	0.968 ± 0.013	784.00 ± 0.00	2.87 × 107
GRU (pskip = 0.5)	0.912 ± 0.004	391.86 ± 0.14	1.44 × 107
Skip GRU, λ = 10-4	0.976 ± 0.003	392.62 ± 26.48	1.44 × 107
TANH-RNN (Le et al., 2015a)	0.350	784.00	-
iRNN (Le et al., 2015a)	0.970	784.00	-
uRNN (Arjovsky et al., 2016)	0.951	784.00	-
sTANH-RNN (Zhang et al., 2016)	0.981	784.00	-
LSTM (Cooijmans et al., 2017)	0.989	784.00	-
BN-LSTM (Cooijmans et al., 2017)	0.990	784.00	-
Table 2: Accuracy, used samples and average FLOPs per sequence at inference on the test set of
MNIST after 600 epochs of training. Results are displayed as mean ± std over four different runs.
(％) >U23UU<
IOO
80
60
40
20
0	100	200	300	400	500	600
Epochs
Figure 2: Accuracy evolution during training on the validation set of MNIST. The Skip GRU exhibits
lower variance and faster convergence than the baseline GRU. A similar behavior is observed for
LSTM and Skip LSTM, but omitted for clarity. Shading shows maximum and minimum over 4 runs,
while dark lines indicate the mean.
The performance of RNN models on this task can be boosted through techniques like recurrent batch
normalization (Cooijmans et al., 2017) or recurrent skip coefficients (Zhang et al., 2016). Cooijmans
et al. (2017) show how an LSTM with specific weight initialization schemes for improved gradient
flow (Le et al., 2015a; Arjovsky et al., 2016) can reach accuracy rates of up to 0.989%. Note that
these techniques are orthogonal to skipping state updates and Skip RNN models could benefit from
them as well.
Sequences of pixels can be reshaped back into 2D images, allowing to visualize the samples used
by the RNNs as a sort of hard visual attention model (Xu et al., 2015). Examples such as the ones
depicted in Figure 3 show how the model learns to skip pixels that are not discriminative, such as
the padding regions in the top and bottom of images. Similarly to the qualitative results for the
adding task (Section 4.1), attended samples vary depending on the particular input being given to
the network.
4.3	Temporal action localization on Charades
One popular approach to video analysis tasks today is to extract frame-level features with a CNN
and modeling temporal dynamics with an RNN (Donahue et al., 2015; Yue-Hei Ng et al., 2015).
Videos are commonly recorded at high sampling rates, generating long sequences with strong tem-
7
Published as a conference paper at ICLR 2018
Figure 3: Sample usage examples for the Skip LSTM with λ = 10-4 on the test set of MNIST. Red
pixels are used, whereas blue ones are skipped.
poral redundancies that are challenging for RNNs. Moreover, processing frames with a CNN is
computationally expensive and may become prohibitive for high frame rates. These issues have
been alleviated in previous works by using short clips (Donahue et al., 2015) or by downsampling
the original data in order to cover long temporal spans without increasing the sequence length ex-
cessively (Yue-Hei Ng et al., 2015). Instead of addressing the long sequence problem at the input
data level, we let the network learn which frames need to be used.
Charades (Sigurdsson et al., 2016a) is a dataset containing 9,848 videos annotated for 157 action
classes in a per-frame fashion. Frames are encoded using fc7 features from the RGB stream of a
Two-Stream CNN provided by the organizers of the challenge4, extracted at 6 fps. The encoded
frames are fed into two stacked RNN layers with 256 units each and the hidden state in the last RNN
layer is used to compute the update probability for the Skip RNN models. Since each frame may
be annotated with zero or more classes, the networks are trained to minimize element-wise binary
cross-entropy at every time step. Unlike the previous sequence tagging tasks, this setup allows us to
evaluate the performance of Skip RNN on a task where the output is a sequence as well.
Evaluation is performed following the setup by Sigurdsson et al. (2016c), but evaluating on 100
equally spaced frames instead of 25, and results are reported in Table 3. It is surprising that the
GRU baselines that randomly skip state updates perform on par with their Skip GRU counterparts
for low skipping probabilities. We hypothesize several reasons for this behavior, which was not
observed in previous experiments: (1) there is a supervision signal at every time step and the inputs
and (2) outputs are strongly correlated in consecutive frames. On the other hand, Skip RNN models
clearly outperform the random methods when fewer updates are allowed. Note that this setup is far
more challenging because of the longer time spans between updates, so properly distributing the
state updates along the sequence is key to the performance of the models. Interestingly, Skip RNN
models learn which frames need to be attended from RGB data and without having access to explicit
motion information.
Skip GRU tends to perform fewer state updates than Skip LSTM when the cost per sample is low or
none. This behavior is the opposite of the one observed in the adding task (Section 4.1), which may
be related to the observation that determining the best performing gated unit depends on the task at
hand Chung et al. (2014). Indeed, GRU models consistently outperform LSTM ones on this task.
This mismatch in the number of used samples is not observed for large values of λ, as both Skip
LSTM and Skip GRU converge to a comparable number of used samples.
A previous work reports better action localization performance by integrating RGB and optical flow
information as an input to an LSTM, reaching 9.60% mAP (Sigurdsson et al., 2016c). This boost
in performance comes at the cost of roughly doubling the number of FLOPs and memory footprint
of the CNN encoder, plus requiring the extraction of flow information during a preprocessing step.
Interestingly, our model learns which frames need to be attended from RGB data and without having
access to explicit motion information.
4http://vuchallenge.org/charades.html
8
Published as a conference paper at ICLR 2018
Model	mAP(%)	State updates	Inference FLOPs
LSTM	8.40	172.9 ± 47.4	2.65 × 1012
LSTM (pskip = 0.75)	8.11	43.3 ± 13.2	6.63 × 1011
LSTM (pskip = 0.90)	7.21	17.2 ± 6.1	2.65 × 1011
Skip LSTM, λ = 0	8.32	172.9 ± 47.4	2.65 × 1012
Skip LSTM, λ = 10-4	8.61	172.9 ± 47.4	2.65 × 1012
Skip LSTM, λ = 10-3	8.32	41.9 ± 11.3	6.41 × 1011
Skip LSTM, λ = 10-2	7.86	17.4 ± 4.4	2.66 × 1011
GRU	8.70	172.9 ± 47.4	2.65 × 1012
GRU (pskip = 0.10)	8.94	155.6 ± 42.9	2.39 × 1012
GRU (pskip = 0.40)	8.81	103.6 ± 29.3	1.06 × 1012
GRU (pskip = 0.70)	8.42	51.9 ± 15.4	7.95 × 1011
GRU (pskip = 0.90)	7.09	17.3 ± 6.3	2.65 × 1011
Skip GRU, λ = 0	8.94	159.9 ± 46.9	2.45 × 1012
Skip GRU, λ = 10-4	8.76	100.8 ± 28.1	1.54 × 1012
Skip GRU, λ = 10-3	8.68	54.2 ± 16.2	8.29 × 1011
Skip GRU, λ = 10-2	7.95	18.4 ± 5.1	2.82 × 1011
Table 3: Mean Average Precision (mAP), used samples and average FLOPs per sequence at infer-
ence on the validation set of Charades. The number of state updates is displayed as mean ± std
over all the videos in the validation set.
5	Conclusion
We presented Skip RNNs as an extension to existing recurrent architectures enabling them to skip
state updates thereby reducing the number of sequential operations in the computation graph. Un-
like other approaches, all parameters in Skip RNN are trained with backpropagation. Experiments
conducted with LSTMs and GRUs showed that Skip RNNs can match or in some cases even out-
perform the baseline models while relaxing their computational requirements. Skip RNNs provide
faster and more stable training for long sequences and complex models, owing to gradients being
backpropagated through fewer time steps resulting in a simpler optimization task. Moreover, the
introduced computational savings are better suited for modern hardware than those methods that
reduce the amount of computation required at each time step (Koutnik et al., 2014; Neil et al., 2016;
Chung et al., 2017).
Acknowledgments
This work was partially supported by the Spanish Ministry of Economy and Competitivity and the
European Regional Development Fund (ERDF) under contracts TEC2016-75976-R and TIN2015-
65316-P, by the BSC-CNS Severo Ochoa program SEV-2015-0493, and grant 2014-SGR-1051 by
the Catalan Government. Victor Campos was supported by Obra Social “la Caixa” through La
Caixa-Severo Ochoa International Doctoral Fellowship program. We would also like to thank the
technical support team at the Barcelona Supercomputing Center.
References
Amjad Almahairi, Nicolas Ballas, Tim Cooijmans, Yin Zheng, Hugo Larochelle, and Aaron
Courville. Dynamic capacity networks. In ICML, 2016.
Martin Arjovsky, Amar Shah, and Yoshua Bengio. Unitary evolution recurrent neural networks. In
ICML, 2016.
Jimmy Ba, Volodymyr Mnih, and Koray Kavukcuoglu. Multiple object recognition with visual
attention. arXiv preprint arXiv:1412.7755, 2014.
Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint
arXiv:1607.06450, 2016.
9
Published as a conference paper at ICLR 2018
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. In ICLR, 2015.
Yoshua Bengio. Deep learning of representations: Looking forward. In SLSP, 2013.
Yoshua Bengio, Patrice Simard, and Paolo Frasconi. Learning long-term dependencies with gradient
descent is difficult. IEEE Transactions on Neural Networks, 1994.
Yoshua Bengio, Nicholas Leonard, and Aaron Courville. Estimating or propagating gradients
through stochastic neurons for conditional computation. arXiv preprint arXiv:1308.3432, 2013.
Subhabrata Bhattacharya, Felix X Yu, and Shih-Fu Chang. Minimally needed evidence for complex
event recognition in unconstrained videos. In ICMR, 2014.
James Bradbury, Stephen Merity, Caiming Xiong, and Richard Socher. Quasi-recurrent neural net-
works. In ICLR, 2017.
Joao Carreira and Andrew Zisserman. Quo vadis, action recognition? a new model and the kinetics
dataset. In CVPR, 2017.
KyUnghyUn Cho, Bart Van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. Learning phrase representations using rnn encoder-decoder
for statistical machine translation. In EMNLP, 2014.
Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of
gated recurrent neural networks on sequence modeling. arXiv preprint arXiv:1412.3555, 2014.
Junyoung Chung, Sungjin Ahn, and Yoshua Bengio. Hierarchical multiscale recurrent neural net-
works. In ICLR, 2017.
Tim Cooijmans, Nicolas Ballas, CeSar Laurent, Caglar GUlcehre, and Aaron Courville. Recurrent
batch normalization. In ICLR, 2017.
Matthieu Courbariaux, Itay Hubara, Daniel Soudry, Ran El-Yaniv, and Yoshua Bengio. Binarized
neural networks: Training deep neural networks with weights and activations constrained to+ 1
or-1. arXiv preprint arXiv:1602.02830, 2016.
Andrew Davis and Itamar Arel. Low-rank approximations for conditional feedforward computation
in deep neural networks. arXiv preprint arXiv:1312.4461, 2013.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. ImageNet: A large-scale
hierarchical image database. In CVPR, 2009.
Jeffrey Donahue, Lisa Anne Hendricks, Sergio Guadarrama, Marcus Rohrbach, Subhashini Venu-
gopalan, Kate Saenko, and Trevor Darrell. Long-term recurrent convolutional networks for visual
recognition and description. In CVPR, 2015.
Alex Graves. Adaptive computation time for recurrent neural networks. arXiv preprint
arXiv:1603.08983, 2016.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recur-
rent neural networks. In ICASSP, 2013.
Alex Graves, Greg Wayne, and Ivo Danihelka. Neural turing machines. arXiv preprint
arXiv:1410.5401, 2014.
Edward Grefenstette, Karl Moritz Hermann, Mustafa Suleyman, and Phil Blunsom. Learning to
transduce with unbounded memory. In NIPS, 2015.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In CVPR, 2016.
Geoffrey Hinton. Neural networks for machine learning. Coursera video lectures, 2012.
SePP Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 1997.
10
Published as a conference paper at ICLR 2018
Gao Huang, Yu Sun, Zhuang Liu, Daniel Sedra, and Kilian Q Weinberger. Deep networks with
stochastic depth. In ECCV, 2016.
Yacine Jernite, Edouard Grave, Armand Joulin, and Tomas Mikolov. Variable computation in recur-
rent neural networks. In ICLR, 2017.
Yoon Kim. Convolutional neural networks for sentence classification. In EMNLP, 2014.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Jan Koutnik, Klaus Greff, Faustino Gomez, and Juergen Schmidhuber. A clockwork rnn. In ICML,
2014.
David Krueger, Tegan Maharaj, Janos Kramar, Mohammad Pezeshki, Nicolas Ballas, Nan Rose-
mary Ke, Anirudh Goyal, Yoshua Bengio, Hugo Larochelle, Aaron Courville, et al. Zoneout:
Regularizing rnns by randomly preserving hidden activations. In ICLR, 2017.
Quoc V Le, Navdeep Jaitly, and Geoffrey E Hinton. A simple way to initialize recurrent networks
of rectified linear units. arXiv preprint arXiv:1504.00941, 2015a.
Quoc V Le, Navdeep Jaitly, and Geoffrey E Hinton. A simple way to initialize recurrent networks
of rectified linear units. arXiv preprint arXiv:1504.00941, 2015b.
Yann LeCun, Leon Bottou, YoshUa Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 1998.
Tao Lei and Yu Zhang. Training rnns as fast as cnns. arXiv preprint arXiv:1709.02755, 2017.
Lanlan Liu and Jia Deng. Dynamic deep neural networks: Optimizing accuracy-efficiency trade-offs
by selective execution. arXiv preprint arXiv:1701.00299, 2017.
Shayne Longpre, Sabeek Pradhan, Caiming Xiong, and Richard Socher. A way out of the odyssey:
Analyzing and combining recent insights for lstms. arXiv preprint arXiv:1611.05104, 2016.
Andrew L Maas, Raymond E Daly, Peter T Pham, Dan Huang, Andrew Y Ng, and Christopher
Potts. Learning word vectors for sentiment analysis. In ACL, 2011.
Mason McGill and Pietro Perona. Deciding how to decide: Dynamic routing in artificial neural
networks. In ICML, 2017.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Corrado, and Jeff Dean. Distributed representa-
tions of words and phrases and their compositionality. In NIPS, 2013.
Takeru Miyato, Andrew M Dai, and Ian Goodfellow. Adversarial training methods for semi-
supervised text classification. In ICLR, 2017.
Volodymyr Mnih, Nicolas Heess, Alex Graves, et al. Recurrent models of visual attention. In NIPS,
2014.
Daniel Neil, Michael Pfeiffer, and Shih-Chii Liu. Phased LSTM: accelerating recurrent network
training for long or event-based sequences. In NIPS, 2016.
Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural
networks. In ICML, 2013.
Colin Raffel and Dieterich Lawson. Training a subsampling mechanism in expectation. In ICLR
Workshop Track, 2017.
Noam Shazeer, Azalia Mirhoseini, Krzysztof Maziarz, Andy Davis, Quoc Le, Geoffrey Hinton, and
Jeff Dean. Outrageously large neural networks: The sparsely-gated mixture-of-experts layer. In
ICLR, 2017.
Evan Shelhamer, Kate Rakelly, Judy Hoffman, and Trevor Darrell. Clockwork convnets for video
semantic segmentation. arXiv preprint arXiv:1608.03609, 2016.
11
Published as a conference paper at ICLR 2018
Gunnar Sigurdsson, Gul Varol, Xiaolong Wang, Ali Farhadi, Ivan Laptev, and Abhinav Gupta. Hol-
lywood in homes: Crowdsourcing data collection for activity understanding. In ECCV, 2016a.
Gunnar A Sigurdsson, Xinlei Chen, and Abhinav Gupta. Learning visual storylines with skipping
recurrent neural networks. In ECCV, 2016b.
Gunnar A Sigurdsson, Santosh Divvala, Ali Farhadi, and Abhinav Gupta. Asynchronous temporal
fields for action recognition. arXiv preprint arXiv:1612.06371, 2016c.
Karen Simonyan and Andrew Zisserman. Two-stream convolutional networks for action recognition
in videos. In NIPS, 2014.
Khurram Soomro, Amir Roshan Zamir, and Mubarak Shah. Ucf101: A dataset of 101 human actions
classes from videos in the wild. arXiv preprint arXiv:1212.0402, 2012.
Yu-Chuan Su and Kristen Grauman. Leaving some stones unturned: dynamic feature prioritization
for activity detection in streaming video. In ECCV, 2016.
Du Tran, Lubomir Bourdev, Rob Fergus, Lorenzo Torresani, and Manohar Paluri. Learning spa-
tiotemporal features with 3d convolutional networks. In ICCV, 2015.
Jason Weston, Sumit Chopra, and Antoine Bordes. Memory networks. arXiv preprint
arXiv:1410.3916, 2014.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine learning, 1992.
Kelvin Xu, Jimmy Ba, Ryan Kiros, Kyunghyun Cho, Aaron Courville, Ruslan Salakhudinov, Rich
Zemel, and Yoshua Bengio. Show, attend and tell: Neural image caption generation with visual
attention. In ICML, 2015.
Serena Yeung, Olga Russakovsky, Greg Mori, and Li Fei-Fei. End-to-end learning of action detec-
tion from frame glimpses in videos. In CVPR, 2016.
Adams Wei Yu, Hongrae Lee, and Quoc V Le. Learning to skim text. In ACL, 2017.
Joe Yue-Hei Ng, Matthew Hausknecht, Sudheendra Vijayanarasimhan, Oriol Vinyals, Rajat Monga,
and George Toderici. Beyond short snippets: Deep networks for video classification. In CVPR,
2015.
Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals. Recurrent neural network regularization. In
ICLR, 2015.
Saizheng Zhang, Yuhuai Wu, Tong Che, Zhouhan Lin, Roland Memisevic, Ruslan R Salakhutdinov,
and Yoshua Bengio. Architectural complexity measures of recurrent neural networks. In NIPS,
2016.
12
Published as a conference paper at ICLR 2018
A Additional Experiments
A. 1 Frequency Discrimination Task
In this experiment, the network is trained to classify between sinusoids whose period is in range
T 〜U (5, 6) milliseconds and those whose period is in range T 〜{(1,5) ∪ (6,100)} milliseconds
(Neil et al., 2016). Every sine wave with period T has a random phase shift drawn fromU(0, T). At
every time step, the input to the network is a single scalar representing the amplitude of the signal.
Since sinusoid are continuous signals, this tasks allows to study whether Skip RNNs converge to the
same solutions when their parameters are fixed but the sampling period is changed. We study two
different sampling periods, Ts = {0.5, 1} milliseconds, for each set of hyperparameters.
We train RNNs with 110 units each on input signals of 100 milliseconds. Batches are stratified,
containing the same number of samples for each class, yielding a 50% chance accuracy. The last
state of the RNN is fed into a 2-way classifier and trained with cross-entropy loss. We consider that a
model is able to solve the task when it achieves an accuracy over 99% on a held-out set of examples.
Table 4 summarizes results for this task. When no cost per sample is set (λ = 0), the number
of updates differ under different sampling conditions. We attribute this behavior to the potentially
large number of local minima in the cost function, since there are numerous subsampling patterns
for which the task can be successfully solved and we are not explicitly encouraging the network to
converge to a particular solution. On the other hand, when λ > 0 Skip RNN models with the same
cost per sample use roughly the same number of input samples even when the sampling frequency
is doubled. This is a desirable property, since solutions are robust to oversampled input signals.
Qualitative results can be found in Section B.2.
Model	Ts = 1ms (length 100)		Ts = 0.5ms (length 200)	
	Task solved	State updates	Task solved	State updates
LSTM	Yes	100.0 ± 0.00	Yes	200.0 ± 0.00
Skip LSTM, λ = 0	Yes	55.5 ± 16.9	Yes	147.9 ± 27.0
Skip LSTM, λ = 10-5	Yes	47.4 ± 14.1	Yes	50.7 ± 16.8
Skip LSTM, λ = 10-4	Yes	12.7 ± 0.5	Yes	19.9 ± 1.5
GRU	Yes	100.0 ± 0.00	Yes	200.0 ± 0.00
Skip GRU, λ = 0	Yes	73.7 ± 17.9	Yes	167.0 ± 18.3
Skip GRU, λ = 10-5	Yes	51.9 ± 10.2	Yes	54.2 ± 4.4
Skip GRU, λ = 10-4	Yes	23.5 ± 6.2	Yes	22.5 ± 2.1
Table 4: Results for the frequency discrimination task, displayed as mean ± std over four different
runs. The task is considered to be solved if the classification accuracy is over 99%. Models with
the same cost per sample (λ > 0) converge to a similar number of used samples under different
sampling conditions.
A.2 Sentiment Analysis on IMDB
The IMDB dataset (Maas et al., 2011) contains 25,000 training and 25,000 testing movie reviews
annotated into two classes, positive and negative sentiment, with an approximate average length of
240 words per review. We set aside 15% of training data for validation purposes. Words are embed-
ded into 300-d vector representations before being fed to an RNN with 128 units. The embedding
matrix is initialized using pre-trained word2vec5 embeddings (Mikolov et al., 2013) when available,
or random vectors drawn from U (-0.25, 0.25) otherwise (Kim, 2014). Dropout with rate 0.2 is
applied between the last RNN state and the classification layer in order to reduce overfitting. We
evaluate the models on sequences of length 200 and 400 by cropping longer sequences and padding
shorter ones (Yu et al., 2017).
Results on the test are reported in Table 5. In a task where itis hard to predict which input tokens will
be discriminative, the Skip RNN models are able to achieve similar accuracy rates to the baseline
5https://code.google.com/archive/p/word2vec/
13
Published as a conference paper at ICLR 2018
models while reducing the number of required updates. These results highlight the trade-off between
accuracy and the available computational budget, since a larger cost per sample results in lower
accuracies. However, allowing the network to select which samples to use instead of cropping
sequences at a given length boosts performance, as observed for the Skip LSTM (length 400, λ =
10-4), which achieves a higher accuracy than the baseline LSTM (length 200) while seeing roughly
the same number of words per review. A similar behavior can be seen for the Skip RNN models with
λ = 10-3, where allowing them to select words from longer reviews boosts classification accuracy
while using a comparable number of tokens per sequence.
In order to reduce overfitting of large models, Miyato et al. (2017) leverage additional unlabeled
data through adversarial training and achieve a state of the art accuracy of 0.941 on IMDB. For an
extended analysis on how different experimental setups affect the performance of RNNs on this task,
we refer the reader to (Longpre et al., 2016).
Model		Length 200		Length 400	
		Accuracy	State updates	Accuracy	State updates
LSTM		0.843 ± 0.003	200.00 ± 0.00	0.868 ± 0.004	400.00 ± 0.00
Skip LSTM, λ	=0	0.844 ± 0.004	196.75 ± 5.63	0.866 ± 0.004	369.70 ± 19.35
Skip LSTM, λ =	10-5	0.846 ± 0.004	197.15 ± 3.16	0.865 ± 0.001	380.62 ± 18.20
Skip LSTM, λ =	10-4	0.837 ± 0.006	164.65 ± 8.67	0.862 ± 0.003	186.30 ± 25.72
Skip LSTM, λ =	10-3	0.811 ± 0.007	73.85 ± 1.90	0.836 ± 0.007	84.22 ± 1.98
GRU		0.845 ± 0.006	200.00 ± 0.00	0.862 ± 0.003	400.00 ± 0.00
Skip GRU, λ	=0	0.848 ± 0.002	200.00 ± 0.00	0.866 ± 0.002	399.02 ± 1.69
Skip GRU, λ =	10-5	0.842 ± 0.005	199.25 ± 1.30	0.862 ± 0.008	398.00 ± 2.06
Skip GRU, λ =	10-4	0.834 ± 0.006	180.97 ± 8.90	0.853 ± 0.011	314.30 ± 2.82
Skip GRU, λ =	10-3	0.800 ± 0.007	106.15 ± 37.92	0.814 ± 0.005	99.12 ± 2.69
Table 5: Accuracy and used samples on the test set of IMDB for different sequence lengths. Results
are displayed as mean ± std over four different runs.
A.3 Action classification on UCF-101
UCF-101 (Soomro et al., 2012) is a dataset containing 13,320 trimmed videos belonging to 101
different action categories. We use 10 seconds of video sampled at 25 fps, cropping longer ones
and padding shorter examples with empty frames. Activations in the Global Average Pooling layer
from a ResNet-50 (He et al., 2016) CNN pretrained on the ImageNet dataset (Deng et al., 2009) are
used as frame-level features, which are fed into two stacked RNN layers with 512 units each. The
weights in the CNN are not tuned during training to reduce overfitting. The hidden state in the last
RNN layer is used to compute the update probability for the Skip RNN models.
We evaluate the different models on the first split of UCF-101 and report results in Table 6. Skip
RNN models do not only improve the classification accuracy with respect to the baseline, but require
very few updates to do so, possibly due to the low motion between consecutive frames resulting in
frame-level features with high temporal redundancy (Shelhamer et al., 2016). Moreover, Figure 4
shows how models performing fewer updates converge faster thanks to the gradients being preserved
during longer spans when training with backpropagation through time.
Non recurrent architectures for video action recognition that have achieved high performance on
UCF-101 comprise CNNs with spatiotemporal kernels (Tran et al., 2015) or two-stream CNNs (Si-
monyan & Zisserman, 2014). Carreira & Zisserman (2017) show the benefits of expanding 2D CNN
filters into 3D and pretraining on larger datasets, obtaining an accuracy of 0.845 when using RGB
data only and 0.934 when incorporating optical flow information.
14
Published as a conference paper at ICLR 2018
Model	Accuracy State updates Inference FLOPs
LSTM		0.671	250.0	9.52	×	1011
Skip LSTM, λ	=0	0.749	138.9	5.29	×	1011
Skip LSTM, λ =	10-5	0.757	24.2	9.21	×	1010
Skip LSTM, λ =	10-4	0.790	7.6	2.89	×	1010
GRU		0.791	250.0	9.51	×	1011
Skip GRU, λ	=0	0.796	124.2	4.73	×	1011
Skip GRU, λ =	10-5	0.792	29.7	1.13	×	1011
Skip GRU, λ =	10-4	0.793	23.7	9.02	×	1010
I3D (RGB) (Carreira & Zisserman, 2017)		0.845	-		-	
Two-stream I3D (Carreira & Zisserman, 2017)		0.934	-		-	
Table 6: Accuracy, used samples and average FLOPs per sequence at inference on the validation set
of UCF-101 (split 1).
Oooo
8 6 4 2
(％) >U2DUU<
O
O	50	IOO	150	200	250	300
Epochs
Figure 4: Accuracy evolution during the first 300 training epochs on the validation set of UCF-101
(split 1). Skip LSTM models converge much faster than the baseline LSTM.
15
Published as a conference paper at ICLR 2018
B Qualitative results
This appendix contains additional qualitative results for the Skip RNN models.
B.1 Adding task
O
3n-",>」3*」婚E
O	IO	20	30	40	50
time step
O
3n-">」3*」婚E
0	10
20	30
time step
40	50
O
3n-",>」3*」婚E
O	10	20	30	40	50
time step
O
3n-">」3*」婚E
10
20	30
time step
40	50
1 O
3n->
O	10	20	30	40	50
time step
1 O
3n-">
10
20	30
time step
40	50
01
3n->」3*」婚E

0	10	20	30	40	50
time step
3n-",>」3*」婚E
0	* *∙∙*∙*∙*∙*∙∙*∙^	∙**∙88—>**X
0	10	20	30	40	50
time step
O
3n-">」3*」婚E
10	20	30	40	50
time step
3n-",>」3*」婚E
time step
Figure 5: Sample usage examples for the Skip GRU with λ = 10-5 on the adding task. Red dots
indicate used samples, whereas blue ones are skipped.
16
Published as a conference paper at ICLR 2018
B.2 Frequency discrimination task
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
∙1F⅛Ilr.
O
3pn-dlu
O
25
50	75 IOO 125	150	175	200
sample
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
O
3pn-dlu
O 25	50	75 IOO 125	150	175	200
sample
Figure 6: Sample usage examples for the Skip LSTM with λ = 10-4 on the frequency discrimina-
tion task with Ts = 0.5ms. Red dots indicate used samples, whereas blue ones are skipped. The
network learns that using the first samples is enough to classify the frequency of the sine waves, in
contrast to a uniform downsampling that may result in aliasing.
17