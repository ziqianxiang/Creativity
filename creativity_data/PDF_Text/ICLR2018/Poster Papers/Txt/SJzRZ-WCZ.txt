Published as a conference paper at ICLR 2018
Latent Space Oddity: on the Curvature
of Deep Generative Models
Georgios Arvanitidis, Lars Kai Hansen, S0ren Hauberg
Technical University of Denmark, Section for Cognitive Systems
{gear,lkai,sohau}@dtu.dk
Ab stract
Deep generative models provide a systematic way to learn nonlinear data distri-
butions through a set of latent variables and a nonlinear “generator” function that
maps latent points into the input space. The nonlinearity of the generator implies
that the latent space gives a distorted view of the input space. Under mild condi-
tions, we show that this distortion can be characterized by a stochastic Rieman-
nian metric, and we demonstrate that distances and interpolants are significantly
improved under this metric. This in turn improves probability distributions, sam-
pling algorithms and clustering in the latent space. Our geometric analysis further
reveals that current generators provide poor variance estimates and we propose a
new generator architecture with vastly improved variance estimates. Results are
demonstrated on convolutional and fully connected variational autoencoders, but
the formalism easily generalizes to other deep generative models.
1 Introduction
Deep generative models (Goodfellow et al., 2014; Kingma & Welling, 2014; Rezende et al., 2014)
model the data distribution of observations x ∈ X through corresponding latent variables z ∈ Z
and a stochastic generator function f : Z → X as
x= f (z).	(1)
Using reasonably low-dimensional latent variables and highly flexible generator functions allows
these models to efficiently represent a useful distribution over the underlying data manifold. These
approaches have recently attracted a lot of attention, as deep neural networks are suitable generators
which lead to the impressive performance of current variational autoencoders (VAEs) (Kingma &
Welling, 2014) and generative adversarial networks (GANs) (Goodfellow et al., 2014).
Consider the left panel of Fig. 1, which shows the latent representations of digits 0 and 1 from
MNIST under a VAE. Three latent points are highlighted: one point (A) far away from the class
boundary, and two points (B, C) near the boundary, but on opposite sides. Points B and C near the
boundary seem to be very close to each other, while the third is far away from the others. Intuitively,
we would hope that points from the same class (A and B) are closer to each other than to members of
other classes (C), but this is seemingly not the case. In this paper, we argue this seemed conclusion
is incorrect and only due to a misinterpretation of the latent space — in fact points A and B are
closer to each other than to C in the latent representation. Correcting this misinterpretation not
only improves our understanding of generative models, but also improves interpolations, clusterings,
latent probability distributions, sampling algorithms, interpretability and more.
In general, latent space distances lack physical units (making them difficult to interpret) and are sen-
sitive to specifics of the underlying neural nets. It is therefore more robust to consider infinitesimal
distances along the data manifold in the input space. Let z be a latent point and let ∆z1 and ∆z2 be
infinitesimals, then we can compute the squared distance
kf(z + ∆zi)- f(z + ∆Z2)k2 = (∆zι- ∆Z2)1 (J∣Jz)(∆zι- ∆z2),	Jz = f ,	(2)
z z=z
using Taylor’s Theorem. This implies that the natural distance function in Z changes locally as
it is governed by the local Jacobian. Mathematically, the latent space should not then be seen
1
Published as a conference paper at ICLR 2018
Which points are closer?
Figure 1: Left: An example of how latent space distances do not reflect actual data distances. Right:
Shortest paths on the surface spanned by the generator do not correspond to straight lines in the
latent space, as is assumed by the Euclidean metric.
Latent space
Input space
as a linear Euclidean space, but rather as a curved space. The right panel of Fig. 1 provides an
example of the implications of this curvature. The figure shows synthetic data from two classes,
and the corresponding latent representation of the data. The background color of the latent space
corresponds to χ/det(J|Jz), which can be seen as a measure of the local distortion of the latent
space. We interpolate two points from the same class by walking along the connecting straight
line (red); in the right panel, we show points along this straight line which have been mapped by
the generator to the input space. Since the generator defines a surface in the input space, we can
alternatively seek the shortest curve along this surface that connects the two points; this is perhaps
the most natural choice of interpolant. We show this shortest curve in green. From the center panel
it is evident that the natural interpolant is rather different from the straight line. This is due to the
distortion of the latent space, which is the topic of the present paper.
Outline. In Sec. 2 we briefly present the VAE as a representative instance of generative models.
In Sec. 3 we connect generative models with their underlying geometry, and in Sec. 4 we argue that
a stochastic Riemannian metric is naturally induced in the latent space by the generator. This metric
enables us to compute length-minimizing curves and corresponding distances. This analysis, how-
ever, reveals that the traditional variance approximations in VAEs are rather poor and misleading;
we propose a solution in Sec. 4.1. In Sec. 5 we demonstrate how the resulting view of the latent
space improves latent interpolations, gives rise to more meaningful latent distributions, clusterings
and more. We discuss related work in Sec. 6 and conclude the paper with an outlook in Sec. 7.
2	The Variational Autoencoders acting as the Generator
The variational autoencoder (VAE) proposed by Kingma & Welling (2014) is a simple yet powerful
generative model which consists of two parts: (1) an inference network or recognition network
(encoder) learns the latent representation (codes) of the data in the input space X = RD ; and (2) the
generator (decoder) learns how to reconstruct the data from these latent space codes in Z = Rd .
Formally, a prior distribution is defined for the latent representations p(z) = N (0, Id), and there
exists a mapping function μθ : Z → X that generates a surface in X. Moreover, We assume
that another function σθ : Z → R+D captures the error (or uncertainty) between the actual data
observation X ∈ X and its reconstruction as X = μθ(Z) + σθ Θ e, where e 〜N(0, ID) and Θ
is the Hadamard (element-wise) product. Then the likelihood is naturally defined as pθ (x | z) =
N(x | μθ(z), IDσ2(z)). The flexible functions μθ and σθ are usually deep neural networks with
parameters θ .
However, the corresponding posterior distribution pθ (z | X) is unknown, as the marginal likelihood
p(X) is intractable. Hence, the posterior is approximated using a variational distribution qφ(z | X) =
N(Z | μφ (x), Idσφ (x)), where the functions μ0 : X → Z and σφ : X → R& are again deep
neural networks with parameters φ. Since the generator (decoder) is a composition of linear maps
and activation functions, its smoothness is based solely on the chosen activation functions.
2
Published as a conference paper at ICLR 2018
The optimal parameters θ and φ are found by maximizing the evidence lower bound (ELBO) of the
marginal likelihood p(x) as
{θ*,φ*} = argmaxEq°(z∣χ)[log(pθ(x|z))] - KL(qφ(z∣x)∣∣p(z)),	(3)
θ,φ
where the bound follows from Jensen’s inequality. The optimization is based on variations of gra-
dient descent using the reparametrization trick (Kingma & Welling, 2014; Rezende et al., 2014).
Further improvements have been proposed that provide more flexible posterior approximations
(Rezende & Mohamed, 2015; Kingma et al., 2016) or tighter lower bound (Burda et al., 2016).
In this paper, we consider the standard VAE for simplicity. The optimization problem in Eq. 3 is
difficult since poor reconstructions by μθ can be explained by increasing the corresponding variance
σ2. A common trick, which We also follow, is to optimize μθ while keeping σ2 constant, and then
finally optimize for the variance σθ2 .
3 Surfaces as the Foundation of Generative Models
Mathematically, a deterministic generative model x = f (z) can be seen as a surface model (Gauss,
1827) if the generator f is sufficiently smooth. Here, we briefly review the basic concepts on sur-
faces, as they form the mathematical foundation of this work.
Intuitively, a surface is a smoothly-connected set of
points embedded in X . When we want to make
computations on a surface, it is often convenient to
parametrize the surface by a low-dimensional (latent)
variable z along with an appropriate function f : Z →
X . We let d = dim(Z) denote the intrinsic dimen-
sionality of the surface, while D = dim(X ) is the
dimensionality of the input space. If we consider a
smooth (latent) curve γt : [0, 1] → Z, then it has
—Latent space —
Input space
Figure 2: The Jacobian J of a nonlinear
function f provides a local basis in the in-
put space, while ʌ/det(j1 J) measures the
volume of an infinitesimal region.
length R1 kγt∣∣dt, where Yt = dγt/dt denotes the ve-
locity of the curve. In practice, the low-dimensional parametrization Z often lacks a principled
meaningful metric, so we measure lengths in input space by mapping the curve through f ,
Lengthf(Y t)] = ZO ∣∣f(71 )∣∣2 dt = ZO ∣∣jγ tY t∣∣2 dt,	jγ t = dff _	(4)
where the last step follows from the chain rule. This implies that the length of a curve γt along the
surface can be computed directly in the latent space using the (locally defined) norm
k jYY k2 = ʌ/ (JY Y)I(JYY) = JYI (JY JY )Y = JYIMYY ∙	⑸
Here, MY = JY JY is a symmetric positive definite matrix, which acts akin to a local Mahalanobis
distance measure. This gives rise to the definition of a Riemannian metric, which represents a
smoothly changing inner product structure.
Definition 1. A Riemannian metric M : Z → Rd×d is a smooth function that assigns a symmetric
positive definite matrix to any point in Z.
It should be clear that if the generator function f is sufficiently smooth, then MY in Eq. 5 is a
Riemannian metric.
When defining distances across a given surface, itis meaningful to seek the shortest curve connecting
two points. Then a distance can be defined as the length of this curve. The shortest curve connecting
points z0 and z1 is by (trivial) definition
Y(tshortest) = argminLength[f(Yt)],	Y0 = z0 , Y1 = z1∙	(6)
Yt
A classic result of differential geometry (do Carmo, 1992) is that solutions to this optimization
problem satisfy the following system of ordinary differential equations (ODEs)
1	1	∂vecMY	∂vecMY I
Yt = -2M-t1	2(Id ③	Y|) —dY	t	Yt-------dY	t	(Yt	③ Yt),	⑺
3
Published as a conference paper at ICLR 2018
where VecH stacks the columns of a matrix into a vector and 0 is the Kronecker product. For
completeness, we provide a derivation of this result in Appendix A. Shortest curves can then be
computed by solving the ODEs numerically; our implementation uses bvp5c from Matlab.
4 The Geometry of Stochastic Generators
In the previous section, we considered deterministic generators f to provide relevant background
information. We now extend these results to the stochastic case; in particular we consider
f (z) = μ(z) + σ(z) Θ €, μ : Z → X, σ : Z → RD, e 〜N(0, ID).	(8)
This is the generator driving VAEs and related models. For our purposes, We will call μ(∙) the mean
function and σ2(∙) the Variancefunction.
Following the discussion from the previous section, it is natural to consider the Riemannian metric
Mz = Jz|Jz in the latent space. Since the generator is now stochastic, this metric also becomes
stochastic, which complicates analysis. The following results, however, simplify matters.
Theorem 1.	If the stochastic generator in Eq. 8 has mean and variance functions that are at least
twice differentiable, then the expected metric equals
Mz= Ep(e) [Mz] = (jZμ))1 (JzM) + (Jzb))I (Jzb)) ,	(9)
where Jzμ) and Jzb) are the Jacobian matrices of μ(∙) and σ(∙).
Proof. See Appendix B.
Remark 1. By Definition 1, the metric tensor must change smoothly, which implies that the Ja-
cobians must be smooth functions as well. This is easily ensured with activation functions for the
neural networks that are C2 differentiable, e.g. tanh(∙), Sigmoid(∙), and SoftPlus(∙).
Theorem 2	(Due to Tosi et al. (2014)). The variance of the metric under the L2 measure vanishes
when the data dimension goes to infinity, i.e. limD→∞ Var (Mz) = 0.
Theorem 2 suggests that the (deterministic) expected metric MZ is
a good approximation to the underlying stochastic metric when the
data dimension is large. We make this approximation, which allows
us to apply the theory of deterministic generators.
This expected metric has a particularly appealing form, where the
two terms capture the distortion of the mean and the variance func-
tions respectively. In particular, the variance term (J(zb))|(J(zb))
will be large in regions of the latent space, where the generator has
large variance. This implies that induced distances will be large in
regions of the latent space where the generator is highly uncertain,
such that shortest paths will tend to avoid these regions. These paths
will then tend to follow the data in the latent space, c.f. Fig. 3. It is worth stressing, that no learning
is needed to compute this metric: it only consists of terms that can be derived directly from the
generator.
Figure 3: Example shortest
paths and distances.
4.1 Ensuring Proper Geometry Through Meaningful Variance Functions
Theorem 1 informs us about how the geometry of the generative model depends on both the mean
and the variance of the generator. Assuming successful training of the generator, we can expect to
have good estimates of the geometry in regions near the data. But what happens in regions further
away from the data? In general, the mean function cannot be expected to give useful extrapolations
to such regions, so it is reasonable to require that the generator has high variance in regions that are
not near the data. In practice, the neural net used to represent the variance function is only trained
in regions where data is available, which implies that variance estimates are extrapolated to regions
with no data. As neural nets tend to extrapolate poorly, practical variance estimates tend to be
arbitrarily poor in regions without data.
4
Published as a conference paper at ICLR 2018
Proposed variance estimate
Input space
Latent space
o latent repr.
--------ɪ------ɪ-
-3	0	3
Standard variance estimate
<Ξ>
6
3
f
Figure 4: From left to right: training data in X , latent representations in Z , the standard deviation
log(PjD=1 σj (z)) for the standard variance network, and the proposed solution.
Figure 4 illustrates this problem. The first two panels show the data and its corresponding latent
representations (here both input and latent dimensions are 2 to ease illustration). The third panel
shows the variance function under a standard architecture, deep multilayer perceptron with softplus
nonlinearity for the output layer. It is evident that variance estimates in regions without data are
not representative of either uncertainty or error of the generative process; sometimes variance is
high, sometimes it is low. From a probabilistic modeling point-of-view, this is disheartening. An
informal survey of publicly available VAE implementations also reveals that it is common to enforce
a constant unit variance everywhere; this is further disheartening.
For our purposes, we need well-behaved variance functions to ensure a well-behaved geometry,
but reasonable variance estimates are of general use. Here, as a general strategy, we propose to
model the inverse variance with a network that extrapolates towards zero. This at least ensures that
variances are large in regions without data. Specifically, We model the precision as βψ (Z) = σ21(z),
where all operations are element-wise. Then, we model this precision with a radial basis function
(RBF) neural network (Que & Belkin, 2016). Formally this is written
βψ(z) = Wv(z) + ζ, with vk(z) = exp -λk kz - ckk22 , k = 1, . . . ,K,	(10)
where ψ are all parameters, W ∈ R>D0×K are the positive weights of the network (positivity ensures
a positive precision), ck and λk are the centers and the bandwidth of the K radial basis functions,
and ζ → 0 is a vector of positive constants to prevent division by zero. It is easy to see that with
this approach the variance of the generator increases with the distance to the centers. The right-
most panel of Fig. 4 shows an estimated variance function, which indeed has the desired property
that variance is large outside the data support. Further, note the increased variance between the two
clusters, which captures that even interpolating between clusters comes with a level of uncertainty. In
Appendix C we also demonstrate that this simple variance model improves the marginal likelihood
p(x) on held-out data.
Training the variance network amounts to fitting the RBF net-
work. Assuming we have already trained the inference network
(Sec. 2), we can encode the training data, and use k-means to
estimate the RBF centers. Then, an estimate for the bandwidths
of each kernel can be computed as
λk = 1 卜 A X kzj-ck k2
Zj ∈Ck
-2
(11)
where the hyper-parameter a ∈ R+ controls the curvature of
the Riemannian metric, i.e. how fast it changes based on the
uncertainty. Since the mean function of the generator is already
trained, the weights of the RBF can be found using projected
gradient descent to ensure positive weights.
One visualization of the distortion of the latent space relative to
the input space is the geometric volume measure ʌ/det(MZ),
which captures the volume of an infinitesimal area in the input
space. Figure 5 shows this volume measure for both standard
20
15
10
5
0
Figure 5: Comparison of (log)
measures of standard (top) and
proposed (bottom) variances.
variance functions as well as our proposed RBF model. We see that the proposed model captures
the trend of the data, unlike the standard model.
5
Published as a conference paper at ICLR 2018
5 Empirical Results
We demonstrate the usefulness of the geometric view of the latent space with several experiments.
Model and implementation details can be found in Appendix D. In all experiments we first train a
VAE and then use the induced Riemannian metric.
5.1	Meaningful Distances
Digits	Linear	Riemannian
{0, 1, 2}	77.57(±0.87)%	94.28(±1.14)%
{3, 4, 7}	77.80(±0.91)%	89.54(±1.61)%
{5, 6, 9}	64.93(±0.96)%	81.13(±2.52)%
Table 1: The F -measure results for k-means.
First we seek to quantify if the induced Rie-
mannian distance in the latent space is more
useful than the usual Euclidean distance.
For this we perform basic k-means cluster-
ing under the two metrics. We construct 3
sets of MNIST digits, using 1000 random
samples for each digit. We train a VAE for
each set, and then subdivide each into 10 sub-sets, and performed k-means clustering under both
distances. One example result is shown in Fig. 6. Here it is evident that, since the latent points
roughly follow a unit Gaussian, there is little structure to be discovered by the Euclidean k-means,
and consequently it performs poorly. The Riemannian clustering is remarkably accurate. Summary
statistics across all subsets are provided in Table 1, which shows the established F -measure for clus-
tering accuracy. Again, the Riemannian metric significantly improves clustering. This implies that
the underlying Riemannian distance is more useful than its Euclidean counterpart.
RipmAnninn
RiirliHpan
Figure 6: The result of k-means comparing the distance measures. For the decision boundaries we
used 7-NN classification.
5.2	Interpolations
Next, we investigate whether the Riemannian metric gives more meaningful interpolations. First,
we train a VAE for the digits 0 and 1 from MNIST. The upper left panel of Fig. 7 shows the latent
space with the Riemannian measure as background color, together with two interpolations. Images
generated by both Riemannian and Euclidean interpolations are shown in the bottom of Fig. 7. The
Euclidean interpolations seem to have a very abrupt change when transitioning from one class to
another. The Riemannian interpolant gives smoother changes in the generated images. The top-
right panel of the figure shows the auto-correlation of images along the interpolants; again we see
a very abrupt change in the Euclidean interpolant, while the Riemannian is significantly smoother.
We also train a convolutional VAE on frames from a video. Figure 8 shows the corresponding latent
space and some sample interpolations. As before, we see more smooth changes in generated images
when we take the Riemannian metric into account.
5.3	Latent Probability Distributions
We have seen strong indications that the Riemannian metric gives a more meaningful view of the la-
tent space, which may also improve probability distributions in the latent space. A relevant candidate
distribution is the locally adaptive normal distribution (LAND) (Arvanitidis et al., 2016)
LAND(Z | μ, Σ) H exp (― Jdist∑(z, μ)) ,	(12)
6
Published as a conference paper at ICLR 2018
O	0.5	1
Figure 7: Left: the latent space with example interpolants. Right: auto-correlations of Riemannian
(top) and Euclidean (bottom) samples along the curves of the left panel. Bottom: decoded images
along Euclidean (top rows) and Riemannian (bottom rows) interpolants.
Figure 8: Left: the latent space and geodesic interpolants. Right: samples comparing Euclidean (top
row) with Riemannian (bottom row) interpolation. Corresponding videos can be found here.
where distΣ is the Riemannian extension of Mahalanobis distance. We fit a mixture of two LANDs
to the MNIST data from Sec. 5.2 alongside a mixture of Euclidean normal distributions. The first
column of Fig. 9 shows the density functions of the two mixture models. Only the Riemannian model
reveals the underlying clusters. We then sample 40 points from each component of these generative
models1 (center column of the figure). We see that the Riemannian model generates high-quality
samples, whereas the Euclidean model generates several samples in regions where the generator
is not trained and therefore produces blurry images. Finally, the right column of Fig. 9 shows all
pairwise distances between the latent points under both Riemannian and Euclidean distances. Again,
we see that the geometric view clearly reveals the underlying clusters.
5.4	Random Walk on the Data Manifold
Finally, we consider random walks over the data manifold, which is a common tool for exploring la-
tent spaces. To avoid the walk drifting outside the data support, practical implementations artificially
1We do not follow common practice and sort samples by their likelihood, as this hides low-quality samples.
7
Published as a conference paper at ICLR 2018
Mixture model PDF
-3
-3	0	3
Samples
Pairwise distance
Class 0
Class 1
Figure 9: From left to right: the mixture models, generated samples, and pairwise distances. Top
row corresponds to the Riemannian model and bottom row to the Euclidean model.
Class 0
Class 1
3
0
-3
-3	0	3
Figure 10: Left: the measure in the latent space. Right: the random walks.
restrict the walk to stay inside the [-1, 1]d hypercube. Here, we consider unrestricted Brownian mo-
tion under both the Euclidean and Riemannian metric. We perform this random walk in the latent
space of the convolutional VAE from Sec. 5.2. Figure 10 shows example walks, while Fig. 11 shows
generated images (video here). While the Euclidean random walk moves freely, the Riemannian
walk stays within the support of the data. This is explained in the left panel of Fig. 10, which shows
that the variance term in the Riemannian metric creates a “wall” around the data, which the random
walk will only rarely cross. These “walls” also force shortest paths to follow the data.
Step 200 Step 300
Figure 11: The comparison of the random walks, at the steps 200, 300, 3000, 4000 and 5000.
Step 3000 Step 4000 Step 5000

8
Published as a conference paper at ICLR 2018
6	Related Work
Generative models. This unsupervised learning category attracted a lot of attention, especially,
due to the advances on the deep neural networks. We have considered VAEs (Kingma & Welling,
2014; Rezende et al., 2014), but the ideas extend to similar related models. These include exten-
sions that provide more flexible approximate posteriors (Rezende & Mohamed, 2015; Kingma et al.,
2016). GANs (Goodfellow et al., 2014) also fall in this category, as these models have an explicit
generator. While the inference network is not a necessary component in the GAN model, it has been
shown that incorporating it improves overall performance (Donahue et al., 2017; Dumoulin et al.,
2017). The same thoughts hold for approaches that transform the latent space through a sequence of
bijective functions (Dinh et al., 2017)
Geometry in neural networks. Bengio et al. (2013) discuss the importance of geometry in neural
networks as a tool to understand local generalization. For instance, the Jacobian matrix is a measure
of smoothness for a function that interpolates a surface to the given data. This is exactly the implica-
tion in (Rifai et al., 2011), where the norm of the Jacobian acts as a regularizer for the deterministic
autoencoder. Recently, Kumar et al. (2017) used the Jacobian to inject invariances in a classifier.
Riemannian Geometry. Like the present paper, Tosi et al. (2014) derive a suitable Riemannian
metric in Gaussian process (GP) latent variable models (Lawrence, 2005), but the computational
complexity of GPs causes practical concerns. Unlike works that explicitly learn a Riemannian metric
(Hauberg et al., 2012; Peltonen et al., 2004), our metric is fully derived from the generator and
requires no extra learning once the generator is available.
7	Discussion and Further Extensions
The geometric interpretation of representation learning is that the latent space is a compressed and
flattened version of the data manifold. We show that the actual geometry of the data manifold can
be more complex than it first appears.
Here we have initiated the study of proper geometries for generative models. We showed that the
latent space not only provides a low-dimensional representation of the data manifold, but at the same
time, can reveal the underlying geometrical structure. We proposed a new variance network for the
generator, which provides meaningful uncertainty estimates while regularizing the geometry. The
new detailed understanding of the geometry provides us with more relevant distance measures, as
demonstrated by the fact that a k-means clustering, on these distances, is better aligned with the
ground truth label structure than a clustering based on conventional Euclidean distances. We also
found that the new distance measure produces smoother interpolation, and when training Rieman-
nian “LAND” mixture models based on the new geometry, the components aligned much better with
the ground truth group structure. Finally, inspired by the recent interest in sequence generation by
random walks in latent space, we found that geometrically informed random walks stayed on the
manifold for much longer runs than sequences based on Euclidean random walks.
The presented analysis easily extends to sophisticated generative models, where the latent space will
be potentially endowed with more flexible nonlinear structures. This directly implies particularly
interesting geometrical models. An obvious question is: can the geometry of the latent space play
a role while we learn the generative model? Either way, we believe that this geometric perspective
provides a new way of thinking and further interpreting the generative models, while at the same
time it encourages development of new nonlinear models in the representation space.
Acknowledgments
LKH is supported by Innovation Fund Denmark / the Danish Center for Big Data Analytics Driven
Innovation. SH was supported by a research grant (15334) from VILLUM FONDEN. This project
has received funding from the European Research Council (ERC) under the European Union’s Hori-
zon 2020 research and innovation programme (grant agreement no 757360). We gratefully acknowl-
edge the support of the NVIDIA Corporation with the donation of the used Titan Xp GPU.
9
Published as a conference paper at ICLR 2018
References
Georgios Arvanitidis, Lars Kai Hansen, and S0ren Hauberg. A Locally Adaptive Normal Distribu-
tion. In Advances in Neural Information Processing Systems (NIPS), 2016.
Yoshua Bengio, Aaron Courville, and Pascal Vincent. Representation Learning: A Review and New
PerSPectiveS. IEEE Trans. PatternAnal. Mach. Intell., 35(8):1798-1828, August 2013.
Yuri Burda, Roger B. Grosse, and Ruslan Salakhutdinov. Importance Weighted Autoencoders. In
International Conference on Learning Representations (ICLR), 2016.
Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using Real NVP. In
International Conference on Learning Representations (ICLR), 2017.
M.P. do Carmo. Riemannian Geometry. Mathematics (Boston, Mass.). Birkhauser, 1992.
Jeff Donahue, Philipp Krhenbhl, and Trevor Darrell. Adversarial Feature Learning. In International
Conference on Learning Representations (ICLR), 2017.
Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Alex Lamb, Martin Arjovsky, Olivier Mastropi-
etro, and Aaron Courville. Adversarially Learned Inference. In International Conference on
Learning Representations (ICLR), 2017.
Carl Friedrich Gauss. Disquisitiones generales circa superficies curvas. Commentationes Societatis
Regiae Scientiarum Gottingesis Recentiores, VI:99-146, 1827.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative Adversarial Nets. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2014.
S0ren Hauberg, Oren Freifeld, and Michael J. Black. A Geometric Take on Metric Learning. In
Advances in Neural Information Processing Systems (NIPS) 25, pp. 2033-2041, 2012.
Diederik P Kingma and Max Welling. Auto-Encoding Variational Bayes. In Proceedings of the 2nd
International Conference on Learning Representations (ICLR), 2014.
Diederik P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling.
Improved Variational Inference with Inverse Autoregressive Flow. In Advances in Neural Infor-
mation Processing Systems (NIPS), 2016.
Abhishek Kumar, Prasanna Sattigeri, and Tom Fletcher. Improved Semi-supervised Learning with
Gans using Manifold Invariances. In Advances in Neural Information Processing Systems (NIPS).
2017.
Neil Lawrence. Probabilistic non-linear principal component analysis with Gaussian process latent
variable models. Journal of machine learning research, 6(Nov):1783-1816, 2005.
Jaakko. Peltonen, Arto Klami, and Samuel Kaski. Improved learning of riemannian metrics for
exploratory analysis. Neural Networks, 17(8):1087-1100, 2004.
Qichao Que and Mikhail Belkin. Back to the future: Radial basis function networks revisited. In
Artificial Intelligence and Statistics (AISTATS), 2016.
Danilo Rezende and Shakir Mohamed. Variational Inference with Normalizing Flows. In Proceed-
ings of the 32nd International Conference on Machine Learning (ICML), 2015.
Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic Backpropagation and
Approximate Inference in Deep Generative Models. In Proceedings of the 31st International
Conference on Machine Learning (ICML), 2014.
Salah Rifai, Pascal Vincent, Xavier Muller, Xavier Glorot, and Yoshua Bengio. Contractive Auto-
Encoders: Explicit Invariance During Feature Extraction. In Proceedings of the 28th International
Conference on Machine Learning (ICML), 2011.
Alessandra Tosi, S0ren Hauberg, Alfredo Vellido, and Neil D. Lawrence. Metrics for Probabilistic
Geometries. In The Conference on Uncertainty in Artificial Intelligence (UAI), July 2014.
10
Published as a conference paper at ICLR 2018
A The Derivation of the Geodesic Differential Equation
The shortest path between two points x, y ∈ M on a Riemannian manifold M is found by optimiz-
ing the functional
YtShorteSt) = argmin Z qhγt, MYtYtidt,
γt	0
Y(0) = x, Y(1) = y
(13)
where Yt : [0,1] → M and Yt = 簪.The minima of this problem can be found instead by
optimizing the curve energy (do Carmo, 1992), So the functional becomeS
1
Y(ShOTteSt) = argmin / hγt, MYtYtidt, Y(O) = χ, γ⑴=y.
γt	0
(14)
The inner product can be written explicitly aS
dd
L(Yt,Yt,MYt) = 61,MYtYti	= XXY(i)	∙Y(j)	∙ MYj)	= (Yt	③	Yt)|vec[Mγt]	(15)
i=1 j=1
where the index in the parentheSiS repreSentS the correSponding element in the vector or matrix. In
the derivation the 0 is the usual Kronecker product and the vec[∙] stacks the column of a matrix into
a vector. We find the minimizerS by the Euler-Lagrange equation
where
∂ ∂L = ∂ dhYt, MYtYti
∂t ∂Y t	∂t	∂Y t
∂L ∂ ∂L
——=——：—
dY t dt d Y t
∂	∂M
=dt (2 ∙ MYtYt) = 2 ；Yt + MYtYt
(16)
(17)
Since the term
d MYt
∂t
∂Mγ(11)
∂t
.
.
.
∂MγD1)
∂t
∂Mγ(1D)
∂t
∂Mγ(2D)
∂t
∂MγDD)
∂t
∂M(11) |
--.~Yt— 7 .
∂y t	' t
∂M(21) |
___Yt  N
dY t	't
∂M(1D) |
--γt--- 7 .
∂Yt	' t
∂MY(2D) |
∂Yt	Y t
(18)
∂M(D1) |
---Yt——7 .
dY t %
∂M (DD) |
Yt
dYt	)t
we can write the right hand side of the Eq. 16 as
∂ ∂L
dtdY t
(Id 0 Y|) dvec卜Yt] Yt + MYtYt
(19)
The left hand side term of the Eq. 16 is equal to
∂L = ∂d- ((Yt 0 Yt)|vec[MYt]) = (Yt 0 Yt)| dVed"
∂Yt	∂Yt	∂Yt
The final system of 2nd order ordinary differential equations is
2 ∙ (Id 0 Y|)dv⅞M^Yt - dv⅞M^|(Yt 0 Yt)
∂Yt	∂Yt
(20)
(21)
B The Derivation of the Riemannian Metric
The proof of Theorem 1.
11
Published as a conference paper at ICLR 2018
Proof. As We introduced in Eq. 8 the stochastic generator is
f (z) = μ(z) + σ(z) Θ €,	μ : Z → X, σ : Z → RD, e 〜N(0, ID).	(22)
Thus, We can compute the corresponding Jacobian as folloWs
where Si
∂f(z) _T
∂z = Z
'dfZ21	∂fZI)..	,MII
∂zι ∂fZ2	∂Z2 ∂fZ2	..	。汛
∂zι . .	∂Z2 .. ..	∂Zd . .
. ∂fZD)	. ∂fZD)..	.. .∂fZD)
- ∂Z1	∂Z2	∂Zd
Γ处	∂μZI)	∂μZI)
∂Z1 a“Z2)		:	 . ∂Z2	. ―	 ∂⅛)
∂Z1 . .	—：	 . ∂Z2 .. .	. 	:	 ∂Zd . ..
. ∂μZD)	. ∂μZD)	∂μZD)
- ∂Z1		:	 . ∂Z2	. 	:	 ∂Zd
{z
A
∂σ(1)
z
∂zi
0
D×d
+ [S1e, S2e,…，Sde]D×d,
'---------7--------'
B
D×d
0
∂σ(2)
z
∂zi
00
0
0
.
.
.
∂σ手
__Z___
∂zi	-
, i = 1, .. ., d
D×D
(23)
(24)
(25)
and the resulting “random” metric in the latent space is MZ = J| Jz. The randomness is due to the
random variable e, and thus, we can compute the expectation
MZ = Epg [Mz] = Epg [(A + B)T(A + B)] = Epg [AτA + AτB + BTA + B|B].	(26)
Using the linearity of expectation we get that
Epg[AT B] = Ep(e) [At [S1e, S2e, ∙∙∙ , Sde]] = At[S⅛(^.0 ., 0] = 0	(27)
because Ep(e)[e] = 0. The other term
(28)
/「eτS1S1e eτS1S2e ∙∙∙	eτS1Sde 1∖
eτS2S1e e| S2S2e ∙∙∙	eτS2Sde
EpgU	.	:	.	:	I
eτSdS1e eτSdS2e :	e|SdSde )
(29)
with
∖]
/
2 [ ∂σZ1) ∂σZ1) ʌ	2 ∂ ∂σZ2) ∂σZ2) ʌ	2 ∂ ∂σZD) ∂σZD)∖
Epg U (H 行)+ 旬(H 行)+ ∙∙∙ £d ( F F )
(31)
(30)
diag(Si)Tdiag(Sj),
(32)
12
Published as a conference paper at ICLR 2018
because Ep() [i2] = 1, ∀i = 1, . . . , D.
The matrix A = jZ") and for the variance network
J(zσ)
∂σ(1)
z
∂σ(D)
z
∂zι
∂σ(1) z	∂σ(1) z
- .. dz2 ∂σZ2)	,. - 蒙2
—--z  ∙ ∙ ∂Z2 ..	■. 			 ∂zd .
. . ∂σZD)	.. `	∂σzD
			 .. ∂Z2	∂zd
(33)
it is easy to see that Ep() [B|B] = J(zσ) | J(zσ). So the expectation of the induced Riemannian
metric in the latent space by the generator is
M Z = (jZμ))l jZμ) + Jzσ)) | JZσ)	(34)
which concludes the proof.	□
C Influence of Variance on the Marginal Likelihood
We trained a VAE on the digits 0 and 1 of the MNIST scaled to [-1, 1]. We randomly split the data
to 90% training and 10% test data, ensuring balanced classes. First, we only trained the encoder and
the mean function of the decoder. Then, keeping these fixed, we trained two variance functions: one
based on standard deep neural network architecture, and the other using our proposed RBF model.
Clearly, we have two generators with the same mean function, but different variance functions.
Below we present the architectures for the standard neural networks. For the RBF model we used
32 centers and a = 1.
Encoder/Decoder	Layer 1	Layer 2	Layer 3
μφ	64, (SoftPlus)	32, (softplus)	d, (linear)
σφ	64, (Softplus)	32, (softplus)	d, (softplus)
μθ	32, (Softplus)	64, (softplus)	D, (tanh)
σθ	32, (Softplus)	64, (softplus)	D, (softplus)
The numbers corresponds to the layer size together with the activation function in parenthesis. Fur-
ther, the mean and the variance functions share the weights of the first layer. The input space
dimension is D = 784. Then, we computed the marginal likelihood p(x) of the test data using
Monte Carlo as:
P(X) = ∕p(x∣z)p(z)dz ` S Xp(x∣Zs), Zs 〜P(Z)
(35)
using S = 10000 samples. The generator with the standard variance function achieved -68.25 mean
log-marginal likelihood, while our proposed model -50.34, where the higher the better.
The reason why the proposed RBF model performs better can be easily analyzed. The marginal
likelihood under the Monte Carlo estimation is, essentially, a large Gaussian mixture model with
equal weights 1. Each mixture component is defined by the generator through the likelihood
p(x∣z) = N (X | μθ(z), IDσθ(Z)). Considering the variance term, the standard neural network
approach is trained on the given data points and the corresponding latent codes. Unfortunately,
its behavior is arbitrary in regions where there are not any encoded data. On the other hand our
proposed model assigns large variance to these regions, while on the regions where we have latent
codes its behavior will be approximately the same with the standard neural network. This implies
that the resulting marginal likelihood P(x) for the two models are highly similar in regions of high
data density, but significantly different elsewhere. The RBF variance model ensures that mixture
components in these regions have high variance, whereas the standard architecture assign arbitrary
variance. Consequently, the RBF-based P(x) assigns minimal density to regions with no data, and,
thus, attains higher marginal likelihood elsewhere.
13
Published as a conference paper at ICLR 2018
D Implementation Details for the Experiments
Algorithm 1 The training of a VAE that ensures geometry
Output: the estimated parameters of the neural networks θ, φ, ψ
1:	Train the 模©, σφ,从& as in Kingma & Welling (2014), keeping σψ fixed.
2:	Train the σψ as explained in Sec. 4.1.
Details for Experiments 5.1, 5.2 & 5.3. The pixel values of the images are scaled to the interval
[0,1]. We use for the functions 模©, σφ,从& multilayer perceptron (MLP) deep neural networks, and
for the βψ the proposed RBF model with 64 centers, so W ∈ RD×64 and the parameter a of Eq. 11
is set to 2. We used L2 regularization with parameter equal to 1e-5.
Encoder/Decoder	Layer 1	Layer 2	Layer 3
μφ	64, (tanh)	32, (tanh)	d, (linear)
σφ	64, (tanh)	32, (tanh)	d, (softPlus)
μθ	32, (tanh)	64, (tanh)	D, (sigmoid)
The number corresponds to the size of the layer, and in the parenthesis the activation function.
For the encoder, the mean and the variance functions share the weights of the Layer 1. The input
space dimension D = 784. After the training, the geodesics can be computed by solving Eq. 7
numerically. The LAND mixture model is fitted as explained in (Arvanitidis et al., 2016).
Details for Experiments 5.4. In this experiment we used Convolutional Variational Auto-
Encoders. The pixel values of the images are scaled to the interval [0, 1]. For the βψ we used
the proposed RBF model with 64 centers and the parameter a of Eq. 11 is set to 2.
Considering the variance network during the decoding stage, the RBF generates an image, which
represents intuitively the total variance of each pixel for the decoded final image, but in an initial
sub-sampled version. Afterwards, this image is passed through a sequence of deconvolution layers,
and at the end will represent the variance of every pixel for each RGB channel. However, itis critical
that the weights of the filters must be clipped during the training to R+ to ensure positive variance.
Encoder Layer 1 (Conv) Layer 2 (Conv) Layer 3(MLP) Layer 4 (MLP)
μφ	32, 3, 2, (tanh)	32, 3, 2, (tanh)	1024, (tanh)	d, (linear)
σφ	32, 3, 2, (tanh)	32, 3, 2, (tanh)	1024, (tanh)	d, (SoftPIus)
For the convolutional and deconvolutional layers, the first number is the number of applied filters,
the second is the kernel size, and third is the stride. Also, for the encoder, the mean and the variance
functions share the convolutional layers. We used L2 regularization with parameter equal to 1e-5.
Decoder L.1 (MLP) L. 2 (MLP) L.3 (DE) L.4 (DE) L. 5 (DE) L.6 (CO)
μθ	1024, (t)	D/4, (t)	32, 3, 2, (t)	32, 3, 2, (t)	3, 3,1, (t)	3, 3,1, (s)
For the decoder, the acronyms (DE) = Deconvolution, (CO) = Convolution and (t), (s) stand for
tanh and sigmoid, respectively. Also, D = width × height × channels of the images, in our
case 64,64,3. For all the convolutions and deconvolutions, the padding is set to same. We used L2
regularization with parameter equal to 1e-5 .
Decoder Layer 1 (RBF) Layer 2 (Deconv) Layer 3 (Conv)
βψ	W ∈ R(D/2>64	1, 3, 2 (linear)	3, 3, 1 (linear)
The Brownian motion over the Riemannian manifold in the latent space is presented in Alg. 2.
14
Published as a conference paper at ICLR 2018
Algorithm 2 Brownian motion on a Riemannian manifold
Input: the starting point Z ∈ Rd× 1, stepsize s, number of steps Ns, the metric tensor M(∙).
Output: the random steps Z ∈ RNs×d.
1:	for n = 0 to Ns do
2:	L, U = eig (M(z)),	(L: eigenvalues, U: eigenvectors)
3:	V = UL- 1 J	e ~N(0, Id)
4:	z = z + S ∙ v
5:	Z(n, :) = z
6:	end for
15