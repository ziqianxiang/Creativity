Published as a conference paper at ICLR 2018
Scalable Private Learning with PATE
Nicolas Papernot*
Pennsylvania State University
ngp5056@cse.psu.edu
Shuang Song*
University of California San Diego
shs037@eng.ucsd.edu
Ilya Mironov, Ananth Raghunathan, Kunal TalWar & Ulfar Erlingsson
Google Brain
{mironov,pseudorandom,kunal,ulfar}@google.com
Ab stract
The rapid adoption of machine learning has increased concerns about the privacy
implications of machine learning models trained on sensitive data, such as medical
records or other personal information. To address those concerns, one promising
approach is Private Aggregation of Teacher Ensembles, or PATE, which transfers
to a “student” model the knowledge of an ensemble of “teacher” models, with
intuitive privacy provided by training teachers on disjoint data and strong privacy
guaranteed by noisy aggregation of teachers’ answers. However, PATE has so far
been evaluated only on simple classification tasks like MNIST, leaving unclear its
utility when applied to larger-scale learning tasks and real-world datasets.
In this work, we show how PATE can scale to learning tasks with large numbers
of output classes and uncurated, imbalanced training data with errors. For this, we
introduce new noisy aggregation mechanisms for teacher ensembles that are more
selective and add less noise, and prove their tighter differential-privacy guarantees.
Our new mechanisms build on two insights: the chance of teacher consensus is
increased by using more concentrated noise and, lacking consensus, no answer
need be given to a student. The consensus answers used are more likely to be
correct, offer better intuitive privacy, and incur lower-differential privacy cost. Our
evaluation shows our mechanisms improve on the original PATE on all measures,
and scale to larger tasks with both high utility and very strong privacy (ε < 1.0).
1 Introduction
Many attractive applications of modern machine-learning techniques involve training models using
highly sensitive data. For example, models trained on people’s personal messages or detailed med-
ical information can offer invaluable insights into real-world language usage or the diagnoses and
treatment of human diseases (McMahan et al., 2017; Liu et al., 2017). A key challenge in such
applications is to prevent models from revealing inappropriate details of the sensitive data—a non-
trivial task, since models are known to implicitly memorize such details during training and also to
inadvertently reveal them during inference (Zhang et al., 2017; Shokri et al., 2017).
Recently, two promising, new model-training approaches have offered the hope that practical, high-
utility machine learning may be compatible with strong privacy-protection guarantees for sensitive
training data (Abadi et al., 2017). This paper revisits one of these approaches, Private Aggrega-
tion of Teacher Ensembles, or PATE (Papernot et al., 2017), and develops techniques that improve
its scalability and practical applicability. PATE has the advantage of being able to learn from the
aggregated consensus of separate “teacher” models trained on disjoint data, in a manner that both
provides intuitive privacy guarantees and is agnostic to the underlying machine-learning techniques
(cf. the approach of differentially-private stochastic gradient descent (Abadi et al., 2016)). In the
PATE approach multiple teachers are trained on disjoint sensitive data (e.g., different users’ data),
and uses the teachers’ aggregate consensus answers in a black-box fashion to supervise the training
of a “student” model. By publishing only the student model (keeping the teachers private) and by
adding carefully-calibrated Laplacian noise to the aggregate answers used to train the student, the
* Equal contributions, authors ordered alphabetically. Work done while the authors were at Google Brain.
1
Published as a conference paper at ICLR 2018
(％) Aue.lnuue⅛2 -UBPmS
0	1000 2000 3000 4000 5000 6000
Number of queries answered
Blsu< 4© 3⅛0u Aue>.ld
Percentage of teachers that agree
Figure 1: Our contributions are techniques (Confident-GNMax) that improve on the original PATE
(LNMax) on all measures. Left: Accuracy is higher throughout training, despite greatly improved
privacy (more in Table 1). Middle: The ε differential-privacy bound on privacy cost is quartered,
at least (more in Figure 5). Right: Intuitive privacy is also improved, since students are trained on
answers with a much stronger consensus among the teachers (more in Figure 5). These are results
for a character-recognition task, using the most favorable LNMax parameters for a fair comparison.
original PATE work showed how to establish rigorous (ε, δ) differential-privacy guarantees (Paper-
not et al., 2017)—a gold standard of privacy (Dwork et al., 2006). However, to date, PATE has been
applied to only simple tasks, like MNIST, without any realistic, larger-scale evaluation.
The techniques presented in this paper allow PATE to be applied on a larger scale to build more
accurate models, in a manner that improves both on PATE’s intuitive privacy-protection due to the
teachers’ independent consensus as well as its differential-privacy guarantees. As shown in our ex-
periments, the result is a gain in privacy, utility, and practicality—an uncommon joint improvement.
The primary technical contributions of this paper are new mechanisms for aggregating teachers’ an-
swers that are more selective and add less noise. On all measures, our techniques improve on the
original PATE mechanism when evaluated on the same tasks using the same datasets, as described
in Section 5. Furthermore, we evaluate both variants of PATE on a new, large-scale character recog-
nition task with 150 output classes, inspired by MNIST. The results show that PATE can be success-
fully utilized even to uncurated datasets—with significant class imbalance as well as erroneous class
labels—and that our new aggregation mechanisms improve both privacy and model accuracy.
To be more selective, our new mechanisms leverage some pleasant synergies between privacy and
utility in PATE aggregation. For example, when teachers disagree, and there is no real consensus,
the privacy cost is much higher; however, since such disagreement also suggest that the teachers
may not give a correct answer, the answer may simply be omitted. Similarly, teachers may avoid
giving an answer where the student already is confidently predicting the right answer. Additionally,
we ensure that these selection steps are themselves done in a private manner.
To add less noise, our new PATE aggregation mechanisms sample Gaussian noise, since the tails
of that distribution diminish far more rapidly than those of the Laplacian noise used in the original
PATE work. This reduction greatly increases the chance that the noisy aggregation of teachers’
votes results in the correct consensus answer, which is especially important when PATE is scaled to
learning tasks with large numbers of output classes. However, changing the sampled noise requires
redoing the entire PATE privacy analysis from scratch (see Section 4 and details in Appendix A).
Finally, of independent interest are the details of our evaluation extending that of the original PATE
work. In particular, we find that the virtual adversarial training (VAT) technique of Miyato et al.
(2017) is a good basis for semi-supervised learning on tasks with many classes, outperforming the
improved GANs by Salimans et al. (2016) used in the original PATE work. Furthermore, we explain
how to tune the PATE approach to achieve very strong privacy (ε ≈ 1.0) along with high utility, for
our real-world character recognition learning task.
This paper is structured as follows: Section 2 is the related work section; Section 3 gives a back-
ground on PATE and an overview of our work; Section 4 describes our improved aggregation mech-
anisms; Section 5 details our experimental evaluation; Section 6 offers conclusions; and proofs are
deferred to the Appendices.
2
Published as a conference paper at ICLR 2018
2	Related Work
Differential privacy is by now the gold standard of privacy. It offers a rigorous framework whose
threat model makes few assumptions about the adversary’s capabilities, allowing differentially pri-
vate algorithms to effectively cope against strong adversaries. This is not the case of all privacy
definitions, as demonstrated by successful attacks against anonymization techniques (Aggarwal,
2005; Narayanan & Shmatikov, 2008; Bindschaedler et al., 2017).
The first learning algorithms adapted to provide differential privacy with respect to their training
data were often linear and convex (Pathak et al., 2010; Chaudhuri et al., 2011; Song et al., 2013;
Bassily et al., 2014; Hamm et al., 2016). More recently, successful developments in deep learning
called for differentially private stochastic gradient descent algorithms (Abadi et al., 2016), some of
which have been tailored to learn in federated (McMahan et al., 2017) settings.
Differentially private selection mechanisms like GNMax (Section 4.1) are commonly used in hy-
pothesis testing, frequent itemset mining, and as building blocks of more complicated private mech-
anisms. The most commonly used differentially private selection mechanisms are exponential mech-
anism (McSherry & Talwar, 2007) and LNMax (Bhaskar et al., 2010). Recent works offer lower
bounds on sample complexity of such problem (Steinke & Ullman, 2017; Bafna & Ullman, 2017).
The Confident and Interactive Aggregator proposed in our work (Section 4.2 and Section 4.3 resp.)
use the intuition that selecting samples under certain constraints could result in better training than
using samples uniformly at random. In Machine Learning Theory, active learning (Cohn et al.,
1994) has been shown to allow learning from fewer labeled examples than the passive case (see e.g.
Hanneke (2014)). Similarly, in model stealing (Tramer et al., 2016), a goal is to learn a model from
limited access to a teacher network. There is previous work in differential privacy literature (Hardt &
Rothblum, 2010; Roth & Roughgarden, 2010) where the mechanism first decides whether or not to
answer a query, and then privately answers the queries it chooses to answer using a traditional noise-
addition mechanism. In these cases, the sparse vector technique (Dwork & Roth, 2014, Chapter 3.6)
helps bound the privacy cost in terms of the number of answered queries. This is in contrast to our
work where a constant fraction of queries get answered and the sparse vector technique does not
seem to help reduce the privacy cost. Closer to our work, Bun et al. (2017) consider a setting where
the answer to a query of interest is often either very large or very small. They show that a sparse
vector-like analysis applies in this case, where one pays only for queries that are in the middle.
3	Background and Overview
We introduce essential components of our approach towards a generic and flexible framework for
machine learning with provable privacy guarantees for training data.
3.1	The PATE Framework
Here, we provide an overview of the PATE framework. To protect the privacy of training data during
learning, PATE transfers knowledge from an ensemble of teacher models trained on partitions of the
data to a student model. Privacy guarantees may be understood intuitively and expressed rigorously
in terms of differential privacy.
Illustrated in Figure 2, the PATE framework consists of three key parts: (1) an ensemble ofn teacher
models, (2) an aggregation mechanism and (3) a student model.
Teacher models: Each teacher is a model trained independently on a subset of the data whose
privacy one wishes to protect. The data is partitioned to ensure no pair of teachers will have trained
on overlapping data. Any learning technique suitable for the data can be used for any teacher.
Training each teacher on a partition of the sensitive data produces n different models solving the
same task. At inference, teachers independently predict labels.
Aggregation mechanism: When there is a strong consensus among teachers, the label they almost
all agree on does not depend on the model learned by any given teacher. Hence, this collective
decision is intuitively private with respect to any given training point—because such a point could
have been included only in one of the teachers’ training set. To provide rigorous guarantees of dif-
ferential privacy, the aggregation mechanism of the original PATE framework counts votes assigned
3
Published as a conference paper at ICLR 2018
Figure 2: Overview of the approach: (1) an ensemble of teachers is trained on disjoint subsets of the
sensitive data, (2) a student model is trained on public data labeled using the ensemble.
to each class, adds carefully calibrated Laplacian noise to the resulting vote histogram, and outputs
the class with the most noisy votes as the ensemble’s prediction. This mechanism is referred to as
the max-of-Laplacian mechanism, or LNMax, going forward.
For samples x and classes 1, . . . , m, let fj (x) ∈ [m] denote the j-th teacher model’s prediction and
ni denote the vote count for the i-th class (i.e., ni , |fj(x) = i|). The output of the mechanism is
A(X)，argmaxi (ni(x) + LaP (1∕γ)). Through a rigorous analysis of this mechanism, the PATE
framework provides a differentially private API: the privacy cost of each aggregated prediction made
by the teacher ensemble is known.
Student model: PATE’s final steP involves the training of a student model by knowledge transfer
from the teacher ensemble using access to Public—but unlabeled—data. To limit the Privacy cost
of labeling them, queries are only made to the aggregation mechanism for a subset of Public data to
train the student in a semi-suPervised way using a fixed number of queries. The authors note that
every additional ensemble Prediction increases the Privacy cost sPent and thus cannot work with
unbounded queries. Fixed queries fixes Privacy costs as well as diminishes the value of attacks
analyzing model Parameters to recover training data (Zhang et al., 2017). The student only sees
Public data and Privacy-Preserving labels.
3.2	Differential Privacy
Differential Privacy (Dwork et al., 2006) requires that the sensitivity of the distribution of an algo-
rithm’s outPut to small Perturbations of its inPut be limited. The following variant of the definition
caPtures this intuition formally:
Definition 1. A randomized mechanism M with domain D and range R satisfies (ε, δ)-differential
privacy if for any two adjacent inputs D, D0 ∈ D and for any subset of outputs S ⊆ R it holds that:
Pr[M(D) ∈ S] ≤ eε ∙ Pr[M(D0) ∈ S]+ δ.	(1)
For our aPPlication of differential Privacy to ML, adjacent inPuts are defined as two datasets that
only differ by one training examPle and the randomized mechanism M would be the model training
algorithm. The Privacy Parameters have the following natural interPretation: ε is an uPPer bound on
the loss of Privacy, and δ is the Probability with which this guarantee may not hold. ComPosition
theorems (Dwork & Roth, 2014) allow us to keeP track of the Privacy cost when we run a sequence
of mechanisms.
3.3	RENYI DIFFERENTIAL PRIVACY
PaPernot et al. (2017) note that the natural aPProach to bounding PATE’s Privacy loss—by bounding
the Privacy cost of each label queried and using strong comPosition (Dwork et al., 2010) to derive
the total cost—yields loose Privacy guarantees. Instead, their aPProach uses data-dependent Privacy
analysis. This takes advantage of the fact that when the consensus among the teachers is very strong,
the Plurality outcome has overwhelming likelihood leading to a very small Privacy cost whenever the
consensus occurs. To caPture this effect quantitatively, PaPernot et al. (2017) rely on the moments
4
Published as a conference paper at ICLR 2018
accountant, introduced by Abadi et al. (2016) and building on previous work (Bun & Steinke, 2016;
Dwork & Rothblum, 2016).
In this section, We recall the language of Renyi Differential Privacy or RDP (Mironov, 2017). RDP
generalizes pure differential privacy (δ = 0) and is closely related to the moments accountant. We
choose to use RDP as a more natural analysis frameWork When dealing With our mechanisms that use
Gaussian noise. Defined beloW, the RDP of a mechanism is stated in terms of the Renyi divergence.
Definition 2 (Renyi Divergence). The Renyi divergence of order λ between two distributions P
and Q is defined as:
Dλ(PkQ) , λ7-ylogEx〜Q [(P(x)∕Q(x))λ] = λ-llogEx〜P h(P(x)∕Q(x))λ-1i .
Definition 3 (Renyi Differential Privacy (RDP)). A randomized mechanism M is said to guarantee
(λ, ε)-RDP with λ ≥ 1 iffor any neighboring datasets D and D0,
Dλ(M(D)kM(DO))=∑⅛ogEx』。)"(PrM(D))=4厂 ≤ε
RDP generalizes pure differential privacy in the sense that ε-differential privacy is equivalent to
(∞, ε)-RDP. Mironov (2017) proves the folloWing key facts that alloW easy composition of RDP
guarantees and their conversion to (ε, δ)-differential privacy bounds.
Theorem 4 (Composition). If a mechanism M consists of a sequence of adaptive mechanisms
M1, . . . , Mk such that for any i ∈ [k], Mi guarantees (λ, εi)-RDP, then M guarantees
(λ,Pik=1εi)-RDP.
Theorem 5 (From RDP to DP). If a mechanism M guarantees (λ, ε)-RDP, then M guarantees
(ε + log-/-, δ)-differentialPrivacyforany δ ∈ (0,1).
While both (ε, δ)-differential privacy and RDP are relaxations of pure ε-differential privacy, the tWo
main advantages of RDP are as folloWs. First, it composes nicely; second, it captures the privacy
guarantee of Gaussian noise in a much cleaner manner compared to (ε, δ)-differential privacy. This
lets us do a careful privacy analysis of the GNMax mechanism as stated in Theorem 6. While the
analysis of Papernot et al. (2017) leverages the first aspect of such frameWorks With the Laplace
noise (LNMax mechanism), our analysis of the GNMax mechanism relies on both.
3.4	PATE Aggregation Mechanisms
The aggregation step is a crucial component of PATE. It enables knoWledge transfer from the teach-
ers to the student While enforcing privacy. We improve the LNMax mechanism used by Papernot
et al. (2017) Which adds Laplace noise to teacher votes and outputs the class With the highest votes.
First, We add Gaussian noise With an accompanying privacy analysis in the RDP frameWork. This
modification effectively reduces the noise needed to achieve the same privacy cost per student query.
Second, the aggregation mechanism is noW selective: teacher votes are analyzed to decide Which
student queries are worth ansWering. This takes into account both the privacy cost of each query and
its payout in improving the student’s utility. Surprisingly, our analysis shoWs that these tWo metrics
are not at odds and in fact align With each other: the privacy cost is the smallest When teachers agree,
and When teachers agree, the label is more likely to be correct thus being more useful to the student.
Third, We propose and study an interactive mechanism that takes into account not only teacher votes
on a queried example but possible student predictions on that query. NoW, queries Worth ansWering
are those Where the teachers agree on a class but the student is not confident in its prediction on that
class. This third modification aligns the tWo metrics discussed above even further: queries Where the
student already agrees With the consensus of teachers are not Worth expending our privacy budget
on, but queries Where the student is less confident are useful and ansWered at a small privacy cost.
5
Published as a conference paper at ICLR 2018
3.5	Data-dependent Privacy in PATE
A direct privacy analysis of the aggregation mechanism, for reasonable values of the noise param-
eter, allows answering only few queries before the privacy cost becomes prohibitive. The original
PATE proposal used a data-dependent analysis, exploiting the fact that when the teachers have large
agreement, the privacy cost is usually much smaller than the data-independent bound would suggest.
In our work, we perform a data-dependent privacy analysis of the aggregation mechanism with
Gaussian noise. This change of noise distribution turns out be technically much more challenging
than the Laplace noise case and we defer the details to Appendix A. This increased complexity
of the analysis however does not make the algorithm any more complicated and thus allows us to
improve the privacy-utility tradeoff.
Sanitizing the privacy cost via smooth sensitivity analysis. An additional challenge with data-
dependent privacy analyses arises from the fact that the privacy cost itself is now a function of the
private data. Further, the data-dependent bound on the privacy cost has large global sensitivity (a
metric used in differential privacy to calibrate the noise injected) and is therefore difficult to sanitize.
To remedy this, we use the smooth sensitivity framework proposed by Nissim et al. (2007).
Appendix B describes how we add noise to the computed privacy cost using this framework to
publish a sanitized version of the privacy cost. Section B.1 defines smooth sensitivity and outlines
algorithms 3-5 that compute it. The rest of Appendix B argues the correctness of these algorithms.
The final analysis shows that the incremental cost of sanitizing our privacy estimates is modest—
less than 50% of the raw estimates—thus enabling us to use precise data-dependent privacy analysis
while taking into account its privacy implications.
4	Improved Aggregation Mechanisms for PATE
The privacy guarantees provided by PATE stem from the design and analysis of the aggregation
step. Here, we detail our improvements to the mechanism used by Papernot et al. (2017). As
outlined in Section 3.4, we first replace the Laplace noise added to teacher votes with Gaussian
noise, adapting the data-dependent privacy analysis. Next, we describe the Confident and Interactive
Aggregators that select queries worth answering in a privacy-preserving way: the privacy budget is
shared between the query selection and answer computation. The aggregators use different heuristics
to select queries: the former does not take into account student predictions, while the latter does.
4.1	The GNMax Aggregator and Its Privacy Guarantee
This section uses the following notation. For a sample x and classes 1 to m, let fj (x) ∈ [m] denote
the j-th teacher model’s prediction on x and ni (x) denote the vote count for the i-th class (i.e.,
ni(x) = |{j: fj (x) = i}|). We define a Gaussian NoisyMax (GNMax) aggregation mechanism as:
Mσ(x)，argmax {ni(x) + N(0,σ2)},
i
where N(0, σ2) is the Gaussian distribution with mean 0 and variance σ2. The aggregator outputs
the class with noisy plurality after adding Gaussian noise to each vote count. In what follow, plurality
more generally refers to the highest number of teacher votes assigned among the classes.
The Gaussian distribution is more concentrated than the Laplace distribution used by Papernot et al.
(2017). This concentration directly improves the aggregation’s utility when the number of classes m
is large. The GNMax mechanism satisfies (λ, λ∕σ2)-RDP, which holds for all inputs and all λ ≥ 1
(precise statements and proofs of claims in this section are deferred to Appendix A). A straight-
forward application of composition theorems leads to loose privacy bounds. As an example, the
standard advanced composition theorem applied to experiments in the last two rows of Table 1
would give us ε = 8.42 and ε = 10.14 resp. at δ = 10-8 for the Glyph dataset.
To refine these, we work out a careful data-dependent analysis that yields values ofε smaller than 1
for the same δ. The following theorem translates data-independent RDP guarantees for higher orders
into a data-dependent RDP guarantee for a smaller order λ. We use it in conjunction with Propo-
sition 7 to bound the privacy cost of each query to the GNMax algorithm as a function of q, the
probability that the most common answer will not be output by the mechanism.
6
Published as a conference paper at ICLR 2018
Theorem 6 (informal). Let M be a randomized algorithm with (μι,ει)-RDP and (μ2,ε2)-
RDP guarantees and suppose that given a dataset D, there exists a likely outcome i* such
that Pr [M(D) = i*] ≤ q. Then the data-dependent Renyi differential privacy for M of order
λ ≤ μι, μ2 at D is bounded by afunction of q, μι, ει, μ2, ε2, which approaches 0 as q → 0.
The new bound improves on the data-independent privacy for λ as long as the distribution of the
algorithm’s output on that input has a strong peak (i.e., qq 1). Values of qq close to 1 could result
in a looser bound. Therefore, in practice We take the minimum between this bound and λ∕σ2 (the
data-independent one). The theorem generalizes Theorem 3 from Papernot et al. (2017), where it
was shown for a mechanism satisfying ε-differential privacy (i.e., μ1 = μ2 = ∞ and ε1 = ε2).
The final step in our analysis uses the following lemma to bound the probability qq when i* corre-
sponds to the class with the true plurality of teacher votes.
Proposition 7. For any i* ∈ [m], we have Pr [Mσ (D) = i*] ≤ 2 Pi=i* erfc (ni2-ni) , where
erfc is the complementary error function.
In Appendix A, we detail how these results translate to privacy bounds. In short, for each query to
the GNMax aggregator, given teacher votes ni and the class i* with maximal support, Proposition 7
gives us the value of qq to use in Theorem 6. We optimize over μ1 and μ2 to get a data-dependent RDP
guarantee for any order λ. Finally, we use composition properties of RDP to analyze a sequence of
queries, and translate the RDP bound back to an (ε, δ)-DP bound.
Expensive queries. This data-dependent privacy analysis leads us to the concept of an expensive
query in terms of its privacy cost. When teacher votes largely disagree, some ni* - ni values may
be small leading to a large value for qq: i.e., the lack of consensus amongst teachers indicates that
the aggregator is likely to output a wrong label. Thus expensive queries from a privacy perspec-
tive are often bad for training too. Conversely, queries with strong consensus enable tight privacy
bounds. This synergy motivates the aggregation mechanisms discussed in the following sections:
they evaluate the strength of the consensus before answering a query.
4.2	The Confident-GNMax Aggregator
In this section, we propose a refinement of the GNMax aggregator that enables us to filter out queries
for which teachers do not have a sufficiently strong consensus. This filtering enables the teachers
to avoid answering expensive queries. We also take note to do this selection step itself in a private
manner.
The proposed Confident Aggregator is described in Algorithm 1. To select queries with overwhelm-
ing consensus, the algorithm checks if the plurality vote crosses a threshold T . To enforce privacy
in this step, the comparison is done after adding Gaussian noise with variance σ12. Then, for queries
that pass this noisy threshold check, the aggregator proceeds with the usual GNMax mechanism
with a smaller variance σ22 . For queries that do not pass the noisy threshold check, the aggregator
simply returns ⊥ and the student discards this example in its training.
In practice, we often choose significantly higher values for σ1 compared to σ2 . This is because
we pay the cost of the noisy threshold check always, and without the benefit of knowing that the
consensus is strong. We pick T so that queries where the plurality gets less than half the votes (often
very expensive) are unlikely to pass the threshold after adding noise, but we still have a high enough
yield amongst the queries with a strong consensus. This tradeoff leads us to look for T ’s between
0.6× to 0.8× the number of teachers.
The privacy cost of this aggregator is intuitive: we pay for the threshold check for every query, and
for the GNMax step only for queries that pass the check. In the work of Papernot et al. (2017), the
mechanism paid a privacy cost for every query, expensive or otherwise. In comparison, the Confident
Aggregator expends a much smaller privacy cost to check against the threshold, and by answering a
significantly smaller fraction of expensive queries, it expends a lower privacy cost overall.
4.3	The Interactive-GNMax Aggregator
While the Confident Aggregator excludes expensive queries, it ignores the possibility that the student
might receive labels that contribute little to learning, and in turn to its utility. By incorporating the
7
Published as a conference paper at ICLR 2018
Algorithm 1 - Confident-GNMax Aggregator: given a query, consensus among teachers is first
estimated in a privacy-preserving way to then only reveal confident teacher predictions.
Input: input x, threshold T , noise parameters σ1 and σ2
1:	if maxi{nj(x)} + N(0, σ12) ≥ T then	. Privately check for consensus
2:	return argmaxj nj (x) + N(0, σ22)	. Run the usual max-of-Gaussian
3:	else
4:	return ⊥
5:	end if
Algorithm 2 - Interactive-GNMax Aggregator: the protocol first compares student predictions to
the teacher votes in a privacy-preserving way to then either (a) reinforce the student prediction for
the given query or (b) provide the student with a new label predicted by the teachers.
Input: input x, confidence γ, threshold T, noise parameters σ1 and σ2, total number of teachers M
1: Ask the student to provide prediction scores p(x)
2	: if maxj {nj (x) - Mpj (x)} + N (0, σ12) ≥ T then	. Student does not agree with teachers
3	:	return argmaxj {nj (x) + N(0, σ22)}	. Teachers provide new label
4	: else if max{pi (x)} > γ then	. Student agrees with teachers and is confident
5	:	return arg maxj pj (x)	. Reinforce student’s prediction
6	: else
7	:	return ⊥	. No output given for this label
8	end if
student’s current predictions for its public training data, we design an Interactive Aggregator that
discards queries where the student already confidently predicts the same label as the teachers.
Given a set of queries, the Interactive Aggregator (Algorithm 2) selects those answered by compar-
ing student predictions to teacher votes for each class. Similar to Step 1 in the Confident Aggregator,
queries where the plurality of these noised differences crosses a threshold are answered with GN-
Max. This noisy threshold suffices to enforce privacy of the first step because student predictions
can be considered public information (the student is trained in a differentially private manner).
For queries that fail this check, the mechanism reinforces the predicted student label if the student
is confident enough and does this without looking at teacher votes again. This limited form of
supervision comes at a small privacy cost. Moreover, the order of the checks ensures that a student
falsely confident in its predictions on a query is not accidentally reinforced if it disagrees with
the teacher consensus. The privacy accounting is identical to the Confident Aggregator except in
considering the difference between teachers and the student instead of only the teachers votes.
In practice, the Confident Aggregator can be used to start training a student when it can make no
meaningful predictions and training can be finished off with the Interactive Aggregator after the
student gains some proficiency.
5	Experimental Evaluation
Our goal is first to show that the improved aggregators introduced in Section 4 enable the application
of PATE to uncurated data, thus departing from previous results on tasks with balanced and well-
separated classes. We experiment with the Glyph dataset described below to address two aspects left
open by Papernot et al. (2017): (a) the performance of PATE on a task with a larger number of classes
(the framework was only evaluated on datasets with at most 10 classes) and (b) the privacy-utility
tradeoffs offered by PATE on data that is class imbalanced and partly mislabeled. In Section 5.2, we
evaluate the improvements given by the GNMax aggregator over its Laplace counterpart (LNMax)
and demonstrate the necessity of the Gaussian mechanism for uncurated tasks.
In Section 5.3, we then evaluate the performance of PATE with both the Confident and Interactive
Aggregators on all datasets used to benchmark the original PATE framework, in addition to Glyph.
With the right teacher and student training, the two mechanisms from Section 4 achieve high ac-
curacy with very tight privacy bounds. Not answering queries for which teacher consensus is too
8
Published as a conference paper at ICLR 2018
low (Confident-GNMax) or the student’s predictions already agree with teacher votes (Interactive-
GNMax) better aligns utility and privacy: queries are answered at a significantly reduced cost.
5.1	Experimental Setup
MNIST, SVHN, and the UCI Adult databases. We evaluate with two computer vision tasks
(MNIST and Street View House Numbers (Netzer et al., 2011)) and census data from the UCI Adult
dataset (Kohavi, 1996). This enables a comparative analysis of the utility-privacy tradeoff achieved
with our Confident-GNMax aggregator and the LNMax originally used in PATE. We replicate the
experimental setup and results found in Papernot et al. (2017) with code and teacher votes made
available online. The source code for the privacy analysis in this paper as well as supporting data
required to run this analysis is available on Github.1
A detailed description of the experimental setup can be found in Papernot et al. (2017); we provide
here only a brief overview. For MNIST and SVHN, teachers are convolutional networks trained on
partitions of the training set. For UCI Adult, each teacher is a random forest. The test set is split in
two halves: the first is used as unlabeled inputs to simulate the student’s public data and the second
is used as a hold out to evaluate test performance. The MNIST and SVHN students are convolutional
networks trained using semi-supervised learning with GANs a la Salimans et al. (2016). The student
for the Adult dataset are fully supervised random forests.
Glyph. This optical character recognition task has an order of magnitude more classes than all
previous applications of PATE. The Glyph dataset also possesses many characteristics shared by
real-world tasks: e.g., it is imbalanced and some inputs are mislabeled. Each input is a 28 × 28
grayscale image containing a single glyph generated synthetically from a collection of over 500K
computer fonts.2 Samples representative of the difficulties raised by the data are depicted in Figure 3.
The task is to classify inputs as one of the 150 Unicode symbols used to generate them.
This set of 150 classes results from pre-processing efforts. We discarded additional classes that
had few samples; some classes had at least 50 times fewer inputs than the most popular classes,
and these were almost exclusively incorrectly labeled inputs. We also merged classes that were too
ambiguous for even a human to differentiate them. Nevertheless, a manual inspection of samples
grouped by classes—favorably to the human observer—led to the conservative estimate that some
classes remain 5 times more frequent, and mislabeled inputs represent at least 10% of the data.
To simulate the availability of private and public data (see Section 3.1), we split data originally
marked as the training set (about 65M points) into partitions given to the teachers. Each teacher is a
ResNet (He et al., 2016) made of 32 leaky ReLU layers. We train on batches of 100 inputs for 40K
steps using SGD with momentum. The learning rate, initially set to 0.1, is decayed after 10K steps
to 0.01 and again after 20K steps to 0.001. These parameters were found with a grid search.
We split holdout data in two subsets of 100K and 400K samples: the first acts as public data to train
the student and the second as its testing data. The student architecture is a convolutional network
learnt in a semi-supervised fashion with virtual adversarial training (VAT) from Miyato et al. (2017).
Using unlabeled data, we show how VAT can regularize the student by making predictions constant
in adversarial3 directions. Indeed, we found that GANs did not yield as much utility for Glyph as
for MNIST or SVHN. We train with Adam for 400 epochs and a learning rate of 6 ∙ 10-5.
5.2	Comparing the LNMax and GNMax Mechanisms
Section 4.1 introduces the GNMax mechanism and the accompanying privacy analysis. With a
Gaussian distribution, whose tail diminishes more rapidly than the Laplace distribution, we expect
better utility when using the new mechanism (albeit with a more involved privacy analysis).
To study the tradeoff between privacy and accuracy with the two mechanisms, we run experiments
training several ensembles of M teachers for M ∈ {100, 500, 1000, 5000} on the Glyph data. Re-
1https://github.com/tensorflow/models/tree/master/research/differential_privacy
2Glyph data is not public but similar data is available publicly as part of the notMNIST dataset.
3In this context, the adversarial component refers to the phenomenon commonly referred to as adversarial
examples (Biggio et al., 2013; Szegedy et al., 2014) and not to the adversarial training approach taken in GANs.
9
Published as a conference paper at ICLR 2018
call that 65 million training inputs are partitioned and distributed among the M teachers with each
teacher receiving between 650K and 13K inputs for the values of M above. The test data is used to
query the teacher ensemble and the resulting labels (after the LNMax and GNMax mechanisms) are
compared with the ground truth labels provided in the dataset. This predictive performance of the
teachers is essential to good student training with accurate labels and is a useful proxy for utility.
For each mechanism, we compute (ε, δ)-differential privacy guarantees. As is common in literature,
for a dataset on the order of 108 samples, we choose δ = 10-8 and denote the corresponding ε as
the privacy cost. The total ε is calculated on a subset of 4,000 queries, which is representative of
the number of labels needed by a student for accurate training (see Section 5.3). We visualize in
Figure 4 the effect of the noise distribution (left) and the number of teachers (right) on the tradeoff
between privacy costs and label accuracy.
Observations. On the left of Figure 1, we compare our GNMax aggregator to the LNMax aggrega-
tor used by the original PATE proposal, on an ensemble of 1000 teachers and for varying noise scales
σ. At fixed test accuracy, the GNMax algorithm consistently outperforms the LNMax mechanism
in terms of privacy cost. To explain this improved performance, recall notation from Section 4.1.
For both mechanisms, the data dependent privacy cost scales linearly with q—the likelihood of an
answer other than the true plurality. The value of q falls of as exp(-x2) for GNMax and exp(-χ)
for LNMax, where X is the ratio (n* - ni)∕σ. Thus, when n%* — n is (say) 4σ, LNMax would have
qq ≈ e-4 = 0.018..., whereas GNMax would have qq ≈ e-16 ≈ 10-7, thereby leading to a much
higher likelihood of returning the true plurality. Moreover, this reduced qq translates to a smaller
privacy cost for a given σ leading to a better utility-privacy tradeoff.
As long as each teacher has sufficient data to learn a good-enough model, increasing the number M
of teachers improves the tradeoff—as illustrated on the right of Figure 4 with GNMax. The larger
ensembles lower the privacy cost of answering queries by tolerating larger σ's. Combining the two
observations made in this Figure, for a fixed label accuracy, we lower privacy costs by switching to
the GNMax aggregator and training a larger number M of teachers.
5.3	Student Training with the GNMax Aggregation Mechanisms
As outlined in Section 3, we train a student on public data labeled by the aggregation mechanisms.
We take advantage of PATE’s flexibility and apply the technique that performs best on each dataset:
semi-supervised learning with Generative Adversarial Networks (Salimans et al., 2016) for MNIST
and SVHN, Virtual Adversarial Training (Miyato et al., 2017) for Glyph, and fully-supervised ran-
dom forests for UCI Adult. In addition to evaluating the total privacy cost associated with training
the student model, we compare its utility to a non-private baseline obtained by training on the sensi-
tive data (used to train teachers in PATE): we use the baselines of 99.2%, 92.8%, and 85.0% reported
by Papernot et al. (2017) respectively for MNIST, SVHN, and UCI Adult, and we measure a base-
line of 82.2% for Glyph. We compute (ε, δ)-privacy bounds and denote the privacy cost as the ε
value at a value of δ set accordingly to number of training samples.
Confident-GNMax Aggregator. Given a pool of 500 to 12,000 samples to learn from (depending
on the dataset), the student submits queries to the teacher ensemble running the Confident-GNMax
aggregator from Section 4.2. A grid search over a range of plausible values for parameters T , σ1
and σ2 yielded the values reported in Table 1, illustrating the tradeoff between utility and privacy
achieved. We additionally measure the number of queries selected by the teachers to be answered
and compare student utility to a non-private baseline.
The Confident-GNMax aggregator outperforms LNMax for the four datasets considered in the origi-
nal PATE proposal: it reduces the privacy cost ε, increases student accuracy, or both simultaneously.
On the uncurated Glyph data, despite the imbalance of classes and mislabeled data (as evidenced
by the 82.2% baseline), the Confident Aggregator achieves 73.5% accuracy with a privacy cost of
just ε = 1.02. Roughly 1,300 out of 12,000 queries made are not answered, indicating that sev-
eral expensive queries were successfully avoided. This selectivity is analyzed in more details in
Section 5.4.
Interactive-GNMax Aggregator. On Glyph, we evaluate the utility and privacy of an interactive
training routine that proceeds in two rounds. Round one runs student training with a Confident
10
Published as a conference paper at ICLR 2018
Figure 3: Some example inputs from the Glyph dataset along with the class they are labeled as.
Note the ambiguity (between the comma and apostrophe) and the mislabeled input.
+	(
(兴)>u EDUUro⅛5①4 uo0roB66q
1(
σ= 20 σ= 10
，C= 150
/
, σ = 200
:餐。小。产5。
σ = 200	∖
σ
σ = 20
→- 1000 teachers (Gaussian)
-÷≡-- 1000 teachers (LapIace)
....Non-private model baseline
10
—100 teachers (Gaussian)
—500 teachers (Gaussian)
—∙— 1000 teachers (Gaussian)
—5000 teachers (Gaussian)
Non-private model baseline
10
15
，25
Privacy cost of 4000 queries (ε bound at o
Privacy cost of 4000 queries (ε at ð = IO-8)
8 6 4 2
(兴)>u EDUUro⅛5①4 uo0roB66q
Figure 4:	Tradeoff between utility and privacy for the LNMax and GNMax aggregators on
Glyph: effect of the noise distribution (left) and size of the teacher ensemble (right). The LNMax
aggregator uses a Laplace distribution and GNMax a Gaussian. Smaller values of the privacy cost ε
(often obtained by increasing the noise scale σ—see Section 4) and higher accuracy are better.
Dataset	Aggregator	Queries answered	Privacy bound ε	AccI Student	Iracy Baseline
MNIST	LNMax (PaPernOt et al., 2017)	100	2.04	98.0%	99.2%
	LNMax (PaPernOt et al., 2017)	-1,000-	8.03	98.1%	
	Confident-GNMax (T=200, σ1=150, σ2=40)	286	1.97	98.5%	
SVHN	LNMax (Papernot et al., 2017)	500	5.04	82.7%	92.8%
	LNMax (PaPernot et al., 2017)	-1,000-	8.19	90.7%	
	Confident-GNMax (T=300, σ1=200, σ2=40)	-3,098	4.96	91.6%	
Adult	LNMax (PaPernot et al., 2017)	500	2.66	83.0%	85.0%
	Confident-GNMax (T=300, σ1=200, σ2=40)	524	1.90	83.7%	
Glyph	LNMax	-4,000-	4.3	72.4%	82.2%
	Confident-GNMax (T =1000, σ1=500, σ2=100)	-10,762	2.03	75.5%	
	Interactive-GNMax, two rounds	-4,341	0.837	73.2%	
Table 1: Utility and privacy of the students. The Confident- and Interactive-GNMax aggregators
introduced in Section 4 offer better tradeoffs between privacy (characterized by the value of the
bound ε) and utility (the accuracy of the student compared to a non-private baseline) than the LNMax
aggregator used by the original PATE proposal on all datasets we evaluated with. For MNIST, Adult,
and SVHN, we use the labels of ensembles of 250 teachers published by Papernot et al. (2017) and
set δ = 10-5 to compute values ofε (to the exception of SVHN where δ = 10-6). All Glyph results
use an ensemble of 5000 teachers and ε is computed for δ = 10-8.
11
Published as a conference paper at ICLR 2018
1200
LNMaX answers
800-
600-
400-
E
200-
-10-3
Φ
笳 1000-
Confident-GNMaX
answers (moderate)
Confident-GNMax
answers (aggressive)
-100
-10
0%
20%
40%
60%
80%
10-200
100%
Percentage of teachers that agree
1.0
∞
0 0.8
Il
O
0 0.6
ω
-M
S
8 0.4
u
ra
≥ 0.2
Q_
0.0
0	1000 2000 3000 4000 5000 6000
■ " LNMaX
Confident-GNMax (moderate)
Confident-GNMax (aggressive)
Number of queries answered
Figure 5:	Effects of the noisy threshold checking: Left: The number of queries answered
by LNMax, Confident-GNMax moderate (T =3500, σ1=1500), and Confident-GNMax aggressive
(T =5000, σ1=1500). The black dots and the right axis (in log scale) show the expected cost of an-
swering a single query in each bin (via GNMax, σ2=100). Right: Privacy cost of answering all
(LNMax) vs only inexpensive queries (GNMax) for a given number of answered queries. The very
dark area under the curve is the cost of selecting queries; the rest is the cost of answering them.
Aggregator. A grid search targeting the best privacy for roughly 3,400 answered queries (out of
6,000)—sufficient to bootstrap a student—led us to setting (T =3500, σ1=1500, σ2=100) and a pri-
vacy cost of ε ≈ 0.59.
In round two, this student was then trained with 10,000 more queries made with the Interactive-
GNMax Aggregator (T =3500, σ1=2000, σ2=200). We computed the resulting (total) privacy cost
and utility at an exemplar data point through another grid search of plausible parameter values.
The result appears in the last row of Table 1. With just over 10,422 answered queries in total at a
privacy cost of ε = 0.84, the trained student was able to achieve 73.2% accuracy. Note that this
students required fewer answered queries compared to the Confident Aggregator. The best overall
cost of student training occurred when the privacy costs for the first and second rounds of training
were roughly the same. (The total ε is less than 0.59 × 2 = 1.18 due to better composition—via
Theorems 4 and 5.)
Comparison with Baseline. Note that the Glyph student’s accuracy remains seven percentage
points below the non-private model’s accuracy achieved by training on the 65M sensitive inputs.
We hypothesize that this is due to the uncurated nature of the data considered. Indeed, the class
imbalance naturally requires more queries to return labels from the less represented classes. For
instance, a model trained on 200K queries is only 77% accurate on test data. In addition, the large
fraction of mislabeled inputs are likely to have a large privacy cost: these inputs are sensitive because
they are outliers of the distribution, which is reflected by the weak consensus among teachers on
these inputs.
5.4 Noisy Threshold Checks and Privacy Costs
Sections 4.1 and 4.2 motivated the need for a noisy threshold checking step before having the teach-
ers answer queries: it prevents most of the privacy budget being consumed by few queries that are
expensive and also likely to be incorrectly answered. In Figure 5, we compare the privacy cost ε of
answering all queries to only answering confident queries for a fixed number of queries.
We run additional experiments to support the evaluation from Section 5.3. With the votes of 5,000
teachers on the Glyph dataset, We plot in Figure 5 the histogram of the plurality vote counts (%*
in the notation of Section 4.1) across 25,000 student queries. We compare these values to the vote
counts of queries that passed the noisy threshold check for tWo sets of parameters T and σ1 in
Algorithm 1. Smaller values imply Weaker teacher agreements and consequently more expensive
queries.
12
Published as a conference paper at ICLR 2018
When (T =3500, σ1=1500) we capture a significant fraction of queries where teachers have a strong
consensus (roughly > 4000 votes) while managing to filter out many queries with poor consensus.
This moderate check ensures that although many queries with plurality votes between 2,500 and
3,500 are answered (i.e., only 50-70% of teachers agree on a label) the expensive ones are most
likely discarded. For (T =5000, σ1=1500), queries with poor consensus are completely culled out.
This selectivity comes at the expense of a noticeable drop for queries that might have had a strong
consensus and little-to-no privacy cost. Thus, this aggressive check answer fewer queries with very
strong privacy guarantees. We reiterate that this threshold checking step itself is done in a private
manner. Empirically, in our Interactive Aggregator experiments, we expend about a third to a half of
our privacy budget on this step, which still yields a very small cost per query across 6,000 queries.
6 Conclusions
The key insight motivating the addition of a noisy thresholding step to the two aggregation mecha-
nisms proposed in our work is that there is a form of synergy between the privacy and accuracy of
labels output by the aggregation: labels that come at a small privacy cost also happen to be more
likely to be correct. As a consequence, we are able to provide more quality supervision to the student
by choosing not to output labels when the consensus among teachers is too low to provide an aggre-
gated prediction at a small cost in privacy. This observation was further confirmed in some of our
experiments where we observed that if we trained the student on either private or non-private labels,
the former almost always gave better performance than the latter—for a fixed number of labels.
Complementary with these aggregation mechanisms is the use of a Gaussian (rather than Laplace)
distribution to perturb teacher votes. In our experiments with Glyph data, these changes proved
essential to preserve the accuracy of the aggregated labels—because of the large number of classes.
The analysis presented in Section 4 details the delicate but necessary adaptation of analogous results
for the Laplace NoisyMax.
As was the case for the original PATE proposal, semi-supervised learning was instrumental to ensure
the student achieves strong utility given a limited set of labels from the aggregation mechanism.
However, we found that virtual adversarial training outperforms the approach from Salimans et al.
(2016) in our experiments with Glyph data. These results establish lower bounds on the performance
that a student can achieve when supervised with our aggregation mechanisms; future work may
continue to investigate virtual adversarial training, semi-supervised generative adversarial networks
and other techniques for learning the student in these particular settings with restricted supervision.
Acknowledgments
We are grateful to MarHn Abadi, Vincent Vanhoucke, and Daniel Levy for their useful inputs and
discussions towards this paper.
13
Published as a conference paper at ICLR 2018
References
Mardn Abadi, Andy Chu, Ian Goodfellow, H Brendan McMahan, Ilya Mironov, Kunal Talwar, and
Li Zhang. Deep learning with differential privacy. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, pp. 308-318. ACM, 2016.
Mardn Abadi, Ulfar Erlingsson, Ian Goodfellow, H. Brendan McMahan, Nicolas Papernot, Ilya
Mironov, Kunal Talwar, and Li Zhang. On the protection of private information in machine
learning systems: Two recent approaches. In 2017 IEEE 30th Computer Security Foundations
Symposium (CSF), pp. 1-6, 2017.
Charu C Aggarwal. On k-anonymity and the curse of dimensionality. In Proceedings of the 31st
International Conference on Very large Data Bases, pp. 901-909. VLDB Endowment, 2005.
Mitali Bafna and Jonathan Ullman. The price of selection in differential privacy. In Proceedings of
the 2017 Conference on Learning Theory (COLT), volume 65 of Proceedings of Machine Learn-
ing Research, pp. 151-168, July 2017.
Raef Bassily, Adam Smith, and Abhradeep Thakurta. Private empirical risk minimization: Efficient
algorithms and tight error bounds. In Proceedings of the 2014 IEEE 55th Annual Symposium on
Foundations of Computer Science (FOCS), pp. 464-473, 2014. ISBN 978-1-4799-6517-5.
Raghav Bhaskar, Srivatsan Laxman, Adam Smith, and Abhradeep Thakurta. Discovering frequent
patterns in sensitive data. In Proceedings of the 16th ACM SIGKDD international conference on
Knowledge discovery and data mining, pp. 503-512. ACM, 2010.
Battista Biggio, Igino Corona, Davide Maiorca, Blaine Nelson, Nedim Srndic, Pavel Laskov, Gior-
gio Giacinto, and Fabio Roli. Evasion attacks against machine learning at test time. In Joint
European Conference on Machine Learning and Knowledge Discovery in Databases, pp. 387-
402, 2013.
Vincent Bindschaedler, Reza Shokri, and Carl A Gunter. Plausible deniability for privacy-preserving
data synthesis. Proceedings of the VLDB Endowment, 10(5), 2017.
Mark Bun and Thomas Steinke. Concentrated differential privacy: Simplifications, extensions, and
lower bounds. In Theory of Cryptography Conference (TCC), pp. 635-658, 2016.
Mark Bun, Thomas Steinke, and Jonathan Ullman. Make up your mind: The price of online queries
in differential privacy. In Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on
Discrete Algorithms, pp. 1306-1325. SIAM, 2017.
Kamalika Chaudhuri, Claire Monteleoni, and Anand D Sarwate. Differentially private empirical
risk minimization. Journal of Machine Learning Research, 12(Mar):1069-1109, 2011.
David Cohn, Les Atlas, and Richard Ladner. Improving generalization with active learning. Machine
learning, 15(2):201-221, 1994.
Cynthia Dwork and Aaron Roth. The algorithmic foundations of differential privacy. Foundations
and Trends in Theoretical Computer Science, 9(3-4):211-407, 2014.
Cynthia Dwork and Guy N Rothblum. Concentrated differential privacy. arXiv preprint
arXiv:1603.01887, 2016.
Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in
private data analysis. In Proceedings of the Third Conference on Theory of Cryptography (TCC),
volume 3876, pp. 265-284, 2006.
Cynthia Dwork, Guy N Rothblum, and Salil Vadhan. Boosting and differential privacy. In Pro-
ceedings of the 51st Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp.
51-60, 2010.
Jihun Hamm, Yingjun Cao, and Mikhail Belkin. Learning privately from multiparty data. In Inter-
national Conference on Machine Learning (ICML), pp. 555-563, 2016.
14
Published as a conference paper at ICLR 2018
Steve Hanneke. Theory of disagreement-based active learning. Foundations and Trends in Machine
Learning, 7(2-3):131-309, 2014.
Moritz Hardt and Guy N Rothblum. A multiplicative weights mechanism for privacy-preserving
data analysis. In 51st Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp.
61-70, 2010.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pp.
770-778, 2016.
Ron Kohavi. Scaling up the accuracy of Naive-Bayes classifiers: A decision-tree hybrid. In KDD,
volume 96, pp. 202-207, 1996.
Yun Liu, Krishna Gadepalli, Mohammad Norouzi, George E Dahl, Timo Kohlberger, Aleksey
Boyko, Subhashini Venugopalan, Aleksei Timofeev, Philip Q Nelson, Greg S Corrado, et al.
Detecting cancer metastases on gigapixel pathology images. arXiv preprint arXiv:1703.02442,
2017.
H Brendan McMahan, Daniel Ramage, Kunal Talwar, and Li Zhang. Learning differentially private
language models without losing accuracy. arXiv preprint arXiv:1710.06963, 2017.
Frank McSherry and Kunal Talwar. Mechanism design via differential privacy. In Proceedings of the
48th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp. 94-103, 2007.
Ilya Mironov. Renyi differential privacy. In 2017 IEEE 30th Computer Security Foundations Sym-
posium (CSF), pp. 263-275, 2017.
Takeru Miyato, Shin-ichi Maeda, Masanori Koyama, and Shin Ishii. Virtual adversarial train-
ing: a regularization method for supervised and semi-supervised learning. arXiv preprint
arXiv:1704.03976, 2017.
Arvind Narayanan and Vitaly Shmatikov. Robust de-anonymization of large sparse datasets. In
Proceedings of the 2008 IEEE Symposium on Security and Privacy, pp. 111-125. IEEE, 2008.
Yuval Netzer, Tao Wang, Adam Coates, Alessandro Bissacco, Bo Wu, and Andrew Y Ng. Reading
digits in natural images with unsupervised feature learning. In NIPS Workshop on Deep Learning
and Unsupervised Feature Learning, pp. 5, 2011.
Kobbi Nissim, Sofya Raskhodnikova, and Adam Smith. Smooth sensitivity and sampling in pri-
vate data analysis. In Proceedings of the Thirty-ninth Annual ACM Symposium on Theory of
Computing (STOC), pp. 75-84, 2007.
Nicolas Papernot, Mardn Abadi, Ulfar Erlingsson, Ian Goodfellow, and Kunal Talwar. Semi-
supervised knowledge transfer for deep learning from private training data. In Proceedings of
the 5th International Conference on Learning Representations (ICLR), 2017.
Manas Pathak, Shantanu Rane, and Bhiksha Raj. Multiparty differential privacy via aggregation of
locally trained classifiers. In Advances in Neural Information Processing Systems, pp. 1876-1884,
2010.
Aaron Roth and Tim Roughgarden. Interactive privacy via the median mechanism. In Proceedings
of the Forty-second ACM Symposium on Theory of Computing (STOC), pp. 765-774, 2010.
Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen.
Improved techniques for training GANs. In Advances in Neural Information Processing Systems,
pp. 2234-2242, 2016.
Reza Shokri, Marco Stronati, Congzheng Song, and Vitaly Shmatikov. Membership inference at-
tacks against machine learning models. In Proceedings of the 2017 IEEE Symposium on Security
and Privacy, pp. 3-18. IEEE, 2017.
Shuang Song, Kamalika Chaudhuri, and Anand D Sarwate. Stochastic gradient descent with differ-
entially private updates. In 2013 IEEE Global Conference on Signal and Information Processing,
pp. 245-248, 2013.
15
Published as a conference paper at ICLR 2018
Thomas Steinke and Jonathan Ullman. Tight lower bounds for differentially private selection. In
58th IEEEAnnual Symposium on Foundations ofComputer Science (FOCS), pp. 552-563, 2017.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. In Proceedings of the 2nd International
Conference on Learning Representations (ICLR), 2014.
Florian Tramer, Fan Zhang, Ari Juels, Michael K Reiter, and Thomas Ristenpart. Stealing machine
learning models via prediction APIs. In USENIX Security Symposium, pp. 601-618, 2016.
Tim van Erven and Peter Harremoes. Renyi divergence and Kullback-Leibler divergence. IEEE
Transactions on Information Theory, 60(7):3797-3820, July 2014.
Chiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals. Understanding
deep learning requires rethinking generalization. In Proceedings of the 5th International Confer-
ence on Learning Representations (ICLR), 2017.
16
Published as a conference paper at ICLR 2018
A Appendix: Privacy Analysis
In this appendix, We provide the proofs of Theorem 6 and Proposition 7. Moreover, We present
Proposition 10, which provides optimal values of μι and μ2 to apply towards Theorem 6 for the
GNMax mechanism. We start off with a statement about the Renyi differential privacy guarantee of
the GNMax.
Proposition 8. The GNMax aggregator Mσ guarantees (λ, λ∕σ2)-RDP for all λ ≥ 1.
Proof. The result follows from observing that Mσ can be decomposed into applying the argmax
operator to a noisy histogram resulted from adding Gaussian noise to each dimension of the original
histogram. The Gaussian mechanism satisfies (λ, λ∕2σ2)-RDP (Mironov, 2017), and since each
teacher may change two counts (incrementing one and decrementing the other), the overall RDP
guarantee is as claimed.	∣
Proposition 7. For a GNMax aggregator Mσ, the teachers' votes histogram n = (nι,..., nm),
and for any i* ∈ [m], we have
Pr [Mσ(D) = i*] ≤ q(n),
where
1	ni* - ni
q(n) , 2∑erfc(^^b
i6=i*
Proof. Recall that Mσ (D) = argmax(ni + Zi), where Zi are distributed as N (0, σ2). Then for
any i ∈ [m], We have
Pr[Mσ(D) = i*] = Pr [∃i, n + Zi > n* + Zi*] ≤ E Pr [ni + Zi > ni* + Zi*]
i6=i*
Pr [Zi 一 Zi* > ni*
i6=i*
—
X 1(1-erf (「)).
where the last equality follows from the fact that Zi - Zj is a Gaussian random variable with mean
zero and variance 2σ2.	∣
We now present a precise statement of Theorem 6.
Theorem 6. Let M be a randomized algorithm with (μ1,ε1)-RDP and (μ2,ε2)-RDP guarantees
and suppose that there exists a likely outcome i* given a dataset D and a bound q ≤ 1 such that
q ≥ Pr [M(D) = i*]. Additionally suppose that λ ≤ μι and q ≤ e(μ2-1)ε2/ (μμ⅛ ∙ μμ⅛).
Then, for any neighboring dataset D0 of D, we have:
Dλ(M(D)kM(D0)) ≤ λ-1log ((1 一 q) ∙ A(q,μ2,ε2)λ-1 + q ∙ B(q,μ1,ε1)λ-1)	⑵
μ	μ2 — 1 ∖	1
where A((j, μ2,ε2)，(1 一 q)/ (1 一 (⅞eε2) μ ) and B((j, μι,ει)，eε1 // 1-1.
Proof. Before we proceed to the proof, we introduce some simplifying notation. For a randomized
mechanism M and neighboring datasets D and D0, we define
βM(λ; D, D0), Dλ(M(D)kM(D0))
_	1	1 κ	[<Pr M(D)= x] V-1-
=λ 一 1 log X〜M(D) (Pr [M(D0) = χ]).
As the proof involves working with the RDP bounds in the exponent, we set Zi，eε1(μ1-1) and
Z2，eε2(μ2-1).
17
Published as a conference paper at ICLR 2018
Finally, We define the following shortcuts:
qi , Pr [M(D) = i] and q，X qi = Pr [M(D) = i*],
i=i*
Pi , Pr [M(D0) = i] andP，XPi = Pr [M(D0) = i*],
i=i*
and note that q ≤ q.
From the definition OfRenyi differential privacy, (μι, ει)-RDP implies:
/	∖ l∕(μι-1)
exp (βu(μι; D,D0))=
(1 - q)μι
(1 - p)μ1-1
+X*步
≤ exp(ει)
cNi	μ μ ∖ μι-1
X b=X qi (pi)	≤ ζ1∙
⑶
人 μι — 1
Since μι ≥ λ, f (x)，x λ-1 is convex. Applying Jensen,s Inequality we have the following:
μ1-1
'Pi=i* qi (Pi)”) λ-1
/	∖μι-1
Pi=i* qi ⑶
q
≤
∖
λ ∖ λ-1
X qi (Pi
i=i*	'	/
≤q
λ-1
J % (P )μ1-1)『
∖
λ-1	1- λ-1
≤ C μ1-1 ∙ q μ1-1
(4)
Next, by the bound at order μ2, we have:
exp (βM(μ2; D', D)) = ( (1)qPl-1 + X qP⅛
1∕(μ2-i)
≤ exp(ε2)
(I -p)"2 + X Pμ2	≤ Z
(1 - q)μ2-1	= qμ2-1 ~ζ2'
By the data processing inequality of Renyi divergence, we have
(I -Pr 1 Pμ2 ”
(1 - q)μ2-1 + qμ2-1 ≤ ζ2,
which implies qpμ-1 ≤ ζ2 and thus
P ≤ (qμ2-1Z2)志.
(5)
Combining (4) and (5), we can derive a bound at λ.
/	∖ 1∕(λ-1)
eχpGβM0D,DO))=((1，qL1+X Pq-T)
/	∖ 1∕(λ-1)
(1 — q)λ	, λ-1	1- λ-1 I
≤ --------------ʌ-j- + Z1 μ1-1 ∙ q μ1-1 I
飞(1-(qμ2-%) W)*-1	)
18
Published as a conference paper at ICLR 2018
Although Equation (6) is very close to the corresponding statement in the theorem’s claim, one
subtlety remains. The bound (6) applies to the exact probability q = Pr [M(D) = i*]. In the
theorem statement, and in practice, we can only derive an upper bound q on Pr [M(D) = i*]. The
last step of the proof requires showing that the expression in Equation (6) is monotone in the range
of values of q that we care about.
Lemma 9 (Monotonicity of the bound). Let thefunCtions fι(∙) and f2(∙) be
f1(x) ,
(I - x);∖λ-1	and	f2(x)，Ziμλ--τ
1_ λ - 1
• X μ1-1
(1 - (xμ2-1Z2 ) μ2)
Then fι(x) + f2(x) is increasing in [θ, min (l,Z2∕(μμ-1 • μ2¾『)]∙
Proof. Taking the derivative of f1 (x), we have:
¥0( ∖ __ -λ(1 - x)λ-i (1 - (xμ2-1Z2)μ )λ-i
f1 (X) =	ɪ
(1 - (xμ2-1Z2) μ2 )2λ-2
(1 — x)λ(λ — 1)(1 — (xμ2-1Z2) μ2 )λ-2Z2 μ2 • μμ-i • X- μ2
+----------------:---:---：~~■ 1 一 C--------------
(1 - (xμ2-1Z2) μ2 )2λ-2
= di	-λ+ +(λ - 1) (1」)1 - x 1 (包产).
(1 - (χμ2-1Z2)否)λ-i V	∖ μ2j 1 - (χμ2TZ2)否 ∖x√	)
We intend to show that:
f10 (X) ≥ -λ + (λ - 1)
(7)
For X ∈ [0,Z2∕ (μf-τ • μμ-1)“] and y ∈ [1, ∞), define g(x,y) as:
1
g(x,y) , -λ • yλ-i + (λ - 1) (1 ——) (Z2)	yλ.
∖	μ2 J ∖x J
We claim that g(X, y) is increasing in y and therefore g(X, y) ≥ g(X, 1), and prove itby showing the
partial derivative of g(X, y) with respect to y is non-negative. Take a derivative with respect to y as:
gy(X,y) =-λ(λ - 1)yλ-2+λ(λ - 1)(1 -后
=λ(λ - 1)yλ-2 (-1+(1 - μ)(ζ2
(Z2 厂 L
μ2 y!.
To see why gy0 (X, y) is non-negative in the respective ranges ofX and y, note that:
,广/ μι	μ2
X ≤ ζ2/ ---Γ------7
∖μι - 1	μ2 - 1
μ2	μ μ ∖ μ2
=⇒ X ≤Z2∕(4)
(as y ≥ 1)
=⇒ 0 ≤ gy0 (X, y).
=⇒ 0 ≤-1 + μ二1
〃2
(in the resp. range of X and y)
19
Published as a conference paper at ICLR 2018
Consider [-(方仙？1—›/仙2. Since Z2 ≥ 1 and X ≤ 1, we have X ≤ Q and hence
1-x
1 - (xμ2-1Z2) μ2
1-X
≥---------------- = 1.
1 — (xμ2-1x) μ2
Therefore we can set y = [-(方仙？1-为尸/仙2 and apply the fact that g(χ, y) ≥ g(χ, 1) for all y ≥ 1 to
get
f1(X) ≥-λ+(λ - 1)(1—μ)( ζ2 )“2,
as required by (7).
Taking the derivative of f2 (X), we have:
,	λ-1
f2 (X) = Z1 "1-1
λ-1
1 —」)X-寻=(Z1) K (1-」)≥ 1 —」
μι - 1 J	∖x J μ μι - 1J μι - 1
Combining the two terms together, we have:
f(X) ≥-λ+(λ -1) (1 - W) (Z)μ2 +1 - S
1
μ2
≥0
For f0(X) to be non-negative we need:
μι
μ1 - 1
+ μ2 - 1 ζ ζ2
μ2 IX
μι μ2
--------------
μι - 1-μ2 - 1
μ2	广
≤®.
X
—
^⇒
So f(x) is increasing for X ∈ [0,Z2/(μμ⅛ ∙ μμ⅛)*]∙ ThiS means
for
q ≤ q ≤
μ	μ μ2
Z2/( μμ-ι ∙ μμ—ι) , we have f (q) ≤ f (q). This completes the proof of the lemma and that of
the theorem.	∣
Theorem 6 yields data-dependent Renyi differential privacy bounds for any value of μι and μ2 larger
than λ. The following proposition simplifies this search by calculating optimal higher moments μι
and μ2 for the GNMax mechanism with variance σ2.
Proposition 10. When applying Theorem 6 and Proposition 8 for GNMax with Gaussian of variance
σ2, the right-hand side of (2) is minimized at
μ2 = σ ∙ VZlog(I/q), and μι = μ2 + 1.
Proof. We can minimize both terms in (2) independently. To minimize the first term in (6), we
minimize (qeε2 )1-1/*2 by considering logarithms:
μ2 -1
σ2
μ2 - 1
σ2
1
(1 - μ1) ∙ log q+
ɪ log1 + μ -二-log 三,
μ2	q σ2 σ2 q
20
Published as a conference paper at ICLR 2018
which is minimized at μ2 = σ ∙ Sog(I/q).
To minimize the second term in (6), We minimize eε1 /亍/(*1-1) as follows：
μι ,
-2 +
σ2
1
σ2
1	1	1
-----7log-
μι 一 1 q
μι - 1 +	1
σ2 μι 一 1
log1,
q
+
which is minimized at μι = 1 + σ ∙ Sog(I/q) completing the proof.
Putting this together, we apply the following steps to calculate RDP of order λ for GNMax with
variance σ2 on a given dataset D . First, we compute a bound q according to Proposition 7. Then we
use the smaller of two bounds: a data-dependent (Theorem 6) and a data-independent one (Proposi-
tion 8) :
βσ(q) , min (ʒ-ɪ-j-log {(1 一 q) ∙ A(q, μ2,ε2)λ-1 + q ∙ B(q,μ1,ε1)λ-l} ,λ∕σ2
I λ 一 1
where A and B are defined as in the statement of Theorem 6, the parameters μι and μ2 are selected
according to Proposition 10, and ει，μ1∕σ2 and ε2，μ2∕σ2 (Proposition 8). Importantly, the first
expression is evaluated only when q < 1,	μι	≥	λ,	μ2 >	1,	and q ≤	e(μ2-1)ε2/ (μμ⅛	∙	μμ-ι)	.
These conditions can either be checked for each application of the aggregation mechanism, or a crit-
ical value of q0 that separates the range of applicability of the data-dependent and data-independent
bounds can be computed for given σ and λ. In our implementation we pursue the second approach.
The following corollary offers a simple asymptotic expression of the privacy of GNMax for the case
when there are large (relative to σ) gaps between the highest three vote counts.
Corollary 11. If the top three vote counts are n1 > n2 > n3 and n1 一 n2, n2 一 n3	σ,
then the mechanism GNMax with Gaussian of variance σ2 satisfies (λ, exp(-2λ∕σ2)∕λ) -RDP for
λ = (n1 一 n2)∕4.
Proof. Denote the noisy counts as n = n + N(0,σ2). Ignoring outputs other than those with
the highest and the second highest counts, we bound q = Pr [M(D) = 1] as Pr[nι < n2]=
Pr[N(0, 2σ2) > n 一 的]< exp (一(nι — nz)2∕4σ2), which we use as q. Plugging q in Proposi-
tion 10, we have μι 一 1 = μ2 = (nι — n2)∕2, limiting the range of applicability of Theorem 6 to
λ < (n1 一 n2)∕2.
Choosing λ = (nι 一 n2)∕4 ensures A(q, μ2,ε2) ≈ 1, which allows approximating the bound (2) as
q ∙ B(q, μι, ε1)λ-1∕(λ 一 1). The proof follows by straightforward calculation.	∣
B Smooth Sensitivity and Publishing the Privacy Parameter
The privacy guarantees obtained for the mechanisms in this paper via Theorem 6 take as input q, an
upper bound on the probability that the aggregate mechanism returns the true plurality. This means
that the resulting privacy parameters computed depend on teacher votes and hence the underlying
data. To avoid potential privacy breaches from simply publishing the data-dependent parameter, we
need to publish a sanitized version of the privacy loss. This is done by adding noise to the computed
privacy loss estimates using the smooth sensitivity algorithm proposed by Nissim et al. (2007).
This section has the following structure. First we recall the notion of smooth sensitivity and intro-
duce an algorithm for computing the smooth sensitivity of the privacy loss function of the GNMax
mechanism. In the rest of the section we prove correctness of these algorithms by stating several
conditions on the mechanism, proving that these conditions are sufficient for correctness of the al-
gorithm, and finally demonstrating that GNMax satisfies these conditions.
21
Published as a conference paper at ICLR 2018
B.1 Computing Smooth Sensitivity
Any dataset D defines a histogram n = (nι,...,nm) ∈ Nm of the teachers, votes. We have a
natural notion of the distance between two histograms dist(n, n0) and a function q: Nm → [0,1]
on these histograms computing the bound according to Proposition 7. The value q(n) can be used
as q in the application of Theorem 6. Additionally we have n(i) denote the i-th highest bar in the
histogram.
We aim at calculating a smooth sensitivity of β (q(n)) whose definition we recall now.
Definition 12 (Smooth Sensitivity). Given the smoothness parameter β, a β-smooth sensitivity of
f (n) is defined as
SSe(n)，max e-βd ∙ max	LS(n0),
d≥0	n，dist(n,n0)≤d
where
LS⑹ ≥ n，：dimaxn，)=IfS)-f(n0)1
is an upper bound on the local sensitivity.
We now describe Algorithms 3-5 computing a smooth sensitivity of β (q(∙)). The algorithms as-
sume the existence of efficiently computable functions q: Nm → [0, 1], BL, BU: [0, 1] → [0, 1], and
a constant q0 .
Informally, the functions BU and BL respectively upper and lower bound the value of q evaluated at
any neighbor of n given q(n), and [0, q0) limits the range of applicability of data-dependent analysis.
The functions BL and BU are defined as follows. Their derivation appears in Section B.4.
,1 ,
Bu(q)，min m m - 】erfc (erfc-1 (—^q-
2	m -1
BL(q)，m- 1 erfc (erfc-1 ( 2q ) + 1
2	m -1 σ
Algorithm 3 - Local Sensitivity: use the functions BU and BL to compute (an upper bound) of the
local sensitivity at a given q value by looking at the difference of β (∙) evaluated on the bounds.
1:	procedure LS(q)
2:	if q1 ≤ q ≤ q0 then	. q1 = BL(q0). Interpolate the middle part.
3：	q — qι
4:	end if
5:	return max{β (BU (q)) - β (q) ,β(q) - β (BL(q))}
6:	end procedure
B.2	Notation and Conditions
Notation. We find that the algorithm and the proof of its correctness are more naturally expressed
if we relax the notions of a histogram and its neighbors to allow non-integer values.
•	We generalize histograms to be any vector with non-negative real values. This relaxation is
used only in the analysis of algorithms; the actual computations are performed exclusively
over integer-valued inputs.
•	Let n = [nι,..., nm] ∈ Rm, n ≥ 0 denote a histogram. Let n(i) denote the i-th bar in the
descending order.
•	Define a “move” as increasing one bar by some value in [0, 1] and decreasing one bar by a
(possibly different) value in [0, 1] subject to the resulting value be non-negative. Notice the
difference between the original problem and our relaxation. In the original formulation, the
histogram takes only integer values and we can only increase/decrease them by exactly 1.
In contrast, we allow real values and a teacher can contribute an arbitrary amount in [0, 1]
to any one class.
22
Published as a conference paper at ICLR 2018
Algorithm 4 - Sensitivity at a distance: given a histogram n, compute the sensitivity of β (∙) at
distance at most d using the procedure LS, function q(∙), constants qo and qι = BL (qo), and careful
case analysis that finds the neighbor at distance d with the maximum sensitivity.
1	procedure ATDISTANCED(n, d)
2	q — q(n)
3	:	if q1 ≤ q ≤ q0 then	. q is in the flat region.
4	return LS(q), STOP
5	:	end if
6	:	if q < q1 then	. Need to increase q.
7	:	if n(1) - n(2) < 2d then	. n(i) is the ith largest element.
8	return LS(q；), STOP
9	:	else
10	n04—SORT(n) + [—d, d, 0,. .., 0]
11	q0 — q(n0)
12	:	if q0 > q； then
13	:	return LS(q0), STOP
14	:	else
15	:	return LS(q0), CONTINUE
16	:	end if
17	:	end if
18	:	else	. Need to decrease q.
19	:	if Pid=2 n(i) ≤ d then
20	n0 J [n, 0,..., 0]
21	q0 J q(n0)
22	return LS(q0), STOP
23	:	else
24	n0 j SORT(n) + [d, 0,..., 0]
25	:	for d0 = 1, . . . , d do
26	:	n0(2) J n0(2) - 1	. The index of n0(2) may change.
27	:	end for
28	q0 J q(n0)
29	:	if q0 < q0 then
30	return LS(qo), STOP
31	:	else
32	:	return LS(q0), CONTINUE
33	:	end if
34	:	end if
35	:	end if
36	: end procedure
	
Algorithm 5 - Smooth Sensitivity: Compute the β smooth sensitivity of β (∙) via Definition 12 by	
looking at sensitivities at various distances and returning the maximum weighted by e-βd.	
1	procedure SMOOTHSENSITIVITY(n, β)
2	:	SJ0
3	:	dJ0
4	:	repeat
5	c, StoppingCondition J ATDISTANCED(n, d)
6	S J max{S, C ∙ e-βd}
7	:	dJd+1
8	:	until StoppingCondition = STOP
9	: end procedure
•	Define the distance between two histograms n = (nι,..., nm,) and n0 = (n；,..., n'rn) as
d(n,n0)，max I E Ini-nie,	E Ini - %] },
i:ni>n0i	i:ni<n0i
23
Published as a conference paper at ICLR 2018
which is equal to the smallest number of “moves” needed to make the two histograms
identical. We use the ceiling function since a single step can increase/decrease one bar by
at most 1.
We say that two histograms are neighbors if their distance d is 1.
Notice that analyses of Renyi differential privacy for LNMax, GNMaX and the exponential
mechanism are still applicable when the neighboring datasets are defined in this manner.
•	Given a randomized aggregator M: R≥m0 → [m], let q: R≥m0 → [0, 1] be so that
q(n) ≥ Pr[M(n) = argmax(n)].
When the context is clear, we use q to denote a specific value of the function, which, in
particular, can be used as q in applications of Theorem 6.
•	Let β: [0, 1] → R be the function that maps a q value to the value of the Renyi accountant.
Conditions. Throughout this section We will be referring to the list of conditions on q(∙) and β (∙):
C1. The function q(∙) is continuous in each argument n%.
C2. There exist functions Bu, Bl： [0,1] → [0,1] such that for any neighbor n0 of n, we have
Bι(q(n)) ≤ q(n0) ≤ Bu(q(n)), i.e., BU and BL provide upper and lower bounds on the
q value of any neighbor of n.
C3. BL(q) is increasing in q.
C4. BU and BL are functional inverses of each other in part of the range, i.e., q = BL(BU(q))
for all q ∈ [0, q0], where q0 is defined below. Additionally BL (q) ≤ q ≤ BU (q) for all
q∈ [0, 1].
C5. β (∙) has the following shape: there exist constants β* and q0 ≤ 0.5, such that β (q) non-
decreasing in [0, qo] and β (q) = β* ≥ β (qo) for q > qo. The constant β* corresponds to
a data-independent bound.
C6. ∆β (q) , β (BU(q)) - β (q) is non-decreasing in [0, BL(qo)], i.e., when BU(q) ≤ qo.
C7. Recall that n(i) is the i-th largest coordinate of a histogram n. Then, if q(n) ≤ Bu(qo),
then q(n) is differentiable in all coordinates and
∀i>j ≥2 ∂nj)(n) ≥ ∂⅛r(n) ≥0.
C8. The function q(n) is invariant under addition of a constant, i.e.,
q(n) = q(n +[x,...,x]) for all n and X ≥ 0,
and q(n) is invariant under permutation of n, i.e.,
q(n) = q(π(n)) for all permutations π on [m].
Finally, we require that if n(1) = n(2), then q(n) ≥ qo.
We may additionally assume that qo ≥ q([n, 0, . . . , 0]). Indeed, if this condition is not satisfied,
then the data-dependent analysis is not going to be used anywhere. The most extreme histogram—
[n, 0, . . . , 0]—is the most advantageous setting for applying data-dependent bounds. If we cannot
use the data-dependent bound even in that case, we would be using the data-independent bound
everywhere and do not need to compute smooth sensitivity anyway. Yet this condition is not auto-
matically satisfied. For example, if m (the number of classes) is large compared to n (the number
of teachers), we might have large q([n, 0, . . . , 0]). So we need to check this condition in the code
before doing smooth sensitivity calculation.
B.3	Correctness of Algorithms 3—5
Recall that local sensitivity ofa deterministic function f is defined as max f(D) - f (D0), where D
and D0 are neighbors.
Proposition 13. Under conditions C2-C6, Algorithm 3 computes an upper bound on local sensitiv-
ityof β (q(n)) ∙
24
Published as a conference paper at ICLR 2018
Proof. Since β (∙) is non-decreasing everywhere (by C5), and for any neighbors n and n0 it holds
that BL(q(n)) ≤ q(n0) ≤ Bu(q(n)) (by C2), we have the following
lβ(q(n)) -β(q(n0))l ≤ max{β(Bu(q(n))) — β(q(n)), β(q(n)) — β(Bι(q(n)))}
=max{∆β(q(n)), ∆β ^Bl(q(n))^ j
as an upper bound on the local sensitivity of β (q(∙)) at input n.
The function computed by Algorithm 3 differs from above when q(n) ∈ (BL (q0),q0). To complete
the proof We need to argue that the local sensitivity is upper bounded by ∆β (BL(qo)) for q(n) in
this interval. The bound follows from the following three observations.
First, ∆β (q) is non-increasing in the range (BL(q0), 1], since β (BU (q)) is constant (by BU(q) ≥
BU(BL(q0)) = q0 and C5) and β (q) is non-decreasing in the range (by C5). In particular,
∆β (q) ≤ ∆β(BL(q0)) ifq ≥ BL(q0).	(8)
Second, ∆β (BL (q)) is non-decreasing in the range [0, q0] since BL (q) is increasing (by C3 and C6).
This implies that
∆β(BL(q)) ≤∆β(BL(q0)) ifq≤q0.	(9)
By (8) and (9) applied to the intersection of the two ranges, it holds that
max {∆β(q(n)), ∆β(BL(q(n))) } ≤ ∆β (BL(qo)) if BL(qo) ≤ q ≤ qo,
as needed.	∣
5 T .1	. 1 1 ∙ 1 1.1 . . 1 Γ∙	. ∙	. 1 1 Al	∙ .1	C 1 ∙ 1	11 丁〜C / ∖ C
We thus established that the function computed by Algorithm 3, which we call LS(q) from now on,
is an upper bound on the local sensitivity. Formally,
∆β(BL(q0))
if q ∈ (BL (q0), q0),
LSg),
max {∆β (q) , ∆β (BL(q))}	otherwise.
The following proposition characterizes the growth of LS(q).
Proposition 14. Assuming conditions C2-C6, the function LS(q) is non-decreasing in [0, BL(qo)],
constant in [BL (q0), q0], and non-increasing in [q0, 1].
Proof. Consider separately three intervals.
•	By construction, LS is constant in [BL (q0), q0].
•	Since both functions ∆β (∙) and ∆β (Bl(∙)) are each non-decreasing in [0, BL(qo)), so is
their max.
•	In the interval (q0, 1], β (q) is constant. Hence ∆β (q) = 0 and ∆β (BL (q)) = β (q) -
β (BL (q)) is non-decreasing. Their maximum value ∆β (BL(q)) is non-decreasing.
The claim follows.	∣
We next prove correctness of Algorithm 4, which computes the maximal sensitivity of β at a fixed
distance.
The proof relies on the following notion of a partial order between histograms.
Definition 15. Prefix sums Si(n) are defined asfollows:
i
Si(n)，X(n(I)- n⑶).
j=1
We say that a histogram n dominates n0, denoted as n 占 n0, iff:
∀ (1 < i ≤ m) it holds that Si(n) ≥ Si(n0).
25
Published as a conference paper at ICLR 2018
The function q(∙) is monotone under this notion of dominance (assuming certain conditions hold):
Proposition 16. If q(∙) satisfies C1, C2, C7, and C8, and q(n) < Bu(qo) ,then
n 占 n0 ⇒ q(n) ≤ q(n0).
Proof. We may assume that n(1) = n0(1). Indeed, if this does not hold, add |n(1) - n0(1) | to all
coordinates of the histogram with the smaller of the two values. This transform does not change the
q value (by C8) and it preserves the 占 relationship as all prefix sums Si(∙) remain unchanged.
We make a simple observation that will be helpful later:
i
∀i ∈ [m] it holds that ^X(n⑴ 一 n7-) ≥ Si(n).	(10)
j=1
The inequality holds because the prefix sum accumulates the gaps between the largest value of n
and all other values in the non-decreasing order. Any deviation from this order may only increase
the prefix sums.
The following lemma constructs a monotone chain (in the partial order of dominance) of histograms
connecting n and n0 via a sequence of intermediate steps that either do not change the value of q or
touch at most two coordinates at a time.
Lemma 17. There exists a chain n = no 占 nι 占 … 占 nd = n0, such that for all i ∈ [d] either
d(ni-ι,ni) = 1 or ni-ι = π(ni) for some permutation π on [m]. Additionally, n01) = … =n1.
Proof(Lemma). Wlog We assume that n and n0 are each sorted in the descending order. The proof
is by induction on '(n,n0)，Pidni - ni] ≤ 2d(n,n0), which, by construction, only assumes
non-negative integer values.
If the distance is 0, the statement is immediate. Otherwise, find the smallest i so that Si(n) > Si(n0)
(if all prefix sums are equal and n(1) = n0(1), it would imply that n = n0). In particular, it means
that n = nj for j < i and n < ni ≤ ni-ι = ni-ι. Let X，min(ni — ni, 1). Define n00 as
identical to n0 except that ni = ni — x. The new value is guaranteed to be non-negative, since
x ≤ ni — ni and n ≥ 0. Note that n00 is not necessarily sorted anymore. Consider two possibilities.
Case I:	n 占	n00.	Since n00	占	n0,	'(n,n00)	<	'(n,n0),	and	d(n00,n0)	= 1, we may apply the
induction hypothesis to the pair n, n00.
Case II:	n t n00. This may happen because the prefix sums of n00 increase compared to Sj (n0) for
0
j ≥ i. Find the smallest such i0 so that Ej=ι(n7 — nj0) > Si，(n). (Since n00 is not sorted, we fix
the order in which prefix sums are accumulated to be the same as in n; by (10) i0 is well defined).
Next we let n000 be identical to n00 except that niθ0 = n% + x. In other words, n000 differs from n0 by
shifting x from coordinate i to coordinate i0 .
We argue that incrementing ni0 by X does not change the maximal value of n00, i.e., n；00 > 叫.Our
choice of i0, which is the smallest index so that the prefix sum over n00 overtakes that over n, implies
that n010 — n0i00 > n1 — ni0. Since n010 = n1, it means that ni0 > n0i00 (and by adding x we move n0i00
towards ni0). Furthermore,
n0i000 = n0i00 + x ≤ ni0 + (n0i — ni) = n0i + (ni0 — ni) ≤ n0i ≤ n01 = n0100,
(We use ni0 ≤ ni , which is implied by i0 > i.)
We claim that Pj=i(n；00 — nj00) ≤ St(n) for all t, and thus, via (10), n 占 n000 . The choice of i0
makes the statement trivial for t < i0. For t ≥ i0 the following holds:
tt	t
X(n；00 — nj00) = X(nz — nj0) — X ≤ I X(n； — nj) + x ∣ — X = St(n0) ≤ St(n).
j=1	j=1	j=1
By construction d(n0, n000 ) = 1 (the two histograms differ in two locations, in positive and negative
directions, by X ≤ 1 in each). For the same reasons n000 占 n0. To show that '(n, n0) > '(n, n000),
26
Published as a conference paper at ICLR 2018
compare dnj - n0je and dnj - n0j00e for j = i, i0 . At j = i the first term is strictly larger than the
second. At j = i0 , the inequality holds too but it may be not strict.
We may again apply the induction hypothesis to the pair n and n000, thus completing the proof of the
lemma.	I
To complete the proof of the proposition, we need to argue that the values of q are also monotone in
the chain constructed by the previous lemma. Concretely, we put forth
Lemma 18. If n0 占 n, q(n0) ≤ Bu(qo), d(n, n0) = 1 and n(1) = n0(1) ,then q(n) ≤ q(n0).
Proof. The fact that d(n, n0) = 1 and n 占 n0 means that there is either a single index i so that
n0i < ni , or there exist two indices i and j so that n0i < ni and n0j > nj . The first case is immediate,
since q is non-decreasing in all inputs except for the largest (by C7).
Let ni = ni 一 X and nj = n + y, where x,y > 0. Since n 占 n0, it follows that n ≥ n and x > y.
Consider two cases.
Case I:	n0i ≥ n0j , i.e., removing x from ni and adding y to nj does not change their ordering. Let
n(t)，(1 — t)n + t ∙ n0 = [nι,...,ni — t ∙ x,...,nj + t ∙ y,..., nm].
Then,
q(n0) — q(n) = q(n(1)) — q(n(0)) = Z (q ◦ η)0(t)dt
t=0
xgn(t)+ y-d^n(t)∖ dt
∂ni	∂nj
≤ 0.
The last inequality follows from C7 and the facts that x > y > 0 and ni(t) > nj (t). (The condition
that q(n(t)) ≤ Bu(qo) follows from C2 and the fact that d(n0, n(t)) ≤ 1.)
Case II:	ni ≤ nj. In this case We swap the ith and jth indices in n0 by defining n00 which differs
from it in ni0 = nj and nj0 = ni. By C8, q(n00) = q(n0) and, of course, n00 占 n since the prefix
sums remain unchanged. The benefit of doing this transformation is that we are back in Case I,
where the relative order of coordinates that change between n and n00 remains the same.
This concludes the proof of the lemma.	∣
Applying Lemma 17 we construct a chain of histograms between n and n0, which, by Lemma 18, is
non-increasing in q(∙). Together this implies that q(n) ≤ q(n0), as claimed.	∣
We apply the notion of dominance in proving the following proposition, which is used later in
arguing correctness of Algorithm 4.
Proposition 19. Let n be an integer-valued histogram and d be a positive integer. And q(∙) satisfies
C1, C7, and C8. The following holds:
1. Assuming n(1) — n(2) ≥ 2d, let n* be obtained from n by decrementing n(1) by d and
incrementing n(2) by d. Then
d(n, n*) = d and q(n*) ≥ q(n0) for any n0 such that d(n, n0) = d.
2. Assuming Pm=2 n(i) ≥ d, let n** be obtained from n by incrementing ni by d, and by
repeatedly decrementing the histogram’s current second highest value by one, d times. Then
d(n, n**) = d and q(n**) ≤ q(n0) for any n0 such that d(n, n0) = d.
Proof. Towards proving the claims, we argue that n* and n** are, respectively, the minimal and
the maximal elements in the histogram dominance order (Definition 15) in the set of histograms at
distance d from n. By Proposition 16 the claims follow.
27
Published as a conference paper at ICLR 2018
1.	Take any histogram n0 at distance d from n.	Our goal is to prove that n0 占
n*. Recall the definition of the distance d(∙, ∙) between two histograms d(n,n0) =
max Pi:ni>n0idni -n0ie,Pi:ni<n0idn0i -nie
in particular, that
If the distance is bounded by d, it means,
n0(1) ≥ n(1) - d and
ii
X n0(j) ≤ X n(j) + d for all i > 2.
That lets us bound the prefix sums of n0 as follows:
ii
Si(n0) = X(n0⑴一nOj)) = (i - 1) ∙ n0(I)- Xn0⑶
j=2	j=2
≥ (i - 1) ∙ (n⑴-d) - (Xn(j) + dj = Si(n*).
We demonstrated that n0 占 n*, which, by Proposition 16, implies that q(n0) ≤ q(n*).
Together with the immediate d(n, n*) = d we prove the claim.
2.	Assume wlog that n is sorted in the descending order. Define the following value that
depends on n and d:
u , min x ∈ N:	ni - x ≤ d .
i:i>1,ni ≥x
The constant u is the smallest such x so that the total mass that can be shaved from elements
of n above X (excluding nι) is at most d.
We give the following equivalent definition of n**:
(nr + d if i = 1,
ni** = u if i > 1 and ni ≥ u,
Ini	otherwise.
Fix any i ∈ [m] and any histogram n0 at distance d from n. Our goal is to prove that
Si(n**) ≥ Si(n0) and thus n** 占 n0. Assume the opposite and take largest i such that
Si(n**) <Si(n0).
We may assume that n0(1) = n1** = n1 + d. Consider the following cases.
Case I.	If n**(i) < u, the contradiction follows from
ii
Si(n0) = ^X(n0(I) — n0(j)) = ^X ((n0(I) — n(I)) + (n(I) — n(j)) + (n(j) — n0(j)))
j=2	j=2
≤ (i — l)d + Si(n) + d = Si(n**).
The last equality is due to the fact that all differences between n and n** are confined to
the indices that are less than i.
Case II.	If n**(i) = U and n0(i) ≥ u, the contradiction with Si(n**) < Si(n0) follows
immediately from
i
Si(n0) = X(n0⑴一n0(j)) ≤ (i — 1)(n0⑴-U) = Si(n**).
j=2
Case III.	Finally, consider the case when n**(i) = U and v , n0(i) < U. Since i is the
largest such that Si(n**) < Si(n0), it means that n**(i+1) < n0(i+1) ≤ v < u = n**(i)
28
Published as a conference paper at ICLR 2018
and thus n**(i) - n**(i+1) ≥ 2 (We rely on the fact that the histograms are integer-valued).
It implies that all differences between n and n** are confined to the indices in [1,i]. Then,
ii
Si(n**) - Si(n0) ≥ X(n；* - nj*)- X(n1 - nj)	(by (10))
j=2	j=2
i
=X((n7- - n**) + (nj - nj))	(since nɪ* = n1)
j=2
≥ d — d(n, n0)
≥ 0,
which contradicts the assumption that Si(n**) < Si(n0).
We may now state and prove the main result of this section.
Theorem 20. Assume that q(∙) satisfies conditions C1-C8 and n is an integer-valued histogram.
Then the following two claims are true:
1.	Algorithm 4 computes maxnodst(n,no)≤d LS(n0).
2.	Algorithm 5 computes SSe (n), which is a β-smooth upper bound on Smooth SenSitivity
of β(q(∙)).
>Λ	C Cl	C	11.1	T^∖∕∖	1 . 1	Γ∙	Λ 1 ʌ	∙ . ∙	Λ Λ .1 Γ∙	. ∙	T~[-Λ / ∖ ♦
Proof. Claim 1. Recall that q1 = BL(q0), and therefore, by Proposition 14 the function LS(q) is
non-decreasing in [0, q1], constant in [q1, q0], and non-increasing in [q0, 1]. It means, in particular,
that to maximize LS(q(n0)) over histograms satisfying d(n, n0) = d, it suffices to consider the
following cases.
If LS(q(n)) < qι, then higher values of LS(∙) may be attained only by histograms with higher values
of q. Proposition 19 enables us to efficiently find a histogram n* with the highest q at distance d, or
conclude that we may reach the plateau by making the two highest histogram entries be equal.
If qι ≤ LS(q(n)) ≤ q0, it means that LS(q(n)) is already as high as it can be.
If qo < LS(q(n)), then, according to Proposition 14, higher values of LS(∙) can be achieved by his-
tograms with smaller values of q, which we explore using the procedure outlined by Proposition 19.
The stopping condition—when the plateau is reached—happens when q becomes smaller than q0 .
Claim 2. The second claim follows from the specification of Algorithm 5 and the first claim. ∣
B.4 GNMAX Satisfies Conditions C1-C8
The previous sections laid down a framework for computing smooth sensitivity of a randomized
aggregator mechanism: defining functions q(∙), Bu(∙), Bl(∙), verifying that they satisfy conditions
C1-C8, and applying Theorem 20, which asserts correctness of Algorithm 5. In this section we
instantiate this framework for the GNMax mechanism.
29
Published as a conference paper at ICLR 2018
B.4.1 Conditions C1-C4, C7 and C8
Defining q and conditions C1, C7, and C8. Following Proposition 7, we define q: R≥m0 → [0, 1]
for a GNMax mechanism parameterized with σ as:
q(n)，min	Pr(Zi —Zi* ≥ ng* — ni), 1
[i=i*	,
= min {X 2 (if (T )),1
{L 1 f n ni* — ni∖ 1 I
CerfC	,
where i* is the histogram n's highest coordinate, i.e., ni* ≥ n for all i (if there are multiple highest,
let i be any of them). Recall that erf is the error function, and erfc is the complement error function.
Proposition 7 demonstrates that q(n) bounds from above the probability that GNMax outputs any-
thing but the highest coordinate of the histogram.
Conditions C1, C7, and C8 follow by simple calculus (q0, defined below, is at most 0.5).
Functions Bl, Bu, and conditions C2-C4. Recall that the functions BL and BU are defined in
Appendix B as follows:
BU ⑹,min {mr1 erfc (erfc-1 (m2—I)-1) ,1},
BLg), m21 erfc 卜rfc-1( m2—1) +1 )，
Proposition 21 (Condition C2). For any neighbor n0 of n, i.e., d(n0, n) = 1, the following bounds
hold:
BL(q(n)) ≤ q(n0) ≤ Bu(q(n)).
Proof. Assume wlog that i* = 1. Let Xi，nι 一 n and qi，erfc(xi∕2σ)∕2, and similarly define
χi for n0. Observe that |xi 一 χi∣≤ 2, which, by monotonicity of erfc, implies that
1 erfc	(χi±^)	≤	qi (n0) ≤ 1 erfc	(Xi-2).
2	∖2σ	一	%- - 2	∖2σ
Thus
1 X erfc	)≤ q(n0) ≤ 2 X	(x^) ∙
i>1	i>1
(Although i* may change between n and n0, the bounds still hold.)
Our first goal is to upper bound q(n0) for a given value of q(n). To this end We set up the following
maximization problem
max X erfc χ xi——-∣ such that - erfc (X-) = q and Xi ≥ 0.
{Xi} 2 与 < 2σ )	2 >	2σσJ U i-
We may temporarily ignore the non-negative constraints, which end up being satisfied by our solu-
tion. Consider using the method of Lagrange multipliers and take a derivative in xi’:
30
Published as a conference paper at ICLR 2018
Since the expression is symmetric in i > 1, it means that the local optima are attained at x2 =
…=Xm (the second derivative confirms that these are local maxima). After solving for (m -
1) erfc(x∕2σ) = 2q We have
q(n0) ≤ m - 1 erfc (erfc-1 (	2q
2	m-1
Where m is the number of classes. Similarly,
q(n0) ≥ m——1 erfc (erfc-1 ( 2q ) + 1
2	m-1 σ
Conditions C3, i.e., BL(q) is monotonically increasing in q, and C4, i.e., BL and BU are functional
inverses of each other in [0, q0] and BL(q) ≤ q ≤ BU(q) for all q ∈ [0, 1], folloW from basic
properties of erfc. The restriction that q ∈ [0, q0] ensures that BU(q) is strictly less than one, and the
minimum in the definition of Bu(∙) simplifies to its first argument in this range.
B.4.2 Conditions C5 and C6
Conditions C5 and C6 stipulate that the function β (q) , βσ (q) (defined in Appendix A) exhibits a
specific groWth pattern. Concretely, C5 states that β (q) is monotonically increasing for 0 ≤ q ≤ q0,
and constant for q0 < q ≤ 1. (Additionally, We require that BU(q0) < 1). Condition C6 requires
that ∆β (q) = β (BU(q)) - β (q) is non-decreasing in [0, BL(q0)].
Rather than proving these statements analytically, We check these assumptions for any fixed σ and λ
via a combination of symbolic and numeric analyses.
More concretely, we construct symbolic expressions for β (∙) and ∆β (∙) and (symbolically) differ-
entiate them. We then minimize (numerically) the resulting expressions over [0, q0] and [0, BL (q0)],
and verify that their minimal values are indeed non-negative.
B.5 RENYI DIFFERENTIAL PRIVACY AND SMOOTH SENSITIVITY
Although the procedure for computing a smooth sensitivity bound may be quite involved (such as
Algorithms 3-5), its use in a differentially private data release is straightforward. Following Nissim
et al. (2007), we define an additive Gaussian mechanism where the noise distribution is scaled by σ
and a smooth sensitivity bound:
Definition 22. Given a real-valued function f: D → R and a β-smooth Sensitivity bound SS(∙) ,let
(β, σ)-GNSS mechanism be
Fσ(D)，f(D) + SSβ(D) ∙N(0,σ2).
We claim that this mechanism satisfies Renyi differential privacy for finite orders from a certain
range.
Theorem 23. The (β, σ)-GNSS mechanism Fσ is (λ, ε)-RDP, where
△ λ∙ e2β	βλ - 0.5ln(1 - 2λβ)
ε , 丁 +-------------Λ-1~-
forall 1 <λ< 1∕(2β).
Proof. Consider two neighboring datasets D and D0. The output distributions of the (β, σ)-GNSS
mechanism on D and D0 are, respectively,
P , f (D) + SSe(D) ∙ N(0, σ2) = N(f (D), (SSβ(D)σ)2) and Q，N(f (D0), (SSe(D0)σ)2).
The Renyi divergence between two normal distributions can be computed in closed form (van Erven
& Harremoes, 2014):
D (PkQ) = λ (f (D)-f(D0))2 ,	1 ln	S	(11)
λ( kQ)=	2σ2s2	+ 1 - λ l SSe(D)1-λ ∙ SSe(D0)λ,	( )
31
Published as a conference paper at ICLR 2018
provided s2，(1 — λ) ∙ SSe(D)2 + λ ∙ SSe(D0)2 > 0.
According to the definition of smooth sensitivity (Definition 12)
e-β ∙ SSe(D) ≤ SSe(D0) ≤ eβ ∙ SSe(D),	(12)
and
|f (D)- f (D0)∣≤ ee ∙ min(SSe(D), SSe(D0))∙	(13)
Bound (12) together with the condition that λ ≤ 1∕(2β) implies that
s2 = (1 — λ) ∙ SSe(D)2 + λ ∙ SSe(DY = SSe(D)2 + λ(SSe(D0)2 — SSe(D)2)
≥ SSe(D)2(1 + λ(e-2e - 1)) ≥ SSe(D)2(1 - 2λβ) > 0. (14)
The above lower bound ensures that s2 is well-defined, i.e., non-negative, as required for application
of (11).
Combining bounds (12)- (14), We have that
Dλ(PkQ)≤
λ ∙ e2e	1 J S	-λe∖	λ∙ e2e	βλ — 0.5ln(1 — 2λβ)
σ2 + 1 — λ ɪɪ S SSe(D)6	ʃ -02+	λ — 1
as claimed.
Note that if λ 1, σ λ, andβ 1∕(2λ), then (β, σ)-GNSS satisfies (λ, (λ+1)∕σ2)-RDP. Com-
pare this with RDP analysis of the standard additive Gaussian mechanism, which satisfies (λ, λ∕σ2)-
RDP. The difference is that GNSS scales noise in proportion to smooth sensitivity, which is no larger
and can be much smaller than global sensitivity.
B.6 Putting It All Together: Applying Smooth Sensitivity
Recall our initial motivation for the smooth sensitivity analysis: enabling privacy-preserving re-
lease of data-dependent privacy guarantees. Indeed, these guarantees vary greatly between queries
(see Figure 5) and are typically much smaller than data-independent privacy bounds. Since data-
dependent bounds may leak information about underlying data, publishing the bounds themselves
requires a differentially private mechanism. As we explain shortly, smooth sensitivity analysis is a
natural fit for this task.
We first consider the standard additive noise mechanism where the noise (such as Laplace or Gaus-
sian) is calibrated to the global sensitivity of the function we would like to make differentially
private. We know that REnyi differential privacy is additive for any fixed order λ, and thus the
cumulative RDP cost is the sum of RDP costs of individual queries each upper bounded by a data-
independent bound. Thus, it might be tempting to use the standard additive noise mechanism for
sanitizing the total, but that would be a mistake.
To see why, consider a sequence of queries nι,...,n' answered by the aggregator. Their total
(unsanitized) RDP cost of order λ is Bσ = P'=ι βσ (q(%)). EVen though βσ(q(ni)) ≤ λ∕σ2 (the
data-independent bound, Proposition 8), the sensitivity of their sum is not λ∕σ2 . The reason is that
the (global) sensitivity is defined as the maximal difference in the function’s output between two
neighboring datasets D and D0 . Transitioning from D to D0 may change one teacher’s output on all
student queries.
In contrast with the global sensitivity of Bσ that may be quite high—particularly for the second
step of the Confident GNMax aggregator—its smooth sensitivity can be extremely small. Towards
computing a smooth sensitivity bound on Bσ, we prove the following theorem which defines a
smooth sensitivity of the sum in terms of local sensitivities of its parts.
Theorem 24. Let f. D → R for 1 ≤ i ≤ ', F(D)，P'=ι fi(D) and β > 0. Then
`
SS(D)，maxe-ed ∙	max	LJSfi(D0),
d≥0	~D0Tist(D,D0)≤d	f
i=1
■ Cl	. 1 1	1	T-I / ∖ ，CT 〜C ∕TΛ∕∖	1	1	. 1 1	1	■ . ■	/- C / 1~∖!∖
is a β-smooth bound on F(∙) fLSfi(D0) are upper bounds on the local Sensitivity of fi(D0).
32
Published as a conference paper at ICLR 2018
Proof. We need to argue that SS(∙) is β-smooth, i.e., SS(DI) ≤ eβ ∙ SS(D2) for any neighbor-
ing D1, D2 ∈ D, and it is an upper bound on the local sensitivity of F(D1), i.e., SS(D1) ≥
|F(D1) - F(D2)|.
Smoothness follows from the observation that
T^½	/ TΛ∖ -	T^½	/ TΛ∖
max LSfi (D) ≤ max LSfi (D)
D:dist(Di ,D)≤d Z	Ddist(D2,D)≤d+l Z
for all neighboring datasets D1 and D2 (by the triangle inequality over distances). Then
` SS(DI) = maxe-βd ∙ 1	d≥0 i=1	max	LSfi (D), D:dist(Di ,D)≤d	Z
` ≤ max e-βd ∙ d≥0 i=1	T^½	/ TΛ∖ max	LSfi (D) Ddist(D2,D)≤d+1
= max e-β(d0-1) d0≥1	` max	LJSf. (D) Dd DGist(D2,D)≤d0
≤ eβ ∙ SS(D2)
as needed for β-smoothness.
The fact that SS(∙) is an upper bound on the local sensitivity of F(∙) is implied by the following:
`	`
|F(D1) - F(D2)| = Xfi(D1)-Xfi(D2)
i=1	i=1
`
≤ X|fi(D1) -fi(D2)|
i=1
`
≤ X LSfi(D1)
i=1
≤ SS(D1),
which concludes the proof.
Applying Theorem 24 allows us to compute a smooth sensitivity of the sum more efficiently than
summing up smooth sensitivities of its parts. Results below rely on this strategy.
Empirical results. Table 2 revisits the privacy bounds in Table 1. For all data-dependent pri-
vacy claims of the Confident GNMax aggregator we report parameters for their smooth sensitivity
analysis and results of applying the GNSS mechanism for their release.
Consider the first row of the table. The MNIST dataset was partitioned among 250 teachers, each
getting 200 training examples. After the teachers were individually trained, the student selected at
random 640 unlabeled examples, and submitted them to the Confident GNMax aggregator with the
threshold of 200, and noise parameters σ1 = 150 and σ2 = 40. The expected number of answered
examples (those that passed the first step of Algorithm 1) is 283, and the expected Renyi differential
privacy is ε = 1.18 at order λ = 14. This translates (via Theorem 5) to (2.00, 10-5)-differential
privacy, where 2.00 is the expectation of the privacy parameter ε.
These costs are data-dependent and they cannot be released without further sanitization, which we
handle by adding Gaussian noise scaled by the smooth sensitivity of ε (the GNSS mechanism,
Definition 22). At β = 0.0329 the expected value of smooth sensitivity is 0.0618. We choose
σSS = 6.23, which incurs, according to Theorem 23, an additional (data-independent) (14, 0.52)-
RDP cost. Applying (β, σSS)-GNSS where σSS = 6.23, we may publish differentially private
estimate of the total privacy cost that consists of a fixed part—the cost of applying Confident GN-
Max and GNSS—and random noise. The fixed part is 2.52 = 1.18 + 0.52 - ln(10-5)/14, and the
noise is normally distributed with mean 0 and standard deviation σss ∙ 0.0618 = 0.385. We note
33
Published as a conference paper at ICLR 2018
Dataset	Confident GNMaX parameters	DP		Smooth Sensitivity				Sanitized DP E [ε] ± noise
		E[ε]	δ	λ	β	E [SSβ]	σss	
MNIST	T=200,σι=150,σ2=40	2.00	10-5	14	.0329	.0618	6.23	2.52 ± 0.385
SVHN	T=300,σι=200,σ2=40	4.96	10-6	7.5	.0533	.0717	4.88	5.45 ± 0.350
Adult	T=300,σι=200,σ2=40	1.68	10-5	15.5	.0310	0.0332	7.92	2.09 ± 0.263
	T=1000,σι=500,σ2=100	2.07	10-8	20.5	.0205	.0128	11.9	2.29 ± 0.152
Glyph	Two-round interactive	0.837	10-8	50	.009	.00278	26.4	1.00 ± .081
					.008	.00088	38.7	
Table 2: Privacy-preserving reporting of privacy costs. The table augments Table 1 by including
smooth sensitivity analysis of the total privacy cost. The expectations are taken over the student’s
queries and outcomes of the first step of the Confident GNMax aggregator. Order λ, smooth sensitiv-
ity parameter β, σSS are parameters of the GNSS mechanism (Section B.5). The final column sums
up the data-dependent cost ε, the cost of applying GNSS (Theorem 23), and the standard deviation
of Gaussian noise calibrated to smooth sensitivity (the product of E [SSβ] and σSS).
that, in contrast with the standard additive noise, one cannot publish its standard deviation without
going through additional privacy analysis.
Some of these constants were optimally chosen (via grid search or analytically) given full view of
data, and thus provide a somewhat optimistic view of how this pipeline might perform in practice.
For example, σSS in Table 2 were selected to minimize the total privacy cost plus two standard
deviation of the noise.
The following rules of thumb may replace these laborious and privacy-revealing tuning procedures
in typical use cases. The privacy parameter δ must be less than the inverse of the number of training
examples. Giving a target ε, the order λ can be chosen so that log(1∕δ) ≈ (λ - 1)ε∕2, i.e., the cost
of the δ contribution in Theorem 5 be roughly half of the total. The β-smoothness parameter can be
set to 0.4∕λ, from which smooth sensitivity SSe Can be estimated. The final parameter σss can be
reasonably chosen between 2 ∙ ,(λ + 1)∕ε and 4 ∙ ,(λ + 1)∕ε (ensuring that the first, dominant
component, of the cost of the GNSS mechanism given by Theorem 23 is between ε∕16 and ε∕4).
34