Under review as a conference paper at ICLR 2018
Integrating Episodic Memory into a
Reinforcement Learning Agent using
Reservoir Sampling
Anonymous authors
Paper under double-blind review
Ab stract
Episodic memory is a psychology term which refers to the ability to recall specific
events from the past. We suggest one advantage of this particular type of memory
is the ability to easily assign credit to a specific state when remembered informa-
tion is found to be useful. Inspired by this idea, and the increasing popularity of
external memory mechanisms to handle long-term dependencies in deep learning
systems, we propose a novel algorithm which uses a reservoir sampling proce-
dure to maintain an external memory consisting of a fixed number of past states.
The algorithm allows a deep reinforcement learning agent to learn online to pref-
erentially remember those states which are found to be useful to recall later on.
Critically this method allows for efficient online computation of gradient estimates
with respect to the write process of the external memory. Thus unlike most prior
mechanisms for external memory it is feasible to use in an online reinforcement
learning setting.
Much of reinforcement learning (RL) theory is based on the assumption that the environment has the
Markov property, meaning that future states are independent of past states given the present state.
This implies the agent has all the information it needs to make an optimal decision at each time
and therefore has no need to remember the past. This is however not realistic in general, realistic
problems often require significant information from the past to make an informed decision in the
present, and there is often no obvious way to incorporate the relevant information into an expanded
present state. It is thus desirable to establish techniques for learning a representation of the relevant
details of the past (e.g. a memory, or learned state) to facilitate decision making in the present.
A popular approach to integrate information from the past into present decision making is to use
some variant of a recurrent neural network, possibly coupled to some form of external memory,
trained with backpropagation through time. This can work well for many tasks, but generally re-
quires backpropagating many steps into the past which is not practical in an online RL setting. In
purely recurrent architectures one way to make online training practical is to simply truncate gra-
dients after a fixed number of steps. In architectures which include some form of external memory
however it is not clear that this is a viable option as the intent of the external memory is generally to
capture long term dependencies which would be difficult for a recurrent architecture alone to han-
dle, especially when trained with truncated gradients. Truncating gradients to the external memory
would likely greatly hinder this capability.
In this work we explore a method for adding external memory to a reinforcement learning architec-
ture which can be efficiently trained online. We liken our method to the idea of episodic memory
from psychology. In this approach the information stored in memory is constrained to consist of
a finite set of past states experienced by the agent. In this work, by states we mean observations
explicitly provided by the environment. In general, states could be more abstract, such as the in-
ternal state of an RNN or predictions generated by something like the Horde architecture of Sutton
et al. (2011). By storing states explicitly we enforce that the information recorded also provides
the context in which it was recorded. We can therefore assign credit to the recorded state without
explicitly backpropagating through time between when the information proves useful and when it
was recorded. If a recorded state is found to be useful we train the agent to preferentially remember
similar states in the future.
1
Under review as a conference paper at ICLR 2018
In our approach the set of states in memory at a given time is drawn from a distribution over all
n-subsets (subsets of size n) of visited states, parameterized by a weight value assigned to each state
by a trained model. To allow us to draw from such a distribution without maintaining all visited
states in memory we introduce a reservoir sampling technique. Reservoir sampling refers to a class
of algorithms for sampling from a distribution over n-subsets of items from a larger set streamed one
item at a time. The goal is to ensure, through specific add and drop probabilities, that the n items in
the reservoir at each time-step correspond to a sample from the desired distribution over n-subsets
of all observed items. Two important examples which sample from different distributions are found
in Chao (1982) and Efraimidis & Spirakis (2006). In this work we will define our own distribution
and sampling procedure to suit our needs.
1	Related Work
Deep learning systems which make use of an external memory have received a lot of interest lately.
Two prototypical examples are found in Graves et al. (2014) and the follow-up Graves et al. (2016).
These systems use an LSTM controller attached to read and write heads of a fully differentiable
external memory and train the combined system to perform algorithmic tasks. Contrary to our
approach, training is done entirely by backpropagation through time. See also Zaremba & Sutskever
(2015), Joulin & Mikolov (2015), Sukhbaatar et al. (2015), Gulcehre et al. (2017) and Kaiser et al.
(2017) for more examples of deep learning systems with integrated external memory.
More directly related to the present work is the application of deep RL to non-markov tasks, in
particular Oh et al. (2016). They experiment with architectures using a combination of key-value
memory and a recurrent neural networks. The memory saves keys and values corresponding to the
last N observations for some integer N , thus it is inherently limited in temporal extent but does
not require any mechanism for information triage. They test on problems in the Minecraft domain
which could provide compelling testbeds for a potential follow-up to the present work. See also
Bakker et al. (2003), Wierstra et al. (2010), Zhang et al. (2016) and Hausknecht & Stone (2015) for
more examples of applying deep RL to non-markov tasks.
2	Architecture
Our model is based around an advantage actor critic architecture (Mnih et al., 2016) consisting of
separate value and policy networks. In addition we include an external memory M consisting of a
set of n past visited states (St0, .., Stn-1) with associated importance weights (wt0 , ..., wtn-1). The
query network q(St) outputs a vector of size equal to the state size with tanh activation. At each
time step a single item Sti is drawn from the memory to condition the policy according to:
n-1
Q(StiMt) = exp(hq(St)ISJ")/ Xexp(〈q(St)ISJ")	⑴
j=0
where τ is a positive learnable temperature parameter. The state, mt , selected from memory is given
as input to the policy network along with the current state, both of which condition the resulting
policy. Finally the write network takes the current state as input and outputs a single value with
sigmoid activation. This value is used to determine how likely the present state is to be written to
and subsequently retained in the memory according to the distribution in equation 7 which will be
throughly explained in section 3. An illustration of this architecture is shown in figure 1.
3	Algorithm
For the most part our model is trained using standard stochastic gradient descent on common RL
loss functions. The value network is trained by gradient descent on the squared one step temporal
different error δt2 where δt = rt+1 + V (St+1) - V (St), and the gradient is passed only through
V (St). The policy is trained using the advantage loss -δt log(π(at ISt, mt)) with gradients passed
only through π(atISt, mt). The query network is trained similarly on the loss -δt log(Q(mtISt))
with gradients passed only through Q(mtISt). We train online, performing one update per time-
step with no experience replay. The main innovation of this work is in the training method for the
2
Under review as a conference paper at ICLR 2018
Figure 1: Episodic memory architecture, each grey circle represents a neural network module. Input
state (S) is given separately to the query (q), write (w), value (V) and policy (π) networks at each
time step. The query network outputs a vector of size equal to the input state size which is used
(via equation 1) to choose a past state from the memory (m1 ,m2 or m3 in the above diagram) to
condition the policy. The write network assigns a weight to each new state determining how likely it
is to stay in memory. The policy network assigns probabilities to each action conditioned on current
state and recalled state. The value network estimates expected return (value) from the current state.
write network which is described in sections 3.1 and 3.2. There are two main desiderata we wish
to satisfy with the write network. First we want to use the weights w(St) generated by the network
in a reservoir sampling algorithm such that the probability of a particular state S^ being present in
memory at any given future time t > t is proportional to the associated weight w(S^). Second
we want to obtain estimates of the gradient of the return with respect to the weight of each item in
memory such that we can perform approximate gradient descent on the generated weights.
3.1	Gradient Estimate
For brevity, in this section we will use the notation Et[x] to denote E[x|S0, ..., St] i.e. the expecta-
tion conditioned on the entire history of state visitation up to time t. Similarly Pt(x) will represent
probability conditioned on the entire history of state visitation. All expectations and probabilities
are assumed to be with respect to the current policy, query and write network. Let A represent the
set of available actions and At the action selected at time t.
3.1.1	One- S tate Memory Case
To introduce the idea we first present our gradient estimation procedure for the case when our mem-
ory can store just one state, and thus there is no need to query. Here mt represents the state in
memory at time t and thus, in the one-state memory case, the state read from memory by the agent
at time t. Assume the stored memory is drawn from a distribution parameterized as follows by a set
of weights {wi|i ∈ {0, ..., t - 1}} associated with each state Si when the state is first visited:
Pt(mt = Si) = wi	Xwj	(2)
j=0
We can then write the expected return Rt = rt+1 + γrt+2 + ... as follows:
t-1
Et[Rt] = X Pt (mt = Sk) X ∏(a∣St,Sk )Et[Rt∣At = a]	⑶
k=0	a∈A
In order to perform gradient descent on the weights wi we wish to estimate the gradient of this
expectation value with respect to each weight. In particular we will derive an estimate of this gradient
using an actor critic method which is unbiased if the critic’s evaluation is correct. Additionally our
estimate will be non-zero only for the wi associated with the index i such that mt = Si . This
means if our weights wi are generated by a neural network, we will only have to propagate gradients
through the single stored state. This is crucial to allow our algorithm to run online, as otherwise we
3
Under review as a conference paper at ICLR 2018
would need to store every visited state to compute the gradient estimate.
d D「X- 1 _ XX d dPt(mt = Sk) X/JD D∖ 口「Dl/(____________1
Et [Rt] = / (	π π (a | St, Sk )Et [Rt IAt = a]
∂wi	∂wi
i	k=0	i	a∈A
l d X X X	X / ∣D	c dEt [Rt |At	= aP∖	小
+ Pt(mt	= Sk)〉,π(a∣St,	Sk)------------- (4)
∂wi
a∈A	i
We can rewrite this as:
∂1
∂Wi Et[Rt] = W Pt(mt = Si)
(a|St,Si)Et[Rt|At =a] -Et[Rt]
∂
+ γEt [∂WiEt+1[Rt+1]J (5)
See appendix A for a detailed derivation of this expression. We will use a policy gradient approach,
similar to REINFORCE (Williams, 1992), to estimate the this gradient using an estimator Gi,t such
that Et[P^≥t YlGi ^] ≈ dEWRt], thus the second term is estimated recursively on subsequent
time-steps. In the present work we will focus on the undiscounted episodic case with the start-state
value objective, for which it suffices to follow the first term in the above gradient expression for each
visited state. This is also true in the continuing case with an average-reward objective. See Sutton
et al. (2000) for further discussion of this distinction. Consider the gradient estimator:
if mt = Si
otherwise
(6)
which has expectation:
Et[Gi,t] = -1 Pt(mt = Si) X π(a∣St,Si)Et[rt+ι + γV(St+ι) - V(St)∣At = a]
wi	a∈A
≈ —Pt(mt = Si)	π(alSt, Si)(Et[rt+1 + YEt+1[Rt+1]|At = a] - Et[Rt])
wi	a∈A
=W Pt (mt = Si) (X π(a∣St,Si)Et[Rt∣At = a] - Et [Rt ])
Where the approximation is limited by the accuracy of our value function. In conventional policy
gradient subtracting the state value (e.g. using δt = rt+1 + γV(St+1) - V(St) instead of rt+1 +
γV(St+1)) is a means of variance reduction. Here it is critical to avoid computing gradients with
respect to the denominator of equation 2, which allows our algorithm to run online while computing
the gradient with respect to only the weight stored in memory.
Given these estimated gradients with respect to Wi We apply the chain rule to compute ∂Rt =
∂Rt ∂Wi ≈ P^≥t GijVwS, for each parameter θw of the write network. This gradient estimate is
used in a gradient descent procedure to emphasize retention of states which improve the return.
Gradient estimates are generated based on the stored values of Wi in memory but applied to the
parameters of the network at the present time. With online updating, this introduces a potential
multiple timescale issue which we conjecture will vanish in the limit of small learning rate, but
leave further investigation to future work.
There are a number of ways to extend the distribution defined in equation 2 to the case where
multiple elements of a set must be selected (see for example Efraimidis & Spirakis (2006)). We
will focus on a generalization which is less explored but which we will see in the following section
results in gradient estimates which are an elegant generalization of the single-state memory case.
4
Under review as a conference paper at ICLR 2018
3.1.2 Multiple-State Memory Case
In this section and those that follow we will routinely use the notation Zn where Z is a set and n an
integer to indicate the set of all n-subsets of Z. Note that (Z) = {0} and We adopt the convention
Q x = 1 thus P Q x = 1 which will be important in a few places in what follows.
x∈0	Z∈(Z) X∈Z
We Will introduce some notation to facilitate reasoning about sets of states. Let Tt = {t0 : 0 ≤ t0 ≤
t - 1} be the set of all time indices from 0 to t - 1. Let T ∈ (Tt) be a set of n indices chosen from
Tt where n is the memory size. Let ST be the set of states {S^ : t ∈ T}. Let Mt be the set of
states in memory at time t. Let Q(S^∣Sc^) be the probability of querying S^ given Mt = ST. The
probability for a particular set of states being contained in memory is defined to be the following:
Pt(Mt = ST) = Y Iwi	X Y Wi	⑺
i∈T	T T∈(Tt) i∈T
A straightforward extension of the derivation of the equation 5 shows that this choice results in a
gradient estimate which is an elegant extension of the one-state memory case. The derivation is
given in appendix B, the result for ∂wEt[Rt] is:
∂∂^Et[Rt]	= X	W Pt (Mt	= ST) (X Q(Sj |St )	X ∏(a∣St,Sj )Et[Rt∣At	= a]
wi	T∈((τt)3i)	wi	∖∈t	a∈A
∂
-Et[Rt] + γ"西Et+1[Rt+1]j	(8)
As in the single-state memory case we recursively handle the second term. To estimate the first term
we could choose the following estimator Gi,t :
C Jδt∕wi
Gi,t =	0
ifSi ∈Mt
otherwise
(9)
This estimator is unbiased under the assumption the critic is perfect, however it scales poorly in terms
of both variance and computation time as the memory size increases. This is because it requires
updating every state in memory regardless of whether it was queried, spreading credit assignment
and requiring compute time proportional to the product of the number of states in memory with the
number of parameters in the write network. Instead we will further approximate the second term
and perform an update only for the queried item. We rewrite the first term of equation 8 as follows:
W Pt (Mt 3 Si)Pt(mt=SiMt 3 Si)
aX∈A
π(aιSt, Sj )Et[Rt|At=a]—Et [Rt]
+ Pt(mt 6= Si|Mt 3 Si)
Pt(At
a|Mt 3 Si,mt 6=Si)Et[Rt|At
a] - Et [Rt]
))
≈ Wi PSmt =Si)
∏(a∣St, Sj)Et[Rt∣At
a] - Et [Rt ]
This approximation is accurate to the extent that our query network is able to accurately select
useful states. To see this, note that if querying a state when it’s in memory helps to generate a
better expected return a well trained query network should do it with high probability and hence
Pt(mt 6= Si|Mt 3 Si) will be low. On the other hand if querying a state in memory is unhelpful
P Pt(At = a|Mt 3 Si, mt 6= Si)Et[Rt|At = a] - Et[Rt] will generally be small. With this
a∈A
approximation the gradient estimate becomes identical to the one-state memory case:
if mt = Si
otherwise
(10)
5
Under review as a conference paper at ICLR 2018
While this justification is not rigorous, this approximation should significantly improve computa-
tional and sample efficiency, and is used in our experiments in section 4.
3.2 Reservoir Sampling Procedure
Algorithm 1 A reservoir sampling algorithm for drawing samples from equation 11			
1	Ω — Zeros(n+1)	1	function UPDATE(W,t)
2	Ω J Zeros(n)	2	ωJW
3	W J Zeros(n)	3	τJt
4	T J Zeros(n)	4	for 0 ≤ i ≤ n - 1 do _	：—	- - r	"T - r
5	: for time 0 ≤ t ≤ n - 1 do	5	Ω0 J Ω[i] + ω ∙ Ω[i]
6	:	Receive Wt	6	if i=n-1 then
7	:	W[t] J Wt	7	Ω00 J Ω[i + 1]
8	八-- T[t] J t	8	else _	. .	- -	r	T-	r
9	: end for	9	Ω00 J Ω[i + 1]+ ω ∙ Ω[i + 1]
10	: Apply equivalent random permutation to W and T	10 11	end if P J 1 _ Ω00Ω[i] ʃ j ɪ	Ω0Ω[i+1]
11	Ω[n] J 1	12	Swap ω with W [i] and T with T[i]
12	*T-	r Ω[n - 1] J 1		with probability P
13	: for n - 1 ≥ i ≥ 0 do	13	Ω[i] J Ω0
14	Ω[i] = W [i] ∙ Ω[i + 1]	14	end for
15	: end for	15	for n - 2 ≥ i ≥ 0 do -T - r	-1	-	-	r		-r	r
16	: for n - 2 ≥ i ≥ 0 do	16	Ω[i] = Ω[i + 1] + W[i] ∙ Ω[i + 1]
17	T - r	_1	-	-	r		-r	T-	r Ω[i] = Ω[i + 1] + W[i] ∙ Ω[i + 1]	17	end for
18	: end for	18	end function
19	: for all time t ≥ n do		
20	:	Receive Wt		
21	:	UPDATE(Wt,t)		
22	: end for		
In the previous section we derived a gradient estimator for our desired memory distribution. in
this section we introduce a method for sampling from this distribution online. Specifically we will
formulate a reservoir sampling algorithm for drawing a subset T of size n from a set of indices
T = {0, ..., t - 1} according to a distribution parameterized by a weight wi for each index i ∈ T .
Following equation 7 the probability for a given subset T is defined as follows:
P(T;T,n)= Y Wi	X Y Wi	(11)
i∈T	T T∈(T) i∈T
This distribution can be sampled from by selecting members sequentially for i ∈ {0, .., n - 1} with
the following conditional probabilities:
P(T[i]∣T[0: i - 1]; T,n) = WT[i]	X Y Wj,(n - i) X Y Wj	(12)
T∈(T-T-:i]) j∈τ	∖	T∈(T'T[-：i ])j∈τ	)
We abuse notation slightly and use T to refer to both an ordered vector and the set of its elements.
Lemma 1. Selecting elements Sequentially according to equation 12 will result in a vector T whose
elements correspond to a sample drawn from equation 11.
Proof. See appendix C.	□
We use lemma 1 to derive a reservoir sampling procedure which works online to update the reservoir
T at each time-step when a new index is added to T along with an associated weight. The result
6
Under review as a conference paper at ICLR 2018
is algorithm 1. At each time-step UPDATE moves through T starting from index 0 and chooses
whether to swap the item and weight at each index with the ones currently contained in a buffer
(τ and ω, initially set to contain the newly added item and associated weight). The probability
of swapping is chosen such that it corrects the conditional probability of the item at each index
(conditioned on the items before it) to compensate for the item in the buffer being added to the set of
possible items for that index. After doing this sequentially at each index the overall probability ofT
will be correct with the newly added item. Computing the necessary swap probabilities is nontrivial
in itself, however we show that it is possible to do this in O(n) time per time-step (where here n is
the memory size) by iteratively updating two vectors Ω and Ω.
Theorem 1. In algorithm 1 let t refer to the parameter of the call to UPDATE, Tt[i] refer to the
value ofT [i] when that call is made, and Tt = {t0 : 0 ≤ t0 ≤ t - 1} refer to the set of all time
indices from 0 to t - 1. ∀t ≥ n, 0 ≤ i ≤ n - 1:
_ , ʌ . .	. ʌ .	r	-	r、	ʌ ,	r —	、
P(Tt[i] = ti∣Tt[0 : i - 1] = [t0,…,ti-ι]) = P(ti|[t0,...,ti-i];Tt,n)
where [t0, ..., ti] is any arbitrary vector of unique elements ofTt.
Proof. See appendix D.	口
Corollary 1.1. At the call to UPDATE with parameter t, ∀t ≥ n, T ∈ (Tt):
.-人-- 人- -- ʌ. ~ , ʌ
P({Tt[0],…,Tt[n - 1]} = T) = P(T; Tt, n)
Proof. The proof follows from theorem 1 and lemma 1.	口
Corollary 1.1 tells us that for any given time-step algorithm 1 produces reservoirs which are a valid
sample from the distribution of equation 11. Note that algorithm 1 runs in O(n) time per time-step
where n is the size of the memory. We use this algorithm along with the weights generated by our
write network to manage updating the memory on each new state visitation.
The careful reader will notice that with the use of reservoir sampling equation 7 no longer holds
explicitly. This is because certain parts of the history may strongly correlate with certain states
being in memory at a particular time in the past, which under reservoir sampling will effect the
distribution of the present memory. We do not account for this in this work and simply assume for
the purpose of estimating gradients that the history of state visitation arises independently of the
history of memory content. Further analysis of the implications of this assumption, and whether it
can be weakened is left to future work.
4	Experiments and Results
We test our algorithm on a toy problem we call “the secret informant problem”. The problem is
intended to highlight the kinds of sharp, long-term dependencies that are often difficult for recurrent
models. The problem is such that in order to behave optimally an agent must remember specific,
initially unknown past states. An instance of the problem is shown in figure 2 and a detailed expla-
nation of the problem structure is available in the associated caption. In each training episode a new
random instance of the problem is created (with the chain length, number of actions and number of
decisions held fixed for a particular training run). This consists of randomly choosing the rewarding
action sequence, the location of the informative state for each decision, and the implied action and
decision state for each of the uninformative states.
All experiments with our episodic memory architecture are run for 3 repetitions with error bars
indicating standard error in the mean over these 3 runs. The architecture and hyper-parameters
used in each experiment are identical. We use the architecture from section 2 with 1 hidden layer
for the value, query and write networks and 2 hidden layers for policy. The value network and
query network outputs each use tanh activation, the policy uses softmax, and the write network uses
sigmoid. Each hidden layer has 10 units. We train using ordinary stochastic gradient descent with
learning rate 0.005 and gradient estimates generated as specified in section 3.
7
Under review as a conference paper at ICLR 2018
(a) An instance of the secret informant problem
1 0 0 1 0 0 1 0 0
(b) A state of the secret in-
formant problem
Figure 2: (a) shows an instance of the secret informant problem with 3 actions (A =
{up, f orward, down}) and 2 decision states. The start state uniquely contains all zeros. In the
final 2 states of an episode (which we call decision states), the agent must select the right sequence
of actions to receive a +1 reward, any other action sequence gives reward 0. At all other states the
forward action leads forward along the chain while other actions keep the agent in the same state.
The correct action (i.e. the one that leads towards the reward) at each decision state is indicated by a
one hot encoding on bits 1-3 of a certain informative state where the pattern in bits 6 and 7 matches
those of the decision state itself. Informative states are distinguished from uninformative states
by bits 4 and 5. To succeed the agent must learn to remember informative states with the pattern 10
in bits 4 and 5 and subsequently query them at the associated decision state. (b) shows a particular
state of the problem. The first 3 bits are action indicators, a one-hot encoding of the action the state
is suggesting should be taken at the associated decision state. The next two bits are informative and
uninformative indicators. If these bits are 01 the state is uninformative, meaning the decision state
and associated action it suggests are uniformly random and give no indications of a correct action.
If these bits are 10 then the state is informative and the associated action it suggests is on the path
toward the reward at the decision state it indicates. The next two bits are decision state identifiers,
in an informative state they indicate it provides information about the decision state with matching
identifier, in a decision state they serve as an identifier for that decision state. Thus, the correct thing
for an agent to do in each decision state is to take the action suggested by the informative state with
matching values of bits 6 and 7. The next bit is a decision state indicator and will be 1 if and only
if the state is a decision state. The final bit is a correct path indicator and indicates for a decision
state whether all the decisions made so far have been correct. This is necessary for our current sys-
tem because without it the final decision states all look the same and it is not possible to learn via
one step updates which decision is correct at the first decision state, in future work we would like to
investigate eliminating the need for information like this by using multi-step updates or eligibility
traces. The particular state shown above is informative, it indicates that the correct action for the
second decision state will be the up action. Versions of this problem can be created with variable
length (which we use to refer to the number of informative states plus the number of uninformative
states), number of actions, and number of decision states by modifying the above description in the
obvious way.
(a) Write weights
(b) Learning curves
Figure 3: Experiment with environment length 10, 1 decision and a 1 state memory. In the 1 state
memory case the query module is unnecessary. (a) shows average write weight assigned to informa-
tive states (•) and uninformative states (). (b) shows average return with episodic memory learner
(•) and recurrent baseline ().
8
Under review as a conference paper at ICLR 2018
(a) Write weights
(b) Learning curves
(c) Queried values
Figure 4: Experiment with environment length 10, 1 decision and a 3 state memory. In this case the
query module is necessarily. (a) shows average write weight assigned to informative states (•) and
uninformative states(). (b)shows average return with episodic memory learner (•) and recurrent
baseline (). (c) shows the value of several relevant query vector elements in the decision state: the
uninformative indicator (N), the informative indicator()and the first decision state identifier (•)
(unnecessary here since there is only one decision state, but included for uniformity).
(a) Write weights
(b) Learning curves
(c) First decision state
queried values
(d) Second decision state
queried values
Figure 5: Experiment with environment length 10, 2 decisions and a 3 state memory. (a) shows
average write weight assigned to informative states (•) and uninformative states (). (b) shows
average return with episodic memory learner (•) and recurrent baseline (). (c) shows the value of
several relevant query vector elements in the first decision state: the uninformative indicator (N),
the informative indicator(),the first decision state identifier (•), and the second decision state
identifier (H). (d) shows the same thing but for the query generated in the second decision state.
We also ran a recurrent baseline with full backpropagation through time which we found required
more fine-tuning to train with online updates. To make comparison as meaningful as possible the re-
current baseline used essentially the same architecture but with the entire memory module replaced
by a basic GRU (Cho et al., 2014) network of 10 units. Stochastic gradient descent alone was found
to give very poor results with the recurrent learner so RMSProp was used instead. Additionally to
obtain reasonable results with the recurrent learner, and avoid catastrophic looping behavior, it was
necessary to add a discount factor (γ = 0.9, applied only for learning purposes and not used in com-
puting the plotted return) as well as entropy regularization on the policy with a relatively low weight
of 0.0005. Perhaps surprisingly neither of these were necessary with the episodic memory based
system as it tended to proceed quickly through the chain without significant looping even without
discounting or entropy regularization. We tuned the learning rate and layer width (including the
number of recurrent units) for each of the 2 environments on which a recurrent baseline was trained
according to highest average performance over the last 100 episodes of a single training run of 25000
episodes for the 1 decision environment, and 50000 episodes for the 2 decision environment. In each
case learning rate was selected from {0.05 ∙ 2-x : X ∈ {0,..., 9}} and layer width was selected from
{5, 10, 15, 20}. For the 1 decision environment we ran the recurrent baseline for 3 repeats, for the 2
decision environment due to higher variance we ran it for 10 repeats. This baseline is not intended
to be representative of the performance of all possible architectures based on RNN variants trained
with backpropagation through time, but merely to provide context for the main experimental results
of this work.
Results and descriptions of the experiments are shown in figures 3, 4 and 5, in each plot the x-axis
shows number of training episodes. One additional experiment with twice the environment length
is shown in appendix E. Notice that in each case the episodic memory learner was is able to learn
9
Under review as a conference paper at ICLR 2018
a good query policy, drive the write weight of the uninformative states to near 0 while keeping the
value for informative states much larger, and obtain close to perfect average return. Comparing
figures 3 and 4 it appears that the addition of redundant memory size may accelerate initial learning
though it has little effect on the overall convergence time. Comparing figures 4 and 5 the number
of episodes to converge appears to roughly double from approximately 25, 000 to 50, 000 with the
addition of the extra decision state but the training remains quite stable.
5 Conclusion
We present a novel algorithm for integrating a form of external memory with trainable reading and
writing into a RL agent. The method depends on the observation that if we restrict the information
stored in memory to be a set of past visited states, the information recorded also provides the context
in which it was recorded. This means it is possible to assign credit to useful information without
needing to backpropagate through time to when it was recorded. To achieve this we devise a reser-
voir sampling technique which uses a sampling procedure we introduce to generate a distribution
over memory configurations for which we can derive gradient estimates. The whole algorithm is
O(n) in both the number of trainable parameters and the size of the memory. In particular neither
memory required nor computation time increase with history length, making it feasible to run in an
online RL setting. We show that the resulting algorithm is able to achieve good performance on a
toy problem we introduce designed to have sharp long-term dependencies which can be problematic
for recurrent models.
Acknowledgements
We acknowledge the support of the Natural Sciences and Engineering Council of Canada (NSERC).
References
Bram Bakker, Viktor Zhumatiy, Gabriel Gruener, and Jurgen Schmidhuber.	A robot that
reinforcement-learns to identify and memorize important previous observations. In International
Conference on Intelligent Robots and Systems, 2003.
Min-Te Chao. A general purpose unequal probability sampling plan. Biometrika, 69(3):653-656,
1982.
Kyunghyun Cho, Bart Van Merrienboer, Dzmitry Bahdanau, and Yoshua Bengio. On the properties
of neural machine translation: Encoder-decoder approaches. In Workshop on Syntax, Semantics
and Structure in Statistical Translation, 2014.
Pavlos S Efraimidis and Paul G Spirakis. Weighted random sampling with a reservoir. Information
Processing Letters, 97(5):181-185, 2006.
Alex Graves, Greg Wayne, and Ivo Danihelka. Neural turing machines. arXiv preprint
arXiv:1410.5401, 2014.
Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Danihelka, Agnieszka Grabska-
Barwinska, Sergio Gomez Colmenarejo, Edward Grefenstette, Tiago Ramalho, John Agapiou,
et al. Hybrid computing using a neural network with dynamic external memory. Nature, 538
(7626):471-476, 2016.
Caglar Gulcehre, Sarath Chandar, and Yoshua Bengio. Memory augmented neural networks with
wormhole connections. arXiv preprint arXiv:1701.08718, 2017.
Matthew Hausknecht and Peter Stone. Deep recurrent q-learning for partially observable mdps. In
AAAI Fall Symposium on Sequential Decision Making for Intelligent Agents, 2015.
Armand Joulin and Tomas Mikolov. Inferring algorithmic patterns with stack-augmented recurrent
nets. In Neural Information Processing Systems, 2015.
Eukasz Kaiser, Ofir Nachum, Aurko Roy, and Samy Bengio. Learning to remember rare events. In
International Conference on Representation Learning, 2017.
10
Under review as a conference paper at ICLR 2018
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. In International Conference on Machine Learning, 2016.
Junhyuk Oh, Valliappa Chockalingam, Satinder P. Singh, and Honglak Lee. Control of memory,
active perception, and action in minecraft. In International Conference on Machine Learning,
2016.
Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, and Rob Fergus. End-to-end memory networks.
In Neural Information Processing Systems, 2015.
Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient
methods for reinforcement learning with function approximation. In Neural Information Process-
ing Systems, 2000.
Richard S Sutton, Joseph Modayil, Michael Delp, Thomas Degris, Patrick M Pilarski, Adam White,
and Doina Precup. Horde: A scalable real-time architecture for learning knowledge from un-
supervised sensorimotor interaction. In International Conference on Autonomous Agents and
Multiagent Systems, 2011.
Daan Wierstra, Alexander Forster, Jan Peters, and Jurgen Schmidhuber. Recurrent policy gradients.
Logic Journal ofIGPL,18(5):620-634, 2010.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine learning, 8(3-4):229-256, 1992.
Wojciech Zaremba and Ilya Sutskever. Reinforcement learning neural turing machines. arXiv
preprint arXiv:1505.00521, 419, 2015.
Marvin Zhang, Sergey Levine, Zoe McCarthy, Chelsea Finn, and Pieter Abbeel. Policy learning with
continuous memory states for partially observed robotic control. In International Conference on
Robotics and Automation, 2016.
A Derivation of Expres sion for Gradient for One-State Memory
t-1
Et[Rt] = X Pt (mt = Sk) X ∏(a∣St,Sk )Et[Rt∣At = a]
k=0	a∈A
d d「DI_ X d dPt(mt = Sk) X/JD	___1
Et [Rt] = / , (	7∖	π π (a | St, Sk )Et [Rt IAt = a]
∂wi	∂wi
i	k=0	i	a∈A
+ Pt (mt = Sk)
X π(a∣St,Sk) dEt[RtIAt = a]
∂wi
a∈A	i
11
Under review as a conference paper at ICLR 2018
Working out the first term:
∂wi
廿 dpt(mt = Sk ) X ，Iq G、Pgld — 1
/	π	/ π (a ∖ St, Sk )Et[RtlAt = a]
z—∂	∂Wi	z—<
k=0	a∈A
=X d IOg(Pt;mt = Sk)) Pt (mt = Sk) X π(a∖St, Sk )Et[R.t∖At = a]
∂w	∂Wi
k=0	a∈A
t——1 内	t——1
=X ∂^7(log(wk) - log(XWj))Pt(mt = Sk) X π(a∖St,Sk)Et[R.t∖At = a]
k=0 OWi	j=0	a∈A
ɪ Pt (mt = Si) X π(a∖St, Si)Et[Rt∖At = a]
W	a∈A
t-1	1
-E P—：Pt(mt = Sk) E π(a∖St, Sk)Et[Rt∖At = a]
k=0 ɪ^j 3j	a∈A
=-Pt (mt = Si) X π(a∖St, Si)Et\Rt\At = a]-它----------Et[Rt]
Wi	a∈A	2 叼
=WPt (mt = Si) (X π(a∖St, Si)Et[Rt\At = a] - Et[Rt])
Working out the second term:
t-1
X Pt (mt = Sk) X π(a∖St,Sk)
k=0	α∈A
∂Et[Rt∖At = a]
∂wi
XPj	x x X / ∖q q "dEt[rt+1 IAt = a]	dEt[Rt+1∖At = a]∖
=⅛Pt(mt = Sk )∣1 π(a∖St,Sk)(—∂Wi—+Y------------∂w;------)
∂
=YEt --Et+1[Rt+1]
∂Wi
Where we are able to drop dEt[rt+WIAt=a] because the immediate reward is independent of the state
in memory once conditioned on the action. Thus we finally arrive at:
∂1
∂WEt [Rt] = WpPt(mt = Si)
(X
π(a∖St, Si)Et[Rt∖At = a] — Et[Rt]
∂
+YEt [西 Et+1[Rt+1]
B Derivation of Expression for Gradient for Multiple-State
Memory
Pt(Mt = ST) = ∩Wi / E ɪɪ Wi
i∈T / T∈(Tt) i∈T
Et[Rt] = X Pt(Mt = ST) X Q(Sj ∖St) X π(a∖St,Sj)Et [Rt∖At = a]
T∈(Tt)	j∈T	a∈A
*t[Rt]= X	广Pt(Mt = ST)
∂Wi	∖	∂Wi
U	^	/ rτ' ∖	∖	U
T∈(Tt)
EQ(Sj ∖Mt = ST) £ π(a∖St,Sj)Et[Rt∖At = a]
j∈T
a∈A
+ Pt (Mt = ST) E Q(SjIST) E π(a∖St,Sj)
j∈T
a∈A
∂Et[Rt∖At = a]
∂Wi
12
Under review as a conference paper at ICLR 2018
Working out the first term:
Σ
T∈(n)
∂Pt(Mt = ST)
∂wi
EQ(Sj| = ST) E π(α∣St, Sj)E∕R∕4 = a]
j∈T
α∈A
∂
E Pt (Mt = ST) d- (log(Pt(Mt = ST))E Q(Sj ∣St)
T∈(Tt)	-i
j∈T
E∏(a∣St,Sj )Et[Rt∣At = a]
α∈A
X	ɪ Pt (Mt = ST) X Q (Sj ∣St) X π(a∣St, Sj )Et[Rt∣At = a]
—i
T∈((Tt )3i)
j∈T
α∈A
-E Pt(Mt = ST)
T∈(n)
j
T∈((Tt)3i) j∈T∖{i}
fQ(S八 ST)
j∈T
∖
j
*（？）关亍	）
E π(α∣St,Sj)Et[Rt∣At = a]
α∈A
∖
Σ
T∈((Ti)3i)
Q ∏	-j
j∈T∖{i}
Σ II%
∖t∈*) j∈τ	)
Q(SjIST) E ∏(a∣St,Sj)Et[Rt∣At = a]
α∈A
-Et[Rt]
X	-Pt(Mt = ST)
—	—∙?
T∈((Tt )3i)
Q(Sj ∣St) E π(a∣St ,Sj)Et [Rt ∣ At = a]
α∈A
-Et [Rt]
Working out the second term:
E Pt(Mt = ST) E Q(Sj ∣St) E π(a∣St, Sj)
∂Et[Rt∣At = a]
T∈(n)
ʌ
j∈T
a∈A
∂wi
E Pt(Mt = ST)E Q(Sj ∣St) ∑π(a∣St,Sj)
∂Et[rt+ι∣At = a]
t∈(T)
j∈T
a∈A
∂wi
dEt[Rt+1∣ At = a]
+ Y
∂wi
π Γ ∂ π E 1
YEt	τ;—Et+1[Rt+1]
o—i
So all together we get:
7^-Et[Rt]=	X	ɪ Pt (Mt = ST) (X Q (Sj ∣St) X π(a∣St,Sj )Et[Rt∣At = a]
O—i	——	—i
τ∈((n)3i)	∖∈τ	a∈A
∂
-Et [Rt]	+ YEtkiEt+1[Rt+1]
13
Under review as a conference paper at ICLR 2018
C	Proof of Lemma 1
Lemma 1. Selecting elements sequentially according to equation 12 will result in a vector T whose
elements correspond to a sample drawn from equation 11.
Proof. Selecting elements sequentially according to equation 12 gives the following probability for
a given vector T.
.ʌ.	,八--一	,八--.^	,.	.八-	-.人-	-.
P(T) = P(T[0])P(T[1]∣T[0])…P(T[n - 1]∣T[0 : n - 2])
wT[0]	Σ ∏ Wj
τ∈(QTF)j∈T
n P Q Wj
T∈(T)j∈T
wT[i]	∑	∏ Wj
t∈(t 巴尸)j∈T
WT[n-1]
(n- 1)	Wj
τ∈(TnTi0]) j∈τ
T∈(
T\T[0:n-2]
1
)j∈T
Wj
1
∑ π
ɪɪw, n! £ IIWi
i∈T /	∖ t∈(T) i∈T
To complete the proof note that this is one of n! vectors with the same set of elements in different or-
der, each of which will have equal probability, hence to obtain the probability for the corresponding
Set We simply have to multiply by n! which gives Us equation 11.	□
D	Proof of theorem 1
We divide the proof into a series of lemmas. First we will define some notation to facilitate referenc-
ing algorithm 1 in the proofs below. Let Tt be the set {0, ..., t - 1} and Tt[0 : i - 1] be the value of
T[0 : i - 1] at the call to UPDATE with parameter t. Note that Tt [0 : -1] = 0. Let Ωt[i] and Ωt[i]
be the values of Ω[i] and Ω[i] respectively, at the call to UPDATE with parameter t. Let Pti be the
value ofP when it is set in loop index i of the loop starting at line 4 within the call to UPDATE with
parameter t. Let Ω01i and Ω[% be the values of Ω00 and Ω0 respectively after they are set within index
i of the loop starting at line 4 within the UPDATE call with parameter t. Let ωt,i and τt,i be the
values of ω and τ respectively at the beginning of loop index i of the loop starting at line 4 within
the call to UPDATE with parameter t. Note that ωt,i = Wτt,i .
Lemma 2.
(Tt+1 \ Tt+1[0 : i - 1]) = (Tt \ Tt[0 : i - 1]) ∪ {τt,i}
Proof. By design Tt+1 = Tt ∪ {τt,0}. Towards a proof by induction assume that after choosing
whether or not to swap Tt [i] we have:
(Tt+1 \ Tt+1[0 : i - 1]) = (Tt \ Tt[0 : i - 1]) ∪ {τt,i}
Then on the next iteration either we swap T[i] for τt,i or we don’t. Ifwe do swap then τt,i+1 = Tt[i]
and Tt+1 [i] = τt,i thus
(Tt+ι \ Tt+ι[0 : i]) = (Tt+ι \ Tt+ι[0 : i - 1]) \ {Tt+ι[i]}
=(Tt \ Tt[0: i - 1]) ∪{τt,i}∖{Tt+ι[i]}
=(Tt \ Tt[0: i - 1]) ∪ {τt,i} \ {τt,i}
=(Tt \ Tt[0 : i - 1])
=(Tt \ Tt[0: i]) ∪{T⅛]}
=(Tt \ Tt[0: i]) ∪{τt,i+ι}
14
Under review as a conference paper at ICLR 2018
On the other hand if we do not swap then τt,i+1 = τt,i and Tt+1 [i] = Tt[i] thus
(Tt+i \ Tt+ι[0 ： i]) =(Tt+i \ Tt+ι[0 ： i - 1]) \ {Tt+ι[i]}
=(Tt \ Tt[0: i- 1]) ∪{τt,i}∖{Tt+ι[i]}
=(Tt \ Tt[0: i- 1]) ∪{τt+ι,i}∖{Tt[i]}
=(Tt \ Tt[0: i]) ∪{τt,i+ι}
Which suffices to complete the inductive proof.	□
Lemma 3.
Σ ∏wE =E ∏w- w^∙ E ∏w⅛
t∈(t mψ∈τ	τ∈(m)t∈τ	τ∈(m-j t∈τ
Proof. The proof follows from noting that the first sum on the right side includes every term of
the left sum where T does not contain t, while the second term on the right side is equivalent to
summing over those T in the left sum that do contain t.	□
Lemma 4. For t ≥ n:
ɑ/i] = E ɪɪ w⅛, ∀i ∈ {0, ...,n}
T《Tt\Tt[0：i-i])e∈t
and also
Σ
≈	- r
Ω t[i]
τ∈(Ttn-巴T)
wtE, ∀i ∈ {0, ...
tE∈TE
n- 1}
Proof. Towards a proof by induction, assume the lemma holds at time t, a quick trace through
algorithm 1 will show that the update leading to Ωt+ι [i] for i ∈ {0,…，n — 1} is always:
_	- r	-	- r	"T - r
Ct+1[i] = Ct[i] + ωt,i ∙ ωt[i]
From here we can apply lemma 3, along with lemma 2 as follows to get the desired result:
_	- r	-	- r	-T - r
Ct+1[i] = Ct[i] + ωt,i ∙ ωt[i]
= E ∏w- ωt,i∙ E ∏w⅛
rjE∈(Tt\T^t[0：i-1]) t∈T
T∈(Tt∖Tt[0∖-i]) t∈T
=	wtE
T∈(τt+ι∖τt+ιmi-1]) t∈T
Now note that Ωt[n] = 1 for all t which is also the correct value thus We have completed the
induction step for the first half of the lemma.
On the other hand the update leading to Ωt+ι [i] is as follows:
A r -i rʌ r ■ . 11 .	A r - . 11
Ct+1[i] = Ct+i[i + 1]+ WTt+Ji] ∙ Ct+ι[i + 1]
As a second level of induction assume the lemma holds for Ωt+ι [i + 1] then applying lemma 3 we
get:
A r -i rʌ r ■ . 11 .	A r - . 11
Ct+i[i] = Ct+i[i + 1]+ WTt+ι[i] ∙ Ct+ι[i + 1]
E ∏w?+wTt+ι[i] ∙ E ∏w?
-1 ∖Tt + 1 [0:i]) e∈T	T∈(Tt+1 \Tt+ 1[0:i]) e∈T
n-i-1	n-i-2
Σ
WtE
T∈(τt+ι∖τt+ι[0t-1]) E∈T
n-i-1
15
Under review as a conference paper at ICLR 2018
t . 1	1	Γ∙ . < ∙	1 1	1 i~ ∙	1	. .t . ʃʌ	Γ	1 1	1	1'	11 >	< ∙	<	∙	1
As the base case for this second level of induction, note that Ωt+ι[n - 1] = 1 for all t which is also
the correct value, thus assuming Ωt+ι is correct we will also get the correct values for Ωt+ι. ThiS
completes the induction step for the lemma, it remains to prove the base case.
Note that Ω[n] and Ω[n - 1] each start at 1. The beginning of the algorithm before line 19 is then
intended to initialize all Ω and Ω values to have the correct value at time t = n, to see that this is the
case, first note ∀i ∈ {0, ..., n}:
n-1
ɑn[i] = Y wTnjj]
j=i
= Σ	∏w⅛
T∈(Tn∖Tn[0ji-1]) t∈T
And also, by induction on the trivial i = n - 1 case, ∀i ∈ {0, ..., n - 2}:
~
-T
Cn [i] = Cn [i + 1] + wr^,n ji] ∙ Cn [i + 1]
= X Y wt + WTn ji] ∙ X Y Wt
T∈ (Tn∖Tn [θ:i]ʌ t∈T	Tt ∈，7n\炉九[。：引、t∈T
T∈( n-i-1 )	T∈( n-i-2 )
=	Wtt
Tt∈(Tn∖Tn [0：i-1]) t∈T
Thus indeed the lemma holds at time n which serves as a base case for the rest of the proof. 口
Lemma 5.
Pt,i = 1 -
ʌ, ʌ _.. ʌ , . .
P(Ttji]|Tt+ij0:i-1];Tt+i,n)
P(Ttji]|Ttj0:i-1];Tt,n)
Proof. Substituting the definition from equation 12, along with the value assigned to Pt,i and sim-
plifying slightly what we wish to show is:
Σ
∙4⅛
∙4⅛
Ωt0iΩt[i]	TECt+NTt+n'i-^MTtW})
Wj
)j∈T	T∈(τt∖Tn
[0：i-1]) j∈Tt
Wj
~
Ωt,iΩt[i + 1]
Wj	Wj
TE(Tt+i\Tt+i[0：i-i])j∈T	T∈(Tt∖Tt[0j]) j∈T
Substituting in the values of Ωt[i] and Ωt+ι [i] from lemma 4 into the above formula, it will suffice
to apply lemma 3 and lemma 4 to additionally show:
_	.	-	- r	~
Ct,i = Ct[i] + ωt,i ∙ ωt[i]
= E ∏wt+W E ∏wt
[0：i-1]) tt∈Tt
-i
T∈(Tt∖Tt[0∖-i]) t∈T
Σ
Σ
Wj
~
T二(τt+ι∖Tt+ι[0t-1]) j∈T
( n-i )
and for 0 ≤ i ≤ n - 2
-，，	_	r	~	r
Ct,i = Ct[i +1] + ωt,i ∙ ωt[i + 1]
Wtt+
T∈(Tt∖Tt[0f) t∈T
X
"i ∙ Σ Πwt
T∈(Tt∖Tt 喝 i]) t∈T
T∈(Tt+ι∖(Tt+ι[0ιi-i]∪{Tt[i]})
Wj
) j∈Tt
The first is a simple application of lemma 2. The second follows from a similar observation in
addition to noting that Tt[i] has been removed from each term. For i = n - 1, Ω1% = 1 which
trivially obeys the same formula.	口
16
Under review as a conference paper at ICLR 2018
Lemma 6. Pt,i ≥ 0.
Proof.
Σ
Pt,i
.a .	.	-	....
Te(Tt+1∖(Tt+1[0M-1]∪{Tt[i]})
∏ wj	Σ ∏ Wj
~	.	八-	..	~
)j∈τ	Te(Tt∖Tt[0/-1]) j∈τ
Σ
T∈(τt+1∖Tt+1[0i-1]
(	n — i
∏ wj	Σ ∏ Wj
)j∈τ	cτ∈(τn∖-Tt-01i]) j∈τ
1 -
q
hence
Pt,i ≥ 0
wj	wj
T∈(τt+1∖Tt+1[0i-1]) j∈τ	τ^∈(τt∖T^tj0^i]) j∈rT?
^⇒
wj	wj
■人 . . -....
T∈(Tt + 1∖(Tt + 1[0M-1]∪{Tt[i]})
~	.八 ―	一	―
)j∈T T∈(τt∖T[0iTl)j∈T
∖T∈(Tt+1∖(Tt+1[0M-1]∪{Tt[i]})) j∈T
∏wj + wTt[i]
∙4⅛
∙4⅛
T∈(Tt+1∖(Tt+1[0: i-1]∪{Tt[i]})
wj
)j∈τ
wj
τ∈(τn'-⅞-01i)) j∈τ
(
X Y wj+ wTt[i]	X
∖T∈(Tt∖Tt[0M]) j∈T
T∈(Tt∖Tt[0 ： i]
∈∖ n-i-1
∏wj I
)j∈τ	T T∈(τt+1∖(Tt
-P,
；+1 [0：i-1]u{Tt[i]}))j∈T
n-i-1	)
wj
~
wj	wj
T∈(Tt+1∖(Tt+1[0M-1]∪{Tt[i]})) j∈T	τ∈(Tt∖Tt[0,]) j∈τ
≥ E	∏wj
~ .■人 . -....
T∈(Tt∖Ttpi]) j∈τ	T∈(Tt+1∖(Tt+1[0M-1]∪{Tt[i]})
wj
)j∈τ
(
X ∏ g ωt,i∙ X ∏
∖T∈(Tt∖Tt[0M]) t∈T	τ∈(Tt∖Tt[0f) t∈T
wt
wj
τ∈(TnT-01i]) j∈τ
X ∏ wt+ ωt,i ∙ X	∏	wj X ∏	wj
ιT∈(Tt∖Tt[0M]) t∈rT	τ∈(Tt∖Tt[0M])	t∈T T	τ∈(Tt∖Tt[0M]) j∈T
\T ∈ ( n-i-1 )	T ∈( n-i-2 )	T τ ∈( n-i )
(
X ∏ wj
"寸沔-0:]”如
≥	wj	wj
T∈(T ∖Tt[0ιi]) j∈T	τ∈(Tt∖Tt[0^i]) j∈T
T∈(Tt∖Tt[0∖-1]) T'∈(Tt∖Tt[0;-1]) j∈T
wj	wj
j∈τ
.3
≥
^⇒
^⇒
^⇒


/
Σ
Σ
Σ
2
Σ
q
≥	wj	wj
T∈(Tt∖Tt[0:3-1]) τo∈(Tt∖Tt[0M-1]) j∈T	j∈T0
It is relatively straightforward to show that the lemma holds in this last form. To do so note that
except for terms for which T and T0 are identical on the left (which are not possible on the right),
17
Under review as a conference paper at ICLR 2018
each term on the left of the inequality is also present on the right, however the number of repetitions
of each term varies between the left and right. In the left sum if a term includes m values shared
between T and T0, this term will appear (2n--11-m)) times. This is because We can choose n -
i - m non-duplicate values to be in T and place the rest in T0, each of these permutations will
correspond to a term in the sum. On the other hand in the left sum ifa term includes m values shared
between T and T0, this term will appear (2n--21-m)) times. Similarly this is because in this case
we can choose n - i - 1 - m non-duplicate values to be in T and place the rest in T0, each of these
permutations will correspond to a different term in the sum.
Since 2NN > N2-N1 , ∀N every term which is present on the right side is present on the left with
more repetitions and thus the left side must be greater than the right and the lemma holds. □
This lemma shows that P is indeed a valid probability, which means that swapping according to it
in algorithm 1 is admissible.
Theorem 1. ∀t ≥ n, 0 ≤ i ≤ n - 1:
_	, ʌ .	.	. ʌ .	r	-	r、	ʌ ,	r	—	、
P(Trt[i] = ti∣Tt[0 : i - 1] = [t0,…,ti-1]) = P(ti|[t0,...,ti-1];Tt,n)
where [t0, ..., ti] is an arbitrary vector of unique elements of Tt.
Proof. Let Ti,t be the value ofT right before making the swap decision on line 12 in loop index i of
the loop starting at line 4 within the call to UPDATE with parameter t. Towards a proof by induction
assume that at time index t directly prior to making the swap decision for T[i] at line 12 of UPDATE
we have for any arbitrary vector [t0, ..., ti-1] of unique elements ofTt:
_	, ʌ	.	.	. ʌ .	r	-	-	ʌ ,	r	—	、
P (Tit j ]=tj ∣Tt[0: j - 1] = [t0,...,tj-i])= P(tj ∣[to,...,tj-i]; Tt,n),
∀j s.t. i ≤ j ≤ n - 1
and for any arbitrary vector [t00, ..., t0i-1] of unique elements of Tt+1:
P(Ti,t j] = tj∣Tt+1[0 : j - 1] = [t0,…,tj-1]) = P(tj I[t0, ...,tj-1]; Tt+1,n),
∀j s.t. 0 ≤ j ≤ i - 1
That is all elements of T from 0 to i - 1 have the desired probability conditioned on proceeding ele-
ments of Tt+1 while all elements from i to n - 1 still have the desired probability when conditioned
on proceeding elements of T This is a natural inductive assumption given we have already made
our swap decisions up to but not including i and are just about to make our decision for i.
z-x ∙ i	. Ii	∙ι i	i	r∙ rr∖ l^c ■ -ι 1	Γ > I	> I 1	t rri l^c ■ -ι 1
Consider two mutually possible selections of Tt+1 [0 : i - 1] = [t00, ..., t0i-1] and Tt[0 : i - 1] =
[t0, ..., ti-1] and note that together these uniquely determine the value τt,i. Fixing these values, the
only possible way to end up with Tt+1[i] = t for t ∈ Tt \ {t°,…,tj-1} is to have Tt[i] = t and
then choose not to swap T[i] at time t. Thus, substituting in 1 - Pt,i using the expression for Pt,i
obtained in lemma 5 we get:
P (Tt+1[i] = £ITt+1[0: i- 1] = [t0,…,tj-1], Tt[0: i- 1] = [to,…,tj-1 D
P5(t∣[to, ...,ti-1];Tt,n)
Pm [to,…,ti-1]; Tt+1,n)
Pm [to,...,ti-1 ]; Tt,n)
P (H[t0,…,ti-1]; Tt+1,n)
18
Under review as a conference paper at ICLR 2018
lx,i .ι i 1 .	1	∙ . 1 rτι Γ ■!	.	.	∙ . <	； _ m ∖	/ r >	> T ∖ ι
On the other hand to end up with Tt+1 [i] = τt,i we may start with any t ∈ Tt \ ({t0, ..., tj-1}) and
then choose to swap T [i] at time t, in this case we get:
P(Tt+1[i] = τt,∕Tt+1 [0 : i - 1] = [t0,…,tj-1], Tt[0 : i - 1] = [t0,…,tj-1])
E	7⅛(t∣[to,...,tj-i]; Tt,n) I 1 -
t∈Tt∖{to,…,tj-ι}	\
P(R[t0,…,tj-i]; Tt+ι,n)
P(R[to,…,tj-i]; Tt, n)
E	T5(t∣[to,...,tj-i]; Tt,n) - P(R[t0,…,tj-i];Tt+ι,n)
t ∈Tt∖{t 0 ,…,t j -1)
1 - X	P(tK,…,tj-i]; Tt+ι,n)
t∈Tt∖{to,…,tj-ι)
1 -	X	P0[t0,…,tj-i];Tt+i ,n)
t∈Tt+ι∖({t0,...,tj-ι)∪{τt,i))
P(τt,i∣[t0,…,tj-i]；Tt+i,n)
EI ∕'	i' t	. Ii	∙ι i	i	∕' rri l^c ■ i 1	Γ > I	> I 1 t rri l^c ■ -ι 1
Thus for any fixed mutually possible selections of Tt+1 [0 : i - 1] = [t00, ..., t0j-1] and Tt[0 : i - 1] =
[to,..., tj-ι] for both τt,i and all other t ∈ Tt+ι \ {t0,…，tj-J We end UP with correct conditional
Probabilities for Tt+1 [i] assUming they are correct for Tt [i]. Now note that the resUlting Probabilities
are Ultimately indePendent of [t0, ..., tj-1], hence we woUld get the same valUes by conditioning
on [t00, ..., t0j-1] alone. ThUs if oUr indUctive assUmPtion holds we have for any arbitrary vector
[t00, ..., t0i-1] of UniqUe elements ofTt+1:
P(Ti+ι,t[j] = tj∣Tt+ι[0 : j - 1] = [t0,…,tj-i]) = P(tjI[t0, ...,tj-i]; Tt+ι,n),
∀j s.t. 0 ≤ j ≤ i
Which completes the inductive step. To prove the base case note that we initialize T such that
at time n it is filled with all available items in random order. It is easy to show that eqUation
12 implies that the probability of any ordering of a given set T is equal thus if the items in T
exactly fill T then ordering them at random will give the desired probabilities P(Tn[i]|Tt+1[0 :
i - 1]; Tt+1, n), ∀i s.t. 0 ≤ i ≤ n - 1, which gives us the base case to complete the inductive
proof.	□
19
Under review as a conference paper at ICLR 2018
E Length 20 Environment Experiment
Figure 6 shows the results of an experiment on the secret informant problem with environment
length 20. Comparing figures 5 and 6 the number of episodes to convergence increases from 50, 000
to around 80, 000 with a doubling of the environment length while training still remains stable.
(a) Write weights
(b) Learning curve (c) First decision queried (d) Second decision
values
queried values
Figure 6: Experiment with environment length 20, 2 decisions and a 3 state memory. (a) shows aver-
age write weight assigned to informative states (•) and uninformative states (). (b) shows average
return with episodic memory learner (•), we did not train a recurrent baseline for this problem. (c)
shows the value of several relevant query vector elements in the decision state. N corresponds to
the uninformative indicator, to the informative indicator, • to the first decision state identifier, H
to the second decision state identifier. (d) shows the same thing but for the query generated in the
second decision state.
20