Table 1: Communication and computation cost of the proposed CCESA algorithm, Secure Aggregation (SA)in (Bonawitz et al., 2017), federated averaging (FedAvg) in (McMahan et al., 2017). Detailed expressions andderivations are in Section 4 and Supplementary Materials, respectively.
Table 2: Running time (unit: ms) of SA (Bonawitz et al., 2017) and suggested CCESA5 ExperimentsHere we provide experimental results on the proposed CCESA algorithm. We compare CCESAand secure aggregation (SA) of (Bonawitz et al., 2017) in terms of time complexity (running time),reliability, and privacy. We tested both schemes on two real datasets, AT&T Laboratories Cambridgedatabase of faces (https://www.kaggle.com/kasikrit/att-database-of-faces) and CIFAR-10. For theAT&T face dataset containing images of 40 individuals, we considered a federated learning setupwhere each of n = 40 clients uses its own images for local training. All algorithms are implementedin python and PyTorch (Paszke et al., 2017). Codes will be made available to the public.
Table 3: Accuracy of the membership inference attack on local models trained on CIFAR-10. The scheme witha higher attack accuracy is more vulnerable to the inference attack. In order to maximize the uncertainty ofthe membership inference, the test set for the attack model consists of 5000 members (training data points)and 5000 non-members (evaluation data points). For the proposed CCESA, the attacker is no better than therandom guess with accuracy = 50%, showing the privacy-preserving ability of CCESA.
Table B.1: Precision of the membership inference attack on local models trained on CIFAR-10. The schemewith a higher attack precision is more vulnerable to the inference attack. For the proposed CCESA, the attackeris no better than the random guess with precision = 50%, showing the privacy-preserving ability of CCESA.
Table G.2: Connection probability p = p? in Fig. 3G.4 Running time experiment in Table 2We implemented CCESA algorithm in python. For symmetric authenticated encryption, we useAES-GCM with 128-bit keys in Crypto.Cipher package. For the pseudorandom generator,we use randint function (input: random seed, output: random integer in the field of size 216)in numpy.random package. For key agreement, we use Elliptic-Curve Diffie-Hellman over theNIST SP800-56 curve composed with a SHA-256 hash function. For secret sharing, we use standardt-out-of-n secret sharing (Shamir, 1979).
