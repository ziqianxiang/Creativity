Figure 1: Learning lifted representations from data. Red nodes represent problem-specific representa-tions, while green nodes are abstractions that can be transferred between tasks.
Figure 2:	The learned propositional operator for a Pick action describing picking B off C. In orderto execute the action, the hand must be empty (Symbol_10), C must be on the table and coveredby a block (Symbol_15), and B must be on top of a block and uncovered (SymbOl_6). Afterexecution, B is in the hand (SymbOl_3), C is on the table and clear (SymbOl_4), and the hand is full(symbol_1). We visualise the symbols by sampling from the propositional symbol, and randomlysampling the remaining independent state variables (since each symbol is a distribution over a subsetof state variables). The transparency is due to the averaging over the independent state variables.
Figure 3:	The learned lifted operator for a Pick action describing picking a block off another. Inorder to pick up block Y, it must be on block X which itself is on the table, and the hand must beempty. As a result, the hand is not empty, Y is now in the hand, and X is on the table and clear.
Figure 4: Our approach learns that, in order to open a particular door, the agent must be standingin front of a closed door (Symbol_37) at a particular location (PSymbol_24), and the door mustbe closed (Symbol_9). The effect of the skill is that the agent finds itself in front of an open door(Symbol_64) and the door is open (Symbol_65). type0 and type1 refer to the “agent” and“door” classes, while id is a fluent specifying the identity of the grounded door object, and is linkedto the problem-specific symbol underlined in red.
Figure 5: Path traced by the agent executing different options while solving the first task.
Figure 6: Results of learning and transferring high-level abstractions between tasks. We report themean and standard deviation averaged over 80 runs with random task orderings.
Figure 7: The number of learned action operators as a function of the number of blocks in thedomain. Since the propositional approach treats each block as its own, unique object, it must learnthe dynamics and interaction of each new block it encounters. For n blocks, this requires O(n2)operators. However, if we learn the object types and construct predicates based on these, then weneed at most 6 operators to represent the dynamics for any number of blocks.
Figure 8: The state of each object in the world at the start of the task. From left to right, the imagesrepresent the agent’s point of view, the four doors, the pickaxe, the chest, and the redstone and goldblocks. The inventory is not shown here.
Figure 9:	Pseudocode for a simple feature selection procedure.
Figure 10:	Pseudocode for constructing propositional PPDDL operators.
Figure 11:	Pseudocode for computing the effect distributions under an option for a given object.
Figure 12:	Pseudocode for lifting propositions to typed predicates.
Figure 13:	Our approach learns that, in order to open a chest, the agent must be standing in front ofa chest (Symbol_13), the chest must be closed (Symbol_4), the inventory must contain a clock(Symbol_55) and the agent must be standing at a certain location (PSymbol_8). The result is thatthe agent finds itself in front of an open chest (Symbol_5 8) and the chest is open (Symbol_5 9).
Figure 14:	Abstract operator that models the agent walking to the crafting table. In order to do so, theagent must be standing in the middle of a room (Symbol_4 6) at a particular location (PSymbol_0).
Figure 15:	Abstract operator that models the agent walking through a door. In order to do so, the agentmust be standing in front of an open door (Symbol_38) at a particular location (PSymbol_2 4),and the door must be open (Symbol_64). As a result, the agent finds itself in the middle of aroom(symbol_50) at a particular location (PSymbol_12).
Figure 16:	Abstract operator that models the agent attacking an object. In order to do so, the agentmust be standing in front of a gold block (Symbol_15) at a particular location (PSymbol_17),and the gold block must be whole (Symbol_2). As a result, the agent finds itself in front of adisintegrated block (Symbol_2 0), and the gold block is disintegrated (Symbol_19).
Figure 17:	In the above example, the partitioning procedure has generated two partitioned optionsfor breaking the gold block, where there should only be one. They are functionally equivalent, butbecause of the strange shadows on the left of the image patch and the subsequent PCA representation,the clustering algorithm has produced one extra partition.
Figure 18:	In this example, the partitioning has clustered noisy samples into an additional partitionof the ToggleDoor option. While the top row shows the case where the state of the door changesfrom open to closed, the bottom row is a relatively useless noisy operator. We will subsequently learna precondition and effect for this partition, but it likely will not be used by the planner.
Figure 19: In the left example, the classifier predicts that the gold block can be broken when the agentis in front of it. However, this is not quite correct, since the agent must also have the pickaxe to breakthe block. In this case, the issue occurs because the data only included states where the agent reachedthe gold block with the pickaxe. Therefore, the agent did not observe states where it was in front ofthe block without the pickaxe, and thus concluded that the pickaxe is irrelevant to the precondition.
Figure 20: Abstract operator that models the agent crafting a gold ingot. In order to do so, the agentmust be standing in front of the crafting table (Symbol_5 6) at a particular location (PSymbol_1),and must have the gold block in its inventory (SymbOl_2 9). As a result, the agent finds itself infront of the crafting table (SymbOl_11), and now has a gold ingot in its inventory (SymbOl_57).
