Under review as a conference paper at ICLR 2021
Measuring Visual Generalization in
Continuous Control from Pixels
Anonymous authors
Paper under double-blind review
Abstract
Self-supervised learning and data augmentation have significantly reduced
the performance gap between state and image-based reinforcement learn-
ing agents in continuous control tasks. However, it is still unclear whether
current techniques can face the variety of visual conditions required by
real-world environments. We propose a challenging benchmark that tests
agents’ visual generalization by adding graphical variety to existing contin-
uous control domains. Our empirical analysis shows that current methods
struggle to generalize across a diverse set of visual changes, and we exam-
ine the specific factors of variation that make these tasks difficult. We find
that data augmentation techniques outperform self-supervised learning ap-
proaches, and that more significant image transformations provide better
visual generalization.
1 Introduction
Reinforcement Learning has successfully learned to control complex physical systems when
presented with real-time sensor data (Gu et al., 2017) (Kalashnikov et al., 2018). However,
much of the field’s core algorithmic work happens in simulation (Lillicrap et al., 2015)
(Haarnoja et al., 2018a), where all of the environmental conditions are known. In the real
world, gaining access to precise sensory state information can be expensive or impossible.
Camera-based observations are a practical solution, but create a representation learning
problem in which important control information needs to be recovered from images of the
environment.
Significant progress has been made towards a solution to this challenge using auxiliary loss
functions (Yarats et al., 2019) (Zhang et al., 2020) (Srinivas et al., 2020) and data augmen-
tation (Laskin et al., 2020) (Kostrikov et al., 2020). These strategies often match or exceed
the performance of state-based approaches in simulated benchmarks. However, current con-
tinuous control environments include very little visual diversity. If existing techniques are
going to be successful in the real world, they will need to operate in a variety of visual con-
ditions. Small differences in lighting, camera position, or the surrounding environment can
dramatically alter the raw pixel values presented to an agent, without affecting the under-
lying state. Ideally, agents would learn representations that are invariant to task-irrelevant
visual changes.
In this paper, we investigate the extent to which current methods meet these requirements.
We propose a challenging benchmark to measure agents’ ability to generalize across a diverse
set of visual conditions, including changes in camera position, lighting, color, and scenery,
by extending the graphical variety of existing continuous control domains. Our benchmark
provides a platform for examining the visual generalization challenge that image-based con-
trol systems may face in the real world while preserving the advantages of simulation-based
training. We evaluate several recent approaches and find that while they can adapt to
subtle changes in camera position and lighting, they struggle to generalize across the full
range of visual conditions and are particularly distracted by changes in texture and scenery.
A comparison across multiple control domains shows that data augmentation significantly
outperforms other approaches, and that visual generalization benefits from more complex,
color-altering image transformations.
1
Under review as a conference paper at ICLR 2021
2 Background
Reinforcement Learning: We deal with the Partially Observed Markov Decision Process
(POMDP) setting defined by a tuple (S, O, φ, A, R, T, γ). S is the set of states, which are
usually low-dimensional representations of all the environment information needed to choose
an appropriate action. In contrast, O is typically a higher-dimensional observation space
that is visible to the agent. R is the reward function S x A → R, T is the function
representing transition probabilities S x S → [0, 1]. φ is the emittion function S → O that
determines how the observations in O are generated by the true states in S. A is the set of
available actions that can be taken at each state; in the continuous control setting we focus
on in this paper, A is a bounded subset of Rn , where n is the dimension of the action space.
An agent is defined by a stochastic policy π that maps observations to a distribution over
actions in A. The goal of Reinforcement Learning (RL) is to find a policy that maximizes
the discounted sum of rewards over trajectories of experience τ , collected from a POMDP
t=∞
M, denoted ηM(π): ηM(π) = E [	γtR(st, at)], where γ ∈ [0, 1) is a discount factor that
T 〜∏ / /
t=0
determines the agent’s emphasis on long-term rewards.
Continuous Control: Many of the challenging benchmarks and applications of RL involve
continuous action spaces. These include classic problems like Cartpole, Mountain Car and
Inverted Pendulum (Moore, 1990) (Barto et al., 1990). However, recent work in Deep RL
has focused on a collection of 3D locomotion tasks in which a robot is rewarded for a specific
type of movement in a physics simulator. At each timestep, the state is a vector representing
key information about the robot’s current position and motion (e.g. the location, rotation
or velocity of joints and limbs). The action space is a continuous subset of Rn , where each
element controls some aspect of the robot’s movement (e.g. the torque of a joint motor).
There have been several standardized implementations of these environments (Schulman
et al., 2015) (Brockman et al., 2016). This paper will use modified versions of those provided
in the DeepMind Control Suite (DMC) (Tassa et al., 2018), built using the MuJoCo physics
simulator (Todorov et al., 2012).
Soft Actor Critic: Soft Actor Critic (SAC) (Haarnoja et al., 2018a) is an off-policy actor-
critic method that achieves impressive performance on many continuous control tasks. For
each training step, a SAC agent collects experience from the environment by sampling from
a high-entropy policy (a 〜 ∏θ (o)) Paramaterized by a neural network with weights θ. It then
adds experience to a large buffer D in the form of a tuple (o, a, r, o0)1 . SAC samples a batch
of previous experience from the buffer, and updates the actor to encourage higher-value
actions, as determined by the critic network (Qφ(o, a)):
Lactor = - E	minQφ,i(o, ɑ) - α log ∏ (a∣o)) ,a 〜∏ (o)	(1)
o 〜D [i=1,2
The critic networks are updated by minimizing the mean squared error of their predictions
relative to a bootstrapped estimate of the action-value function:
Lcritic =	E I Qφ(o, a) - (r + γ(min Qφ0,i(o0, a0) - α log∏θ(GloO))) ) ,α 〜∏θ(o0)
(o,a,r,o0)〜D ∖	i=1,2	)
(2)
The log πθ terms are a maximum-entropy component that encourages exploration subject to
a parameter α, which can either be fixed or learned by gradient descent to approach a target
entropy level (Haarnoja et al., 2018b). The min operation makes use of two critic networks
that are trained separately, and helps to reduce overestimation bias (Fujimoto et al., 2018).
φ0 refers to target networks, which are moving averages of the critic networks’ weights and
help to stabilize learning - a common trick in Deep RL (Lillicrap et al., 2015) (Mnih et al.,
2015).
Generalization in Reinforcement Learning: Consider a set of POMDPs M =
{(S0, φ0, O0,A0, R0, T0,γ0), ..., (Sn, φn, On,An, Rn, Tn,γn)}. Given access to one or several
training tasks Mtrain 〜M, we would like to learn a policy that can generalize to the entire
1 We leave out the terminal boolean d common to most implementations both for notational
simplicity and because many of the DMC tasks reset after a fixed amount of time.
2
Under review as a conference paper at ICLR 2021
set. This is analogous to the way we train supervised models to generalize across an entire
distribution despite only having labels for a finite number of inputs. In supervised learn-
ing, we would partition our labeled data into training and testing sets, and measure the
difference in our model’s performance between them. We can create Mtrain and Mtest in a
similar way (Zhang et al., 2018a). This paper focuses on the zero-shot generalization setting
(|Mtrain | = 1), and will normalize by the training return in an effort to compare the general-
ization of policies with different baseline levels of performance. A policy’s generalization er-
rθr, EG(n), is defined as: EG(n) ≡ (ηMtrain (n) - |^^ PiMtestI 〃M test,Mn)) / 5必小*(n)).
3	A Benchmark for Measuring Visual Generalization in
Continuous Control from Pixels
3.1	Continuous Control From Pixels
While SAC performs well on many of the DMC tasks, it has access to state information
that would be difficult to replicate in the context of real-world robotics (O = S). Ideally, we
could learn a policy from imperfect or high-dimensional observations. This had led to a more
challenging benchmark where the same set of tasks are learned from image renderings of
the environment. Many successful approaches build around the addition of a convolutional
encoder to the SAC agent architecture. The encoder attempts to process a stack of consec-
utive frames into a low-dimensional representation that is then treated as a surrogate state
vector for the actor and critic(s). However, the RL setting’s sparse gradient signal makes it
difficult to train a high-capacity encoder with a limited number of samples, and baseline im-
plementations typically fail to make progress (Tassa et al., 2018). Several recent works have
addressed this problem by adding additional objectives to the encoder’s gradient update.
SAC+AE adds an image reconstruction term that trains a decoder network to recover the
original image from the encoder’s compressed representation, as in a standard autoencoder
(Yarats et al., 2019). CURL uses a contrastive loss (Srinivas et al., 2020) that encourages
similar representations across random crops of its input images. DBC uses a bisimulation
metric to discard observation information that isn’t relevant to control (Zhang et al., 2020).
All three result in performance at or near the levels of state-based SAC and experiments
show that the representation learned by the encoder recovers key state information.
Data Augmentation in Deep RL: Another recent line of work applies standard data
augmentations from image processing to the training loops of RL algorithms. This simple
technique can outperform more complicated approaches like SAC+AE and CURL. There
are some subtleties in both the types of data augmentations that are used and how they
are applied within the training update. RAD (Laskin et al., 2020) renders the environment
at a higher resolution and randomly crops each observation as it sampled from the replay
buffer. Data Regularized Q-Learning (DrQ) (Kostrikov et al., 2020) is a similar approach
that includes the option to augment the o0 images separately within each timestep in hopes
of computing a lower-variance target for the critic updates. Instead of upscaling, DrQ pads
each image by replicating border pixels before randomly cropping back to the original size.
Data Regularized Actor-Critic (DrAC) (Raileanu et al., 2020) more explicitly regularizes
the outputs of the actor and critic networks to be invariant under each augmentation. It
also attempts to learn which transformations to apply automatically; experiments in all
of these works show this to be a surprisingly high-stakes problem, as many augmentation
choices have little to no effect on learning (cf. Laskin et al. (2020) Figure 2a, Kostrikov
et al. (2020) Appendix E Figure 6, and Appendix A.3.3). The search finds random crop to
be the most helpful in many of the Procgen benchmark games (Cobbe et al., 2019a) and
shows that it is a strong default even when outperformed by other methods. Most of the
successful augmentations aside from Random Crop are color-based transformations. These
include Network Randomization (NR) (Lee et al., 2019) - which uses randomly initialized
convolutional layers to create visually distinct filters of the same image - and Color Jitter
(CJ), which shuffles the color palette.
Instead of benchmarking NR, DrQ and RAD separately, we implement a custom version of
Pixel SAC that lets us combine aspects of all three algorithms. The overall structure is sim-
ilar to the originals: we use a large convolutional encoder that is only updated by the critic’s
gradients and copy many of the baselines’ hyperparameters for the sake of comparison. Data
3
Under review as a conference paper at ICLR 2021
Figure 1: Example
“Walker, Walk” visual
seeds. The random
aesthetic changes gen-
erated by DMCR al-
low for significant vi-
sual diversity. φ0 uses
the default DMC as-
sets.
augmentation is applied in a way that is most similar to RAD (Laskin et al., 2020). We
introduce a new hyperparameter β ∈ [0, 1] which controls how we mix the augmented and
original batches for the actor and critic updates. β = 1 uses augmented data only; β = 0
uses the original. We set β = .9. This setup looks to alleviate the need to perform test
time augmentation, even when the augmentation significantly alters the image, as in (Lee
et al., 2019) (see more analysis in Appendix A.3.1). In addition, we encourage the output
of the encoder, eξ to be invariant to our augmentation pipeline z , by adding an explicit
regularization term to the encoder loss:
Lencoder = Lcritic + λ E [υeξ(O) ― eξ(Z(O)) || ]	(3)
o〜D
We set λ = 1e-5, and only let gradients flow through the eθ (z(o)) pass, for stability. Ap-
pendix A.3.2 discusses this idea in more detail.
After a comparison (Appendix A.3.3), we settle on the pad/crop transformation from DrQ
(Kostrikov et al., 2020) as our primary augmentation. We will refer to this algorithm as
SAC+AUG. Any other transformations that are used will be added to the acronym in results
and figures. For example, SAC+AUG that applies Color Jitter before the DrQ crop will be
denoted SAC+CJ+AUG.
3.2	Observational Overfitting and Visual Generalization
While algorithms like CURL, SAC+AE and DrQ can learn successful policies from pixels, we
are interested in measuring the extent to which they overfit to the visual conditions of their
training environments. Observational overfitting occurs when an agent becomes dependent
on features that are spuriously correlated with high reward (Song et al., 2019). Visual
generalization is succinctly described as low EG across a set of POMDPs that varies primarily
(or even exclusively) in φ. We aim to evaluate this by creating a set of environments that vary
only in their appearance, meaning that any generalization error is the result of overfitting
to visual features that are not relevant to the task.
3.3	Expanding the Visual Diversity of DMC Tasks
Towards this goal, we introduce a modified version of the DeepMind Control Suite with an
emphasis on visual diversity. Environments are given a new “visual seed”, which significantly
modifies the graphical appearance of the MuJoCo renderings while leaving the transition
dynamics untouched. This allows the same sequence of states to be rendered in millions
of distinct ways (see Figure 9). When initialized, our environments make a sequence of
pseudo-random graphical choices, deterministically seeded by the visual seed, k, resulting
in a unique appearance φk :
1.	Floor. The floor’s pattern is sampled from a game design pack that includes hundreds
of rock, grass, soil, sand, ice and concrete textures.
2.	Background. The background is sampled from a collection of natural landscape photos.
3.	Body Color. The color of the robot’s body is sampled from the full RGB space. If
there is another MuJoCo body in the scene (e.g., the glowing target location in “Reacher,
Reach”), it is given a second random color.
4.	Camera and Lighting. The camera’s position and rotation are sampled uniformly
within a relatively small range that varies across each domain. Lighting position is
chosen similarly, along with other properties like ambience and diffusion. The limits of
these distributions were determined by generating a large number of seeds across each
domain and ensuring that there were sufficient variations without hiding important task
information.
4
Under review as a conference paper at ICLR 2021
These simple alterations are enough to create an enormous amount of variety. Figure 1 shows
a sample of 10 seeds in the “Walker, Walk” task, and Appendix A.5 contains many more
examples. We also allow each type of adjustment to be toggled on or off independently,
and deterministic seeding makes it easy to train or evaluate multiple agents in the same
environments. Importantly, we decouple the visual seed from the random seed that is
already present in DMC tasks, determining the robot’s initial position. During training,
each reset generates a new starting position, as usual. We re-brand the original random
seed as the “dynamics seed” for clarity.
The initial release includes 10 of the DMC domains for a total of 24 tasks. A full list of
the randomized elements that are relevant to each domain is provided in Table 5. We will
refer to this version of DMC with expanded graphics as “DeepMind Control Remastered”
(DMCR).
4	Experimental Results and Analysis
We evaluate several recent works in pixel-based continuous control on DMC Remastered.
The experimental results are organized as follows: in Section 4.1, we test the baselines’
performance on the more complicated graphics assets of DMCR under the classic setup of
a single training and testing seed. In Section 4.2, we evaluate each method’s ability to
generalize to the entire distribution of levels. In Section 4.3, we test each factor of variation
in isolation to get an understanding of the specific visual characteristics current methods
struggle with the most. Then in Section 4.4, we highlight the advantages of data augmenta-
tion methods and investigate the performance of more powerful image transformations like
Color Jitter and Network Randomization.
4.1	Training Pixel-based Agents on Complex Graphics Textures
We first look at whether agents can be successfully trained from scratch inside environments
with DMCR’s more distracting visuals, including changes in lighting and camera position.
We train CURL, SAC+AE, and SAC+AUG on the original DMC visuals (φ0) and three
representative samples from the DMCR version of “Walker, Walk” - one of the more dif-
ficult tasks in the benchmark. The CURL and SAC+AE runs use their authors’ original
implementations, while SAC+AUG is a mix of data augmentation methods, as discussed
in Section 3.1. Results are shown in Figure 2. SAC+AE and CURL perform well across
each visual seed, but SAC+AUG collapses early in training in one environment. Follow-
ing this, we collect data using the original DrQ implementation and notice a similar effect.
We investigate this issue further by comparing the performance of SAC+AUG and CURL
in the original environment against more than 60 visual seeds from the DMCR version of
“Ball in Cup, Catch.” Results (shown in the bottom right of Figure 2) suggest that DMCR
environment visuals are slightly more difficult than the high contrast default appearance of
DMC.
4.2	Generalizing to the Full φ Distribution
Next, we measure the ability of agents trained in one environment to adapt to the full vi-
sual diversity of the DMCR benchmark. We train CURL, SAC+AE, and SAC+AUG agents
in six tasks, using the original (φ0) visuals. The pixel-based MuJoCo literature makes an
important distinction between ‘training steps’ and ‘environment steps.’ A training step is
defined by the agent taking an action in the environment and storing the resulting experi-
ence in its replay buffer. The simulator repeats the action several times before returning
the next observation; this ‘frame skip’ or ‘action repeat’ hyperparameter creates a discrep-
ancy between the training step count and the total number of environment timesteps. Our
experiments use the settings listed in Table 3 (see Appendix). After training, the agent is
evaluated over 100 dynamics seeds in its original training environment and tested in 3 dy-
namics seeds across 100 different visual seeds from DMCR. Table 1 reports the mean return
over each set, as well as the normalized generalization error. The results show that these
methods do not learn features capable of generalizing across significant visual changes.
5
Under review as a conference paper at ICLR 2021
6985
400
350
300
250
150
MO
50
O
CURL
50∞0 IOOOOO 150000 2∞0∞ 2500∞ 3∞0∞
Env1ιt>n mβnt Steps
OrQ
O
DMCv.
50∞0 IOOOOO 150000 2∞0∞ 2500∞ 3∞0∞
Env1ιt>n mβnt Steps
SAC+AE
600
500
400
300
200
IOO
50∞0 l∞0∞ 1500∞ 2∞0∞ 2500∞ 3∞0∞
Env1ιt>n mβnt Steps
10∞
8∞
600
«0
200
0.
DMC
Benchmark
Agent
SAC+AUG
CURL
DMCR
40000 60000 80000 IOOOOO 1200∞ 14∞00 160000
EnviranmentSteps
O

O
O
Figure 2: Pixel SAC variants trained on 4 different visual seeds from the DMCR version of “Walker,
Walk”. Final performance is relatively consistent, though the pure data augmentation methods are
prone to occasional collapses early in training that are difficult to recover from. We also provide a
comparison of the DMC and DMCR versions of ”Ball in Cup, Catch” (in bottom right).
Method:	SAC+AE	CURL	SAC+AUG
Metrics:	Train	Test	EG	Train	Test	EG	Train	Test	EG
Walker, Walk	643.6	25.0	96.1%	622.7	25.3	95.9%	919.3	28.0	97.0%
Cheetah, Run	387.9	4.2	98.9%	202.3	2.4	98.8%	712.8	19.8	97.2%
Hopper, Stand	631.8	1.6	99.8%	425.5	1.9	99.5%	878.1	3.3	99.6%
Finger, Spin	622.1	0.1	100.0%	731.3	1.6	99.8%	916.7	7.4	99.2%
Ball in Cup, Catch	647.0	99.2	84.6%	815.6	106.3	87.0%	934.5	103.0	89.0%
Cartpole, Balance	942.8	212.3	77.5%	885.7	233.3	73.7%	987.4	218.8	77.8%
Table 1: Training and Testing returns across 6 tasks. Training scores are averaged over 100
random initializations with no visual changes. Testing scores use 3 random initializations
on 100 visual seeds. EG indicates the agent’s decline in performance relative to it’s training
environment. Results are averaged over five runs.
4.3	Identifying the Most Difficult Factors of Variation
While generalizing to the entire distribution of visuals is a desirable goal, the high level of
difficulty can make it hard to differentiate between algorithms and measure gradual progress.
It would be helpful to know the specific factors of variation that are most challenging.
We investigate this by allowing each category of visual changes to be toggled on or off
independently. Each agent is re-evaluated over 100 visual seeds, each with 3 dynamics
seeds, across 7 variations of the core environment. Results for all 6 tasks are shown in Table
2. In addition to the CURL, SAC+AE and SAC+AUG agents from Section 4.2, we test
the impact of Color Jitter and Network Randomization augmentations. SAC+AUG has the
highest returns across every task, adding more evidence to recent findings (Laskin et al.,
2020) (Kalashnikov et al., 2018) that simple augmentation techniques can outperform the
more complicated auxiliary losses of SAC+AE and CURL. We find that all methods adapt
well to changes in lighting conditions. Aside from SAC+AE, many agents can also handle
the camera shifts and rotations. This may be because SAC+AE is the only method that does
not involve a random crop, which can have a similar effect to subtle camera translations.
SAC+NR+AUG and SAC+CJ+AUG are capable of ignoring changes in floor texture, and
identifying the agent as it shifts color. The large improvement in generalization between
SAC+AUG and and it’s heavier-augmentation variants is investigated further in Section
4.4.
6
Under review as a conference paper at ICLR 2021
None
Light Camera Body
Floor Background All

None Light Camera Body Color Floor Background All
SAC+AE	647.0	610.5	489.9	334.5	105.3	107.5	99.2
q03
,puC
ni lla
CURL	822.5	707.0	766.9	342.3	169.4	106.5	109.2
SAC+AUG	934.5	918.9	873.4	261.0	147.1	118.6	103.0
SAC+CJ+AUG	955.6	954.9	889.6	928.2	949.3	509.4	322.1
SAC+NR+AUG 948.5	947.8	864.9	937.6	932.6	582.3	411.2
SAC+AE	643.6	538.0	145.9	316.9	31.7	53.8	25.0
CURL	622.7	472.8	532.6-	231.7	25.8	46.3	25.3
SAC+AUG	919.3	830.1	518.3-	550.7	31.1	106.2	28.0
SAC+CJ+AUG	925.1	905.4	459.6	852.6	535.3	240.3	71.9
622.1	615.7	76.4	347.4	8.1	38.8	0.1
W≡Λ1
,rekla
SAC+AE
CURL	731.3	716.9	521.1	433.7	29.6	53.6	1.6
SAC+AUG	916.7	873.2	441.7-	525.3	470.3	98.1	7.4
SAC+CJ+AUG	798.5	796.4	388.8	760.6	795.7	274.6	82.8
SAC+NR+AUG79776788.0	420.6	779.5	7955	332.4	15477
SAC+AE	387.9	252.9	36.4	252.6	65.8	75.9	4.2
CURL	202.3	142.6	-15779	109.3	18.5	32.1	2.4
SAC+AUG	712.7	321.8	-25973	471.3	127.9	310.6	19.8
SAC+CJ+AUG	669.2	406.3	278.9	620.6	144.3	359.7	47.4
SAC+AE	942.8	810.8	^^37772	492.6	313.8	254.2	212.3
CURL	885.7	789.9	-83177	521.2	403.9	261.4	233.3
SAC+AUG	987.4	963.0	878.1	655.2	565.1	422.2	218.8
SAC+CJ+AUG	984.2	920.9	-87675	865.5	978.3	457.1	358.6
SAC+NR+AUG	946.0	859.8	-85576	860.9	923.2	462.5	377.4
SAC+AE	631.8	616.4	77	260.4	6.3	1.4	1.6
CURL	425.5	311.9	202.7.4-	72.1	12.4	4.7	1.9
SAC+AUG	878.1	764.9	-19572	403.4	46.0	39.5	3.3
SAC+CJ+AUG	848.3	778.6	18872	693.4	144.5	50.5	1.8
,hateehC ,eloptraC
PUDaS
,reppo

UnH Uou-DlDa
Table 2: Return of pixel-based SAC variants in 6 tasks from DMCR. Agents are trained on
the default visuals (“None”), and evaluated in versions of the environment where one aspect
of the scene (“Light”, “Floor”, . . . ) is randomly adjusted. Testing lasts for 300 episodes
across 100 distinct visual seeds. Reported scores are the average of five experiments.
4.4	Analyzing the Success of Data Augmentation Methods
To understand the effect that augmentations like Color Jitter and Network Randomization
have on generalization, we take a closer look at their performance relative to the default
DrQ crop. While SAC+AUG generalizes poorly to changes in floor texture in “Ball in Cup,
Catch” (Table 2) (EG = 84.2%), SAC+NR+AUG generalizes nearly perfectly (EG = 1.7%).
We speculate that the random color changes introduced by the NR augmentation reduce
the variance of the encoder’s state representation w.r.t changes in floor texture and color.
We can measure this by using DMCR to generate a batch of observations of the exact same
state, rendered with hundreds of different floor patterns. We pass these observations through
the encoder of trained SAC+AUG and SAC+NR+AUG agents, and collect the resulting
state representations. An encoder with perfect visual generalization would have zero output
variance, meaning it predicts the same state vector for every observation. We plot the
standard deviation of the agents’ representations in Figure 3. Because the encoder’s indices
have no meaningful order, we sort them by increasing variance. We average the results
of this experiment over five trained agents. Network Randomization learns a much more
consistent representation of this state than the DrQ crop augmentation alone. This process
is repeated for the SAC+CJ+AUG agents in “Cartpole, Balance” with very similar results.
Finally, we compare the spatial activation maps of SAC+AUG and SAC+CJ+AUG encoders
in “Ball in Cup, Catch”, and find that the CJ agent is much less distracted by a change
in floor texture. Results can be found in Appendix A.1 Figure 4. We argue that the
zero-shot generalization benchmark provided by DMCR is a better use-case for significant
7
Under review as a conference paper at ICLR 2021
Figure 3: Standard deviation of the encoder network’s output across renderings of the same
state with different floor textures and colors. Indices sorted by increasing variance. Results
averaged over five agents.
Cartpole, Balance
image alterations like CJ and NR than the typical single-environment setting, where simple
random crops have become the default (Laskin et al., 2020) (Kostrikov et al., 2020). By
randomizing color during training, they act as a kind of self-generated domain randomization
(Tobin et al., 2017) (Mehta et al., 2019) (OpenAI et al., 2019) and regularize learning by
increasing generalization across tasks at the expense of performance on the training task.
This is also supported by the success of NR and CJ on Procgen (Raileanu et al., 2020)
(Cobbe et al., 2019a), where success involves a similar amount of visual generalization.
5	Related Work
The generalization of Deep RL methods is an active area of research. Agents have been
shown to overfit to deterministic environment elements (Zhang et al., 2018a), despite efforts
to add stochasticity during evaluation (Zhang et al., 2018c) (Machado et al., 2017). Other
work focuses on generalization across environments with different transition dynamics, par-
ticularly in the continuous control setting (Packer et al., 2019) (Zhao et al., 2019) (James
et al., 2019) (Plappert et al., 2018), and recommends an evaluation protocol where agents’
generalization is assessed based on their performance in a held out set of tasks (Cobbe et al.,
2019b). This has led to the development of benchmarks with a large or infinite (procedurally
generated) number of similar environments (Nichol et al., 2018) (Juliani et al., 2019) (Juste-
sen et al., 2018). Notable among these is Procgen (Cobbe et al., 2019a) - a set of games
meant to imitate the strengths of the Atari 57 benchmark (Bellemare et al., 2013) but with
procedurally generated level layouts and visuals. Unlike the DMCR environments discussed
in this paper, tasks in the Procgen benchmark have different state spaces and transition
dynamics, and demand a more universal form of generalization; DMCR tests perception
and observational overfitting in isolation by keeping the underlying task fixed. Procgen’s
discrete action space also lends itself to a different family of algorithms than are often used
in the continuous control setting.
Other work has investigated visual generalization by adding spurious visual features to
popular RL environments (Gamrian & Goldberg, 2019) (Roy & Konidaris, 2020) (Sonar
et al., 2020). This paper, and the DMCR benchmark, is most directly inspired by (Zhang
et al., 2018b), as well as experiments in (Zhang et al., 2020) and (Yarats et al., 2019),
where the observations of similar continuous control tasks are processed to remove all of the
floor and background pixels and replace them with natural images or video. This is usually
accomplished by masking out the color of the background after the observation has been
rendered. DMCR takes this idea a step further, and directly changes the graphical assets
of the environment. This design gives it more control over the tasks’ appearance and opens
up the opportunity for changes in lighting and camera position. It is also the first time this
concept has been made into a reproducible benchmark for future research.
6	Conclusion
In this work, we propose a challenging benchmark for measuring the visual generalization
of continuous control agents by expanding the graphical variety of the DeepMind Control
Suite. Our experiments show that recent advances in representation learning in RL are not
enough to achieve a high level of performance across a wide range of conditions, but suggest
that data augmentation may be a promising path forward.
8
Under review as a conference paper at ICLR 2021
References
Andrew G. Barto, Richard S. Sutton, and Charles W. Anderson. Neuronlike Adaptive
Elements That Can Solve Difficult Learning Control Problems, pp. 81-93. IEEE Press,
1990. ISBN 0818620153.
Marc G Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The arcade learning
environment: An evaluation platform for general agents. Journal of Artificial Intelligence
Research, 47:253-279, 2013.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie
Tang, and Wojciech Zaremba. Openai gym, 2016.
Karl Cobbe, Christopher Hesse, Jacob Hilton, and John Schulman. Leveraging procedural
generation to benchmark reinforcement learning. arXiv preprint arXiv:1912.01588, 2019a.
Karl Cobbe, Oleg Klimov, Chris Hesse, Taehoon Kim, and John Schulman. Quantifying
generalization in reinforcement learning, 2019b.
Terrance Devries and Graham W. Taylor. Improved regularization of convolutional neural
networks with cutout. ArXiv, abs/1708.04552, 2017.
Scott Fujimoto, Herke van Hoof, and David Meger. Addressing function approximation
error in actor-critic methods, 2018.
Shani Gamrian and Yoav Goldberg. Transfer learning for related reinforcement learning
tasks via image-to-image translation, 2019.
S. Gu, E. Holly, T. Lillicrap, and S. Levine. Deep reinforcement learning for robotic ma-
nipulation with asynchronous off-policy updates. In 2017 IEEE International Conference
on Robotics and Automation (ICRA), pp. 3389-3396, 2017.
Tuomas Haarno ja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-
policy maximum entropy deep reinforcement learning with a stochastic actor, 2018a.
Tuomas Haarnoja, Aurick Zhou, Kristian Hartikainen, George Tucker, Sehoon Ha, Jie Tan,
Vikash Kumar, Henry Zhu, Abhishek Gupta, Pieter Abbeel, and Sergey Levine. Soft
actor-critic algorithms and applications, 2018b.
Stephen James, Zicong Ma, David Rovick Arrojo, and Andrew J. Davison. Rlbench: The
robot learning benchmark & learning environment, 2019.
Arthur Juliani, Ahmed Khalifa, Vincent-Pierre Berges, Jonathan Harper, Ervin Teng,
Hunter Henry, Adam Crespi, Julian Togelius, and Danny Lange. Obstacle tower: A
generalization challenge in vision, control, and planning, 2019.
Niels Justesen, Ruben Rodriguez Torrado, Philip Bontrager, Ahmed Khalifa, Julian To-
gelius, and Sebastian Risi. Illuminating generalization in deep reinforcement learning
through procedural level generation, 2018.
Dmitry Kalashnikov, Alex Irpan, Peter Pastor, Julian Ibarz, Alexander Herzog, Eric Jang,
Deirdre Quillen, Ethan Holly, Mrinal Kalakrishnan, Vincent Vanhoucke, and Sergey
Levine. Qt-opt: Scalable deep reinforcement learning for vision-based robotic manip-
ulation, 2018.
Ilya Kostrikov, Denis Yarats, and Rob Fergus. Image augmentation is all you need: Regu-
larizing deep reinforcement learning from pixels, 2020.
Michael Laskin, Kimin Lee, Adam Stooke, Lerrel Pinto, Pieter Abbeel, and Aravind Srinivas.
Reinforcement learning with augmented data, 2020.
Kimin Lee, Kibok Lee, Jinwoo Shin, and Honglak Lee. Network randomization: A simple
technique for generalization in deep reinforcement learning, 2019.
9
Under review as a conference paper at ICLR 2021
Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval
Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement
learning, 2015.
Zhichao Lu, Ian Whalen, V. Boddeti, Yashesh D. Dhebar, K. Deb, E. Goodman, and
W. Banzhaf. Nsga-net: neural architecture search using multi-objective genetic algo-
rithm. Proceedings of the Genetic and Evolutionary Computation Conference, 2019.
Marlos C. Machado, Marc G. Bellemare, Erik Talvitie, Joel Veness, Matthew Hausknecht,
and Michael Bowling. Revisiting the arcade learning environment: Evaluation protocols
and open problems for general agents, 2017.
Bhairav Mehta, Manfred Diaz, Florian Golemo, Christopher J. Pal, and Liam Paull. Active
domain randomization, 2019.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G
Bellemare, Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al.
Human-level control through deep reinforcement learning. nature, 518(7540):529-533,
2015.
A. W. Moore. Efficient memory-based learning for robot control. 1990.
Alex Nichol, Vicki Pfau, Christopher Hesse, Oleg Klimov, and John Schulman. Gotta learn
fast: A new benchmark for generalization in rl, 2018.
OpenAI, Ilge Akkaya, Marcin Andrychowicz, Maciek Chociej, Mateusz Litwin, Bob Mc-
Grew, Arthur Petron, Alex Paino, Matthias Plappert, Glenn Powell, Raphael Ribas,
Jonas Schneider, Nikolas Tezak, Jerry Tworek, Peter Welinder, Lilian Weng, Qiming
Yuan, Wo jciech Zaremba, and Lei Zhang. Solving rubik’s cube with a robot hand, 2019.
Charles Packer, Katelyn Gao, Jernej Kos, PhiliPP KrahenbuhL Vladlen Koltun, and DaWn
Song. Assessing generalization in deep reinforcement learning, 2019.
Hieu Pham, Melody Y. Guan, Barret Zoph, Quoc V. Le, and Jeff Dean. Efficient neural
architecture search via parameter sharing. In ICML, 2018.
Matthias Plappert, Marcin AndrychoWicz, Alex Ray, Bob McGreW, BoWen Baker, Glenn
PoWell, Jonas Schneider, Josh Tobin, Maciek Chociej, Peter Welinder, Vikash Kumar, and
Wo jciech Zaremba. Multi-goal reinforcement learning: Challenging robotics environments
and request for research, 2018.
Roberta Raileanu, Max Goldstein, Denis Yarats, Ilya Kostrikov, and Rob Fergus. Automatic
data augmentation for generalization in deep reinforcement learning, 2020.
Josh Roy and George Konidaris. Visual transfer for reinforcement learning via Wasserstein
domain confusion, 2020.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-
dimensional continuous control using generalized advantage estimation, 2015.
Anoopkumar Sonar, Vincent Pacelli, and Anirudha Ma jumdar. Invariant policy optimiza-
tion: ToWards stronger generalization in reinforcement learning, 2020.
Xingyou Song, Yiding Jiang, Stephen Tu, Yilun Du, and Behnam Neyshabur. Observational
overfitting in reinforcement learning, 2019.
Aravind Srinivas, Michael Laskin, and Pieter Abbeel. Curl: Contrastive unsupervised rep-
resentations for reinforcement learning, 2020.
Ryo Takahashi, Takashi Matsubara, and Kuniaki Uehara. Data augmentation using random
image cropping and patching for deep cnns. ArXiv, abs/1811.09030, 2018.
Yuval Tassa, Yotam Doron, Alistair Muldal, Tom Erez, Yazhe Li, Diego de Las Casas,
David Budden, Abbas Abdolmaleki, Josh Merel, AndreW Lefrancq, Timothy Lillicrap,
and Martin Riedmiller. Deepmind control suite, 2018.
10
Under review as a conference paper at ICLR 2021
Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, and Pieter Abbeel.
Domain randomization for transferring deep neural networks from simulation to the real
world, 2017.
E. Todorov, T. Erez, and Y. Tassa. Mujoco: A physics engine for model-based control. In
2012 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 5026-
5033, 2012.
Qizhe Xie, Zihang Dai, E. Hovy, Minh-Thang Luong, and Quoc V. Le. Unsupervised data
augmentation. ArXiv, abs/1904.12848, 2019.
Denis Yarats, Amy Zhang, Ilya Kostrikov, Brandon Amos, Joelle Pineau, and Rob Fergus.
Improving sample efficiency in model-free reinforcement learning from images, 2019.
Sergey Zagoruyko and Nikos Komodakis. Paying more attention to attention: Improving
the performance of convolutional neural networks via attention transfer, 2017.
Amy Zhang, Nicolas Ballas, and Joelle Pineau. A dissection of overfitting and generalization
in continuous reinforcement learning, 2018a.
Amy Zhang, Yuxin Wu, and Joelle Pineau. Natural environment benchmarks for reinforce-
ment learning, 2018b.
Amy Zhang, Rowan McAllister, Roberto Calandra, Yarin Gal, and Sergey Levine. Learning
invariant representations for reinforcement learning without reconstruction, 2020.
Chiyuan Zhang, Oriol Vinyals, Remi Munos, and Samy Bengio. A study on overfitting in
deep reinforcement learning, 2018c.
Hongyi Zhang, M. Cisse, Yann Dauphin, and David Lopez-Paz. mixup: Beyond empirical
risk minimization. ArXiv, abs/1710.09412, 2018d.
Chenyang Zhao, Olivier Sigaud, Freek Stulp, and Timothy M. Hospedales. Investigating
generalisation in continuous deep reinforcement learning, 2019.
Z. Zhong, L. Zheng, Guoliang Kang, Shaozi Li, and Y. Yang. Random erasing data aug-
mentation. In AAAI, 2020.
Barret Zoph and Quoc V. Le. Neural architecture search with reinforcement learning. ArXiv,
abs/1611.01578, 2017.
11
Under review as a conference paper at ICLR 2021
A Appendix
A.1 Spatial Attention Map Results
Using a method described in (Zagoruyko & Komodakis, 2017), we analyze the spatial atten-
tion maps of SAC+AUG and SAC+CJ+AUG encoder networks in “Ball in Cup, Catch.”
The activations of intermediate convolutional layers are resized and superimposed over the
original observation, giving us a sense of what the agent is paying attention to. In the
training environment, both agents are fixated on the path of the ball2 , as well as the closest
edge of the cup. However, SAC+AUG becomes distracted by a change in floor texture,
while the Color Jitter variant remains focused on the task. This provides some insight into
why SAC+CJ+AUG performs so much better than the default SAC+AUG when testing
over random floor changes (see Table 2).
SAC+AUG, Train Seed
SAC+AUG, Test Seed
SAC+CJ+AUG, Train Seed
SAC+CJ+AUG, Test Seed
Figure 4: Spatial attention maps of trained SAC+AUG and SAC+CJ+AUG agents. Com-
puted by taking the channel-wise average of encoder layer activations, and overlaying them
on the original observation. Green and red heatmap colors indicate high levels of atten-
tion. Both agents are trained with the default checkerboard floor, but the CJ agent is less
distracted by a change to a concrete texture.
A.2 Connecting to General Data Augmentation
Data augmentation synthesizes new training data from an available set of samples and pro-
vides a practical and common way to achieve better generalization. Basic data augmentation
strategies like random affine and pro jective transformations, and color jittering, have shown
significance in computer vision applications.
We can group existing data augmentation methods roughly into four groups: (1) spatial
or color transformation, (2) information deletion, (3) mixing up samples, and (4) meta-
augmentation.
•	(1) Spatial transformation and color distortion revise some channels of original image
information (Takahashi et al., 2018). This type helps the training set better simulate the
real-world.
•	(2) Information dropping type is more recent, including methods like cutout (Devries &
Taylor, 2017) and random erasing (Devries & Taylor, 2017; Zhong et al., 2020). This kind
tries to enforce the representation learning to focus on less sensitive signals, aiming for
more robust models.
•	(3) Mixup Zhang et al. (2018d) proposed the idea of interpolating two images and their
ground truth labels to augment the training data. Mixup and its variants aim for stable
model training and increased model robustness to adversarial examples.
•	(4) More recently, researchers have proposed methods to automatically search for
data augmentation policies with Reinforcement Learning (RL) or Evolutionary Algo-
rithms (Zoph & Le, 2017; Lu et al., 2019; Pham et al., 2018; Xie et al., 2019).
2The high-attention zones trailing the ball’s current position are a result of past timesteps in
the framestack that make up this observation, which are not pictured here.
12
Under review as a conference paper at ICLR 2021
Data augmentation investigated in this paper fall into the first first types. We foresee
great potentials for benchmarking the latter two groups to reinforcement learning and will
investigate shortly.
A.3 Augmented Soft Actor Critic: Details and Ablations
SAC+AUG is a custom implementation meant to combine several of the ideas from recent
work on data augmentation in RL. It uses the augmentation process described in RAD
(Laskin et al., 2020), which was chosen for its simplicity; observations are augmented as
they exit the replay buffer, and then used in a standard SAC learning update. We make
two additions: a β parameter to control how the augmented data is mixed into the update
batch, and a feature-matching loss term.
A.3.1 β parameter to alleviate test-time augmentation
Several methods apply their augmentations to observations during both training and eval-
uation. In Lee et al. (2019), the agent’s actions are an average across several different
augmentations of the current observation. CURL and RAD render the environment in a
higher resolution in order to efficiently perform their random crop augmentations, which
requires a center crop during testing. We experiment with skipping this step by mixing
un-augmented images back into the gradient update, controlled by β ∈ [0, 1]. However,
results in Figure 5 show this to be unimportant, at least over short training runs. Our main
experiments do not use test-time augmentation, and fix β = .9.
Figure 5: Testing a range of β values on “Walker, Walk” and “Cartpole, Balance.” We find
there to be little difference over short training runs.
A.3.2 State regularization ablation
The encoder’s goal is to distill the high-dimensional image observations into a low-
dimensional representation that, ideally, would recover the information present in the state-
based versions of these tasks. The observational changes caused by data augmentation have
no effect on the true state, so we would hope that they would be equally irrelevant to the
encoder’s representation. Therefore, we regularize the output of the encoder eξ to be invari-
ant to our augmentation pipeline z by adding adding a norm-based penalty that is mixed
into the encoder’s loss with a hyperparameter λ:
Lencoder =Lcritic + λ E ["eξ(O)- eξ(Z(O))||2]	⑷
o〜D
We compare several choices of λ in Figure 6.
A.3.3 Augmentation Comparison
We consider 11 augmentations to serve as the SAC+AUG default. Any randomness (e.g.
where to crop, or how far to move) is kept consistent between the same batch index in the
O and O0 tensors, meaning the O and O0 pairs that go into the critic update have identical
transformations. Observations consist of a stack of 3 frames. Random elements are also con-
13
Under review as a conference paper at ICLR 2021
Environment Steps
Figure 6: Testing a range of λ values on “Walker, Walk” with β = 1 averaged over 8 trials.
sistent across frames in this stack. This requires augmentations that can be deterministically
seeded.
A brief summary of each transformation:
1.	RAD imitates the augmentation in (Laskin et al., 2020) by resizing the 84x84 observation
to 100x100, and then randomly cropping back to the original size.
2.	Cutout Color selects a rectangular patch of the image to occlude with a random color
mask.
3.	DrQ imitates the augmentation in (Kostrikov et al., 2020). The image is padded by 4
pixels by replicating the colors at the border, and then randomly cropped back to 84x84.
Kostrikov et al. (2020)’s implementation uses a resampling method that turns each pixel
into a non-integer float. The need for deterministic seeding prevents us from using that
version, so we mimic the effect by adding small amounts of noise.
4.	DrQ No Noise uses the same 4 pixel pad/crop as DrQ, but without the additional
noise.
5.	Large DrQ pads and crops by 12 pixels instead of 4. Figure 8 uses Large DrQ for visual
effect.
6.	Large DrQ No Noise pads and crops by 12 pixels and does not add noise.
7.	Translate pads the image with 4 pixels of a random color, and then shifts the image
within this expanded area before center-cropping.
8.	Large Translate pads and shifts by 12 pixels instead of 4. Figure 8 uses Large Translate
for visual effect.
9.	Rotate rotates the image by one of {0°, 90°, 180°, 270°}
10.	Vertical Flip rotates a portion of each batch by 180°
11.	Window selects a rectangular viewing lens to see the original image and sets all other
pixels to 0.
An implementation of each transformation (many based on the RAD Procgen (Laskin
et al., 2020) experiments) is available in our code release. See Figure 8 for examples.
Figure 7 shows the learning curves of all 11 augmentations over the first 100k steps of the
“Walker, Walk” task, averaged over 5 trials with β = .9 and λ = .0015. In general, all
pad + crop augmentations perform well; the additional noise does not appear to be an
important detail. Rotations and flips slow down training significantly. Window and Cutout
Color also perform poorly. This is somewhat counter intuitive, as these transformations
hide information from the image much like Translate and DrQ. However, they tend to mask
14
Under review as a conference paper at ICLR 2021
Figure 7: All the minor augmentations tested for 5 trials on “Walker, Walk” with β = .9
and λ = .0015. Figure best viewed in color.
large portions of the input, and might be making the task too difficult. This is supported
by the reduced performance of DrQ and Translate when their crop factor is raised to even
12 pixels.
The limited sample size makes it difficult to distinguish between DrQ and Translate. We
decide to use DrQ based on the intuition that the color-replicating padding strategy will
fare better in DMCR, where it becomes more important to disregard the background.
Figure 8: Examples of our augmentation implementations. We categorize the transfor-
mations into two groups. “Alterations” make significant enough visual changes that the
result could conceivably be from another emission function. “Augmentations” reduce over-
fitting by occluding or moving the image. Our code release includes several augmentations
not mentioned in the main results, which were either less effective or too computationally
expensive to allow for multiple training runs.
Vertical Flip
Cutout Color
AUNmentationS
Translate
S
15
Under review as a conference paper at ICLR 2021
A.4 Additional Baseline Details and Hyperparameters
We use the publicly available implementations of CURL, SAC+AE, and DrQ. Frame skip
settings are chosen based on (Srinivas et al., 2020), and listed in Table 3 for convenience.
See Table 4 for a list of other hyperparameters.
	Training Steps	Frame Skip (Action Repeat)
Walker, Walk	^^250k	2
Cheetah, Run	^^250k	4
Hopper, Stand	^^50k	4
Finger, Spin	^100k	2
Ball in Cup, Catch	^75k	4
Cartpole, Balance	50k	8
Table 3: The frame skip settings used in all of our experiments, along with the length of
training runs used to compute the results in Tables 1 and 2.
Hyperparameter	Value
Frame Stack Image Size Replay Buffer Capacity Warmup Steps Batch Size Actor Critics Encoder Critic Learning Rate Actor Learning Rate Encoder Learning Rate Initial Alpha Target Entropy Alpha Learning Rate Action Log Std Range Encoder Tau Actor Tau Critic Tau Gamma Gradient Updates per Step Update Delay	1 84 100,000 1,000 256, 128 (SAC+AE) 2x ReLU(FC(1024)) → Tanh(FC(out)) 2x ReLU(FC(1024)) → FC(out) ReLU(Conv(32 filters, stride 2)) → 3x ReLU(Conv(32 fil- ters, stride 1)) → FC(50) → Tanh(LayerNorm(50)) 1e-3, 2e-4 (CURL Cheetah) 1e-3, 2e-4 (CURL Cheetah) 1e-3, 2e-4 (CURL Cheetah) .1 -|A| 1e-4 (-10, 2) .05 .01 .01 .99 1 2
Table 4: Hyperparameter settings used in all experiments.
A.5 DMC Remastered: Details and Examples
This initial version of DMC Remastered includes 10 of the DeepMind Control Suite domains
for a total of 24 tasks. There are 300+ floor textures and 100+ backgrounds. Early results
showed this to be more than enough of a challenge, but there is nothing to prevent (many)
more images from being added in the future.
Each environment’s visuals are generated by a sequence of pseudo-random decisions, deter-
ministically seeded by the ‘visual seed.’ The seeds are not guaranteed to generate the same
visuals across domains, although they are consistent across tasks within the same domain
(e.g. seed 11 in Fish, Swim will look identical to seed 11 of Fish, Upright). Real-valued
parameters like the camera’s x, y and z coordinates or the light diffusion are sampled uni-
formly from a preset range of values that varies by domain. These ranges were determined
by generating a large number of images and ensuring that there was sufficient variation
without making the task unsolvable by hiding important information. Several of these dis-
tributions are far more conservative than they could be, in an effort to make this a useful
16
Under review as a conference paper at ICLR 2021
t = 0	t=l	t = 2	t = 3	t = 4	t = 5
Figure 9: DMCR allows the same state trajectory to be rendered in millions of distinct
visual styles. Here we show 4 examples from the “Hopper, Hop” task. Our benchmark can
always recover the original DMC environment by setting the visual seed to 0.
benchmark for the abilities of current methods. In particular, the camera is restricted to
minor translations and tilts, although it would be interesting to see if agents could maintain
control across significantly different perspectives. Slight movements in camera position al-
ter the raw pixel values of the observations without meaningfully changing the information
within them. Moving the camera to new angles may create a more difficult challenge where
the agent needs to adapt to an entirely different observation. Not every factor of variation
is applicable to every domain; see Table 5 for a complete list. The 0 seed is reserved for the
default DMC assets, however, some tasks alter the default camera angle in an effort to fit
more of the background or floor in the frame.
The DMCR benchmark also includes a version of the environment that samples from a set of
visual seeds after every reset - a convenient way to train and evaluate few-shot generalizers.
Training seeds are sampled from a fixed range while testing seeds are drawn up to a large
positive constant. Initial experiments suggested that successful few-shot learning requires a
high-throughput training setup. We extended each of the baselines described in Sec 3.1 to
collect experience from 8 actors in parallel, each interacting with a different random seed.
We found that this was not enough to see positive results on all but the most straightforward
domains. Due to concerns over cost, we shifted our focus to the zero-shot setting. However,
the few-shot environment remains in the code release, and we hope it can be helpful in
future work.
17
Under review as a conference paper at ICLR 2021
	Camera	Light	Body Color	Target Color	Background	Floor	Reflectance
Cheetah	Yes	Yes	Yes	No	Yes	Yes	Yes
Walker	Yes	Yes	Yes	No	Yes	Yes	Limited Effect
Hopper	Yes	Yes	Yes	No	Yes	Yes	Limited Effect
Cartpole	Yes	Yes	Yes	No	Yes	Yes	No
Finger	Yes	Yes	Yes	No	Yes	Yes	No
Pendulum	Yes	Yes	Yes	No	Yes	Yes	No
Fish	Yes	Yes	Yes	Yes	No	Yes	No
Humanoid	Yes	Yes	Yes	No	No	Yes	No
Ball in Cup	Yes	Yes	Yes	No	Yes	Yes	No
Reacher	Yes	Yes	Yes	Yes	No1	Yes	No
Table 5: Factors of variation that are applicable to each environment. The cam-
era position, lighting conditions, body color and floor texture randomizations are always
available. Some tasks use birds-eye-view default cameras that do not show the background.
‘Reflectance’ adjusts the visibility of the agent’s reflection on the floor, a very small or
non-existent change in most environments that is included as a way to screen for extreme
overfitting. 1 Adding camera movement to the Reacher environment will show some of
the background (see Figure 12).
Figure 10: Example seeds from the DMCR version of “Cartpole, Swingup.
⅜22(Sθ)
缶736 (So)
07215(So)
18
Under review as a conference paper at ICLR 2021
Φ4848（≡θ）
⅛534β（Sθ）
⅛1030<≡θ）
@2 591 （SO）
由6916（SO）
强739（SO）
由793（SO）
Figure 11: Example seeds from the DMCR version of “Walker, Walk.
⅛（5θ）	^6544（5o）	由9105（SO）	由402 6（SO）	02Dθ（Sθ）
Figure 12: Example seeds from the DMCR version of “Reacher, Easy.” The birds-eye view
reduces visual complexity considerably. Note that the target position is given its own ran-
domized color.
19
Under review as a conference paper at ICLR 2021
Φθ(Sf))	@739：L(SO)	46689(SO)	弧力7(So)	⅛7159⅛θ)
Figure 13: Example seeds from the DMCR version of ”Finger, Spin.”
20