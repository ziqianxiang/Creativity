Under review as a conference paper at ICLR 2021
Global Attention Improves
Graph Networks Generalization
Anonymous authors
Paper under double-blind review
Ab stract
This paper advocates incorporating a Low-Rank Global Attention (LRGA) mod-
ule, a computation and memory efficient variant of the dot-product attention
(Vaswani et al., 2017), to Graph Neural Networks (GNNs) for improving their
generalization power.
To theoretically quantify the generalization properties granted by adding the
LRGA module to GNNs, we focus on a specific family of expressive GNNs and
show that augmenting it with LRGA provides algorithmic alignment to a powerful
graph isomorphism test, namely the 2-Folklore Weisfeiler-Lehman (2-FWL) algo-
rithm. In more detail we: (i) consider the recent Random Graph Neural Network
(RGNN) (Sato et al., 2020) framework and prove that it is universal in probability;
(ii) show that RGNN augmented with LRGA aligns with 2-FWL update step via
polynomial kernels; and (iii) bound the sample complexity of the kernel’s feature
map when learned with a randomly initialized two-layer MLP.
From a practical point of view, augmenting existing GNN layers with LRGA pro-
duces state of the art results in current GNN benchmarks. Lastly, we observe that
augmenting various GNN architectures with LRGA often closes the performance
gap between different models.
1	Introduction
In many domains, data can be represented as a graph, where entities interact, have meaningful
relations and a global structure. The need to be able to infer and gain a better understanding of such
data rises in many instances such as social networks, citations and collaborations, chemoinformatics,
epidemiology etc. In recent years, along with the major evolution of artificial neural networks, graph
learning has also gained a new powerful tool - graph neural networks (GNNs). Since first originated
(Gori et al., 2005; Scarselli et al., 2009) as recurrent algorithms, GNNs have become a central
interest and the main tool in graph learning.
Perhaps the most commonly used family of GNNs are message-passing neural networks (Gilmer
et al., 2017), built by aggregating messages from local neighborhoods at each layer. Since infor-
mation is only kept at the vertices and propagated via the edges, these models’ complexity scales
linearly with |V | + |E |, where |V | and |E | are the number of vertices and edges in the graph, re-
spectively. In a recent analysis of the expressive power of such models, (Xu et al., 2019a; Morris
et al., 2018) have shown that message-passing neural networks are at most as powerful as the first
Weisfeiler-Lehman (WL) test, also known as vertex coloring. The k-WL tests, are a hierarchy of
increasing power and complexity algorithms aimed at solving graph isomorphism. This bound on
the expressive power of GNNs led to the design of new architectures (Morris et al., 2018; Maron
et al., 2019a) mimicking higher orders of the k-WL family, resulting in more powerful, yet complex,
models that scale super-linearly in |V | + |E |, hindering their usage for larger graphs.
Although expressive power bounds on GNNs exist, empirically in many datasets, GNNs are able
to fit the train data well. This indicates that the expressive power of these models might not be
the main roadblock to a successful generalization. Therefore, we focus our efforts in this paper on
strengthening GNNs from a generalization point of view. Towards improving the generalization of
GNNs we propose the Low-Rank Global Attention (LRGA) module which can be augmented to
any GNN. Standard dot-product global attention modules (Vaswani et al., 2017) apply |V | × |V |
1
Under review as a conference paper at ICLR 2021
attention matrix to node data with O(|V |3) computational complexity making them impractical for
large graphs. To overcome this barrier, we define a κ-rank attention matrix, where κ is a parameter,
that requires O(κ∣V|) memory and can be applied in O(κ21V|) computational complexity.
To theoretically justify LRGA we focus on a GNN model family possessing maximal expressiveness
(i.e., universal) but vary in the generalization properties of the family members. (Murphy et al.,
2019; Loukas, 2019; Dasoulas et al., 2019; Loukas, 2020) showed that adding node identifiers to
GNNs improves their expressiveness, often making them universal. In this work, we prove that even
adding random features to the network’s input, as suggested in (Sato et al., 2020), a framework we
call Random Graph Neural Network (RGNN), GNN models are universal in probability.
The improved generalization properties of LRGA-augmented GNN models is then showcased for the
RGNN framework, where we show that augmenting it with LRGA algorithmically aligns with the
2-folklore WL (FWL) algorithm; 2-FWL is a strictly more powerful graph isomorphism algorithm
than vertex coloring (which bounds message passing GNNs). To do so, we adopt the notion of al-
gorithmic alignment introduced in (Xu et al., 2019b), stating that a neural network aligns with some
algorithm if it can simulate it with simple modules, resulting in provable improved generalization.
We opt to use monimials in the role of simple modules and prove the alignment using polynomial
kernels. Lastly, we bound the sample complexity of the model when learning the 2-FWL update
rule. Although our bound is exponential in the graph size, it nevertheless implies that RGNN aug-
mented with LRGA can provably learn the 2-FWL step, when training each module independently
with two-layer MLP.
We evaluate our model on a set of benchmark datasets including tasks of graph classification and
regression, node labeling and link prediction from (Dwivedi et al., 2020; Hu et al., 2020). LRGA
improves state of the art performance in most datasets, often with a significant margin. We further
perform ablation study in the random features framework to support our theoretical propositions.
2	Related Work
Attention mechanisms. The first work to use an attention mechanism in deep learning was (Bah-
danau et al., 2015) in the context of natural language processing. Ever since, attention has proven to
be a powerful module, even becoming the only component in the transformer architecture (Vaswani
et al., 2017). Intuitively, attention provides an adaptive importance metric for interactions between
pairs of elements, e.g., words in a sentence, pixels in an image or nodes in a graph. A natural draw-
back of classical attention models is the quadratic complexity generated by computing scores among
pairs. Methods to reduce the computation complexity were introduced by (Lee et al., 2018b) which
introduced the set-transformer and addressed the problem by inducing point methods used in sparse
Gaussian processes. Linearized versions of attention were suggested by (Shen et al., 2020) factor-
izing the attention matrix and normalizing separate components. Concurrently to the first version
of this paper (Anonymous, 2020), Katharopoulos et al. (2020) formulated a linearized attention for
sequential data.
Attention in graph neural networks. In the field of graph learning, most attention works (Li et al.,
2016; Velickovic et al., 2018; AbU-EI-Haija et al., 2018; Bresson & Laurent, 2017; Lee et al., 2018a)
restrict learning the attention scores to the local neighborhoods of the nodes in the graph. Motivated
by the fact that local aggregations cannot capture long range relations which may be important
when node homophily does not hold, global aggregation in graphs using node embeddings have
been suggested by (You et al., 2019; Pei et al., 2020). An alternative approach for going beyond the
local neighborhood aggregation utilizes diffusion methods: (Klicpera et al., 2019) use diffusion in
a pre-process to replace the adjacency with a sparsified weighted diffusion matrix, while (Zhuang
& Ma, 2018) add the diffusion matrix as an additional aggregation operator. LRGA allows global
weighted aggregations via embedding of the nodes in a low dimension (i.e., rank) space.
Generalization in graph neural networks. Although being a pillar stone of modern machine
learning, the generalization capabilities of NN are still not very well understood, e.g., see (Bartlett
et al., 2017; Golowich et al., 2019). Due to the irregular structure of graph data and the weight
sharing nature of GNN, investigating their generalizing capabilities poses an even greater challenge.
Despite the nonstandard setting, few works were able to construct generalization bounds for GNN
2
Under review as a conference paper at ICLR 2021
via VC dimension (Scarselli et al., 2018), uniform stability (Verma & Zhang, 2019), Rademacher
Complexity (Garg et al., 2020) and Neural Tangent Kernel (Du et al., 2019).
3	Preliminaries and notations
We denote a graph by G = (V, E, X) where V is the vertex set of size |V | = n, E is the edge
set, and adjacency A. X = (x1, . . . , xn)T represents the input vertex features. A vertex vi ∈ V
carries an input feature vector xi ∈ Rd0; in turn, Xl ∈ Rn×dl represents the output of the lth layer
of a neural network. We denote concatenation along the last dimension with brackets and stacking
along a new last dimension with double brackets, i.e., for W, Z ∈ Rn×d, [W, Z] ∈ Rn×2d and
[[W,Z]] ∈ Rn×d×2.
A common form of evaluating GNNs is by their ability to distinguish different graphs, described by
graph isomorphism which is an equivalence relation between graphs. The isomorphism type tensor
of a graph G is a tensor Y ∈ Rn2×diso which holds the isomorphism types of all pairs (i, j) ∈ [n]×[n].
Given a pair (i, j), which represents either an edge or a node of graph G, Yi,j summarizes all the
information this pair carries in graph G. More precisely put, isomorphism type is an equivalence
relation defined by: (i, j) and (i0, j0) have the same isomorphism type iff the following conditions
hold: (i) i = j ^⇒ i0 = j0; (ii) Xi = Xi，and Xj = Xjo; and (iii) (i,j) ∈ E ^⇒ (i0,j0) ∈ E. One
way to build an isomorphism type tensor for graph G is Y = [1,1 0 X, X 0 1, A], where I is the
identity matrix, (10 X)ij,： = Xj, and similarly (with a slight abuse of notation) (X 0 1)i,j,: = xi.
4	Low-rank global attention (LRGA)
We propose the Low-Rank Global Attention (LRGA) module that can augment any graph neural
network layer, denoted here generically as GNN, in the following way:
Xl+1 J [Xl,LRGA(Xl), GNN(Xl)]	(1)
where the brackets denote concatenation along the feature dimension. The LRGA module is defined
for an input feature matrix X ∈ Rn×din via
LRGA(X) = [nɪ)mι(X) (m2(X)Tm3(X)), m4(X)	⑵
where m1 , m2 , m3 , m4 : Rn×din → Rn×κ are MLPs operating on the feature dimension, that is
m(X) = [m(X1), . . . , m(Xn)]T, and κ ∈ N0 is a parameter representing the rank of the attention
module. Lastly, η is a normalization factor:
η(X) = 1 (ITmι(X)) (m2(X)T1),	⑶
where 1 = (1, 1, . . . ,1)T ∈ Rn. The matrix η(X)-1m1(X)m2(X)T can be thought of as a κ-rank
attention matrix that acts globally on the graph’s node features.
Computational complexity. Standard attention models (Vaswani et al., 2017; Luong et al., 2015)
require explicitly computing the attention score between all possible pairs in the set, meaning that
its memory requirement and computational cost scales as O(n2). This makes global-attention seem
impractical for large sets, or large graphs in our case. We address the global attention computational
challenge by working with bounded rank (i.e., κ) attention matrices, and avoid the need to construct
the attention matrix in memory by replacing the standard entry-wise normalization (softmax or
tanh) with a the global normalization η. In turn, the memory requirement of LRGA is O(nκ),
and using low rank matrix-vector multiplications LRGA allows applying global attention in O(nκ2 )
computation cost.
Permutation Equivariance. A common demand from GNN architectures is to respect the graph
representation symmetries, namely the ordering of nodes (Maron et al., 2019b). As shown in (Lee
et al., 2018b) the set attention module is permutation equivariant. The same matrix product structure
of the LRGA makes this module also permutation equivariant.
3
Under review as a conference paper at ICLR 2021
5	Theoretical Analysis
In this section we establish the theoretical underpinning for LRGA. Since we want to analyse the
generalization power added by LRGA, we focus on a family of GNNs with unbounded expressive
power in probability (RGNN). Under this model we show the benefit of augmenting GNNs with
LRGA in terms of improved generalization via the notion of algorithmic alignment with a powerful
graph isomorphism testing algorithm (2-FWL).
5.1	Random graph neural networks
We analyse LRGA under the framework of Random Graph Neural Networks (RGNNs):
Definition 1 (Random Graph Neural Network). Let D be a probability distribution of zero mean
and variance c, and G = (V, E, X) a graph. RGNN is a GNN variant with random input features
sampled at every forward pass i.e., the input to the network is [X , R] where R are i.i.d. samples
R ∈ Rn×d 〜D.
RGNN, suggested by Sato et al. (2020), has related variants (Loukas, 2020; 2019; Murphy et al.,
2019) that use node identifiers or distinctive features, which can be viewed as constant random
features, in order to break symmetry between isomorphic nodes. Such models are proven to be
universal but lose their inherent equivariance due to arbitrary prescription of node identifiers. We
choose to work in the seemingly more limited setting of RGNN, which allows the network to dis-
tinguish between different nodes but does not overfit specific identifiers. Our main claims regarding
this framework is that RGNN is both universal in probability and equivariant in expectation.
Proposition 1 (Universal). RGNN can approximate an arbitrary continuous graph function given
random features sampled from a bounded distribution D.
Here approximation is in a Probabilitic sense: Let Ω ⊂ Rn×d0 X Rn2 be a compact set of
graphs, [X, A] ∈ Ω, where A ∈ Rn is the adjacency matrix. Then, given a continuous graph
function f defined over Ω and arbitrary ε,δ > 0, there exist network parameters and d so that
P(∣GNN([X, R]) 一 f ([X, A])| < ε) > 1 一 δ, for all graphs [X, A] ∈ Ω. Proposition 1 holds for
GNN variants with a global attribute block such as (Battaglia et al., 2018). The proof is based on
the idea that random features allow the GNN to transfer the graph’s connectivity information to the
node features. Once all graph information is encapsulated at the nodes, we exploit the universality
of set functions (Zaheer et al., 2017) to get universality. The full proof is in Appendix A. To the best
of our knowledge this is the first result proving universality under the random feature assumption.
Proposition 2 (Equivariant in expectation). RGNN is permutation equivariant in expectation.
Changing the random features at each forward pass allows RGNN to preserve equivariance in ex-
pectation. Indeed, equivariance of GNN implies that GNN(P ∙ [X, Rj) = P ∙ GNN([X, R]), for
any permutation matrix P and input [X, R]. Taking the expectation of both sides w.r.t. R 〜 D,
noting that P R 〜 R and using linearity of expectation we get equivariance in expectation.
5.2	RGNN augmented with LRGA aligns with 2-FWL
In this section we will formulate our main theoretical result, Theorem 1, stating that augmenting
RGNN with LRGA algorithmically aligns with a powerful graph isomorphism testing algorithm
called 2-Folklore Weisfeiler-Lehman (2-FWL) (Grohe & Otto, 2015; Grohe, 2017). We will first
introduce the notion of algorithmic alignment and the 2-FWL algorithm, then formulate our main
theorem, and continue in the next section with a proof.
Algorithmic alignment. The notion of algorithmic alignment was introduced in Xu et al. (2019b)
as a framework for exploring effective neural architectures for certain tasks. A neural network N
is said to be aligned with an algorithm A if N can simulate A by a composition of modules, and
each module is ”simple”, or learnable, i.e., have bounded (hopefully low) sample complexity. For
example, message passing networks can simulate the vertex coloring algorithm (Xu et al., 2019a;
Morris et al., 2018) and therefore message passing can be seen as algorithmically aligned with vertex
coloring. Intuitively, algorithmic alignment introduces an inductive bias that improves the sample
complexity. Our definition of algorithmic alignment is a slightly stricter version:
4
Under review as a conference paper at ICLR 2021
Definition 2 (Monomial Algorithmic Alignment). A neural network N aligns with algorithm A if
N can simulate A by learning only monomial functions, i.e., f (x) = xα, where x ∈ Rd, α ∈ Nd,
and Xa = x；1........Xad ∙
To motivate this choice of monomials as ”simple” functions we note that (Arora et al., 2019; Xu
et al., 2019b) show a sample complexity bound for even-power polynomials learned by (two-layer)
MLPs and we extend it to general monomials in the following proposition proved in Appendix E:
Proposition 3. Let a two layer MLP trained with gradient descent be denoted as the learning algo-
rithm A. The monomial g(x) 二 Xa, X ∈ Rd, of degree n, |a| ≤ n, is PAC learnable with A with
a sample complexity bound:
CAO(g,e,δ) = o(Cn⅛≡),
Cn,d = (n2 + l)(n+1"2 cn,d, ε > 0 is the error parameter and δ ∈ (0,1) thefailure probability.
The asymptotic behaviour of cn,d is out of the scope of this paper. Therefore, a monomial algorith-
mic alignment of N to A means (under the assumptions and sequential training method of Theorem
3.6 in Xu et al. (2019b)) that Ais learnable by N.
2-Folklore Weisfeiler-Lehman (2-FWL) Algorithm. 2-FWL is part of the k-WL hierarchy of
polynomial-time (approximate) graph isomorphism iterative algorithms that recolor k-tuples of ver-
tices at each step according to neighborhoods aggregation. Upon reaching a stable coloring, the
algorithm terminates and if the histograms of colors of two graphs are not the same then the graphs
are deemed not isomorphic. The 2-FWL algorithm is equivalent to 3-WL, strictly stronger than
vertex coloring (2-WL) which bounds the expressive power of GNNs.
In more detail, let Y0 ∈ Rn2×diso represent the isomorphism types
of a given graph G = (V, E, X), that is Yi0,j ∈ Rdiso represents
the isomorphism type of the pair (i, j). The 2-FWL algorithm is
initialized with Y0 . Let Yl ∈ Rn2×dl denote the coloring tensor
after the lth update step. An update step in the algorithm aggregates
information from the multiset of neighborhood colors for each pair.
We represent the multiset of neighborhood colors of the tuple (i,j)	Zg〉
with a matrix Z(li,j) ∈ Rn×2dl . That is, any permutation of the rows of Z(li,j) represent the same
multiset. The rows of Z(li,j), which represent the elements in the multiset, are zk = [Yli,k, Ylk,j] ∈
R2dl, k ∈ [n]. See the inset for an illustration. The 2-FWL update step of a pair (i, j) from Yl to
Yl+1 concatenates the previous pair’s color and an encoding of the multiset of neighborhoods colors:
Yli+,j1 = hYli,j,ENC Z(li,j)i	(4)
where ENC : Rn×2dl → Rdenc is a multiset injective map invariant to the row-order of its input.
Main result. Consider the 2-FWL update rule in equation 4 and let Y l+1 ∈ Rn2 denote (arbitrary)
single feature dimension pealed off Yl+1 ∈ Rn2 ×dl+1 ; we call Y l+1 a single-head of the update
rule. Then,
Theorem 1. LRGA augmented RGNN algorithmically aligns with a single head 2-FWL update step.
A corollary of this theorem is:
Corollary 1. Multi-head LRGA augmented RGNN algorithmically aligns with 2-FWL.
Multi-head LRGA is a module of the form [Xl, LRGA1 (X l), . . . , LRGAk (X l), GNN(X l)],
which is an equivalent to multi-head self-attention. In practice, we found single-head LRGA to be
on par performance-wise with multi-head LRGA and therefore we focus on the single-head version
in the experimental section.
(1,j)
(2,j)
(3,j)
(i,2C
(4,j)
(i,3)
(B
(1,j
(i,1)
(i,2)
(2,.
(3,.
S'')
j
5.3 Proof of Theorem 1
To prove Theorem 1 we need to show RGNN augmented with LRGA can simulate one head of the
2-FWL update step using only monomials as learnable functions. We achieve that by the following
5
Under review as a conference paper at ICLR 2021
steps: (i) introduce the notion of node factorization to encode n × n tensor data as node features;
(ii) show that RGNN can approximate node factorization of the graph’s isomorphism type tensor
with a single GNN layer using learnable monomial functions; (iii) show that 2-FWL update step
can be formulated using matrix multiplication of monomial functions; and (iv) show LRGA can
approximate a single head 2-FWL update step using learnable monomials.
Part (i).	We start with the definition of node feature factorization:
Definition 3 (Node factorization). Let Y ∈ Rn2×d be a tensor. X ∈ Rn×D is called
node factorization of Y if there exists a block structure X = X1, . . . , Xk so that Y =
Xs1(Xt1)T,...,Xsd(Xtd)T, where (s1,t1),..., (sd , td ) ∈ [k] × [k] are index pairs.
Note that for all i,j ∈ [n] we have Yi,j = xis1 , xtj1 , . . . , xisd, xtjd ∈ Rd. Lets illustrate the
definition with an example. Let A ∈ {0, 1}n×n be the adjacency matrix of some graph G, and
for simplicity assume that there are no node features. Then, the isomorphism type tensor of G is
Y0 = [[I,A]] ∈ Rn2×2. One possible way of node factoring Y0 is using the SVD decomposition of
the adjacency matrix A. Note that node factorization is not unique.
Part (ii).
Proposition 4. RGNN with skip connection can approximate node factorization of the isomorphism
type tensor Y0.
Proof. We will prove the case of graph G = (V, E), i.e., with no vertex features; the general case
can be found in Appendix D. Let R ∈ Rn×d be a random node features matrix sampled i.i.d. from
D. A single layer of standard message passing can represent GNN(R) = d-0.5 [AR, R], which
requires learning only first degree (linear) monomials in the GNN’s learnable parts. Furthermore,
GNN(R) is an approximate node factorization ofY0, since d-1 RRT, ARRT ≈ [[I, A]] = Y0,
where the approximation error d-1RRT ≈ I can be bounded using the result in Appendix A. □
Part (iii). As shown in (Maron et al., 2019a) the encoding function ENC from the 2-FWL update
rule (see equation 4) can be expressed as follows (derivation can be found in Appendix B):
Yl+1 = [[y, [YβYγ I (β, Y) ∈ N2d, ∣β∣ + ∣γ| ≤ n]ii	(5)
where for notational simplicity we denote Y = Yl and d = dl . By Yβ we mean that we apply the
multi-power β to the feature dimension, i.e., (Yβ)i,j = Yiβ,j . Therefore, computing the multisets
encoding amounts to calculating monomials Yβ , Yγ and their matrix multiplications YβYγ .
Part (iv).
Proposition 5. The node factorization of each head of Yl+1, the result of 2-FWL update step, can
be approximated via LRGA module applied to node factorization of Y = Yl. The MLPs in the LRGA
approximation need to learn only monomial functions.
Proof. Let X = [X1, . . . , Xk] ∈ Rn×D be a node factorization of Y = Yl. The 2-FWL update
step requires computation of polynomials of the form Yβ as shown in equation 5. Using the node
factorization of Y, Yi,j = xis1, xtj1 , . . . , xisd, xtjd ∈ Rd, we can write:
dd	d
Yej = Y〈xsl, Xjl >βl = Y"βι (Xsl ),^βι (Xjl» = Ygl (χs),ψβι (Xj)〉
l=1	l=1	l=1
=(ψβ (Xv),中 β (Xj)〉	⑹
where the second equality is using the feature maps 夕βl of the (homogeneous) polynomial kernels
(VaPnik, 1998),(Xi, X2iβl; the third equality is reformulating the feature maps ψβl on the vectors
Xis = [Xis1 , . . . , Xisd], and Xit = Xit1 , . . . , Xitd ; and the last equality is due to the closure of kernels
to multiplication. We denote the final feature map by 夕β.
Now, let ψβ(Xi) = φβ(Xs) and φβ(Xi)= 夕β(Xi) then We have:
Yβ = ψβ(X)φβ(X)T,
6
Under review as a conference paper at ICLR 2021
where ψβ(X) is applying ψβ to every row of X. Therefore, arbitrary head of Yl+1, i.e., of the form
YβYγ , can be written directly as a function of X using the feature maps φβ , ψβ , φγ , ψγ :
YβYγ = ψβ(X)φβ(X)Tψγ(X)φγ(X)T.	(7)
A node factorization of the head YβYα is therefore ψβ(X)φβ(X)Tψγ(X), φγ (X). Re-
calling the structure of the LRGA module introduced in equation 2: LRGA(X)	=
[η(X)-1m1(X) (m2(X)Tm3(X)), m4(X)], to implement the 2-FWL head the MLPs
m1 , m2 , m3, m4 need to learn the polynomial feature maps formulated in equation 7: m1 ≈ ψβ,
m2 ≈ φβ , m3 ≈ ψγ , and m4 ≈ φγ . Every coordinate of these feature maps is a monomial (proof
of this fact in Appendix C). Lastly, note that 2-FWL tensors Yl are insensitive to global scaling and
therefore the normalization η has no theoretical influence (it is assumed non-zero). □
6	Experiments
We evaluated our method on various tasks including graph regression, graph classification, node
classification and link prediction. The datasets we used are from two benchmarks: (i) benchmarking
GNNs (Dwivedi et al., 2020); and (ii) Open Graph Benchmark (OGB) (Hu et al., 2020). Each
benchmark has its own evaluation protocol designed for a fair comparison among different models.
These protocols define consistent splits of the data to train/val/test sets, set a budget on the size of
the models (OGB), define a stopping criterion for reporting test results and require training with
several different initializations to measure the stability of the results. We followed these protocols.
Baselines. We compare performance with the following state of the art baselines: GCN (Kipf &
Welling, 2016), GraphSAGE (Hamilton et al., 2017), GIN (XU et al., 2019a), GAT (Velickovic et al.,
2018), GatedGCN (Bresson & Laurent, 2017), Node2Vec (Grover & Leskovec, 2016) , DeepWalk
(Perozzi et al., 2014) and MATRIX FACTORIZATION (Hu et al., 2020).
Attention Ablation. We compared the performance of different versions of global attention
modules. The experiment was conduced on the ZINC dataset and compared performance on the
GCN, GAT and GatedGCN models.
Random Features Evaluation. In addition, we also conducted a set of experiments with the
random feature framework. In this experiment we focused on the PATTERN node classification
dataset from (Dwivedi et al., 2020) and evaluated a variety of models under the RGNN framework.
Rank Ablation Study. In this experiment we examined the relation between the rank parameter κ,
which can limit the expressiveness of the attention module, and the network performance. Results
are presented in Appendix G.
Implementation details of LRGA. We implemented the LRGA module according to the descrip-
tion in Section 4 (equations 2, 3) using the pytorch framework and the DGL (Wang et al., 2019)
and Pytorch geometric (Fey & Lenssen, 2019) libraries. Each LRGA module contains 4 MLPs
m1, m2, m3, m4. Each mi : Rd → Rκ is a single layer MLP (linear with ReLU activation). The
implementation of a layer is according to equation 2, where in practice we added another single
layer MLP, m5 : Rd+2κ+dGN N → Rd, for the purpose of reducing the feature dimension size. In the
OGB benchmark dataset we did not use the skip connections (better performance), and as advised
in (Wang et al., 2019), we used batch and graph normalization at each layer.
6.1	Benchmarking Graph Neural Networks (Dwivedi et al., 2020)
Datasets. This benchmark contains 6 main datasets (full description in appendix H.1) : (i) ZINC,
graph regression task of molecular dataset evaluated with MAE metric; (ii) MNIST and CIFAR10,
the image classification problem converted to graph classification using a super-pixel representation
(Knyazev et al., 2019); (iii) CLUSTER and PATTERN, node classification tasks which aim to clas-
sify embedded node structures (Abbe, 2017); (iv) TSP, a link prediction variation of the Traveling
Salesman Problem (Joshi et al., 2019) on 2D Euclidean graph.
Evaluation protocol. All models were evaluated with two different sets of parameter budgets and
restrictions. The first set restricted to have roughly 100K parameters and 4 layers, while the second
set of experiments has a budget of roughly 500K parameters and up to 16 layers. The learning rate
and its decay are set according to a predetermined scheduler using the validation loss. The stopping
criterion is set to when the learning rate reaches a specified threshold. All results are averaged over
a set of predetermined fixed seeds and standard deviation is reported as well.
7
Under review as a conference paper at ICLR 2021
Table 1: Performance on the benchmarking GNN datasets. In bold: better performance between LRGA aug-
mented and vanilla models; note the parameter (#) budget. Blue represents best performance with the 100K
budget and red with the 500K budget.
Model	PATTERN		CLUSTER		ZINC		MNIST		CIFAR10		TSP	
	#	Acc ± std	#	Acc ± std	#	MAE ± Std	#	Acc ± std	#	Acc ± std	#	F1 ± std
GCN	100K	63.88 ± 0.07	101K	53.44 ± 2.02	103K	0.459 ± 0.006	101K	90.70 ± 0.21	101K	55.71 ± 0.38	95K	0.630 ± 0.001
LRGA + GCN	90K	83.09 ± 0.73	91K	68.44 ± 0.16	92K	0.448 ± 0.009	91K	97.63 ± 0.11	91K	65.80 ± 0.43	97K	0.702 ± 0.001
GAT	109K	75.82 ± 1.82	110K	57.73 ± 0.32	102K	0.475 ± 0.007	110K	95.53 ± 0.20	110K	64.22 ± 0.45	96K	0.671 ± 0.002
LRGA + GAT	90K	82.54 ± 0.71	91K	69.05 ± 0.05	92K	0.421 ± 0.020	90K	97.47 ± 0.16	90K	68.00 ± 0.13	97K	0.680 ± 0.003
GatedGCN	104K	84.48 ± 0.12	104K	60.40 ± 0.41	105K	0.375 ± 0.003	104K	97.34 ± 0.14	104K	67.31 ± 0.31	97K	0.808 ± 0.003
LRGA + GatedGCN	93K	85.09 ± 0.11	93K	69.28 ± 0.16	94K	0.355 ± 0.010	93K	98.20 ± 0.03	93K	70.65 ± 0.18	97K	0.807 ± 0.001
GCN	500K	71.89 ± 0.33	501K	68.49 ± 0.97	505K	0.367 ± 0.011	504K	91.39 ± 0.25	504K	54.84 ± 0.44	-	-
LRGA + GCN	400K	84.55 ± 0.57	400K	76.01 ± 0.67	501K	0.377 ± 0.009	463K	98.34 ± 0.06	463K	68.27 ± 0.46	-	-
GAT	526K	78.27 ± 0.18	528K	70.58 ± 0.44	531K	0.384 ± 0.007	441K	96.50 ± 0.18	442K	66.11 ± 0.98	-	-
LRGA + GAT	533K	85.82 ± 0.42	267K	76.16 ± 0.34	536K	0.360 ± 0.004	476K	98.41 ± 0.08	476K	71.57 ± 0.26	-	-
GatedGCN	502K	85.56 ± 0.01	502K	73.84 ± 0.32	504K	0.282 ± 0.015	500K	98.24 ± 0.04	500K	71.33 ± 0.39	-	-
LRGA + GatedGCN	486K	85.81 ± 0.31	438K	76.39 ± 0.13	446K	0.249 ± 0.011	486K	98.47 ± 0.16	487K	73.48 ± 0.29	-	-
Results. Table 1 summarizes the results of training and evaluating our model according to the
evaluation protocol; We observe that LRGA improves GNN performance, often by a large margin,
across all models and datasets, besides GCN on ZINC and GatedGCN in TSP, supporting our claim
for improved generalization. We further note that SOTA in all datasets except TSP is achieved with
LRGA augmented GNNs. In some datasets, such as CLUSTER and PATTERN, LRGA reaches top
and roughly equivalent performance for all models it augmented, which emphasizes the empirical
contribution of LRGA independently of the GNN variant.
6.2	Link prediction datasets from the OGB benchmark (Hu et al., 2020)
Datasets. We further evaluate LRGA
on semi-supervised learning tasks includ-
ing graphs with hundreds of thousands of
nodes, from the OGB benchmark: (i) ogbl-
ppa, a graph of proteins and biological
connections as edges ;(ii) ogbl-collab, an
authors collaborations graph; (iii) ogbl-ddi
drug interaction network. The evaluation
metric for all of the tasks is Hits@K; more
Table 2: Performance on the link prediction tasks from the
OGB benchmark
Model	ogbl-ppa		ogbl-collab		ogbl-ddi	
	# Param	Hits@100±std	# Param	Hits@50± std	# Param	Hits@20±std
Node2vec	7.3M	0.223 ± 0.008	30M	0.489 ± 0.005	645K	0.233 ± 0.021
DeepWalk	150M	0.289 ± 0.015	61M	0.504 ± 0.003	11M	0.264 ± 0.061
MF	147M	0.323 ± 0.009	60M	0.389 ± 0.003	1.2M	0.137 ± 0.047
GraphSage	424K	0.165 ± 0.024	460K	0.481 ± 0.008	1.4M	0.539 ± 0.047
GCN	278K	0.187 ± 0.013	296K	0.447 ± 0.011	1.2M	0.370 ± 0.050
LRGA + GCN	814K	0.342 ± 0.016	1M	0.522 ± 0.007	1.5M	0.623 ± 0.091
details in appendix H.2.
Evaluation protocol. All models have a hidden layer of size 256 and the number of layers is 3 in
ogbl-ppa and ogbl-collab and 2 in ogbl-ddi. Test results are reported by the best validation epoch
averaged over 10 random seeds.
Results. Table 2 summarizes the results on the link prediction tasks. It should be noted that the
first three rows correspond to node embedding methods where the rest are GNNs. Augmenting
GCN with LRGA achieves SOTA results on those datasets, while still using order of magnitude less
parameters than the node embedding runner-up method.
6.3	Attention Ablation
Table 3: Attention ablation table. Various GNNs augmented with attention variants on the ZINC dataset. Bold
represent best performance and blue represent second best.
Model	LRGA	LRGA no m4	Polynomial kernel (degree 2)	Polynomial kernel (degree 4)	Exponential kernel	RBF kernel
	MAE ± std	MAE ± std	MAE ± Std	MAE ± std	MAE ± Std	MAE ± Std
GCN	0.448 ± 0.009	0.440 ± 0.006	0.464 ± 0.011	0.467 ± 0.008	0.450 ± 0.011	0.457 ± 0.007
GAT	0.421 ± 0.020	0.435 ± 0.026	0.460 ± 0.011	0.475 ± 0.014	0.439 ± 0.016	0.452 ± 0.003
GatedGCN	0.355 ± 0.010	0.363 ± 0.008	0.363 ± 0.008	0.370 ± 0.011	0.351 ± 0.028	0.371 ± 0.005
The LRGA model (equation 2) applies the low-rank attention matrix S = η(X)-1m1(X)m2(X)T
to the node features m3(X), that, together with m4 (X), align with node factorization of 2-FWL
head. In this experiment we have tested two variations of LRGA: First, removing the m4 component;
and second, replacing S with standard, kernel-based attention matrices (Tsai et al., 2019). Results of
8
Under review as a conference paper at ICLR 2021
incorporating the different attention mechanisms to GCN, GAT, and GatedGCN and experimenting
with the ZINC dataset are summarized in Table 3. First, it seems incorporating m4 explicitly in the
LRGA module compares mostly favorably to LRGA model with no m4 . We attribute that mainly to
the algorithmic alignment of the full LRGA model with 2-FWL, and in particular to the encoding
of 2-FWL neighborhood multisets. Second, as indicated in (Tsai et al., 2019), the attention matrix
could be expressed using a kernel function, Si,j = (Pn=I k(xi, x'))-1k(xi, Xj) . We replace
the low-rank attention matrix S in the LRGA module with attention matrices defined via different
kernels k : a polynomial kernel (of degree 2 and 4); exponential kernel (which is equivalent to
the classical self-attention (Vaswani et al., 2017)) and radial basis function (RBF) kernel. A full
definition of the different kernels is provided in Appendix F. Note that the proof of Theorem 1
utilizes a kernel defined by a polynomials feature map to align with the 2-FWL head. As the table
shows, with the expection of the exponential kernel on GatedGCN, LRGA achieve superior result
across all the models. The major advantage of LRGA over the other kernels in that it does not require
to explicitly compute and store in memory the attention matrix, and exploit the low rank structure
for fast multiplication.
6.4	Random Features Ablation
In this experiment we wanted to validate the theoretical analysis pre-
sented at section 5. The dataset for this evaluation is the PATTERN
dataset, which is originally equipped with random features, but in con-
trast to the RGNN framework those features are sampled only once at
the dataset creation stage. We evaluated the different models according
to the RGNN framework, i.e., resample the features with every forward
pass. The features were sampled from a zero mean Gaussian distribution
with variance d, where d is the input feature dimension. The evaluation
protocol is the same as the one used in section 6.1 and we followed the
500K budget. As seen from table 4, using alternating random features
improves performance for all the models. GIN and GraphSage do not
appear in the main table but according to (Dwivedi et al., 2020) achieves
85.39% and 50.49% respectively. The LRGA augmented RGNN models
maintain their superiority (even presenting a small improvement com-
Table 4: Random Features
Evaluation
Model	PATTERN
	Acc ± Std
GCN	74.891 ± 0.713
LRGA + GCN	84.118 ± 1.216
GAT	81.796 ± 0.661
LRGA + GAT	85.905 ± 0.109
GraphSage	85.039 ± 0.068
LRGA + GraPhSage	85.229 ± 0.331
GatedGCN	85.848 ± 0.065
LRGA + GatedGCN	85.944 ± 0.664
GIN	85.760 ± 0.001
LRGA + GIN	86.765 ± 0.065
pared to Table 1) and serve as an empirical validation to our main theorem.
7	Conclusions
In this work, we set ourself in a path for improving the generalization power of GNNs. To do so, we
introduced the LRGA module, a global self attention module, which is a variant of the dot-product
self-attention with linear complexity. In order to theoretically evaluate the contribution of LRGA
we analyzed our model under the RGNN framework, which is proved to be universal in probability.
Under this framework we were able to show that RGNN augmented with LRGA can align with
the powerful 2-FWL isomorphism test by learning simple monomial functions, which have a known
sample complexity bound. Under certain conditions the latter provides concrete generalization guar-
antees for RGNN augmented with LRGA. Empirically, we demonstrated augmenting GNN models
with LRGA improves their performance significantly, often achieving SOTA performance.
9
Under review as a conference paper at ICLR 2021
References
Emmanuel Abbe. Community detection and stochastic block models: recent developments, 2017.
Sami Abu-El-Haija, Rami Al-Rfou, Bryan Perozzi, and Alex Alemi. Watch your step: Learning
node embeddings via graph attention. In Advances in Neural Information Processing Systems,
volume 2018-Decem,pp. 9180-9190, 2018.
Anonymous. From graph low-rank global attention to 2-fwl approximation, 2020.
Sanjeev Arora, Simon S Du, Wei Hu, Zhiyuan Li, and Ruosong Wang. Fine-grained analysis of
optimization and generalization for overparameterized two-layer neural networks. arXiv preprint
arXiv:1901.08584, 2019.
Dzmitry Bahdanau, Kyung Hyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. In 3rd International Conference on Learning Representations,
ICLR 2015, 2015.
Peter Bartlett, Dylan J. Foster, and Matus Telgarsky. Spectrally-normalized margin bounds for neural
networks, 2017.
Peter W Battaglia, Jessica B Hamrick, Victor Bapst, Alvaro Sanchez-Gonzalez, Vinicius Zambaldi,
Mateusz Malinowski, Andrea Tacchetti, David Raposo, Adam Santoro, Ryan Faulkner, et al.
Relational inductive biases, deep learning, and graph networks. arXiv preprint arXiv:1806.01261,
2018.
Xavier Bresson and Thomas Laurent. Residual Gated Graph Convnets. Technical report, 2017.
George Dasoulas, Ludovic Dos Santos, Kevin Scaman, and Aladin Virmaux. Coloring graph neural
networks for node disambiguation, 2019.
Simon S. Du, Kangcheng Hou, Barnabas Poczos, RUslan Salakhutdinov, RUosong Wang, and Keyulu
Xu. Graph neural tangent kernel: Fusing graph neural networks with graph kernels, 2019.
Vijay Prakash Dwivedi, Chaitanya K. Joshi, Thomas Laurent, Yoshua Bengio, and Xavier Bresson.
Benchmarking graph neural networks, 2020.
Matthias Fey and Jan Eric Lenssen. Fast Graph Representation Learning with PyTorch Geometric.
arXiv preprint arXiv:1903.02428, 2019.
Vikas K. Garg, Stefanie Jegelka, and Tommi Jaakkola. Generalization and representational limits of
graph neural networks, 2020.
Justin Gilmer, Samuel S Schoenholz, Patrick F Riley, Oriol Vinyals, and George E Dahl. Neural
Message Passing for Quantum Chemistry. In International Conference on Machine Learning, pp.
1263-1272, 2017.
Noah Golowich, Alexander Rakhlin, and Ohad Shamir. Size-independent sample complexity of
neural networks, 2019.
Marco Gori, Gabriele Monfardini, and Franco Scarselli. A new model for learning in graph domains.
In Proceedings of the International Joint Conference on Neural Networks, volume 2, pp. 729-734,
2005. ISBN 0780390482. doi: 10.1109/IJCNN.2005.1555942.
Martin Grohe. Descriptive complexity, canonisation, and definable graph structure theory, vol-
ume 47. Cambridge University Press, 2017.
Martin Grohe and Martin Otto. Pebble games and linear equations. The Journal of Symbolic Logic,
80(3):797-844, 2015.
Aditya Grover and Jure Leskovec. node2vec: Scalable feature learning for networks, 2016.
William L Hamilton, Rex Ying, and Jure Leskovec. Inductive representation learning on large
graphs. In Advances in Neural Information Processing Systems, volume 2017-Decem, pp. 1025-
1035, 2017.
10
Under review as a conference paper at ICLR 2021
Weihua Hu, Matthias Fey, Marinka Zitnik, Yuxiao Dong, Hongyu Ren, Bowen Liu, Michele Catasta,
and Jure Leskovec. Open Graph Benchmark: Datasets for Machine Learning on Graphs. may
2020. URL http://arxiv.org/abs/2005.00687.
Chaitanya K. Joshi, Thomas Laurent, and Xavier Bresson. An efficient graph convolutional network
technique for the travelling salesman problem, 2019.
Angelos Katharopoulos, APoorv Vyas, Nikolaos Pappas, and Francois Fleuret. Transformers are
rnns: Fast autoregressive transformers with linear attention, 2020.
Thomas N. Kipf and Max Welling. Semi-Supervised Classification with Graph Convolutional Net-
works. 5th International Conference on Learning Representations, ICLR 2017, sep 2016. URL
http://arxiv.org/abs/1609.02907.
Johannes Klicpera, Stefan WeiBenberger, and Stephan Gunnemann. Diffusion improves graph learn-
ing, 2019.
Boris Knyazev, Graham W. Taylor, and Mohamed R. Amer. Understanding attention in graph neural
networks. CoRR, abs/1905.02850, 2019. URL http://arxiv.org/abs/1905.02850.
John Boaz Lee, Ryan A Rossi, Sungchul Kim, Nesreen K Ahmed, and Eunyee Koh. Attention
Models in Graphs: A Survey. Technical report, 2018a. URL https://doi.org/.
Juho Lee, Yoonho Lee, Jungtaek Kim, Adam R. Kosiorek, Seungjin Choi, and Yee Whye Teh. Set
transformer: A framework for attention-based permutation-invariant neural networks, 2018b.
Yujia Li, Richard Zemel, Marc Brockschmidt, and Daniel Tarlow. Gated graph sequence neural
networks. In 4th International Conference on Learning Representations, ICLR 2016 - Conference
Track Proceedings, 2016.
Andreas Loukas. What graph neural networks cannot learn: depth vs width, 2019.
Andreas Loukas. How hard is graph isomorphism for graph neural networks?, 2020.
Minh-Thang Luong, Hieu Pham, and Christopher D Manning. Effective Approaches to Attention-
based Neural Machine Translation. Technical report, 2015. URL http://nlp.stanford.
edu/projects/nmt.
Haggai Maron, Heli Ben-Hamu, Hadar Serviansky, and Yaron Lipman. Provably pow-
erful graph networks. In Advances in Neural Information Processing Systems 32, pp.
2156-2l67. Curran Associates, Inc., 2019a. URL http://papers.nips.cc/paper/
8488-provably-powerful-graph-networks.pdf.
Haggai Maron, Heli Ben-Hamu, Nadav Shamir, and Yaron Lipman. Invariant and equivariant graph
networks. In 7th International Conference on Learning Representations, ICLR 2019, 2019b.
Christopher Morris, Martin Ritzert, Matthias Fey, William L Hamilton, Jan Eric Lenssen, Gaurav
Rattan, and Martin Grohe. Weisfeiler and Leman Go Neural: Higher-order Graph Neural Net-
works. arXiv preprint arXiv:1810.02244, 2018.
Ryan L Murphy, Balasubramaniam Srinivasan, Vinayak Rao, and Bruno Ribeiro. Relational Pooling
for Graph Representations. arXiv preprint arXiv:1903.02541, 2019.
Hongbin Pei, Bingzhe Wei, Kevin Chen-Chuan Chang, Yu Lei, and Bo Yang. Geom-GCN: Geomet-
ric Graph Convolutional Networks. 2020. URL http://arxiv.org/abs/2002.05287.
Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. Deepwalk. Proceedings of the 20th ACM
SIGKDD international conference on Knowledge discovery and data mining - KDD ’14,
2014. doi: 10.1145/2623330.2623732. URL http://dx.doi.org/10.1145/2623330.
2623732.
Ryoma Sato, Makoto Yamada, and Hisashi Kashima. Random features strengthen graph neural
networks, 2020.
11
Under review as a conference paper at ICLR 2021
Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini.
The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61-80, 2009.
ISSN 10459227. doi: 10.1109/TNN.2008.2005605.
Franco Scarselli, Ah Tsoi, and Markus Hagenbuchner. The vapnik-chervonenkis dimension of graph
and recursive neural networks. Neural Networks, 108, 09 2018. doi: 10.1016/j.neunet.2018.08.
010.
Zhuoran Shen, Mingyuan Zhang, Haiyu Zhao, Shuai Yi, and Hongsheng Li. Efficient attention:
Attention with linear complexities, 2020.
Yao-Hung Hubert Tsai, Shaojie Bai, Makoto Yamada, Louis-Philippe Morency, and Ruslan
Salakhutdinov. Transformer dissection: A unified understanding of transformer’s attention via
the lens of kernel, 2019.
Vladimir N. Vapnik. Statistical Learning Theory. Wiley-Interscience, 1998.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information
processing systems, pp. 5998-6008, 2017.
Petar Velickovic, Arantxa Casanova, Pietro Lio, Guillem Cucurull, Adriana Romero, and Yoshua
Bengio. Graph attention networks. In 6th International Conference on Learning Representations,
ICLR 2018, 2018. ISBN 1710.10903v3.
Saurabh Verma and Zhi-Li Zhang. Stability and generalization of graph convolutional neural net-
works, 2019.
Minjie Wang, Lingfan Yu, Da Zheng, Quan Gan, Yu Gai, Zihao Ye, Mufei Li, Jinjing Zhou,
Qi Huang, Chao Ma, Ziyue Huang, Qipeng Guo, Hao Zhang, Haibin Lin, Junbo Zhao, Jinyang
Li, Alexander J Smola, and Zheng Zhang. Deep graph library: Towards efficient and scalable
deep learning on graphs. ICLR Workshop on Representation Learning on Graphs and Manifolds,
2019. URL https://arxiv.org/abs/1909.01315.
Holger Wendland. Scattered data approximation, volume 17. Cambridge university press, 2004.
Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka. How Powerful are Graph Neural
Networks? In International Conference on Learning Representations, 2019a. URL https:
//openreview.net/forum?id=ryGs6iA5Km.
Keyulu Xu, Jingling Li, Mozhi Zhang, Simon S Du, Ken-ichi Kawarabayashi, and Stefanie Jegelka.
What Can Neural Networks reason About? Technical report, 2019b.
Jiaxuan You, Rex Ying, and Jure Leskovec. Position-aware graph neural networks. CoRR,
abs/1906.04817, 2019. URL http://arxiv.org/abs/1906.04817.
Manzil Zaheer, Satwik Kottur, Siamak Ravanbakhsh, Barnabas Poczos, Ruslan R Salakhutdinov,
and Alexander J Smola. Deep sets. In Advances in Neural Information Processing Systems, pp.
3391-3401, 2017.
Chenyi Zhuang and Qiang Ma. Dual graph convolutional networks for graph-based semi-supervised
classification. WWW ’18, pp. 499-508, Republic and Canton of Geneva, CHE, 2018. In-
ternational World Wide Web Conferences Steering Committee. ISBN 9781450356398. doi:
10.1145/3178876.3186116. URL https://doi.org/10.1145/3178876.3186116.
A Proof of Proposition 1
Proof. We will now prove the universality in probability over the distribution D of RGNNs. Let
Ω ⊂ Rn×d0 X Rn×n be a compact set of graphs, [X, A] ∈ Ω, where X are the node features
and A is the adjacency matrix and we assume that n is fixed. Consider f, a continuous graph
function. f is permutation invariant where the permutation acts on all n dimensions, namely,
12
Under review as a conference paper at ICLR 2021
f([PX, PAPT]) = f([X, A]) for all permutation matrices P ∈ Rn×n. RGNN is defined as
RGNN(X) = GNN([X, R]) where R ∈ Rn×d are i.i.d. samples from D.
To prove universality in probability we need to show that RGNN can approximate f to an arbitrary
precision ε with high probability 1 - δ :
∀ε,δ > 0 ∃Θ,d s.t. P (|RGNN(X) - f([X,A])| < ε) > 1 - δ
where Θ are the RGNN network parameters and d is the dimension of the random features of RGNN.
In fact, a simple RGNN composed of single message passing layer and a global attribute block,
a DeepSets network (Zaheer et al., 2017), suffices. The message passing layer first transfers the
graph structural information to the node features by creating a factorized representation of A. This
means that all the graph information is now stored in a set. Then, using the universality of DeepSets
network for invariant set functions we can approximate f to an arbitrary precision.
Let us denote the output of the message passing layer of RGNN by h1. The structural information
of the graph can be transferred to the node features using the message passing layer by choosing
parameters such that h1 = [X, R, AR]. h1 is then fed to the DeepSets network, so we have
RGNN(X) = DeepSets([X , R, AR]).
Observing the approximation error:
|RGNN(X) - f([X,A])| = |DeepSets([X, R, AR]) - f([X,A])| =
=∣DeepSets([X, R, AR]) - f ([X, dARRt]) + f ([X, dARRt]) - f ([X, A])| ≤
≤ ∣DeepSets([X, R, AR) - f([X, 1 ARRTDI + |f ([X, 1 ARRTD- f ([X, A])|
dd
We can now bound the two terms in the last inequality above. Since f is defined on the compact set
Ω We first make sure that 1ARRT remains bounded (We assume f can be extended continuously
to this domain). Since we assume D is bounded (given X ~ D, ∣χ∣ < M/2), we get:
1 ARRT
d
≤ d kA∣∣F∣∣RRTll ≤ d kAkF dM42n
Fd	d	4
For the second term we can achieve a bound in probability. Since f is a continuous function on a
compact set, by the Heine-Cantor theorem, it is uniformly continuous, meaning that
∀ε0 > 0 ∃ ξ s.t ∀ Q, S ∈ Ω dn(Q, S) <ξ ⇒ dR(f (Q), f (S)) < ε0
Setting ε0 = ε∕2 we can now choose d such that with probability 1 - δ we have
dn([X, dARRT], [X, A]) < ξ. Let dn be the euclidean metric, then, dn(dARRT, A) ≤
kA∣∣F ∙ ∣∣ 1 RRt - I∣∣f. Since we assume a graph of fixed size n, kAkF ≤ n and we are left
with bounding ∣∣ dRRt - I∣∣f in probability. Using Hoeffding,s inequality we will be able to find
d satisfying the conditions.
A single entry in Rhas mean 0 and variance c, for simplicity we set c = 1. An entry in RRT is of
the form (RRT)ij = Pld=1RilRjl. Note that all elements of the sum are statistically independent
and bounded. Using Hoeffding’s inequality:
P(Id XX RilRjl- E
d X RilRjl J ≥ t
≤ 2 exp
(8)
For i= j: E [d Pd=I Ril Rjl] =0 and for i = j: E [l Pd=1 RilRjl] = 1.
Using union bound over all entries of d RRt :
P ( [	d (RRT)ij - Iij
i,j∈[n]
13
Under review as a conference paper at ICLR 2021
Setting t = ξ∕n2 IlAkF and requiring 2n2 exp (-2M2-) < δ we get d = M0n ξAkF log (2n2-)
where M0 accumulates all constant factors. Lastly, kAkF is bounded by n, so the d we should take
is d = M0nξ6 log (2n2). Finally, We have that for large enough d, ∣∣ dRRT - IhF is arbitrarily
small with a high probability.
For the first term, we note that f ([X, 1dARRT]) = F(X, R, AR]) is a continuous invariant set
function over a bounded domain. Therefore the first term can be bounded by invoking the universal
approximation theorem of invariant set functions (Zaheer et al., 2017), i.e., exist a set of parameters
and model size such that the approximation error is less than ε∕2.
This concludes the proof. We found that exists a set of network parameters and d such that the
approximation error is arbitrarily small.
□
B Multiset encoding
As shown in Maron et al. (2019a) the multiset encoding function, ENC, can be defined using the
collection of Power-sum Multi-symmetric Polynomials (PMPs). That is, given a multiset Z =
(z1, . . . , zn)T ∈ Rn×2d the encoding is defined by
n
ENC(Z )= X Za α ∈ N0d,∣α∣≤ n ,
k=1
where α = (αι,..., α2d), and Za = z；1 …Zadd.
Let us focus on computing a single output coordinate α of the ENC function applied to a particular
multiset Z(i,j). This can be efficiently computed using matrix multiplication Maron et al. (2019a):
Let α = (β, γ) ∈ N02d, where β, γ ∈ N0d. Then,
nn
ENCa(Z(i,j)) =XZka =XYiβ,kYkγ,j = (YβYγ)i,j.
k=1	k=1
By Yβ we mean that we apply the multi-power β to the feature dimension, i.e., (Yβ)i,j = Yiβ,j.
This implies that computing the multisets encoding amounts to calculating monomials Yβ , Yγ and
their matrix multiplications YβYγ . Thus the 2-FWL update rule, equation 4, can be written in the
following matrix form, where for notational simplicity we denote Y = Yl :
Yl+1 = [[y, [YβYγ I (β, Y) ∈ N2d, ∣β∣ + ∣γ| ≤ niii
C 2-FWL via polynomial kernels
In this section, we give a full characterization of feature maps, We, of the final polynomial kernel
we use to formulate the 2-FWL algorithm. A key tool for the derivation of the final feature map is
the multinomial theorem, which we state here in a slightly different form to fit our setting.
Multinomial theorem. Let us define a set of m variables x1y1, . . . , xmym composed of products
of corresponding x and y’s. Then,
nm
(XIyI + •…+ Xmym) =	νn	(xiyi)νi
∣ν∣=n、i i=1
where V ∈ Nmm, and the notation ¢) = V ! n!ν !. The SUm is over all possible V which sum to n,
in total (n+m-1) elements.
m-1
14
Under review as a conference paper at ICLR 2021
Recall that we wish to compute Yiβ,j as in equation 6 in the paper:
dd	d
Yej = Y〈xsl, Xjl >βl = Y"βι (Xsl ),^βι (Xjl» = Ygl (χs),ψβι (Xj)〉
l=1	l=1	l=1
=(ψβ (Xr)Ne (Xj)〉
We will now follow the equalities in equation 6 to derive the final feature map. The second equality
is using the feature maps 夕力忆 of the (homogeneous) polynomial kernels (VaPnik, 1998),(Xi, X2iβk,
which can be derived from the multinomial theorem.
Suppose the dimensions of Xsl, Xtl are n X Dl where Pd=i 2Dι = D. Then, ψβl consists of
monomials of degree βl of the form 夕βl (X)V = Je) QD=I XVi = J(Vl)XV, ∣ν| = βl. In total the
size of the feaure map 夕βl is (βl+D-l-1).
The third equality is reformulating the feature maps 夕 βl on the vectors XS = [xS1 ,..., XSk ] ∈ RD/2,
and Xit = Xit1 , . . . , Xitk ∈ RD/2.
The last equality is due to the closure of kernels to multiplication. The final feature map, which is
the product kernel, is composed of all possible products of elements of the feature maps, i.e.,
ψβ(X)= (Y jCl)XVll ∣νj∣ = βj-, ∀j ∈ [d]),
where X = [X1, X2, . . . , Xk] ∈ RD/2, and Xl ∈ RDl for all l ∈ [d]. The size of the final feature map
is Qd=I (βl+D-l-1) ≤ N where N = (nDD).
D Extension of Proposition 4
In this section we would like to extend the proof of proposition 4 to the case where the
graph is equipped with prior node features X ∈ Rn×d0, s.t the network’s input is [X, R].
As mentioned in Section 3 the isomorphism type of a graph equipped with node features
is Y = [1, 1 0 X, X 0 1, A]∣.	Following this description We claim that the node factor-
ization representation of the graph will be of the form R0 = [1, X, R, AR], where 1 =
(1, 1, . . . , 1)T ∈ Rn . To build the isomorphosm tensor we can use the sequence of outer products
X1 1T, . . . , Xd1T, 1X1T, . . . , 1XdT , where Xl ∈ Rn is the l-th column of X. This sequence
could be represented using the two first components of R0 . The last two components, R and AR
allow to approximate in probability A and I as shown in Appendix A, which complete the isomor-
phism tensor construction and conclude that [1, X, R, AR∣ is a node factorization representation.
Lastly, we have to show that we can construct this structure using RGNN, and actually we are left
to explain how to add the 1 vector to the representation. This could be done using a global attribute
block as used to proof Proposition 1.
E S ample complexity bound of monomials
Corollary 6.2 in (Arora et al., 2019) provides a bound on the sample complexity, denoted CA0 (g, , δ),
of a polynomial g : RD → R of the form
g(X) = Xaj hβj, Xipj ,	(9)
j
where pj	∈	{1, 2, 4,	6, 8, . . .},	aj	∈	R,	βj	∈	RD;	, δ are the relevant PAC learning constants,
and A0 represents an over-parameterized, randomly initialized two-layer MLP trained with gradient
descent.
P ,	4	C(Pj Pj∣aj∣kβjkPj+log(1∕δ)
Cao (g, e, δ) = O I ---------M------------
15
Under review as a conference paper at ICLR 2021
It is not immediately clear, however, how to use this theorem to learn an arbitrary monomial xδ
since g has the above particular form. Nevertheless we show how it can be generalized to this case.
Let B = {β ∈ ND | ∣β∣ ≤ n}, and note that there are N = (nDD) elements in B. We assume some
fixed ordering in B is prescribed. Define the sample matrix (multivariate Vandemonde) V ∈ RN ×N
by Vα,β = βα . Lemma 2.8 in (Wendland, 2004) implies that V is non-singular. Let cn,D =
Il V-1∣∣∞ (i.e., the induced '∞ matrix norm); note that cn,D is dependant only upon n, D.
Lemma 1. Fix D, n ∈ N, and let δ ∈ B be arbitrary. Then, there exist coefficients a ∈ RN,
kak1 ≤ cn,D, so that xδ = β∈B aβ (hβ, xi + 1)n , for all x ∈ RD.
Proof. Using the multinomial theorem we have: (hβ, xi + 1)n = Pα∈B dαβαxα, where dα are
positive multinomial coefficients. This equation defines a linear relation between the monomial
basis xδ and (hβ, xi + 1)n , for β ∈ B. The matrix of this system is V multiplied by a positive
diagonal matrix with dα on its diagonal. By inverting this matrix and solving this system for xδ the
lemma is proved.	□
We can use this Lemma in the following way: Assume n is even or otherwise consider 2dn/2e.
Further assume that the MLP m :RD+1
→ R is two-layer, over-parameterized of the form m(x, 1)
(i.e., we assume there is a constant 1 plugged in an extra D + 1 coordinate). We consider training m
with random initialization and gradient descent using data (x, xδ) ∈ RD × R where x is sampled
i.i.d. from some distribution D over RD.
Let g : RD+1 → R defined as g(x, xD+1) = Pβ∈B aβ (hβ, xi + xD+1)n , where a ∈ RN
is as promised by Lemma 1. Then, the learning setup described above is equivalent to training
the MLP m(x, xD+1) using data of the form ((x, 1), g(x, 1) = xδ), where (x, 1) is sampled
i.i.d. from a distribution D0 over RD+1 concentrated on the hyperplane xD+1 = 1. Now us-
ing the Corollary 6.2 from (Arora et al., 2019) in our case where g : RD+1 → R is defined as
g(x,xD+ι) = Pβ∈B aβ (hβ, Xi + xD+ι)n where B = {β ∈ ND | ∣β∣≤ n} and by Lemma 1
there exist a such that g(x, 1) = xδ. The sample complexity bound expression by Corollary 6.2 is
therefore:
(Pβ∈B n ∣aβ ∣∣∣β∣∣n + log(1∕δ)∖	ʌ
Ca，(g, e, δ) = O ---------------------------------- I , β = (β, 1)
Let us bound the first term in the numerator of the sample complexity expression:
XDn/2
β2 + 1	≤ n ∙ (n2 + 1)"/2 X ∣aβI ≤ (n + l)(n+1”2 c„,D
β∈B
The first inequality is due to ∣∣∙k2 ≤ ∣∣∙kι, the second is by Lemma 1 and uniting n into the main
term. From the above, the bound follows.
16
Under review as a conference paper at ICLR 2021
F Kernel Definition
Let x, y ∈ Rd the kernel function were defined in the following manner -
(i)	Polynomial Kernel - km(x, y) = (hx, yi + 1)m
(ii)	Exponential Kernel - k(x,y) = exp( h√yi)
(iii)	RBF Kernel - k(x,y) = exp(- kx√yk )
Lets XQ,XK,∈ Rn×d where XQ = {(x1Q)T,...,(xnQ)T} and XV = {(x1V)T,..., (xVn)T} de-
notes the attention Query and Key matrices. For a given kernel function k we define the attention
matrix S ∈ Rn×n in the following way -
S _	k(XQ,χK)
i,j = pn=ι k(χQ,χK)
G Rank Ablation S tudy
We investigated the affects of the attention’s
rank κ on the performance of GNNs augmented
with LRGA on the CLUSTER dataset. The
dataset contains graphs of 40 to 190 nodes (117
nodes in average). Our experimental setting
included fixing the GNN’s hidden dimensions
size and changing κ. Figure 1 shows that ac-
curacy increases with the rank values until it
reaches a plateau around K ≈ 30 (κ∕n = 0.25
where n is the average graph size), a fact that
could be attributed to saturating the expressive-
ness of the LRGA module. Moreover, the max-
imal accuracy is achieved at a value that corre-
sponds to the maximal graph size in the dataset,
smaller than what the theory predicts as a func-
tion of the graph size n. This rank value is
enough to compute any attention function on
this graph collection.
Figure 1: Ablation study on CLUSTER dataset. The
X-axis represent the ratio between the rank parameter
K and the average graph size n = 117. The Y-axis
represent the network’s accuracy
H Implementation Details
In this section we describe the datasets on which we performed our evaluation. In addition, we
specify the hyperparameters for the experiments section in the paper. The rest of the model con-
figurations are determined directly by the evaluation protocols defined by the benchmarks. It is
worth noting that most of our experiments ran on a single Tesla V-100 GPU, if not stated other-
wise. We performed our parameter search only on κ and d (except for CIFAR10 and MNIST were
we searched over different dropout values), since the rest of the parameters were dictated by the
evaluation protocol. The models sizes were restricted by the allowed parameter budget.
H.1 Benchmarking Graph Neural Networks (Dwivedi et al., 2020)
Datasets. This benchmark contains 6 main datasets :
(i)	ZINC, a molecular graphs dataset with a graph regression task where each node represents
an atom and each edge represents a bond. The regression target is a property known as the
constrained solubility (with mean absolute error as evaluation metric). Additionally, the node
features represent the atom’s type (28 types) and the edge features represents the type of con-
nection (4 types). The result reported for GCN used d = 60 for the 100K budget and d = 90
17
Under review as a conference paper at ICLR 2021
(network’s depth is L = 12) for the 500K budget. For the GAT network we used d = 60 (4
attention heads of dimension 15) for the 100K budget and d = 120 (4 attention heads of di-
mension 30) with L = 8 for the 500K budget. For the GatedGCN network we used d = 45 for
the 100K budget and d = 60 with L = 12 for the 500K budget. All the models used κ = 30.
(ii)	MNIST and CIFAR10, the known image classification problem is converted to a graph clas-
sification task using Super-pixel representation (Knyazev et al., 2019), which represents small
regions of homogeneous intensity as nodes. The edges in the graph are obtained by applying
k-nearest neighbor algorithm on the nodes coordinates. Node features are a concatenation of
the Super-pixel intensity (RGB for CIFAR10 and greyscale for MNIST) and its image coor-
dinate. Edges features are the k-nearest distances. The result reported for GCN used d = 60
for the 100K budget and d = 110 with L = 8 for the 500K budget. For the GAT network we
used d = 60 (4 attention heads of dimension 15) for the 100K budget and d = 122 (4 attention
heads of dimension 28) with L = 8 for the 500K budget. For the GatedGCN network we used
d = 45 for the 100K budget and d = 80 with L = 8 for the 500K budget. All the models used
κ = 30.
(iii)	CLUSTER and PATTERN, node classification tasks which aim to identify embedded node
structures in stochastic block model graphs (Abbe, 2017). The goal of the task is to assign
each node to the stochastic block it was originated from, while the structure of the graph
is governed by two probabilities that define the inner-structure and cross-structure edges. A
single representative from each block is assigned with an initial feature that indicates its block
while the rest of the nodes have no features (CLUSTER), while in the PATTERN dataset nodes
are assigned with a random value as input feature at the creation stage. The result reported for
GCN used d = 60 for the 100K budget and d = 100 with L = 8 for the 500K budget
(PATTERN, CLUSTER respectively). For the GAT network we used d = 60 (4 attention
heads of dimension 15) for the 100K budget and d = 120, 60 (8 attention heads of dimension
15, 4 attention heads of dimension 15) with L = 8, 12 for the 500K budget (PATTERN,
CLUSTER respectively). For the GatedGCN network we used d = 45 for the 100K budget
andd = 80, 50 with L = 8, 12 for the 500K budget (PATTERN, CLUSTER respectively). All
the models used κ = 30.
(iv)	TSP, a link prediction task that tries to tackle the NP-hard classical Traveling Salesman Prob-
lem (Joshi et al., 2019). Given a 2D Euclidean graph the goal is to choose the edges that
participate in the minimal edge weight tour of the graph. The evaluation metric for the task
is F1 score for the positive class. The result reported for GCN used d = 60 . For the GAT
network we used d = 60 (4 attention heads of dimension 15). For the GatedGCN network we
used d = 45. All the models used κ = 30.
H.2 Link prediction datasets from the OGB benchmark (Hu et al., 2020)
Datasets. In order to provide a more complete evaluation of our model we also evaluate it on
semi-supervised learning tasks of link prediction. We searched over the same hyperparameter range
κ ∈ {25, 50, 100} , d ∈ {150, 256} and used κ = 50, d = 256 in all tasks. The three datasets were:
(i)	ogbl-ppa, an undirected unweighted graph. Nodes represent types of proteins and the edges
signify biological connections between proteins. The initial node feature is a 58-dimensional
one-hot-vector that indicates the origin specie of the protein. The learning task is to predict
new connections between nodes. The train/validation/test split sizes are 21M/6M/3M . The
evaluation metric is called Hits@K (Hu et al., 2020).
(ii)	ogbl-collab, is a graph that represents a network of collaborations between authors. Every au-
thor in the network is represented by a node and each collaboration is assigned with an edge.
Initial node features are obtained by combining word embeddings of papers by that author
(128-dimensional vector). Additionally, each collaboration is described by the year of collab-
oration and the number of collaborations in that year as a weight. The train/validation/test split
sizes are 1.1M/60K/46K. Similarly to the previous dataset, the evaluation metric is Hits@K.
(iii)	ogbl-ddi - an undirected unwighted graph which represent drug-drug interaction. Each Node
represents FDA approved or experimental drug. The edges represent interactions between
drugs and represent the joint effect of taking both drugs together. The learning task is to
predict new drug to drug interactions. The train/validation/test split sizes are 1M/150K/150K.
The evaluation here is also Hits@K.
18