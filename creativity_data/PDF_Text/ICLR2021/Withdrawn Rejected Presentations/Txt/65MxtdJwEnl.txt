Under review as a conference paper at ICLR 2021
Neural CDEs for Long Time Series via the
Log-ODE Method
Anonymous authors
Paper under double-blind review
Ab stract
Neural Controlled Differential Equations (Neural CDEs) are the continuous-time
analogue of an RNN, just as Neural ODEs are analogous to ResNets. However
just like RNNs, training Neural CDEs can be difficult for long time series. Here,
we propose to apply a technique drawn from stochastic analysis, namely the log-
ODE method. Instead of using the original input sequence, our procedure sum-
marises the information over local time intervals via the log-signature map, and
uses the resulting shorter stream of log-signatures as the new input. This repre-
sents a length/channel trade-off. In doing so we demonstrate efficacy on problems
of length up to 17k observations and observe significant training speed-ups, im-
provements in model performance, and reduced memory requirements compared
to the existing algorithm.
1	Introduction
Neural controlled differential equations (Neural CDEs) (Kidger et al., 2020) are the continuous-time
analogue to a recurrent neural network (RNN), and provide a natural method for modelling temporal
dynamics with neural networks.
Neural CDEs are similar to neural ordinary differential equations (Neural ODEs), as popularised by
Chen et al. (2018). A Neural ODE is determined by its initial condition, without a direct way to
modify the trajectory given subsequent observations. In contrast the vector field of a Neural CDE
depends upon the time-varying data, so that the trajectory of the system is driven by a sequence of
observations.
1.1	Controlled Differential Equations
We begin by stating the definition of a CDE.
Let a, b ∈ R with a < b, and let v, w ∈ N. Let ξ ∈ Rw . Let X : [a, b] → Rv be a continuous function
of bounded variation (which is for example implied by it being Lipschitz), and let f : Rw → Rw×v
be continuous.
Then we may define Z : [a, b] → Rw as the unique solution of the controlled differential equation
Za = ξ,
Zt = Za + Z tf(Zs)dXs
a
for t ∈ (a, b],
(1)
The notation “f(Zs)dXs” denotes a matrix-vector product, and if X is differentiable then
Rat f (Zs)dXs = Rt f (Zs) dS (S)ds.
If in equation (1), dXs was replaced with ds, then the equation would just be an ODE. Using dXs
causes the solution to depend continuously on the evolution of X . We say that the solution is “driven
by the control, X”.
1.2	Neural Controlled Differential Equations
We recall the definition of a Neural CDE as introduced in Kidger et al. (2020).
1
Under review as a conference paper at ICLR 2021
Consider a time series x as a collection of points xi ∈ Rv-1 with corresponding time-stamps ti ∈ R
such that x = ((t0, x0), (t1, x1), ..., (tn, xn)), and t0 < ... < tn.
Let X : [t0, tn] → Rv be some interpolation of the data such that Xti = (ti, xi). Kidger et al. (2020)
use natural cubic splines. Here we will actually end up finding piecewise linear interpolation to be a
more convenient choice. (We avoid issues with adaptive solvers as discussed in Kidger et al. (2020,
Appendix A) simply by using fixed solvers.)
Let ξθ : Rv → Rw and fθ : Rw → Rw×v be neural networks. Let `θ : Rw → Rq be linear, for some
output dimension q ∈ N. Here θ is used to denote dependence on learnable parameters.
We define Z as the hidden state and Y as the output of a neural controlled differential equation
driven by X if
Zto =	ξθ(to,xo),	with Zt =	Zto	+ Z	fθ(Zs)dXs	and	Yt =	'θ(Zt)	for t ∈	(to,tn].⑵
t0
That is - just like an RNN - We have evolving hidden state Z, which We take a linear map from
to produce an output. This formulation is a universal approximator (Kidger et al., 2020, Appendix
B). The output may be either the time-evolving Yt or just the final Ytn. This is then fed into a loss
function (L2, cross entropy, . . . ) and trained via stochastic gradient descent in the usual way.
The question remains how to compute the integral of equation (2). Kidger et al. (2020) let
dX
gθ,x (Z,s) = fθ (Z )ɪ (s)
(3)
where the right hand side denotes a matrix multiplication, and then note that the integral can be
written as
t
gθ,x (Zs, s)ds.	(4)
o
This reduces the CDE to an ODE, so that existing tools for Neural ODEs may be used to evaluate
this, and to backpropagate.
Zt = Zto +
t
By moving from the discrete-time formulation of an RNN to the continuous-time formulation of a
Neural CDE, then every kind of time series data is put on the same footing, whether it is regularly
or irregularly sampled, whether or not it has missing values, and whether or not the input sequences
are of consistent length.
Besides this, the continuous-time or differential equation formulation may be useful in applications
where such models are explicitly desired, as when modelling physics.
1.3	Contributions
Neural CDEs, as with RNNs, begin to break down for long time series. Training loss/accuracy
worsens, and training time becomes prohibitive due to the sheer number of forward operations within
each training epoch.
Here, we apply the log-ODE method, which is a numerical method from stochastic analysis and
rough path theory. It is a method for converting a CDE to an ODE, which may in turn be solved via
standard ODE solvers. Thus this acts as a drop-in replacement for the original procedure that uses
the derivative of the control path.
In particular, we find that this method is particularly beneficial for long time series (and incidentally
does not require differentiability of the control path). With this method both training time and model
performance of Neural CDEs are improved, and memory requirements are reduced.
The resulting scheme has two very neat interpretations. In terms of numerical differential equation
solvers, this corresponds to taking integration steps larger than the discretisation of the data, whilst
incorporating substep information through additional terms1. In terms of machine learning, this
corresponds to binning the data prior to running a Neural CDE, with bin statistics carefully chosen
to extract precisely the information most relevant to solving a CDE.
1For the reader familiar with numerical methods for SDEs, this is akin to the additional correction term in
Milstein’s method as compared to Euler-Maruyama.
2
Under review as a conference paper at ICLR 2021
Hidden state Zt
Integration
steps
Hidden state Zt
ooooo∞oooooooooooo---x∞∞∞oo∞o} SntpgratiOn
Path X
f
Data x
Time
r。	ri	r	r3 ∙∙∙ rm-2	rm-1	rm
Log-signature path
,÷
LogSigri,ri+1(X)
t
Path X
f
Data x
* Time
Figure 1: Left: The original Neural CDE formulation. The path X is quickly varying, meaning a lot
of integration steps are needed to resolve it. Right: The log-ODE method. The log-signature path is
more slowly varying (in a higher dimensional space), and needs fewer integration steps to resolve.
2	Theory
We begin with motivating theory, though we note that this section is not essential for using the
method. Readers more interested in practical applications should feel free to skip to section 3.
2.1	Signatures and Log-signatures
The signature transform is a map from paths to a vector of real values, specifying a collection of
statistics about the path. It is a central component of the theory of controlled differential equations,
since these statistics describe how the data interacts with dynamical systems. The log-signature is
then formed by representing the same information in a compressed format.
We begin by providing a formal definition of the signature, and a description of the log-signature.
We will then give some intuition, first into the geometry of the first few terms of the (log-)signature,
and then by providing a short example of how these terms appear when solving CDEs.
Signature transform Let x = (x1, ..., xn), where xi ∈ Rv. Let T > 0 and 0 = t1 < t2 <
... < tn-1 < tn = T be arbitrary. Let X = (X1, ..., Xd) : [0, T] → Rd be the unique continu-
ous function such that X (ti) = xi and is affine on the intervals between (essentially just a linear
interpolation of the data). Letting2
k dXij
Sarik (X)=	… Y -t- O )dt,	(5)
j=1
0<t1 <...<tk <T =
then the depth-N signature transform of X is given by
SigNb(X) = ({S(X)(i)}d=ι, {S(x产叫dj=ι,..., {S(x产,…，iN)}∖,..,iN=1).	(6)
This definition is independent of the choice of T andti (Bonnier et al., 2019, Proposition A.7).
We see that the signature is a collection of integrals, with each integral defining a real value. It
is a graded sequence of statistics that characterise the input time series. In particular, (Hambly &
Lyons, 2010) show that under mild conditions, Sig∞(X) completely determines X up to translation
(provided time is included in a channel in X).
Log-signature transform However, the signature transform has some redundancy: a little algebra
shows that for example Sa1,,b2(X) + Sa2,,b1(X) = Sa1,b(X)Sa2,b(X), so that for instance we already
know Sa2,,b1 (X ) provided we know the other three quantities.
2This is a slightly simplified definition, and the signature is often instead defined using the notation of
stochastic calculus; see Definition A.2.
3
Under review as a conference paper at ICLR 2021
X2
Data, x
X2
Path, X
X1
Log-signature
∙=	∆X1	:	IDePth 1
∙=	∆X2	l	
∙=	A+ - A-:	I Depth 2
■ Higher order
∆X2
X1
Figure 2: Geometric intuition for the first two levels of the log-signature for a 2-dimensional path.
The depth 1 terms correspond to the change in each of the coordinates over the interval. The depth 2
term corresponds to the Levy area of the path, this being the signed area between the curve and the
chord joining its start and endpoints.
The log-signature transform is then essentially obtained by computing the signature transform, and
throwing out redundant terms, to obtain some (nonunique) minimal collection.
Starting from the depth-N signature transform and removing some fixed set of redundancies pro-
duces the depth-N log-signature transform.3 We denote this LogSigaN,b, which is a map from Lip-
schitz continuous paths [a, b] → Rv into Rβ(v,N), where β(v, N) denotes the dimension of the
log-signature. The precise procedure is a little involved; both this and a formula for β(v, N) can be
found in Appendix A.
Geometric intuition In figure 2 we provide a geometric intuition for the first two levels of the
log-signature (which have particularly natural interpretations).
(Log-)Signatures and CDEs (Log-)signatures are intrinsically linked to solutions of CDEs. Let
Df denote the Jacobian of a function f. Now expand equation (1) by linearising the vector field f
and neglecting higher order terms:
Zt ≈ Za + Z (f (Za) + Df(Za)(Zs - Za))	(S)ds
Zs	dX	dX
f (Zu) ^d^ (U) du) ~d^ (S) ds
≈ Za + f (Za) / ^d^ (S) ds + Df(Za)f (Za)
苧(U) du ddX (S) ds
Za + f4){S(X )(i)}d=1 + Df(Za)f(Za){S(X 产叫j=「
(7)
This gives a Taylor expansion of the solution, and moreover the coefficients involve the terms in the
signature. Higher order Taylor expansions results in corrections using higher order signature terms.
We refer the reader to section 7.1 of Friz & Victoir (2010) for further details.
2.2	The Log-ODE Method
Recall for X : [a, b] → Rv that LogSigaN,b(X) ∈ Rβ(v,N). The log-ODE method states
Zb ≈ Zbb
u	LogSigaNb (X)
where Zu = Za +	f (Zbs)——--,——-ds,
a	b-a
and Za = Za .
(8)
where Z is as defined in equation (2), and the relationship between f to f is given in Appendix A.
That is, the solution of the CDE may be approximated by the solution to an ODE. In practice, we go
further and pick some points r such that a = r0 < ri < •一 < rm/ = b. We split UP the CDE of
3Similar terminology such as “step-N log-signature” is also used in the literature.
4
Under review as a conference paper at ICLR 2021
equation (1) into an integral over [r0, r1], an integral over [r1, r2], and so on, and apply the log-ODE
method to each interval separately.
See Appendix A for more details and Appendix B for a proof of convergence.
Also see Janssen (2011); Lyons (2014); Boutaib et al. (2014) for other discussions of the log-ODE
method. See Gaines & Lyons (1997); Gyurko & Lyons (2008); Flint & Lyons (2015); Foster et al.
(2020) for applications of the log-ODE method to stochastic differential equations (SDEs).
3	Method
We move on to discussing the application of the log-ODE method to Neural CDEs.
Recall that we observe some time series x = ((t0, x0), (t1, x1), ..., (tn, xn)), and have constructed
a piecewise linear interpolation X : [t0, tn] → Rv such that Xti = (ti, xi).
We now pick points r such that to = ro < ri < •…< rm = tn. In principle these can be variably
spaced but in practice we will typically space them equally far apart. The total number of points m
should be much smaller than n.
In section 2 the log-signature transform was introduced. To recap, for X : [t0, tn] → Rv and t0 ≤
ri < ri+1 ≤ tn the depth-N log-signature of X over the interval [ri, ri+1] is some collection of
statistics LogSigrNi,ri+1 (X) ∈ Rβ(v,N).
In particular, these statistics are precisely those most relevant for solving the CDE equation (1).
3.1	Updating the Neural CDE Hidden State Equation via the Log-ODE Method
Recall how the Neural CDE formulation of equation (2) was solved via equations (3), (4). For the
log-ODE approach we replace (3) with the piecewise
LogSigN	(X)
bθ,x(Z,s)= fθ(Z) —r+:+1	for S ∈ [r-i,ri+i),	(9)
where fbθ : Rw → Rw×β(v,N) is an arbitrary neural network, and the right hand side denotes a
matrix-vector product between fθ and the log-signature. Equation (4) then becomes
t
gbθ,X (Zs, s)ds.	(10)
0
This may now be solved as a (neural) ODE using standard ODE solvers.
Zt = Zt0 +
t
3.2	Relationship to the Original Method
Suppose we happened to choose ri = ti and ri+1 = ti+1. Then the log-signature term is
LOgSigN,ti+1 (X )
ti+1 - ti
(11)
The depth 1 the log-signature is just the increment of the path over the interval, and so this becomes
△X[ti,ti+l]
ti+1 - ti
dX linear
dt
(ti)
for s ∈ [ti, ti+1),
(12)
that is to say the same as obtained via the original method if using linear interpolation.
3.3	Discussion
Ease of Implementation This method is straightforward to implement using pre-existing tools.
There are standard libraries available for computing the log-signature transform; we use Signatory
(Kidger & Lyons, 2020b). Then, as equation (10) is an ODE, it may be solved directly using tools
such as torchdiffeq (Chen, 2018).
5
Under review as a conference paper at ICLR 2021
As an alternative, we note that the formulation in equation (11) can be written in precisely the
same form as equation (3), with the driving path taken to be piecewise linear in log-signature space.
Computation of the log-signatures can therefore be considered as a preprocessing step, producing
a sequence of logsignatures. From this we may construct a path in log-signature space, and apply
existing tools for neural CDEs. This idea is summarised in figure 1. We make this approach available
in the [redacted] open source project.
Structure of f The description here aligns with the log-ODE scheme described in equation (8).
There is one discrepancy: we do not attempt to model the specific structure of f . This is in prin-
ciple possible, but is computationally expensive. Instead, we model f as a neural network directly.
This need not necessarily exhibit the requisite structure, but as neural networks are universal ap-
proximators (Pinkus, 1999; Kidger & Lyons, 2020a) then this approach is at least as general from a
modelling perspective.
Lossy Representation The log-signature transform can be thought of as a lossy representation for
time series. This is made rigorous in Diehl et al. (2020), where it is shown that the log-signature
can be obtained by iterating an “area” operation between paths. For CDEs, these geometric features
precisely encode the interaction between the data and the system.
Length/Channel Trade-Off The sequence of log-signatures is now of length m, which was cho-
sen to be much smaller than n. As such, it is much more slowly varying over the interval [t0 , tn] than
the original data, which was of length n. The differential equation it drives is better behaved, and so
larger integration steps may be used in the numerical solver. This is the source of the speed-ups of
this method; we observe typical speed-ups by a factor of about 100.
Each element is a log-signature of size β(v, N) ≥ v; the additional channels are higher-order cor-
rections to compensate for the larger integration steps.
Generality of the Log-ODE Method If depth N = 1 and steps ri = ti are used, then the above
formulation exactly reduces onto the original Neural CDE formulation using linear interpolation.
Thus the log-ODE method in fact generalises the original approach.
Applications In principle the log-ODE method may be applied to solve any Neural CDE. In prac-
tice, the reduction in length (from n to m), coupled with the loss of information (from using the
log-signature as a summary statistic) makes this particularly useful for long time series.
Memory Efficiency Long sequences need large amounts of memory to perform backpropagation-
through-time (BPTT). As with the original Neural CDEs, the log-ODE approach supports memory-
efficient backpropagation via the adjoint equations, alleviating this issue. See Kidger et al. (2020).
The Depth and Step Hyperparameters To solve a Neural CDE accurately via the log-ODE
method, we should be prepared to take the depth N suitably large, or the intervals ri+1 - ri suitably
small. Accomplishing this would realistically require that they are taken very large or very small,
respectively. Instead, we treat these as hyperparameters. This makes use of the log-ODE method a
modelling choice rather than an implementation detail.
Increasing step size will lead to faster (but less informative) training by reducing the number of
operations in the forward pass. Increasing depth will lead to slower (but more informative) training,
as more information about each local interval is used in each update.
4	Experiments
We investigate solving a Neural CDE with and without the log-ODE method on four real-world
problems. Every problem was chosen for its long length. The lengths are in fact sufficiently long
that adjoint-based backpropagation (Chen et al., 2018) was needed to avoid running out of memory
at any reasonable batch size. Every problem is regularly sampled, so we take ti = i.
6
Under review as a conference paper at ICLR 2021
Model	Step	Test Accuracy (%)	Time (Hrs)	Memory (Mb)
	1	62.4 ± 12.1	22.0	176.5
NCDE1	8	64.1 ± 13.3	3.1	24.3
	32	64.1 ± 14.3	0.5	8.0
	128	48.7 ± 2.6	0.1	3.9
	8	77.8 ± 5.9	2.1	94.2
NCDE2	32	67.5 ± 12.1	0.7	28.1
	128	76.1 ± 5.9	0.2	7.8
		^70.1 ± 6.5	1.3	460.7
NCDE3	32	75.2 ± 3.0	0.6	134.7
	128	68.4 ± 8.2	0.1	53.3
Table 1: Mean and standard deviation of test set accuracy (in %) over three repeats, as well as
memory usage and training time, on the EigenWorms dataset for depths 1-3 and a small selection
of step sizes. The bold values denote that the model was the top performer for that step size.
Figure 3: Left: Heatmap of normalised accuracies on the EigenWorms dataset for differing step
sizes and depths. Right: Log-log plot of the elapsed time of the algorithm against the step size.
We will denote a Neural CDE model with log-ODE method, using depth N and step s, as NCDEsN .
Taking N = 1 (and any s) corresponds to not using the log-ODE method, with the data subsampled
at rate 1/s, as per section 3.3. Thus we use NCDE11 as our benchmark: no subsampling, no log-ODE
method.
In principle we could compare against RNN variants. This is for simple practical reasons: RNN-
based models do not fit in the memory of the GPU resources we have available. This is one of the
main advantages of using differential equation models in the first place, for which adjoint backprop-
agation is available. (As per the first paragraph of this section.)
Each model is run three times and we report the mean and standard deviation of the test metrics
along with the mean training times and memory usages.
For each task, the hyperparameters were selected by performing a grid search on the NCDEs1 model,
where s was chosen so that the length of the sequence was 500 steps. This was found to create a
reasonable balance between training time and sequence length. (Doing hyperoptimisation on the
baseline NCDE11 model would have been more difficult due to the larger training times.)
Precise details of the experiments can be found in Appendices C and D.
4.1	Classifying EigenWorms
Our first example uses the EigenWorms dataset from the UEA archive from Bagnall et al. (2017).
This consists of time series of length 17 984 and 6 channels (including time), corresponding to the
movement of a roundworm. The goal is to classify each worm as either wild-type or one of four
mutant-type classes.
7
Under review as a conference paper at ICLR 2021
Depth	Step	RR	L2 HR	Spθ2	Time (H)			Memory (Mb)
					RR	HR	SpO2	
	1	2.79 ± 0.04	9.82 ± 0.34	2.83 ± 0.27	23.8	22.1	28.1	56.5
NCDE1	8	2.80 ± 0.06	10.72 ± 0.24	3.43 ± 0.17	3.0	2.6	4.8	14.3
	32	2.53 ± 0.23	12.23 ± 0.43	2.68 ± 0.12	1.9	0.9	2.2	9.8
	128	2.64 ± 0.18	11.98 ± 0.37	2.86 ± 0.04	0.2	0.2	0.3	8.7
	8	2.63 ± 0.12	8.63 ± 0.24	2.88 ± 0.15	2.1	3.4	3.3	21.8
NCDE2	32	1.90 ± 0.02	7.90 ± 1.00	1.69 ± 0.20	1.2	1.1	2.0	13.1
	128	1.86 ± 0.03	6.77 ± 0.42	1.95 ± 0.18	0.3	0.4	0.7	10.9
	^ Y^	2.42± 0.19 ^	F6 一±而厂	2.55 ±-0?13—	一2.9一	一—3£一一	3.1^	43^3
NCDE3	32	1.67 ± 0.01	4.50 ± 0.70	1.61 ± 0.05	1.3	1.8	7.3	20.5
	128	1.51 ± 0.08	2.97 ± 0.45	1.37 ± 0.22	0.5	1.7	1.7	17.3
Table 2: Mean and standard deviation of the L2 losses on the test set for each of the vitals signs
prediction tasks (RR, HR, SpO2) on the BIDMC dataset, across three repeats. Only mean times
are shown for space. The memory usage is given as the mean over all three of the tasks as it was
approximately the same for any task for a given depth and step. The bold values denote the algorithm
with the lowest test set loss for a fixed step size for each task.
Figure 4: Heatmap of normalised losses on the three BIDMC datasets for differing step sizes and
depths.
See Table 1. We see that the straightforward NCDE11 model takes roughly a day to train. Using
the log-ODE method (NCDE2, NCDE3) speeds this up to take roughly minutes. Doing so addi-
tionally improves model performance dramatically, and reduces memory usage. Naive subsampling
8	32	128
approaches (NCDE18, NCDE312 , NCDE1128) only achieve speed-ups without performance improve-
ments, this can be seen in the NCDE1 column which corresponds to naive subsampling for a step
size greater than 1.
We notice that the NCDE3 model has faster training times than the depth 2 model (and sometimes
better then depth 1) over each step size. This is due to the fact we imposed a stopping criterion if
the loss failed to decrease after 60 epochs, meaning that the NCDE3 has converged with less epochs
(time per epoch will still be larger though).
See also Figure 3, in which we summarise results for a larger range of step sizes.
4.2	Estimating Vitals Signs from PPG and ECG data
Next we consider the problem of estimating vital signs from PPG and ECG data. This comes
from the TSR archive (Tan et al., 2020) using data from the Beth Israel Deaconess Medical Centre
(BIDMC). We consider three separate tasks, in which we aim to predict a person’s respiratory rate
(RR), their heart rate (HR), and their oxygen saturation (SpO2). This data is sampled at 125Hz with
each series having a length of 4 000. There are 7 949 training samples, and 3 channels (including
time).
We train a model on each of the three vitals sign prediction tasks. The metric used to evaluate
performance is the L2 loss. The results over a range of step sizes are presented in table (2). We also
provide heatmaps in Figure 4 for each dataset containing the loss values (normalised to [0, 1]) for
each task. The full results over all step sizes may be found in Appendix D.
We find that the depth 3 model is the top performer for every task at any step size. What’s more,
it does so with a significantly reduced training time. We attribute the improved performance to
8
Under review as a conference paper at ICLR 2021
the log-ODE model being better able to learn long-term dependencies due to the reduced sequence
length. Note that the performance of the NCDEs2, NCDEs3 models actually improves as the step size
is increased. This is in contrast to NCDEs1, which sees a degradation in performance.
5	Limitations of the Log-ODE Method
Number of hyperparameters TWo new hyperparameters - truncation depth and step size - with
substantial effects on training time and memory usage must now also be tuned.
Number of input channels The log-ODE method is most feasible for low numbers of input chan-
nels, as the number of log-signature channels β(v, N) grows exponentially in v.
6	Related Work
There has been some work on long time series for classic RNN (GRU/LSTM) models.
Wisdom et al. (2016); Jing et al. (2019) show that unitary or orthogonal RNNs can mitigate the
vanishing/exploding gradients problem. However, they are expensive to train due to the need to
compute a matrix inversion at each training step. Chang et al. (2017) introduce dilated RNNs with
skip connections between RNN states, which help improve training speed and learning of long-
term dependencies. Campos et al. (2017) introduce the ‘Skip-RNN’ model, which extend the RNN
by adding an additional learnt component that skips state updates. Li et al. (2018) introduce the
‘IndRNN’ model, with particular structure tailored to learning long time series.
One important comparison is to hierarchical subsampling as in Graves (2012); De Mulder et al.
(2015). There the data is split into windows, an RNN is run over each window, and then an additional
RNN is run over the first RNN’s outputs; we may describe this as an RNN/RNN pair. Liao et al.
(2019) then perform the equivalent operation with a log-signature/RNN pair. In this context, our use
of log-ODE method may then be described as a log-signature/NCDE pair.
In comparison to Liao et al. (2019), this means moving from an inspired choice of pre-processing
to an actual implementation of the log-ODE method. In doing so the differential equation structure
is preserved. Moreover this takes advantage of the synergy between log-signatures (which extract
statistics on how data drives differential equations), and the controlled differential equation it then
drives. Broadly speaking these connections are natural: at least within the signature/CDE/rough path
community, it is a well-known but poorly-published fact that (log-)signatures, RNNs and (Neural)
CDEs are all related; see for example Kidger et al. (2020) for a little exposition on this.
CNNs and Transformers have been shown to offer improvements over RNNs for modelling long-
term dependencies (Bai et al., 2018; Li et al., 2019). However, both can be expensive in their own
right; Transformers are famously O(L2) in the length of the time series L. Whilst several approaches
have been introduced to reduce this, for example Li et al. (2019) reduce this to O(L(log L)2), this
can still be difficult with long series. Extensions specifically to long sequences do exist (Sourkov,
2018), but these typically focus on language modelling rather than multivariate time series data.
De Brouwer et al. (2019); Lechner & Hasani (2020) amongst others consider continuous time ana-
logues of GRUs and LSTMs, going some way to improving the learning of long-term dependencies.
Voelker et al. (2019); Gu et al. (2020) consider links with ODEs and approximation theory, to im-
prove the long-term memory capacity of RNNs.
7	Conclusion
We demonstrate how to effectively apply Neural CDEs to long (17k) time series, via the log-ODE
method. The model may still be solved via ODE methods and thus retains adjoint backpropagation
and continuous dynamics. In doing so we see significant training speed-ups, improvements in model
performance, and reduced memory requirements.
9
Under review as a conference paper at ICLR 2021
References
Anthony Bagnall, James Lines, Aaron Bostrom, James Large, and Eamonn Keogh. The great time
series classification bake off: a review and experimental evaluation of recent algorithmic ad-
Vances. Data Mining and Knowledge Discovery, 31:606-660, 2017.
Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional
and recurrent networks for sequence modeling. arXiv preprint arXiv:1803.01271, 2018.
Patric Bonnier, Patrick Kidger, Imanol Perez Arribas, Cristopher Salvi, and Terry Lyons. Deep
Signature Transforms. Advances in Neural Information Processing Systems, 2019.
Youness Boutaib, Lajos Gergely Gyurko, Terry Lyons, and DanyU Yang. Dimension-free EUler
estimates of rough differential equations. Revue Roumaine de Mathmatiques Pures et Appliques,
59, 2014.
Victor Campos, Brendan Jou, Xavier Giro-i Nieto, Jordi Torres, and Shih-Fu Chang. Skip RNN:
Learning to Skip State Updates in Recurrent Neural Networks. arXiv preprint arXiv:1708.06834,
2017.
Shiyu Chang, Yang Zhang, Wei Han, Mo Yu, Xiaoxiao Guo, Wei Tan, Xiaodong Cui, Michael
Witbrock, Mark A Hasegawa-Johnson, and Thomas S Huang. Dilated recurrent neural networks.
In Advances in Neural Information Processing Systems, pp. 77-87, 2017.
Ricky T. Q. Chen.	torchdiffeq, 2018. https://github.com/rtqichen/
torchdiffeq.
Ricky T. Q. Chen, Yulia Rubanova, Jesse Bettencourt, and David Duvenaud. Neural Ordinary Dif-
ferential Equations. Advances in Neural Information Processing Systems, 2018.
Edward De Brouwer, Jaak Simm, Adam Arany, and Yves Moreau. Gru-ode-bayes: Continuous
modeling of sporadically-observed time series. In Advances in Neural Information Processing
Systems, pp. 7379-7390, 2019.
Wim De Mulder, Steven Bethard, and Marie-Francine Moens. A survey on the application of re-
current neural networks to statistical language modeling. Computer Speech & Language, 30(1):
61-98, 2015.
Joscha Diehl, Terry Lyons, Rosa Preiβ, and Jeremy Reizenstein. Areas of areas generate the shuffle
algebra. arXiv preprint arXiv:2002.02338, 2020.
Guy Flint and Terry Lyons. Pathwise approximation of SDEs by coupling piecewise abelian rough
paths. arXiv preprint arXiv:1505.01298, 2015.
James Foster, Harald Oberhauser, and Terry Lyons. An optimal polynomial approximation of Brow-
nian motion. SIAM Journal on Numerical Analysis, 58(3):1393-1421, 2020.
Peter K Friz and Nicolas B Victoir. Multidimensional stochastic processes as rough paths: theory
and applications, volume 120. Cambridge University Press, 2010.
Jessica G Gaines and Terry J Lyons. Variable step size control in the numerical solution of stochastic
differential equations. SIAM Journal on Applied Mathematics, 57(5):1455-1484, 1997.
Alex Graves. Supervised sequence labelling. In Supervised sequence labelling with recurrent neural
networks, pp. 5-13. Springer, 2012.
Albert Gu, Tri Dao, Stefano Ermon, Atri Rudra, and Christopher Re. HiPPO: Recurrent Memory
with Optimal Polynomial Projections. arXiv:2008.07669, 2020.
Lajos Gergely Gyurko. Numerical methods for approximating solutions to rough differential equa-
tions. DPhil thesis, University of Oxford, 2008.
Lajos Gergely GyUrkO and Terry Lyons. Rough paths based numerical algorithms in computational
finance. Mathematics in Finance: UIMP-RSME Lluis A. Santalo Summer School, 2008.
10
Under review as a conference paper at ICLR 2021
Ben Hambly and Terry Lyons. Uniqueness for the signature of a path of bounded variation and the
reduced path group. Annals of Mathematics, 171, 2010.
Arend Janssen. Order book models, signatures and numerical approximations of rough differential
equations. PhD thesis, University of Oxford, 2011.
Li Jing, Caglar Gulcehre, John Peurifoy, Yichen Shen, Max Tegmark, Marin Soljacic, and Yoshua
Bengio. Gated orthogonal recurrent units: On learning to forget. Neural computation, 31(4):
765-783, 2019.
Patrick Kidger and Terry Lyons. Universal Approximation with Deep Narrow Networks. COLT
2020, 2020a.
Patrick Kidger and Terry Lyons. Signatory: differentiable computations of the signature and
logsignature transforms, on both CPU and GPU. arXiv:2001.00706, 2020b. URL https:
//github.com/patrick-kidger/signatory.
Patrick Kidger, James Morrill, James Foster, and Terry Lyons. Neural controlled differential equa-
tions for irregular time series. arXiv preprint arXiv:2005.08926, 2020.
Mathias Lechner and Ramin Hasani. Learning long-term dependencies in irregularly-sampled time
series. arXiv preprint arXiv:2006.04418, 2020.
Shiyang Li, Xiaoyong Jin, Yao Xuan, Xiyou Zhou, Wenhu Chen, Yu-Xiang Wang, and Xifeng
Yan. Enhancing the locality and breaking the memory bottleneck of transformer on time series
forecasting. In Advances in Neural Information Processing Systems, pp. 5243-5253, 2019.
Shuai Li, Wanqing Li, Chris Cook, Ce Zhu, and Yanbo Gao. Independently recurrent neural network
(indrnn): Building a longer and deeper rnn. In Proceedings of the IEEE conference on computer
vision and pattern recognition, pp. 5457-5466, 2018.
Shujian Liao, Terry Lyons, Weixin Yang, and Hao Ni. Learning stochastic differential equations
using RNN with log signature features. arXiv preprint arXiv:1908.08286, 2019.
Terry Lyons. Rough paths, signatures and the modelling of functions on streams. Proceedings of
the International Congress of Mathematicians, 4, 2014.
Terry Lyons, Caruana Michael, and Levy Thierry. Differential equations driven by rough paths. In
一 一 一 ^ _ _ . _ _ _ _ . 一.一一 一. . .. _ _
Ecole d'ete de Probabilites de Samt-FloUr XXXIV-2004, edited by J. Picard m Volume 1908 of
Lecture Notes in Mathematics, Berlin, Springer, 2007.
Allan Pinkus. APProximation theory of the MLP model in neural networks. Acta Numer., 8:143-
195, 1999.
Jeremy Reizenstein. Calculation of Iterated-Integral Signatures and Log Signatures. arXiv preprint
arXiv:1712.02757, 2017.
Raymond A. Ryan. Introduction to Tensor Products of Banach Spaces. SPringer MonograPhs in
Mathematics, SPringer, 2002.
Vsevolod Sourkov. Igloo: Slicing the features sPace to rePresent sequences. arXiv preprint
arXiv:1807.03402, 2018.
Chang Wei Tan, Anthony Bagnall, ChristoPh Bergmeir, Eamonn Keogh, Francois Petitjean, and
Geoffrey I. Webb. Monash university, uea, ucr time series regression archive, 2020. http:
//timeseriesregression.org/.
Aaron Voelker, Ivana Kajic, and Chris Eliasmith. Legendre memory units: Continuous-time repre-
sentation in recurrent neural networks. In Advances in Neural Information Processing Systems
32. Curran Associates, Inc., 2019.
Scott Wisdom, Thomas Powers, John Hershey, Jonathan Le Roux, and Les Atlas. Full-capacity
unitary recurrent neural networks. In Advances in neural information processing systems, pp.
4880-4888, 2016.
Eugene Wong and Moshe Zakai. On the Convergence of Ordinary Integrals to Stochastic Integrals.
Annals of Mathematical Statistics, 36(5):1560-1564, 1965.
11
Under review as a conference paper at ICLR 2021
Supplementary material
In sections A and B, we give a more thorough introduction to solving CDEs via the log-ODE method.
In section C we discuss the experimental details such as the choice of network structure, computing
infrastructure and hyperparameter selection approach.
In section D we give a full breakdown of every experimental result.
A	An introduction to the log-ODE method for controlled
DIFFERENTIAL EQUATIONS
The log-ODE method is an effective method for approximating the controlled differential equation:
dYt = f(Yt)dXt,	(13)
Y0 = ξ,
where X : [0, T] → Rd has finite length, ξ ∈ Rn and f : Rn → L(Rd, Rn) is a function with certain
smoothness assumptions so that the CDE (13) is well posed. Throughout these appendices, L(U, V )
denotes the space of linear maps between the vector spaces U and V . In rough path theory, the
function f is referred to as the “vector field” of (13) and usually assumed to have Lip(γ) regularity
(see definition 10.2 in Friz & Victoir (2010)). In this section, we assume one of the below conditions
on the vector field:
1.	f is bounded and has N bounded derivatives.
2.	f is linear.
In order to define the log-ODE method, we will first consider the tensor algebra and path signature.
Definition A.1 We say that T (Rd) := R ㊉ Rd ㊉(Rd)02 ㊉∙∙∙ 2S the tensor algebra of Rd and
T((Rd))= {a = (a0,a1,…):ak ∈ (Rd)0k ∀k ≥ 0} is the Setofformalseriesoftensorsof Rd.
Moreover, T Rd and T Rd can be endowed w2th the operat2ons of add2t2on and mult2pl2cat2on.
Given a = (a0, aι, •…)and b = (bo, bi, ∙∙∙), we have
a + b = (ao + bo,ai + bi,…),	(14)
a 0 b = (c0,cι,c2,…),	(15)
Wherefor n ≥ 0, the n-th term Cn ∈ (Rd )0n can be written using the usual tensor product as
n
cn :=	ak 0 bn-k.
k=0
The operation 0 given by (15) is often referred to as the “tensor product”.
Definition A.2 The signature of a finite length path X : [0, T] → Rd over the interval [s, t] is
defined as the following collection of iterated (Riemann-Stieltjes) integrals:
(i)	(2)	(3)	d
Ss,t (X ) : = (1 ,Xs,t , Xs,t , X s,t , ∙∙j ∈ T R (R / / ,
(16)
where for n ≥ 1,
Xsn) ：=	Z …/ dXuι 0 …0 dXun ∈ (Rd)0".
S‹Ul<∙∙∙<Un‹t
Similarly, we can define the depth-N (or truncated) signature of the path X on [s, t] as
(17)
where TN (Rd) := R ㊉ Rd ㊉(Rd)02 ㊉.…㊉(Rd)0N denotes the truncated tensor algebra.
12
Under review as a conference paper at ICLR 2021
The (truncated) signature provides a natural feature set that describes the effects a path X has on
systems that can be modelled by (13). That said, defining the log-ODE method actually requires the
so-called “log-signature” which efficiently encodes the same integral information as the signature.
The log-signature is obtained from the path’s signature by removing certain algebraic redundancies,
such as
dXuidXsj+	dXujdXsi =XtiXtj,
00	00
for i,j ∈ {1,…，d}, which follows by the integration-by-parts formula. To this end, We will define
the logarithm map on the depth-N truncated tensor algebra TN (Rd) := R ㊉ Rd ㊉•…㊉(Rd产N.
Definition A.3(The logarithm of a formal series) For a = (ao,aι,…)∈ T((Rd)) with ao > 0,
define log(a) to be the element of T Rd given by the following series:
<∞ (-1)n / a λ0n
log(a) := log(ao) + E--------(1------)
n=1	n	a0
(18)
where 1 = (1,0,…)is the unit element of T( (Rd)) and log(a0) is viewed as log(ao)1.
Definition A.4 (The logarithm of a truncated series) For a = (ao,aι,…,aN) ∈ T( (Rd)) with
a0 > 0, define logN (a) to be the element ofTN Rd defined from the logarithm map (18) as
IogN (a):= PN (log(α)),	(19)
where e := (ao, aι, ∙∙∙ , a N, 0, .…)∈ T( (Rd)) and PN denotes the standard projection mapfrom
T ((Rd)) onto TN (Rd).
Definition A.5 The log-signature of a finite length path X : [0, T] → Rd over the interval [s, t] is
defined as LogSigs,t (X) := log(Ss,t(X)), where Ss,t (X) denotes the path signature ofX given by
Definition A.2. Likewise, the depth-N (or truncated) log-signature ofX is defined for each N ≥ 1
as LogSigsN,t(X) := logN(SsN,t(X)).
The log-signature is a map from X : [0, T] → Rd → Rβ(d,N). The exact form of β(d, N) is given
by
β(d,N ) = X k X μ (k)d
k=1	i|k
with μ the MObiUS function. We note that the order of this remains an open question.
The final ingredient we use to define the log-ODE method are the derivatives of the vector field f .
It is worth noting that these derivatives also naturally appear in the Taylor expansion of (13).
Definition A.6 (Vector field derivatives) We define f ◦k : Rn → L((Rd产k, Rn) recursively by
f。⑼(y) := y,
f。⑴(y) := f (y),
f°(k+1)(y) := D(f◦k)(y)f(y),
for y ∈ Rn, where D(f ◦k) denotes the Frechet derivative of f ◦k.
Using these definitions, we can describe two closely related numerical methods for the CDE (13).
Definition A.7 (The Taylor method) Given the CDE (13), we can use the path signature of X to
approximate the solution Y on an interval [s, t] via its truncated Taylor expansion. That is, we use
N
Taylor(K,f,SNt(X)) := Xf°k(K)∏k(Sf/X)),	(20)
k=0
as an approximation for Y where each πk : T N (Rd) → (Rd)Rk is the projection map onto (Rd)室 k.
13
Under review as a conference paper at ICLR 2021
Figure 5: Illustration of the log-ODE and Taylor methods for controlled differential equations.
Definition A.8 (The Log-ODE method) Using the Taylor method (20), we can define the function
f : Rn → L(T N (Rd), Rn) by f (z) := Taylor(z,f, ∙). By applying f to the truncated log-signature
of the path X over an interval [s, t], we can define the following ODE on [0, 1]
dz = f(z)LogSigNt(X),
du	s,
z(0) = Ys.
Then the log-ODE approximation of Yt (given Ys and LogSigsN,t(X)) is defined as
LogODE(Ys, f, LogSigsN,t(X)) := z(1).
(21)
(22)
N
Remark A.9 Our assumptions of f ensure that z 7→ f (z)LogSigsN,t (X) is either globally bounded
and Lipschitz continuous or linear. Hence both the Taylor and log-ODE methods are well defined.
Remark A.10 It is well known that the log-signature of a path X lies in a certain free Lie algebra
(this is detailed in section 2.2.4 of Lyons et al. (2007)). Furthermore, it is also a theorem that the
Lie bracket of two vector fields is itself a vector field which doesn’t depend on choices of basis.
By expressing LogSigsN,t (X) using a basis of the free Lie algebra, it can be shown that only the
vector field f and its (iterated) Lie brackets are required to construct the log-ODE vector field
fb(z)LogSigsN,t(X). In particular, this leads to our construction of the log-ODE (8) using the Lyndon
basis of the free Lie algebra (see Reizenstein (2017) for a precise description of the Lyndon basis).
We direct the reader to Lyons (2014) and Boutaib et al. (2014) for further details on this Lie theory.
To illustrate the log-ODE method, we give two examples:
Example A.11 (The “increment-only” log-ODE method) When N = 1, the ODE (21) becomes
dz
du
f(z)Xs,t,
z(0) = Ys .
Therefore we see that this “increment-only” log-ODE method is equivalent to driving the original
CDE (13) by a piecewise linear approximation of the control path X. This is a classical approach
for stochastic differential equations (i.e. when Xt = (t, Wt) with W denoting a Brownian motion)
and is an example of a Wong-Zakai approximation (see Wong & Zakai (1965) for further details).
Example A.12 (An application for SDE simulation) Consider the following affine SDE,
dYt = a(b - yt) dt + σyt ◦ dWt,	(23)
y(0) = y0 ∈ R≥0 ,
14
Under review as a conference paper at ICLR 2021
where a, b ≥ 0 are the mean reversion parameters, σ ≥ 0 is the volatility and W denotes a standard
real-valued Brownian motion. The ◦ means that this SDE is understood in the Stratonovich sense.
The SDE (23) is known in the literature as Inhomogeneous Geometric Brownian Motion (or IGBM).
Using the control path X = {(t, Wt)}t≥0 and setting N = 3, the log-ODE (21) becomes
dU = a(b — Zu )h + σ ZuWs,t — abσ As,t + abσ2LS,t + a2bσ Lsjt,
z(0) = Ys .
where h := t - s denotes the step size and the random variables As,t, L(s1,t), L(s2,t) are given by
As,t := Z Ws,r dr - 2hWs,t,
,v ◦ dWv dr- 2Ws,tAs,t- 6hWS2,t,
Wsv dvdr - 2hAs,t - 6h2Ws,t.
In Foster et al. (2020), the depth-3 log-signature of X = {(t, Wt)}t≥0 was approximated so that
the above log-ODE method became practical and this numerical scheme exhibited state-of-the-art
convergence rates. For example, the approximation error produced by 25 steps of the high order
log-ODE method was similar to the error of the “increment only” log-ODE method with 1000 steps.
B Convergence of the log-ODE method for rough differential
EQUATIONS
In this section, we shall present “rough path” error estimates for the log-ODE method. In addition,
we will discuss the case when the vector fields governing the rough differential equation are linear.
We begin by stating the main result of Boutaib et al. (2014) which quantifies the approximation error
of the log-ODE method in terms of the regularity of the systems vector field f and control path X .
Since this section uses a number of technical definitions from rough path theory, we recommend
Lyons et al. (2007) as an introduction to the subject.
For T > 0, we will use the notation 4T := {(s, t) ∈ [0, T]2 : s < t} to denote a rescaled 2-simplex.
Theorem B.1 (Lemma 15 in Boutaib et al. (2014)) Consider the rough differential equation
dYt = f(Yt)dXt,	(24)
Y0 = ξ,
where we make the following assumptions:
• X is a geometric p-rough path in Rd, that is X : 4T → T bpc (Rd) is a continuous path in
the tensor algebra Tbpc (Rd) := R ㊉ Rd ㊉(Rd广2 ㊉.…㊉(RdLbpc With increments
(1)	(2)	(bpc)
Xs,t = 11, Xs,t , Xs,t ,…，Xs,t b	(25)
Xst := ∏k(Xs,t),
where ∏k : Tbpc (Rd) → (Rd『k is the projection map onto (Rd)0k, Such that there
exists a sequence of continuous finite variation paths xn : [0, T] → Rd whose truncated
signatures converge to X in the p-variation metric:
dpSbpc(xn),X →0,	(26)
as n → ∞, where the p-variation between two continuous paths Z1 and Z2 in Tbpc (Rd) is
dp(Z 1,Z2) := max sup ( X 卜k(Z1i,ti+ι)-πk(Z2i,ti+ι)∣∣k)P,	(2T)
1≤k≤bpc D
15
Under review as a conference paper at ICLR 2021
where the supremum is taken over all partitions D of [0, T ] and the norms ∣∣ ∙ ∣∣ must satisfy
(up to some constant)
ka ㊈ bk ≤ kakkbk,
for a ∈ (Rd产n and b ∈ (Rd产m. For example, we can take ∣∣ ∙ ∣∣ to be the projective or
injective tensor norms (see Propositions 2.1 and 3.1 in Ryan (2002)).
•	The solution Y and its initial value ξ both take their values in Rn.
•	The collection of vector fields {fι,…，fd} on Rn are denoted by f : Rn → L(Rn, Rd),
where L(Rn , Rd ) is the space of linear maps from Rn to Rd. We will assume that f has
Lip(γ) regularity with γ > p. That is, f it is bounded with bγc bounded derivatives, the
last being Holder continuous with exponent (Y — [γ[). Hence thefollowing norm is finite:
∣f∣Lip(γ) :
0≤maXγC HD fU∞ ∨ UDbYcfu(Y-bY」)-Hol,
(28)
where Dkf is the k-th (Frechet) derivative of f and ∣∣ ∙ ∣∣α-HoI is the standard a-HoIder
norm with α ∈ (0, 1).
•	The RDE (24) is defined in the Lyon’s sense. Therefore by the Universal Limit Theorem
(see Theorem 5.3 in Lyons et al. (2007)), there exists a unique solution Y : [0, T] → Rn.
We define the log-ODE for approximating the solution Y over an interval [s, t] ⊂ [0, T] as follows:
1.	Compute the depth-bγc log-signature of the control path X over [s, t]. That is, we obtain
LogSigbYc (X ):= log bγc (Ssbγtc (X)) ∈ T bγc (Rd), where log[γc (∙) is defined by projecting
the standard tensor logarithm map onto {a ∈ TbYc (Rd) : π0(a) > 0}.
2.	Construct the following (well-posed) ODE on the interval [0, 1],
dzs,t
ʃ = F D,	(29)
du
z0s,t = Ys ,
where the vector field F : Rn → Rn is defined from the log-signature as
bYc
F(z) ：= X f ◦k(z)∏k (LogSigbYc(X)).	(30)
k=1
Recall that f ◦k : Rn → L((Rd 产k, Rn) was defined previously in DefinitionA.6.
Then we can approximate Yt using the u = 1 solution of (29). Moreover, there exists a universal
constant Cp,Y depending only on p and γ such that
僮-z；1l ≤ Cp,Y∣f∣Yip(Y)∣X∣Y-var；[s,t],	(31)
where ∣∣ ∙ ∣∣p-vαr ；卜,力 is the P-VariatiOn norm defined for paths in T bpc (Rd) by
k
∣∣x∣∣p-var",t] := ι≤maxcsup(X IlXti,ti+ι∣∣k) ,	(32)
ti∈D
with the supremum taken over all partitions D of [s, t].
Remark B.2 Ifthe vector fields {fι, ∙∙∙ , fd} are linear, then it immediately follows that F is linear.
Although the above theorem requires some sophisticated theory, it has a simple conclusion - namely
that log-ODEs can approximate controlled differential equations. That said, the estimate (31) does
not directly apply when the vector fields {fi} are linear as they would be unbounded. Fortunately,
it is well known that linear RDEs are well posed and the growth of their solutions can be estimated.
16
Under review as a conference paper at ICLR 2021
Theorem B.3 (Theorem 10.57 in Friz & Victoir (2010)) Consider the linear RDE on [0, T]
dYt = f(Yt)dXt,
Y0 = ξ,
where X is a geometric p-rough path in Rd, ξ ∈ Rn and the vector fields {fi}1≤i≤d take the form
fi (y) = Aiy + B where {Ai } and {Bi } are n × n matrices. Let K denote an upper bound on
maxi(kAik + kBik). Then a unique solution Y : [0, T] → Rn exists. Moreover, it is bounded and
there exists a constant Cp depending only on p such that
kYt - Ysk ≤ Cp(l+ kξk)KkXkp一即[s,t] exp (CpKPkXkp-Var；[s,t]),	(33)
for all 0 ≤ s ≤ t ≤ T.
When the vector fields of the RDE (24) are linear, then the log-ODE (29) also becomes linear.
Therefore, the log-ODE solution exists and is explicitly given as the exponential of the matrix F .
Theorem B.4 Consider the same linear RDE on [0, T] as in Theorem B.3,
dYt = f(Yt)dXt,
Y0 = ξ.
Then the log-ODE vector field F given by (30) is linear and the solution of the associated ODE (29)
exists and satisfies
bγc
kzus,tk ≤ kYskexp X Kmπm(LogSigbs,γtc(X)	,	(34)
m=1
for u ∈ [0, 1] and all 0 ≤ s ≤ t ≤ T.
Proof B.5 Since F is a linear vector field on Rn, we can view it as an n × n matrix and so for
u ∈ [0, 1],
zus,t = exp(uF)z0s,t,
where exp denotes the matrix exponential. The result now follows by the standard estimate
k exp(F)k ≤ exp(kF k).
Remark B.6 Due to the boundedness of linear RDEs (33) and log-ODEs (34), the arguments that
established Theorem B.1 will hold in the linear setting as kfkLip(γ) would be finite when defined on
the domains that the solutions Y and z lie in.
Given the local error estimate (31) for the log-ODE method, we can now consider the approximation
error that is exhibited by a log-ODE numerical solution to the RDE (24). Thankfully, the analysis
required to derive such global error estimates was developed by Greg GyUrko in his PhD thesis.
Thus the following result is a straightforward application of Theorem 3.2.1 from Gyurko (2008).
Theorem B.7 Let X, f and Y satisfy the assumptions given by Theorem B.1 and suppose that
{0 = to < tι < … < tN = T} is a partition of [0,T] with max k ∣∣X∣∣p-Var；[tk,tk+i] sufficiently
small. We can construct a numerical solution {Yk }0≤k≤N of (24) by setting Y0log := Y0 and for
each k ∈ {0,1,…，N — 1} ,defining YlO+gι to be the solution at U = 1 of the following ODE:
dz tk,tk+1
du
:= F ztk,tk+1 ,
(35)
ztk ,tk+1 := Ylog
where the Vector field F is constructed from the log-signature of X oVer the interVal [tk, tk+1]
according to (30). Then there exists a constant C depending only on p, γ and kf kLip(γ) such that
k-1
M- YkkI ≤ C X kx∣Y-var；[ti,ti+i],	(36)
i=0
for 0 ≤ k ≤ N.
17
Under review as a conference paper at ICLR 2021
n layers
IX Y
UZ =ndso
IXQp C
Linear
+ reshape
Matrix multiplication
ODE Solve
IXd UjmIUOPPIH
ReLU Tanh
ijəa-uəp3H
ReLU
4 IndUT
IXQ H
<%
JOsυJ
-sm0j
Figure 6: Overview of the hidden state update network structure. We give the dimensions at each
layer in the top right hand corner of each box.
Remark B.8 The above error estimate also holds when the vector field f is linear (by Remark B.6)).
Since bγc is the truncation depth of the log-signatures used to construct each log-ODE vector field,
we see that high convergence rates can be achieved through using more terms in each log-signature.
It is also unsurprising that the error estimate (36) increases with the “roughness” of the control path.
So just as in our experiments, we see that the performance of the log-ODE method can be improved
by choosing an appropriate step size and depth of log-signature.
C Experimental details
Code The code to reproduce the experiments is available at [redacted; see supplementary material]
Data splits Each dataset was split into a training, validation, and testing dataset with relative sizes
70%/15%/15%.
Normalisation The training splits of each dataset were normalised to zero mean and unit variance.
The statistics from the training set were then used to normalise the validation and testing datasets.
Architecture We give a graphical description of the architecture used for updating the Neural
CDE hidden state in figure 6. The input is first run through a multilayer perceptron with n layers of
size h, with with n, h being hyperparameters. ReLU nonlinearities are used at each layer except the
final one, where we instead use a tanh nonlinearity. The goal of this is to help prevent term blow-up
over the long sequences.
Note that this is a small inconsistency between this work and the original model proposed in Kidger
et al. (2020). Here, we applied the tanh function as the final hidden layer nonlinearity, whilst in the
original paper the tanh nonlinearity is applied after the final linear map. Both methods are used to
constrain the rate of change of the hidden state; we do not know of a reason to prefer one over the
other.
Note that the final linear layer in the multilayer perceptron is reshaped to produce a matrix-valued
output, of shape v × p. (As fbθ is matrix-valued.) A matrix-vector multiplication with the log-
signature then produces the vector field for the ODE solver.
ODE Solver All problems used the ‘rk4’ solver as implemented by torchdiffeq (Chen, 2018)
version 0.0.1.
18
Under review as a conference paper at ICLR 2021
Computing infrastructure All EigenWorms experiments were run on a computer equipped with
three GeForce RTX 2080 Ti’s. All BIDMC experiments were run on a computed with two GeForce
RTX 2080 Ti’s and two Quadro GP100’s.
Optimiser All experiments used the Adam optimiser. The learning rate was initialised at 0.032
divided by batch size. The batch size used was 1024 for EigenWorms and 512 for the BIDMC
problems. If the validation loss failed to decrease after 15 epochs the learning rate was reduced by a
factor of 10. If the validation loss did not decrease after 60 epochs, training was terminated and the
model was rolled back to the point at which it achieved the lowest loss on the validation set.
Hyperparameter selection Hyperparameters were selected to optimise the score of the NCDE1
model on the validation set. For each dataset the search was performed with a step size that meant the
total number of hidden state updates was equal to 500, as this represented a good balance between
length and speed that allowed us to complete the search in a reasonable time-frame. In particular,
this was short enough that we could train using the non-adjoint training method which helped to
speed this section up. The hyperparameters that were considered were:
•	Hidden dimension: [16, 32, 64] - The dimension of the hidden state Zt.
•	Number of layers: [2, 3, 4] - The number of hidden state layers.
•	Hidden hidden multiplier: [1, 2, 3] - Multiplication factor for the hidden hidden state, this
being the ‘Hidden layer k’ in figure 6. The dimension of each of these ‘hidden hidden’
layers with be this value multiplied by ‘Hidden dimension’.
We ran each of these 27 total combinations for every dataset and the parameters that corresponded
were used as the parameters when training over the full depth and step grid. The full results from
the hyperparameter search are listed in tables (3, 4) with bolded values to show which values were
eventually selected.
D	Experimental Results
Here we include the full breakdown of all experimental results. Tables 5 and 6 include all results
from the EigenWorms and BIDMC datasets respectively.
19
Under review as a conference paper at ICLR 2021
Validation accuracy	Hidden dim	Num layers	Hidden hidden multiplier	Total params
33.3	16	2	3	5509
43.6	16	2	2	5509
56.4	16	2	1	4453
64.1	16	3	2	8869
38.5	16	3	3	8869
51.3	16	3	1	6517
82.1	16	4	2	12741
35.9	16	4	3	12741
53.8	16	4	1	8581
35.9	32	2	3	21253
74.4	32	2	2	21253
43.6	32	2	1	17093
53.8	32	3	3	34629
87.2	32	3	2	34629
64.1	32	3	1	25317
35.9	32	4	3	50053
71.8	32	4	1	33541
79.5	32	4	2	50053
41.0	64	2	3	83461
64.1	64	2	2	83461
48.7	64	3	3	136837
59.0	64	3	2	136837
51.3	64	2	1	66949
56.4	64	4	2	198405
64.1	64	4	3	198405
64.1	64	3	1	99781
51.3	64	4	1	132613
Table 3: Hyperparamter selection results for the EigenWorms dataset. The blue values denote the
selected hyperparameters.
20
Under review as a conference paper at ICLR 2021
Validation loss			Hidden dim	Num layers	Hidden hidden multiplier	Total params
RR	HR	SpO2				
1.72	6.10	2.07	16	2	1	2209
1.57	5.58	1.97	16	2	2	3265
1.55	6.10	1.33	16	2	3	3265
1.80	5.16	2.05	16	3	1	3249
1.61	5.22	1.62	16	3	2	5601
1.56	3.34	1.18	16	3	3	5601
1.57	3.86	1.97	16	4	1	4289
1.45	3.54	1.25	16	4	2	8449
1.54	3.93	1.09	16	4	3	8449
1.56	6.81	1.87	32	2	1	8513
1.42	3.11	1.43	32	2	2	12673
1.54	3.60	1.11	32	2	3	12673
1.54	3.52	1.57	32	3	1	12641
1.39	2.96	1.03	32	3	2	21953
1.47	2.95	1.05	32	3	3	21953
1.55	3.00	2.00	32	4	1	16769
1.38	3.20	1.07	32	4	2	33281
1.43	2.58	1.01	32	4	3	33281
1.51	3.21	1.10	64	2	1	33409
1.43	2.22	1.00	64	2	2	49921
1.51	3.34	0.94	64	2	3	49921
1.55	3.24	2.09	64	3	1	49857
1.32	2.53	0.88	64	3	2	86913
1.25	2.57	0.73	64	3	3	86913
1.43	5.78	1.43	64	4	1	66305
1.28	2.26	0.93	64	4	2	132097
1.32	2.46	1.15	64	4	3	132097
Table 4: Hyperparameter selection results for each problem of the BIDMC dataset. The bold values
denote the selected hyperparameters for each vitals sign problem. Note that RR and SpO2 had the
same parameters selected, hence why only two lines are given in bold.
21
Under review as a conference paper at ICLR 2021
Model	Step	Test Accuracy	Time (Hrs)	Memory (Mb)
	1	62.4 ± 12.1	22.0	176.5
	2	69.2 ± 4.4	14.6	90.6
	4	66.7 ± 11.8	5.5	46.6
	6	65.8 ± 12.9	2.6	31.5
	8	64.1 ± 13.3	3.1	24.3
	16	64.1 ± 16.8	1.5	13.4
NCDE1	32	64.1 ± 14.3	0.5	8.0
	64	56.4 ± 6.8	0.4	5.2
	128	48.7 ± 2.6	0.1	3.9
	256	42.7 ± 3.0	0.1	3.2
	512	44.4 ± 5.3	0.0	2.9
	1024	41.9 ± 14.6	0.0	2.7
	2048	38.5 ± 5.1	0.0	2.6
	2	76.1 ± 13.2	9.8	354.3
	4	83.8 ± 3.0	2.4	180.0
	6	76.9 ± 6.8	2.0	82.2
	8	77.8 ± 5.9	2.1	94.2
	16	78.6 ± 3.9	1.3	50.2
NCDE2	32	67.5 ± 12.1	0.7	28.1
	64	73.5 ± 7.8	0.4	17.2
	128	76.1 ± 5.9	0.2	7.8
	256	72.6 ± 12.1	0.1	8.9
	512	69.2 ± 11.8	0.0	7.6
	1024	65.0 ± 7.4	0.0	6.9
	2048	67.5 ± 3.9	0.0	6.5
	^^2^^	^^ 66.7工 4.4―	7.4	1766.2
	4	76.9 ± 9.2	2.8	856.8
	6	70.9 ± 1.5	1.4	606.1
	8	70.1 ± 6.5	1.3	460.7
	16	73.5 ± 3.0	1.4	243.7
NCDE3	32	75.2 ± 3.0	0.6	134.7
	64	74.4 ± 11.8	0.3	81.0
	128	68.4 ± 8.2	0.1	53.3
	256	60.7 ± 8.2	0.1	40.2
	512	62.4 ± 10.4	0.0	33.1
	1024	59.8 ± 3.9	0.0	29.6
	2048	61.5 ± 4.4	0.0	27.7
Table 5: Mean and standard deviation of test set accuracy (in %) over three repeats, as well as
memory usage and training time, on the EigenWorms dataset for depths 1-3 and a small selection
of step sizes. The bold values denote that the model was the top performer for that step size.
22
Under review as a conference paper at ICLR 2021
Depth	Step	L2			Time (H)			Memory (Mb)
		RR	HR	Spθ2	RR	HR	SpO2	
	1	2.79 ± 0.04	9.82 ± 0.34	2.83 ± 0.27	23.8	22.1	28.1	56.5
	2	2.87 ± 0.03	11.69 ± 0.38	3.36 ± 0.2	19.3	9.6	8.8	32.6
	4	2.92 ± 0.08	11.15 ± 0.49	3.69 ± 0.06	5.3	5.7	3.2	20.2
	8	2.8 ± 0.06	10.72 ± 0.24	3.43 ± 0.17	3.0	2.6	4.8	14.3
	16	2.22 ± 0.07	7.98 ± 0.61	2.9 ± 0.11	1.7	1.4	1.8	11.8
NCDE1	32	2.53 ± 0.23	12.23 ± 0.43	2.68 ± 0.12	1.9	0.9	2.2	9.8
	64	2.63 ± 0.11	12.02 ± 0.09	2.88 ± 0.06	0.2	0.3	0.4	9.1
	128	2.64 ± 0.18	11.98 ± 0.37	2.86 ± 0.04	0.2	0.2	0.3	8.7
	256	2.53 ± 0.04	12.29 ± 0.1	3.08 ± 0.1	0.1	0.1	0.1	8.3
	512	2.53 ± 0.03	12.22 ± 0.11	2.98 ± 0.04	0.1	0.0	0.1	8.4
	1024	2.67 ± 0.12	11.55 ± 0.03	2.91 ± 0.12	0.1	0.1	0.1	8.4
	2048	2.48 ± 0.03	12.03 ± 0.2	3.25 ± 0.01	0.0	0.1	0.0	8.2
	2	2.91 ± 0.1	11.11 ± 0.23	3.89 ± 0.44	12.7	9.3	8.2	58.3
	4	2.92 ± 0.04	11.14 ± 0.2	4.23 ± 0.57	18.1	5.0	3.4	34.0
	8	2.63 ± 0.12	8.63 ± 0.24	2.88 ± 0.15	2.1	3.4	3.3	21.8
	16	1.8 ± 0.07	5.73 ± 0.45	1.98 ± 0.21	2.2	1.4	2.5	16.0
	32	1.9 ± 0.02	7.9 ± 1.0	1.69 ± 0.2	1.2	1.1	2.0	13.1
NCDE2	64	1.89 ± 0.04	5.54 ± 0.45	2.04 ± 0.07	0.3	0.3	1.7	11.6
	128	1.86 ± 0.03	6.77 ± 0.42	1.95 ± 0.18	0.3	0.4	0.7	10.9
	256	1.86 ± 0.09	5.64 ± 0.19	2.1 ± 0.19	0.1	0.1	0.5	10.5
	512	1.81 ± 0.02	5.05 ± 0.23	2.17 ± 0.18	0.1	0.2	0.4	10.3
	1024	1.93 ± 0.11	6.0 ± 0.19	2.41 ± 0.07	0.1	0.1	0.2	10.2
	2048	2.03 ± 0.03	7.7 ± 1.46	2.55 ± 0.03	0.1	0.1	0.1	10.2
	一2一	-2.82 ± 0.08-	li.of ± 028 一	-4.1 ± 访2 -	^8.8^	―--	"6.9"	125.2
	4	2.97 ± 0.23	10.13 ± 0.62	3.56 ± 0.44	3.2	4.1	2.6	71.6
	8	2.42 ± 0.19	7.67 ± 0.4	2.55 ± 0.13	2.9	3.2	3.1	43.3
	16	1.74 ± 0.05	4.11 ± 0.61	1.4 ± 0.06	1.4	1.4	6.5	29.1
	32	1.67 ± 0.01	4.5 ± 0.7	1.61 ± 0.05	1.3	1.8	7.3	20.5
NCDE3	64	1.53 ± 0.08	3.05 ± 0.36	1.48 ± 0.14	0.4	1.9	3.3	17.9
	128	1.51 ± 0.08	2.97 ± 0.45	1.37 ± 0.22	0.5	1.7	1.7	17.3
	256	1.51 ± 0.06	3.4 ± 0.74	1.47 ± 0.07	0.3	0.7	0.6	16.6
	512	1.49 ± 0.08	3.46 ± 0.13	1.29 ± 0.15	0.3	0.4	0.4	15.4
	1024	1.83 ± 0.33	5.58 ± 2.5	1.72 ± 0.31	0.2	0.1	0.1	15.7
	2048	2.31 ± 0.27	9.77 ± 1.53	2.45 ± 0.18	0.1	0.1	0.1	15.6
Table 6: Mean and standard deviation of the L2 losses on the test set for each of the vitals signs
prediction tasks (RR, HR, SpO2) on the BIDMC dataset, across three repeats. Only mean times
are shown for space. The memory usage is given as the mean over all three of the tasks as it was
approximately the same for any task for a given depth and step. The bold values denote the algorithm
with the lowest test set loss for a fixed step size for each task.
23