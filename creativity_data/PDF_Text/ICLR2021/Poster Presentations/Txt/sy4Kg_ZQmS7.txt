Published as a conference paper at ICLR 2021
Learning Deep Features in Instrumental
Variable Regression
Liyuan Xu
Gatsby Unit
liyuan.jo.19@ucl.ac.uk
Nando de Freitas
DeepMind
nandodefreitas@google.com
Arthur Gretton
Gatsby Unit
arthur.gretton@gmail.com
Yutian Chen
DeepMind
yutianc@google.com
Siddarth Srinivasan
University of Washington
sidsrini@cs.washington.edu
Arnaud Doucet
DeepMind
arnauddoucet@google.com
Abstract
Instrumental variable (IV) regression is a standard strategy for learning
causal relationships between confounded treatment and outcome variables
from observational data by using an instrumental variable, which affects
the outcome only through the treatment. In classical IV regression, learn-
ing proceeds in two stages: stage 1 performs linear regression from the
instrument to the treatment; and stage 2 performs linear regression from
the treatment to the outcome, conditioned on the instrument. We propose
a novel method, deep feature instrumental variable regression (DFIV), to
address the case where relations between instruments, treatments, and
outcomes may be nonlinear. In this case, deep neural nets are trained to
define informative nonlinear features on the instruments and treatments.
We propose an alternating training regime for these features to ensure good
end-to-end performance when composing stages 1 and 2, thus obtaining
highly flexible feature maps in a computationally efficient manner. DFIV
outperforms recent state-of-the-art methods on challenging IV benchmarks,
including settings involving high dimensional image data. DFIV also exhibits
competitive performance in off-policy policy evaluation for reinforcement
learning, which can be understood as an IV regression task.
1 Introduction
The aim of supervised learning is to obtain a model based on samples observed from some
data generating process, and to then make predictions about new samples generated from
the same distribution. If our goal is to predict the effect of our actions on the world, however,
our aim becomes to assess the influence of interventions on this data generating process.
To answer such causal questions, a supervised learning approach is inappropriate, since our
interventions, called treatments, may affect the underlying distribution of the variable of
interest, which is called the outcome.
To answer these counterfactual questions, we need to learn how treatment variables causally
affect the distribution process of outcomes, which is expressed in a structural function.
Learning a structural function from observational data (that is, data where we can observe,
but not intervene) is known to be challenging if there exists an unmeasured confounder,
which influences both treatment and outcome. To illustrate: suppose we are interested in
predicting sales of airplane tickets given price. During the holiday season, we would observe
the simultaneous increase in sales and prices. This does not mean that raising the price
1
Published as a conference paper at ICLR 2021
causes the sales to increase. In this context, the time of the year is a confounder, since it
affects both the sales and the prices, and we need to correct the bias caused by it.
One way of correcting such bias is via instrumental variable (IV) regression (Stock and
Trebbi, 2003). Here, the structural function is learned using instrumental variables, which
only affect the treatment directly but not the outcome. In the sales prediction scenario,
we can use supply cost shifters as the instrumental variable since they only affect the price
(Wright, 1928; Blundell et al., 2012). Instrumental variables can be found in many contexts,
and IV regression is extensively used by economists and epidemiologists. For example, IV
regression is used for measuring the effect of a drug in the scenario of imperfect compliance
(Angrist et al., 1996), or the influence of military service on lifetime earnings (Angrist, 1990).
In this work, we propose a novel IV regression method, which can discover non-linear causal
relationships using deep neural networks.
Classically, IV regression is solved by the two-stage least squares (2SLS) algorithm; we learn
a mapping from the instrument to the treatment in the first stage, and learn the structural
function in the second stage as the mapping from the conditional expectation of the treatment
given the instrument (obtained from stage 1) to the outcome. Originally, 2SLS assumes
linear relationships in both stages, but this has been recently extended to non-linear settings.
One approach has been to use non-linear feature maps. Sieve IV performs regression using
a dictionary of nonlinear basis functions, which increases in size as the number of samples
increases (Newey and Powell, 2003; Blundell et al., 2007; Chen and Pouzo, 2012; Chen
and Christensen, 2018). Kernel IV (KIV) (Singh et al., 2019) and Dual IV regression
(Muandet et al., 2020) use different (and potentially infinite) dictionaries of basis functions
from reproducing kernel Hibert spaces (RKHS). Although these methods enjoy desirable
theoretical properties, the flexibility of the model is limited, since all existing work uses
pre-specified features.
Another approach is to perform the stage 1 regression through conditional density estimation
(Carrasco et al., 2007; Darolles et al., 2011; Hartford et al., 2017). One advantage of this
approach is that it allows for flexible models, including deep neural nets, as proposed in
the DeepIV algorithm of (Hartford et al., 2017). It is known, however, that conditional
density estimation is costly and often suffers from high variance when the treatment is
high-dimensional.
More recently, Bennett et al. (2019) have proposed DeepGMM, a method inspired by the
optimally weighted Generalized Method of Moments (GMM) (Hansen, 1982) to find a
structural function ensuring that the regression residual and the instrument are independent.
Although this approach can handle high-dimensional treatment variables and deep NNs as
feature extractors, the learning procedure might not be as stable as the 2SLS approach,
since it involves solving a smooth zero-sum game, as when training Generative Adversarial
Networks (Wiatrak et al., 2019).
In this paper, we propose Deep Feature Instrumental Variable Regression (DFIV), which
aims to combine the advantages of all previous approaches, while avoiding their limitations.
In DFIV, we use deep neural nets to adaptively learn feature maps in the 2SLS approach,
which allows us to fit highly nonlinear structural functions, as in DeepGMM and DeepIV.
Unlike DeepIV, DFIV does not rely on conditional density estimation. Like sieve IV and
KIV, DFIV learns the conditional expectation of the feature maps in stage 1 and uses the
predicted features in stage 2, but with the additional advantage of learned features. We
empirically show that DFIV performs better than other methods on several IV benchmarks,
and apply DFIV successfully to off-policy policy evaluation, which is a fundamental problem
in Reinforcement Learning (RL).
The paper is structured as follows. In Section 2, we formulate the IV regression problem and
introduce two-stage least-squares regression. In Section 3, we give a detailed description of
our DFIV method. We demonstrate the empirical performance of DFIV in Section 4, covering
three settings: a classical demand prediction example from econometrics, a challenging IV
setting where the treatment consists of high-dimensional image data, and the problem of
off-policy policy evaluation in reinforcement learning.
2
Published as a conference paper at ICLR 2021
2 Preliminaries
2.1	Problem Setting of Instrumental Variable Regression
We begin with a description of the IV setting. We observe
a treatment X ∈ X, where X ⊂ RdX , and an outcome Y ∈
Y , where Y ⊂ R. We also have an unobserved confounder
that affects both X and Y . This causal relationship can be
represented with the following structural causal model:
Y = fstruct(X) + ε, E [ε] =0, E [ε∣X] = 0,	(1)
where fstruct is called the structural function, which we assume Figure 1: Causal Graph.
to be continuous, and ε is an additive noise term. This specific
confounding assumption is necessary for the IV problem. In Bareinboim and Pearl (2012), it
is shown that we cannot learn fstruct if we allow any type of confounders. The challenge is
that E [ε∣X] = 0, which reflects the existence of a ConfoUnder. Hence, We cannot use ordinary
supervised learning techniques since fstruct(x) 6= E [Y|X = x]. Here, we assume there is no
observable confounder but we may easily include this, as discussed in Appendix C.
To deal with the hidden confounder ε, we assume to have access to an instrumental variable
Z ∈ Z which satisfies the following assumption.
Assumption 1. The conditional distribution P(X|Z) is not constant in Z and E [ε∣Z] = 0.
Intuitively, Assumption 1 means that the instrument Z induces variation in the treatment
X but is uncorrelated with the hidden confounder ε. Again, for simplicity, we assume
Z ⊂ RdZ. The causal graph describing these relationships is shown in Figure 1.1. Note that
the instrument Z cannot have an incoming edge from the latent confounder that is also a
parent of the outcome.
Given Assumption 1, we can see that the function fstruct satisfies the operator equation
E [Y|Z] = E [fstruct (X)|Z] by taking expectation conditional on Z of both sides of (1).
Newey and Powell (2003) provide necessary and sufficient conditions, known as completeness
assumptions, to ensure identifiability of fstruct (X). Solving this equation, however, is known
to be ill-posed (Nashed and Wahba, 1974). To address this, recent works (Carrasco et al.,
2007; Darolles et al., 2011; Muandet et al., 2020; Singh et al., 2019) minimize the following
regularized loss L to obtain the estimate fstruct :
fStruct = argmin L(f), L(f )= EYZ [(Y - Eχ∣z [f(X )])2 ] + Ω(f),	(2)
f∈F
where F is an arbitrary space of continuous functions and Ω(f) is a regularizer on f.
2.2	Two Stage Least Squares Regression
A number of works (Newey and Powell, 2003; Singh et al., 2019) tackle the minimization
problem (2) using two-stage least squares (2SLS) regression, in which the structural function
is modeled as fstruct (x) = u>ψ(x), where u is a learnable weight vector and ψ(x) is a vector
of fixed basis functions. For example, linear 2SLS used the identity map ψ (x) = x, while
sieve IV (Newey and Powell, 2003) uses Hermite polynomials.
In the 2SLS approach, an estimate U is obtained by solving two regression problems succes-
sively. In stage 1, we estimate the conditional expectation EX|z [ψ(X)] as a function of z.
Then in stage 2, as EX|z [f(X)] = u>EX|z [ψ (X)], we minimize L with EX|z [f(X)] being
replaced by the estimate obtained in stage 1.
Specifically, we model the conditional expectation as EX|z [ψ(X)] = V φ(z), where φ(z) is
another vector of basis functions and V is a matrix to be learned. Again, there exist many
1 We show the simplest causal graph in Figure 1 It entails Z ⊥⊥ ε, but we only require Z and ε to
be uncorrelated in Assumption 1. Of course, this graph also says that Z is not independent of ε
when conditioned on observations X .
3
Published as a conference paper at ICLR 2021
choices for φ(z), which can be infinite-dimensional, but we assume the dimensions of ψ(x)
and φ(z) to be d1, d2 < ∞ respectively.
In stage 1, the matrix V is learned by minimizing the following loss,
V = argmin Lι(V), Lι(V) = Eχ,z [kΨ(X) - Vφ(Z)k2] + λj∣ V『,	(3)
V ∈Rd1 ×d2
where λ1 > 0 is a regularization parameter. This is a linear ridge regression problem with
multiple targets, which can be solved analytically. In stage 2, given V, We can obtain U by
minimizing the loss
U = arg min L2(u),
u∈Rd1
L2(u) = Ey,z [kY — u>Vφ(Z)k2] + λ2kuk2,
(4)
where λ2 > 0 is another regularization parameter. Stage 2 corresponds to a ridge linear
• C	r t f Γ7∖ 1 ʌ Z^	1 1	∙	1 1 C	1 ι ∙	f~∖ ∙	1 1 1	1
regression from Vφ(Z) to Y, and also enjoys a closed-form solution. Given the learned
weights U, the estimated structural function is fstrUct(X) = U>ψ(x).
3 DFIV Algorithm
In this section, we develop the DFIV algorithm. Similarly to Singh et al. (2019), we assume
that we do not necessarily have access to observations from the joint distribution of (X, Y, Z).
Instead, we are given m observations of (X, Z) for stage 1 and n observations of (Y, Z) for
stage 2. We denote the stage 1 observations as (xi, Zi) and the stage 2 observations as (yi, <¾).
If observations of (X, Y, Z) are given for both stages, we can evaluate the out-of-sample
losses, and these losses can be used for hyper-parameter tuning of λ1, λ2 (Appendix A).
DFIV uses the following models
fstruct(x) = U>ψθX (x)	and	EX|z [ψθX (X)] = VφθZ (z),	(5)
where U ∈ Rd1 and V ∈ Rd1×d2 are the parameters, and ψθX (x) ∈ Rd1 and φθZ (z) ∈ Rd2
are the neural nets parameterised by θX ∈ ΘX and θZ ∈ ΘZ , respectively. As in the original
2SLS algorithm, we learn EX|z [ψθX (X)] in stage 1 and fstruct(x) in stage 2. In addition to
the weights U and V, however, we also learn the parameters of the feature maps, θX and
θZ . Hence, we need to alternate between stages 1 and 2, since the conditional expectation
EX|z [ψθX (X)] changes during training.
Stage 1 Regression The goal of stage 1 is to estimate the conditional expectation
Eχ∣z [ψθχ (X)] ` Vφθz (Z) by learning the matrix V and parameter θz, with θχ = θχ given
and fixed. Given the stage 1 data (xi, zi), this can be done by minimizing the empirical
estimate of L1 ,
1m
V (m),θz=V ∈Rargdmθn .θzL1m)(V,θz ),L1m)=而 Xkψθχ (Xi)- Vφθz (Zi) k2+"H2
(6)
Note that the feature map ψ^χ (X) is fixed during stage 1, since this is the “target variable.”
If we fix θZ , the minimization problem (6) reduces to a linear ridge regression problem with
multiple targets, whose solution as a function of θX and θZ is given analytically by
V (m)(θχ ,θz ) = Ψ>Φ1(Φ>Φ1 + mλιI )-1,	⑺
where Φ1, Ψ1 are feature matrices defined as Ψ1 = [ψθX (X1), . . . , ψθX (Xm)]> ∈ Rm×d1
and Φ1 = [φθZ (Z1), . . . , φθZ (Zm)]> ∈ Rm×d2 . We can then learn the parameters θZ of the
adaptive features ψθz by minimizing the loss LIm) at V = V(m)(θχ,θz) using gradient
descent. For simplicity, we introduce a small abuse of notation by denoting as θz the result
of a user-chosen number of gradient descent steps on the loss (6) with V(m) (θχ, θz) from
(7), even though GZ need not attain the minimum of the non-convex loss (6). We then write
4
Published as a conference paper at ICLR 2021
V(m) := V(m)(θχ,θz). While this trick of using an analytical estimate of the linear output
weights of a deep neural network might not lead to significant gains in standard supervised
learning, it turns out to be very important in the development of our 2SLS algorithm. As
shown in the following section, the analytical estimate V(m)(θχ, θz) (now considered as a
function of θX ) will be used to backpropagate to θX in stage 2.
Stage 2 Regression In stage 2, we learn the structural function by computing the weight
vector U and parameter θχ while fixing θz = θz, and thus the corresponding feature map
φ^z (z). Given the data (yi, ∙¾), we can minimize the empirical version of L2, defined as
1n
U(n),θχ =	arg min	L2n∖u,θχ), Wn = -f® - u>V (m)Φ^z (Zi))2 + λ2kU∣2. (8)
u∈Rd1,θX ∈ΘX	n i=1
Again, for a given θX, we can solve the minimization problem (8) for u as a function of
V(m) := V(m)(θχ ,θz) by a linear ridge regression
U (n)(θχ ,θz) = (V gφ>Φ2(V (m))> + nλ2I )-1 V (m)Φ>y2,
where Φ2 = [φ^z (z1),..., φ^, (Zn )]> ∈ Rn×d2 and y = [y1,...,yn]> ∈ Rn.
(9)
The loss L(2n) explicitly depends on the parameters θX and we can backpropagate it to θX
via V(m)(θχ, θz), even though the samples of the treatment variable X do not appear in
stage 2 regression. We again introduce a small abuse of notation for simplicity, and denote by
θχ the estimate obtained after a few gradient steps on (8) with U(n)(θχ, θz) from (9), even
though θχ need not minimize the non-convex loss (8). We then have U(n) = U(n)(θχ, GZ).
After updating θχ
we need to update θz accordingly. We do not attempt to backpropagate
through the estimate θz to do this, however, as this would be too computationally expensive;
instead, we alternate stages 1 and 2. We also considered updating θX and θZ jointly to
optimize the loss L(2n) , but this fails, as discussed in Appendix F.
Computational Complexity and Convergence The computational complexity of the
algorithm is O(md1 d2 + d32) for stage 1, while stage 2 requires additional O(nd1 d2 + d13)
computations. This is small compared to KIV (Singh et al., 2019), which takes O(m3) and
O(n3), respectively. We can further speed up the learning by using mini-batch training
as shown in Algorithm 1. Here, V (mb) and U (nb) are the functions given by (7) and (9)
calculated using mini-batches of data. Similarly, L(1mb ) and L(1nb ) are the stage 1 and 2 losses
for the mini-batches. We recommend setting the batch size large enough so that V (mb), Unb)
do not diverge from V(m), U(n) computed on the entire dataset. Furthermore, we observe
that setting T1 > T2 , i.e. updating θZ more frequently than θX , stabilizes the learning
process.
In Appendix B, we provide regularity conditions under which the function learned by
DFIV converges to the true structural function in probability. The derivation is based on
Rademacher complexity bounds (Mohri et al., 2012).
4 Experiments
In this section, we report the empirical performance of the DFIV method. The evaluation
considers both low and high-dimensional treatment variables. We used the demand design
dataset of Hartford et al. (2017) for benchmarking in the low and high-dimensional cases,
and we propose a new setting for the high-dimensional case based on the dSprites dataset
(Matthey et al., 2017). In the deep RL context, we also apply DFIV to perform off-policy
policy evaluation (OPE). The network architecture and hyper-parameters are provided in
Appendix G. The algorithms in the first two experiments are implemented using PyTorch
(Paszke et al., 2019) and the OPE experiments are implemented using TensorFlow (Abadi
et al., 2015) and the Acme RL framework (Hoffman et al., 2020). The code is included in
the supplemental material.
5
Published as a conference paper at ICLR 2021
Algorithm 1 Deep Feature Instrumental Variable Regression
Input: Stage 1 data (xi,zj, Stage 2 data (y/i), Regularization parameters (λ1,λ2). Initial
values θX, θZ. Mini-batch size (mb, nb). Number of updates in each stage (T1, T2).
Output: Estimated structural function fstruct (x)
1:	repeat
2:	Sample mb stage 1 data (x(b), z(b)) and n stage 2 data (y(b), Zib)).
3:	for t = 1 to T1 do
4:	Return function V(mb)(θχ, θz) in ⑺ using (χib), zib))
5： Update θz — GZ - αVθzLImb)(V(mb)(θχ,θz),θz)或=θ,	\\ Stage 1 learning
6:	end for
7:	for t = 1 to T2 do
8:	Return function U inb)(θχ ,θz) in ⑼ using (y(b),Z(b)) and function V (mb )(θχ ,θz)
9：	Update GX - θχ - αVθxL(nbi(uι(nb)(θχ,θz),θχ)∣θχ一 =θx \\ Stage 2 learning
10:	end for
11:	until convergence
12： Compute U(n) := U^(n)(θχ, GZ) from ⑼ using entire dataset.
13: return f≡truct(X) = (U(n))>ψ^χ(x)
4.1	Demand Design Experiments
The demand design dataset is a synthetic dataset introduced by Hartford et al. (2017) that
is now a standard benchmarking dataset for testing nonlinear IV methods. In this dataset,
we aim to predict the demands on airplane tickets Y given the price of the tickets P . The
dataset contains two observable confounders, which are the time of year T ∈ [0, 10] and
customer groups S ∈ {1, ..., 7} that are categorized by the levels of price sensitivity. Further,
the noise in Y and P is correlated, which indicates the existence of an unobserved confounder.
The strength of the correlation is represented by ρ ∈ [0, 1]. To correct the bias caused by
this hidden confounder, the fuel price C is introduced as an instrumental variable. Details of
the data generation process can be found in Appendix E.1. In DFIV notation, the treatment
is X = P , the instrument is Z = C, and (T, S) are the observable confounders.
We compare the DFIV method to three leading modern competitors, namely KIV (Singh
et al., 2019), DeepIV (Hartford et al., 2017), and DeepGMM (Bennett et al., 2019). We used
the DFIV method with observable confounders, as introduced in Appendix C. Note that
DeepGMM does not have an explicit mechanism for incorporating observable confounders.
The solution we use, proposed by Bennett et al. (2019, p. 2), is to incorporate these observables
in both instrument and treatment; hence we apply DeepGMM with treatment X = (P, T, S)
and instrumental variable Z = (C, T, S). Although this approach is theoretically sound,
this makes the problem unnecessary difficult since it ignores the fact that we only need to
consider the conditional expectation of P given Z.
We used a network with a similar number of parameters to DeepIV as the feature maps in
DFIV and models in DeepGMM. We tuned the regularizers λ1 , λ2 as discussed in Appendix A,
with the data evenly split for stage 1 and stage 2. We varied the correlation parameter ρ and
dataset size, and ran 20 simulations for each setting. Results are summarized in Figure 2. We
also evaluated the performance via the estimation of average treatment effect and conditional
average treatment effect, which is presented in Appendix E.2
Next, we consider a case, introduced by Hartford et al. (2017), where the customer type
S ∈ {1, . . . , 7} is replaced with an image of the corresponding handwritten digit from the
MNIST dataset (LeCun and Cortes, 2010). This reflects the fact that we cannot know the
exact customer type, and thus we need to estimate it from noisy high-dimensional data.
Note that although the confounder is high-dimensional, the treatment variable is still real-
valued, i.e. the price P of the tickets. Figure 3 presents the results for this high-dimensional
confounding case. Again, we train the networks with a similar number of learnable parameters
to DeepIV in DFIV and DeepGMM, and hyper-parameters are set in the way discussed in
6
Published as a conference paper at ICLR 2021
4 3 2
Ooo
111
山Sw WdEESJOJnO
p = 0.25
中工三
七 +
十士士
p = 0.5	p = 0.75
p = 0.9
事早孑
*于
Algorithm
陵 DeepGMM
中 DeepIV
KM
S DFIV


Oo
10
5000 10000	1000 5000 10000	1000 5000 10000	1000 5000 10000	1000 5000 10000
Training Sample Size
Figure 2: MSE for demand design dataset with low dimensional confounders.
GOT-山 SW-dEes-oJno
巨弓 '=⅛='
Algorithm
原 DeepGMM
[⅞ DeepIV
摩MV
@ DFIV
山 SW-dEe'JOJnO
30
10
≡≈
Algorithm
图 DeepGMM
味KIV
U DFIV
0.1	0.25	0.5	0.75	0.9
Confounding Level p
5000	10000
Training Sample Size
Figure 3:	MSE for demand design dataset
with high dimensional observed confounders.
Figure 4:	MSE for dSprite dataset. DeepIV
did not yield meaningful predictions for this
experiment.
Appendix A. We ran 20 simulations with data size n + m = 5000 and report the mean and
standard error.
Our first observation from Figure 2 and 3 is that the level ρ of correlation has no significant
impact on the error under any of the IV methods, indicating that all approaches correctly
account for the effect of the hidden confounder. This is consistent with earlier results on
this dataset using DeepIV and KIV (Hartford et al., 2017; Singh et al., 2019). We note
that DeepGMM does not perform well in this demand design problem. This may be due to
the current DeepGMM approach to handling observable confounders, which might not be
optimal. KIV performed reasonably well for small sample sizes and low-dimensional data,
but it did less well in the high-dimensional MNIST case due to its less expressive features.
In high dimensions, DeepIV performed well, since the treatment variable is unidimensional.
However, DFIV performed consistently better than all other methods in both low and high
dimensions, which suggests it can learn a flexible structural function in a stable manner.
4.2	dSprites Experiments
To test the performance of DFIV methods for a high dimensional
treatment variable, we utilized the dSprites dataset (Matthey
et al., 2017). This is an image dataset described by five latent
parameters (shape, scale, rotation, posX and posY). The
images are 64 × 64 = 4096-dimensional. In this experiment, we
fixed the shape parameter to heart, i.e. we only used heart-
shaped images. An example is shown in Figure 5.
From this dataset, we generated data for IV regression in which
we use each figure as treatment variable X . Hence, the treatment
variable is 4096-dimensional in this experiment. To make the task
more challenging, we used posY as the hidden confounder, which
is not revealed to the model. We used the other three latent
0	25	50
Figure 5: dSprite image
variables as the instrument variables Z . The structural function fstruct and outcome Y are
defined as
fstruct (X) =  ----IO。。------, Y = fstrUct(X) + 32(posY - 0.5) + ε,	ε 〜N(0, 0.5),
7
Published as a conference paper at ICLR 2021
where each element of the matrix A ∈ R10×4096 is generated from Unif (0.0, 1.0) and fixed
throughout the experiment. See Appendix E.3 for the detailed data generation process.
We tested the performance of DFIV with KIV and DeepGMM, where the hyper-parameters
are determined as in the demand design problem. The results are displayed in Figure 4.
DFIV consistently yields the best performance of all the methods. DeepIV is not included in
the figure because it fails to give meaningful predictions due to the difficulty of performing
conditional density estimation for the high-dimensional treatment variable. The performance
of KIV suffers since it lacks the feature richness to express a high-dimensional complex
structural function. Although DeepGMM performs comparatively to DFIV, we observe some
instability during the training, see Appendix E.4.
4.3	Off-Policy Policy Evaluation Experiments
We apply our IV methods to the off-policy policy evaluation (OPE) problem (Sutton and
Barto, 2018), which is one of the fundamental problems of deep RL. In particular, it has
been realized by Bradtke and Barto (1996) that 2SLS could be used to estimate a linearly
parameterized value function, and we use this reasoning as the basis of our approach. Let us
consider the RL environment hS, A, P, R, ρ0, γi, where S is the state space, A is the action
space, P : S × A × S → [0, 1] is the transition function, R : S × A × S × R → R is the reward
distribution, ρ0 : S → [0, 1] is the initial state distribution, and discount factor γ ∈ (0, 1].
Let π be a policy, and We denote π(a∣s) as the probability of selecting action a in stage S ∈ S.
Given policy π , the Q-function is defined as
∞
Qπ (s, a) = E	γtrt s0 = s, a0 = a
t=0
with at 〜π(∙ | st), st+ι 〜P(∙∣st, at), r 〜R(∙∣st, at, st+ι)∙ The goal of OPE is to evaluate
the expectation of the Q-function With respect to the initial state distribution for a given
target policy π, Es〜。。,。,〜∏[Qπ(s, a)], learned from a fixed dataset of transitions (s, a, r, s0),
where S and a are sampled from some potentially unknown distribution μ and behavioral
policy ∏b(∙∣s) respectively. Using the Bellman equation satisfied by Qπ, we obtain a structural
causal model of the form (1),
structural function fstruct (s,a,s0 ,a0 )
z---------------^-----------{
r =	Qπ (S, a) - γQπ(S0, a0)
(10)
+ Y (Q (S , a ) ― Es0~P(∙∣ s,a),a0~∏(∙∣ s0) [Q (S , a )]) + r ― Er~R(∙∣ s,a,s0) [r],
S-------------------------------------------V-----------------------------------------}
confounder ε
where X = (s,a,s0,a0),Z = (S,a),Y = r. We have that E [ε] = 0, E [ε∣X] = 0, and
Assumption 1 is verified. Minimizing the loss (2) for the structural causal model (10)
corresponds to minimizing the following loss LOPE
LOPE
Es,a,r [(r + YEs0〜P (∙∣ s,a),a0〜π(∙∣ s0) [Q (S
a0)]-Qπ(S,a)2 ,
(11)
and we can apply any IV regression method to achieve this. In Appendix D, we show
that minimizing LOPE corresponds to minimizing the mean squared Bellman error (MSBE)
(Sutton and Barto, 2018, p. 268) and we detail the DFIV algorithm for OPE. Note that
MBSE is also the loss minimized by the residual gradient (RG) method proposed in (Baird,
1995) to estimate Q-functions. However, this method suffers from the “double-sample” issue,
i.e. it requires two independent samples of S0 starting from the same (S, a) due to the inner
conditional expectation (Baird, 1995), whereas IV regression methods do not suffer from
this issue.
We evaluate DFIV on three BSuite (Osband et al., 2019) tasks: catch, mountain car, and
cartpole. See Section E.6.1 for a description of those tasks. The original system dynamics
are deterministic. To create a stochastic environment, we randomly replace the agent action
by a uniformly sampled action with probability p ∈ [0, 0.5]. The noise level p controls the
level of confounding effect. The target policy is trained using DQN (Mnih et al., 2015),
and we subsequently generate an offline dataset for OPE by executing the policy in the
8
Published as a conference paper at ICLR 2021
JoxI 山 £-OSqV
100
catch
100-
mountain car
J-甲一 ∙
_• iτ
S? ∙
=nτπ9
• ≡∙∙= ∙
EEHB
10
一申
-BT
±⅛∙ ∙
卓O-
_• S .
⅛⅛τ∙ T
10
IOT
⅛τ
θ ɪu
-∙ τ⅛mω
Algorithm
用 DeepGMM
⅜ DeepIV
白FQE
KIV
用 DFIV
0.0 0.1 0.2 0.3 0.4 0.5
0.0 0.1 0.2 0.3 0.4 0.5
Noise Level
0.0 0.1 0.2 0.3 0.4 0.5
1
Figure 6: Error of offline policy evaluation.
same environment with a random action probability of 0.2 (on top of the environment’s
random action probability p). We compare DFIV with KIV, DeepIV, and DeepGMM; as
well as Fitted Q Evaluation (FQE) (Le et al., 2019; Voloshin et al., 2019), a specialized
approach designed for the OPE setting, which serves as our “gold standard” baseline (Paine
et al., 2020) (see Section E.6.2 for details). All methods use the same network for value
estimation. Figure 6 shows the absolute error of the estimated policy value by each method
with a standard deviation from 5 runs. In catch and mountain car, DFIV comes closest in
performance to FQE, and even matches it for some noise settings, whereas DeepGMM is
somewhat worse in catch, and significantly worse in mountain car. In the case of cartpole,
DeepGMM performs somewhat better than DFIV, although both are slightly worse than
FQE. DeepIV and KIV both do poorly across all RL benchmarks.
5 Conclusion
We have proposed a novel method for instrumental variable regression, Deep Feature IV
(DFIV), which performs two-stage least squares regression on flexible and expressive features
of the instrument and treatment. As a contribution to the IV literature, we showed how to
adaptively learn these feature maps with deep neural networks. We also showed that the
off-policy policy evaluation (OPE) problem in deep RL can be interpreted as a nonlinear IV
regression, and that DFIV performs competitively in this domain. This work thus brings the
research worlds of deep offline RL and causality from observational data closer.
In terms of future work, it would be interesting to adapt the ideas from (Angrist and
Krueger, 1995; Angrist et al., 1999; Hansen and Kozbur, 2014) to select the regularization
hyperparameters of DFIV as well as investigate generalizations of DFIV beyond the additive
model (1) as considered in (Carrasco et al., 2007, Section 5.5). In RL, problems with
additional confounders are common, see e.g. (Namkoong et al., 2020; Shang et al., 2019),
and we believe that adapting DFIV to this setting will be of great value.
References
M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis,
J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia,
R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mane, R. Monga, S. Moore,
D. Murray, C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker,
V. Vanhoucke, V. Vasudevan, F. Viegas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke,
Y. Yu, and X. Zheng. TensorFlow: Large-scale machine learning on heterogeneous systems,
2015. URL http://tensorflow.org/.
J. D. Angrist. Lifetime earnings and the Vietnam era draft lottery: Evidence from social
security administrative records. The American Economic Review, 80(3):313—336, 1990.
J. D. Angrist and A. B. Krueger. Split-sample instrumental variables estimates of the return
to schooling. Journal of Business & Economic Statistics, 13(2):225-235, 1995.
9
Published as a conference paper at ICLR 2021
J. D. Angrist, G. W. Imbens, and D. B. Rubin. Identification of causal effects using
instrumental variables. Journal of the American Statistical Association, 91(434):444-455,
1996.
J. D. Angrist, G. W. Imbens, and A. B. Krueger. Jackknife instrumental variables estimation.
Journal of Applied Econometrics, 14(1):57-67, 1999.
L. Baird. Residual algorithms: Reinforcement learning with function approximation. In
Proceedings of the 12th International Conference on Machine Learning, 1995.
E. Bareinboim and J. Pearl. Causal inference by surrogate experiments: Z-identifiability. In
Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence, page 113-120,
2012.
A. G. Barto, R. S. Sutton, and C. W. Anderson. Neuronlike adaptive elements that can solve
difficult learning control problems. IEEE transactions on Systems, Man, and Cybernetics,
(5):834-846, 1983.
A. Bennett, N. Kallus, and T. Schnabel. Deep generalized method of moments for instrumental
variable analysis. In Advances in Neural Information Processing Systems 32, pages 3564-
3574. 2019.
R. Blundell, X. Chen, and D. Kristensen. Semi-nonparametric IV estimation of shape-
invariant engel curves. Econometrica, 75(6):1613-1669, 2007.
R.	Blundell, J. Horowitz, and M. Parey. Measuring the price responsiveness of gasoline
demand: Economic shape restrictions and nonparametric demand estimation. Quantitative
Economics, 3:29-51, 2012.
S.	J. Bradtke and A. G. Barto. Linear least-squares algorithms for temporal difference
learning. Machine Learning, 22(1-3):33-57, 1996.
M. Carrasco, J.-P. Florens, and E. Renault. Linear inverse problems in structural econo-
metrics estimation based on spectral decomposition and regularization. In Handbook of
Econometrics, volume 6B, chapter 77. 2007.
X. Chen and T. M. Christensen. Optimal sup-norm rates and uniform inference on nonlinear
functionals of nonparametric IV regression: Nonlinear functionals of nonparametric IV.
Quantitative Economics, 9:39-84, 2018.
X. Chen and D. Pouzo. Estimation of nonparametric conditional moment models with
possibly nonsmooth generalized residuals. Econometrica, 80(1):277-321, 2012.
S. Darolles, Y. Fan, J. P. Florens, and E. Renault. Nonparametric instrumental regression.
Econometrica, 79(5):1541-1565, 2011.
D. Ernst, P. Geurts, and L. Wehenkel. Tree-based batch mode reinforcement learning.
Journal of Machine Learning Research, 6:503-556, 2005.
C. Hansen and D. Kozbur. Instrumental variables estimation with many weak instruments
using regularized jive. Journal of Econometrics, 182(2):290-308, 2014.
L.	P. Hansen. Large sample properties of generalized method of moments estimators.
Econometrica, 50(4):1029-1054, 1982.
J. Hartford, G. Lewis, K. Leyton-Brown, and M. Taddy. Deep IV: A flexible approach for
counterfactual prediction. In International Conference on Machine Learning, 2017.
M.	Hoffman, B. Shahriari, J. Aslanides, G. Barth-Maron, F. Behbahani, T. Norman, A. Ab-
dolmaleki, A. Cassirer, F. Yang, K. Baumli, S. Henderson, A. Novikov, S. G. Colmenarejo,
S. Cabi, C. Gulcehre, T. L. Paine, A. Cowie, Z. Wang, B. Piot, and N. de Freitas. Acme: A
research framework for distributed reinforcement learning. arXiv preprint arXiv:2006.00979,
2020.
10
Published as a conference paper at ICLR 2021
H. Le, C. Voloshin, and Y. Yue. Batch policy learning under constraints. In International
Conference on Machine Learning, 2019.
Y. LeCun and C. Cortes. MNIST handwritten digit database. 2010. URL http://yann.
lecun.com/exdb/mnist/.
L. Matthey, I. Higgins, D. Hassabis, and A. Lerchner. dSprites: Disentanglement testing
sprites dataset, 2017. URL https://github.com/deepmind/dsprites-dataset/.
T. Miyato, T. Kataoka, M. Koyama, and Y. Yoshida. Spectral normalization for generative
adversarial networks. In International Conference on Learning Representations, 2018.
V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves,
M. Riedmiller, A. K. Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik,
I. Antonoglou, H. King, D. Kumaran, D. Wierstra, S. Legg, and D. Hassabis. Human-level
control through deep reinforcement learning. Nature, 518(7540):529-533, 2015.
M. Mohri, A. Rostamizadeh, and A. Talwalkar. Foundations of Machine Learning. MIT
Press, 2012.
A. W. Moore. Efficient Memory-Based Learning for Robot Control. PhD thesis, Cambridge
University, 1990.
K. Muandet, A. Mehrjou, S. K. Lee, and A. Raj. Dual IV: A single stage instrumental
variable regression. In Advances in Neural Information Processing Systems 34, 2020.
H.	Namkoong, R. Keramati, S. Yadlowsky, and E. Brunskill. Off-policy policy evaluation for
sequential decisions under unobserved confounding. In Advances in Neural Information
Processing Systems 34, 2020.
M. Z. Nashed and G. Wahba. Generalized inverses in reproducing kernel spaces: An approach
to regularization of linear operator equations. SIAM Journal on Mathematical Analysis, 5
(6):974-987, 1974.
W. K. Newey and J. L. Powell. Instrumental variable estimation of nonparametric models.
Econometrica, 71(5):1565-1578, 2003.
I.	Osband, Y. Doron, M. Hessel, J. Aslanides, E. Sezener, A. Saraiva, K. McKinney, T. Lat-
timore, C. Szepesvari, S. Singh, et al. Behaviour suite for reinforcement learning. In
International Conference on Learning Representations, 2019.
T. L. Paine, C. Paduraru, A. Michi, C. Gulcehre, K. Zolna, A. Novikov, Z. Wang, and
N. de Freitas. Hyperparameter selection for offline reinforcement learning. arXiv preprint
arXiv:2007.09055, 2020.
A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin,
N. Gimelshein, L. Antiga, A. Desmaison, A. Kopf, E. Yang, Z. DeVito, M. Raison,
A. Tejani, S. Chilamkurthy, B. Steiner, L. Fang, J. Bai, and S. Chintala. Pytorch:
An imperative style, high-performance deep learning library. In Advances in Neural
Information Processing Systems 32, pages 8024-8035. 2019.
A. Rahimi and B. Recht. Random features for large-scale kernel machines. In Advances in
Neural Information Processing Systems 20, pages 1177-1184. 2008.
W. Shang, Y. Yu, Q. Li, Z. Qin, Y. Meng, and J. Ye. Environment reconstruction with
hidden confounders for reinforcement learning based recommendation. In Proceedings of
the 25th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining,
pages 566-576, 2019.
R. Singh, M. Sahani, and A. Gretton. Kernel instrumental variable regression. In Advances
in Neural Information Processing Systems 32, pages 4593-4605. 2019.
J.	H. Stock and F. Trebbi. Retrospectives: Who invented instrumental variable regression?
Journal of Economic Perspectives, 17(3):177-194, 2003.
11
Published as a conference paper at ICLR 2021
R. S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. The MIT Press,
2018.
C. Voloshin, H. M. Le, N. Jiang, and Y. Yue. Empirical study of off-policy policy evaluation
for reinforcement learning. arXiv preprint arXiv:1911.06854, 2019.
M. Wiatrak, S. V. Albrecht, and A. Nystrom. Stabilizing generative adversarial networks: A
survey. arXiv preprint arXiv:1910.00927, 2019.
P. Wright. The Tariff on Animal and Vegetable Oils. Investigations in International
Commercial Policies. Macmillan Company, 1928.
12
Published as a conference paper at ICLR 2021
A Hyper-Parameter Tuning
If observations from the joint distribution of (X, Y, Z) are available in both stages, we can
tune the regularization parameters λ1, λ2 using the approach proposed in Singh et al. (2019).
Let the complete data of stage 1 and stage 2 be denoted as (xi,yi,zi) and (Xi,5i,Zi)∙ Then,
we can use the data not used in each stage to evaluate the out-of-sample performance of the
other stage. Specifically, the regularizing parameters are given by
1n
λ1 = argmin LIno皿 LInoOs = n Ek Ψθx (Xi) - V (m)Φ^z (Zi)k2,
n j=1
m
λ2 = argminL2mos,比Oos = m £(yi - (U⑺)>V(m)φ^z(zi))2,
m i=1
where U⑺，V(m),θθx ,θθz are the parameters learned in (6) and (8).
B Consistency of DFIV
In this appendix, we prove consistency of the DFIV approach. Our contribution is to establish
consistency of the end-to-end procedure incorporating Stages 1 and 2, which we achieve by
first showing a Stage 1 consistency result (Lemma 1), and then establishing the consistency
of Stage 2 when the empirical Stage 1 solution is used as input (Lemma 2). The desired
result then follows in Theorem 1.
Consistency results will be expressed in terms of the complexity of the function classes used
in Stages 1 and 2, as encoded in the Rademacher complexity of functionals of these functions
(see Proposition 1 below). Consistency for particular function classes can then be shown by
establishing that the respective Rademacher complexities vanish. We leave for future work
the task of demonstrating this property for function classes of interest.
B.1	Operator view of DFIV
The goal of DFIV is to learn structural function fstruct , which satisfies
EY|Z[Y] =EX|Z[fstruct(X)].	(12)
We model fstruct as fstruct (X) = U>ψθX (X) and denote the hypothesis spaces for ψθX and
fstruct as follows:
Hψ = {ψθX : X → Rd1 | θX ∈ ΘX},
F = {U>ψθX : X → Y | ψθX ∈ Hψ, U ∈ Rd1}.
To learn the parameters, we minimize the following stage 2 loss:
1n
U(n),θχ = argmin L2n(u,θχ), 嘴)=- u>Eχ∣z [Ψθχ (X )](∙))2∙
u∈Rd1 ,θX	n i=1
We denote the resulting estimated structural function as fstrUct(X) = (US))>Ψθχ (X). For
simplicity, we set all regularization terms to zero. Here, Eχ∣z [ψθχ (X)] is the empirical
conditional expectation operator, which maps an element of Hψ to some function g : Z 7→
Rd1 ∈ G that
_m
E X|Z [ψθχ (X)] = arg min LIm) (V,θz), LIm) = 一 X kΨθχ (Xi)- g(zi)k2.
g∈G	m i=1
In DFIV, we define G as
G = {V φθZ : Z →Rd1 | V ∈Rd2×d1,θZ ∈ ΘZ}.
This formulation is equivalent to the one introduced in Section 3. With a slight abuse of
notation, for f (X) = u>ψθχ (X) ∈ F, we define EX∣z [f (X)] to be
^	. ,	~Γ ^	一	.,
EX|Z [f (X)] = U EX|Z [ψθχ (X)]
since this is the empirical estimate of EX|Z [f (X)].
13
Published as a conference paper at ICLR 2021
/log2∕δ
V 2n
B.2	Generalization errors for regression
Here, we bound the generalization errors of both stages using Rademacher complexity bounds
(Mohri et al., 2012).
Proposition 1. (Theorem 3.3 Mohri et al., 2012, with slight modification) Let S be a
measurable space and H be a family of functions mapping from S to [0, M]. Given fixed
dataset S = (s1 , s2, . . . , sn) ∈ Sn, empirical Rademacher complexity is given by
n
RS(H) = Eσ sup Xσih(si),
h∈H i=1
where σ = (σ1, . . . , σn), with σi is independent uniform random variables taking values in
{-1, +1}. Then, for any δ > 0, with probability at least 1 - δ over the draw of an i.i.d
sample S of size n, each of following holds for all h ∈ H:
1n
E [h(s)] ≤ — E h(si) + 2R^s + 3M
n i=1
1 X h(si) ≤ E [h(s)] + 2Rs + 3M∖∕⅛2^∙
n	2n
i=1
We list the assumptions below.
Assumption 2. The following hold:
1.	Bounded outcome variable |Y | ≤ M.
2.	Bounded stage 1 hypothesis space: ∀z ∈ Z, kg(z)k ≤ 1.
3.	Bounded stage 2 feature map ∀x ∈ X, kψθX (x)k ≤ 1.
4.	Bounded stage 2 weight: kuk ≤ M .
5.	Identifiable stage 1 hypothesis space: ∀ψθX ∈ Hψ, ∃g ∈ G, EX|Z [ψθX] = g.
6.	Identifiable stage 2 hypothesis space: fstruct ∈ F.
Note that we leave aside questions of optimization. Thus, we assume that the optimization
procedure over (θz, V) is sufficient to recover EX∣z, and that the optimization procedure
over (u, θX) is sufficient to recover fstruct (which requires, in turn, the correct EX|Z, for this
ψθX ). We emphasize that Algorithm 1 does not guarantee these properties.
Based on these assumptions, We derive the generalization error in terms of L?-norm ∣∣ ∙ ∣∣p(Z)
defined as
kh∣P(Z)= (/ ∣h(Z)k2dP(Z))2.
The folloWing lemma proves the generalization error for stage 1 regression.
Lemma 1. Under Assumption 2, and given stage 1 data S1 = {(xi, zi)}im=1, for any δ > 0,
with at least probability 1 - 2δ, we have
∣∣E X|Z [f(X)] - Eχ∣z [f(X )]||p( Z)≤ M j4R Si (H1) + 24J Iogmδ
for any f = u> ψθX ∈ F, where hypothesis space H1 is defined as
H1= {(x, z) ∈ X × Z 7→ ∣ψθX (x) - g(z)∣2 ∈ R | g ∈ G, ψθX ∈ Hψ}.	(13)
14
Published as a conference paper at ICLR 2021
Proof. From Cauchy-SchWarZ inequality, We have
∣∣E[f(X )[Z] - E χ∣z[f(X )]∣J Z) = M> (EX |Z [ψθχ (X)] - E x∣z[ψθχ (X Ml”
≤ M ∣lEX∣Z [ψθχ (X)] - EX|Z [ψθχ (X)] L(Z)
By applying Proposition 1 to hypothesis space H1, We have
EXZ MX (X) - EX|Z [ψθχ(X)]|1 ]
≤ m X ∣lψθχ (Xi)- EX|Z [ψθχ (XI(Zi) ll + 2RSi (HI) + 12↑J 2m~
i=1
With probability 1 - δ. Indeed all functions h ∈ H1 satisfy khk ≤ 4 since kψθX (X)k ≤
1, kg(Z)k ≤ 1 from Assumption 2.
Also, since ∀ψθX ∈ Hψ, ∃g ∈ G, EX|Z [ψθX] = g, again from Proposition 1, We have
m
一X∣∣ψθχ(Xi)- EX∣z[ψθχ (X)](zi)Il2
m
i=1
≤ EXZ h∣∣ψθχ (X) - EXIZ [ψθχ (X )]/i + 2R Si (HI) + 12y^lm^
with probability 1 一 δ. From the optimality of Ex∣z [ψθχ(X)], we have
m	2m
m X llψθχ (Xi)- EX|Z [ψθχ] (Zi) ll ≤ m X l∣ψθχ (Xi)- EXIZ [ψθχ (X)] (Zi)『.
Hence, we have
EXZ ∣∣ψθχ (X) - EX∣Z [ψθχ (X)]|| ]
≤ EXZ h∣∣ψθχ (X) - ex∣Z [ψθχ (X )]∣l2i +4R Si (HI) +24 ʌ/gm/ɪ
with probability 1 - 2δ. Now we have
EXZ ∣lψθχ (X) - EXIZ [ψθχ (X)]「
=EXZ h∣∣ψθχ (X) - EX|Z [ψθχ (X)]∣∣2] + EZnEX|Z [ψθχ (X)] - EX∣Z [ψθχ (X)]|| |,
and thus
EZnEXIZ [ψθχ (X)] - EX∣Z [ψθχ (X)]|1 ] ≤ 4RSi (HI) + 24J°gm”
Therefore, by taking the square root of both sides, we can see
∣∣ΕXIZ [f(X)] - Exiz [f(X)]∣∣p(Z) ≤ M^4RSi (Hι) + 24jlθ2mδ∙
□
The generaliZation error for stage 2 is given in the following lemma.
15
Published as a conference paper at ICLR 2021
Lemma 2. Under Assumption 2, and given stage 1 data S1 = {(xi, zi)}im=1, stage 2 data
S2 = {(yi, Zi)}n=ι, and the estimated structural function fstruCt(X) = (U^(n))>ψ^^χ (x), then
for any δ > 0, with at least probability 1 - 4δ, we have
IEYIZ [Y] - Ex∣z hfStruCt(XR ∣lp(z)
≤ JR S2(H2)+24M2 r Iogn/δ+M s&r si (HI)+24r Iogm/δ,
where H1 is defined in (13) and H2 is defined as
H2 = {(y, z) ∈Y × Z7→ (y - u>g(z))2 ∈R | g ∈ G,u ∈Rd1,kuk ≤M}.	(14)
Proof. Since
EXIZ [ψθχ]
∈ G, by applying Proposition 1 to hypothesis space H2 , we have
EYZ [(Y - EX|Z fstrUCt(X)])2]
≤ 1 XX (yi - EXIZ [篇UCt(X)] (Zi))2 + 2RS2(H2) + 12M2rIogn/δ
i=1
with probability of 1 - δ. Note that all functions h ∈ H2 are bounded in khk ≤ 4M2 since
|Y| ≤ M, kψθX (X)k ≤ 1, kuk ≤ M from Assumption 2. Similarly, since fstruCt ∈ F from
Assumption 2, we have
1n	2
—^X (yi - EX∣Z [fstruCt(X)](>))
n i=1
≤ EYZ [(Y - EXIZ [fstruct(X)])2] + 2RS2(H2) + 12M2 Jlogn^
with probability 1 - δ. From the minimality of fstruCt , we have
n	2n
—^X	(yi	-	EX∣Z	[fStruCt(X)](名))≤ ~	^X(yi	-	EX∣Z	[fstruCt(X)]	(Zi))2
n i=1	n i=1
Hence, we have
EYZ (Y - EX∣Z [fstruCt(X)])]
≤ EYZ [(Y - EX∣Z [fstruCt(X)])2] +4RS2 (H2) + 24M2 j"：：",
with probability 1 - 2δ. Now we also have
EYZ ] (Y - E X∣Z [fstruCt]) ] = EYZ [(Y - EYIZ [Y])2] + EZ [(E X ∣Z [.fstruCt] - EYIZ [Y ])2 ],
EYZ [(Y - EXIZ [fstruCt])2] = EYZ [(Y - EYIZ [Y])2] + EZ [(EXIZ [fstruCt] - EYIZ [Y])2] ∙
Therefore, with probability 1 - 2δ,
EZ [(EYIZ [Y] - EXIZ [fstruCt(X)] )2]
≤ 4RS2(H2) +24M2 Jlogn^ + Ez [(Exiz [fstrUCt(X)] - 6丫② [Y])2].
From Lemma 1 and (12), with probability at least 1 - 2δ,
Ez [(Ex∣z [fstruCt(X)] - Eyiz [Y])2] ≤ 4M2R& (Hi) + 24M2 jlo∣mδ.
16
Published as a conference paper at ICLR 2021
By combining them, we can see that with probability 1 - 4δ,
IlEY|Z [Y] - EX|Z hfStruCt(XU IIp(Z)
≤ CR S2(H2)+24M2 r Iogn/δ
+ 4M 2R Si (HI) + 24M 2∖ ∕log^δ
2m
≤ 'r S2(H2)+24M2 r IogI/δ
+M
CRSi (Hl) + 24r0gP.
□
B.3 Consistency Proof of DFIV
The goal is to bound the deviation between fstruct and fstruct. This discrepancy is measured
by L2 -norm with respect to P(X), defined as
kh(X)kp(x)= (/ kh(X)k2dP(X))2.
However, We used the norm ∣∣ ∙ ∣∣p(Z) in Lemmas 1 and 2. To bridge this gap, We state the
necessary condition for identification introduced in (Newey and Powell, 2003).
Proposition 2. (Proposition 2.1 Newey and Powell, 2003) For all δ(x) with finite expecta-
tion, E [δ(X)|Z] = 0 a.e. on Z implies δ(x) = 0.
Proposition 2 is the minimum requirement for identification and Assumption 1 is a sufficient
condition for it. Given Proposition 2, We can consider a constant τ < ∞ defined as
=	IlfStrUct(X) - f (X)∣∣P(X)
f∈F,f = fstruct kE [/struct(X) - f(X)|Z]kp(Z)
(15)
Note that τ ≥ 1 from definition and τ = 1 if and only if X is measurable With respect to Z .
This measures the ill-posedness of IV problem. A similar quantity is introduced in (Blundell
et al., 2007). Given this quantity, We derive the convergence rate of DFIV as folloWs.
Theorem 1. Let Assumption 2 hold. Given stage 1 data S1 = {(xi, zi)}im=1, stage 2 data
S2 = {(yi, Zi)}m=ι and T defined in (15), for any δ > 0, with at least probabilty of 1 — 6δ, we
have
...	____ O	_______
IIfStrUct(X ) - /struct (X )∣P (X)
≤ 2TM
CRSi (H1) + 24r0lP
+T
j4RS2 (H2 ) + 24M2
/log2∕δ
V 2n
where H1 and H2 are defined in (13) and (14), respectively.
Proof. Using T in (15), We have
IlfStrUct(X) - fstruct(X)∣P(X) ≤ T ||E [fstrUct(X) - fstruct(X) |Z| ||玖2)
≤ T IIE [/strUct(X)|Zi — EX|Z [/strUct(X)]]⑶
+ T IE [/strUct(X)|Z] — EX|Z [/strUct(X)])^
T IE [/strUct(X)|Zi — EX|Z [/strUct(X)])^
+ T IE [Y|Z] — Eχ∣Z [/strUct(XMYZ)，
where the last inequality holds from (12). Using Lemmas 1 and 2, the result thus follows. □
17
Published as a conference paper at ICLR 2021
Figure 7: Causal graph with observable confounder
From this result, we obtain directly the following corollary.
Corollary 1. Let Assumption 2 hold. If RS1 (H1) → 0 and RS2 (H2) → 0 in probability as
datasize increases, fstruct converges to fstruct in probability.
The proof of vanishing Rademacher complexities for particular Stage 1 and Stage 2 function
classes is a topic for future work.
C 2SLS algorithm with observable confounders
In this appendix, we formulate the DFIV method when observable confounders are available.
Here, we consider the causal graph given in Figure 7. In addition to treatment X ∈ X ,
outcome Y ∈ Y , and instrument Z ∈ Z , we have an observable confounder O ∈ O. The
structural function fstruct we aim to learn is now X × O → Y , and the structural causal
model is represented as
Y = fstruct(X,O) + ε, E [ε] =0, E [ε∣X] = 0.
For hidden confounders, we rely on Assumption 1. For observable confounders, we introduce
a similar assumption.
Assumption 3. The conditional distribution P (X |Z, O) is not constant in Z, O and
E [ε|Z, O] = 0.
Following a similar reasoning as in Section 2, we can estimate the structural function fstruct
by minimizing the following loss:
fstruct = argminL(f),	L(f ) = EYZO [(Y - Eχ∣z,o [f (X,O)])2] +Ω(f).
f∈F
One universal way to deal with the observable confounder is to augment both the treatment
and instrumental variables. Let us introduce the new treatment X = (X, O) and instrument
Z = (Z, O), then the loss L becomes
L(f )= EyZ ](Y - Eχ∣Z [f(X)])J +Ω(f),
which is equivalent to the original loss L. This approach is adopted in KIV (Singh et al.,
2019), and we used it here for DeepGMM method (Bennett et al., 2019) in the demand design
experiment. However, this ignores the fact that we only have to consider the conditional
expectation of X given Z = (Z, O). Hence, we introduce another approach which is
to model f(X, O) = u> (ψ(X) 0 ξ(O)), where ψ(X) and ξ(O) are feature maps and 0
denotes the tensor product defined as a 0 b = vec(ab>). It follows that Eχ∣z,o [f (X, O)]=
u> (EX |Z,O [ψ(X)] 0 ξ(O)), which yields the following two-stage regression procedure.
In stage 1, we learn the matrix V that
V= argmin Lι(V) Lι(V) = Eχ,z,o [kΨ(X) - Vφ(Z,O)∣∣2] + λι∣∣Vk2,
V ∈Rd1×d2
which estimates the conditional expectation EX∣z,o [ψ(X)]. Then, in stage 2, we learn U
using
U^ = arg min £2(W)
u∈Rd1
£2(w) = Eγ,z,o [kY — u>(VΦ(Z,O) 0 ξ(O))k2] + λ2kuk2.
18
Published as a conference paper at ICLR 2021
Again, both stages can be formulated as ridge regressions, and thus enjoy closed-form solutions.
We can further extend this to learn deep feature maps. Let φθZ (Z, O), ψθX (X), ξθO (O) be
the feature maps parameterized by θZ, θX , θO, respectively. Using notation similar to Section
3, the corresponding DFIV algorithm with observable confounders is shown in Algorithm 2.
Note that in this algorithm, steps 3, 5, 6 are run until convergence, unlike for Algorithm 1.
Algorithm 2 Deep Feature Instrumental Variable with Observable Confounder
T j n 1	ri, /	∖c,	∕~ ~ ~∖ t∙j∙i i Λ A Λ -rʌ ι
Input: Stage 1 data (xi,zi,θi), Stage 2 data (yi,zi,θi). Initial values θo, θχ, θz. RegUlanZ-
ing parameters (λ1, λ2)
Output: Estimated structural function fstruct (x).
1
2
3
4
5
6
7
8
9
while L⅞2n) has not converged do
while LIm) has not converged do
Update θz by GZ 一 GZ - αVθzLm)(V(m)(θo,θχ,θz),θz)∣θZ=θZ \\ Stage 1
end while
Update θχ by θχ 一 θχ - αVθχLn(Ug0。,θχ,θz),θo,θχ)∣θχ =θX \\ Stage 2
Update GO by GO 一 θo -瓜θ0Ln(U(n)(θo,θχ,θz),θ°,θχ肌=@。	\\ Stage 2
end while
Compute U(n) from ⑼
return Struct(X) = (U⑺)>ψ^χ (x)
D Application of 2SLS and DFIV to Off-Policy Policy
Evaluation
Here we first show that the optimal solution of (2) in the OPE problem is equivalent to that
of mean squared Bellman error, and then describe how we apply 2SLS algorithm.
We interpret the Bellman equation in (10) as IV regression problem, where X =
(s, a, s0, a0), Z = (s, a) and Y = r and
fstruct(s, a, s0, a0) = Qπ (s, a) - γQπ(s0, a0).
Let R(S, a) be the conditional expectation of reward given s, a defined as
R(S,a) = Er∣s,a [r] = J rP(s0∣s,α)R(r∣s,α, s0)ds0dr.
Then, we can prove that the solutions of (11) and MSBE are equivalent. Indeed, we have
argminEs” [(r — Qπ(s, a) + γEso,aθ∣a,s [Qπ(s0, a0)])2]	// (11)


arg min Esar (r — R(s, a) + R(s, a) — Qπ (
Qπ	,,
arg min Es,a Var(r|s, a)	// const wrt Qπ
Qπ	,
；so,a0|a,s [Qπ(s0,α0)])2]
+ 2Er∣s,a [(r — R(S, α))] (R(s, a) — Qn(S, a) + YEs0,a0|a,s [Q" (s0, a0)])
+ (R(S, a) — Qn (s, a) + YEs0,a0|a,s [Qn(S0, a0)])]
argminEs,。[(R(s, a) — Qπ(S,a) + YEs，,a，|a,s [Qπ(s0, a0)])2].
// = 0
(16)
In this context, we model Qπ (S, a) = U>ψ(S, a) so that
fstruct(S,a, S0, a0) = U>(ψ(S, a) — γψ(S0, a0)).	(17)
It follows that
Eχ∣z [f (X)] = u>(Ψ(S,a) — γEso〜P(∙∣s,a),a0〜∏(∙∣so) [Ψ(s0,a0)]).
19
Published as a conference paper at ICLR 2021
We will model E,，〜P(.⑶。),。，〜冗(.同)[ψ(s0,a0)] = Vφ(s,a). In this case, given stage 1 data
(si , ai , s0i ), stage 1 regression becomes
m
V (m) = argmin LIm),	L" = — X1必…)-Vφ(si,ai)k2 + λι∣∣V∣∣2,
V ∈Rd1 ×d2	m i=1
where we sample ai 〜π(∙∣si). However, given the specific form (17) of the structural function,
stage 2 is slightly modified and requires minimizing the loss
1n
u^(n) = arg min LSn, L2n = 一	- u> (Ψ(Si, a/ - YV (m)φ(si, ai)))2 + 12怙|[2,
u∈Rd1	n i=1
given stage 2 data (尻，a%, ri). We can further learn deep feature maps by parameterized
feature maps ψ and φ as described in Section 3 to obtain the DFIV algorithm for OPE.
E Experiment Details and Additional Results
E.1 Details of Demand Design Experiments
Here, we introduce the details of demand design experiments. We follow the procedure in
Singh et al. (2019). The observations are generated from the IV model,
Y = fstruct(P, τ, S) + ε, E [ε∣C, T, S] = 0,
where Y is sales, P is the treatment variable (price) instrumented by supply cost-shifter C.
T, S are the observable confounder, interpretable as time of year and customer sentiment.
The true structural function is
fstruct (P, T, S) = 100 + (10 + P)Sh(T) -2P,
h(t) = 2 (( 600)+ exp(-4(t - 5)2) + 10 - 2).
Data is sampled as
S 〜Unif {1,..., 7}
T 〜Unif[0,10]
C 〜N(0,1)
V 〜 N(0, 1)
ε 〜 N(ρV, 1 - ρ2)
P=25+ (C+3)h(T)+V
From observations of (Y, P, T, S, C), we estimate fstruct by several methods. For each
estimated fstruct , we measure out-of-sample error as the mean square error of f versus true
fstruct applied to 2800 values of (p, t, s). Specifically, we consider 20 evenly spaced values of
p ∈ [10, 25], 20 evenly spaced values of t ∈ [0, 10], and all 7 values s ∈ {1, . . . , 7}.
E.2 Effect Estimation in Demand Design Experiments
In this section, we report the result of causal effect estimation based on demand design
experiments. Specifically, we consider two effects: one is average treatment effect (ATE) and
another is conditional average treatment effect (CATE).
ATE Estimation ATE is a central target quantity in causal inference defined as
ATE = E [Y |do(X = 1)] - E [Y |do(X = 0)]
for binary treatment X ∈ {0, 1}. ATE thus requires estimating the counterfactual mean out-
comes E [Y |do(X = 1)] , E [Y |do(X = 0)]. Here, we generalize this to continuous treatment
20
Published as a conference paper at ICLR 2021
Figure 8: Estimation of ATE.
Figure 9: Estimation of CATE condi-
tioned on T given P = 25.
and consider estimating E [Y |do(X = x)]. This is also known as continuous treatment effect
or dose-response curve.
In the demand design problem, the ground truth is given by
E [Y |do(P =p)] =ET,S[fstruct(p,T,S)]
= (G-2)p+100+10G,
where G = ES [S] ET [h(T)]. The important point here is that this quantity must be
monotonically decreasing with respect to price P , since we should observe drop of demand
as we increase the ticket price.
We estimate ATE by averaging the estimated structural function fstruct over S and T . The
estimated ATE given by DeepGMM, KIV, DeepIV, DFIV are shown in Figure 8. From
Figure 8, we can see that KIV and DeepGMM fail to recover the monotonic structure in ATE.
DeepIV and DFIV are able to capture this structure, but DFIV estimation is consistently
better than DeepIV.
CATE Estimation Although ATE captures the treatment effect for the entire population,
treatment effects may be heterogeneous for different sub-populations, which we might be
interested in. In such a case, we can consider CATE defined as
CATE(O) = E [Y J do(X = 1),O = θ] - E [y ∣ do(X = 0),O = θ]
for binary treatment X ∈ {0, 1}. Here, O is a sub-vector of observable confounder O. Again,
We generalize this idea and consider E [y ∣ do(X = x), O = θ], which allows treatment X
to be continuous. This quantity is also known as the heterogeneous treatment effect.
In demand design experiment, we can consider the CATE conditioned on the time of the
year T . The true CATE is defined as
E[Y | do(P =p),T =t] = ES [fstruct(p, t, S)]
= 100+ (10 +p)E [S] h(t) - 2p,
which can be obtained by averaging the estimated structural function fstruct over S . Figure 9
shows the prediction of CATE with respect to T where treatment P is fixed to P = 25.
Again, we can observe that KIV and DeepGMM fail to capture the shape of the ground
truth curve. DeepIV performs significantly better but is less accurate than DFIV.
E.3 Data Generation Process in dSprites Experiments
Here, we describe the data generation process for the dSprites dataset experiment. This
is an image dataset described via five latent parameters (shape, scale, rotation, posX
and posY). The images are 64 × 64 = 4096-dimensional. In this experiment, we fixed shape
parameter to heart, i.e. we only used the heart-shaped images. The other latent parameters
take values of scale ∈ [0.5, 1], rotation ∈ [0, 2π], posX ∈ [0, 1], posY ∈ [0, 1].
From this dataset, we generate the treatment variable X and outcome Y as follows.
21
Published as a conference paper at ICLR 2021
0 5 0 5 0 5
3 2 2 1 1
山SW gdluescolano
o-
0	20
40	60	80	100
Epoch
Figure 10: Out-of-Sample MSE in dSprite experiment during the training
1.	Uniformly samples latent parameters (scale, rotation, posX, posY).
2.	Generate treatment variable X as
X = Fig(scale, rotation, posX, posY) + η.
3.	Generate outcome variable Y as
Y
∣∣AXk2 - 5000
1000
+ 32(posY - 0.5) + ε.
Here, function Fig returns the corresponding image to the latent parameters, and η, ε are
noise variables generated from η 〜N(0.0, 0.1I) and ε 〜N(0.0, 0.5). Each element of the
matrix A ∈ R10×4096 is generated from Unif (0.0, 1.0) and fixed throughout the experiment.
From the data generation process, we can see that X and Y are confounded by posY. We
use the instrumental variable Z = (scale, rotation, posX) ∈ R3 , and figures with random
noise as treatment variable X . The variable posY is not revealed to the model, and there is
no observable confounder. The structural function for this setting is
fstruct (X)
∣∣AX k2 — 5000
1000
We use 588 test points for measuring out-of-sample error, which is generated from the grid
points of latent variables. The grids consist of 7 evenly spaced values for posX, posY, 3 evenly
spaced values for scale, and 4 evenly spaced values for orientation.
E.4 Instability of DeepGMM in dSprites Experiments
In the dSprite experiments, we observed that the training procedure of DeepGMM can be
unstable. Figure 10 displays the MSE for the models learned in the first 100 epochs. Here,
we can see that DeepGMM performs poorly in the early stage of the learning. Furthermore,
even after it appears to have converged, we observe a sudden increase of MSE around 80th
epoch, which makes difficult to determine when to stop. We conjecture that this is due
to the instability of the smooth zero-sum game solved by DeepGMM. By contrast, DFIV
converges quickly and performs consistently better than DeepGMM on this task.
E.5 MNIST Experiments
Here, we report the result of MNIST experiments proposed by Bennett et al. (2019), who
consider the following datasets:
Z 〜Unif([-3, 3]2)
e 〜N(0,1), γ,δ 〜N(0,0.1)
X = Z1 + e + γ
Y = |X| + e + δ
22
Published as a conference paper at ICLR 2021
MNISTx	MNISTz	MNISTxz
DeepGMM^^.15 ± .02	.07 ± .02	.14 ± .02
DFIV	.18 ± .01	.07 ± .001	.10 ± .003
Table 1:	Out-of-Sample MSE in MNIST experiment of Bennett et al. (2019)
Catch Mountain Car Cartpole
F 50	3	6
A3	3	3
Table 2:	Dimensions of BSuite tasks
Here, the structural function we aim to learn is fstruct(X) = |X|. Additionally, we map
Z, X, or both X and Z to MNIST images to see whether the model can handle the high-
dimensional treatment and instrumental variables. Let the output of original IV problem
above to be Xlow, Zlow and π(x) = round(min(max(1.5x + 5, 0), 9)) be a transformation
function that maps inputs to an integer between 0 and 9, and let RandomImage(d) be a
function that selects a random MNIST image from the digit class d. The images are 28 × 28
= 784-dimensional. We consider the three following scenarios.
•	MNISTx: X J XloW, Z J RandomImage(π(Ziow))
•	MNISTz: X J RandomImage(π(Xlow)),Z J ZloW
•	MNISTxz: X J RandomImage(π(Xlow)), Z J RandomImage(π(Zlow))
We refer the reader to Bennett et al. (2019) for a detailed description. We applied DFIV using
the same architecture as DeepGMM. In Table 1, we present the mean and standard error
of out-of-sample MSE for DFIV and report the results obtained for DeepGMM in Bennett
et al. (2019). From Table 1, we can see that DFIV performs essentially like DeepGMM.
E.6 OPE Experiment Details
E.6.1 BSuite tasks
We provide a brief description below of the three behavior suite (BSuite) reinforcement
learning tasks in Osband et al. (2019):
1.	Catch: A 10x5 Tetris-grid with single block falling per column. The agent can move
left/right in the bottom row to ‘catch’ the block. Illustrated in Figure 11a.
2.	Mountain Car: The agent drives an underpowered car up a hill (Moore, 1990).
Illustrated in Figure 11b.
3.	Cartpole: The agent can move a cart left/right on a plane to keep a balanced pole
upright (Barto et al., 1983). Illustrated in Figure 11c.
(a) Catch
(b) Mountain Car
(c) Cartpole
Figure 11: Three BSuite tasks. Figures are from Osband et al. (2019).
All tasks have a real-valued state space S ⊆ RD and a discrete action space A =
{0, 1, 2, . . . , A - 1}. The state dimension and number of actions are provided in Table 2.
23
Published as a conference paper at ICLR 2021
E.6.2 Fitted Q Evaluation
Fitted Q Evaluation (FQE) (Le et al., 2019) is a simple variant of the Fitted Q Iteration
(FQI) algorithm (Ernst et al., 2005). Instead of learning the Q function of an optimal policy
as FQI, FQE estimates the Q function of a fixed policy π. It is an iterative algorithm with
randomly initialized the Q function parameters θ0 . At iteration k ≥ 1 with the current
estimate of Q function Qn(s, a∣θk-ι), it updates parameters θk by solving the following
regression problem using a least squares approach:
r + γQπ (s0,ao∣θk-i)=Qπ (s,a∣θk)	(18)
+ Y(Qn (S0, alθk-I)- Es0〜P(∙∣s,a),a0〜π(∙∣s0) [Q"(S0, alθk-I)D
+ r ― Er〜R(∙∣s,a,s0) [r] ,
where the regression function to estimate is Qn(s,a∣θk), the observed outcome is the term
on the LHS of (18) and the residual is the sum of terms in the second and third lines of
(18). Comparing the equation above with (10), FQE reformulates the regression problem
and moves the confounded part in the treatment of (10), that is γQπ (S0, a0), to the outcome.
The regression problem at each iteration is therefore not confounded any more. If FQE
converges, it finds a solution of the following equation
Qπ(s, a∣θ)= P(Er∣s,a [r] + YEs，,a，|s,a [Qπ(s0, a0∣θ)]),	(19)
where P(∙) is the L2 projection operator that maps a function of (s, a) onto the (parameterized)
Q function space.
F Failure of Joint Optimization
One might want to jointly minimize the loss Ln, which is the empirical approximation of L.
However, this fails to learn the true structural function fstruct , as shown in this appendix.
Figure 12 shows the learning curve obtained when we jointly minimize θX and θZ with
respect to L2n), where Ltest is the empirical approximation of
Ltest = EX [kfstrUct(X) — (U(n))>Ψθχ (X)k2i .	(20)
We observe in Figure 12 that the decrease of stage 2 loss does not improve the performance of
the learned structural function. This is because the model focuses on learning the relationship
between instrument Z and outcome Y , while ignoring treatment X. We can see this from the
fact that stage 1 loss becomes large and unstable. This is against the goal of IV regression,
which is to learn a causal relationship between X and Y .
On the other hand, Figure 13 shows the learning curve obtained using DFIV. Now, we can
see that stage 2 loss matches Ltest . Also, we can confirm that stage 1 loss stays small and
stable.
24
Published as a conference paper at ICLR 2021
Figure 12: Learning curve of joint minimiza-
tion
Figure 13: Learning curve of DFIV
Table 3: Network structures of DeepIV for demand design dataset. For the input layer, we
provide the input variable. For the fully-connected layers (FC), we provide the input and
output dimensions. For mixture Gaussian output, we report the number of components.
Dropout rate is given in the main text.
Instrument Net		Treatment Net	
Layer	Configuration	Layer	Configuration
1	Input(C, T, S)	1	Input (P, T, S)
2	FC(3,128), ReLU	2	FC(3,128), ReLU
3	Dropout	3	Dropout
4	^^FC(128, 64), ReLU	4	FC(128, 64), ReLU
5	Dropout	5	Dropout
6	FC(64, 32), ReLU	6	FC(64, 32), ReLU
7	Dropout	7	Dropout
8	MixtureGaussian(10)	8	FC(32,1)
G Network Structures and Hyper-Parameters
Here, we describe the network architecture and hyper-parameters of all experiments. Unless
otherwise specified, all neural network-based algorithms are optimized using Adam with
learning rate = 0.001, β1 = 0.9, β2 = 0.999 and ε = 10-8.
Demand Design For DeepIV, we used the original structure proposed in Hartford et al.
(2017), which is described in Table 3. We follow the default dropout rate in Hartford et al.
(2017), which depends on the data size. For DFIV, we used the structure described in Table 4.
The regularizer λ1, λ2 are both set to 0.1 as a result of the tuning procedure described in
Appendix A. For KIV, we used the Gaussian kernel where the bandwidth is determined by
the median trick described by Singh et al. (2019). We used random Fourier feature trick
(Rahimi and Recht, 2008) with 100-dimensions. For DeepGMM, we used the same structure
as DeepIV but no dropout is applied and the last layer of the Instrument Net is changed to
a fully-connected layer which maps 32 dimensions to 1 dimension.
Demand Design with MNIST The feature extractor for MNIST image data is given in
Table 5, which is used for both stage 1 and 2. For DeepIV, we used the original structure
proposed in Hartford et al. (2017), which is described in Table 6. We follow the default
dropout rate in Hartford et al. (2017), which depends on the data size. For DFIV, we used
the structure described in Table 7. The regularizer λ1, λ2 are both set to 0.1 as a result of
the tuning procedure described in Appendix A. For KIV, we used the Gaussian kernel where
the bandwidth is determined by the median trick and also used random Fourier features
with 100-dimensions. For DeepGMM, we used the same structure as DeepIV but no dropout
25
Published as a conference paper at ICLR 2021
Table 4: Network structures of DFIV for demand design datasets. For the input layer, we
provide the input variable. For the fully-connected layers (FC), we provide the input and
output dimensions.
Instrument Feature φθZ		Treatment Feature ψθX	
Layer	Configuration		
		Layer	Configuration
1	~~Input(C, T, S)~~		
		1	Input(P)
2	FC(3,128), ReLU		
		2	FC(1,16), ReLU
3	FC(128, 64), ReLU		
		3	FC(16,1)
4	FC(64, 32), ReLU		
			
	Observable Feature ξθO		
	Layer	Configuration	
	1	Input(T, S)	
	2	^^FC(2,128), ReLU	
	4	^^FC(128, 64), ReLU	
	6	FC(64, 32), BN, ReLU	
Table 5: Network structures of feature extractor used in demand design experiment with
MNIST. For each convolution layer, we list the input dimension, output dimension, kernel
size, stride, and padding. For the input layer, we provide the input variable. For the
fully-connected layers (FC), we provide the input and output dimensions. For max-pool, we
list the size of the kernel. Dropout rate here is set to 0.1. SN denotes Spectral Normalization
(Miyato et al., 2018).
ImageFeature
Layer	Configuration
1	Input(S)
2	Conv2D (1, 64, 3,1,1), ReLU, SN
3	Conv2D (64, 64, 3,1,1), ReLU, SN
-4	MaXPool(2,	2)
5	Dropout
6	FC(9216, 64), ReLU
7	Dropout
8	FC(64, 32), ReLU
is applied and the last layer of instrument net is changed to a fully connected layer which
maps 32 dimensions to 1 dimension.
dSprite experiment For DeepGMM, we used the structure described in Table 8. For
DFIV, we used the structure described in Table 9. The regularizer λ1 , λ2 are both set to
0.01 as a result of the tuning procedure described in AppendiX A. For KIV, we used the
Gaussian kernel where the bandwidth is determined by the median trick. We used random
Fourier feature trick (Rahimi and Recht, 2008) with 100 dimensions.
OPE experiment For DeepIV, we used the structure described in Table 12. For DFIV,
we used the structure described in Table 10. The regularizer λ1, λ2 are both set to 10-5 as a
result of the tuning procedure described in AppendiX A. For KIV, we used the Gaussian
kernel where the bandwidth is determined by the median trick. We used random Fourier
features (Rahimi and Recht, 2008) with 100 dimensions. For DeepGMM, we use the structure
described in Table 11.
26
Published as a conference paper at ICLR 2021
Table 6: Network structures of DeepIV in demand design with MNIST data. For the input
layer, we provide the input variable. For the fully-connected layers (FC), we provide the input
and output dimensions. For mixure Gaussian output, we report the number of components.
ImageFeature denotes the module given in Table 5. Dropout rate is described in the main
text.
Instrument Net		Treatment Net	
Layer	Configuration	Layer	Configuration
1	Input(C, T, ImageFeature(S))	1	Input(P, T, ImageFeature(S))
2	FC(66, 32), ReLU	2	FC(66, 32), ReLU	一
3	Dropout	3	Dropout
4	MixtureGaussian(10)	4	FC(32,1), ReLU
Table 7: Network structures of DFIV in demand design with MNIST. For the input layer,
we provide the input variable. For the fully-connected layers (FC), we provide the input and
output dimensions. ImageFeature denotes the module given in Table 5.
Instrumental Feature φθZ	Treatment Feature ψθX	
	Layer	Configuration
Layer	Configuration		
	1	Input(P)
1	Input(C, T, ImageFeature(S))		
	2	FC(1,16), ReLU
2	FC(66, 32), BN, ReLU 一		
	3	FC(16,1)
Obsevable Feature Net ξθO
Layer	Configuration
1	Input(T, ImageFeature(S))
2	FC(65, 32), BN, ReLU
Table 8: Network structures of DeepGMM in dSprite experiment. For the input layer, we
provide the input variable. For the fully-connected layers (FC), we provide the input and
output dimensions. SN denotes Spectral Normalization (Miyato et al., 2018).
Instrument Net		Treatment Net	
Layer	Configuration	Layer	Configuration
1	Input(Z)	1	Input(X)
2	FC(3, 256), SN, ReLU	2	^^FC(4096, 1024), SN, ReLU
3	FC(256, 128), SN, ReLU, BN	3	FC(1024, 512), SN, ReLU, BN
4	FC(128, 128), SN, ReLU, BN	4	FC(512, 128), SN, ReLU
5	FC(128, 32), SN, BN, ReLU	5	^^FC(128, 32), SN, BN, Tanh
6	FC(32,1)	6	FC(32,1)
Table 9: Network structures of DFIV in dSprite experiment. For the input layer, we provide
the input variable. For the fully-connected layers (FC), we provide the input and output
dimensions. SN denotes Spectral Normalization (Miyato et al., 2018).
Instrument Feature φθZ	Treatment Feature ψθX
Layer	Configuration	Layer	Configuration
1	Input(Z)	1	Input(X)
2	FC(3, 256), SN, ReLU	2	^^FC(4096, 1024), SN, ReLU"-
3	FC(256, 128), SN, ReLU, BN	3	FC(1024, 512), SN, ReLU, BN
4	FC(128,128), SN, ReLU, BN	4	FC(512, 128), SN, ReLU
5	FC(128, 32), SN, BN, ReLU	5	FC(128, 32), SN, BN, Tan「
27
Published as a conference paper at ICLR 2021
Table 10: Network structures of DFIV in OPE experiment. For the input layer, we provide
the input variable. For the fully-connected layers (FC), we provide the input and output
dimensions.
Instrument Feature φθZ		Treatment Feature ψθX	
Layer	Configuration		
		Layer	Configuration
1	Input(s, one-hot(a))		
		1	Input(s, one-hot(a))
2	FC(*,150), ReLU		
		2	^^FC(*, 50), ReLU
3	FC(150,100), ReLU		
		3	FC(50, 50), ReLU
4	FC(100, 50), ReLU		
Table 11: Network structures of DeepGMM in OPE experiment. For the input layer, we
provide the input variable. For the fully-connected layers (FC), we provide the input and
output dimensions.
Instrument Net		Treatment Net	
Layer	Configuration		
		Layer	Configuration
1	Input(s, one-hot(a))		
		1	Input(s, one-hot(a))
2	FC(*,150), ReLU		
		2	~~FC(*, 50), ReLU
			
3	FC(150, 100), ReLU		
		3	^^FC(50, 50), ReLU
4	FC(100, 50), ReLU		
		4	FC(50,1), ReLU
5	FC(50,1)		
Table 12: Network structures of DeepIV in OPE experiment. For the input layer, we provide
the input variable. For the fully-connected layers (FC), we provide the input and output
dimensions. The MixutureGaussian layer maps the input linearly to required parameter
dimensions for a mixture of Gaussian distribution with diagonal covariance matrices. The
Bernoulli layer maps the input linearly to a single dimension to represent the logit of a
Bernoulli distribution to predict if the next state is a terminating state.
Instrument Net		Treatment Net	
Layer	Configuration	Layer	Configuration
1	Input(s, one-hot(a))	1	Input(s, one-hot(a))
2	FC(*, 50), ReLU	2	FC(*, 50), ReLU
3	FC(50, 50), ReLU	一	3	^^FC(50, 50), ReLU
4	MixtureGaussian(3) and Bernoulli	4	FC(50,1), ReLU
28