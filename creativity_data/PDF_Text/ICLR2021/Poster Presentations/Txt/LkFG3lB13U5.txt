Published as a conference paper at ICLR 2021
Adaptive Federated Optimization
Sashank J. Reddi； Zachary Charles； Manzil Zaheer, Zachary Garrett, Keith Rush,
Jakub Konecny, Sanjiv Kumar, H. Brendan McMahan
Google Research
{sashank, zachcharles, manzilzaheer, zachgarrett, krush,
konkey, sanjivk, mcmahan}@google.com
Ab stract
Federated learning is a distributed machine learning paradigm in which a large
number of clients coordinate with a central server to learn a model without sharing
their own training data. Standard federated optimization methods such as Fed-
erated Averaging (FedAvg) are often difficult to tune and exhibit unfavorable
convergence behavior. In non-federated settings, adaptive optimization methods
have had notable success in combating such issues. In this work, we propose fed-
erated versions of adaptive optimizers, including Adagrad, Adam, and Yogi,
and analyze their convergence in the presence of heterogeneous data for general
nonconvex settings. Our results highlight the interplay between client heterogeneity
and communication efficiency. We also perform extensive experiments on these
methods and show that the use of adaptive optimizers can significantly improve the
performance of federated learning.
1	Introduction
Federated learning (FL) is a machine learning paradigm in which multiple clients cooperate to learn
a model under the orchestration of a central server (McMahan et al., 2017). In FL, raw client data
is never shared with the server or other clients. This distinguishes FL from traditional distributed
optimization, and requires contending with heterogeneous data. FL has two primary settings, cross-
silo (eg. FL between large institutions) and cross-device (eg. FL across edge devices) (Kairouz et al.,
2019, Table 1). In cross-silo FL, most clients participate in every round and can maintain state
between rounds. In the more challenging cross-device FL, our primary focus, only a small fraction of
clients participate in each round, and clients cannot maintain state across rounds. For a more in-depth
discussion of FL and the challenges involved, we defer to Kairouz et al. (2019) and Li et al. (2019a).
Standard optimization methods, such as distributed Sgd, are often unsuitable in FL and can incur
high communication costs. To remedy this, many federated optimization methods use local client
updates, in which clients update their models multiple times before communicating with the server.
This can greatly reduce the amount of communication required to train a model. One such method is
FedAvg (McMahan et al., 2017), in which clients perform multiple epochs of Sgd on their local
datasets. The clients communicate their models to the server, which averages them to form a new
global model. While FedAvg has seen great success, recent works have highlighted its convergence
issues in some settings (Karimireddy et al., 2019; Hsu et al., 2019). This is due to a variety of factors
including (1) client drift (Karimireddy et al., 2019), where local client models move away from
globally optimal models, and (2) a lack of adaptivity. FEDAVG is similar in spirit to SGD, and may
be unsuitable for settings with heavy-tail stochastic gradient noise distributions, which often arise
when training language models (Zhang et al., 2019a). Such settings benefit from adaptive learning
rates, which incorporate knowledge of past iterations to perform more informed optimization.
In this paper, we focus on the second issue and present a simple framework for incorporating
adaptivity in FL. In particular, we propose a general optimization framework in which (1) clients
perform multiple epochs of training using a client optimizer to minimize loss on their local data and
(2) server updates its global model by applying a gradient-based server optimizer to the average of the
clients’ model updates. We show that FEDAVG is the special case where SGD is used as both client
and server optimizer and server learning rate is 1. This framework can also seamlessly incorporate
* Authors contributed equally to this work
1
Published as a conference paper at ICLR 2021
adaptivity by using adaptive optimizers as client or server optimizers. Building upon this, we develop
novel adaptive optimization techniques for FL by using per-coordinate methods as server optimizers.
By focusing on adaptive server optimization, we enable use of adaptive learning rates without increase
in client storage or communication costs, and ensure compatibility with cross-device FL.
Main contributions In light of the above, we highlight the main contributions of the paper.
•	We study a general framework for federated optimization using server and client optimizers. This
framework generalizes many existing federated optimization methods, including FedAvg.
•	We use this framework to design novel, cross-device compatible, adaptive federated optimization
methods, and provide convergence analysis in general nonconvex settings. To the best of our
knowledge, these are the first methods for FL using adaptive server optimization. We show an
important interplay between the number of local steps and the heterogeneity among clients.
•	We introduce comprehensive and reproducible empirical benchmarks for comparing federated
optimization methods. These benchmarks consist of seven diverse and representative FL tasks
involving both image and text data, with varying amounts of heterogeneity and numbers of clients.
•	We demonstrate strong empirical performance of our adaptive optimizers throughout, improving
upon commonly used baselines. Our results show that our methods can be easier to tune, and
highlight their utility in cross-device settings.
Related work FEDAVG was first introduced by McMahan et al. (2017), who showed it can dramati-
cally reduce communication costs. Many variants have since been proposed to tackle issues such as
convergence and client drift. Examples include adding a regularization term in the client objectives
towards the broadcast model (Li et al., 2018), and server momentum (Hsu et al., 2019). When clients
are homogeneous, FedAvg reduces to local Sgd (Zinkevich et al., 2010), which has been analyzed
by many works (Stich, 2019; Yu et al., 2019; Wang & Joshi, 2018; Stich & Karimireddy, 2019; Basu
et al., 2019). In order to analyze FedAvg in heterogeneous settings, many works derive convergence
rates depending on the amount of heterogeneity (Li et al., 2018; Wang et al., 2019; Khaled et al., 2019;
Li et al., 2019b). Typically, the convergence rate of FedAvg gets worse with client heterogeneity.
By using control variates to reduce client drift, the SCAFFOLD method (Karimireddy et al., 2019)
achieves convergence rates that are independent of the amount of heterogeneity. While effective in
cross-silo FL, the method is incompatible with cross-device FL as it requires clients to maintain state
across rounds. For more detailed comparisons, we defer to Kairouz et al. (2019).
Adaptive methods have been the subject of significant theoretical and empirical study, in both
convex (McMahan & Streeter, 2010b; Duchi et al., 2011; Kingma & Ba, 2015) and non-convex
settings (Li & Orabona, 2018; Ward et al., 2018; Wu et al., 2019). Reddi et al. (2019); Zaheer et al.
(2018) study convergence failures of Adam in certain non-convex settings, and develop an adaptive
optimizer, Yogi, designed to improve convergence. While most work on adaptive methods focuses
on non-FL settings, Xie et al. (2019) propose AdaAlter, a method for FL using adaptive client
optimization. Conceptually, our approach is also related to the Lookahead optimizer (Zhang et al.,
2019b), which was designed for non-FL settings. Similar to AdaAlter, an adaptive FL variant of
Lookahead entails adaptive client optimization (see Appendix B.3 for more details). We note that
both AdaAlter and Lookahead are, in fact, special cases of our framework (see Algorithm 1)
and the primary novelty of our work comes in focusing on adaptive server optimization. This allows
us to avoid aggregating optimizer states across clients, making our methods require at most half as
much communication and client memory usage per round (see Appendix B.3 for details).
Notation For a, b ∈ Rd, We let √α, a2 and a/b denote the element-wise square root, square, and
division of the vectors. For θi ∈ Rd, we use both θi,j and [θi]j to denote its jth coordinate.
2 Federated Learning and FedAvg
In federated learning, we solve an optimization problem of the form:
min f(x)
x∈Rd
1m
—X Fi(x),
m
i=1
(1)
where Fi(X) = Ez〜D』fi(x, z)], is the loss function of the ith client, Z ∈ Z, and Di is the data
distribution for the ith client. For i 6= j , Di and Dj may be very different. The functions Fi (and
2
Published as a conference paper at ICLR 2021
therefore f) may be nonconvex. For each i and x, we assume access to an unbiased stochastic gradient
gi(χ) of the client,s true gradient VFi(x). In addition, We make the following assumptions.
Assumption 1 (Lipschitz Gradient). Thefunction Fi is L-smooth for all i ∈ [m] i.e., kVFi(x) 一
VFi (y)k ≤ Lkx - yk, for all x, y ∈ Rd.
Assumption 2 (Bounded Variance). The function Fi have σl-bounded (local) variance i.e.,
E[kV[fi(x,z)]j 一 [VFi(x)]jk2] = σl2,j for all x ∈ Rd, j ∈ [d] and i ∈ [m]. Furthermore, we
assume the (global) variance is bounded, (1/m) im=1 kV[Fi(x)]j 一 [Vf (x)]j k2 ≤ σg2,j for all
x ∈ Rd andj ∈ [d].
Assumption 3 (Bounded Gradients). The function fi(x, z) have G-bounded gradients i.e., for any
i ∈ [m], x ∈ Rd and z ∈ Z we have |[Vfi(x, z)]j | ≤ G for all j ∈ [d].
With a slight abuse of notation, we use σl2 and σg2 to denote Pjd=1 σl2,j and Pjd=1 σg2,j. Assumptions 1
and 3 are fairly standard in nonconvex optimization literature (Reddi et al., 2016; Ward et al., 2018;
Zaheer et al., 2018). We make no further assumptions regarding the similarity of clients datasets.
Assumption 2 is a form of bounded variance, but between the client objective functions and the
overall objective function. This assumption has been used throughout various works on federated
optimization (Li et al., 2018; Wang et al., 2019). Intuitively, the parameter σg quantifies similarity of
client objective functions. Note σg = 0 corresponds to the i.i.d. setting.
A common approach to solving (1) in federated settings is FedAvg (McMahan et al., 2017). At each
round of FedAvg, a subset of clients are selected (typically randomly) and the server broadcasts its
global model to each client. In parallel, the clients run Sgd on their own loss function, and send the
resulting model to the server. The server then updates its global model as the average of these local
models. See Algorithm 3 in the appendix for more details.
Suppose that at round t, the server has model xt and samples a set S of clients. Let xit denote the
model of each client i ∈ S after local training. We rewrite FEDAVG’s update as
xt+1
|s| X Xt = Xt - |s| X(Xt - xt).
i∈S	i∈S
Let ∆it := Xit 一 Xt and ∆t := (1/|S|) Pi∈S ∆it. Then the server update in FEDAVG is equivalent to
applying SGD to the “pseudo-gradient” 一∆t with learning rate η = 1. This formulation makes it
clear that other choices of η are possible. One could also utilize optimizers other than SGD on the
clients, or use an alternative update rule on the server. This family of algorithms, which we refer to
collectively as FedOpt, is formalized in Algorithm 1.
Algorithm 1 FEDOPT
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
Input: X0, CLIENTOPT, SERVEROPT
for t = 0,…，T - 1 do
Sample a subset S of clients
Xit,0 = Xt
for each client i ∈ S in parallel do
for k = 0,…，K — 1 do
Compute an unbiased estimate git,k of VFi(Xit,k)
Xit,k+1 = CLIENTOPT(Xit,k, git,k, ηl, t)
∆it = Xit,K 一 Xt
∆t = |S| Pi∈S δ
Xt+1 = SERVEROPT(xt, -∆t,η,t)
In Algorithm 1, CLIENTOPT and SERVEROPT are gradient-based optimizers with learning rates
ηl and η respectively. Intuitively, CLIENTOPT aims to minimize (1) based on each client’s local
data while ServerOpt optimizes from a global perspective. FedOpt naturally allows the use of
adaptive optimizers (eg. Adam, Yogi, etc.), as well as techniques such as server-side momentum
(leading to FedAvgM, proposed by Hsu et al. (2019)). In its most general form, FedOpt uses a
ClientOpt whose updates can depend on globally aggregated statistics (e.g. server updates in the
3
Published as a conference paper at ICLR 2021
previous iterations). We also allow η and ηl to depend on the round t in order to encompass learning
rate schedules. While we focus on specific adaptive optimizers in this work, we can in principle use
any adaptive optimizer (e.g. AMSGrad (Reddi et al., 2019), AdaB ound (Luo et al., 2019)).
While FEDOPT has intuitive benefits over FEDAVG, it also raises a fundamental question: Can the
negative of the average model difference ∆t be used as a pseudo-gradient in general server optimizer
updates? In this paper, we provide an affirmative answer to this question by establishing a theoretical
basis for FedOpt. We will show that the use of the term ServerOpt is justified, as we can guarantee
convergence across a wide variety of server optimizers, including Adagrad, Adam, and Yogi,
thus developing principled adaptive optimizers for FL based on our framework.
3 Adaptive Federated Optimization
In this section, we specialize FedOpt to settings where ServerOpt is an adaptive optimization
method (one of Adagrad, Yogi or Adam) and ClientOpt is Sgd. By using adaptive methods
(which generally require maintaining state) on the server and Sgd on the clients, we ensure our
methods have the same communication cost as FedAvg and work in cross-device settings.
Algorithm 2 provides pseudo-code for our methods. An alternate version using batched data and
example-based weighting (as opposed to uniform weighting) of clients is given in Algorithm 5. The
parameter τ controls the algorithms’ degree of adaptivity, with smaller values of τ representing higher
degrees of adaptivity. Note that the server updates of our methods are invariant to fixed multiplicative
changes to the client learning rate ηl for appropriately chosen τ , though as we shall see shortly, we
will require ηl to be sufficiently small in our analysis.
Algorithm 2IFEDADAGRAD , IFEDYOGI, and IFEDADAM
1:	Initialization: x0 , v-1 ≥ τ2, decay parameters β1 , β2 ∈ [0, 1)
2:	for t = 0,…，T 一 1 do
3:	Sample subset S of clients
4:	xit,0 = xt
5:	for each client i ∈ S in parallel do
6:	for k = 0,…，K - 1 do
7:	Compute an unbiased estimate gt fc of VFi (Xik)
8:	xit,k+1 = xit,k - ηlgit,k
9:	∆it = xit,K - xt
10:	∆t = BAt-i + (I-为)(啬 Pi∈s δ0
11:	Vt = vt-1 + ∆2 (Fedadagrad)
12:	∣Vt = Vt-1 - (1 - β2)∆ Sign(Vt-I- ∆2) (FEDYOGI)
13:	Vt = β2vt-1 + (1 - β2)∆2 (FedAdam)
14:	xt+1 = Xt + η √vt+τ
We provide convergence analyses of these methods in general nonconvex settings, assuming full
participation, i.e. S = [m]. For expository purposes, we assume β1 = 0, though our analysis can be
directly extended to β1 > 0. Our analysis can also be extended to partial participation (i.e. |S| < m,
see Appendix A.2.1 for details). Furthermore, non-uniform weighted averaging typically used in
FedAvg (McMahan et al., 2017) can also be incorporated into our analysis fairly easily.
Theorem 1. Let Assumptions 1 to 3 hold, and let L, G, σl , σg be as defined therein. Let σ2 =
σl2 + 6Kσg2. Consider the following conditions for ηl:
(Condition I)
(Condition II)
1	1	1 τ	1/3
ηl ≤ K min[16L, T* 1/6 120L2G	,
/ 1	∙ ( 1	J T3 ]1/5	1 Γ τ2
ηi ≤ 3K min j T1/10 [l2G3]	, T1∕8 [lGGη
1/4
}
4
Published as a conference paper at ICLR 2021
Then the iterates of Algorithm 2 for FEDADAGRAD satisfy
under Condition I only,
0≤m≤in-1 EkVf(Xt)k2 ≤ O
under both Condition I & II,
0≤m≤in-1EkVf(Xt)k2 ≤ O
τ
+ ηιKT
+ ηιKT
(Ψ + Ψvar) ,
Ψ + Ψe var
Here, we define
f(xo)- f(x*) + 5η3K2L2T
η
d(ηl KG2 + TrIL) ' + log
2τ
τ2
σ2,
+ ηl2K2G2T
Ψe
var
τ
2ηlKG2 + τηL
τ2
τ2
σl2 + 10ηl4K3L2Tσ2 .
Ψ
All proofs are relegated to Appendix A due to space constraints. When ηl satisfies the condition in the
second part the above result, we obtain a convergence rate depending on min{Ψvar, Ψvar}. To obtain
an explicit dependence on T and K, we simplify the above result for a specific choice of η, ηl and τ .
Corollary 1. Suppose ηι is such that the conditions in Theorem 1 are satisfied and ηι = Θ(1∕(kl√t).
Also suppose η = Θ(√Km) and T = g∕l. Then, for sufficiently large T, the iterates OfAlgorithm 2
for FEDADAGRAD satisfy
min	EkVf(Xt)k2 = O( f(x√-f x*)
0≤t≤T -1	mKT
ι	2σ2L	ι	σ2	∣	σ2L√m
+ G2√mKT + GKT + G2√KT3/2
We defer a detailed discussion about our analysis and its implication to the end of the section.
Analysis of FedAdam Next, we provide the convergence analysis of FEDADAM. The proof of
FedYogi is very similar and hence, we omit the details of FedYogi’s analysis.
Theorem 2. Let Assumptions 1 to 3 hold, and L, G, σι, σg be as defined therein. Letσ2 = σι2+6Kσg2.
Suppose the client learning rate satisfies ηι ≤ 1/16LK and
Then the iterates of Algorithm 2 for FEDADAM satisfy
0≤min-1EkVf(Xt) k2 = O (ylΚG + T " + ψvar)),
where
ψ = f(x0)- f(x*) , 5η3K2L2T 2
η +	2τ	° ,
Ψ，ar =(G+ηL) [T σ + 20η⅞3LTσ2
Similar to the FEDADAGRAD case, we restate the above result for a specific choice of ηι , η and T in
order to highlight the dependence of K and T .
Corollary 2. Suppose ηι is chosen such that the conditions in Theorem 2 are satisfied and that
ηι = Θ(1∕(kl√t)). Also, suppose η = Θ(√Κm) and T = g∕l. Then, for sufficiently large T, the
iterates of Algorithm 2 for FEDADAM satisfy
min
0≤t≤T -1
EkVf(Xt)k2=O
f(xo) - f(x*)
√mκT-
2σ2L	σ2	σ2L√m	ʌ
G2√mKT + GKT + G2√KT3/2 .
σ2
+
5
Published as a conference paper at ICLR 2021
Remark 1. The server learning rate η = 1 typically used in FEDAVG does not necessarily minimize
the upper bound in Theorems 1 & 2. The effectofσg, a measure of client heterogeneity, on convergence
can be reduced by choosing sufficiently ηl and a reasonably large η (e.g. see Corollary 1). Thus, the
effect of client heterogeneity can be reduced by carefully choosing client and server learning rates,
but not removed entirely. Our empirical analysis (eg. Figure 1) supports this conclusion.
Discussion. We briefly discuss our theoretical analysis and its implications in the FL setting. The
convergence rates for FedAdagrad and FedAdam are similar, so our discussion applies to all the
adaptive federated optimization algorithms (including FEDYOGI) proposed in the paper.
(i)	Comparison of convergence rates. When T is sufficiently large compared to K, O(1∕√mκτ)
is the dominant term in Corollary 1 & 2. Thus, we effectively obtain a convergence rate of
O(1∕√mκτ), which matches the best known rate for the general non-convex setting of our interest
(e.g. see (Karimireddy et al., 2019)). We also note that in the i.i.d setting considered in (Wang
& Joshi, 2018), which corresponds to σg = 0, we match their convergence rates. Similar to the
centralized setting, it is possible to obtain convergence rates with better dependence on constants
for federated adaptive methods, compared to FedAvg, by incorporating non-uniform bounds on
gradients across coordinates (Zaheer et al., 2018).
(ii)	Learning rates & their decay. The client learning rate of 1∕√T in our analysis requires knowl-
edge of the number of rounds T a priori; however, it is easy to generalize our analysis to the case
where η is decayed at a rate of 1∕√t. Observe that one must decay ηι, not the server learning
rate η, to obtain convergence. This is because the client drift introduced by the local updates
does not vanish as T → ∞ when ηl is constant. As we show in Appendix E.6, learning rate
decay can improve empirical performance. Also, note the inverse relationship between ηl and η
in Corollary 1 & 2, which we observe in our empirical analysis (see Appendix E.4).
(iii)	Communication efficiency & local steps. The total communication cost of the algorithms
depends on the number of communication rounds T. From Corollary 1 & 2, it is clear that a larger
K leads to fewer rounds of communication as long as K = O(Tσp∕σg). Thus, the number of
local iterations can be large when either the ratio σl2 /σg2 or T is large. In the i.i.d setting where
σg = 0, unsurprisingly, K can be very large.
(iv)	Client heterogeneity. While careful selection of client and server learning rates can reduce
the effect of client heterogeneity (see Remark 1), it does not completely remove it. In highly
heterogeneous settings, it may be necessary to use mechanisms such as control variates (Karim-
ireddy et al., 2019). However, our empirical analysis suggest that for moderate, naturally arising
heterogeneity, adaptive optimizers are quite effective, especially in cross-device settings (see
Figure 1). Furthermore, our algorithms can be directly combined with such mechanisms.
As mentioned earlier, for the sake of simplicity, our analysis assumes full-participation (S = [m]).
Our analysis can be directly generalized to limited participation at the cost of an additional variance
term in our rates that depends on |S |/m, the fraction of clients sampled (see Section A.2.1 for details).
4 Experimental Evaluation: Datasets, Tasks, and Methods
We evaluate our algorithms on what we believe is the most extensive and representative suite of
federated datasets and modeling tasks to date. We wish to understand how server adaptivity can help
improve convergence, especially in cross-device settings. To accomplish this, we conduct simulations
on seven diverse and representative learning tasks across five datasets. Notably, three of the five have
a naturally-arising client partitioning, highly representative of real-world FL problems.
Datasets, models, and tasks We use five datasets: CIFAR-10, CIFAR-100 (Krizhevsky & Hinton,
2009), EMNIST (Cohen et al., 2017), Shakespeare (McMahan et al., 2017), and Stack Overflow (Au-
thors, 2019). The first three are image datasets, the last two are text datasets. For CIFAR-10 and
CIFAR-100, we train ResNet-18 (replacing batch norm with group norm (Hsieh et al., 2019)). For
EMNIST, we train a CNN for character recognition (EMNIST CR) and a bottleneck autoencoder
(EMNIST AE). For Shakespeare, we train an RNN for next-character-prediction. For Stack Overflow,
we perform tag prediction using logistic regression on bag-of-words vectors (SO LR) and train an
RNN to do next-word-prediction (SO NWP). For full details of the datasets, see Appendix C.
Implementation We implement all algorithms in TensorFlow Federated (Ingerman & Ostrowski,
2019). Clients are sampled uniformly at random, without replacement in a given round, but with
replacement across rounds. Our implementation has two important characteristics. First, instead of
6
Published as a conference paper at ICLR 2021
doing K training steps per client, we do E epochs of training over each client’s dataset. Second,
to account for varying numbers of gradient steps per client, we weight the average of the client
outputs ∆it by each client’s number of training samples. This follows the approach of (McMahan
et al., 2017), and can often outperform uniform weighting (Zaheer et al., 2018). For full descriptions
of the algorithms used, see Appendix B.
Optimizers and hyperparameters We compare FEDADAGRAD, FEDADAM, and FEDYOGI (with
adaptivity τ) to FEDOPT where CLIENTOPT and SERVEROPT are SGD with learning rates ηl and
η. For the server, we use a momentum parameter of 0 (FEDAVG), and 0.9 (FEDAVGM). We fix the
client batch size on a per-task level (see Appendix D.3). For FedAdam and FedYogi, we fix a
momentum parameter β1 = 0.9 and a second moment parameter β2 = 0.99. We also compare to
SCAFFOLD (see Appendix B.2 for implementation details). For SO NWP, we sample 50 clients per
round, while for all other tasks we sample 10. We use E = 1 local epochs throughout.
We select ηl, η, and τ by grid-search tuning. While this is often done using validation data in
centralized settings, such data is often inaccessible in FL, especially cross-device FL. Therefore, we
tune by selecting the parameters that minimize the average training loss over the last 100 rounds
of training. We run 1500 rounds of training on the EMNIST CR, Shakespeare, and Stack Overflow
tasks, 3000 rounds for EMNIST AE, and 4000 rounds for the CIFAR tasks. For more details and a
record of the best hyperparameters, see Appendix D.
Validation metrics For all tasks, we measure the performance on a validation set throughout training.
For Stack Overflow tasks, the validation set contains 10,000 randomly sampled test examples (due
to the size of the test dataset, see Table 2). For all other tasks, we use the entire test set. Since
all algorithms exchange equal-sized objects between server and clients, we use the number of
communication rounds as a proxy for wall-clock training time.
5 Experimental Evaluation: Results
5.1	Comparisons between methods
We compare the convergence of our adaptive methods to non-adaptive methods: FedAvg, FedAvgM
and SCAFFOLD. Plots of validation performances for each task/optimizer are in Figure 1, and
Table 1 summarizes the last-100-round validation performance. Due to space constraints, results for
EMNIST CR are in Appendix E.1, and full test set results for Stack Overflow are in Appendix E.2.
Sparse-gradient tasks Text data often
produces long-tailed feature distributions,
leading to approximately-sparse gradients
which adaptive optimizers can capitalize
on (Zhang et al., 2019a). Both Stack Over-
flow tasks exhibit such behavior, though
they are otherwise dramatically different—
in feature representation (bag-of-words vs.
variable-length token sequence), model ar-
chitecture (GLM vs deep network), and
optimization landscape (convex vs non-
convex). In both tasks, words that do not
appear in a client’s dataset produce near-
zero client updates. Thus, the accumulators
vt,j in Algorithm 2 remain small for pa-
rameters tied to rare words, allowing large
Fed...	Adagrad		Adam	Yogi	AvgM	Avg
CIFAR- 10	72.1	77.4	78.0	77.4	72.8
CIFAR- 100	47.9	52.5	52.4	52.4	44.7
EMNIST CR	85.1	85.6	85.5	85.2	84.9
Shakespeare	57.5	57.0	57.2	57.3	56.9
SO NWP	23.8	25.2	25.2	23.8	19.5
SO LR	67.1	65.8	65.9	36.9	30.0
EMNIST AE	4.20	1.01	0.98	1.65	6.47
Table 1: Average validation performance over the last
100 rounds: % accuracy for rows 1-5; Recall@5 (X100)
for Stack Overflow LR; and MSE (×1000) for EMNIST
AE. Performance within 0.5% of the best result for each
task are shown in bold.
updates to be made when they do occur. This intuition is born out in Figure 1, where adaptive
optimizers dramatically outperform non-adaptive ones. For the non-convex NWP task, momentum is
also critical, whereas it slightly hinders performance for the convex LR task.
Dense-gradient tasks CIFAR-10/100, EMNIST AE/CR, and Shakespeare lack a sparse-gradient
structure. Shakespeare is relatively easy—most optimizers perform well after enough rounds once suit-
ably tuned, though FEDADAGRAD converges faster. For CIFAR-10/100 and EMNIST AE, adaptivity
and momentum offer substantial improvements over FedAvg. Moreover, FedYo gi and FedAdam
have faster initial convergence than FedAvgM on these tasks. Notably, FedAdam and FedYogi
perform comparably to or better than non-adaptive optimizers throughout, and close to or better than
7
Published as a conference paper at ICLR 2021

,86,42,0
Ooooo
ClFAR-Io
ClFAR ・100
IOOO 2000	3000	4000
Number of Rounds
EMNIST AE
山pajronbs uro①W
0 00O	1000	2000	3000
Number of Rounds
1000	2000	3000	4000
Number of Rounds
Shakespeare
200 400 600 800 1000 1200
Number of Rounds
Stack Overflow LR
-8-64 2
Oooo
s©__S ①α
500	1000
Number of Rounds
1500

Figure 1: Validation accuracy of adaptive and non-adaptive methods, as well as SCAFFOLD, using
constant learning rates η and ηl tuned to achieve the best training performance over the last 100
communication rounds; see Appendix D.2 for grids.
FedAdagrad throughout. As we discuss below, FedAdam and FedYogi actually enable easier
learning rate tuning than FedAvgM in many tasks.
Comparison to SCAFFOLD On all tasks, SCAFFOLD performs comparably to or worse than
FedAvg and our adaptive methods. On Stack Overflow, SCAFFOLD and FedAvg are nearly
identical. This is because the number of clients (342,477) makes it unlikely we sample any client
more than once. Intuitively, SCAFFOLD does not have a chance to use its client control variates. In
other tasks, SCAFFOLD performs worse than other methods. We present two possible explanations:
First, we only sample a small fraction of clients at each round, so most users are sampled infrequently.
Intuitively, the client control variates can become stale, and may consequently degrade the perfor-
mance. Second, SCAFFOLD is similar to variance reduction methods such as SVRG (Johnson
& Zhang, 2013). While theoretically performant, such methods often perform worse than Sgd in
practice (Defazio & Bottou, 2018). As shown by Defazio et al. (2014), variance reduction often only
accelerates convergence when close to a critical point. In cross-device settings (where the number of
communication rounds are limited), SCAFFOLD may actually reduce empirical performance.
5.2	Ease of tuning
Stack Overflow NWP, FedYogi
Stack Overflow NWP, FedAdam
Client Learning Rate (logɪo)
ACCUraCy
ŋ 5 O 5 O I
3 2 2 Il 51 O
1.0 2.3 1.9 1.3 0.3 0.4 0.0 0.0
3 0.5 ɪə 0.9 0.8 0.4 1.2 1.0
o.o
0.0 0.0
D 0.0 1.4 1.4 0.7 0.6 2.2 0.9 0.0
1.6 0.0
7.5
-3.0
2.1 0.3 1.5 2.3 8.0
2 -0-5
.c-1.0
S-1.5
fe-2.0
己
*25
14.3
12.1 14.3
-3.0-2.5-2.0-1.5-1.0-0.5 0
0.0 0.0
0.0 0.0
0.0 0.0
0.0 0.0
0.2 0.0
Client Learning Rate (logɪo)
o.o
o.o
0 Q.5
ACCUraCy
ŋ 5 O 5 O I
3F2F2Ilf5l0
Stack Overflow NWP, FedAvgM
1.0 i5∙o
3 0.5 1O∙3
S 0.0 7.0
0.0
1.6 0.6 0.0 2.3 1.7
2 -0.5 5.6 7.0
C -1.0 0-5 5.6
0.4
10.7
0.2
10.5
0.
7.1
7.2
10.2
14.6
10.1
-2.5 O.o 0.0 0.0 1.2 5.4 6.9
5.5 7.0
ra -1.5 0.0	0.5 5.5
⅛ -2.0 0 0	0.0 0.9
-3.0 O.o 0.0 0.0 0.0 0.6 5.0
1.4
0.0
0.0
1.6
0.0
2.4 2.2
0.0 1.4
0.0
1.3 0.0
-3.0-2.5-2.0-1.5-i.o-0.5 0：0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
ŋ 5 O 5 O ' I
3 2 2 Il 5 O
Figure 2: Validation accuracy (averaged over the last 100 rounds) of FedAdam, FedYogi, and
FedAvgM for various client/server learning rates combination on the SO NWP task. For FedAdam
and FEDYOGI, we set τ = 10-3.
Obtaining optimal performance involves tuning ηl, η, and for the adaptive methods, τ. To quantify
how easy it is to tune various methods, we plot their validation performance as a function of ηl and η .
Figure 2 gives results for FedAdam, FedYogi, and FedAvgM on Stack Overflow NWP. Plots for
all other optimizers and tasks are in Appendix E.3. For FedAvgM, there are only a few good values
of ηl for each η, while for FEDADAM and FEDYOGI, there are many good values of ηl for a range of
8
Published as a conference paper at ICLR 2021
0.60
0.60
0.50
CIFAR-IO
5 0 5
7 7∙6
Ooo
>UE≡U<
IO-5
10^4 10~3 10~2
Adaptivity (τ)
io-1
Shakespeare
0.58
S0.56
n
u 0.54
<
0.52
IO-5
ib^4 ib-3 ib_2 ib^1
Agptivity (τ)
CIFAR-100
10^4	10~3	10~2
Adaptivity (r)
Stack Overflow LR
io-1
10^4 10~3 10-2 10^1
Adaptivity (τ)
Adaptivity (τ)
0.30
Stack Overflow NWP
5 0 5
2 2 1
>UE≡U<
Figure 3: Validation performance of FEDADAGRAD, FEDADAM, and FEDYOGI for varying τ on
various tasks. The learning rates η and ηl are tuned for each τ to achieve the best training performance
on the last 100 communication rounds.
η. Thus, FEDADAM and FEDYOGI are arguably easier to tune in this setting. Similar results hold for
other tasks and optimizers (Figures 5 to 11).
This leads to a natural question: Is the reduction in the need to tune ηl and η offset by the need to
tune the adaptivity τ ? In fact, while we tune τ in Figure 1, our results are relatively robust to τ . To
demonstrate, we plot the best validation performance for various τ in Figure 3. For nearly all tasks
and optimizers, τ = 10-3 works almost as well all other values. This aligns with work by Zaheer
et al. (2018), who show that moderately large τ yield better performance for centralized adaptive
optimizers. FEDADAM and FEDYOGI see only small differences in performance among τ on all tasks
except Stack Overflow LR (for which FEDADAGRAD is the best optimizer, and is robust to τ).
5.3	Other Findings
We present additional empirical analyses in Appendix E. These include EMNIST CR results (Ap-
pendix E.1), Stack Overflow results on the full test dataset (Appendix E.2), client/server learning rate
heat maps for all optimizers and tasks (Appendix E.3), an analysis of the relationship between η and
ηl (Appendix E.4), and experiments with learning rate decay (Appendix E.6).
6 Conclusion
In this paper, we demonstrated that adaptive optimizers can be powerful tools in improving the conver-
gence of FL. By using a simple client/server optimizer framework, we can incorporate adaptivity into
FL in a principled, intuitive, and theoretically-justified manner. We also developed comprehensive
benchmarks for comparing federated optimization algorithms. To encourage reproducibility and
breadth of comparison, we have attempted to describe our experiments as rigorously as possible,
and have created an open-source framework with all models, datasets, and code. We believe our
work raises many important questions about how best to perform federated optimization. Example
directions for future research include understanding how the use of adaptivity affects differential
privacy and fairness.
References
The TensorFlow Federated Authors. TensorFlow Federated Stack Overflow dataset,
2019. URL https://www.tensorflow.org/federated/api_docs/python/tff/
simulation/datasets/stackoverflow/load_data.
9
Published as a conference paper at ICLR 2021
Debraj Basu, Deepesh Data, Can Karakus, and Suhas Diggavi. Qsparse-local-SGD: Distributed
SGD with quantization, sparsification and local computations. In Advances in Neural Information
Processing Systems,pp. 14668-14679, 2019.
Keith Bonawitz, Hubert Eichner, Wolfgang Grieskamp, Dzmitry Huba, Alex Ingerman, Vladimir
Ivanov, Chloe Kiddon, Jakub Konecny, Stefano Mazzocchi, Brendan McMahan, Timon
Van Overveldt, David Petrou, Daniel Ramage, and Jason Roselander. Towards feder-
ated learning at scale: System design. In A. Talwalkar, V. Smith, and M. Zaharia
(eds.), Proceedings of Machine Learning and Systems, volume 1, pp. 374-388. Proceed-
ings of MLSys, 2019. URL https://proceedings.mlsys.org/paper/2019/file/
bd686fd640be98efaae0091fa301e613- Paper.pdf.
Sebastian Caldas, Peter Wu, Tian Li, Jakub Konecny, H Brendan McMahan, Virginia Smith, and
Ameet Talwalkar. LEAF: A benchmark for federated settings. arXiv preprint arXiv:1812.01097,
2018.
Gregory Cohen, Saeed Afshar, Jonathan Tapson, and Andre Van Schaik. EMNIST: Extending MNIST
to handwritten letters. In 2017 International Joint Conference on Neural Networks (IJCNN), pp.
2921-2926. IEEE, 2017.
Aaron Defazio and Leon Bottou. On the ineffectiveness of variance reduced optimization for deep
learning. arXiv preprint arXiv:1812.04529, 2018.
Aaron Defazio, Francis Bach, and Simon Lacoste-Julien. SAGA: A fast incremental gradient method
with support for non-strongly convex composite objectives. In NIPS, pp. 1646-1654, 2014.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and
stochastic optimization. Journal of Machine Learning Research, 12(Jul):2121-2159, 2011.
Priya Goyal, Piotr Dolldr, Ross Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola,
Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch SGD: Training
ImageNet in 1 hour. arXiv preprint arXiv:1706.02677, 2017.
Kevin Hsieh, Amar Phanishayee, Onur Mutlu, and Phillip B Gibbons. The non-IID data quagmire of
decentralized machine learning. arXiv preprint arXiv:1910.00189, 2019.
Tzu-Ming Harry Hsu, Hang Qi, and Matthew Brown. Measuring the effects of non-identical data
distribution for federated visual classification. arXiv preprint arXiv:1909.06335, 2019.
Alex Ingerman and Krzys Ostrowski.	Introducing TensorFlow Fed-
erated, 2019.	URL https://medium.com/tensorflow/
introducing- tensorflow- federated- a4147aa20041.
Rie Johnson and Tong Zhang. Accelerating stochastic gradient descent using predictive variance
reduction. In Advances in Neural Information Processing Systems, pp. 315-323, 2013.
Peter Kairouz, H Brendan McMahan, Brendan Avent, Aurelien Bellet, Mehdi Bennis, Arjun Nitin
Bhagoji, Keith Bonawitz, Zachary Charles, Graham Cormode, Rachel Cummings, et al. Advances
and open problems in federated learning. arXiv preprint arXiv:1912.04977, 2019.
Sai Praneeth Karimireddy, Satyen Kale, Mehryar Mohri, Sashank J Reddi, Sebastian U Stich, and
Ananda Theertha Suresh. SCAFFOLD: Stochastic controlled averaging for on-device federated
learning. arXiv preprint arXiv:1910.06378, 2019.
Ahmed Khaled, Konstantin Mishchenko, and Peter Richtdrik. First analysis of local GD on heteroge-
neous data. arXiv preprint arXiv:1909.04715, 2019.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In 3rd International
Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May 7-9, 2015,
Conference Track Proceedings, 2015.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images.
Technical report, Citeseer, 2009.
10
Published as a conference paper at ICLR 2021
Tian Li, Anit Kumar Sahu, Manzil Zaheer, Maziar Sanjabi, Ameet Talwalkar, and Virginia Smith.
Federated optimization in heterogeneous networks. arXiv preprint arXiv:1812.06127, 2018.
Tian Li, Anit Kumar Sahu, Ameet Talwalkar, and Virginia Smith. Federated learning: Challenges,
methods, and future directions. arXiv preprint arXiv:1908.07873, 2019a.
Wei Li and Andrew McCallum. Pachinko allocation: DAG-structured mixture models of topic
correlations. In Proceedings of the 23rd international conference on Machine learning, pp. 577-
584, 2006.
Xiang Li, Kaixuan Huang, Wenhao Yang, Shusen Wang, and Zhihua Zhang. On the convergence of
FedAvg on non-IID data. arXiv preprint arXiv:1907.02189, 2019b.
Xiaoyu Li and Francesco Orabona. On the convergence of stochastic gradient descent with adaptive
stepsizes. arXiv preprint arXiv:1805.08114, 2018.
Liangchen Luo, Yuanhao Xiong, Yan Liu, and Xu Sun. Adaptive gradient methods with dynamic
bound of learning rate. In 7th International Conference on Learning Representations, ICLR 2019,
New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019. URL https://openreview.
net/forum?id=Bkg3g2R9FX.
Brendan McMahan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Aguera y Areas.
Communication-efficient learning of deep networks from decentralized data. In Proceedings of the
20th International Conference on Artificial Intelligence and Statistics, AISTATS 2017, 20-22 April
2017, Fort Lauderdale, FL, USA, pp. 1273-1282, 2017. URL http://proceedings.mlr.
press/v54/mcmahan17a.html.
H. Brendan McMahan and Matthew Streeter. Adaptive bound optimization for online convex
optimization. In COLT, 2010a.
H.	Brendan McMahan and Matthew J. Streeter. Adaptive bound optimization for online convex
optimization. In COLT The 23rd Conference on Learning Theory, 2010b.
Sashank J Reddi, Ahmed Hefny, Suvrit Sra, BarnabgS P6cz6s, and Alex Smola. Stochastic variance
reduction for nonconvex optimization. arXiv:1603.06160, 2016.
Sashank J Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of ADAM and beyond. arXiv
preprint arXiv:1904.09237, 2019.
Sebastian U. Stich. Local SGD converges fast and communicates little. In International Confer-
ence on Learning Representations, 2019. URL https://openreview.net/forum?id=
S1g2JnRcFX.
Sebastian U Stich and Sai Praneeth Karimireddy. The error-feedback framework: Better rates for
SGD with delayed gradients and compressed communication. arXiv preprint arXiv:1909.05350,
2019.
Jianyu Wang and Gauri Joshi. Cooperative SGD: A unified framework for the design and analysis of
communication-efficient SGD algorithms. arXiv preprint arXiv:1808.07576, 2018.
Shiqiang Wang, Tiffany Tuor, Theodoros Salonidis, Kin K Leung, Christian Makaya, Ting He, and
Kevin Chan. Adaptive federated learning in resource constrained edge computing systems. IEEE
Journal on Selected Areas in Communications, 37(6):1205-1221, 2019.
Rachel Ward, Xiaoxia Wu, and Leon Bottou. Adagrad stepsizes: Sharp convergence over nonconvex
landscapes, from any initialization. arXiv preprint arXiv:1806.01811, 2018.
Xiaoxia Wu, Simon S Du, and Rachel Ward. Global convergence of adaptive gradient methods for an
over-parameterized neural network. arXiv preprint arXiv:1902.07111, 2019.
Yuxin Wu and Kaiming He. Group normalization. In Proceedings of the European Conference on
Computer Vision (ECCV), pp. 3-19, 2018.
Cong Xie, Oluwasanmi Koyejo, Indranil Gupta, and Haibin Lin. Local AdaAlter: Communication-
efficient stochastic gradient descent with adaptive learning rates. arXiv preprint arXiv:1911.09030,
2019.
11
Published as a conference paper at ICLR 2021
Hao Yu, Sen Yang, and Shenghuo Zhu. Parallel restarted SGD with faster convergence and less
communication: Demystifying why model averaging works for deep learning. In Proceedings of
the AAAI Conference on Artificial Intelligence, volume 33, pp. 5693-5700, 2019.
Manzil Zaheer, Sashank Reddi, Devendra Sachan, Satyen Kale, and Sanjiv Kumar. Adaptive methods
for nonconvex optimization. In Advances in Neural Information Processing Systems, pp. 9815-
9825, 2018.
Jingzhao Zhang, Sai Praneeth Karimireddy, Andreas Veit, Seungyeon Kim, Sashank J. Reddi,
Sanjiv Kumar, and Suvrit Sra. Why ADAM beats SGD for attention models. arXiv preprint
arxiv:1912.03194, 2019a.
Michael R. Zhang, James Lucas, Jimmy Ba, and Geoffrey E. Hinton. Lookahead optimizer: k
steps forward, 1 step back. In Hanna M. Wallach, Hugo Larochelle, Alina Beygelzimer, Florence
d,Alche-Buc, Emily B. Fox, and Roman Garnett (eds.), Advances in Neural Information Processing
Systems 32: Annual Conference on Neural Information Processing Systems 2019, NeurIPS 2019,
8-14 December 2019, Vancouver, BC, Canada, pp. 9593-9604, 2019b.
Martin Zinkevich, Markus Weimer, Lihong Li, and Alex J Smola. Parallelized stochastic gradient
descent. In Advances in neural information processing systems, pp. 2595-2603, 2010.
12
Published as a conference paper at ICLR 2021
A	Proof of results
A.1 Main Challenges
We first recap some of the central challenges to our analysis. Theoretical analyses of optimization
methods for federated learning are much different than analyses for centralized settings. The key
factors complicating the analysis are:
1.	Clients performing multiple local updates.
2.	Data heterogeneity.
3.	Understanding the communication complexity.
As a result of (1), the updates from the clients to the server are not gradients, or even unbiased estimates
of gradients, they are pseudo-gradients (see Section 2). These pseudo-gradients are challenging to
analyze as they can have both high bias (their expectation is not the gradient of the empirical loss
function) and high variance (due to compounding variance across client updates) and are therefore
challenging to bound. This is exacerbated by (2), which we quantify by the parameter σg in Section 2.
Things are further complicated by (3), as we must obtain a good trade-off between the number of
client updates taken per round (K in Algorithms 1 and 2) and the number of communication rounds
T . Such trade-offs do not exist in centralized optimization.
A.2 Proof of Theorem 1
Proof of Theorem 1. Recall that the server update of FEDADAGRAD is the following
χt+ι,i = χt,i + η ʒ^t,i—,
√vj + T
for all i ∈ [d]. Since the function f is L-smooth, we have the following:
f (Xt+1) ≤ f (Xt) +〈▽/(Xt), xt+1 - xti + 2 kxt+1 - xtk2
=f(Xt) + η (Vf(Xj √VΓ+7〉+ η2L X (√v⅛+τ)2	⑵
The second step follows simply from FEDADAGRAD’s update. We take the expectation of f(Xt+1)
(over randomness at time step t) in the above inequality:
Et[f (Xt+1)] ≤ f (Xt) + η (Vf(Xt), Et [√vδ+7D + η2L XEt ](√δ⅛
=f (Xt) + η (Vf(Xj Et [√VΓ+7 - √v!⅛ + √v!⅛D
f(Xt)+ η(Vf(Xt),Et [ ^δ!	)+η(Vf(Xt),Et	ʌɪ--------工 )
∖	L√vt-1 + 7」/	∖	L√vt + τ	W-I + 7」/
`----------{-----------}	`---------------{---------------}
T1	T2
事
(√vtj + T )2
j=1
(3)
13
Published as a conference paper at ICLR 2021
We will first bound T2 in the following manner:
T
),Et
.√Vt + T	√vt-i + T_
Et >E'× [ √⅛
d
Et EVf(xt)]j × ∆t,j ×
j=ι
一	√v-17- √⅞^ 一
一(√vt7 + T )(√v-17 + T )，一
and recalling Vt = vt-1 + ∆2 so -∆2,j. = (√vt-ι,j - √vj)(√vt-ι,j + √vtjj)) We have,
d
=Et ^X[▽/(Xt)]j × 't,j ×
j=ι
d
≤ Et E ∣Vf(xt)]j | X ∣∆t,j|
j=i
d
≤ Et E ∣Vf(xt)]j ∣ X ∣∆t,j∣
j=ι
(√v7 + T )(√vt-1,j + T )(√vt-1,j + √vtj)
△2,7	#
(Vt,j + T 2)(√v-17 + T)
since %—ι,j ≥ T2.
Here vt-17 ≥ T since v-1 ≥ T (see the initialization of Algorithm 2) and vt,j is increasing in t. The
above bound can be further upper bounded in the following manner:
d
T2 ≤ Et E ηlKG2
7 = 1
ηιKG2
T
(Vt,j+ T 2)(√v-17 + T)
一	∆2,j	#
_Pt=°$ + t 2J
since [Vf(xt)]i ≤ G and ∆t,i ≤ ηιKG
since √vt-17 ≥ 0.	(4)
d
≤ Et E
7 = 1
—
—
Z,j
j + T	√vF + T
×
×
Bounding Ti We now turn our attention to bounding the term T∖, which we need to be sufficiently
negative. We observe the following:
Ti = 〈 Vf(Xt), Et
+T
√f⅛，Et CtfK Vf(Xt)+ ηiK Vf(Xt)]
d
-ηιK E
7=1
[Vf (χt)]2
√vF + T
+ ( ^fxh, Et [∆t + ηιK Vf(Xt)]).
∖√vt-1 + T
X-----------------V----------------}
T3
(5)
In order to bound Ti, we use the following upper bound on T3 (which captures the difference between
the actual update ∆t and an appropriate scaling of -Vf(Xt)):
Vf (Xt)
√vt-1 + T
Et [∆t + ηιKVf(Xt)]
(√f⅛τ, Et- mm E J必+ηιK Vf(Xt)D
(f+)T,Et -mEEηιVFi(Xt,k)+ηιKVf(Xt)
14
Published as a conference paper at ICLR 2021
Here We used the fact that Vf (Xt) = ml Pm=I VFi(Xt) and gt fc is an unbiased estimator of the
gradient at xit,k, we further bound T3 as follows using a simple application of the fact that ab ≤
(a2 + b2)/2. :
t ≤	ηιKXX	[Vf(Xt)]2	+ JLE UlɪXlK- VFi(Xt,k)- ɪXXK- VFi(Xt)	11
^	2 j=1	√v-j + T 2K [IIm ⅛	k=0	√√vt-1+ τ m ⅛ k=0	W +	TIU
≤ ηιK XX [Vf(xt)j + 上E jχK-1 VFi(Xt,k)-VFi(Xt)(21
-2 j=ι √vt-ιj+T	2m t[⅛ ⅛	√√v-1+τ	H
≤ ηl^- X '▽'(”‘)j——+ ηl^LEt X X ∣∣Xt k - Xtk2	using Assumption 1 and Vt-I ≥ 0.
—2 M √vt-1j+T 2mτ	Li=1 k=0	,	J	—
(6)
The second inequality folloWs from Lemma 6. The last inequality folloWs from L-Lipschitz nature of
the gradient (Assumption 1). We noW prove a lemma that bounds the “drift” of the Xit,k from Xt:
Lemma 3. For any step-size satisfying ηι ≤ 8Lk, we can bound the driftfor any k ∈ {0, ∙∙∙ ,K -1}
as
1m	d
m XE∣Xt,k-Xtk2 ≤ 5KηlEX(σ2,j + 2Kσgj) + 30K2η2E[∣Vf (Xt)))∣2].	(7)
m i=1	j=1
Proof. The result trivially holds for k = 1 since Xti,0 = Xt for all i ∈ [m]. We noW turn our attention
to the case Where k ≥ 1. To prove the above result, We observe that for any client i ∈ [m] and
k∈ [K],
EkXit,k - Xtk2 = EIIXit,k-1 - Xt - ηιgit,k-1II2
≤ EIIXti,k-1 - Xt - ηι(git,k-1 - VFi(Xit,k-1) + VFi(Xit,k-1) - VFi(Xt) + VFi(Xt) - Vf(Xt) + Vf(Xt))II2
≤ (1 + 2K1-1) E∣∣Xt,k-ι - Xtll2 + E∣∣ηι(gt,k-1 - VFi(Xt,k-1))∣∣2
+ 6KE[kηι(VFi(Xit,k-1) - VFi(Xt))k2] + 6KE[kηι(VFi(Xt) - Vf(Xt))k2] + 6KE[kηιVf(Xt)))k2]
The first inequality uses the fact that gkt -1,i is an unbiased estimator of VFi (Xit,k-1) and Lemma 7.
The above quantity can be further bounded by the folloWing:
d
EkXit,k-1 - Xtk2 + ηι2E X σι2,j + 6Kηι2EkL(Xti,k-1 - Xt)k2
j=1
+6KE[kηι(VFi(Xt)-Vf(Xt))k2] +6KE[kηιVf(Xt)))k2]
EkXt,k - Xtk2 ≤ (1+ 2K - 1)
=(1 + 2K-I + 6Kη2L2) Ek(Xt,k-1 - Xt)k2 + ηι2E X σι2,j
j=1
+ 6KE[kηι(VFi(Xt) - Vf(Xt))k2] + 6Kηι2E[kVf(Xt)))k2]
Here, the first inequality folloWs from Assumption 1 and 2. Averaging over the clients i, We obtain
the folloWing:
m	md
ɪ XEkXi,k-Xtk2 ≤	1 + 2K⅛+6Kηι2L2 ɪ XEkXt,k-i-Xtk2 + η2EXσ2j
m	-	m
i=1	i=1	j=1
m
+ 6K XE[kηι(VFi(Xt) - Vf (Xt))k2] + 6Kη2E[kVf (Xt)))k2]
m i=1
1	1m	d
≤ ( 1 + 2K - 1 +6Kη2L2) m EEkXt,k-i -Xtk2 + η2EE(σ2j+6Kσg,j)
i=1	j=1
+ 6Kηι2E[kVf(Xt)))k2]
15
Published as a conference paper at ICLR 2021
From the above, we get the following inequality:
1m
一XEkxt,k - xtk2 ≤
m,
i=1
1	1m	d
1 + K-I	- X Ekxit,k-1 - xt k2 + ηl2E X(σl2,j + 6K σg2,j)
- i=1	j=1
+ 6Kη2E[∣Nf (Xt))) k2]
Unrolling the recursion, we obtain the following:
m	k-1	p
J XEKk - Xtk2 ≤ X 1 + K1:-1
i=1	p=0
≤ (K - 1) X [(1 + k-i)	- 1 Xn
d
η2E X(σ2,j + 6Kσg,j) + 6κη2E[∣Nf (Xt)))II2]
j=1
d
W(σ2j + 6Kσgj + 6Kη2E[kVf(xt)))k2]
j=1
d
≤ 5Kηl2EX(σl2,j+6Kσg2,j)+30K2ηl2E[IVf(Xt)))I2] ,
j=1
concluding the proof of Lemma 3. The last inequality uses the fact that (1 + k-ι)k ≤ 5 for
K > 1.	□
Using the above lemma in Equation 6 and Condition I, we can bound T3 in the following manner:
T3 ≤
nιK G	[Vf (Xt) j	nιL2πr
F M √v-1j + T + 后Et
m K-1 d
X X X([Xit,k]j - [Xt]j)2
i=1 k=0 j=1
≤ nιK X [vf(χt)j + nιKL2
2	2	j=1 √vt-ι,j + T	2τ
d
5Kηι2EX(σι2,j + 6Kσg2,j) + 30K2ηι2E[kVf(Xt)))k2]
j=1
3ηιK d	[Vf(Xt)]j2
≤	+
_	4	j=l √v-ιj+ T
5n3K2L2 E X (σ2j+6Kσgj)
j=1
Here we used the fact that √vt-ι,j ≤ nιKGy∕T and Condition I in Theorem 1. Using the above
bound in Equation 5, we get
T1 ≤-nKX Vf(Xt)j +
—	4 j=l √v-j + τ
5nfκ 2L2
-2T-
d
EX(σι2,j +6Kσg2,j)
j=1
(8)
Putting the pieces together Substituting in Equation (3), bounds T1 in Equation (8) and bound T2
in Equation (4), we obtain
Et[f (Xt+1)] ≤ f (Xt) + n X -nK X ≡B + TEX(σι2,j + 6Kσg,j)
d
+n X EX
j=1
nιKG2
T
∆2,j
Pt=o ∆2,j + τ2
△2,j
Pt=o ∆2,j + τ2
(9)
Rearranging the above inequality and summing it from t = 0 to T - 1, we get
TX nιK X W Vf(Xt)]2
⅛0 丁 ⅛1	√vt-1j + τ
f(X0)- E[f(Xτ)]
n
+ — X (σ2j +6Kσg,j)
j=1
T-1	d
+XEX
nι kg2 +
△2,j
Pt=o ∆2,j + τ2
(10)
≤
T
X
16
Published as a conference paper at ICLR 2021
The first inequality uses simple telescoping sum. For completing the proof, we need the following
result.
Lemma 4. The following upper bound holds for Algorithm 2 (FEDADAGRAD):
T-1 d	∆2
E XX —ʃ——t,j------- ≤
t=0 j=1 Pt=0 δ13 + T2 -
.ʃ
min
d
d + log
j=1
1+
η2κ 2g2t A
T2	)
4η2KT
mT2
dd
X σl2,j + 20ηl4K3L2TE X
j=1	j=1
jKj + — Xl E hkVf(xt)『
T	T	t=0
Proof. We bound the desired quantity in the following manner:
+
T-1 d
EXt=0Xj=1
Pt=0 ∆2,j + T2
d
≤ d+ EXlog
j=1
d
≤ d + log 1 +
j=1
η2K 2G2T A
τ2广
An alternate way of the bounding this quantity is as follows:
T-1 d
EXt=0Xj=1Plt=0
T-1 d ∆2
一≤ E XX 与
+ * -	t=0 j=1 τ 2
T-1
≤EX
t=0
∆ + ηιKVf(Xt)- ηιKVf(Xt)
T
T-1
≤ 2EX
t=0
△t + ηιK Vf(Xt)
T
2
+ ηι2K2
Vf(Xt)
T
(11)
The first quantity in the above bound can be further bounded as follows:
T-1
2EX
t=0
1
T
m K-1
-m X X ηι%+ηι K Vf(Xt)
T-1
2EX
t=0
1	1 m K-1
-∙ I m XX (ηιg[k - ηιVFi(Xrk) + ηNFi(Xti,k) - ηNFi(Xt) + ηNFi(Xt) - ηιKVf(Xt)
T	m i=1 k=0
2
2 2 T-1	m K-1 1
m X EllXX : ∙ (gt,k - VFi(Xt,k) + VFi(Xt,k) - VFi(Xt))
t=0	i=1 k=0
1 2 T-1	ΓH m K-1 1
≤ m XEIIIX X T ∙ (gt,k- VFi(Xt,m
t=0	l i=1 k=0
2 m K-1 T-1
+ 4η2K E XXX
m
i=1 k=0 t=0
2 m K-1 T-1
+ 4η2K E XXX
m
i=1 k=0 t=0
2 m K-1 1	2
+ XX T ∙ (VFi(Xi,k)-VFi(Xt)) Il
I i=1 k=0 T	I
I2
(VFi(X黑)-VFi(Xt))
I2
Xit,k - Xt I (by Assumptions 1 and 2)
≤
≤
1
T
L
T
≤ T X σ2,j + 20η4 K 3L2T X jKj + 40η4K^ ∑ E [∣∣Vf (“)『]	(byLemma 3).
j=1	j=1	t=0
Here, the first inequality follows from simple application of the fact that ab ≤ (a2 + b2)/2. The result
follows.
17
Published as a conference paper at ICLR 2021
Substituting the above bound in Equation (10), we obtain:
ηιK T-1 J [Vf(xt)]2
4 t=0 j=1	√v-j + T
≤
f(xo) - E[f (XT)] + 5η3K2L2
η
2τ
T-1 d
EXX(σl2,j +6Kσg2,j)
4ηl2KT
d
mτ2
j=1
+ X (H +
j=1
×
t=0 j =1
min d + d log 1 +
σl2,j + 20ηl4K3L2T
We observe the following:
X X [VEf(χt)]2
t=0 j=1 √vt-1,j + T
T-1 d
≥Xt=0Xj=1Eηl
d
j=1
ηl2K2G2T
τ2
+
⅛+ 6Kσg,/ l 40η4κ4L
τ2
τ2
2 TX-1 E hkVf(Xt)k2
t=0
(12)
[Vf(χt)]2
KG√T + T
〉 T
一ηιKG√T + T
0mt≤T EkVf(Xt) k2.
The second part of Theorem 1 follows from using the above inequality in Equation (12). Note that
the first part of Theorem 1 is obtain from the part of Lemma 4.
□
A.2.1 Limited Participation
For limited participation, the main changed in the proof is in Equation (11). The rest of the proof is
similar so we mainly focus on Equation (11) here. Let S be the sampled set at the tth iteration such
that |S | = s. In partial participation, we assume that the set S is sampled uniformly from all subsets
of [m] with size s. In this case, for the first term in Equation (11), we have
T-1	1
2E X 1 •
T1
—
t=0
T-1
2EX
t=0
∣Ss∣ XX m gt,k+m K Vf(Xt))]
|S | i∈S k=0
1 •(- X X(ηgi,k-ηNFi(Xi,k) + ηιVFi(X.,k) - ηlVFi(χt) + mVFi(Xt)) - ηικVf(Xt)
2
≤
整 X EilX X T ∙ (gt,k - NFi(Xti,k))
t=0	i∈S k=0
2
+
2
K-1 1
∑∑-∙ (VFi(Xt,k) - VFi(Xt))
i∈S k=0
2
+ K2
Fi (Xt) - sVf(Xt)
≤
6η2KT
s
≤
6ηl2KT
j=1
6 2K	K-1 T-1
T E XXX
i∈S k=0 t=0
T ∙ (VFi(Xi,k) - VFi(Xt))	+
2
6η2K 2Tσg
T2
1 - -s
m
s
2	2	K-1 T-1
X妥+半E XXX
≤
6ηl2KT
j=1
i∈S k=0 t=0
L
T
6η2K 2Tσg
T2
1 - -s
m

T2s
j=1
σl2,j +30ηl4K3L2TE
(σ2j + 6Kσg,j) 1 60η4K4 L
j=1
T2
T2
2 TX-1 E hkVf(Xt)k2i
+
t=0
6η2 K 2Tσg
T2
1 - -s
m
Note that the expectation here also includes S . The first inequality is obtained from the fact that
(a+ b+ c)2 ≤ 3(a2 + b2 +c2). The second inequality is obtained from the fact that setS is uniformly
18
Published as a conference paper at ICLR 2021
sampled from all subsets of [m] with size s. The third and fourth inequalities are similar to the
one used in proof of Theorem 1. Substituting the above bound in Equation (10) gives the desired
convergence rate.
A.3 Proof of Theorem 2
Proof of Theorem 2. The proof strategy is similar to that of FEDADAGRAD except that we need to
handle the exponential moving average in FedAdam. We note that the update of FedAdam is the
following
工	∆t
χt+ι = Xt + η L I一,
√vt + T
for all i ∈ [d]. Using the L-smooth nature of function f and the above update rule, we have the
following:
f(xt+ι) ≤ f(xt)+ η (Vf(Xj 二)+ η2L X W⅛	(13)
The second step follows simply from FEDADAM’s update. We take the expectation of f(xt+1) (over
randomness at time step t) and rewrite the above inequality as:
Et[f(xt+1)] ≤ f (xt)	+ η (Vf (xt), Et	[-Iδ----------,	+	, 1 V η2L X EJ / J2j、2
∖	[√vt+ T	√β2Vt-1	+ T	√β2Vt-1 + T)/	2 M [(√vtj+ τ)2
=f(xt)	+ η(Vf(xt), Et	[	,	]∖+η	Vfx(xt)，Et	[ʒɪr--------------, 1)
∖	[√β2Vt-i	+	τ∖ /	∖	[√vt+ T	√β2vt-i + T_|/
、-------------{-------------}	、------------------V----------------------}
R1	R2
+
△2j	一
(√vtj + T )2
(14)
Bounding R2. We observe the following about R2:
d
R2 = Et X[Vf (xt)]j ×
j=1
△t,j	△，,
---------------, -----------
√vj + T	√β2vt-1,j + T
d
Et X[Vf(xt)]j × △t,j ×
j=1
d
Et X[Vf(xt)]j × △t,j ×
j=1
yzιβ2vt-1j - √vj
(√vtj + T )(√β2vt-1,j + T)_
________________-(1 - QNj____________________
(√vtj + T )(√β2vt-1,j + T )(√β2vt-1,j + √vj)
d
≤ (i-β2)Et X ∣vf(xt)j∣
j=1
X dj | X
≤ √ι -β2Et X Vf(xt)j∣ X -△	---]
j=1	j	[√vtj + T )(√βv-j + T)]
，——――二 G
≤ √1 - β2 Et E - X
T
j=1
△2j
√vtjj+ T
19
Published as a conference paper at ICLR 2021
Bounding R1 . The term R1 can be bounded as follows:
RI = (f( (xt), Et	IQ Z - ∖
β2vt-1 + τ
=/ ^f)	, Et [∆t - ηιKVf(Xt) + ηιKVf (xt)] ∖
β2vt-1 + τ
=-ηιK XX PV(X)j + * AVfxt)	，Et [∆t + ηιKVf(χt)] +.	(15)
j=1	β2vt-1,j + τ	β2vt-1 + τ
X{}
R3
Bounding R3 . The term R3 can be bounded in exactly the same way as term T3 in proof of
Theorem 1:
R<ηι K X [Vf (Xt)]2 JL2 E
R3 ≤ F ⅛ pβ2Vt-ι,j+T + 2mτ Et
Substituting the above inequality in Equation (15), We get
η η ηιK X [Vf(Xt)j	ηιL2 E
R1 ≤- 丁 ⅛ √βvκ+T + 2mτ Et
m K-1
X X	kxit,k-xtk2
i=1 k=0
m K-1
X X	kxit,k - xtk2
i=1 k=0
Here We used the fact that √vt-1j ≤ ηιKG and conditions in Theorem 2. Using Lemma 3, We
obtain the following bound on R1 :
R < ηιK X	[Vf(χt)]2	+
R1 ≤-丁 ⅛ Pβ2Vt-1,j+ T +
5ηl3K2L2
2τ
d
EtX(σl2,j+6Kσg2,j)
j=1
(16)
Putting pieces together. Substituting bounds R1 and R2 in Equation (14), we have
Et[f (xt+1)] ≤ f(xt) - ηηlK XX Zf⅞ +
4 j=1 β2 vt-1,j + T
5ηηl3 K2L2
2τ
d
E X(σl2,j + 6Kσg2,j)
+ (η√1-β2G )XX Et
△2j
vt,j + T 2)
Summing over t = 0 to T - 1 and using telescoping sum, we have
K T-1 d
E[f(xτ)] ≤ f(χ0)- ηη4r∑ EE
t=0 j=1
[Vf (Xt)j
5ηη∣3κ 2L2T
2τ
d
EX(σl2,j+6Kσg2,j)
j=1
T-1 d
XXE
△2J
vt,j + T 2)
(17)
+
To bound this term further, we need the following result.
Lemma 5.
T-1 d
Xt=0Xj=1E
The following upper bound holds for Algorithm 2 (FEDADAM):
△t2,j
(Vt,j+ T 2)
4ηl2KT
mτ2
d
X σl2,j+
j=1
20ηl4K3L2T
τ2
d
EX(σl2,j+6Kσg2,j)+
j=1
40ηl4K4L2
τ2
T-1
X E kVf(xt)k2
t=0
≤
Proof.
T-1 d
EXt=0Xj=1
(i-β2) Pt=O β2-l∆2,j + T2
T-1 d ∆2
≤ EXX ∆j
t=0 j=1
20
Published as a conference paper at ICLR 2021
The rest of the proof follows along the lines of proof of Lemma 4. Using the same argument, we get
XX E " J⅛# ≤ NKT XX σ2,j + 20n4K3L2TE XX(σ2j + 6Kσg,j
j=1	vt,j τ	mτ	j=1	τ	j=1
+ 40看"2 X1E [kVf(xt)k2i,
τ t=0
which is the desired result.	□
Substituting the bound obtained from above lemma in Equation (17) and using a similar argument for
bounding
(一)XX1X e> ]
we obtain
Et[f(xT)] ≤ f(x0) -
nnιK TX1XX [V"-/
8 t=0 j=1 √β2vt-1,j + T
+5nn3K2L2TE X "F
+ (n√1 - β2G + n2L) X
4n2κτ X σ2 +
ImT2	l,j
j=1
20η∣4K 4L2T
τ 2
d
E X(σl2,j +6Kσg2,j)
j=1
The above inequality is obtained due to the fact that:
(L2G + ηL) 40η4Τ*
≤ 哈(√β⅛G + 1)
The above condition follows from the condition on ηl in Theorem 2. We also observe the following:
^-J^^ [Vf (xt)]j	[Vf (xt)]j	T	2
≥ ≥	≥	≥	mm kVf(Xt)Il2.
t=0 j=1 √β2vt-i,j + τ = j=1 √β2ηιKG + T	√β2ηιKG + T 0≤t≤T
Substituting this bound in the above equation yields the desired result.	□
A.4 Auxiliary Lemmatta
Lemma 6. For random variables z1 , . . . , zr, we have
E Iz1 + ... + zrI2 ≤ rE Iz1I2 + ... + IzrI2 .
Lemma 7. For independent, mean 0 random variables z1 , . . . , zr, we have
E Iz1 + ... + zrI2 = E Iz1 I2 + ... + IzrI2 .
B Federated Algorithms: Implementations and Practical
Considerations
B.1	FedAvg and FedOpt
In Algorithm 3, we give a simplified version of the FedAvg algorithm by McMahan et al. (2017), that
applies to the setup given in Section 2. We write SGDK(xt, ηl, fi) to denote K steps of SGD using
gradients Vfi(x, Z) for Z 〜Di with (local) learning rate ηι, starting from -t. As noted in Section 2,
Algorithm 3 is the special case of Algorithm 1 where ClientOpt is Sgd, and ServerOpt is Sgd
with learning rate 1.
While Algorithms 1, 2, and 3 are useful for understanding relations between federated optimization
methods, we are also interested in practical versions of these algorithms. In particular, Algorithms
1, 2, and 3 are stated in terms of a kind of ‘gradient oracle’, where we compute unbiased estimates
21
Published as a conference paper at ICLR 2021
Algorithm 3 Simplified FEDAVG
Input: xo
for t = 0,…，T - 1 do
Sample a subset S of clients
xit = xt
for each client i ∈ S in parallel do
xti = SGDK (xt, ηl, fi) for i ∈ S (in parallel)
xt+1 =吉 Pi∈S Xt
of the client’s gradient. In practical scenarios, we often only have access to finite data samples, the
number of which may vary between clients.
Instead, we assume that in (1), each client distribution Di is the uniform distribution over some
finite set Di of size ni . The ni may vary significantly between clients, requiring extra care when
implementing federated optimization methods. We assume the set Di is partitioned into a collection
of batches Bi, each of size B. For b ∈ Bi, we let fi(x; b) denote the average loss on this batch at x
with corresponding gradient Vfi(x; b). Thus, if b is sampled uniformly at random from Bi, Vfi(x; b)
is an unbiased estimate of VFi(x).
When training, instead of uniformly using K gradient steps, as in Algorithm 1, we will instead
perform E epochs of training over each client’s dataset. Additionally, we will take a weighted average
of the client updates, where we weight according to the number of examples ni in each client’s
dataset. This leads to a batched data version of FedOpt in Algorithm 4, and a batched data version
of FedAdagrad, FedAdam, and FedYogi given in Algorithm 5.
Algorithm 4 FEDOPT - Batched data
Input: x0, CLIENTOPT, SERVEROPT
for t = 0,…，T 一 1 do
Sample a subset S of clients
xit = xt
for each client i ∈ S in parallel do
for e = 1, . . . , E do
for b ∈ Bi do
git = Vfi(xit;b)
xit = CLIENTOPT(xit, git, ηl, t)
∆it = xit - xt
n = Pi∈S ni, ∆t = Pi∈S niδ
xt+1 = SERVEROPT(xt, -∆t, η, t)
In Section 5, we use Algorithm 4 when implementing FedAvg and FedAvgM. In particular,
FedAvg and FedAvgM correspond to Algorithm 4 where ClientOpt and ServerOpt are Sgd.
FedAvg uses vanilla Sgd on the server, while FedAvgM uses Sgd with a momentum parameter
of 0.9. In both methods, we tune both client learning rate ηl and server learning rate η. This means
that the version of FedAvg used in all experiments is strictly more general than that in (McMahan
et al., 2017), which corresponds to FedOpt where ClientOpt and ServerOpt are Sgd, and
S erverOpt has a learning rate of 1.
We use Algorithm 5 for all implementations FedAdagrad, FedAdam, and FedYo gi in Section 5.
For FEDADAGRAD, we set β1 = β2 = 0 (as typical versions of ADAGRAD do not use momentum).
For FEDADAM and FEDYOGI we set β1 = 0.9, β2 = 0.99. While these parameters are generally
good choices (Zaheer et al., 2018), we emphasize that better results may be obtainable by tuning
these parameters.
B.2	SCAFFOLD
As discussed in Section 5, we compare all five optimizers above to SCAFFOLD (Karimireddy et al.,
2019) on our various tasks. There are a few important notes about the validity of this comparison.
22
Published as a conference paper at ICLR 2021
Algorithm 5IEDADAGRAD , ]edYOGI , and IEDADAM - Batched data
Input: x0,v-1 ≥ T2, optional β1,β2 ∈ [0,1) for FedYogi and FedAdam
for t = 0,…，T 一 1 do
Sample a subset S of clients
xit = xt
for each client i ∈ S in parallel do
for e = 1, . . . , E do
for b ∈ Bi do
Xt = Xt- ηι Vfi(χt; b)
∆it = xit 一 xt
n=Pi∈s ni, ∆t = Pi∈s nniδ:
δ⅛ = eCt-I + (I 一 肉池/；
vt = vt-1 + ∆2 (Fedadagrad)
Vt = vt-1 -(1 一 e2)∆2 Sign(Vt-I- ∆2) (FEDYOGI)
Vt = β2vt-ι + (1 — β2)∆2 (FedAdam)
xt+1 = Xt + η √δ+t
1.	In cross-device settings, this is not a fair comparison. In particular, SCAFFOLD does not
work in settings where clients cannot maintain state across rounds, as may be the case for
federated learning systems on edge devices, such as cell phones.
2.	SCAFFOLD has two variants described by Karimireddy et al. (2019). In Option I, the
control variate of a client is updated using a full gradient computation. This effectively
requires performing an extra pass over each client’s dataset, as compared to Algorithm 1. In
order to normalize the amount of client work, we instead use Option II, in which the clients’
control variates are updated using the difference between the server model and the client’s
learned model. This requires the same amount of client work as FedAvg and Algorithm 2.
For practical reasons, we implement a version of S CAFFOLD mirroring Algorithm 4, in which we
perform E epochs over the client’s dataset, and perform weighted averaging of client models. For
posterity, we give the full pseudo-code of the version of SCAFFOLD used in our experiments in
Algorithm 6. This is a simple adaptiation of Option II of the SCAFFOLD algorithm in (Karimireddy
et al., 2019) to the same setting as Algorithm 4. In particular, we let ni denote the number of examples
in client i’s local dataset.
Algorithm 6 SCAFFOLD, Option II - Batched data
Input: X0, c, ηι, η
for t = 0,…，T - 1 do
Sample a subset S of clients
Xit = Xt
for each client i ∈ S in parallel do
for e = 1, . . . , E do
for b ∈ Bi do
gt = vfi (xi；b)
Xit = Xit - ηl (git - ci + c)
c+ = Ci - c + (E∣Bi∣ηι)-1 (χi - Xi)
∆Xi = Xit - Xt, ∆ci = ci+ - ci
ci = ci+
n = pi∈s ni, δx = pi∈s n△◎, δc = pi∈s n△以
χt+ι = χt + η∆χ, c = c + |S| ∆c
In this algorithm, ci is the control variate of client i, and c is the running average of these control
variates. In practice, we must initialize the control variates ci in some way when sampling a client i
for the first time. In our implementation, we set ci = c the first time we sample a client i. This has
23
Published as a conference paper at ICLR 2021
the advantage of exactly recovering FedAvg when each client is sampled at most once. To initialize
c, we use the all zeros vector.
We compare this version of S CAFFOLD to FedAdagrad, FedAdam, FedYogi, FedAvgM,
and FedAvg on our tasks, tuning the learning rates in the same way (using the same grids as in
Appendix D.2). In particular, ηl, η are tuned to obtain the best training performance over the last 100
communication rounds. We use the same federated hyperparameters for SCAFFOLD as discussed in
Section 4. Namely, we set E = 1, and sample 10 clients per round for all tasks except Stack Overflow
NWP, where we sample 50. The results are given in Figure 1 in Section 5.
B.3	Lookahead, AdaAlter, and client adaptivity
The Lookahead optimizer (Zhang et al., 2019b) is primarily designed for non-FL settings. Looka-
head uses a generic optimizer in the inner loop and updates its parameters using a “outer” learning
rate. Thus, unlike FedOpt, Lookahead uses a single generic optimizer and is thus conceptually dif-
ferent. In fact, Lookahead can be seen as a special case of FedOpt in non-FL settings which uses a
generic optimizer ClientOpt as a client optimizer, and Sgd as the server optimizer. While there are
multiple ways Lookahead could be generalized to a federated setting, one straightforward version
would simply use an adaptive method as the ClientOpt. On the other hand, AdaAlter (Xie et al.,
2019) is designed specifically for distributed settings. In AdaAlter, clients use a local optimizer
similar to Adagrad (McMahan & Streeter, 2010a; Duchi et al., 2011) to perform multiple epochs
of training on their local datasets. Both Lookahead and AdaAlter use client adaptivity, which is
fundamentally different from the adaptive server optimizers proposed in Algorithm 2.
To illustrate the differences, consider the client-to-server communication in AdaAlter. This requires
communicating both the model weights and the client accumulators (used to perform the adaptive
optimization, analogous to vt in Algorithm 2). In the case of ADAALTER, the client accumulator is
the same size as the model’s trainable weights. Thus, the client-to-server communication doubles for
this method, relative to FedAvg. In AdaAlter, the server averages the client accumulators and
broadcasts the average to the next set of clients, who use this to initialize their adaptive optimizers.
This means that the server-to-client communication also doubles relative to FedAvg. The same
would occur for any adaptive client optimizer in the distributed version of Lookahead described
above. For similar reasons, we see that client adaptive methods also increase the amount of memory
needed on the client (as they must store the current accumulator). By contrast, our adaptive server
methods (Algorithm 2) do not require extra communication or client memory relative to FedAvg.
Thus, we see that server-side adaptive optimization benefits from lower per-round communication
and client memory requirements, which are of paramount importance for FL applications (Bonawitz
et al., 2019).
C	Dataset & Models
Here we provide detailed description of the datasets and models used in the paper. We use federated
versions of vision datasets EMNIST (Cohen et al., 2017), CIFAR-10 (Krizhevsky & Hinton, 2009),
and CIFAR-100 (Krizhevsky & Hinton, 2009), and language modeling datasets Shakespeare (McMa-
han et al., 2017) and StackOverflow (Authors, 2019). Statistics for the training datasets can be found
in Table 2. We give descriptions of the datasets, models, and tasks below. Statistics on the number of
clients and examples in both the training and test splits of the datasets are given in Table 2.
Table 2: Dataset statistics.
Dataset	Train Clients	Train Examples	Test Clients	Test Examples
CIFAR- 1 0	500	50,000	100	10,000
CIFAR- 1 00	500	50,000	100	10,000
EMNIST-62	3,400	671,585	3,400	77,483
Shakespeare	715	16,068	715	2,356
StackOverflow	342,477	135,818,730	204,088	16,586,035
24
Published as a conference paper at ICLR 2021
C.1 CIFAR- 1 0/CIFAR- 1 00
We create a federated version of CIFAR-10 by randomly partitioning the training data among 500
clients, with each client receiving 100 examples. We use the same approach as Hsu et al. (2019),
where we apply latent Dirichlet allocation (LDA) over the labels of CIFAR-10 to create a federated
dataset. Each client has an associated multinomial distribution over labels from which its examples
are drawn. The multinomial is drawn from a symmetric Dirichlet distribution with parameter 0.1.
For CIFAR-100, we perform a similar partitioning of 100 examples to 500 clients, but using a more
sophisticated approach. We use a two step LDA process over the coarse and fine labels. We randomly
partition the data to reflect the "coarse" and "fine" label structure of CIFAR-100 by using the Pachinko
Allocation Method (PAM) (Li & McCallum, 2006). This creates more realistic client datasets, whose
label distributions better resemble practical heterogeneous client datasets. We have made publicly
available the specific federated version of CIFAR-100 we used for all experiments, though we avoid
giving a link in this work in order to avoid de-anonymization. For complete details on how the dataset
was created, see Appendix F.
We train a modified ResNet-18 on both datasets, where the batch normalization layers are replaced
by group normalization layers (Wu & He, 2018). We use two groups in each group normalization
layer. As shown by Hsieh et al. (2019), group normalization can lead to significant gains in accuracy
over batch normalization in federated settings.
Preprocessing CIFAR-10 and CIFAR-100 consist of images with 3 channels of 32 × 32 pixels
each. Each pixel is represented by an unsigned int8. As is standard with CIFAR datasets, we perform
preprocessing on both training and test images. For training images, we perform a random crop
to shape (24, 24, 3), followed by a random horizontal flip. For testing images, we centrally crop
the image to (24, 24, 3). For both training and testing images, we then normalize the pixel values
according to their mean and standard deviation. Namely, given an image x, We compute (X - μ)∕σ
where μ is the average of the pixel values in x, and σ is the standard deviation.
C.2 EMNIST
EMNIST consists of images of digits and upper and lower case English characters, with 62 total
classes. The federated version of EMNIST (Caldas et al., 2018) partitions the digits by their author.
The dataset has natural heterogeneity stemming from the writing style of each person. We perform two
distinct tasks on EMNIST, autoencoder training (EMNIST AE) and character recognition (EMNIST
CR). For EMNIST AE, we train the “MNIST” autoencoder (Zaheer et al., 2018). This is a densely
connected autoencoder with layers of size (28 × 28) - 1000 - 500 - 250 - 30 and a symmetric
decoder. A full description of the model is in Table 3. For EMNIST CR, we use a convolutional
network. The network has two convolutional layers (with 3 × 3 kernels), max pooling, and dropout,
followed by a 128 unit dense layer. A full description of the model is in Table 4.
Table 3: EMNIST autoencoder model architecture. We use a sigmoid activation at all dense layers.
Layer	Output Shape	# of Trainable Parameters
Input	784	0
Dense	1000	785000
Dense	500	500500
Dense	250	125250
Dense	30	7530
Dense	250	7750
Dense	500	125500
Dense	1000	501000
Dense	784	784784
25
Published as a conference paper at ICLR 2021
Table 4: EMNIST character recognition model architecture.
Layer	Output Shape	# of Trainable Parameters	Activation	Hyperparameters
Input	(28, 28, 1)	0		
Conv2d	(26, 26, 32)	320		kernel size = 3; strides=(1, 1)
Conv2d	(24, 24, 64)	18496	ReLU	kernel size = 3; strides=(1, 1)
MaxPool2d	(12, 12, 64)	0		pool size= (2, 2)
Dropout	(12, 12, 64)	0		p=0.25
Flatten	9216	0		
Dense	128	1179776		
Dropout	128	0		p= 0.5
Dense	62	7998	softmax	
C.3 Shakespeare
Shakespeare is a language modeling dataset built from the collective works of William Shakespeare.
In this dataset, each client corresponds to a speaking role with at least two lines. The dataset consists
of 715 clients. Each client’s lines are partitioned into training and test sets. Here, the task is to do
next character prediction. We use an RNN that first takes a series of characters as input and embeds
each of them into a learned 8-dimensional space. The embedded characters are then passed through
2 LSTM layers, each with 256 nodes, followed by a densely connected softmax output layer. We
split the lines of each speaking role into into sequences of 80 characters, padding if necessary. We
use a vocabulary size of 90; 86 for the characters contained in the Shakespeare dataset, and 4 extra
characters for padding, out-of-vocabulary, beginning of line and end of line tokens. We train our
model to take a sequence of 80 characters, and predict a sequence of 80 characters formed by shifting
the input sequence by one (so that its last character is the new character we are actually trying to
predict). Therefore, our output dimension is 80 × 90. A full description of the model is in Table 5.
Table 5: Shakespeare model architecture.
Layer	Output Shape	# of Trainable Parameters
Input	80	0
Embedding	(80, 8)	720
LSTM	(80, 256)	271360
LSTM	(80, 256)	525312
Dense	(80, 90)	23130
C.4 Stack Overflow
Stack Overflow is a language modeling dataset consisting of question and answers from the question
and answer site, Stack Overflow. The questions and answers also have associated metadata, including
tags. The dataset contains 342,477 unique users which we use as clients. We perform two tasks on this
dataset: tag prediction via logistic regression (Stack Overflow LR, SO LR for short), and next-word
prediction (Stack Overflow NWP, SO NWP for short). For both tasks, we restrict to the 10,000 most
frequently used words. For Stack Overflow LR, we restrict to the 500 most frequent tags and adopt a
one-versus-rest classification strategy, where each question/answer is represented as a bag-of-words
vector (normalized to have sum 1).
For Stack Overflow NWP, we restrict each client to the first 1000 sentences in their dataset (if
they contain this many, otherwise we use the full dataset). We also perform padding and truncation
to ensure that sentences have 20 words. We then represent the sentence as a sequence of indices
corresponding to the 10,000 frequently used words, as well as indices representing padding, out-of-
vocabulary words, beginning of sentence, and end of sentence. We perform next-word-prediction on
these sequences using an RNN that embeds each word in a sentence into a learned 96-dimensional
space. It then feeds the embedded words into a single LSTM layer of hidden dimension 670, followed
26
Published as a conference paper at ICLR 2021
by a densely connected softmax output layer. A full description of the model is in Table 6. The
metric used in the main body is the top-1 accuracy over the proper 10,000-word vocabulary; it does
not include padding, out-of-vocab, or beginning or end of sentence tokens when computing the
accuracy.klkjlkj
Table 6: Stack Overflow next word prediction model architecture.
Layer	Output Shape	# of Trainable Parameters
Input	20	0
Embedding	(20, 96)	960384
LSTM	(20, 670)	2055560
Dense	(20, 96)	64416
Dense	(20, 10004)	970388
D	Experiment Hyperparameters
D. 1 Hyperparameter tuning
Throughout our experiments, we compare the performance of different instantiations of Algorithm 1
that use different server optimizers. We use Sgd, Sgd with momentum (denoted Sgdm), Adagrad,
Adam, and Yogi. For the client optimizer, we use mini-batch Sgd throughout. For all tasks, we tune
the client learning rate ηl and server learning rate η by using a large grid search. Full descriptions of
the per-task server and client learning rate grids are given in Appendix D.2.
We use the version of FEDADAGRAD, FEDADAM, and FEDYOGI in Algorithm 5. We let β1 = 0
for FEDADAGRAD, and we let β1 = 0.9, β2 = 0.99 for FEDADAM, and FEDYOGI. For FEDAVG
and FedAvgM, we use Algorithm 4, where ClientOpt, ServerOpt are Sgd. For FedAvgM,
the server SGD optimizer uses a momentum parameter of 0.9. For FEDADAGRAD, FEDADAM, and
FEDYOGI, we tune the parameter τ in Algorithm 5.
When tuning parameters, we select the best hyperparameters (ηl , η, τ) based on the average training
loss over the last 100 communication rounds. Note that at each round, we only see a fraction of the
total users (10 for each task except Stack Overflow NWP, which uses 50). Thus, the training loss at a
given round is a noisy estimate of the population-level training loss, which is why we averave over a
window of communication rounds.
D.2 Hyperparameter grids
Below, we give the client learning rate (ηl in Algorithm 1) and server learning rate (η in Algorithm 1)
grids used for each task. These grids were chosen based on an initial evaluation over the grids
ηl ∈ {10-3,10-2.5,10-2,...,100.5}
η ∈ {10-3,10-2.5,10-2,...,101}
These grids were then refined for Stack Overflow LR and EMNIST AE in an attempt to ensure that
the best client/server learning rate combinations for each optimizer was contained in the interior of
the learning rate grids. We generally found that these two tasks required searching larger learning
rates than the other two tasks. The final grids were as follows:
CIFAR-10:
ηl ∈ {10-3,10-2.5,...,100.5}
η ∈ {10-3, 10-2.5,..., 101}
CIFAR-100:
ηl ∈ {10-3,10-2.5,...,100.5}
η ∈ {10-3, 10-2.5,..., 101}
27
Published as a conference paper at ICLR 2021
EMNIST AE:	ηl ∈ {10-1.5,10-1,...,102} η ∈ {10-2, 10-1.5,..., 101}
EMNIST CR:	ηl ∈ {10-3,10-2.5,...,100.5} η ∈ {10-3, 10-2.5,..., 101}
Shakespeare:	ηl ∈ {10-3,10-2.5,...,100.5} η ∈ {10-3, 10-2.5,..., 101}
StackOverflow LR:	ηl ∈ {10-1, 10-0.5,..., 103} η∈ {10-2, 10-1.5,..., 101.5}
StackOverflow NWP:	ηl ∈ {10-3,10-2.5,...,100.5} η ∈ {10-3, 10-2.5,..., 101}
For all tasks, we tune τ over the grid:
	τ ∈ {10-5,...,10-1}.
D.3 Per-task batch sizes
Given the large number of hyperparameters to tune, and to avoid conflating variables, we fix the batch
size at a per-task level. When comparing centralized training to federated training in Section 5, we
use the same batch size in both federated and centralized training. A full summary of the batch sizes
is given in Table 7.
	Table 7: Client batch sizes used for each task.
TASK	Batch size
CIFAR-10	20
CIFAR-100	20
EMNIST AE	20
EMNIST CR	20
Shakespeare	4
S tackOverflow LR	100
S tackOverflow NWP	16
D.4 Best performing hyperparameters
In this section, we present, for each optimizer, the best client and server learning rates and values
of τ found for the tasks discussed in Section 5. Specifically, these are the hyperparameters used in
Figure Figure 1 and table Table 1. The validation metrics in Table 1 are obtained using the learning
rates in Table 8 and the values of τ in Table 9. As discussed in Section 4, we choose η, ηl and τ to be
the parameters that minimizer the average training loss over the last 100 communication rounds.
28
Published as a conference paper at ICLR 2021
Table 8: The base-10 logarithm of the client (ηl) and server (η) learning rate combinations that achieve
the accuracies from Table 1. See Appendix D.2 for a full description of the grids.
FedAdagrad FedAdam FedYogi FedAvgM FedAvg
ηl	η	ηl	η	ηl	η ηl η	ηl	η
CIFAR- - 0	-%
CIFAR- - 00	--
EMNIST AE	%
EMNIST CR	-%
Shakespeare	0
S tackOverflow LR	2
S tackOverflow NWP	-½
o½ooooo
∙-½-ll-lo2-½
2 22
1 OO1 1 Oo
- --
%%%%o 2%
--- - -
2 o%% 2 ½ 2
- ---------
3 3 -3 02-
-- - -
2 o%% 2 ½ 2
- ---------
6 ㊀ I ∙ - 4
3 3 -3 02-
-- - -
----------- -
Table 9: The base-10 logarithm of the parameter τ (as defined in Algorithm 2) that achieve the
validation metrics in Table 1.
FedAdagrad		FedAdam	FedYogi
CIFAR--0	-2	-3	-3
CIFAR--00	-2	--	--
EMNIST AE	-3	-3	-3
EMNIST CR	-2	-4	-4
Shakespeare	--	-3	-3
StackOverflow LR	-2	-5	-5
StackOverflow NWP	-4	-5	-5
29
Published as a conference paper at ICLR 2021
Figure 4: Validation accuracy on EMNIST CR using constant learning rates η, ηl, and τ tuned to
achieve the best training performance on the last 100 communication rounds; see Appendix D for
hyperparameter grids.
Table 10: Test set performance for Stack Overflow tasks after training: Accuracy for NWP and
Recall@5 (×100) for LR. Performance within within 0.5% of the best result are shown in bold.
Fed...	Adagrad	Adam	Yogi	AvgM	Avg
Stack Overflow NWP 24.4	25.7	25.7	24.5	20.5
Stack Overflow LR	66.8	65.2	66.5	46.5	40.6
E Additional Experimental Results
E.1 RESULTS ON EMNIST CR
We plot the validation accuracy of FedAdagrad, FedAdam, FedYogi, FedAvgM, FedAvg,
and SCAFFOLD on EMNIST CR. As in Figure 1, we tune the learning rates ηl, η and adaptivity τ
by selecting the parameters obtaining the smallest training loss, averaged over the last 100 training
rounds. The results are given in Figure 4.
We see that all methods are roughly comparably throughout the duration of training. This reflects the
fact that the dataset is quite simple, and most clients have all classes in their local datasets, reducing
any heterogeneity among classes. Note that S CAFFOLD performs slightly worse than FedAvg
and all other methods here. As discussed in Section 5, this may be due to the presence of stale client
control variates, and the communication-limited regime of our experiments.
E.2 Stack Overflow test set performance
As discussed in Section 5, in order to compute a measure of performance for the Stack Overflow
tasks as training progresses, we use a subsampled version of the test dataset, due to its prohibitively
large number of clients and examples. In particular, at each round of training, we sample 10,000
random test samples, and use this as a measure of performance over time. However, once training is
completed, we also evaluate on the full test dataset. For the Stack Overflow experiments described in
Section 5, the final test accuracy is given in Table 10.
E.3 Learning rate robustness
In this section, we showcase what combinations of client learning rate ηl and server learning rate η
performed well for each optimizer and task. As in Figure 2, we plot, for each optimizer, task, and
pair (ηl, η), the validation set performance (averaged over the last 100 rounds). As in Section 5, we
fix τ = 10-3 throughout. The results, for the CIFAR-10, CIFAR-100, EMNIST AE, EMNIST CR,
30
Published as a conference paper at ICLR 2021
Shakespeare, Stack Overflow LR, and Stack Overflow NWP tasks are given in Figures 5, 6, 7, 8, 9,
10, and 11, respectively.
While the general trends depend on the optimizer and task, we see that in many cases, the adaptive
methods have rectangular regions that perform well. This implies a kind of robustness to fixing one
of η, ηl , and varying the other. On the other hand, FEDAVGM and FEDAVG often have triangular
regions that perform well, suggesting that η and ηl should be tuned simultaneously.
CIFAR10, FedAdagrad
1.0 10.1 10.1 10.0 10.0 10.0 10.1 10.1 10.0
3 0.5
≤ 0.0
ω
济0.5
,c1-1.0
S-1-5
⅛-2.0
≥
/5
-3.0
10.3 10.3 10.3 10.3 10.3 10.3 10.3 10.5
18.5
Λ 10.4 10.4 10.4 19.8 10.4
10.5
38.3
20.2
23.5
22.3
16.1
38.fi
6.2
16.5
6.2
f.S 66.9 67.4
72.K ħK.H
l.7 73.1 69.8
-3.0-2.5-2.0-1.5-1.0-0.5 0^0 0：5
Client Learning Rate (logɪo)
ACCUraCy
io,oioQgloio。 —
8765H 32 Io
fe-2.0f
CIFAR10, FedAdam
1.0 10.3 10.0 9.8 9.8 9.6 9.8 10.1 9.9
S 0.0
9.9 9.8 10.0 10.1 10.1 10.3 10.5
2-0.5
L0.1 18.1 10.2 17.5 10.2 10.0
38.7 31.8
16.9 11.1
34.0
-2.5
-3.0
f-1.0
⊂
rŋ .I 5
QJ ɪ'j
W 0.5 9∙9 ɪθ.θ 9.8 9.9 10.1 10.1 10.4 10.3
σι
17.6
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
;0QQQgQo O —
Γ8l-7⅝-654h3h2li0
CIFAR10, FedAvgM
-3.0-2.5-2.0-1.5-1.0-0.5 0：0 0：5
Client Learning Rate (logɪo)
ACCUraCy
ioggoogoo —
876i^5432110
CIFAR10, FedYogi
27.3
9.8 10.0 10.0 10.1 10.0 14.7
10.2 10.2
22.2 10.3
18.7
17.6 10.0 9.8 9.9 10.0 9.9 10.5
1.0 IO l 10.0 10.0 10.0 10.0 9.7 9.8 9.7
9.7
D 0.0
2-0-5
10.1
19.4
10.5
18.5
fe-2.0
21.3
-2.5
26.8
-3.0
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 0.5
1 7f1.7 75.2
3 75.7 78.0 77.C
L 69.7 75.7 77.C
Il-LO
S-1-5
Client Learning Rate (logɪo)
QFARlO, FedAvg
8.3 10.2 10.1 12.3
0.510.1
g O O^S	ιo.ι
黑5
,c1-1.0
S-1-5
ω -2 5-
S ∕Q
80
70
60
11.9	14.7	21.3	26.4	25.0	20.9	16.8	11.4
14.1	11.9	13.5	17.4	16.4	11.4	9.9	10.2
8.3	7.5	13.4	15.3	13.1	6.2	9.4	7.0
-3.0-2.5-2.0-1.5-1.0-0.5 0：0 0：5
Client Learning Rate (logɪo)
-3.0
20
10
0
ACCUraCy
ioggoogoo —
876i^5432110
Figure 5:	Validation accuracy (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the
CIFAR-10 task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
31
Published as a conference paper at ICLR 2021
CIFAR-100, FedAdagrad
1.0 10 1.0 1.0 1.0 1.0 1.0 1.0 1.0
W 0.5 2.9 1.0 1.0 1.0 1.0 1.0 1.0 0.9
σι
D 0.0 ɪə-7 15.8
16.3 2.8	9.6 24.3 4.0	1.7
1.0 1.0 1.0 1.0 1.0
(5-0-5
.c-1.0
S-1∙5
⅛j -2.0
-2.5 14.3
3.2
10.6
23.4
29.6
24.7
8.0
23.2
23.3
13.0
2.6
-3.0 7.0 11.6 15.6 21.3 20.1
12.2
5.2 1.0
-3.0-2.5-2.0-i.5-i.0-0.5 0：0 Q.5
Client Learning Rate (logɪo)
ACcUraCy
ioQgio!og I
6 5 4 3 2 1 0
CIFAR-100, FedAdam
1.0 i-o	1.0	1.0	1.0	1.0	1.0	1.0	1.0
W	0 5 ] 29.4	1.0	1.0	1.0	1.0	1.0	1.0	1.0
g, ■■
D	ɪɑ	10	1.0	1.0	1.0	1.0
⅞	4.3 1.0 1.0 1.0 1.0
C -1.0	22.9 8.7 4.9 1.0
⅛ -1.5	21.1 10.5
⅛ -2,θ] 29.4	10.4
ω ,2.5 17.4	15.7
-3.0 101	182	27.7	3.4
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 0：5
Client Learning Rate (logɪo)
ACCUraCy
Qogooo
6 5 4 3 2 1
3 0.5
S 0.0
ω
*0.5
Il-Lo
S-1-5
⅛-2.0
≥
ω -2 5 17.4
S NQ
CIFAR-100, FedYogi
1.0 1.0 1.0 1.0 1.0 1.0 1.0
-3.0 9∙3 17.8 27.4	28.6 1.8
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 Q.5
Client Learning Rate (logɪo)
r60
ACCUraCy
Ogooo
5 4 3 2 rH
CIFAR-IOOf FedAvgM
i o ι.o ι.o ι.o ι,o
W	1.0 1.0
D 0.025.9
-0.5	1.0
⊂1.l0Q 10.5 20.8	29.1 1.0
⅛ -1.5	3.7	9.7	16.9	24.8	26.6	24.5	20.6	2.3
⅛ -2.0	3.1	3.8	6.9	13.6	14.6	11.8	10.6	1.0
ω -2.5	1∙3	3.0	2.7	7.1	9.5	4.6	6.5	1.0
-3.0	0.9	1.1	1.4	3.2	5.6	3.4	2.2	1.0
-3.0-2.5-2.0-i.5-i.0-0.5 0：0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
Qogooo
6 5 4 3 2 rH
CIFAR-100, FedAvg
20.1 1.0 1.0 1.0
3 0.5
ɔ o.o
28.1
17.2
1.0
9.8
1.0
2 -0∙5 4.4 8.8
16.7
25.4 27.2 24.9 24.4
13.6 15.2 12.3 12.2
⊂ -1.0 3.8 4.4 6.6
1.7
ro -1.5 1-1 2.8 2.9 7.1 9.6 5.8 4.9 1.4
⅛ -2.0	0∙9	1-5	1.8	3.4	5.4	2.9	2.2	1.3
ω -2.5	11	1.0	1.1	2.3	3.5	2.9	1.2	1.0
-3.0 0.9 1.0 0.9 1.3 2.2 1.1 1.0 1.0
-3.0-2.5-2.0-i.5-i.0-0.5 0：0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
go。。。。
Γ65I-4I-3IF2I-I
Figure 6:	Validation accuracy (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the
CIFAR-100 task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
EMNlST AE, FedAdaqrad
0.5
⅛-1.5
A 20
3. o o
c1-0.5
E
S-ιθ
1 ι,o
1.2
-1.5-1.0-0.5 0.0 0：5 LO 1.5 2.0
Client Learning Rate (logɪo)
0.7 0.5 0.4
0.9 0.7 0.7
2-5 ω
2.0 ω
1-5 m
0.5 §
"o.os
⅛-1.5
I-20
EMNISTAEf FedAdam
D 0.5
3. o o
,∣-0.5
i-ιo
1 ι,o
0.3
-1.5-1.0-0.5 0^0 0：5 LO 1.5 2.0
Client Learning Rate (logɪo)
1.5 1.2
1.0 0.2 0.2
3•。手
2.0 ω
1.5 m
0.5 §
"o.os
⅛-1.5
I-20
EMNISTAEf FedYoqi
D 0.5
3. o o
c1-0.5
E
s-ιθ
1 ι,o
1.7
-1.5-1.0-0.5 0^0 0：5 LO 1.5 2.0
Client Learning Rate (logɪo)
1.5 1.4
Γ71.7 I
0.3 o.ι o.ι
1.0 0.2 0.2
Mean SqUared ErTOr×102
3 ι.o
6
❷0.5
ω
2 o.o
c-0.5
E
TLo
⅛-l.5
A 20
-1.5-1.0-0.5 0.0 0.5 1.0 1.5 2.0
Client Learning Rate (logɪo)
3
2
2
1
1
0
」0
Mean SqUared ErTOr×10s
L^lr I I L^lr I I L^lr I I LI
1 1.0
6
ɔ 0.5
ω
2 00
C-0.5
E
TLo
⅛-l.5
I-20
EMNIST AE, FedAvq
-1.5-1.0-0.5 0.0 0.5 1.0 1.5 2.0
Client Learning Rate (logɪo)
ɜθf
a
2耳
q
2.0 ω
d
1-5 m
1.0 3
0.5 §
"o.os
30 f
25 ω
1.0 2
1.0 2
Figure 7:	Validation MSE (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the
EMNIST AE task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
32
Published as a conference paper at ICLR 2021
EMNIST CR, FedAdagrad
1.0 5.0 5.0 5.0 5.1
0.8 0.9 4.9 2.6
5.1 5.5 5.4
5.3 5.1 5.6
2-0-5
/5
0.5 4.9 4.9 3.1 4.9
0.0 5.3 5.3 5.3 5.3 5.3
5.6 5.6 5.6 5.6
C-1.0
E
S-1-5
fe-2.0
5.6 5.6 5.6
5.6
5.6
30.2
10.0
14.5
5.7
-3.0 -2.5 -2.0-1.5-1.0 -0.5 0：0
5 84.3 84.9 83.8
.1 HS.9 H4.h H5.1
5.6 4.9
5.6
5.2
5.2
5.2
5.6
ACCUraCy
loio,oioQgio!oQI
9876543210
........................................................................................................................................................_
EMNIST CR, FedAdam
Client Learning Rate (logɪo)
1.0	4.4	4.5	4.8	3.3	4.4	3.6	5.1	0.4
3	0.5	4.9	4.7	4.6	4.8	0.7	2.0	4.7	5.1
CT
D	0 0	4 7	4.8	5.0	4.8	4.7	4.7	4.6	5.1
i-0.5	-
f-1.0
S-l∙5
fe-2.0
A 25
-3.0
Client Learning Rate (logɪo)
5.0
5.1
5.6
1.4
4.9
4.6
4.6
5.3
34.7
5.1
0
l-2.5-2.0-1.5-1.0-0.5 0.0
ACCUraCy
IoQgQQgQ Oo —
F4h3F2IE
EMNIST CR, FedYogi
1.0 4.2 4.7 4.5 4.2 4.5 4.0
4.4
4.8
4.8
4.5
4.7
5.0
^MNISTCR, FedAvgM
1.0
4.6
2.8
4.8
4.5
4.9
4.8
2-0.5
4.9
5.3
5.6
Il-LO
S-1-5
⅛-2.0
1 0.5
❷0.0
23.0
9.3 15.7
-2.5 5.2 5.1
84.3 85
5.1
4.6
4.2
5.0
5.1
5.1
5.1
5.3
-3.0 5.6 5.3 7.9 10.0 33.0 5.1 5.1
4.6
4.8
5.2
5.3
-3.0-2.5-2.0-1.5-1.0-0.5 0：0 0：5
ACCUraCy
QQggOOgOO —
98765 4 32 r-l10
Client Learning Rate (logɪo)
ACCUraCy
Qogg Oogool
98765432r-Io
0.5 4.9 4.7
5.3
-3.0 35.4
4.8 4.9 4.8
D 0.0 4.7 4.8 5.0 4.7 4.7 5.1
4.4 4.8 4.9 4.8
4.9
5.6
5.6
5.6
5.6
5.5
5.6
4.9
-3.0-2.5-2.0-1.5-1.0-0.5
2 -0.5 4.9 4.9
I-ι.otffi≡
E
T15.
fe-2.0
253
0：0
4.5
5.5
5.5
5.6
Client Learning Rate (logɪo)
EMNIST CR, FedAvg
Client Learning Rate (logɪo)
ACCUraCy
0
0
Figure 8:	Validation accuracy (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the
EMNIST CR task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
Shakespeare, FedAdagrad
1.0 8.4 10.2 8.9 3.8 3.2 11.0 9.3 10.0
1 0.5
S 0.0
4.7
18.7 14.5 7.9
3. -0-5
17.9 21.6 15.3 4.9
19.5
/5
20.6 9.7 6.1 17.5
5.5 7.3 11.7 4.9 7.2 9.3 9.9 11.6
c-1.0
E
s-ɪ-5
φ -2.0
6.0 29.8 3.3
8.4
0.0
0.0
-3.0 17∙6 ɪθə 18.9 21.8 21.8 22.9 20.8
-3.0-2.5-2.0-1.5-1.0-0.5 OQ 0：5
Client Learning Rate (logɪo)
ACCUraCy
QQgQoo
6 5 4 3 2 1
Shakespeare, FedAdam
1.0 0.0 0.2 9.2 8.7 12.0 0.3 0.0 0.0
1 0.5 OO
6
S 0.0 OO
2 -0.5 16 9
8.0 11.2 5.0 8.3 0.0 0.0 0.0
21.8 24.8 24.
0.0
-2.5
-3.0
,6 38.6
.2 54.6
9.7 10.2 6.6 6.6 11.0 0.0 0.0
7.3 4.6 8.2
c-1.0
E
s-ɪ-5
⅛-2.0
18.2
0.0
0.0
-3.0-2.5-2.0-1.5-l.0-0.5 0.0 0：5
Client Learning Rate (logɪo)
ACCUraCy
Qogooo
6 53 2 1
Shakespeare, FedYogi
1.0 0.0 0.0 6.2 7.7 5.0
1 0.5 9∙5
6
S 0.0 OO
0.0
o.o
6.9
8.8
2.3
8.1
6.4
4.3
11.8
0.0
2 -0-5
6.9
0.5
9.2
0.0
8.9
0.0
15.9
0.0
-2.5
-3.0
c-1.0
E
s-ɪ-5
⅛-2.0
4.3 0.0 0.0
0.0 3.6
28.8
26.g
π.o
o.o
o.o
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
Qogooo
6 5 4 3 2 1
Shakespearef FedAvgM
1.0	7.8 7.5 7.7 0.0 0.1 0.1
ShakeSPaa re, FedAvg
9.5 11.6 o.o o.o
0
3 0.5
CT
❷0.0
ω
2-0-5
f-1.0
E
s-ɪ-5
⅛-2.0
己
ω -2 5
S ∕Q
-3.0
29.0
18.2
27.8
14.1 18.9 27.6
0.7 12.8 19.6
28.8
0.0 1.5 12.4
19.9
24.8 10.9 9.5
.3 53.6
.5 56.7
.6 57.3
Hl
Kl
28.4
37.2
52.3
52.5
5.4
0.0 1.2 1.6 3.4 20.1 27.8	18.1
-3.0-2.5-2.0-1.5-1.0-0.5 0.0 0：5
Client Learning Rate (logɪo)
ACCUraCy
Ogooo
5 4 3 2 1
3 0.5
CT
S 0.0
ω
济0.5
,c1-1.0
S-1-5
⅛-2.0
ω -2 5-
S ∕Q
-3.0
29.0
18.1 29.7
12,8 21.2 29.2
1.7 11.7 18.9 29.1
0.0 2.7 12.1 18.9
0.0 0.0 2.1 15.1
4.8 0.0 0.0 0.0
4.9 0.0 0.0 0.0
-3.0-2.5-2.0-1.5
13.9
29.0
20.0 28.7
8.9 18.4 25.1 5.6
0.0 7.3 18.4 19.5
-i.0-0.5 0：0 Q.5
Client Learning Rate (logɪo)
ACCUraCy
Ooo
4 3 2
10




5
0
Figure 9:	Validation accuracy (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the
Shakespeare task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
33
Published as a conference paper at ICLR 2021
ReCa=@5×10s
,oioQQlo!oo
7 6 5-4-3-21
Stack Overflow LR, FedAdam
1.5
34.5
33.8
29.6
N o.o
27.0
-2.0
15.6 17.：
S' ι.o
3 0.5
E -0.5 22.5
≥ -1.5 19 2 21.l
1.0 21.0 23.6
60
34.6
28.6
30 ×
28.7
34.7
7.0
20
.0 23.2 26.4
30.5 33.9
1.2
10
3.8
uO
3：0
22 4 40≡
a 61 8 61 8 fiθ 7
40 f
50S
-i.0-0.5 0^0 0：5 Io 1.5 2.0 2.5
Client Learning Rate (logɪo)
.2 19.2 21.1 22.7 24.1 25.2 32.1
Client Learning Rate (logɪo)
Stack Overflow LR, FedAvgM
-i.0-0.5 0.0 0.5 1.0 i.5 2.0 2.5 3：0
70
Stack Overflow LR. FedYoai
1.5
N o.o
E -0.5
S' ι.o
3 0.5
2-1.0
φ
≥-l-5
(υ
ω-2.0
70
60
34.q
jι.a
27.4
22.9
28.8
30 ×
21.：
.1 23.6
28.6
34.4
4.4
18.9 20.7 23.0 25.9
29.6 32.9 34.8
1.7
10
5.2
uO
3：0
50R
40 f
200
-i.0-0.5 0^0 0：5 Io i.5 2.0 2.5
Client Learning Rate (logɪo)
15.6 16.8 18.9 20.7 22.2 23.3 25.1 34.2
Client Learning Rate (logɪo)
Stack Overflow LR, FedAvg
1.5 18.3 18.1 15.0 14.1 11.7 10.6 7.6 10.8 9.3
g1 1.0 183 18.3 18.3 15.4 12.5 10.8 12.8 10.4 13.4
D
g 0.5 17∙2 18∙3 18.3 18.6 20.9 21.1 23.6 23.3 23.5
(D
£ 0.0 15∙4 17∙2 18.3 18.4 19.3 24.5 30.0 30.7 16.4
C
∈ -0.5 15∙3 154 17.2 18.1 18.3 19.8 23.6 22.3 5.5
(D
ɑi -1.0 1≡-2	15.3	15.4	17.0	16.7	17.2	19.1	15.5	1.3
g-1.5-15∙3	15.2	15.3	15.4	15.4	15.4	15.0	11.7	0.0
S -2.0-15.3	15.2	15.2	15.4	15.4	15.4	14.7	9.3	0.2
-i.0-0.5	0^0	Q.5	lb	i.5	2.Q	2.5	3.0
Client Learning Rate (logɪo)
70
60
50S
401
30 7
20≡
10
Figure 10:	Validation recall@5 (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the Stack
Overflow LR task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
Stack Overflow NWP,
1.0	2.6	1.6	0.8	1.7	3.1
W 0.5	3.6	3.2	3.9	5.1	9.9
CT
S 0.0 6.0 9.1 10.0 10.4 12.1
ω
⅛ ,0.5 11.6 13.6
C	11.4 □国
⅛ -l.5J 13.9
⅛ -2.0 ɪɪ-4 13-3
-2.5 5.8 7.8 10.7 11.6 13.8
FedAdagrad
Stack Overflow NWP, FedAdam
1.0 2.1 2.1 1.2 0.1 0.3 0.0 0.0 0.0
0.3
o.o
o.ι
0.3
0.2
ACCUraCy
0 5 0
2 11
W 0.5	2.2	1.6	1.2	0.6	0.5	0.0	0.0	0.0
σι
g 0.0	1.6	1.7	1.1	1.7	2.1	0.6	0.0	0.0
0.0
5.1 1.4 0.3 0.7
-3.0-2.5-2.0-1.5-1.0-0.5 0：0 0：5
Client Learning Rate (logɪo)
f-1.0 3∙3
⊂
rŋ .I 5
QJ ɪ'j
13.2 15.0
6.2
⅛-2.0
-2.5
ra -0.5 0.6 1.7 5.6 4.0 5.8 3.2
0.0
0.0
0.0
0.0
0.0
-3.0-2.5-2.0-1.5-1.0-0.5 0：0
-3.0 ɪɪə 14.6
Client Learning Rate (logɪo)
0.0
0.0
0.0
0.0
0.0
0.0
Q.5
ACcUraCy
Q 5 O 5 O I
Γ3⅝-2⅝-2Hl-l 5iQ
Stack Overflow NWP, FedYogi
1.0	2.3	1.9	1.3	0.3	0.4	0.0	0.0	0.0
W 0.5	1.9	0.9	0.8	0.4	1.2	1.0	0.0	0.0
σι
g 0.0	1.4	1.4	0.7	0.6	2.2	0.9	0.0	0.0
ω
2-0-5
f-1.0
S-1.5
⅛j -2.0
A 25
-3.0
Client Learning Rate (logɪo)
0.0
o.o
0.0
0.2
-2.5-2.0-1.5-1.0-0.5 0；0
0.0 0.0
0.0 0.0
o.o
o.o
o.o
o.o
Stack Overflow NWP, FedAvgM
1.0 15.0 1.6 0.6 0.0 2.3
3 0.5 103
S 0.0 7.0
Si
ra -0.5 5.6
Il-L0 0.5
S -15。。
⅛ -2.0 o o
)-2.5 o o
-3.0 oo
0.5	5.5	7.2	10.2	14.6
0.0	0.9	5.5	7.0	10.1
0.0	0.0	1.2	5.4	6.9
0.0	0.0	0.0	0.6	5.0
0.7
0.7
0.4
0.2
0.1
2.4
0.0
1.1
1.3
1.4
0.0
0.0
1.6
0.0
2.2
1.4
0.0
0.0
ACCUraCy
0 5 0 5 0
3 2 2 1 r-I
1.0 5.8
3 0.5
Stack Overflow NWP, FedAvg
8.9
5.7
5.2
D 0.0 10
2 -0.5 c o
,⊂-1.0 c o
TL5。。
⅛ -2.0 o o
,-2.5 o o
-3.0 0.0
5.6
1.2
0.0
0.0
0.0
0.0
0.0
0.9
0.0
0.0
0.0
0.0
1.6
0.0
0.0
0.0
-3.0-2.5-2.0-i.5-i.0-0.5 0：0 Q.5
Client Learning Rate (logɪo)
12.4
11.1
5.5
5.5 7.1
0.3 1.2
1.0
0.0
0.5
2.2
1.0
0.5
10.3
7.0
5.5
0.8
0.0
0.0
5.2
0.0
0.0
1.2
0.0
..9
0
0.0
0.2
-3.0-2.5-2.0-i.5-i.0-0.5 0
Client Learning Rate (logɪo)
Q.5
ACCUraCy
ŋ 5 O 5 O . I
3 2 2 1 1 5 0
ACCUraCy
ŋ 5 O 5 O
3 2 2 Il
Q 5
3 2
O
0
5
Figure 11:	Validation accuracy (averaged over the last 100 rounds) of FedAdagrad, FedAdam,
FedYogi, FedAvgM, and FedAvg for various client/server learning rates combination on the Stack
Overflow NWP task. For FEDADAGRAD, FEDADAM, and FEDYOGI, we set τ = 10-3.
34
Published as a conference paper at ICLR 2021
E.4 On the relation between client and server learning rates
In order to better understand the results in Appendix E.3, we plot the relation between optimal choices
of client and server learning rates. For each optimizer, task, and client learning rate ηl, we find the
best corresponding server learning rate η among the grids listed in Appendix D.2. Throughout, we
fix τ = 10-3 for the adaptive methods. We omit any points for which the final validation loss is
within 10% of the worst-recorded validation loss over all hyperparameters. Essentially, we omit client
learning rates that did not lead to any training of the model. The results are given in Figure 12.
10 12
ɪ0100-0-
1 1
36umea*∣」3AJ3S
16^3......16^2......16^1......IO0
Client Learning Rate
10 12
10105 5
1 1
36U-Ee2」3AJ3S
3sα6umea*∣」3AJ3S
EMNIST CR
10 12
ɪ0100-0-
1 1
36u-UJea*l
10-2	1O^1
Client Learning Rate
ld
10 12
10105 5
1 1
36U-Ee2」3AJ3S
Stack Overflow LR
1 O
O O
1 1
36U-Ee2」3AJ3S
IO0 IO1 IO2
Client Learning Rate
1
10
3sα6umea*∣」3AJ3S
Stack Overflow NWP
10-2 ιo-1
Client Learning Rate
Figure 12:	The best server learning rate in our hyperparameter tuning grids for each client learning rate,
optimizers, and task. We select the server learning rates based on the average validation performance
over the last 100 communication rounds. For FedAdagrad, FedAdam, and FedYogi, we fix
τ = 10-3 . We omit all client learning rates for which all server learning rates did not change the
initial validation loss by more than 10%.
In virtually all tasks, we see a clear inverse relationship between client learning rate ηl and server
learning rate η for FEDAVG and FEDAVGM. As discussed in Section 5, this supports the observation
that for the non-adaptive methods, ηl and η must in some sense be tuned simultaneously. On the other
hand, for adaptive optimizers on most tasks we see much more stability in the best server learning
rate η as the client learning rate ηl varies. This supports our observation in Section 5 that for adaptive
methods, tuning the client learning rate is more important.
Notably, we see a clear exception to this on the Stack Overflow LR task, where there is a definitive
inverse relationship between learning rates among all optimizers. The EMNIST AE task also displays
somewhat different behavior. While there are still noticeable inverse relationships between learning
rates for FedAvg and FedAvgM, the range of good client learning rates is relatively small. We
emphasize that this task is fundamentally different than the remaining tasks. As noted by Zaheer et al.
(2018), the primary obstacle in training bottleneck autoencoders is escaping saddle points, not in
converging to critical points. Thus, we expect there to be qualitative differences between EMNIST
AE and other tasks, even EMNIST CR (which uses the same dataset).
35
Published as a conference paper at ICLR 2021
E.5 Robustness of the adaptivity parameter
As discussed in Section 5, we plot, for each adaptive optimizer and task, the validation accuracy
as a function of the adaptivity parameter τ . In particular, for each value of τ (which we vary
over {10-5, . . . , 10-1}, see Appendix D), we plot the best possible last-100-rounds validation set
performance. Specifically, we plot the average validation performance over the last 100 rounds using
the best a posteriori values of client and server learning rates. The results are given in Figure 13.
0 5 0 5 0
8 7 7 6 6
>UE≡U<
ShakeSPeare
Stack Overflow LR
EMNIST CR
I- -iæ
0 5 0 5 0
9 8 8 7 7
0.0.0.0.0.
>υε3υυ<
io-4 io-3 id-2 id-1
AdaPtiVity ⑴
0.60
0.58
^0.56
n
y 0.54
<
0.52
l51015
6 6 5
ge=3
10~4 IOf IO-2 10-1
Adaptivity (τ)
FedAdagrad
-B- FedAdam
* FedYogi
0-5 IO-4 10-3 10-2 IO-1
Ad 叩 tiVity (τ)
Stack Overflow NWP
5 0 5
2 2 1
X32∙ln8<
10~4 IO4 10-2 io-ɪ
Adaptivity (τ)
Figure 13:	Validation performance of FEDADAGRAD, FEDADAM, and FEDYOGI for varying τ on
various tasks. The learning rates η and ηl are tuned for each τ to achieve the best training performance
on the last 100 communication rounds.
E.6 Improving performance with learning rate decay
Despite the success of adaptive methods, it is natural to ask if there is still more to be gained. To test
this, we trained the EMNIST CR model in a centralized fashion on a shuffled version of the dataset.
We trained for 100 epochs and used tuned learning rates for each (centralized) optimizer, achieving
an accuracy of 88% (see Table 11, Centralized row), significantly above the best EMNIST CR
results from Table 1. The theoretical results in Section 3 point to a partial explanation, as they only
hold when the client learning rate is small or is decayed over time.
To validate this, we ran the same hyperparameter grids on the federated EMNIST CR task, but using
a client learning rate schedule. We use a “staircase” exponential decay schedule (ExpDecay) where
the client learning rate ηl is decreased by a factor of 0.1 every 500 rounds. This is analogous in some
sense to standard staircase learning rate schedules in centralized optimization (Goyal et al., 2017).
Table 11 gives the results. ExpDecay improves the accuracy of all optimizers, and allows most to
get close to the best centralized accuracy. While we do not close the gap with centralized optimization
entirely, we suspect that further tuning of the amount and frequency of decay may lead to even better
accuracies. However, this may also require performing significantly more communication rounds, as
the theoretical results in Section 3 are primarily asymptotic. In communication-limited settings, the
added benefit of learning rate decay seems to be modest.
36
Published as a conference paper at ICLR 2021
Table 11: (Top) Test accuracy (%) of a model trained centrally with various optimizers. (Bottom)
Average test accuracy (%) over the last 100 rounds of various federated optimizers on the EMNIST
CR task, using constant learning rates or the EXPDECAY schedule forηl. Accuracies (for the federated
tasks) within 0.5% of the best result are shown in bold.
Adagrad		Adam	Yogi	Sgdm	Sgd
Centralized	88.0	87.9	88.0	87.7	87.7
Fed...	Adagrad		ADAM	Yogi	AvgM	Avg
CONSTANT ηl	85.1	85.6	85.5	85.2	84.9
ExpDecay	85.3	86.2	86.2	85.8	85.2
F Creating a Federated CIFAR- 1 00
Overview We use the Pachinko Allocation Method (PAM) (Li & McCallum, 2006) to create a
federated CIFAR-100. PAM is a topic modeling method in which the correlations between individual
words in a vocabulary are represented by a rooted directed acyclic graph (DAG) whose leaves are the
vocabulary words. The interior nodes are topics with Dirichlet distributions over their child nodes.
To generate a document, we sample multinomial distributions from each interior node’s Dirichlet
distribution. To sample a word from the document, we begin at the root, and draw a child node its
multinomial distribution, and continue doing this until we reach a leaf node.
To partition CIFAR-100 across clients, we use the label structure of CIFAR-100. Each image in
the dataset has a fine label (often referred to as its label) which is a member of a coarse label. For
example, the fine label “seal” is a member of the coarse label “aquatic mammals”. There are 20
coarse labels in CIFAR-100, each with 5 fine labels. We represent this structure as a DAG G, with a
root whose children are the coarse labels. Each coarse label is an interior node whose child nodes are
its fine labels. The root node has a symmetric Dirichlet distribution with parameter α over the coarse
labels, and each coarse label has a symmetric Dirichlet distribution with parameter β .
We associate each client to a document. That is, we draw a multinomial distribution from the Dirichlet
prior at the root (Dir(α)) and a multinomial distribution from the Dirichlet prior at each coarse label
(Dir(β)). To create the client dataset, we draw leaf nodes from this DAG using Pachinko allocation,
randomly sample an example with the given fine label, and assign it to the client’s dataset. We do this
100 times for each of 500 distinct training clients.
While more complex than LDA, this approach creates more realistic heterogeneity among client
datasets by creating correlations between label frequencies for fine labels within the same coarse
label set. Intuitively, if a client’s dataset has many images of dolphins, they are likely to also have
pictures of whales. By using a small α at the root, client datasets become more likely to focus on a
few coarse labels. By using a larger β for the coarse-to-fine label distributions, clients are more likely
to have multiple fine labels from the same coarse label.
One important note: Once we sample a fine label, we randomly select an element with that label
without replacement. This ensures no two clients have overlapping examples. In more detail, suppose
we have sample a fine label y with coarse label c for client m, and there is only one remaining such
example (x, c, y). We assign (x, c, y) to client m’s dataset, and remove the leaf node y from the DAG
G. We also remove y from the multinomial distribution θc that client m has associated to coarse
label c, which we refer to as renormalization with respect to y (Algorithm 8). If i has no remaining
children after pruning node j , we also remove node i from G and re-normalize the root multinomial
θr with respect to c. For all subsequent clients, we draw multinomials from this pruned G according
to symmetric Dirichlet distributions with the same parameters as before, but with one fewer category.
Notation and method Let C denote the set of coarse labels and Y the set of fine labels, and let S
denote the CIFAR-100 dataset. This consists of examples (x, c, y) where x is an image vector, c ∈ C
is a coarse label set, and y ∈ Y is a fine label with y ∈ c. For c ∈ C , y ∈ Y, we let Sc and Sy denote
the set of examples in S with coarse label c and fine label y. For v ∈ G we let |G[v]| denote the set
of children of v in G. For γ ∈ R, let Dir(γ, k) denote the symmetric Dirichlet distribution with k
categories.
37
Published as a conference paper at ICLR 2021
Algorithm 7 Creating a federated CIFAR-100
Input: N,M ∈ Z>o, α,β ∈ R≥o
for m = 1,…，M do
Sample θr 〜Dir(α, ∣G[r]∣)
for c ∈ C ∩ G[r] do
Sample θc 〜Dir(β, ∣G[c]∣)
Dm = Q
for n = 1,…N do
Sample C 〜Multinomial(θr)
Sample y 〜Multinomial(θc)
Select (x, c, y) ∈ S uniformly at random
Dm = Dm ∪ {(x, c, y)}
S = S\{(x, c, y)}
if Sy = Q then
G = G\{y}
θc = RENORMALIZE(θc, y)
if Sc = Q then
G= G\{c}
θr = RENORMALIZE(θr, c)
Algorithm 8 RENORMALIZE
Initialization: θ = (p1, . . . , pK), i ∈ [K]
a = Pk6=i pk
for k ∈ [K], k 6= i do
p0k = pk/a
Return θ0 =(P0i，…Pi-ι,Pi+ι,…，pK)
Let M denote the number of clients, N the number of examples per client, and Dm the dataset
for client m ∈ {1,…，M}.A full description of our method is given in Algorithm 7. For our
experiments, we use N = 100, M = 500, α = 0.1, β = 10. In Figure 14, we plot the distribution of
unique labels among the 500 training clients. Each client has only a fraction of the overall labels in
the distribution. Moreover, there is variance in the number of unique labels, with most clients having
between 20 and 30, and some having over 40. Some client datasets have very few unique labels.
While this is primarily an artifact of performing without replacement sampling, this helps increase the
heterogeneity of the dataset in a way that can reflect practical concerns, as in many settings, clients
may only have a few types of labels in their dataset.
io
60
70 c1far-10° c"ent LabH Distribution
Ooo-
5 4 3 _
A□unbt
Figure 14: The distribution of the number of unique labels among
federated CIFAR-100 dataset.
10	20	30	40
Number of unique labels
training client datasets in our
38