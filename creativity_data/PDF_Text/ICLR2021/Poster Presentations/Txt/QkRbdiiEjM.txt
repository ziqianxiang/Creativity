Published as a conference paper at ICLR 2021
AdaGCN: Adaboosting Graph Convolutional
Networks into Deep Models
Ke Sun
Zhejiang Lab
Key Lab. of Machine Perception (MoE), School of EECS, Peking University
ajksunke@pku.edu.cn
Zhanxing Zhu*
Beijing Institute of Big Data Research, Beijing, China
zhanxing.zhu@pku.edu.cn
Zhouchen Lin*
Key Lab. of Machine Perception (MoE), School of EECS, Peking University
Pazhou Lab, Guangzhou, China
zlin@pku.edu.cn
Ab stract
The design of deep graph models still remains to be investigated and the crucial
part is how to explore and exploit the knowledge from different hops of neighbors
in an efficient way. In this paper, we propose a novel RNN-like deep graph neu-
ral network architecture by incorporating AdaBoost into the computation of net-
work; and the proposed graph convolutional network called AdaGCN (Adaboost-
ing Graph Convolutional Network) has the ability to efficiently extract knowledge
from high-order neighbors of current nodes and then integrates knowledge from
different hops of neighbors into the network in an Adaboost way. Different from
other graph neural networks that directly stack many graph convolution layers,
AdaGCN shares the same base neural network architecture among all “layers”
and is recursively optimized, which is similar to an RNN. Besides, We also theo-
retically established the connection between AdaGCN and existing graph convo-
lutional methods, presenting the benefits of our proposal. Finally, extensive ex-
periments demonstrate the consistent state-of-the-art prediction performance on
graphs across different label rates and the computational advantage of our ap-
proach AdaGCN * 1 .
1	Introduction
Recently, research related to learning on graph structural data has gained considerable attention in
machine learning community. Graph neural networks (Gori et al., 2005; Hamilton et al., 2017;
VeliCkovic et al., 2018), particularly graph convolutional networks (KiPf & Welling, 2017; Deffer-
rard et al., 2016; Bruna et al., 2014) have demonstrated their remarkable ability on node classifi-
cation (Kipf & Welling, 2017), link prediction (Zhu et al., 2016) and clustering tasks (Fortunato,
2010). Despite their enormous success, almost all of these models have shallow model architectures
with only two or three layers. The shallow design of GCN appears counterintuitive as deep versions
of these models, in principle, have access to more information, but perform worse. Oversmooth-
ing (Li et al., 2018) has been proposed to explain why deep GCN fails, showing that by repeatedly
applying Laplacian smoothing, GCN may mix the node features from different clusters and makes
them indistinguishable. This also indicates that by stacking too many graph convolutional layers,
the embedding of each node in GCN is inclined to converge to certain value (Li et al., 2018), mak-
ing it harder for classification. These shallow model architectures restricted by oversmoothing issue
* Corresponding author.
1Code is available at https://github.com/datake/AdaGCN.
1
Published as a conference paper at ICLR 2021
limit their ability to extract the knowledge from high-order neighbors, i.e., features from remote
hops of neighbors for current nodes. Therefore, it is crucial to design deep graph models such that
high-order information can be aggregated in an effective way for better predictions.
There are some works (Xu et al., 2018b; Liao et al., 2019; Klicpera et al., 2018; Li et al., 2019; Liu
et al., 2020) that tried to address this issue partially, and the discussion can refer to Appendix A.1.
By contrast, we argue that a key direction of constructing deep graph models lies in the efficient
exploration and effective combination of information from different orders of neighbors. Due to
the apparent sequential relationship between different orders of neighbors, it is a natural choice to
incorporate boosting algorithm into the design of deep graph models. As an important realization of
boosting theory, AdaBoost (Freund et al., 1999) is extremely easy to implement and keeps competi-
tive in terms of both practical performance and computational cost (Hastie et al., 2009). Moreover,
boosting theory has been used to analyze the success of ResNets in computer vision (Huang et al.,
2018) and AdaGAN (Tolstikhin et al., 2017) has already successfully incorporated boosting algo-
rithm into the training of GAN (Goodfellow et al., 2014).
In this work, we focus on incorporating AdaBoost into the design of deep graph convolutional
networks in a non-trivial way. Firstly, in pursuit of the introduction of AdaBoost framework, we
refine the type of graph convolutions and thus obtain a novel RNN-like GCN architecture called
AdaGCN. Our approach can efficiently extract knowledge from different orders of neighbors and
then combine these information in an AdaBoost manner with iterative updating of the node weights.
Also, we compare our AdaGCN with existing methods from the perspective of both architectural
difference and feature representation power to show the benefits of our method. Finally, we conduct
extensive experiments to demonstrate the consistent state-of-the-art performance of our approach
across different label rates and computational advantage over other alternatives.
2	Our Approach: AdaGCN
2.1	Establishment of AdaGCN
Consider an undirected graph G = (V, E) with N nodes vi ∈ V, edges (vi , vj ) ∈ E. A ∈ RN ×N
is the adjacency matrix with corresponding degree matrix Dii = Pj Aij . In the vanilla GCN
model (Kipf & Welling, 2017) for semi-supervised node classification, the graph embedding of
nodes with two convolutional layers is formulated as:
Z = A ReLU(AXW (O))W ⑴	(1)
where Z ∈ RN ×K is the final embedding matrix (output logits) of nodes before softmax and K
is the number of classes. X ∈ RN ×C denotes the feature matrix where C is the input dimension.
A = DD-2 AD-2 where A = A + I and DD is the degree matrix of A. In addition, W⑼ ∈ RC×H
is the input-to-hidden weight matrix for a hidden layer with H feature maps and W(1) ∈ RH×K is
the hidden-to-output weight matrix.
Our key motivation of constructing deep graph models is to efficiently explore information of high-
order neighbors and then combine these messages from different orders of neighbors in an AdaBoost
way. Nevertheless, if we naively extract information from high-order neighbors based on GCN,
we are faced with stacking l layers’ parameter matrix W(i), i = 0, ..., l - 1, which is definitely
costly in computation. Besides, Multi-Scale Deep Graph Convolutional Networks (Luan et al.,
2019) also theoretically demonstrated that the output can only contain the stationary information
of graph structure and loses all the local information in nodes for being smoothed if we simply
deepen GCN. Intuitively, the desirable representation of node features does not necessarily need too
many nonlinear transformation f applied on them. This is simply due to the fact that the feature of
each node is normally one-dimensional sparse vector rather than multi-dimensional data structures,
e.g., images, that intuitively need deep convolution network to extract high-level representation for
vision tasks. This insight has been empirically demonstrated in many recent works (Wu et al., 2019;
Klicpera et al., 2018; Xu et al., 2018a), showing that a two-layer fully-connected neural networks is a
better choice in the implementation. Similarly, our AdaGCN also follows this direction by choosing
an appropriate f in each layer rather than directly deepen GCN layers.
Thus, we propose to remove ReLU to avoid the expensive joint optimization of multiple parameter
matrices. Similarly, Simplified Graph Convolution (SGC) (Wu et al., 2019) also adopted this prac-
2
Published as a conference paper at ICLR 2021
Figure 1: The RNN-like architecture of AdaGCN with each base classifier fθI) sharing the same
neural network architecture fθ. Wl and θι denote node weights and parameters computed after the
l-th base classifier, respectively.
tice, arguing that nonlinearity between GCN layers is not crucial and the majority of the benefits
arises from local weighting of neighboring features. Then the simplified graph convolution is:
Z = AlXW⑼W⑴…W(IT) = AlXW,	(2)
where We collapse W(O)W⑴•…W(l-1) as W and Al denotes A to the l-th power. In particular,
one crucial impact of ReLU in GCN is to accelerate the convergence of matrix multiplication since
the ReLU is a contraction mapping intuitively. Thus, the removal of ReLU operation could also
alleviate the oversmoothing issue, i.e. slowering the convergence of node embedding to indistin-
guishable ones (Li et al., 2018). Additionally, without ReLU this simplified graph convolution is
also able to avoid the aforementioned joint optimization over multiple parameter matrices, result-
ing in computational benefits. Nevertheless, we find that this type of stacked linear transformation
from graph convolution has insufficient power in representing information of high-order neighbors,
which is revealed in our experiment described in Appendix A.2. Therefore, we propose to utilize an
appropriate nonlinear function fθ, e.g., a two-layer fully-connected neural network, to replace the
linear transformation W in Eq. 2 and enhance the representation ability of each base classifier in
AdaGCN as follows:
Z (I)= fθ (Al X),	(3)
where Z(l) represents the final embedding matrix (output logits before Softmax) after the l-th base
classifier in AdaGCN. This formulation also implies that the l-th base classifier in AdaGCN is ex-
tracting knowledge from features of current nodes and their l-th hop of neighbors. Due to the fact
that the function of l-th base classifier in AdaGCN is similar to that of the l-th layer in other tra-
ditional GCN-based methods that directly stack many graph convolutional layers, we regard the
whole part of l-th base classifier as the l-th layers in AdaGCN. As for the realization of Multi-class
AdaBoost, we apply SAMME (Stagewise Additive Modeling using a Multi-class Exponential loss
function) algorithm (Hastie et al., 2009), a natural and clean multi-class extension of the two-class
AdaBoost adaptively combining weak classifiers.
As illustrated in Figure 1, we apply base classifier fθ(l) to extract knowledge from current node
feature and l-th hop of neighbors by minimizing current weighted loss. Then we directly compute
the weighted error rate err(l) and corresponding weight α(l) of current base classifier fθ(l) as follows:
nn
err(l) = XwiI ci 6= fθ(l) (xi) /Xwi
i=1	i=1	(4)
1	err(l)
α(I) = log--jτ- + log(K - 1),
err(l)
where wi denotes the weight of i-th node and ci represents the category of current i-th node. To
attain a positive α(l), we only need (1 - err(l)) > 1/K, i.e., the accuracy of each weak classifier
3
Published as a conference paper at ICLR 2021
should be better than random guess (Hastie et al., 2009). This can be met easily to guarantee the
weights to be updated in the right direction. Then we adjust nodes’ weights by increasing weights
on incorrectly classified ones:
Wi — Wi ∙ exp (α(l) ∙ I j = fθl) (Xi))) ,i = 1,...,n	(5)
After re-normalizing the weights, We then compute Al+1X = A ∙ (AlX) to sequentially extract
knowledge from l+1-th hop of neighbors in the following base classifier fθ(l+1). One crucial point
of AdaGCN is that different from traditional AdaBoost, we only define one fθ, e.g. a two-layer
fully connected neural network, which in practice is recursively optimized in each base classifier
just similar to a recurrent neural network. This also indicates that the parameters from last base
classifier are leveraged as the initialization of next base classifier, which coincides with our intuition
that l + 1-th hop of neighbors are directly connected from l-th hop of neighbors. The efficacy of this
kind of layer-wise training has been similarly verified in (Belilovsky et al., 2018) recently. Further,
we combine the predictions from different orders of neighbors in an Adaboost way to obtain the
final prediction C(A, X):
L
C(A, X) = arg max X α(lfθ(I(AIX)	(6)
l=0
Finally, we obtain the concise form of AdaGCN in the following:
A(X = A ∙ (A(TX)
Z (I) = fθI)(A(X)	(7)
Z= AdaBoost(Z(())
Note that fθ is non-linear, rather than linear in SGC (Wu et al., 2019), to guarantee the representation
power. As shown in Figure 1, the architecture of AdaGCN is a variant of RNN with synchronous
sequence input and output. Although the same classifier architecture is adopted for fθ((), their pa-
rameters are different, which is different from vanilla RNN. We provide a detailed description of the
our algorithm in Section 3.
2.2 Comparison WITH Existing Methods
Architectural Difference. As illustrated in
Figure 1 and 2, there is an apparent differ-
ence among the architectures of GCN (KiPf
& Welling, 2017), SGC (WU et al., 2019),
Jumping Knowledge (JK) (Xu et al., 2018b)
and AdaGCN. Compared with these existing
graph convolutional approaches that sequen-
tially convey intermediate result Z(I) to com-
pute final prediction, our AdaGCN transmits
weights of nodes wi, aggregated features of
different hops of neighbors A(X. More im-
portantly, in AdaGCN the embedding Z(I) is
independent of the flow of computation in the
network and the sparse adjacent matrix A is
Figure 2: Comparison of the graph model architec-
tures. fa in JK network denotes one aggregation
layer with aggregation function such as concatena-
tion or max pooling.
also not directly involved in the computation
of individual network because we compute
A(I+I)X in advance and then feed it instead of A into the classifier f£+1), thus yielding signifi-
cant computation reduction, which will be discussed further in section 3.
Connection with PPNP and APPNP. We also established a strong connection between AdaGCN
and previous state-of-the-art Personalized Propagation of Neural Predictions (PPNP) and Approxi-
mate PPNP (APPNP) (Klicpera et al., 2018) method that leverages personalized pagerank to recon-
struct graph convolutions in order to use information from a large and adjustable neighborhood. The
analysis can be summarized in the following Proposition 1. Proof can refer to Appendix A.3.
4
Published as a conference paper at ICLR 2021
Proposition 1. Suppose that γ is the teleport factor. Let matrix sequence {Z(l)} be from the output
of each layer l in AdaGCN, then PPNP is equivalent to the Exponential Moving Average (EMA) with
exponentially decreasing factor γ on {Z (l) } in a sharing parameters version, and its approximate
version APPNP can be viewed as the approximated form of EMA with a limited number of terms.
Proposition 1 illustrates that AdaGCN can be viewed as an adaptive form of APPNP, formulated as:
L
Z = X α(l)fθl)(AlX)
(8)
l=0
Specifically, the first discrepancy between AdaGCN and APPNP lies in the adaptive coefficient
α(l) in AdaGCN determined by the error of l-th base classifier fθ(l) rather than fixed exponentially
decreased weights in APPNP. In addition, AdaGCN employs classifier fθ(l) with different parameters
to learn the embedding of different orders of neighbors, while APPNP shares these parameters in its
form. We verified this benefit of our approach in our experiments shown in Section 4.2.
Comparison with MixHop MixHop (Abu-El-Haija et al., 2019) applied the similar way of graph
convolution by repeatedly mixing feature representations of neighbors at various distance. Propo-
sition 2 proves that both AdaGCN and MixHop are able to represent feature differences among
neighbors while previous GCNs-based methods cannot. Proof can refer to Appendix A.4. Recap the
definition of general layer-wise Neighborhood Mixing (Abu-El-Haija et al., 2019) as follows:
Definition 1. General layer-wise Neighborhood Mixing: A graph convolution network has the abil-
ity to represent the layer-wise neighborhood mixing iffor any b0,b1,…,bL, there exists an injective
mapping f with a setting of its parameters, such that the output of this graph convolution network
can express the following formula:
(9)
Proposition 2. AdaGCNs defined by our proposed approach (Eq. equation 7) are capable of repre-
senting general layer-wise neighborhood mixing, i.e., can meet the Definition 1.
Albeit the similarity, AdaGCN distinguishes from MixHop in many aspects. Firstly, MixHop con-
catenates all outputs from each order of neighbors while we combines these predictions in an Ad-
aboost way, which has theoretical generalization guarantee based on boosting theory Hastie et al.
(2009). Oono & Suzuki (2020) have recently derived the optimization and generalization guarantees
of multi-scale GNNs, serving as the theoretical backbone of AdaGCN. Meantime, MixHop allows
full linear mixing of different orders of neighboring features, while AdaGCN utilizes different non-
linear transformation fθ(l) among all layers, enjoying stronger expressive power.
3 Algorithm
In practice, we employ SAMME.R (Hastie et al., 2009), the soft version of SAMME, in AdaGCN.
SAMME.R (R for Real) algorithm (Hastie et al., 2009) leverages real-valued confidence-rated pre-
dictions, i.e., weighted probability estimates, rather than predicted hard labels in SAMME, in the
prediction combination, which has demonstrated a better generalization and faster convergence than
SAMME. We elaborate the final version of AdaGCN in Algorithm 1. We provide the analysis on
the choice of model depth L in Appendix A.7, and then we elaborate the computational advantage
of AdaGCN in the following.
Analysis of Computational Advantage. Due to the similarity of graph convolution in Mix-
Hop (Abu-El-Haija et al., 2019), AdaGCN also requires no additional memory or computational
complexity compared with previous GCN models. Meanwhile, our approach enjoys huge com-
putational advantage compared with GCN-based models, e.g., PPNP and APPNP, stemming from
excluding the additional computation involved in sparse tensors, such as the sparse tensor multipli-
cation between A and other dense tensors, in the forward and backward propagation of the neural
network. Specifically, there are only L times sparse tensor operations for an AdaGCN model with L
layers, i.e., AlX = A ∙ (Al-1X) for each layer l. This operation in each layer yields a dense tensor
5
Published as a conference paper at ICLR 2021
Algorithm 1 AdaGCN based on SAMME.R Algorithm
Input: Features Matrix X, normalized adjacent matrix A, a two-layer fully connected network fθ,
number of layers L and number of classes K .
Output: Final combined prediction C(A, X).
1:	Initialize the node weights wi = 1/n, i = 1, 2, ..., n on training set, neighbors feature matrix
X(O) = X and classifier fθ-1).
2:	for l = 0 to L do
3:	Fit the graph convolutional classifier fθl) on neighbor feature matrix X(I) based on fθl-1) by
minimizing current weighted loss.
4:	Obtain the weighted probability estimates P(I)(X (I)) for fθl):
Pkl)(X(I)) = SOftmax(fθl)(c = k|X(I))), k =1,...,K
5:	Compute the individual prediction h(kl)(x) for the current graph convolutional classifier fθ(l):
hkl)(X(I))-(K - 1) (logPkl)(X(I))- K X logPklO)(X(I)))
where k = 1, . . . , K .
6:	Adjust the node weights wi for each node xi with label yi on training set:
Wi J Wi ∙ exp (— KK 1 y› log P(I) (Xi)) ,i = 1,... ,n
7:	Re-normalize all weights wi .
8:	Update l+1-hop neighbor feature matrix X(l+1):
X (l+1) = AX(l)
9:	end for
10:	Combine all predictions h%l (X(I)) for l = 0,…,L.
L
C(A, X) = arg max X h*X (I))
l=0
11:	return Final combined prediction C(A, X).
Bl = AlX for the l-th layer, which is then fed into the computation in a two-layer fully-connected
network, i.e., fθ(l)(Bl) = ReLU(BlW(0))W(1). Due to the fact that dense tensor Bl has been com-
puted in advance, there is no other computation related to sparse tensors in the multiple forward and
backward propagation procedures while training the neural network. By contrast, this multiple com-
putation involved in sparse tensors in the GCN-basedmodels, e.g., GCN: A ReLU(AXW(O))W⑴，
is highly expensive. AdaGCN avoids these additional sparse tensor operations in the neural network
and then attains huge computational efficiency. We demonstrate this viewpoint in the Section 4.3.
4 Experiments
Experimental Setup. We select five commonly used graphs: CiteSeer, Cora-ML (Bojchevski &
Gunnemann, 2018; McCallum et al., 2000), PubMed (Sen et al., 2008), MS-Academic (Shchur
et al., 2018) and Reddit. Dateset statistics are summarized in Table 1. Recent graph neural networks
suffer from overfitting to a single splitting of training, validation and test datasets (Klicpera et al.,
2018). To address this problem, inspired by (Klicpera et al., 2018), we test all approaches on multiple
random splits and initialization to conduct a rigorous study. Detailed dataset splittings are provided
in Appendix A.6.
Dateset	Nodes	Edges	Classes	Features	Label Rate
CiteSeer	3,327	4,732	6	3,703	3.6%
Cora	2,708	5,429	7	1,433	5.2%
PubMed	19,717	44,338	3	500	0.3%
MS Academic	18,333	81,894	15	6,805	1.6%
Reddit	232,965	11,606,919	41	602	65.9%
Table 1: Dateset statistics
6
Published as a conference paper at ICLR 2021
8070605040
(％)Auβlgv mH
30
20
Cora-ML
GCN
GCN(Residual)
SGC
AdaGCN
1 2 3 4 5 6 7 8 9 101112131415
Layers
70605040
(％XUEn8Vml
706050
(％XUEn8Vml
AdaGCN
1 2 3 4 5 6 1 8 9 101112131415
Layers
GCN
GCN(Re
SGC
40
Pubmed
_∙
-----GCN
GCN(Residual)
—SGC
---AdaGCN
1 2 3 4 5 6 1 8 9 101112 13 1415
Layers

Figure 3:	Comparison of test accuracy of different models as the layer increases. We regard the l-th
base classifier as the l-th layer in AdaGCN as both of them are leveraged to exploit the information
from l-th order of neighbors for current nodes.
Basic Setting of Baselines and AdaGCN. We compare AdaGCN with GCN (Kipf & Welling,
2017) and Simple Graph Convolution (SGC) (Wu et al., 2019) in Figure 3. In Table 2, we employ
the same baselines as (Klicpera et al., 2018): V.GCN (vanilla GCN) (Kipf & Welling, 2017) and
GCN with our early stopping, N-GCN (network of GCN) (Abu-El-Haija et al., 2018a), GAT (Graph
Attention Networks) (VelickoVic et al., 2018), BT.FP (bootstrapped feature propagation) (BUchnik
& Cohen, 2018) and JK (jumping knowledge networks with concatenation) (Xu et al., 2018b). In
the computation part, we additionally compare AdaGCN with FastGCN (Chen et al., 2018) and
GraphSAGE (Hamilton et al., 2017). We refer to the result of baselines from (Klicpera et al., 2018)
and the implementation of AdaGCN is adapted from APPNP. For AdaGCN, after the line search
on hyper-parameters, we set h = 5000 hidden units for the first four datasets except Ms-academic
with h = 3000, and 15, 12, 20 and 5 layers respectiVely due to the different graph structures. In
addition, we set dropout rate to 0 for Citeseer and Cora-ML datasets and 0.2 for the other datasets
and 5 × 10-3L2 regularization on the first linear layer. We set weight decay as 1 × 10-3 for Citeseer
while 1 × 10-4 for others. More detailed model parameters and analysis about our early stopping
mechanism can be referred from Appendix A.6.
4.1	Design of Deep Graph Models to Circumvent Oversmoothing Effect
It is well-known that GCN suffers from oVersmoothing (Li et al., 2018) with the stacking of more
graph conVolutions. HoweVer, combination of knowledge from each layer to design deep graph
Model	Citeseer	Cora-ML	Pubmed	MS Academic
V.GCN	73.51±0.48	82.30±0.34	77.65±0.40	91.65±0.09
GCN	75.40±0.30	83.41±0.39	78.68±0.38	92.10±0.08
N-GCN	74.25±0.40	82.25±0.30	77.43±0.42	92.86±0.11
GAT	75.39±0.27	84.37±0.24	77.76±0.44	91.22±0.07
JK	73.03±0.47	82.69±0.35	77.88±0.38	91.71±0.10
BT.FP	73.55±0.57	80.84±0.97	72.94±1.00	91.61±0.24
PPNP	75.83±0.27	85.29±0.25	OOM	OOM
APPNP	75.73±0.30	85.09±0.25	79.73±0.31	93.27±0.08
PPNP (ours)	75.53±0.32	84.39±0.28	OOM	OOM
APPNP (ours)	75.41±0.35	84.28±0.28	79.41±0.34	92.98±0.07
AdaGCN	76.68±0.20	85.97±0.20	79.95±0.21	93.17±0.07
P Value	1.8×10-15	2.2×10i	1.1×10-5	2.1×10-9
Table 2: AVerage accuracy under 100 runs with uncertainties showing the 95 % confidence leVel
calculated by bootstrapping. OOM denotes “out of memory”. “(ours)” denotes the results based on
our implementation, which are slight lower than numbers aboVe from original literature (Klicpera
et al., 2018). P Values of paired t test between APPNP (ours) and AdaGCN are proVided in the last
row.
7
Published as a conference paper at ICLR 2021
Label Rates	Citeseer 1.0% / 2.0%	Cora-ML 2.0% / 4.0%	Pubmed 0.1% / 0.2%	MS Academic 0.6% / 1.2%
V.GCN	67.6±1.4/70.8±1.4	76.4±1.3∕81.7±0.8	70.1±1.4/74.6±1.6	89.7±0.4/91.1±0.2
GCN	70.3±0.9/72.7±1.1	80.0±0.7/82.8±0.9	71.1±1.1/75.2±1.0	89.8±0.4/91.2±0.3
PPNP	72.5±0.9/74.7±0.7	80.1±0.7/83.0±0.6	OOM	OOM
APPNP	72.2±1.3/74.2±1.1	80.1±0.7∕83.2±0.6	74.0±1.5/77.2±1.2	91.7±0.2/92.6±0.2
AdaGCN	74.2±0.3/75.5±0.3	83.7±0.3/85.3±0.2	77.1±0.5/79.3±0.3	92.1±0.1/92.7±0.1
Table 3: Average accuracy across different label rates with 20 splittings of datasets under 100 runs.
models is a reasonable method to circumvent oversmoothing issue. In our experiment, we aim to
explore the prediction performance of GCN, GCN with residual connection (Kipf & Welling, 2017),
SGC and our AdaGCN with a growing number of layers.
From Figure 3, it can be easily observed that oversmoothing leads to the rapid decreasing of accu-
racy for GCN (blue line) as the layer increases. In contrast, the speed of smoothing (green line) of
SGC is much slower than GCN due to the lack of ReLU analyzed in Section 2.1. Similarly, GCN
with residual connection (yellow line) partially mitigates the oversmoothing effect of original GCN
but fails to take advantage of information from different orders of neighbors to improve the predic-
tion performance constantly. Remarkably, AdaGCN (red line) is able to consistently enhance the
performance with the increasing of layers across the three datasets. This implies that AdaGCN can
efficiently incorporate knowledge from different orders of neighbors and circumvent oversmoothing
of original GCN in the process of constructing deep graph models. In addition, the fluctuation of
performance for AdaGCN is much lower than GCN especially when the number of layer is large.
4.2	Prediction Performance
We conduct a rigorous study of AdaGCN on four datasets under multiple splittings of dataset. The
results from Table 2 suggest the state-of-the-art performance of our approach and the improvement
compared with APPNP validates the benefit of adaptive form for our AdaGCN. More rigorously, p
values under paired t test demonstrate the significance of improvement for our method.
In the realistic setting, graphs usually have different labeled nodes and thus it is necessary to in-
vestigate the robust performance of methods on different number of labeled nodes. Here we utilize
label rates to measure the different numbers of labeled nodes and then sample corresponding labeled
nodes per class on graphs respectively. Table 3 presents the consistent state-of-the-art performance
of AdaGCN under different label rates. An interesting manifestation from Table 3 is that AdaGCN
yields more improvement on fewer label rates compared with APPNP, showing more efficiency on
graphs with few labeled nodes. Inspired by the Layer Effect on graphs (Sun et al., 2019), we argue
that the increase of layers in AdaGCN can result in more benefits on the efficient propagation of
label signals especially on graphs with limited labeled nodes.
More rigorously, we additionally conduct the
comparison on a larger dataset, i.e., Reddit. We
choose the best layer as 4 due to the fact that
AdaGCN with larger number of layers tends to
suffer from overfitting on this relatively sim-
ple dataset (with high label rate 65.9%). Ta-
ble 4 suggests that AdaGCN can still outper-
form other typical baselines, including V.GCN,
PPNP and APPNP. More experimental details
can be referred from Appendix A.6.
Reddit	F1-Score	Per-epoch training time
V.GCN	94.46±0.06	5627.46ms
PPNP	OOM	OOM
APPNP	95.04±0.07	29489.81ms
AdaGCN	95.39±0.13	32.29ms
Table 4: Average F1-scores and per-epoch train-
ing time of typical methods on Reddit dataset un-
der 5 runs.
4.3	Computational Efficiency
Without the additional computational cost involved in sparse tensors in the propagation of the neu-
ral network, AdaGCN presents huge computational efficiency. From the left part of Figure 4, it
exhibits that AdaGCN has the fastest speed of per-epoch training time in comparison with other
methods except the comparative performance with FastGCN in Pubmed. In addition, there is a
somewhat inconsistency in computation of FastGCN, with fastest speed in Pubmed but slower than
8
Published as a conference paper at ICLR 2021
Time
Time on Pubmed
GCN
SGC
AdaGCN
GCN
GraPhSAGE~mean
FastGCN
APPNP
AdaGCN
Pnbmed Ms-Acadanic
Layers

(SlD) Ipoda Jaduuη^
Figure 4:	Left: Per-epoch training time of AdaGCN vs other methods under 5 runs on four datasets.
Right: Per-epoch training time of AdaGCN compared with GCN and SGC with the increasing of
layers and the digit after “k =” denotes the slope in a fitted linear regression.
GCN on Cora-ML and MS-Academic datasets. Furthermore, with multiple power iterations in-
volved in sparse tensors, APPNP unfortunately has relatively expensive computation cost. It should
be noted that this computational advantage of AdaGCN is more significant when it comes to large
datasets, e.g., Reddit. Table 4 demonstrates AdaGCN has the potential to perform much faster on
larger datasets.
Besides, we explore the computational cost of ReLU and sparse adjacency tensor with respect to the
number of layers in the right part of Figure 4. We focus on comparing AdaGCN with SGC and GCN
as other GCN-based methods, such as GraphSAGE and APPNP, behave similarly with GCN. Partic-
ularly, we can easily observe that both SGC (green line) and GCN (red line) show a linear increasing
tendency and GCN yields a larger slope arises from ReLU and more parameters. For SGC, stack-
ing more layers directly is undesirable regarding the computation. Thus, a limited number of SGC
layers is preferable with more advanced optimization techniques Wu et al. (2019). It also shows
that the computational cost involved sparse matrices in neural networks plays a dominant role in all
the cost especially when the layer is large enough. In contrast, our AdaGCN (pink line) displays
an almost constant trend as the layer increases simply because it excludes the extra computation
involved in sparse tensors A, such as •…A ReLU(AXW(O))W(1) ∙∙∙, in the process of training
neural networks. AdaGCN maintains the updating of parameters in the fθ(l) with a fixed architecture
in each layer while the layer-wise optimization, therefore displaying a nearly constant computation
cost within each epoch although more epochs are normally needed in the entire layer-wise train-
ing. We leave the analysis of exact time and memory complexity of AdaGCN as future works, but
boosting-based algorithms including AdaGCN is memory-efficient (Oono & Suzuki, 2020).
5 Discussions and Conclusion
One potential concern is that AdaBoost (Hastie et al., 2009; Freund et al., 1999) is established on
i.i.d. hypothesis while graphs have inherent data-dependent property. Fortunately, the statistical
convergence and consistency of boosting (Lugosi & Vayatis, 2001; Mannor et al., 2003) can still
be preserved when the samples are weakly dependent (Lozano et al., 2013). More discussion can
refer to Appendix A.5. In this paper, we propose a novel RNN-like deep graph neural network
architecture called AdaGCNs. With the delicate architecture design, our approach AdaGCN can
effectively explore and exploit knowledge from different orders of neighbors in an Adaboost way.
Our work paves a way towards better combining different-order neighbors to design deep graph
models rather than only stacking on specific type of graph convolution.
Acknowledgments
Z. Lin is supported by NSF China (grant no.s 61625301 and 61731018), Major Scientific Research
Project of Zhejiang Lab (grant no.s 2019KB0AC01 and 2019KB0AB02), Beijing Academy of Arti-
ficial Intelligence, and Qualcomm.
9
Published as a conference paper at ICLR 2021
References
Sami Abu-El-Haija, Amol Kapoor, Bryan Perozzi, and Joonseok Lee. N-gcn: Multi-scale graph con-
volution for semi-supervised node classification. International Workshop on Mining and Learning
with Graphs (MLG), 2018a.
Sami Abu-El-Haija, Bryan Perozzi, Amol Kapoor, Hrayr Harutyunyan, Nazanin Alipourfard,
Kristina Lerman, Greg Ver Steeg, and Aram Galstyan. Mixhop: Higher-order graph convolution
architectures via sparsified neighborhood mixing. International Conference on Machine Learning
(ICML), 2019.
Eugene Belilovsky, Michael Eickenberg, and Edouard Oyallon. Greedy layerwise learning can scale
to imagenet. International Conference on Machine Learning (ICML), 2018.
Aleksandar Bojchevski and StePhan Gunnemann. Deep gaussian embedding of graphs: UnsU-
pervised inductive learning via ranking. International Conference on Learning Representations
(ICLR), 2018.
Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann LeCun. Spectral networks and locally
connected networks on graphs. International Conference on Learning Representations (ICLR),
2014.
Eliav Buchnik and Edith Cohen. Bootstrapped graph diffusions: Exposing the power of nonlinear-
ity. In Abstracts of the 2018 ACM International Conference on Measurement and Modeling of
Computer Systems, pp. 8-10. ACM, 2018.
Peter BUhlmann and Bin Yu. Boosting with the 12 loss: regression and classification. Journal Ofthe
American Statistical Association, 98(462):324-339, 2003.
Jie Chen, Tengfei Ma, and Cao Xiao. Fastgcn: fast learning with graph convolutional networks via
importance sampling. International Conference on Learning Representations (ICLR), 2018.
Michael Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional neural networks
on graphs with fast localized spectral filtering. In Advances in Neural Information Processing
Systems (NeurIPS), pp. 3844-3852, 2016.
Santo Fortunato. Community detection in graphs. Physics reports, 486(3-5):75-174, 2010.
Yoav Freund, Robert Schapire, and Naoki Abe. A short introduction to boosting. Journal-Japanese
Society For Artificial Intelligence, 14(771-780):1612, 1999.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural infor-
mation processing systems (NeurIPS), pp. 2672-2680, 2014.
Marco Gori, Gabriele Monfardini, and Franco Scarselli. A new model for learning in graph domains.
In Proceedings. 2005 IEEE International Joint Conference on Neural Networks, 2005., volume 2,
pp. 729-734. IEEE, 2005.
Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive representation learning on large graphs.
In Advances in Neural Information Processing Systems (NeurIPS), pp. 1024-1034, 2017.
Trevor Hastie, Saharon Rosset, Ji Zhu, and Hui Zou. Multi-class adaboost. Statistics and Its Inter-
face, 2(3):349-360, 2009.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016.
Furong Huang, Jordan Ash, John Langford, and Robert Schapire. Learning deep resnet blocks
sequentially using boosting theory. International Conference on Machine Learning (ICML), 2018.
Wenxin Jiang et al. Process consistency for adaboost. The Annals of Statistics, 32(1):13-29, 2004.
10
Published as a conference paper at ICLR 2021
Ming Jin, Heng Chang, Wenwu Zhu, and Somayeh Sojoudi. Power up! robust graph convolutional
network against evasion attacks based on graph powering. arXiv preprint arXiv:1905.10029,
2019.
Thomas N Kipf and Max Welling. Semi-supervised classification with graph convolutional net-
works. International Conference on Learning Representations (ICLR), 2017.
Johannes Klicpera, Aleksandar Bojchevski, and StePhan Gunnemann. Predict then propagate:
Graph neural networks meet personalized pagerank. International Conference on Learning Rep-
resentations (ICLR), 2018.
Guohao Li, Matthias Muller, Ali ThabeL and Bernard Ghanem. Can gcns go as deep as cnns? ICCV,
2019.
Qimai Li, Zhichao Han, and Xiao-Ming Wu. Deeper insights into graph convolutional networks
for semi-supervised learning. Association for the Advancement of Artificial Intelligence (AAAI),
2018.
Renjie Liao, Zhizhen Zhao, Raquel Urtasun, and Richard S Zemel. Lanczosnet: Multi-scale deep
graph convolutional networks. International Conference on Learning Representations (ICLR),
2019.
Meng Liu, Hongyang Gao, and Shuiwang Ji. Towards deeper graph neural networks. In Proceedings
of the 26th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining, pp.
338-348, 2020.
Aurelie C Lozano, Sanjeev R Kulkarni, and Robert E Schapire. Convergence and consistency of
regularized boosting with weakly dependent observations. IEEE Transactions on Information
Theory, 60(1):651-660, 2013.
Sitao Luan, Mingde Zhao, Xiao-Wen Chang, and Doina Precup. Break the ceiling: Stronger multi-
scale deep graph convolutional networks. Advances in Neural Information Processing Systems
(NeurIPS), 2019.
Gabor Lugosi and Nicolas Vayatis. On the bayes-risk consistency of boosting methods. 2001.
Shie Mannor, Ron Meir, and Tong Zhang. Greedy algorithms for classification-consistency, conver-
gence rates, and adaptivity. Journal of Machine Learning Research, 4(Oct):713-742, 2003.
Andrew Kachites McCallum, Kamal Nigam, Jason Rennie, and Kristie Seymore. Automating the
construction of internet portals with machine learning. Information Retrieval, 3(2):127-163,
2000.
Kenta Oono and Taiji Suzuki. Optimization and generalization analysis of transduction through
gradient boosting and application to multi-scale graph neural networks. Advances in Neural In-
formation Processing Systems (NeurIPS), 2020.
Omri Puny, Heli Ben-Hamu, and Yaron Lipman. From graph low-rank global attention to 2-fwl
approximation. ICML Workshop Graph Representation Learning and Beyond, 2020.
Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Galligher, and Tina Eliassi-Rad.
Collective classification in network data. AI magazine, 29(3):93, 2008.
Oleksandr Shchur, Maximilian Mumme, Aleksandar Bojchevski, and Stephan Gunnemann. Pitfalls
of graph neural network evaluation. In Relational Representation Learning Workshop (R2L 2018),
NeurIPS, 2018.
Ke Sun, Zhanxing Zhu, and Zhouchen Lin. Multi-stage self-supervised learning for graph convolu-
tional networks. Association for the Advancement of Artificial Intelligence (AAAI), 2019.
Ilya O Tolstikhin, Sylvain Gelly, Olivier Bousquet, Carl-Johann Simon-Gabriel, and Bernhard
Scholkopf. Adagan: Boosting generative models. In Advances in Neural Information Processing
Systems (NeurIPS), pp. 5424-5433, 2017.
11
Published as a conference paper at ICLR 2021
Petar VeliCkovic, GUillem CUcUrUlL Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua
Bengio. Graph attention networks. International Conference on Learning Representations
(ICLR), 2018.
Felix WU, Tianyi Zhang, AmaUri Holanda de SoUza Jr, Christopher Fifty, Tao YU, and Kilian Q
Weinberger. Simplifying graph convolUtional networks. International Conference on Machine
Learning (ICML), 2019.
KeyUlU XU, WeihUa HU, JUre Leskovec, and Stefanie Jegelka. How powerfUl are graph neUral
networks? International Conference on Learning Representations (ICLR), 2018a.
KeyUlU XU, Chengtao Li, Yonglong Tian, Tomohiro Sonobe, Ken-ichi Kawarabayashi, and Stefanie
Jegelka. Representation learning on graphs with jUmping knowledge networks. International
Conference on Machine Learning (ICML), 2018b.
Hanqing Zeng, HongkUan ZhoU, Ajitesh Srivastava, Rajgopal Kannan, and Viktor Prasanna. Graph-
saint: Graph sampling based indUctive learning method. International Conference on Learning
Representations (ICLR), 2019.
Tong Zhang, Bin YU, et al. Boosting with early stopping: Convergence and consistency. The Annals
OfStatistics, 33(4):1538-1579, 2005.
JUn ZhU, Jiaming Song, and Bei Chen. Max-margin nonparametric latent featUre models for link
prediction. arXiv preprint arXiv:1602.07428, 2016.
12
Published as a conference paper at ICLR 2021
A	Appendix
A. 1 Related Works on Deep Graph Models
A straightforward solution (Kipf & Welling, 2017; Xu et al., 2018b) inspired by ResNets (He et al., 2016) was
by adding residual connections, but this practice was unsatisfactory both in prediction performance and com-
putational efficiency towards building deep graph models, as shown in our experiments in Section 4.1 and 4.3.
More recently, JK (Jumping Knowledge Networks (Xu et al., 2018b)) introduced jumping connections into final
aggregation mechanism in order to extract knowledge from different layers of graph convolutions. However,
this straightforward change of GCN architecture exhibited inconsistent empirical performance for different ag-
gregation operators, which cannot demonstrate the successful construction of deep layers. In addition, Graph
powering-based method (Jin et al., 2019) implicitly leveraged more spatial information by extending classical
spectral graph theory to robust graph theory, but they concentrated on defending adversarial attacks rather than
model depth. LanczosNet (Liao et al., 2019) utilized Lanczos algorithm to construct low rank approximations
of the graph Laplacian and then can exploit multi-scale information. Moreover, APPNP (Approximate Per-
sonalized Propagation of Neural Predictions, (Klicpera et al., 2018)) leveraged the relationship between GCN
and personalized PageRank to derive an improved global propagation scheme. Beyond these, DeepGCNs (Li
et al., 2019) directly adapted residual, dense connection and dilated convolutions to GCN architecture, but it
mainly focused on the task of point cloud semantic segmentation and has not demonstrated its effectiveness in
typical graph tasks. Similar to our work, Deep Adaptive Graph Neural Network (DAGNN) (Liu et al., 2020)
also focused on incorporating information from large receptive fields through the entanglement of represen-
tation transformation and propagation, while our work efficiently ensembles knowledge from large receptive
fields in an Adaboost manner. Other related works based on global attention models (Puny et al., 2020) and
sample-based methods (Zeng et al., 2019) are also helpful to construct deep graph models.
A.2 Insufficient Representation Power of AdaSGC
As illustrated in Figure 5, with the increasing of layers, AdaSGC with only linear transformation has insufficient
representation power both in extracting knowledge from high-order neighbors and combining information from
different orders of neighbors while AdaGCN exhibits a consistent improvement of performance as the layer
increases.
Cora-ML	Citeseer	Pubmed
8075706560555045
(％Muα,muuv⅛3I
AdaSGC
AdaGCN
2 3 4 5 6 7 8 9 101112 131415
Layers
706560555045
(％Muα,muuv⅛aH
1 2 3 4 5 6 7 8 9 101112131415
Lavers
Figure 5: AdaSGC vs AdaGCN.
8070605040
(％Muα,muuv⅛3I
30
1 2 3 4 5 6 7 8 9 10 111213 1415
Lavers
A.3	Proof of Proposition 1
Firstly, we further elaborate the Proposition 1 as follows, then we provide the proof.
Suppose that Y is the teleport factor. Consider the output ZPPNP = Y(I — (1 — Y)A)Tfθ(X) in PPNP and
ZAPPNP from its approxminated version APPNP. Let matrix sequence {Z(l)} be from the output of each layer l
in AdaGCN, then PPNP is equivalent to the Exponential Moving Average (EMA) with exponentially decreasing
factor Y, a first-order infinite impulse response filter, on {Z(l)} in a sharing parameters version, i.e., fθ(l) ≡ fθ.
In addition, APPNP, which we reformulate in Eq. 10, can be viewed as the approximated form of EMA with a
13
Published as a conference paper at ICLR 2021
limited number of terms.
ZAPPNP = (Y XX (1 - γ)lAl + (1 - Y)LAL)fθ (X)	(10)
l=0
Proof. According to Neumann Theorem, ZPPNP can be expanded as a Neumann series:
ZPPNP = Y(I - (1 - Y)A)Tfθ(X)
=γ xx (1 - Y)IAIfθ(x),
l=0
where feature embedding matrix sequence {Z(l)} for each order of neighbors share the same parameters fθ. If
We relax this sharing nature to the adaptive form With respect to the layer and put Al into fθ, then the output Z
can be approximately formulated as:
Zppnp ≈ Y XX(1 - γ)lfθl)(AlX)
l=0
This relaxed version from PPNP is the Exponential Moving Average form of matrix sequence {Z (l) } With
exponential decreasing factor Y . Moreover, if We approximate the EMA by truncating it after L - 1 items, then
the Weight omitted by stopping after L - 1 items is (1 - Y)L . Thus, the approximated EMA is exactly the
APPNP form:
Zappnp = (Y £(1- Y)IAI + (1- Y)LAL) fθ(X)
l=0
□
A.4 Proof of Proposition 2
Proof. We consider a tWo layers fully-connected neural netWork as f in Eq. 8, then the output of AdaGCN can
be formulated as:
L
Z = X α(l)σ(AlXW(O))W⑴
l=0
Particularly, we set W(O) = ^^(^]@(1)I and W(I) = sign(bl)I where sign (bl) is the signed incidence scalar
W.r.t bl. Then the output of AdaGCN can be presented as:
Lb
Z = X *σ(AlX siin(b⅛y I)Sign(bl)I
=XX α")σ(AlX) sign(bl)α(l) sign(bl)
L
=X blσ (AlX)
l=O
The proof that GCNs-based methods are not capable of representing general layer-wise neighborhood mixing
has been demonstrated in MixHoP (AbU-El-Haija et al., 2019). Proposition 2 proved.	□
A.5 Explanation about Consistency of Boosting on Dependent Data
Definition 2. (β-mixing sequences.) Let σij = σ(W) = σ(Wi , Wi+1 , ..., Wj) be the σ-field generated by a
strictly stationary sequence of random variables W = (Wi, Wi+1 , ..., Wj). The β-mixing coefficient is defined
by:
βw(n) = SuPESuP n∣P (A∣σk) - P(A)∣ : A ∈ σ∞+n}
Then a sequence W is called β-mixing if limn→∞βW (n) = 0. Further, it is algebraically β-mixing if there is
a positive constant rβ such that βW (n) = O(n-rβ ).
Definition 3. (Consistency) A classification rule is consistent for a certain distribution P if E(L(hn)) =
P{hn (X) = Y } → a as n → ∞ where a is a constant. It is strongly Bayes-risk consistent if
limn→∞ L(hn) = a almost surely.
Under these definitions, the convergence and consistence of regularized boosting method on stationary β-
mixing sequences can be proved under mild assumptions. More details can be referred from (Lozano et al.,
2013).
14
Published as a conference paper at ICLR 2021
A.6 Experimental Details
Early Stopping on AdaGCN. We apply the same early stopping mechanism across all the methods as (Klicpera
et al., 2018) for fair comparison. Furthermore, boosting theory also has the capacity to perfectly incorporate
early stopping and it has been shown that for several boosting algorithms including AdaBoost, this regulariza-
tion via early stopping can provide guarantees of consistency (Zhang et al., 2005; Jiang et al., 2004; Buhlmann
& Yu, 2003).
Dataset Splitting. We choose a training set of a fixed nodes per class, an early stopping set of 500 nodes and
test set of remained nodes. Each experiment is run with 5 random initialization on each data split, leading
to a total of 100 runs per experiment. On a standard setting, we randomly select 20 nodes per class. For the
two different label rates on each graph, we select 6, 11 nodes per class on citeseer, 8, 16 nodes per class on
Cora-ML, 7, 14 nodes per class on Pubmed and 8, 15 nodes per class on MS-Academic dataset.
Model parameters. For all GCN-based approaches, we use the same hyper-parameters in the original paper:
learning rate of 0.01, 0.5 dropout rate, 5 × 10-4 L2 regularization weight, and 16 hidden units. For FastGCN,
we adopt the officially released code to conduct our experiments. PPNP and APPNP are adapted with best
setting: K = 10 power iteration steps for APPNP, teleport probability γ = 0.1 on Cora-ML, Citeseer and
Pubmed, γ = 0.2 on Ms-Academic. In addition, we use two layers with h = 64 hidden units and apply L2
regularization with λ = 5 × 10-3 on the weights of the first layer and use dropout with dropout rate d = 0.5
on both layers and the adjacency matrix. The early stopping criterion uses a patience of p = 100 and an
(unreachably high) maximum of n = 10000 epochs.The implementation of AdaGCN is adapted from PPNP
and APPNP. Corresponding patience p = 300 and n = 500 in the early stopping of AdaGCN. Moreover, SGC
is re-implemented in a straightforward way without incorporating advanced optimization for better illustration
and comparison. Other baselines are adopted the same parameters described in PPNP and APPNP.
Settings on Reddit dataset. By repeatedly tuning the parameters of these typical methods on Reddit, we finally
choose weight decay rate as 10-4, hidden layer size 100 and epoch 20000 for AdaGCN. For APPNP, we opt
weight decay rate as 10-5, dropout rate as 0 and epoch 500. V.GCN applies the same parameters in (Kipf
& Welling, 2017) and we choose epoch as 500. All approaches have not deployed early stopping due to the
expensive computational cost on the large Reddit dataset, which is also a fair comparison.
A.7 Choice of the Number of Layers
Different from the “forcible” behaviors in CNNs that directly stack many convolution layers, in our AdaGCN
there is a theoretical guidance on the choice of model depth L, i.e., the number of base classifiers or layers,
derived from boosting theory. Specifically, according to the boosting theory, the increasing of L can expo-
nentially decreases the empirical loss, however, from the perspective of VC-dimension, an overly large L can
yield overfitting of AdaGCN. It should be noted that the deeper graph convolution layers in AdaGCN are not
always better, which indeed heavily depends on the the complexity of data. In practice, L can be determined via
cross-validation. Specifically, we start a VC-dimension-based analysis to illustrate that too large L can yield
overfitting of AdaGCN. For L layers of AdaGCN, its hypothesis set is
: α(l) ∈ R, l ∈ [1, L]
(11)
Then the VC-dimension of FT can be bounded as follows in terms of the VC-dimension d of the family of base
hypothesis:
VCdim (FL) ≤ 2(d+ 1)(L + 1) log2((L + 1)e),	(12)
where e is a constant and the upper bounds grows as L increases. Combined with VC-dimension generalization
bounds, these results imply that larger values of L can lead to overfitting of AdaBoost. This situation also
happens in AdaGCN, which inspires us that there is no need to stack too many layers on AdaGCN in order to
avoid overfitting. In practice, L is typically determined via cross-validation.
15