Hopfield Networks is All You Need
Hubert Ramsauer* Bernhard Schafl* Johannes Lehner* Philipp Seidl*
Michael Widrich* Thomas Adler* Lukas Gruber* Markus Holzleitner*
David Kreilt Michael Koppt Gunter Klambauer* Johannes Brandstetter*
Sepp Hochreiter*,t
* ELLIS Unit Linz, LIT AI Lab, Institute for Machine Learning,
Johannes Kepler University Linz, Austria
t Institute of Advanced Research in Artificial Intelligence (IARAI)
Email: {ramsauer,schaefl,brandstetter,hochreit}@ml.jku.at
Ab stract
We introduce a modern Hopfield network with continuous states and a correspond-
ing update rule. The new Hopfield network can store exponentially (with the
dimension of the associative space) many patterns, retrieves the pattern with one
update, and has exponentially small retrieval errors. It has three types of energy
minima (fixed points of the update): (1) global fixed point averaging over all pat-
terns, (2) metastable states averaging over a subset of patterns, and (3) fixed points
which store a single pattern. The new update rule is equivalent to the attention
mechanism used in transformers. This equivalence enables a characterization of
the heads of transformer models. These heads perform in the first layers preferably
global averaging and in higher layers partial averaging via metastable states. The
new modern Hopfield network can be integrated into deep learning architectures
as layers to allow the storage of and access to raw input data, intermediate results,
or learned prototypes. These Hopfield layers enable new ways of deep learning,
beyond fully-connected, convolutional, or recurrent networks, and provide pooling,
memory, association, and attention mechanisms. We demonstrate the broad appli-
cability of the Hopfield layers across various domains. Hopfield layers improved
state-of-the-art on three out of four considered multiple instance learning problems
as well as on immune repertoire classification with several hundreds of thousands
of instances. On the UCI benchmark collections of small classification tasks, where
deep learning methods typically struggle, Hopfield layers yielded a new state-of-
the-art when compared to different machine learning methods. Finally, Hopfield
layers achieved state-of-the-art on two drug design datasets. The implementation is
available at: https://github.com/ml-jku/hopfield-layers
1	Introduction
The deep learning community has been looking for alternatives to recurrent neural networks (RNNs)
for storing information. For example, linear memory networks use a linear autoencoder for sequences
as a memory (Carta et al., 2020). Additional memories for RNNs like holographic reduced represen-
tations (Danihelka et al., 2016), tensor product representations (Schlag & Schmidhuber, 2018; Schlag
et al., 2019) and classical associative memories (extended to fast weight approaches) (Schmidhuber,
1992; Ba et al., 2016a;b; Zhang & Zhou, 2017; Schlag et al., 2021) have been suggested. Most
approaches to new memories are based on attention. The neural Turing machine (NTM) is equipped
with an external memory and an attention process (Graves et al., 2014). Memory networks (Weston
et al., 2014) use an arg max attention by first mapping a query and patterns into a space and then
retrieving the pattern with the largest dot product. End to end memory networks (EMN) make this
attention scheme differentiable by replacing arg max through a softmax (Sukhbaatar et al., 2015a;b).
EMN with dot products became very popular and implement a key-value attention (Daniluk et al.,
2017) for self-attention. An enhancement of EMN is the transformer (Vaswani et al., 2017a;b) and its
1
extensions (Dehghani et al., 2018). The transformer has had a great impact on the natural language
processing (NLP) community, in particular via the BERT models (Devlin et al., 2018; 2019).
Contribution of this work: (i) introducing novel deep learning layers that are equipped with a
memory via modern Hopfield networks, (ii) introducing a novel energy function and a novel update
rule for continuous modern Hopfield networks that are differentiable and typically retrieve patterns
after one update. Differentiability is required for gradient descent parameter updates and retrieval
with one update is compatible with activating the layers of deep networks.
We suggest using modern Hopfield networks to store information or learned prototypes in different
layers of neural networks. Binary Hopfield networks were introduced as associative memories
that can store and retrieve patterns (Hopfield, 1982). A query pattern can retrieve the pattern to
which it is most similar or an average over similar patterns. Hopfield networks seem to be an ancient
technique, however, new energy functions improved their properties. The stability of spurious states or
metastable states was sensibly reduced (Barra et al., 2018). The largest and most impactful successes
are reported on increasing the storage capacity of Hopfield networks. In a d-dimensional space, the
standard Hopfield model can store d uncorrelated patterns without errors but only Cd/ log(d) random
patterns with C < 1/2 for a fixed stable pattern or C < 1/4 if all patterns are stable (McEliece et al.,
1987). The same bound holds for nonlinear learning rules (Mazza, 1997). Using tricks-of-trade and
allowing small retrieval errors, the storage capacity is about 0.138d (Crisanti et al., 1986; Hertz et al.,
1991; Torres et al., 2002). If the learning rule is not related to the Hebb rule, then up to d patterns can
be stored (Abu-Mostafa & StJacques, 1985). For Hopfield networks with non-zero diagonal matrices,
the storage can be increased to Cd log(d) (Folli et al., 2017). In contrast to the storage capacity, the
number of energy minima (spurious states, stable states) of Hopfield networks is exponential in d
(Tanaka & Edwards, 1980; Bruck & Roychowdhury, 1990; Wainrib & Touboul, 2013).
The standard binary Hopfield network has an energy function that can be expressed as the sum of
interaction functions F with F (x) = x2 . Modern Hopfield networks, also called “dense associative
memory” (DAM) models, use an energy function with interaction functions of the form F (x) = xn
and, thereby, achieve a storage capacity proportional to dn-1 (Krotov & Hopfield, 2016; 2018). The
energy function of modern Hopfield networks makes them robust against adversarial attacks (Krotov
& Hopfield, 2018). Modern binary Hopfield networks with energy functions based on interaction
functions of the form F(x) = exp(x) even lead to storage capacity of 2d/2, where all stored binary
patterns are fixed points but the radius of attraction vanishes (Demircigil et al., 2017). However, in
order to integrate Hopfield networks into deep learning architectures, it is necessary to make them
differentiable, that is, we require continuous Hopfield networks (Hopfield, 1984; Koiran, 1994).
Therefore, we generalize the energy function of Demircigil et al. (2017) that builds on exponential
interaction functions to continuous patterns and states and obtain a new modern Hopfield network.
We also propose a new update rule which ensures global convergence to stationary points of the
energy (local minima or saddle points). We prove that our new modern Hopfield network typically
retrieves patterns in one update step (-close to the fixed point) with an exponentially low error
and has a storage capacity proportional to Cd-1 (reasonable settings for C = 1.37 and C = 3.15 are
given in Theorem 3). The retrieval of patterns with one update is important to integrate Hopfield
networks in deep learning architectures, where layers are activated only once. Surprisingly, our new
update rule is also the key-value attention as used in transformer and BERT models (see Fig. 1). Our
modern Hopfield networks can be integrated as a new layer in deep learning architectures for pooling,
memory, prototype learning, and attention. We test these new layers on different benchmark datasets
and tasks like immune repertoire classification.
Figure 1: We generalize the energy of binary modern Hopfield networks to continuous states while
keeping fast convergence and storage capacity properties. We also propose a new update rule that
minimizes the energy. The new update rule is the attention mechanism of the transformer. Formulae
are modified to express softmax as row vector. “=”-sign means “keeps the properties”.
2
2	Modern Hopfield Nets with Continuous States
New energy function for continuous state Hopfield networks. In order to integrate modern
Hopfield networks into deep learning architectures, we have to make them continuous. To allow for
continuous states, we propose a new energy function that is a modification of the energy of modern
Hopfield networks (Demircigil et al., 2017). We also propose a new update rule which can be proven
to converge to stationary points of the energy (local minima or saddle points).
We have N stored (key) patterns xi ∈ Rd represented by the matrix X = (x1, . . . , xN) with the
largest pattern M = maxi kxi k. The state (query) pattern is ξ ∈ Rd . For exponential interaction
functions, we need the log-sum-exp function (lse) for 0 < β
lse(β, x) = β-1 log X exp(βxi)	,	(1)
which is convex (see appendix Eq. (461), and Lemma A22). The energy function E of the modern
Hopfield networks for binary patterns Xi and a binary state pattern ξ is E= - PN=I F (ξτXi)
(Krotov & Hopfield, 2016). Here, F (x) = xn is the interaction function, where n = 2 gives the
classical Hopfield network. The storage capacity is proportional to dn-1 (Krotov & Hopfield, 2016).
This model was generalized by Demircigil et al. (2017) to exponential interaction functions F(x) =
exp(x) which gives the energy E = - exp(lse(1, XTξ)). This energy leads to an exponential
storage capacity of N = 2d/2 for binary patterns. Furthermore, with a single update, the fixed point
is recovered with high probability for random patterns. However, still this modern Hopfield network
has binary states.
We generalize this energy function to continuous-valued patterns while keeping the properties of the
modern Hopfield networks like the exponential storage capacity and the extremely fast convergence
(see Fig. 1). For the new energy we take the logarithm of the negative energy of modern Hopfield
networks and add a quadratic term of the current state. The quadratic term ensures that the norm
of the state vector ξ remains finite and the energy is bounded. Classical Hopfield networks do not
require to bound the norm of their state vector, since it is binary and has fixed length. We define the
novel energy function E as
E = - lse(β, XTξ) + 2ξTξ + β-1 log N + 2M2 .	⑵
We have 0 6 E 6 2M2 (see appendix Lemma A1). Using p = softmax(βXT ξ), we define a novel
update rule (see Fig. 1):
ξnew = f (ξ) = Xp = Xsoftmax(βXTξ) .	(3)
The next theorem states that the update rule Eq. (3) converges globally. The proof uses the Concave-
Convex Procedure (CCCP) (Yuille & Rangarajan, 2002; 2003), which is equivalent to Legendre
minimization (Rangarajan et al., 1996; 1999) algorithms (Yuille & Rangarajan, 2003).
Theorem 1.	The update rule Eq. (3) converges globally: For ξt+1 = f(ξt), the energy E(ξt) →
E(ξ*) for t → ∞ and a fixed point ξ*.
Proof. The update rule in Eq. (3) is the CCCP for minimizing the energy E, which is the sum of
the convex 1∕2ξTξ and concave -lse (see details in appendix Theorem 1). Theorem 2 in YUille &
Rangarajan (2002) yields the global convergence property. Also, in Theorem 2 in Sriperumbudur &
Lanckriet (2009) the global convergence of CCCP is proven via a rigoroUs analysis Using Zangwill’s
global convergence theory of iterative algorithms.	□
The global convergence theorem only assures that for the energy E(ξt) → E(ξ*) for t → ∞ but not
ξt → ξ. The next theorem strengthens Zangwill,s global convergence theorem (Meyer, 1976) and
gives convergence results similar to those known for expectation maximization (Wu, 1983).
Theorem 2.	For the iteration Eq. (3) we have E (ξt) → E (ξ*) = E* as t → ∞, for some
Stationary point ξ. Furthermore, ∣∣ξt+1 — ξ[∣ → 0 and either {ξt}∞=0 converges or in the
other case, the set of limit points of {ξt}∞=° is a connected and compact subset of L (E*), where
L (a) = {ξ ∈ L | E (ξ) = a} and L is the set ofstationary points ofthe iteration Eq. (3). If L (E*) is
finite, then any sequence {ξt}∞=o generated by the iteration Eq. (3) converges to some ξ* ∈ L (E*).
3
For a proof, see appendix Theorem 2. Therefore, all the limit points of any sequence generated by the
iteration Eq. (3) are stationary points (local minima or saddle points) of the energy function E. Either
the iteration converges or, otherwise, the set of limit points is a connected and compact set.
The next theorem gives the results on the storage capacity of our new continuous state modern
Hopfield network. We first define what we mean by storing and retrieving patterns using a modern
Hopfield network with continuous states.
Definition 1 (Pattern Stored and Retrieved). We assume that around every pattern xi a sphere Si is
given. We say Xi is stored ifthere is a single fixed point x* ∈ Si to which all points ξ ∈ Si converge,
and Si ∩ Sj = 0 for i = j. We say Xi is retrieved for a given e ifiteration (update rule) Eq. (3) gives
a point Xi that is at least e -close to the single fixed point x* ∈ Si. The retrieval error is kxi 一 xik.
As with classical Hopfield networks, we consider patterns on the sphere, i.e. patterns with a fixed
norm. For randomly chosen patterns, the number of patterns that can be stored is exponential in the
dimension d of the space of the patterns (Xi ∈ Rd).
Theorem 3. We assume a failure probability 0 < p 6 1 and randomly chosen patterns on the
sphere with radius M := KId — 1. We define a := d—ι(1 + ln(2βK2p(d - 1))), b := 2K β, and
C := Wo (eχpb+in(b)), where W° is the upper branch ofthe Lambert W function (Olver et al., 2010,
4
(4.13)), and ensure C ≥ (√2ρ) - ɪ. Then with probability 1 — P, the number ofrandom patterns that
can be stored is
一 d-1
N ≥ √pcF ∙	(4)
Therefore it is proven for C ≥ 3.1546 with β = 1, K = 3, d = 20 andp = 0.001 (a + ln(b) > 1.27)
and proven for C ≥ 1∙3718 with β = 1, K = 1, d = 75, andp = 0∙001 (a + ln(b) < -0∙94).
For a proof, see appendix Theorem A5.
The next theorem states that the update rule typically retrieves patterns after one update. Retrieval
of a pattern Xi for fixed point Xi* and query ξ is defined via an e by kf (ξ) - Xi*k < e, that is, the
update is e-close to the fixed point. Retrieval with one update is crucial to integrate modern Hopfield
networks into deep learning architectures, where layers are activated only once. First we need the
concept of separation of a pattern. For pattern Xi we define its separation ∆i to other patterns by:
∆i := min XiT Xi - XiT Xj = XiT Xi - max XiT Xj ∙	(5)
j,j 6=i	i	i	i	j,j6=i i
The update rule retrieves patterns with one update for well separated patterns, that is, patterns with
large ∆i .
Theorem 4. With query ξ, after one update the distance of the new point f(ξ) to the fixed point Xi*
is exponentially small in the separation ∆%. The precise bounds using the Jacobian J = fξ) and its
value Jm in the mean value theorem are:
kf(ξ) - Xi*k 6 kJmk2 kξ - Xi*k ,	(6)
kJmk2 6 2 β N M2 (N - 1) exp(- β (∆i - 2 max{kξ - Xik, kXi* - Xik} M)) ∙
(7)
For given e and sufficient large ∆i, we have kf (ξ) - Xi*k < e, that is, retrieval with one update.
See proof in appendix Theorem A8.
At the same time, the retrieval error decreases exponentially with the separation ∆i .
Theorem 5 (Exponentially Small Retrieval Error). The retrieval error kf (ξ) - Xik of pattern Xi is
bounded by
kf (ξ) - Xik 6 2 (N - 1) exp(- β (∆i - 2 max{kξ - Xik, kXi* - Xik} M)) M (8)
andfor ∣∣Xi - x*k 6 11M together with ∣∣Xi - ξk 6 3M by
kXi - Xi* k 6 2 e (N - 1) M exp(- β ∆i) ∙	(9)
See proof in appendix Theorem A9.
4
Metastable states and one global fixed point. So far, we considered patterns xi that are well
separated and the iteration converges to a fixed point which is near a pattern xi . If no pattern
xi is well separated from the others, then the iteration converges to a global fixed point close to
the arithmetic mean of the vectors. In this case the softmax vector p is close to uniform, that is,
pi = 1/N . If some vectors are similar to each other and well separated from all other vectors, then a
metastable state near the similar vectors exists. Iterations that start near the metastable state converge
to this metastable state, also if initialized by one of the similar patterns. For convergence proofs to one
global fixed point and to metastable states see appendix Lemma A7 and Lemma A12, respectively.
Hopfield update rule is attention of the transformer. The Hopfield network update rule is the
attention mechanism used in transformer and BERT models (see Fig. 1). To see this, we assume
N stored (key) patterns yi and S state (query) patterns ri that are mapped to the Hopfield space of
dimension dk. We set xi = WKTyi, ξi = WQTri, and multiply the result of our update rule with WV .
The matrices Y = (y1, . . . , yN)T and R = (r1, . . . , rS)T combine the yi and ri as row vectors.
We define the matrices XT = K = YWK, ΞT = Q = RWq, and V = YWK WV = XT WV,
where WK ∈ Rdy ×dk, WQ ∈ Rdr ×dk, WV ∈ Rdk ×d. If β = 1∕√dk and Softmax ∈ RN is
changed to a row vector, we obtain for the update rule Eq. (3) multiplied by WV :
Z = SoftmaX(1/Pdk Q KT) V = SoftmaX (β R WQ WK YT) Y WK WV .	(10)
The left part of Eq. (10) is the transformer attention. In the transformer self-attention R = Y, and
WKWV replaced by just WV. Besides the attention mechanism, Hopfield networks allow for other
functionalities in deep network architectures, which we introduce via specific layers in the next
section. The right part of Eq. (10) serves to explain these specific layers.
3	New Hopfield Layers for Deep Learning
Modern Hopfield networks with continuous states can be integrated into deep learning architectures,
because they are continuous and differentiable with respect to their parameters. Furthermore, they
typically retrieve patterns with one update, which is conform to deep learning layers that are activated
only once. For these two reasons, modern Hopfield networks can serve as specialized layers in
deep networks to equip them with memories. Below, we introduce three types of Hopfield layers:
Hopfield, HopfieldPooling, and HopfieldLayer. Possible applications of Hopfield
layers in deep network architectures comprise:
•	multiple instance learning (MIL) (Dietterich et al., 1997),
•	processing of and learning with point sets (Qi et al., 2017a;b; Xu et al., 2018),
•	set-based and permutation invariant learning (Guttenberg et al., 2016; Ravanbakhsh et al.,
2016; Zaheer et al., 2017; Korshunova et al., 2018; Ilse et al., 2018; Zhai et al., 2020),
•	attention-based learning (Vaswani et al., 2017a),
•	deep learning with associative memories (Graves et al., 2014; Weston et al., 2014; Ba et al.,
2016a;b; Schlag & Schmidhuber, 2018; Schlag et al., 2019),
•	natural language processing (Devlin et al., 2018; 2019),
•	sequence analysis and time series prediction (Hochreiter, 1991; Hochreiter & Schmidhuber,
1997; Cho et al., 2014), and
•	storing and retrieving reference data, e.g. the training data, outliers, high error data points,
prototypes or cluster centers, support vectors & border cases.
Hopfield network layers can substitute existing layers like pooling layers, permutation equivariant
layers (Guttenberg et al., 2016; Ravanbakhsh et al., 2016), GRU (Cho et al., 2014) & LSTM
(Hochreiter, 1991; Hochreiter & Schmidhuber, 1997) layers, and attention layers (Vaswani et al.,
2017a;b; Bahdanau et al., 2014).
5
Types of neural networks. We consider two types of feed-
forward neural networks: (I) Neural networks that propagate an
activation vector from the input layer to the output layer. Exam-
ples are fully-connected or convolutional neural networks. (II)
Neural networks that propagate a set of vectors from the input
layer to the output layer, where each layer applies the same
operation to each element of the set and the output layer may
summarize the set via a vector. An example is the transformer.
Recurrent neural networks are networks of type (I), which are
iteratively applied to a set or a sequence, where intermediate
results are stored in a memory and can be reused. Modern
Hopfield networks can be integrated into both types of neural
network architectures and enable to equip each of their layers
with associative memories. See Fig. 2.
Types of new Hopfield layers. We introduce three types
of Hopfield layers: Hopfield, HopfieldPooling, and
HopfieldLayer. The continuous modern Hopfield network
results in a plethora of new deep learning architectures, since we
can (a) propagate sets or single vectors, (b) propagate queries,
Figure 2: Left: A standard deep
network with layers () propagates
either a vector or a set of vectors
from the input to the output. Right:
A deep network, where layers ()
are equipped with associative mem-
ories via Hopfield layers ().
stored patterns, or both, (c) learn static queries or stored patterns, (d) fill the memory by training
sets, prototypes, or external data. Next, we provide three useful types of Hopfield layers. The
implementation is available at: https://github.com/ml-jku/hopfield-layers
(1)	Layer Hopfield for networks that propagate sets of vectors via state (query) patterns R
and stored (key) patterns Y . The layer Hopfield is the realization of formula (10). The memory
of the Hopfield layer can be filled with sets from the input or previous layers, see Fig. 3. The
memory may be filled with a reference set, which is covered by providing the reference set as
additional input. Thus, the layer Hopfield allows the association of two sets. A prominent example
of a layer that performs such association is the transformer attention mechanism, which associates
keys and queries, e.g. two point sets that have to be compared. This layer allows for different kinds
of sequence-to-sequence learning, point set operations, and retrieval-based methods. The layer
Hopfield with skip connections in a ResNet architecture is identical to the popular transformer and
BERT models. In the experiments, we analyzed these Hopfield layers in transformer architectures.
In our experiments in which we compare machine learning methods on small datasets of the UCI
benchmark collection the layer Hopfield is also used.
Z = SoftmaX(夕 R WQ Wl Yτ) Y WV
=Soltmax( ∣-^
Z
R

Figure 3: The layer Hopfield allows the association of two sets R () and Y (). It can be
integrated into deep networks that propagate sets of vectors. The Hopfield memory is filled with a set
from either the input or previous layers. The output is a set of vectors Z ().
(2)	Layer HopfieldPooling for networks that propagate patterns via the stored (key) patterns
Y . This layer performs a pooling or summarization of sets Y obtained from queries in previous
layers or the input. The memory of the HopfieldPooling layer is filled with sets from the input
or previous layers. The HopfieldPooling layer uses the queries to search for patterns in the
memory, the stored set. If more patterns are similar to a particular search pattern (query), then the
result is an average over these patterns. The state (query) patterns of each layer are static and can be
learned. Multiple queries supply a set to the next layer, where each query corresponds to one element
of the set. Thus, the layer HopfieldPooling enables fixed pattern search, pooling operations,
and memories like LSTMs or GRUs. The static pattern functionality is typically needed if particular
patterns must be identified in the data.
A single HopfieldPooling layer allows for multiple instance learning. Static state (query)
6
patterns together with position encoding in the keys allows for performing pooling operations. The
position encoding can be two-dimensional, where standard convolutional filters can be constructed as
in convolutional neural networks (CNNs). The HopfieldPooling layer can substitute pooling,
averaging, LSTM, and permutation equivariant layers. See Fig. 4. The layer HopfieldPooling
is used for experiments with multiple instance learning tasks, e.g. for immune repertoire classification
in the experiments.
==SoltmaX(P Q Yτ) Y WV
■ = Softmax(■■的；)面 目
Figure 4: The layer HopfieldPooling enables pooling or summarization of sets, which are
obtained from the input or from previous layers. The input Y () can be either a set or a sequence.
The query patterns of each layer are static and can be learned. The output is a set of vectors Z (),
where the number of vectors equals the number of query patterns. The layer HopfieldPooling
can realize multiple instance learning.
(3)	Layer HopfieldLayer for networks that propagate a vector or a set of vectors via state
(query) patterns R. The queries R can be input vectors or queries that are computed from the
output of previous layers. The memory of the HopfieldLayer layer is filled with a fixed set,
which can be the training set, a reference set, prototype set, or a learned set (a learned matrix). The
stored (key) patterns are static and can be learned. If the training set is stored in the memory, then
each layer constructs a new set of queries based on the query results of previous layers. The stored
patterns can be initialized by the training set or a reference set and then learned, in which case they
deviate from the training set. The stored patterns can be interpreted as weights from the state (query)
to hidden neurons that have a softmax activation function (Krotov & Hopfield, 2020). The layer
HopfieldLayer can substitute a fully connected layer, see Fig. 5. A single HopfieldLayer
layer also allows for approaches similar to support vector machines (SVMs), approaches similar
to k-nearest neighbor, approaches similar to learning vector quantization, and pattern search. For
classification, the raw data yi = (zi, ti) can be the concatenation of input zi and target ti. In this
case, the matrices WK and WV can be designed such that inside the softmax the input zi is used
and outside the softmax the target ti . Thus, the softmax provides a weighted average of the target
vectors based on the similarity between the query and the inputs. Also SVM models, k-nearest
neighbor, and learning vector quantization can be considered as weighted averages of the targets.
The encoder-decoder attention layer of the transformers are a HopfieldLayer layer, where the
memory is filled with the encoder output set. In our experiments with the drug design benchmark
datasets, the layer HopfieldLayer has been applied and compared to other machine learning
methods.
Figure 5: The layer HopfieldLayer enables multiple queries of the training set, a reference
set, prototype set, or a learned set (a learned matrix). The queries for each layer are computed
from the results of previous layers. The input is a set of vectors R (). The output is also a set of
vectors Z (), where the number of output vectors equals the number of input vectors. The layer
HopfieldLayer can realize SVM models, k-nearest neighbor, and LVQ.
Additional functionality of new Hopfield layers. The insights about energy, convergence, and
storage properties provide all new Hopfield layers with additional functionalities: i) multiple updates
7
to control how precise fixed points are found without additional parameters needed. ii) variable β
to determine the kind of fixed points such as the size of metastable states. The variable β controls
over how many patterns is averaged. As observed in the experiments, the variable is relevant in
combination with the learning rate to steer the learning dynamics. The parameter β governs the fixed
point dynamics and can be learned, too. iii) controlling the storage capacity via the dimension of the
associative space. The storage capacity can be relevant for tasks with a huge number of instances
as in the immune repertoire classification experiment. iv) pattern normalization controls, like the
layernorm, the fixed point dynamics by the norm and shift of the patterns. For more details see
appendix, Section A.6.
4	Experiments
We show that our proposed Hopfield layers can be applied successfully to a wide range of tasks. The
tasks are from natural language processing, contain multiple instance learning problems, a collection
of small classification tasks, and drug design problems.
Analysis of transformer and BERT models. Transformer and BERT models can be implemented
by the layer Hopfield. The kind of fixed point of the Hopfield net is determined by how the
pattern xi is separated from others patterns. (a) a global fixed point: no separation of a pattern from
the others, (b) a fixed point close to a single pattern: pattern is separated from other patterns, (c)
metastable state: some patterns are similar to each other and well separated from all other vectors. We
observed that the attention heads of transformer and BERT models are predominantly in metastable
states, which are categorized into four classes: (I) averaging over a very large number of patterns
(very large metastable state or fixed point (a)), (II) averaging over a large number of patterns (large
metastable state), (III) averaging over a medium number of patterns (medium metastable state), (IV)
averaging over a small number of patterns (small metastable state or fixed point (c)). For analyzing the
metastable states, we calculated the minimal number k of softmax values required to sum up to 0.90.
Hence, k indicates the size of a metastable state. To determine in which of the four classes a head
is mainly operating, we computed the distribution of k across sequences. Concretely, for N tokens
and for k as the median of the distribution, a head is classified as operating in class (I) if 1/2N ‹ k,
as operating in class (II) if 1/8N < k 6 1/2N, as operating in class (III) if 1/32N < k 6 1/8N,
and as operating in class (IV) if kk 6 1/32N. We analyzed pre-trained BERT models from Hugging
Face Inc. (Wolf et al., 2019) according to these operating classes. In Fig. A.3 in the appendix the
distribution of the pre-trained bert-base-cased model is depicted (for other models see appendix
Section A.5.1.4). Operating classes (II) (large metastable states) and (IV) (small metastable states)
are often observed in the middle layers. Operating class (I) (averaging over a very large number
of patterns) is abundant in lower layers. Similar observations have been reported in other studies
(Toneva & Wehbe, 2019a;b; Tay et al., 2020). Operating class (III) (medium metastable states) is
predominant in the last layers.
Multiple Instance Learning Datasets. For multiple instance learning (MIL) (Dietterich et al.,
1997), we integrate our new Hopfield network via the layer HopfieldPooling into deep learning
architectures. Recently, deep learning methods have been applied to MIL problems (Ilse et al., 2018),
but still the performance on many datasets lacks improvement. Thus, MIL datasets still pose an
interesting challenge, in which Hopfield layers equipped with memory are a promising approach.
•Immune Repertoire Classification. The first MIL task is immune repertoire classification, where a
deep learning architecture with HopfieldPooling (DeepRC) was used (Widrich et al., 2020a;b).
Immune repertoire classification (Emerson et al., 2017) typically requires to extract few patterns
from a large set of sequences, the repertoire, that are indicative for the respective immune status.
The datasets contain ≈ 300,000 instances per immune repertoire, which represents one of the largest
multiple instance learning experiments ever conducted (Carbonneau et al., 2018). Most MIL methods
fail due the large number of instances. This experiment comprises real-world and simulated datasets.
Simulated datasets are generated by implanting sequence motifs (Akbar et al., 2019; Weber et al.,
2020) with low frequency into simulated or experimentally-observed immune receptor sequences.
The performance of DeepRC was compared with other machine learning methods: (i) known motif,
(ii) SVM using k-mers and MinMax or Jaccard kernel, (iii) K-Nearest Neighbor (KNN) with k-
mers, (iv) logistic regression with k-mers, (v) burden test with k-mers, and (vi) logistic multiple
8
Method	tiger	fox	elephant	UCSB
Hopfield (ours)	91.3 ± 0.5	64.05 ± 0.4	94.9 ± 0.3	89.5 ± 0.8
Path encoding ( KUgUkaSCI & Baydogan, 2018)	91.0 ± 1.0a	71.2 ± 1.4a	94.4 ± 0.7a	88.0 ± 2.2a
MInD (Cheplygina et al., 2016)	85.3 ± 1.1a	70.4 ± 1.6a	93.6 ± 0.9a	83.1 ± 2.7a
MILES (Chen et al., 2006)	87.2 ± 1.7b	73.8 ± 1.6a	92.7 ± 0.7a	83.3 ± 2.6a
APR (Dietterich et al., 1997)	77.8 ± 0.7b	54.1 ± 0.9b	55.0 ± 1.0b	—
Citation-kNN (Wang, 2000)	85.5 ± 0.9b	63.5 ± 1.5b	89.6 ± 0.9b	70.6 ± 3.2a
DD (Maron & Lozano-Perez, 1998)	84.1b	63.1b	90.7b	—
Table 1: Results for MIL datasets Tiger, Fox, Elephant, and UCSB Breast Cancer in terms of AUC. Results
for all methods except the first are taken from either a( KUgUkaScI & Baydogan, 201 ) or b( Carbonneau et al.,
2016), depending on which reports the higher AUC.
instance learning (lMIL). On the real-world dataset DeepRC achieved an AUC of 0.832 ± 0.022,
followed by the SVM with MinMax kernel (AUC 0.825 ± 0.022) and the burden test with an AUC
of 0.699 ± 0.041. Across datasets, DeepRC outperformed all competing methods with respect to
average AUC (Widrich et al., 2020a;b).
•MIL benchmark datasets. We apply Hopfield layers to further MIL datasets (Ilse et al., 2018;
KUgUkaSCI & Baydogan, 2018; Cheplygina et al., 2016): Elephant, Fox and Tiger for image annotation
(Andrews et al., 2003). These datasets consist of color images from the Corel dataset that have been
preprocessed and segmented. An image consists of a set of segments (or blobs), each characterized by
color, texture and shape descriptors. The datasets have 100 positive and 100 negative example images.
The latter have been randomly drawn from a pool of photos of other animals. Elephant comprises
1,391 instances and 230 features, Fox 1,320 instances and 230 features, and Tiger has 1,220 instances
and 230 features. Furthermore, we use the UCSB breast cancer classification (Kandemir et al., 2014)
dataset, which consists of 2,002 instances across 58 input objects. An instance represents a patch of
a histopathological image of cancerous or normal tissue. The layer HopfieldPooling is used,
which allows for computing a per-input-object representation by extracting an average of instances
that are indicative for one of the two classes. The input to the layer HopfieldPooling is a set
of embedded instances Y . A trainable but fixed state (query) pattern Q is used for averaging over
class-indicative instances. This averaging enables a compression of variable-sized bags to a fixed-
sized representation to discriminate the bags. More details in appendix Sec. A.5.2. Our approach
has set a new state-of-the-art and has outperformed other methods ( KUgUkaSCI & Baydogar, 2018;
Carbonneau et al., 2016) on the datasets Tiger, Elephant and UCSB Breast Cancer (see Table 1).
UCI Benchmark Collection. So far deep learning struggled with small datasets. However, Hop-
field networks are promising for handling small datasets, sinCe they Can store the training data
points or their representations to perform similarity-based, nearest neighbor, or learning veCtor
quantization methods. Therefore, we test the Hopfield layer Hopfield on the small datasets
of the UC Irvine (UCI) MaChine Learning Repository that have been used to benChmark super-
vised learning methods (Ferndndez-Delgado et al., 2014; Wainberg et al., 2016; Khan et al., 2018)
and also feed-forward neural networks (Klambauer et al., 2017a; Wu et al., 2018), where our
Hopfield networks Could exploit their memory. The whole 121 datasets in the ColleCtion vary
strongly with respeCt to their size, number of features, and diffiCulties (Ferndndez-Delgado et al.,
2014), suCh that they have been divided into 75 “small datasets” with less than 1,000 samples
and 45 “large datasets” with more than or equal to 1,000 samples in Klambauer et al. (2017a).			
On the 75 small datasets, Random Forests (RFs) and Support Vector Machines (SVM) are highly	Method	avg. rank diff.	p-value
	Hopfield (ours)	-3.92	—
accurate, whereas on the large datasets, deep			
learning methods and neural networks are in	SVM	-3.23	0.15
the lead (Klambauer et al., 2017a;b; Wu et al.,	SNN	-2.85	0.10
2018). We applied a modern Hopfield network via the layer HopfieldLayer, where a self-	RandomForest ...	-2.79 ...	0.05 ...
normalizing net (SNN) maps the input vector to	Stacking	8.73	1.2e-11
Y and R. The output Z of HopfieldLayer
enters a softmax output. We Compared our mod- Table 2: Results on 75 small datasets of the UCI
ern Hopfield networks against deep learning benChmarks given as differenCe to average rank.
9
methods (e.g. SNNs, resnet), RFs, SVMs, boosting, bagging, and many other machine learning
methods of Femgndez-Delgado et al. (2014). Since for each method, multiple variants and imple-
mentations had been included, we used method groups and representatives as defined by Klambauer
et al. (2017a). For each dataset, a ranking of the methods was calculated which is presented in
Table 2. We found that Hopfield networks outperform all other methods on the small datasets, setting
a new state-of-the-art for 10 datasets. The difference is significant except for the first three runner-up
methods (Wilcoxon signed rank test). See appendix Section A.5.3 for details.
Drug Design Benchmark Datasets. We test the Hopfield layer HopfieldLayer, on four drug
design datasets. These datasets represent four main areas of modeling tasks in drug design, concretely
to develop accurate models for predicting a) new anti-virals (HIV) by the Drug Therapeutics Program
(DTP) AIDS Antiviral Screen, b) new protein inhibitors, concretely human β-secretase (BACE) in-
hibitors by Subramanian et al. (2016), c) metabolic effects as blood-brain barrier permeability (BBBP)
(Martins et al., 2012) and d) side effects of a chemical compound from the Side Effect Resource
(SIDER) Kuhn et al. (2016). We applied the Hopfield layer HopfieldLayer, where the training
data is used as stored patterns Y , the input vector as state pattern R, and the corresponding training
label to project the output of the Hopfield layer Y WV . Our architecture with HopfieldLayer has
reached state-of-the-art for predicting side effects on SIDER 0.672 ± 0.019 as well as for predicting
β-secretase BACE 0.902 ± 0.023. For details, see Table A.5 in the appendix.
Conclusion. We have introduced a modern Hopfield network with continuous states and the corre-
sponding new update rule. This network can store exponentially many patterns, retrieves patterns with
one update, and has exponentially small retrieval errors. We analyzed the attention heads of BERT
models. The new modern Hopfield networks have been integrated into deep learning architectures as
layers to allow the storage of and access to raw input data, intermediate results, or learned prototypes.
These Hopfield layers enable new ways of deep learning, beyond fully-connected, convolutional, or
recurrent networks, and provide pooling, memory, association, and attention mechanisms. Hopfield
layers that equip neural network layers with memories improved state-of-the-art in three out of four
considered multiple instance learning problems and on immune repertoire classification, and on two
drug design dataset. They yielded the best results among different machine learning methods on the
UCI benchmark collections of small classification tasks.
Acknowledgments
The ELLIS Unit Linz, the LIT AI Lab and the Institute for Machine Learning are supported by
the Land Oberosterreich, LIT grants DeepToxGen (LIT-2017-3-YOU-003), and AI-SNN (LIT-
2018-6-YOU-214), the Medical Cognitive Computing Center (MC3), Janssen Pharmaceutica, UCB
Biopharma, Merck Group, Audi.JKU Deep Learning Center, Audi Electronic Venture GmbH, TGW,
Primal, S3AI (FFG-872172), Silicon Austria Labs (SAL), Anyline, FILL, EnliteAI, Google Brain,
ZF Friedrichshafen AG, Robert Bosch GmbH, TUV Austria, DCS, and the NVIDIA Corporation.
IARAI is supported by Here Technologies.
10
A Appendix
This appendix consists of six sections (A.1-A.6). Section A.1 introduces the new modern Hopfield
network with continuous states and its update rule. Furthermore, Section A.1 provides a thorough and
profound theoretical analysis of this new Hopfield network. Section A.2 provides the mathematical
background for Section A.1. Section A.3 reviews binary Modern Hopfield Networks of Krotov
& Hopfield. Section A.4 shows that the Hopfield update rule is the attention mechanism of the
transformer. Section A.5 gives details on the experiments. Section A.6 describes the PyTorch
implementation of layers based on the new Hopfield networks and how to use them.
Contents of the appendix
A.1 Continuous State Modern Hopfield Networks (A New Concept) ...................... 12
A.1.1	Introduction ........................................................... 12
A.1.2	New Energy Function .................................................... 13
A.1.3	New Update Rule ........................................................ 15
A.1.4	Global Convergence of the Update Rule .................................. 16
A.1.5	Local Convergence of the Update Rule: Fixed Point Iteration ............ 19
A.1.6	Properties of Fixed Points Near Stored Pattern ......................... 44
A.1.7	Learning Associations .................................................. 57
A.1.8	Infinite Many Patterns and Forgetting Patterns ......................... 60
A.1.9	Number of Spurious States .............................................. 61
A.2 Properties of Softmax, Log-Sum-Exponential, Legendre Transform, Lambert W
Function ...................................................................... 62
A.3 Modern Hopfield Networks: Binary States (Krotov and Hopfield) .................. 70
A.3.1 Modern Hopfield Networks: Introduction .................................. 70
A.3.2 Energy and Update Rule for Binary Modern Hopfield Networks .............. 71
A.4 Hopfield Update Rule is Attention of The Transformer ........................... 73
A.5 Experiments .................................................................... 73
A.5.1	Experiment 1:	Attention in Transformers described by	Hopfield dynamics .	73
A.5.2	Experiment 2:	Multiple Instance Learning Datasets.	.......... 78
A.5.3	Experiment 3:	Classification on Small UCI Benchmark Datasets ........... 81
A.5.4	Experiment 4:	Drug Design Benchmark Datasets ........................... 83
A.6 PyTorch Implementation of Hopfield Layers ...................................... 84
A.6.1	Introduction ........................................................... 84
A.6.2	Functionality	.......................................................... 85
A.6.3	Usage .................................................................. 87
List of theorems
A1	Theorem	(Global Convergence (Zangwill): Energy) ............................. 16
A2	Theorem	(Global Convergence: Stationary Points) ............................. 18
A3	Theorem	(Storage Capacity (M=2): Placed Patterns) ........................... 46
11
A4	Theorem (Storage Capacity	(M=5): Placed Patterns) ............................ 47
A5	Theorem (Storage Capacity	(Main): Random Patterns) ........................... 49
A6	Theorem (Storage Capacity	(d computed): Random Patterns) ..................... 52
A7	Theorem (Storage Capacity	(expected separation): Random Patterns) ............ 55
A8	Theorem (Pattern Retrieval	with One Update) ................................... 56
A9 Theorem (Exponentially Small Retrieval Error) ................................... 57
A10 Theorem (Storage Capacity for Binary Modern Hopfield Nets (Demircigil et al. 2017)) 72
List of definitions
A1 Definition (Softmax) ............................................................ 62
A2 Definition (Log-Sum-Exp Function) ............................................... 62
A3 Definition (Convex Conjugate) ................................................... 66
A4 Definition (Legendre Transform) ................................................. 66
A5 Definition (Epi-Sum) ............................................................ 66
A6 Definition (Lambert Function) ................................................... 69
List of figures
A.1 The three cases of fixed points ................................................ 19
A.2 From binary Hopfield network to transformer .................................... 73
A.4 Ridge plots of the distribution of counts ...................................... 76
A.5 Change of count density during training ........................................ 77
A.6 Attentions of a Gaussian averaging heads ....................................... 78
A.7 A flowchart of the Hopfield layer .............................................. 88
List of tables
A.1	Results of immune repertoire	classification across all	datasets ............... 79
A.2	Hyperparameter selection for MIL datasets ..................................... 80
A.3	Hyperparameter selection for	small UCI benchmark datasets ..................... 82
A.4	Hyperparameter selection for	drug design datasets ............................. 83
A.5 Results on drug design benchmark datasets ...................................... 84
A. 1 Continuous State Modern Hopfield Networks (A New Concept)
A.1.1 Introduction
In Section A.1 our new modern Hopfield network is introduced. In Subsection A.1.2 we present
the new energy function. Then in Subsection A.1.3, our new update rule is introduced. In Subsec-
tion A.1.4, we show that this update rule ensures global convergence. We show that all the limit
points of any sequence generated by the update rule are the stationary points (local minima or saddle
points) of the energy function. In Section A.1.5, we consider the local convergence of the update rule
and see that patterns are retrieved with one update. In Subsection A.1.6, we consider the properties
of the fixed points that are associated with the stored patterns. In Subsection A.1.6.1, we show that
exponentially many patterns can be stored. The main result is given in Theorem A5: For random
12
patterns on a sphere we can store and retrieve exponentially (in the dimension of the Hopfield space)
many patterns. Subsection A.1.6.2 reports that patterns are typically retrieved with one update step
and that the retrieval error is exponentially small.
In Subsection A.1.7, we consider how associations for the new Hopfield networks can be learned.
In Subsection A.1.7.2, we analyze if the association is learned directly by a bilinear form. In
Subsection A.1.7.3, we analyze if stored patterns and query patterns are mapped to the space
of the Hopfield network. Therefore, we treat the architecture of the transformer and BERT. In
Subsection A.1.8, we introduce a temporal component into the new Hopfield network that leads to a
forgetting behavior. The forgetting allows us to treat infinite memory capacity in Subsection A.1.8.1.
In Subsection A.1.8.2, we consider the controlled forgetting behavior.
In Section A.2, we provide the mathematical background that is needed for our proofs. In particular
we give lemmas on properties of the softmax, the log-sum-exponential, the Legendre transform, and
the Lambert W function.
In Section A.3, we review the new Hopfield network as introduced by Krotov and Hopfield in 2016.
However in contrast to our new Hopfield network, the Hopfield network of Krotov and Hopfield is
binary, that is, a network with binary states. In Subsection A.3.1, we give an introduction to neural
networks equipped with associative memories and new Hopfield networks. In Subsection A.3.1.1,
we discuss neural networks that are enhanced by an additional external memory and by attention
mechanisms. In Subsection A.3.1.2, we give an overview over the modern Hopfield networks. Finally,
in Subsection A.3.2, we present the energy function and the update rule for the modern, binary
Hopfield networks.
A.1.2 New Energy Function
We have patterns x1 , . . . , xN that are represented by the matrix
X = (x1,...,xN) .	(11)
The largest norm of a pattern is
M = max kxik .	(12)
i
The query or state of the Hopfield network is ξ.
The energy function E in the new type of Hopfield models of Krotov and Hopfield is E =
-PN=ι F (ξτXi) for binary patterns Xi and binary state ξ with interaction function F(x) = xn,
where n = 2 gives classical Hopfield model (Krotov & Hopfield, 2016). The storage capacity is
proportional to dn-1 (Krotov & Hopfield, 2016). This model was generalized by Demircigil et
al. (Demircigil et al., 2017) to exponential interaction functions F(x) = exp(x), which gives the en-
ergy E = - exp(lse(1, XTξ)). This energy leads to an exponential storage capacity of N = 2d/2 for
binary patterns. Furthermore, with a single update the fixed point is recovered with high probability.
See more details in Section A.3.
In contrast to the these binary modern Hopfield networks, we focus on modern Hopfield networks
with continuous states that can store continuous patterns. We generalize the energy of Demircigil et
al. (Demircigil et al., 2017) to continuous states while keeping the lse properties which ensure high
storage capacity and fast convergence. Our new energy E for a continuous query or state ξ is defined
13
as
E = - lse(β, XTξ) + 1 ξτξ + βT ln N + 2M2
=— β-1 ln (X exp(βxTξ)) + β-1 ln N + 2ξTξ + 2M2
=-β-1ln (N Xeχp (- 1 β (M2 - kχik2)) eχp (- 2 β Ilxi - ξk2
(13)
(14)
(15)
First let us collect and prove some properties of E. The next lemma gives bounds on the energy E.
Lemma A1. The energy E is larger than zero:
0 6 E.	(16)
For ξ in the simplex defined by the patterns, the energy E is upper bounded by:
E 6 β T ln N + 1 M2 ,	(17)
E 6 2M2 .	(18)
Proof. We start by deriving the lower bound of zero. The pattern most similar to query or state ξis
xξ:
We obtain
xξ = xk , k = arg max ξTxi .
i
+ β-1 ln N + 1 ξτξ + 2 M2
(19)
(20)
=-β-1 ln(N∙ X eχp(βxTE)) + 2ξTξ + 1 M2
i=1
≥ - β-1ln (营 X exP(βxTE)) + 2 ξTξ + 2 xTxξ
≥ — β-1 ln (exp(βxTξ)) + 1ETE + 2 xTxξ
=-xTξ + 2 ξTξ + 2 xTxξ
=I(E — xξ )T(E — xξ) = 2 kξ - xξk2 ≥ 0.
The energy is zero and, therefore, the bound attained, if all xi are equal, that is, xi = x for all i and
E = x.
For deriving upper bounds on the energy E, we require the the query E to be in the simplex defined
by the patterns, that is,
NN
E =	pi	xi	,	pi	= 1 ,	∀i	: 0 6	pi	.
i=1	i=1
The first upper bound is.
E = - β-1 ln (X exp(βxTE)) + 2 ETE + βT ln N + 2 M2
(21)
(22)
N1	1
6 - XPi (XTE) + 2 ETE + β-1 ln N + 1 M2
=-1 ETE + β-1ln N + 2 M2 6 βTln N + | M2 .
14
For the first inequality we applied Lemma A19 to -lse(β, XTξ) with z = p giving
N	NN
- lse(β, XTξ) 6 - Xpi (xiT ξ) + β-1 Xpilnpi 6 - Xpi (xiT ξ) ,	(23)
i=1	i=1	i=1
as the term involving the logarithm is non-positive.
Next we derive the second upper bound, for which we need the mean mx of the patterns
1N
mx = N x x Xi .	(24)
i=1
We obtain
+ 1 ξτξ + β T ln N + 1 M 2	(25)
E = - β-1ln X exp(βxiT ξ)
i=1
=- mT ξ + 1 £Ι£ + 1 M 2
6 kmχkkξk + 1 kξk2 + 1 M2
6 2 M2 ,
where for the first inequality we again applied Lemma A19 with z = (1/N, . . . , 1/N) and
β-1 Pi 1/N ln(1/N) = -β-1 ln(N). This inequality also follows from Jensen’s inequality. The
second inequality uses the Cauchy-Schwarz inequality. The last inequality uses
kξk = pixi 6	pi kxi k 6	pi M = M	(26)
and
kmxk =	(1/N)xi 6	(1/N) kxik 6	(1/N) M = M.
(27)
□
A.1.3 New Update Rule
We now introduce an update rule for minimizing the energy function E. The new update rule is
ξnew = Xp = Xsoftmax(βXT ξ) ,	(28)
where we used
p = softmax(β X T ξ) .	(29)
The new state ξnew is in the simplex defined by the patterns, no matter what the previous state ξ was.
For comparison, the synchronous update rule for the classical Hopfield network with threshold zero is
ξnew = sgn (XXT ξ) .	(30)
Therefore, instead of using the vector XTξ as in the classical Hopfield network, its softmax version
softmax(βX T ξ) is used.
In the next section (Section A.1.4) we show that the update rule Eq. (28) ensures global convergence.
We show that all the limit points of any sequence generated by the update rule are the stationary
points (local minima or saddle points) of the energy function E. In Section A.1.5 we consider the
local convergence of the update rule Eq. (28) and see that patterns are retrieved with one update.
15
A.1.4 Global Convergence of the Update Rule
We are interested in the global convergence, that is, convergence from each initial point, of the
iteration
ξnew = f(ξ) = Xp = Xsoftmax(βXTξ) ,	(31)
where we used	p	= softmax(β X T ξ) .	(32)
We defined the energy function			
E=	- lse(β, XTξ) +	2 ξτξ + β-1ln N + 1 M2	(33)
=	:-β-iln (XXexp(βxTξ)) + β-ilnN + 2ξτξ + 2M2 .		(34)
We will show that the update rule in Eq. (31) is the Concave-Convex Procedure (CCCP) for minimiz-
ing the energy E. The CCCP is proven to converge globally.
Theorem A1 (Global Convergence (Zangwill): Energy). The update rule Eq. (31) converges globally:
For ξt+1 = f (ξt) ,the energy E(ξt) → E(ξ*) for t → ∞ and a fixed point ξ*.
Proof. The Concave-Convex Procedure (CCCP) (Yuille & Rangarajan, 2002; 2003) minimizes a
function that is the sum of a concave function and a convex function. CCCP is equivalent to Legendre
minimization (Rangarajan et al., 1996; 1999) algorithms (Yuille & Rangarajan, 2003). The Jacobian
of the softmax is positive semi-definite according to Lemma A22. The Jacobian of the softmax is
the Hessian of the lse, therefore lse is a convex and -lse a concave function. Therefore, the energy
function E(ξ) is the sum of the convex function Eι(ξ) = 1∕2ξTξ + Ci and the concave function
E2(ξ) = -lse:
E(ξ) = E1(ξ) + E2(ξ) ,	(35)
Eι(ξ) = 1 ξTξ + β-i ln N + 1M2 = 1 ξTξ + Ci ,	(36)
E2(ξ) = -lse(β,XTξ),	(37)
where Ci does not depend on ξ.
The Concave-Convex Procedure (CCCP) (Yuille & Rangarajan, 2002; 2003) applied to E is
VgEi (ξt+1) = - VξE2 (ξt) ,	(38)
which is
Vg (1 ξTξ + Ci) (ξt+1) = Vξlse(β, XTξt) .	(39)
The resulting update rule is
ξt+i = Xpt = Xsoftmax(βXTξt)	(40)
using
pt = softmax(βXTξt) .	(41)
This is the update rule in Eq. (31).
Theorem 2 in Yuille & Rangarajan (2002) and Theorem 2 in Yuille & Rangarajan (2003) state that
the update rule Eq. (31) is guaranteed to monotonically decrease the energy E as a function of time.
See also Theorem 2 in SriPerUmbUdur & Lanckriet (2009).	□
Although the objective converges in all cases, it does not necessarily converge to a local minimum
(LiPP & Boyd, 2016).
16
However the convergence proof of CCCP in Yuille & Rangarajan (2002; 2003) was not as rigorous as
required. In Sriperumbudur & Lanckriet (2009) a rigorous analysis of the convergence of CCCP is
performed using Zangwill’s global convergence theory of iterative algorithms.
In Sriperumbudur & Lanckriet (2009) the minimization problem
min E1 + E2	(42)
ξ
s.t. c(ξ) 6 0 , d(ξ) = 0
is considered with E1 convex, -E2 convex, c component-wise convex function, and d an affine
function. The CCCP algorithm solves this minimization problem by linearization of the concave part
and is defined in Sriperumbudur & Lanckriet (2009) as
ξt+1 ∈ arg min Ei (ξ) + ξτ VξE2 (ξt)	(43)
s.t. c(ξ) 6 0 ,	d(ξ) = 0 .
We define the upper bound EC on the energy:
EC (ξ, ξt) := Ei (ξ) + E2 (ξt) + (ξ - ξt)T VξE2 (ξt) .	(44)
EC is equal to the energy E (ξt) for ξ = ξt:
EC (ξt, ξt) = Ei (ξt) + E2 (ξt) = E (ξt) .	(45)
Since -E2 is convex, the first order characterization of convexity holds (Eq. 3.2 in Boyd & Vanden-
berghe (2009)):
-E2 (ξ) ≥ - E2 (ξt) - (ξ - ξt)T VξE2 (ξt) ,	(46)
that is
E2 (ξ) 6 E2 (ξt) + (ξ - ξt)T VξE2 (ξt) .	(47)
Therefore, for ξ 6= ξt the function EC is an upper bound on the energy:
E(ξ)	6	EC	(ξ, ξt)	=	Ei	(ξ)	+	E2 (ξt)	+ (ξ -	ξt)T VξE2	(ξt)	(48)
=Ei (ξ) + ξτVξE2 (ξt) + C ,
where C2 does not depend on ξ. Since we do not have constraints, ξt+i is defined as
ξt+i ∈ arg min EC (ξ, ξt) ,	(49)
hence EC ξt+i, ξt 6 EC (ξt, ξt). Combining the inequalities gives:
E (ξt+i) 6 EC (ξt+i, ξt) 6 EC (ξt, ξt) = E (ξt) .	(50)
Since we do not have constraints, ξt+i is the minimum of
EC (ξ, ξt) = Ei (ξ) + ξτVξE2 (ξt) + C2	(51)
as a function of ξ.
For a minimum not at the border, the derivative has to be the zero vector
∂Ec (ξ, ξt)
∂ ξ
ξ + VξE2 (ξt) = ξ - XSoftmax(βXTξt) = 0
(52)
and the Hessian must be positive semi-definite
∂2Ec (ξ, ξt)
∂ξ2
I.
(53)
17
The Hessian is strict positive definite everywhere, therefore the optimization problem is strict convex
(if the domain is convex) and there exist only one minimum, which is a global minimum. EC can
even be written as a quadratic form:
EC (ξ,ξt) = 2 (ξ + VξE2 (ξt))T (ξ + VξE2 (ξt)) + C3 ,	(54)
where C3 does not depend on ξ.
Therefore, the minimum is
ξt+1 = — VξE2 (ξt) = XSoftmax(βXTξt)	(55)
if it is in the domain as we assume.
Using M = maxi kxik, ξt+1 is in the sphere S = {x | kxk 6 M} which is a convex and compact
set. Hence, if ξ0 ∈ S, then the iteration is a mapping from S to S. Therefore, the point-set-map
defined by the iteration Eq. (55) is uniformly compact on S according to Remark 7 in Sriperumbudur
& Lanckriet (2009). Theorem 2 and Theorem 4 in (Sriperumbudur & Lanckriet, 2009) states that all
the limit points of the iteration Eq. (55) are stationary points. These theorems follow from Zangwill’s
global convergence theorem: Convergence Theorem A, page 91 in Zangwill (1969) and page 3 in Wu
(1983).
The global convergence theorem only assures that for the sequence ξt+1 = f(ξt) and a function
Φ We have Φ(ξt) → Φ(ξ*) for t → ∞ but not ξt → ξ*. However, if f is strictly monotone with
respect to Φ, then we can strengthen Zangwill’s global convergence theorem (Meyer, 1976). We set
Φ = E and show E(ξt+1) < E(ξt ) if ξt is not a stationary point of E, that is, f is strictly monotone
with respect to E. The following theorem is similar to the convergence results for the expectation
maximization (EM) algorithm in Wu (1983) which are given in theorems 1 to 6 in Wu (1983). The
following theorem is also very similar to Theorem 8 in Sriperumbudur & Lanckriet (2009).
Theorem A2 (Global Convergence: Stationary Points). For the iteration Eq. (55) we have E (ξt) →
E (ξ*) =E* as t → ∞ ,for some Stationary point ξ*. Furthermore ∣∣ξt+1 一 ξ[∣ → 0 and either
{ξt}t∞=0 converges or, in the other case, the set of limit points of {ξt}t∞=0 is a connected and compact
subset ofL (E*), where L (a) = {ξ ∈ L | E (ξ) = a} and L is the set of stationary points of the
iteration Eq. (55). If L (E*) is finite, then any sequence {ξt}t∞=0 generated by the iteration Eq. (55)
converges to some ξ* ∈ L (E*).
Proof. We have E (ξt) = Ei (ξt) + E2 (ξt). The gradient VξE2 (ξt) = -Vξlse(β, XTξ) is
continuous. Therefore, Eq. (51) has minimum in the sphere S, which is a convex and compact
set. If ξt+1 6= ξt, then ξt was not the minimum of Eq. (48) as the derivative at ξt is not equal to
zero. Eq. (53) shows that the optimization problem Eq. (48) is strict convex, hence it has only one
minimum, which is a global minimum. Eq. (54) shows that the optimization problem Eq. (48) is even
a quadratic form. Therefore, we have
E (ξt+1) 6 EC (ξt+1, ξt) < EC (ξt, ξt) = E (ξt) .	(56)
Therefore, the point-set-map defined by the iteration Eq. (55) (for definitions see (Sriperumbudur
& Lanckriet, 2009)) is strictly monotonic with respect to E. Therefore, we can apply Theorem 3 in
Sriperumbudur & Lanckriet (2009) or Theorem 3.1 and Corollary 3.2 in Meyer (1976), which give
the statements of the theorem.
□
We showed global convergence of the iteration Eq. (31). We have shown that all the limit points of any
sequence generated by the iteration Eq. (31) are the stationary points (critical points; local minima
or saddle points) of the energy function E. Local maxima as stationary points are only possible if
the iterations exactly hits a local maximum. However, convergence to a local maximum without
being there is not possible because Eq. (56) ensures a strict decrease of the energy E. Therefore,
almost sure local maxima are not obtained as stationary points. Either the iteration converges or, in
the second case, the set of limit points is a connected and compact set. But what happens if ξ0 is in
an -neighborhood around a local minimum ξ*? Will the iteration Eq. (31) converge to ξ*? What is
the rate of convergence? These questions are about local convergence which will be treated in detail
in next section.
18
A.1.5 Local Convergence of the Update Rule: Fixed Point Iteration
For the proof of local convergence to a fixed point we will apply Banach fixed point theorem. For the
rate of convergence we will rely on properties of a contraction mapping.
A.1.5.1 General Bound on the Jacobian of the Iteration. We consider the iteration
ξnew = f(ξ) = Xp = Xsoftmax(βXTξ)	(57)
using
p = softmax(βXTξ) .	(58)
The Jacobian J is symmetric and has the following form:
J = d∂ξξ) = β X (diag(p)- PpT) XT = X JsXT，	(59)
where Js is Jacobian of the softmax.
To analyze the local convergence of the iteration, we distinguish between the following three cases
(see also Fig. A.1). Here we only provide an informal discussion to give the reader some intuition. A
rigorous formulation of the results can be found in the corresponding subsections.
a)	If the patterns xi are not well separated, the iteration goes to a fixed point close to the
arithmetic mean of the vectors. In this case p is close to pi = 1/N .
b)	If the patterns xi are well separated, then the iteration goes to the pattern to which the initial
ξ is similar. If the initial ξ is similar to a vector xi then it will converge to a vector close to
xi and p will converge to a vector close to ei .
c) If some vectors are similar to each other but well separated from all other vectors, then a
so called metastable state between the similar vectors exists. Iterations that start near the
metastable state converge to this metastable state.
Figure A.1: The three cases of fixed points. a) Stored patterns (fixed point is single pattern):
patterns are stored if they are Wen separated. EaCh pattern Xi has a single fixed point x* close to it. In
the sphere Si, pattern Xi is the only pattern and x* the only fixed point. b) Metastable state (fixed
point is average of similar patterns): xi and xj are similar to each other and not Well separated.
The fixed point m*x is a metastable state that is close to the mean mx of the similar patterns. c)
Global fixed point (fixed point is average of all patterns): no pattern is Well separated from the
others. A single global fixed point m*x exists that is close to the arithmetic mean mx of all patterns.
We begin With a bound on the Jacobian of the iteration, thereby heavily relying on the Jacobian of the
softmax from Lemma A24.
Lemma A2. For N patterns X = (x1, . . . , xN), p = softmax(βXTξ ), M = maxi kxik, and
m = maxi pi(1 - pi), the spectral norm of the Jacobian J of the fixed point iteration is bounded:
kJk2 6 2β kXk22 m 6 2βN M2 m .	(60)
If pmax = maxi pi ≥ 1 - , then for the spectral norm of the Jacobian holds
kJk2 6 2βNM2	- 22βNM2 < 2βNM2.	(61)
19
Proof. With
p = softmax(β X T ξ) ,
(62)
the symmetric Jacobian J is
I	∂f(ξ)
j = ^∂T
β X (diag(p) - PPT) XT = XJsXT ,
(63)
where Js is Jacobian of the softmax.
With m = maxi pi(1 - pi), Eq. (476) from Lemma A24 is
kJsk2 = β diag(P) - PPT 2 6 2 m β .
Using this bound on kJs k2, we obtain
kJk2 6 β XT2 kJsk2 kXk2 6 2mβkXk22 .
(64)
(65)
The spectral norm k.k2 is bounded by the Frobenius norm k.kF which can be expressed by the norm
squared of its column vectors:
kXk2 6 kXkF = X kXik2 .
Therefore, we obtain the first statement of the lemma:
kJk2 6 2 β kXk22 m 6 2 βN M2 m.
(66)
(67)
With pmax = maxi pi ≥ 1 - Eq. (480) in Lemma A24 is
kJsk2 6 2β - 22β < 2β.
Using this inequality, we obtain the second statement of the lemma:
kJk2 6 2 β N M2 - 2 2 β N M2 < 2 β N M2 .
(68)
(69)
□
We now define the “separation” ∆i of a pattern xi from data X = (x1,... , xN) here, since it has an
important role for the convergence properties of the iteration.
Definition 2 (Separation of Patterns). We define ∆i, i.e. the separation of pattern xi from data
X = (x1,... , xN) as:
∆i = min xiT xi - xiT xj = xiT xi - max xiTxj.	(70)
j,j 6=i	i	i	i	j,j6=i i
The pattern is separated from the other data if 0 < ∆i. Using the parallelogram identity, ∆i can
also be expressed as
δ = min，1 (kxi『-kxjk2 + Ilxi - Xj『)	(71)
j,j 6=i 2
=11lxik2 - 1 max (kxj『-kxi - xj『).
For kxi k = kxj k we have ∆i = 1/2 minj,j 6=i kxi - xj k2.
Analog we say for a query ξ and data X = (x1, . . . , xN), that xi is least separated from ξ while
being separated from other xj with j 6= i if
i
0 6 c = max min ξTxk - ξTxj
k j,j 6=k
arg max min ξTxk - ξTxj
k j,j 6=k
max ξTxj
j,j6=k
(72)
(73)
Next we consider the case where the iteration has only one stable fixed point.
20
A.1.5.2 One Stable State: Fixed Point Near the Mean of the Patterns. We start with the case
where no pattern is well separated from the others.
•Global fixed point near the global mean: Analysis using the data center.
We revisit the bound on the Jacobian of the iteration by utilizing properties of pattern distributions.
We begin with a probabilistic interpretation where we consider pi as the probability of selecting the
vector xi. Consequently, we define expectations as Ep[f(x)] = PiN=1 pif(xi). In this setting the
matrix
X (diag(p) - PpT) XT	(74)
is the covariance matrix of data X when its vectors are selected according to the probability p:
X (diag(p) - PpT) XT = Xdiag(p)XT - XppTXT	(75)
N	N	NT
=	pi xi xiT -	pi xi	pi xi	(76)
i=1	i=1	i=1
= Ep [x xT] - Ep [x] Ep [x]T = Varp [x] ,	(77)
therefore we have
J = β Varp[x] .	(78)
The largest eigenvalue of the covariance matrix (equal to the largest singular value) is the variance in
the direction of the eigenvector associated with the largest eigenvalue.
We define:
mx
mmax
1N
N X xi,
i=1
max kxi - mx k2 .
16i6N
(79)
(80)
mx is the arithmetic mean (the center) of the patterns. mmax is the maximal distance of the patterns
to the center mx .
The variance of the patterns is
T
N
Varp [x] =	pi xi xiT
i=1
XN
=	pi xi
i=1
T
i
(81)
The maximal distance to the center mmax allows the derivation of a bound on the norm of the
Jacobian.
Next lemma gives a condition for a global fixed point.
Lemma A3. The following bound on the norm kJk2 of the Jacobian of the fixed point iteration f
holds independent ofp or the query ξ.
kJk2 6 β m2max .	(82)
For β m2max < 1 there exists a unique fixed point (global fixed point) of iteration f in each compact
set.
Proof. In order to bound the variance we compute the vector a that minimizes
NN
f(a) = Xpikxi - ak2 = Xpi(xi - a)T (xi - a) .	(83)
i=1	i=1
21
The solution to
dfa) = 2 XXPig - Xi) = 0
i=1
(84)
is
N
Pixi .
i=1
(85)
a
The Hessian of fis positive definite since
∂2f (a)
∂ a2
N
2 X	Pi I = 2 I
i=1
(86)
and fis a convex function. Hence, the mean
N
X ：= EPi Xi	(87)
i=1
minimizes PiN=1 Pi kXi - ak2 . Therefore, we have
NN
XPikXi - X『6 XPikXi - mχk2 6 mlax .	(88)
i=1	i=1
Let us quickly recall that the spectral norm of an outer product of two vectors is the product of the
Euclidean norms of the vectors:
IIabTII2 = Jλmaχ(baTabT) = ∣∣a∣∣ Jλmaχ(bbτ) = kak kbk ,	(89)
since bbT has eigenvector b/kbk with eigenvalue kbk2 and otherwise zero eigenvalues.
We now bound the variance of the patterns:
N
∣∣Varp[X]k2 6 XPi∣∣(Xi - X)(Xi - X)τ∣l	(90)
i=1	2
NN
=EPikXi- x∣2 6 EPikXi- mx k2 6 mmax .
i=1	i=1
The bound of the lemma on kJk2 follows from Eq. (78).
For kJk2 6 β m2max < 1 we have a contraction mapping on each compact set. Banach fixed point
theorem says there is a unique fixed point in the compact set.
□
Now let Us further investigate the tightness of the bound on kVarp[X]k2 Via ∣∣Xi 一 X∣∣2: We consider
the trace, which is the sum Pdk=1 ek of the w.l.o.g. ordered nonnegative eigenvalues ek of Varp[X]
The spectral norm is equal to the largest eigenvalue e1 , which is equal to the largest singular value, as
we have positive semidefinite matrices. We obtain:
11 Varp [x]∣∣2 = Tr I EPi (Xi — X)(Xi — X)	— Eek
i=1	k=2
Nd
=XPiTr((Xi - X)(Xi - X)T) - X ek
i=1	k=2
Nd
=EPikXi - Xk2 - Eek .
i=1	k=2
(91)
22
Therefore, the tightness of the bound depends on eigenvalues which are not the largest. Hence
variations which are not along the largest variation weaken the bound.
Next we investigate the location of fixed points which existence is ensured by the global convergence
stated in Theorem A2. For N patterns X = (x1, . . . , xN), we consider the iteration
ξnew = f (ξ) = Xp = Xsoftmax(βXTξ)	(92)
using
p = softmax(β X T ξ) .	(93)
ξnew is in the simplex of the patterns, that is, ξnew = Pi pixi with Pi pi = 1 and 0 6 pi . Hence,
after one update ξ is in the simplex of the pattern and stays there. If the center mx is the zero vector
mx = 0, that is, the data is centered, then the mean is a fixed point of the iteration. For ξ = mx = 0
we have
p = 1/N 1	(94)
and
ξnew = 1/NX 1 = mx = ξ.	(95)
In particular normalization methods like batch normalization would promote the mean as a fixed
point.
We consider the differences of dot products for Xi： xτXi - xτXj = xτ(Xi - Xj), for fixed point mX：
(mX)TXi — (mX)TXj = (mX)T(Xi-Xj),andfortheCenter mx： mTXi-mTXj = mT(Xi-Xj).
Using the Cauchy-Schwarz inequality, we get
ξT (Xi	-	Xj)	6 kξk	kXi	-	Xjk	6 kξk (kXi	- mxk	+	kXj	- mxk)	(96)
6 2 mmax kξk .
This inequality gives：
ξ	(Xi - Xj ) 6 2 mmax (mmax + kmx k) ,	(97)
ξ	(Xi - Xj ) 6 2 mmax M ,
where we used kξ -	0k	6 kξ - mxk + kmx - 0k, kξ - mxk =	kPipiXi -	mxk 6
i pi kXi	- mx k 6 mmax,	and M = maxi kXi k. In particular
β mTx (Xi	-	Xj)	6	2 β mmax kmxk ,	(98)
β	∣(mX)T (Xi	-	Xj )∣	6	2 β mmax ∣∣mXk 6 2 β mmax	(mmax	+	Imxk),	(99)
β Xi (Xi	-	Xj)	6	2 β mmax kXi k 6 2 β mmax	(mmax	+	kmx k)	.	(100)
Let i = arg maxj ξTXj , therefore the maximal softmax component is i. For the maximal softmax
component i we have：
[sθftmax(β XTξ)]i = 1 + Pj=i exp(-β (ξTXi - ξTXj))
1
、1 + Pj=i exp(- 2 βmmax (m
max + kmxk))
_	1
1 + (N - 1) exp(- 2 β mmax (mmax + kmχ II))
_	eχp(2 § mmax (mmax + kmxk))
eχp(2 β mmax (mmax + kmχ k)) + (N - 1)
6 1/N exp(2 β mmax (mmax + kmx k)) .
(101)
23
Analogously we obtain for i = arg maxj mTxxj, a bound on the maximal softmax component i if
the center is put into the iteration:
[softmax(β XTmx)]i 6 1/N exp(2 β mmax kmxk) .	(102)
Analog We obtain a bound for i = arg max, (mχ )TXj on the maximal Softmax component i of the
fixed point:
[softmax(β XTmX)]i 6 1/N exp(2 β mmax Ilmxk)	(103)
6 1/N exp(2 β mmax (mmax + kmx k)) .
The tWo important terms are mmax, the variance or spread of the data and kmx k, Which tells hoW
Well the data is centered. For a contraction mapping We already required β m2max < 1, therefore the
first term in the exponent is 2βm2max < 2. The second term 2βmmax kmx k is small if the data is
centered.
•Global fixed point near the global mean: Analysis using softmax values.
If ξTxi ≈ ξTxj for all i and j, then pi ≈ 1/N and We have m = maxi pi (1 - pi) < 1/N. For
M 6 1/√2β We obtain from Lemma A2:
kJk2 < 1.	(104)
The local fixed point is mx ≈ mx = (1/N) PN=I Xi with Pi ≈ 1/N.
We noW treat this case more formally. First We discuss conditions that ensure that the iteration is a
contraction mapping. We consider the iteration Eq. (57) in the variable p:
pnew = g(p) = softmax(βXTXp) .	(105)
The Jacobian is
J(P) = dg(p) = XTX Js	(106)
∂p
With
Js(PneW) = β (diag(PneW) - PneW(PneW)T) .	(107)
The version of the mean value theorem in Lemma A32 states for Jm = R01 J(λP) dλ = XT XJsm
With the symmetric matrix Jsm = R01 Js (λP) dλ:
PneW =	g(P)	=	g(0)	+	(Jm)TP	=	g(0)	+	JsmXTXP = 1/N1 +	JsmXTXP.
(108)
With m = maxi pi (1 - pi), Eq. (476) from Lemma A24 is
kJs(P)k2 = β diag(P) - PPT 2 6 2 m β .	(109)
First observe that λpi(1 - λpi) 6 pi(1 -pi) for pi 6 0.5 and λ ∈ [0, 1], sincepi(1 -pi) - λpi(1 -
λpi) = (1 - λ)pi(1 - (1 + λ)pi) ≥ 0. For maxi pi 6 0.5 this observation leads to the folloWing
bound for Jm :
s
kJsmk2 6 2mβ .	(110)
Eq. (479) in Lemma A24 states that every Js is bounded by 1/2e, therefore also the mean:
kJsmk2 6 0.5β .	(111)
Since m = maxipi(1 - pi) < maxi pi = pmax, the previous bounds can be combined as folloWs:
kJsmk2 6 2 min{0.25, pmax} β.	(112)
24
Consequently,
kJmk2 6 NM22 min{0.25, pmax} β,	(113)
where we used Eq. (170). XTX 2 = XXT 2, therefore XTX 2 is N times the maximal
second moment of the data squared.
Obviously, g(p) is a contraction mapping in compact sets, where
N M2 2 min{0.25, pmax} β < 1 .	(114)
S is the sphere around the origin 0 with radius one. For
pnew = g(p) = 1/N 1 + Jm p ,
(115)
we have kpk 6 kpk1 = 1 and kpnew k 6 kpnew k1 = 1. Therefore, g maps points from S into S. g is
a contraction mapping for
kJmk2 6 N M2 2 min{0.25, pmax} β = c < 1 .	(116)
According to Banach fixed point theorem g has a fixed point in the sphere S.
Holder,s inequality gives:
Alternatively:
kpk2
kpk2 = pTp 6 kpk1kpk∞ = kpk∞ = pmax .
pi2
i
pi
PmaX / ,-----Pi
pmax
6 PmaX	Pi
i
PmaX .
(117)
(118)
Let now S be the sphere around the origin 0 with radius 1 /√N + √pmX and let IIJm(P) k2 6 c < 1
for p ∈ S. The old P is in the sphere S (p ∈ S) since PmaX < √pmOX for PmaX < 1. We have
kpnewk 6 1∕√N + kJmk2 kPk 6 1∕√N + √Pmaχ.	(119)
Therefore, g is a mapping from S into S and a contraction mapping. According to Banach fixed point
theorem, a fixed point exists in S.
For the 1-norm, we use Lemma A24 and IpI1 = 1 to obtain from Eq. (115):
	Ipnew - 1/N 1I1	6	IJmI1 6 2βmIXI∞M1,	(120)
	Ipnew - 1/N 1I1	6	IJm I1 6 2 β m N M∞ M1 ,	(121)
	Ipnew - 1/N 1I1	6	IJmI1 6 2 β mN M2 ,	(122)
where m =	maxi Pi (1 - Pi), M1 = IX I	1=	maxi IxiI1, M = maxi IxiI, IXI∞	XT1=
maxi [XT]i 1 (maximal absolute row sum norm), and M∞ = maxi IxiI∞. Let us quickly mention
some auxiliary estimates related to XTX:
NN
XTX1 = miax X xiT xj 6 miax X IxiI∞ IxjI1	(123)
j=1	j=1
N
6 M∞ X M1 = N M∞ M1 ,
j=1
where the first inequaltiy is from Holder’s inequality. We used
NN
XTX1 = miax X xiTxj 6 miax X IxiI IxjI	(124)
j=1	j=1
N
6 M XM = NM2 ,
j=1
25
where the first inequality is fromHolder,s inequality (here the same as the Cauchy-SchWarz inequality).
See proof of Lemma A24 for the 1-norm bound on Js. Everything else follows from the fact that the
1-norm is sub-multiplicative as induced matrix norm.
We consider the minimal kpk.
min kpk2	(125)
p
s.t.	pi = 1
i
∀i : pi ≥ 0 .
The solution to this minimization problem is P = (1/N)1. Therefore, we have 1∕√N 6 ∣∣pk and
1/N 6 kpk2 Using Eq. (119) we obtain
1∕√N 6 kpnewk 6 1∕√N + √pmax .	(126)
Moreover
∣pnew∣2 = (pnew)Tpnew = 1/N + (pnew)T Jm p 6 1/N + ∣Jm∣2 ∣p∣	(127)
6 1/N + ∣Jm∣2,
since pnew ∈ S and p ∈ S.
For the fixed point, we have
kp*k2 = (p*)TP* = 1/N + (p*)TJmP* 6 1/N + kJm∣2 kp*k2 ,	(128)
and hence
1/N 6 kp*k26 1/Nf—⅛ = 1/N (I + J⅛).	(129)
Therefore, for small ∣Jm ∣2 we have P* ≈ (1/N)1.
A.1.5.3 Many Stable States: Fixed Points Near Stored Patterns. We move on to the next case,
where the patterns xi are well separated. In this case the iteration goes to the pattern to which the
initial ξ is most similar. If the initial ξ is similar to a vector xi then it will converge to xi and P will
be ei. The main ingredients are again Banach’s Theorem and estimates on the Jacobian norm.
•Proof of a fixed point by Banach Fixed Point Theorem.
→ Mapped Vectors Stay in a Compact Environment. We show that if xi is sufficient dissimilar to
other xj then there is an compact environment of xi (a sphere) where the fixed point iteration maps
this environment into itself. The idea of the proof is to define a sphere around xi for which points
from the sphere are mapped by f into the sphere.
We first need following lemma which bounds the distance ∣xi —f (ξ)∣, where xi is the pattern that
is least separated from ξ but separated from other patterns.
Lemma A4. For a query ξ and data X = (x1, . . . , xN), there exists a xi that is least separated
from ξ while being separated from other xj with j 6= i:
	i = arg max min (ξτXk — ξτXj) = arg max ξTxk —max ξTxj	(130) k j,j 6=k	k	j,j 6=k 0 6 c = max min ξTXk — ξTXj = max ξTXk — max ξTXj	.	(131) k j,j 6=k	k	j,j 6=k
For xi, the following holds:
	∣Xi — f(ξ)∣ 6 2M,	(132)
where	M = max ∣Xi∣ ,	(133) i = (N — 1) exp(— β c) .	(134)
26
Proof. For the softmax component i we have:
[sθftmax(β X Tξ)]i = 1 + Pj=i expJ(ξTXj - ξT Xi)) ≥ 1 + Pj=ilxp(-βc) (135)
1	(N - 1) exp(- β c)
1
1 + (N — 1) exp(- β c)	1 + (N — 1) exp(- β C)
≥ 1 - (N - 1) exp(- β c) — 1 -
For softmax components k 6— i we have
[softmax(β X T ξ)]k
exp(β (ξTXk — ξTXi))
1 + Pj= exp(β (ξTXj — ξTXi))
6 exp(— β c)
N — 1 .
(136)
The iteration f can be written as
N
f(ξ) — Xsoftmax(βXTξ) — X Xj [softmax(β X T ξ)]j .	(137)
j=1
We now can bound kXi — f (ξ)k:
kXi — f(ξ)k
N
Xi —	[softmax(βX T ξ)]j Xj
j=1
N
(1 — [softmax(βX T ξ)]i) Xi — X [softmax(βXT ξ)]j Xj
j=1,j 6=i
(138)
N
6 E Ek + N-1	X	kXjIl
j=1,j 6=i
N
6 EM + ʌɪɪ X M — 2 eM .
N — 1 j=1,j6=i
□
We define ∆i, i.e. the separation of pattern Xi from data X — (X1, . . . , XN) as:
∆i — min XiT Xi — XiT Xj — XiT Xi — max XiT Xj .	(139)
j,j 6=i	i	i	i	j,j6=i i
The pattern is separated from the other data if 0 < ∆i . Using the parallelogram identity, ∆i can also
be expressed as
△i = min 1 (kgk2 - kXjk2 + kXi — Xjk2)	(140)
j,j 6=i 2
=1 Ek2 — 1 max (kXjk2 — kXi — Xjk2).
For kXik — kXjk we have △i — 1/2 minj,j6=i kXi — Xjk2.
Next we define the sphere where we want to apply Banach fixed point theorem.
Definition 3 (Sphere Si). The sphere Si is defined as
& := {ξlkξ -Xik 6 βNM }∙	(141)
Lemma A5. With ξ given, if the assumptions
27
A1: ξ is inside sphere: ξ ∈ Si,
A2: data point xi is well separated from the other data:
∆i ≥ β2N + J ln (2 (N - 1) NβM2)	(142)
hold, then f(ξ) is inside the sphere: f (ξ) ∈ Si. Therefore, with assumption (A2), f is a mapping
from Si into Si.
Proof. We need the separation ∆i of ξ from the data.
min
j,j 6=i
Using the Cauchy-Schwarz inequality, we obtain for 1 6 j 6 N:
ξT xj - xiTxj 6 kξ - xik kxjk 6 kξ - xik M .
We have the lower bound
△ i ≥ min ((xTXi — ∣∣ξ — Xik M) — (XTXj + ∣∣ξ — Xik M))
j,j6=i
=—2 ∣∣ξ — Xik M + min (xtXi — XTXj) = △ — 2 ∣∣ξ — Xik M
j,j6=i
2
≥ Z 一 βN,
where we used the assumption (A1) of the lemma.
From the proof in Lemma A4 we have
Pmax = [softmax(βXTξ)]i ≥ 1 — (N — 1) exp(— β △ i) = 1 —"
Lemma A4 states that
kXi — f(ξ)k 6
6
_ _ ，_____ . ， _ ~ . _
2 e M = 2 (N — 1) exp(— β ∆i) M
2 (N — 1) exp(— β (∆i — β2N)) M.
We have
kXi — f(ξ)k
6	2	(N — 1)	exP(一	β (βΓN + β ln (2(N — 1)	n β M2)	— βΓN))	M
=2	(N — 1)	exp(—	ln(2 (N — 1) Nβ M2)) M
__	1
=N β M ,
(143)
(144)
(145)
(146)
(147)
(148)
where we used assumption (A2) of the lemma. Therefore, f(ξ) is a mapping from the sphere Si into
the sphere Si： If ξ ∈ Si then f (ξ) ∈ Si.	□
•Contraction mapping.
For applying Banach fixed point theorem we need to show that f is contraction in the compact
environment Si .
Lemma A6. Assume that
A1:
△i ≥ βΓN + β ln (2 (N - 1) N β M2)，
(149)
then f is a contraction mapping in Si.
28
Proof. The version of the mean value theorem Lemma A32 states for Jm
JOIJ(λξ +(1- λ)xi) dλ:
f (ξ) = f (Xi) + Jm (ξ - Xi) .	(150)
Therefore
kf(ξ) - f(g)k 6 Jmk2 kξ - Xik ∙	(151)
5 TFC	Jb	∖ J= . / 1	∖ ∖	f	∖ _ Γ<^> 1 T TΓ-<	. 1	C ∙ ɪ	A Λ	1
We define ξ = λξ + (1 一 λ)xi for some λ ∈ [0,1]. From the proof in Lemma A4 We have
Pmax(ξ) = [softmax(β XT ξ)]i ≥ 1 - (N - 1) exp(- β Ai) = 1 - e ,	(152)
，__ . ， _ ~ .
Z= (N - 1) exp(- β Ai),	(153)
Ai = m' (ξτXi - ξτXj) .	(154)
First we compute an upper bound on 匚 We need the separation Ai of ξ from the data. Using the
Cauchy-Schwarz inequality, we obtain for 1 6 j 6 N:
WTXj-	XTXj I	6	∣∣ξ	-	Xi Il	∣∣Xj k	6 ∣∣ξ -	Xi Il	M .	(155)
We have the lower bound on Ai:
Ai ≥ min KXTXi - ∣∣ξ - Xi∣∣ M) - (XTXj + ∣∣ξ - Xi∣∣ M))	(156)
=-2 ∣∣ξ - Xi∣∣ M + m4 (XTXi - xTXj) =Ai - 2 ∣∣ξ - Xi∣∣ M
≥ Ai - 2 ∣∣ξ - Xill M ,
where we used ∣∣ξ - Xi∣∣ = λ∣ξ - Xik 6 ∣∣ξ - Xi∣∣. From the definition of W in Eq. (152) we have
，__ . ， _ ~ .
Z= (N - 1) exp(- β Ai)	(157)
6 (N - 1) exp (- β (Ai - 2 kξ - Xik M))
6 (N — 1) exp
where we used ξ ∈ Si, therefore ∣∣ξ - Xik 6 . N M.
Next we compute an lower bound on W. We start with an upper on Ai:
Ai	6 min ((XTXi	+	∣∣ξ	- Xi∣∣	M)	-	(XTXj	-	∣∣ξ	-	Xi∣∣	M))	(158)
=2 ∣∣ξ - Xi∣∣ M + min. (xtXi - xtXj) =Ai + 2 ∣∣ξ - Xi∣∣ M
6 Ai + 2 kξ - Xik M,
where we used ∣∣ξ - Xi∣∣ = λ∣∣ξ - Xik 6 kξ - Xik∙ From the definition of W in Eq. (152) we have
，_____________________________ . ， , ~
Z= (N - 1) exp(- β Ai)	(159)
≥ (N - 1) exp (- β (Ai + 2 kξ - Xik M))
≥ (N — 1) exp
where we used ξ ∈ Si, therefore ∣∣ξ - Xik 6 . N M.
Now we bound the Jacobian. We can assume W 6 0.5 otherwise (1 - W) 6 0.5 in the following.
From the proof of Lemma A24 we know for pmax(ξ) ≥ 1 - e, then pi(ξ) 6 e for pi(ξ) = Pmax(ξ).
29
EI	l'	/ Jb∖ / 1	/ Jb∖ ∖	/	/ ~∕r	~∖ r∙ 11	∙ -Λ T	,1	1	-	1	Fl
Therefore, pi(ξ)(1 - Pi(ξ)) 6 m 6 e(1 - e) for all i. Next We use the derived upper and lower
bound on e in previous Eq.(61) in Lemma A2:
∣∣J(ξ')∣∣2 6 2 β N M2 e - 2 三 β N M2
6 2 βNM2 (N - 1) exp (- β (△，- 号)) ∙
2 (N - 1)2 exp (- 2 β (∆i + β2N)) βNM2 .
(160)
The bound Eq. (160) holds for the meanJm, too, since it averages over J(ξ):
kJmk2 6 2βNM2 (N- 1) exp
(161)
2 (N - 1)2 exp (- 2 β (∆i + β2N)) βNM2 .
The assumption of the lemma is
△i ≥ -2N + J ln (2 (N - 1) NeM2) ,	(162)
This is
△i - -2N ≥ - ln (2 (N - 1) NeM2) ,	(163)
Therefore, the spectral norm kJk2 can be bounded by:
Jmk2 6 2 e (N - 1) exp (- - 1 ln(2 (N - 1) N-M 2)) NM2 -
2 (N - 1)2 exp (- 2 - (∆i + -2N)) -NM2
1
2(N-1)
2(N- 1)N-M2
N M2 -
(164)
2 (N - 1)2 exp (- 2 - (∆i + -2N)) -NM2
=1 - 2 (N - 1)2 exp (- 2 - (∆i + -2N)) -NM2 < 1 .
Therefore, f is a contraction mapping in Si .
□
•Banach Fixed Point Theorem. Now we have all ingredients to apply Banach fixed point theorem.
Lemma A7. Assume that
A1:
△i ≥ -N + - ln (2 (N - 1) N- M2)，
(165)
then f has a fixed point in Si.
Proof. We use Banach fixed point theorem: Lemma A5 says that f maps from Si into Si . Lemma A6
says that f is a contraction mapping in Si.	□
30
•Contraction mapping with a fixed point.
We have shown that a fixed point exists. We want to know how fast the iteration converges to the fixed
point. Let x* be the fixed point of the iteration f in the sphere Si. Using the mean value theorem
Lemma A32, We have with Jm = R1 J(λξ + (1 - λ)x*) dλ:
kf(ξ)	-	xi*k	= kf(ξ)	-	f(xi*)k	6	kJmk2	kξ	-	xi*k	(166)
According to Lemma A24, if PmaX = maxi Pi ≥ 1 — e for all X = λξ + (1 - λ)x*, then the spectral
norm of the Jacobian is bounded by
IIJs(X)k2 < 2 eβ .	(167)
The norm of Jacobian at X is bounded
kJ(X)k2 6 2 β ∣∣Xk2 e 6 2 β NM2 e .	(168)
We used that the spectral norm I.I2 is bounded by the Frobenius norm I.IF which can be expressed
by the norm squared of its column vectors:
∣X∣2 6 ∣X∣F
X kχik2.
Therefore
∣X ∣22 6 N M2 .
The norm of Jacobian of the fixed point iteration is bounded
∣Jm ∣2 6 2 β ∣X ∣22 e 6 2 β NM2 e .
(169)
(170)
(171)
The separation of pattern Xi from data X = (X1 , . . . , XN ) is
∆i = min XiT Xi - XiT Xj = XiT Xi
j,j 6=i	* i	i	i
max XiT Xj .
j,j6=i i
We need the separation ∆i of X
λξ + (1 - λ)Xi* from the data:
∆∆ i = min (XTxi — XTXj).
j,j6=i
(172)
(173)
—
We compute a lower bound on ∆i. Using the Cauchy-Schwarz inequality, we obtain for 1 6 j 6 N:
IXTXj - XTXjI 6 ∣∣X - XiIIIIXjk 6 ∣∣X - XiIl M .
We have the lower bound
∆i ≥ min ((XTXi - ∣∣X - Xik M) - (xtXj + ∣∣X - Xik M))
j,j6=i
(174)
(175)
=—2 ∣X — Xik M + min (xtXi — xtXj) = ∆i — 2 ∣X — Xik M .
j,j6=i i	i
Since
kx - Xik = kλξ + (1- λ)x* - Xik	(176)
6 λ ∣ξ - Xi∣ + (1 - λ) ∣Xi* - Xi∣
6 max{kξ - Xik, kXi* - Xik} ,
we have
∆i ≥ ∆i - 2 max{∣ξ - Xik,∣x* - Xik} M ∙	(177)
For the softmax component i we have:
[softmax(β XTξr)]i = ---------------\---------R-----
1	+ Pj=i exp(β (ξTXj - ξTXi))
1
2	1 + Pj=i exp(- β (∆i - 2 max{∣ξ - Xik,∣x* - Xik} M))
_	1
1 + (N - 1)exp(- β (∆i - 2 max{∣ξ - Xik,∣x* - Xik} M))
(178)
(N - 1) exp(- β (∆i - 2 max{kξ - Xik, kXi* - Xik} M))
=1 - ------7—----：---:-——-----------77----------------—~~——
1 + (N - 1)exp(- β (∆i - 2 max{∣ξ - Xik, ∣x* - Xik} M))
≥ 1 - (N - 1) exp(- β (∆i - 2 max{kξ - Xik, kXi* - Xik} M))
1 - e.
31
Therefore
e = (N - 1)exp(- β (∆i - 2 max{∣∣ξ - Xi||,||x； - Xi∣∣} M)) .	(179)
We can bound the spectral norm of the Jacobian, which upper bounds the Lipschitz constant:
∣∣Jmk2 6 2 βNM2 (N - 1)exp(- β (∆i - 2 max{∣∣ξ - Xik, ||x； - g∣∣} M)) . (180)
For a contraction mapping we require
kJmk2 < 1,	(181)
which can be ensured by
2 β NM2 (N - 1)exp(- β (∆i - 2 max{∣∣ξ - Xik, |向一Xik} M)) < 1.	(182)
Solving this inequality for ∆i gives
∆i	> 2 max{∣∣ξ	-	xik,	||x；	-	Xik} M + 1 In(2	(N - 1) Ne	M2)	.	(183)
β
In an environment around x* in which Eq. (183) holds, f is a contraction mapping and every point
converges under the iteration f to x* when the iteration stays in the environment. After every iteration
the mapped point f(ξ) is closer to the fixed point xi* than the original point xi :
kf(ξ) - xi*k 6 kJmk2 kξ - xi*k < kξ - xi*k .	(184)
Using
kf(ξ)	-	xi*k	6	kJmk2 kξ -	xi*k	6	kJmk2	kξ	-	f(ξ)k +	kJmk2 kf(ξ)	-	xi*k	, (185)
we obtain
kJmk
kf(ξ) - x*k 6 I k jm” kξ - f(ξ)k .	(186)
1 - kJ k2
For large ∆i the iteration is close to the fixed point even after one update. This has been confirmed in
several experiments.
A.1.5.4 Metastable States: Fixed Points Near Mean of Similar Patterns. The proof concept
is the same as for a single pattern but now for the arithmetic mean of similar patterns.
•Bound on the Jacobian.
The Jacobian of the fixed point iteration is
J = β X (diag(p) - PPT) XT = XJsXT .	(187)
If we consider pi as the probability of selecting the vector xi , then we can define expectations as
Ep [f (x)] = PiN=1 pif(xi). In this setting the matrix
X (diag(p) - PPT) XT	(188)
is the covariance matrix of data X when its vectors are selected according to the probability P:
X (diag(p) - ppT) XT = Xdiag(p)XT - XPPTXT	(189)
N	N	NT
=	pi xi xiT -	pi xi	pi xi	(190)
i=1	i=1	i=1
= Ep[x xT] - Ep[x] Ep[x]T = Varp[x] ,	(191)
therefore we have
J = β Varp [x] .	(192)
We now elaborate more on this interpretation as variance. Specifically the singular values of J (or in
other words: the covariance) should be reasonably small. The singular values are the key to ensure
convergence of the iteration Eq. (57). Next we present some thoughts.
32
1.	It’s clear that the largest eigenvalue of the covariance matrix (equal to the largest singu-
lar value) is the variance in the direction of the eigenvector associated with the largest
eigenvalue.
2.	Furthermore the variance goes to zero as one pi goes to one, since only one pattern is chosen
and there is no variance.
3.	The variance is reasonable small if all patterns are chosen with equal probability.
4.	The variance is small if few similar patterns are chosen with high probability. If the patterns
are sufficient similar, then the spectral norm of the covariance matrix is smaller than one.
The first three issues have already been adressed. Now we focus on the last one in greater detail. We
assume that the first l patterns are much more probable (and similar to one another) than the other
patterns. Therefore, we define:
M:	= max kxi k , i	(193)
	N	
Y	pi 6	,	(194)
	i=l+1	
1-Y	l pi ≥ 1 -	,	(195)
	i=1	
pi ,:■	=γp- 6 pi∕(I - e), 1-Y	(196)
l X pi =	1,	(197)
i=1		
mx	1l =7 X xi , i=1	(198)
mmax	max kxi - mx k . 16i6l	i	x	(199)
M is an upper bound on the Euclidean norm of the patterns, which are vectors. is an upper bound
on the probability γ of not choosing one of the first l patterns, while 1 - is a lower bound the
probability (1 - γ) of choosing one of the first l patterns. mx is the arithmetic mean (the center)
of the first l patterns. mmax is the maximal distance of the patterns to the center mx . P is the
probability p normalized for the first l patterns.
The variance of the first l patterns is
Varp [xi：i]
ll
Epi	χi - Epixi
i=1	i=1
l
xi
pixi
—
(200)
i=1
Σ
T
Lemma A8. With the definitions in Eq. (193) to Eq. (200), the following bounds on the norm kJk2
of the Jacobian of the fixed point iteration hold. The γ-bound for kJk2 is
kJ∣∣2 6 β ((I-Y) m2maχ + Y 2(2 - Y) M2)	(201)
and the -bound for kJk2 is:
kJk2 6 β ( m2max + e 2(2 - e) M2).
(202)
33
Proof. The variance Varp[xi：i] can be expressed as:
l
(1 - Y)Varp[xi：i] = Epi
i=1
xi
占 X pi Xi
l
=	pi xi
i=1
+ Pi=I Pi
+ (1-Y )2
l
T
xiT -
(X pi xi!±(X pi xi!
Σ
i=1
l
X
i=1
pi xi
pi xi
—
Therefore, we have
T
l
pi xi xiT
i=1
—
pi xi
(1 - Y) Varp[xi：i] + Tɪ-
1-Y
pi xi
(204)
T
We now can reformulate the Jacobian J:
XlN
pi xi xiT +	pi xi xiT
i=l+1
(205)
J
T
+
—
+
—
—
N
pi xi + pi xi
i=l+1
N
+ pi xi
i=l+1
T
β	pi xi xiT
i=1
pi xi
—
N
pi xi xiT
i=l+1
NN
pi xi	pi xi
i=l+1	i=l+1
Xi=l1pi xi	pi xi	-	pi xi	pi xi
i=l+1	i=l+1	i=1
T
β I (1 - Y)Varp[xi：i] + γ--γ
N
pi xi xiT
i=l+1
N
pi xi	pi xi
i=l+1	i=l+1
pi xi
Xi=l1pi xi	pi xi	-	pi xi	pi xi
i=l+1	i=l+1	i=1
—
—
T
34
The spectral norm of an outer product of two vectors is the product of the Euclidean norms of the
vectors:
IIabTlI2 = Jλmaχ(baTabT) = ka∣∣ Jλmax(bbτ) = ∣∣a∣∣ ∣∣b∣∣ ,	(206)
since bbT has eigenvector b/kbk with eigenvalue kbk2 and otherwise zero eigenvalues.
We now bound the norms of some matrices and vectors:
l
II pi xi II
I	i=1	I
IN	I
II	pi xi II
Ii=l+1	I
NI
pi xi xiT II
i=l+1	I2
l
6 X pi kxi k 6 (1 - γ) M ,
i=1
N
6 X pi kxi k 6 γ M ,
i=l+1
N	NN
6 X pi	IIxi xiT II2 = X	pi kxik2 6 X piM2 = γM2 .
i=l+1	i=l+1	i=l+1
(207)
(208)
(209)
f(a) =	PikXi
i=1
The solution to
∂f (a)
∂a
is
In order to bound the variance of the first l patterns, we compute the vector a that minimizes
ll
- ak2 = Xpi(xi - a)T (xi - a) .	(210)
i=1
N
= 2 Xpi(a - xi) = 0	(211)
i=1
N
a =	pixi .	(212)
i=1
The Hessian of f is positive definite since
dfa) = 2 X PiI = 2 I	(213)
∂a2
i=1
andf is a convex function. Hence, the mean
N
X := XPi Xi	(214)
i=1
minimizes PiN=1 Pi kXi - ak2 . Therefore, we have
ll
XPikXi- χk2 6 XPikXi- mxk2 6 (1 - Y) m2naχ .	(215)
i=1	i=1
We now bound the variance on the first l patterns:
l
(1 - Y) IIVarp[xli]∣∣2 6 XP』(xi - X)(Xi - X)T∣∣	(216)
i=1	2
ll
=EPikXi- Xk2 6 EPikXi- mxk2 6 (I - Y) m2naχ .
i=1	i=1
35
We obtain for the spectral norm of J:
kJk2 6
β ((I-Y) kVarp[xi：i]k2
占 I (X Pi Xi	Pi Xi
(217)
N
pi xi xiT
i=l+1
+
Pi Xi	Pi Xi
i=l+1
+ IIII	XN Pi Xi
2 I i=l+1
N	T II
2
X pi xi
2
N
Pi Xi
i=l+1
Pi Xi
+
+
T
+
2
T
T
2
6
Y
β ((1 - Y) IlVarp[x±ι]∣∣2 + Y (1 - Y) M2 + YM2 + γ2 M2 +
(1 -γ)M2 + γ(1 -γ)M2
β ((I- Y) kvarp[χι⅛ + Y 2(2 — Y) M2).
Combining the previous two estimates immediately leads to Eq. (201).
The function h(x) = x2(2 - x) has the derivative h0(x) = 4(1 - x). Therefore, h(x) is monotone
increasing for x < 1. For 0 6 Y 6 < 1, we can immediately deduce that Y2(2 - Y) 6 2(2 - ).
Since is larger than Y, we obtain the following -bound for IJI2 :
kJ∣2 6 β ( mirnax + e 2(2 - e) M2) .	(218)
□
We revisit the bound on (1 一 Y) Varp[x±ι]. The trace Pd= ek is the SUm of the eigenvalues ek. The
spectral norm is equal to the largest eigenvalue e1, that is, the largest singular value. We obtain:
||Varp[xi：i]k2 = Tr (XPi(Xi — X)(Xi — X)T) — Xek	(219)
i=1	k=2
ld
=XPiT ((Xi — X)(Xi — X)T) — X ek
i=1	k=2
ld
=EPikXi — Xk2 — Eek .
i=1	k=2
Therefore, the tightness of the bound depends on eigenvalues which are not the largest. That is
variations which are not along the strongest variation weaken the bound.
•Proof of a fixed point by Banach Fixed Point Theorem.
36
Without restricting the generality, we assume that the first l patterns are much more probable (and
similar to one another) than the other patterns. Therefore, we define:
M:	= max kXi k , i	(220)
	N	
γ	Pi 6	,	(221)
	i=l+1	
1-γ	l Pi ≥ 1 -	,	(222)
	i=1	
Pi ：--	=γp~ 6 Pi/(1 - e), 1-γ	(223)
l X Pi =	1,	(224)
i=1		
mx	1l =7 X Xi, l i=1	(225)
mmax	max kXi - mx k . 16i6l	(226)
M is an upper bound on the Euclidean norm of the patterns, which are vectors. is an upper bound
on the probability γ of not choosing one of the first l patterns, while 1 - is a lower bound the
probability (1 - γ) of choosing one of the first l patterns. mx is the arithmetic mean (the center)
of the first l patterns. mmax is the maximal distance of the patterns to the center mχ . P is the
probability p normalized for the first l patterns.
•Mapped vectors stay in a compact environment. We show that if mx is sufficient dissimilar to other
xj with l < j then there is an compact environment of mx (a sphere) where the fixed point iteration
maps this environment into itself. The idea of the proof is to define a sphere around mx for which
the points from the sphere are mapped by f into the sphere.
We first need following lemma which bounds the distance kmx - f (ξ)k ofa ξ which is close to
mx.
Lemma A9. For a query ξ and data X = (X		1, . . . , XN), we define		
06c	= min ξTmx - j,l<j	ξTXj	= ξTmx -	max ξTXj . j,l<j	(227)
The following holds:				
kmx	- f(ξ)k 6 mmax	+ 2 γ M 6 mmax	+2M,	(228)
where				
	M = max kXik , i			(229)
	= (N	- l) exp(- β c) .		(230)
Proof. Let S = arg maxj,j6i ξτXj, therefore ξτmχ = 1 Pi=I ξτXi 6 1 Pi=I ξτXs = ξτx§.
For softmax components j with l < j we have
[softmax(βXT ξ)]j
exp(β (ξTXj - ξTXs))
1 + Pk=S exp(β (ξTXk - ξTXs))
6 eχp(- βc) = N-ι,
(231)
since ξTXs - ξT Xj ≥ ξTmx - ξTXj for each j with l < j , therefore ξTXs - ξTXj ≥ c
The iteration f can be written as
N
f(ξ) = Xsoftmax(βXTξ) = X Xj [softmax(β X T ξ)]j .	(232)
j=1
37
We set Pi
Therefore
[softmax(βXTξ)]i, therefore Pli=1 Pi
1 - γ ≥ 1 - and PiN=l+1 Pi
γ 6 .
l
mx -
Pj
2
j=1
1-γ
xj
l
X
j=1
Pj
1-γ
(mx
- xj)
2
(233)
l
X
j=1,k=1
Pj
Pk
1-γ 1-γ
(mx
- xj)T(mx
—
xk)
1
2
l
X
j=1,k=1
Pj
Pk
1-γ 1-γ
mx - xjk2 + kmx - xkk2 - kxj - xkk2
l
X
Pj
j=1
1-γ
kmx
—
xj k2
—
1
2
l
X
j=1,k=1
Pj
Pk
1-γ 1-γ
kxj - xkk2
l
6X
Pj
j=1
1-γ
kmx
—
xj k2
6
m2
mmax .
It follows that
mx
—
l
X
Pj
j=1
1-γ
xj	6 mmax
(234)
We now can bound kmx
—
f(ξ)k:
kmx - f (ξ)k
6
6
6
6
mx
mx
mx
mx
mx
mx
mmax
—
—
—
—
—
—
N
Pj xj
j=1
l
Pj xj
j=1
l
X
j=1
l
X
j=1
l
X
j=1
l
X
j=1
—
N
Pj xj
j=l+1
Pj
1-γ
xj
+
γ
1-γ
l
Pj xj
j=1
—
N
Pj xj
j=l+1
(235)
Pj
1-γ
xj
+
γ
1-γ
X Pj xj
j=1
+
N
Pj xj
j=l+1
Pj
1-γ
xj
+
γ
l
N
Pj
1-γ
xj
+
+ 2 γ M 6 mmax
1-γ
2γM
j=1
PjM +	PjM
+2M,
j=l+1
where we applied Eq. (233) in the penultimate inequality. This is the statement of the lemma.
□
The separation of the center (the arithmetic mean) mx of the first l from data X = (xl+1, . . . , xN)
is ∆m , defined as
∆m
m<nj (mTmx - mTXj)
T
mTx mx
—
T
max m xj .
j,l<j x j
(236)
38
The center is separated from the other data xj with l < j if 0 < ∆m . By the same arguments as in
Eq. (140), ∆m can also be expressed as
∆m = min 1 (
j,l<j 2
=2 Ilmxk2
mx k2
- kXjk2 + kmx - Xjk2
(237)
1
一 max
2 j,l<j
kxjk2 - kmx
- xj k2	.
—
For kmxk = kxjk we have ∆m = 1/2 minj,l<j kmx - xjk2.
Next we define the sphere where we want to apply Banach fixed point theorem.
Definition 4 (Sphere Sm). The sphere Sm is defined as
1
ξ | kξ - mxk 6
β
mmax
(238)
Lemma A10. With ξ given, if the assumptions
A1:
A2:
ξ is inside sphere: ξ ∈ Sm,
the center mx is well separated from other data xj with l < j :
∆m ≥
β
2M
mmax
Tn
1 - β m2max
2β (N- l) M max{mmax , 2M}
(239)
A3:
the distance mmax of similar patterns to the center is sufficient small:
β m2max 6 1
(240)
hold, then f(ξ) ∈ Sm. Therefore, under conditions (A2) and (A3), f is a mapping from Sm into Sm.
Proof. We need the separation ∆m of ξ from the rest of the data, which is the last N - l data points
X = (xl+1, . . . , xN).
∆m = min ξζτmχ - ξτXj).
j,l<j
Using the Cauchy-Schwarz inequality, we obtain for l + 1 6 j 6 N:
ξτ xj - mτx xj 6 kξ - mxk kxjk 6 kξ - mxk M .
We have the lower bound
∆m ≥ min ((mTmχ - kξ - mxk M) — (mTXj + kξ — mxk M))
j,l<j
(241)
(242)
(243)
-2 kξ - mxk M + min mTx mx
j,l<j
mx xj	= ∆m
- 2 kξ - mxk M
—
M
≥ ∆m - 2
β
mmax
where we used the assumption (A1) of the lemma.
From the proof in Lemma A9 we have
l
^Xpi ≥ 1 - (N - I) exp(- β δm) = 1 -
(244)
i=1
N
X pi
i=l+1
Lemma A9 states that
kmx - f (ξ)k 6
6
6 (N - I) exp(- B δm) ="
mmax
mmax
2 € M
2(N - l) exp(- β ∆m) M .
(245)
(246)
〜
e ,
+
+
6
+
mmax
2 (N - l) exp(- β (∆m - 2
β
-M-)) M.
mmax
39
Therefore, we have
M
kmx - f(ξ)k 6 mmax + 2(N-1) exp(-β0m - 2 j^)
(247)
6 mmax + 2 (N - l) exp -β
2 2 M
β mmax
1ln (	1 - βmmχ	∖ - 2 M ”
β 2 β (N - l) M max{mmaχ , 2 M} )	β mmax )
mmax
+ 2(N-l) --------1 - β mmax------
2 β (N — l) M max{mmaχ , 2 M}
6 mmax
1 - βmmmax =	1
β mmax	β mmax
where we used assumption (A2) of the lemma. Therefore, f(ξ) is a mapping from the sphere Sm into
the sphere Sm .
mmax = max kxi - mx k
16i6l
max
16i6l
xi - 1/l	xj
j=1
max
16i6l
1/l (xi - xj)
j=1
6 max
16i,j6l
kxi-xjk
6 max kxi k + max kxi k
16i6l	16j6l
6 2M
(248)
(249)
(250)
(251)
(252)
(253)
□
M
l
l
M
M
(254)
•Contraction mapping.
For applying Banach fixed point theorem we need to show that f is contraction in the compact
environment Sm .
Lemma A11. Assume that
A1:
∆	≥	2 M - 1 in (_____________1 - β mmax____________
m — β mmax	β 2 β (N - l) M max{mmax , 2 M}
and
A2:
β m2max 6 1 ,	(255)
then f is a contraction mapping in Sm.
Proof. The version of the mean value theorem Lemma A32 states for the symmetric Jm = R01 J(λξ +
(1 - λ)mx ) dλ:
f(ξ) = f(mx) + Jm(ξ - mx).	(256)
In complete analogy to Lemma A6, we get:
kf(ξ) - f(mx)k 6 kJmk2 kξ - mxk.	(257)
40
5TFC Jb ∖ J= . / 1 ∖ ∖ C∙	∖ _ Γ(^> -ɪ 1 -ITT	1 .1	. ∙ Λ 1' Jb 1' .1	,
We define ξ = λξ +(1 - λ)mx for some λ ∈ [0,1]. We need the separation Am of ξ from the rest
of the data, which is the last N — l data points X = (xι+ι,..., XN).
Am = mn (ξτmx - ξτXj) .	(258)
From the proof in Lemma A9 we have
W= (N - l) exp(- β Am) ,	(259)
ι
^X pi(ξ) ≥ 1 - (N - l) eXp(- β Am) = 1 - W ,	(260)
i=1
N
E Pi(ξ) 6 (N - l) exp(- β Am) = W .	(261)
i=l+1
We first compute an upper bound on W. Using the Cauchy-Schwarz inequality, we obtain for l + 1 6
j 6 N:
〜
〜
∖ξτxj - mTxj
6 I归-m∕∣ - 6 I 归-mæ I I M ∙
(262)
We have the lower bound on AW m :
AW
≥ m⅛( (mT mχ TK
=-21 I ξ - mx 11M +
m
-mæn M) - (mTxj + 归-mæn M))	(263)
min_ (mTmx - mTxj) =Am - 2 归-mJ M
≥ Am - 2 ∣∣ξ - mχ∣∣ M .
where we used (g - mx1 = λ∣∣ξ - mx ∣∣ 6 ∣∣ξ 一 mxk. We obtain the upper bound on e:
e 6 (N - l) eχp (- β (Am - 2 ∣∣ξ - mxk M))
(N - l) exp I - β I Am -
2 M
β mmaχ
where we used that in the sphere Si holds:
l∣ξ - mχ∣ 6
1
β mmax
therefore
2 ∣∣ξ - mχ∣ M 6
2 M
β mmax
(264)
(265)
(266)
6
Next we compute a lower bound on W and to this end start with the upper bound on Am using the
same arguments as in Eq. (158) in combination with Eq. (266).
A
m
≥
xj - Hξ -
min
j,ι<j
〜
2 ξξ - mæn M + min
mx +1 I ξ -
—
—
(267)
mTxj) =Am + 2 4-mxI∖ M
≥ Am + 2 ∣∣ξ -	mxk M.
where we used(£ - mJ = λ∣ξ - mx ∣∣ 6 ∣∣ξ - mx∣. We obtain the lower bound on e:
e ≥ (N - l) exp (- β (Am + 飞---------)),	(268)
∖	∖	β mmax))
where we used that in the sphere Si holds:
∣…∣6 士,	(269)
41
therefore
2 ∣∣ξ - mχ∣∣ M 6
2 M
β mmax
From Lemma A8 we have
J(ξ)∣∣2 6 β ( mmax + 52(2 - W) M2)
=β (mmax + M M2 - 2 W2 M2)
6 β (mmax + (N - l) exp (- β fʌm - -3-4 M2 -
β	β x	β mmax
2 (N - 1)2 exp (- 2 β (ʌm + βmM-)) M2).
El 1	1 -r-< ∕r∙∖!-ι -t ∖ 1 1 1 C . 1	Tm .	∙	∙ ,	T / Jb∖
The bound Eq. (271) holds for the mean Jm, too, since It averages over J(ξ):
IlJmll 2	6 β	(mmax +	(N	-	1)	exp (-	β	(ʌm -飞--------))4 M2	-
β	β ∖	β mmax))
2 (N - l)2 exp - 2 β
+
β≡) MI
(270)
(271)
(272)
The assumption of the lemma is
ʌm ≥	2 M - 1 ln (_____________1 - β mmax__________)
β ~β mmax	β 2 β (N - l) M max(mmax , 2 M})
Therefore, we have
ʌ -	2 M ≥ - 1 in (___________1 - β mmax__________
m β mmax — β 2 β (N - l) M max(mmax , 2 M}
(273)
(274)
Therefore, the spectral norm IIJmk 2 Can be bounded by:
IlJmil2 6	(275)
β (mmax + (N - l) exp (- β (- β ln (2 β (N - l)1M mammLx ,2 M})))
4 M2 - 2 (N - l)2 exp (- 2 β (ʌm + -M-)) M2)
∖	∖	β mmax))	)
=β (mmax + (N - l) exp (ln (2 β (N - l)1M mj⅛max ,2 M} )
4 M2 - 2 (N - l)2 exp (- 2 β (△% +	2 M )) M2
∖	∖	β mmax))
β (mmax + (N - l) 2 β (N - l)M m ax /max ,2 M} 4 M 2
—
2 (N - l)2 exp - 2 β ʌm +
2 M
β mmax
M2
βmmax+
1 - β mmax
max{mmax , 2 M}
2 M -
β 2 (N - l)2 exp (- 2 β (ʌm + 飞-))M2
∖	∖	β mmax))
6 βmmax + 1 - β mmax - β 2 (N - l)2 exp - 2 β
+
2 M
β mmax
M2
1 — β 2 (N — l)2 exp (- 2 β (ʌm + 飞-))M2 < 1 .
∖	∖	β mmax))
42
For the last but one inequality we used 2M 6 max{mmax, 2M }.
Therefore, f is a contraction mapping in Sm.	□
•Banach Fixed Point Theorem. Now we have all ingredients to apply Banach fixed point theorem.
Lemma A12. Assume that
A1:
∆	≥	2 M - 1(	1 - βm,x
m — β mmax β 2 β (N — l) M max{mmaχ , 2 M}
and
(276)
A2:
β m2max 6 1 ,
(277)
then f has a fixed point in Sm.
Proof. We use Banach fixed point theorem: Lemma A10 says that f maps from the compact set Sm
into the same compact set Sm,. Lemma A11 Says that f is a contraction mapping in Sm/.	□
•Contraction mapping with a fixed point.
We assume that the first l patterns are much more probable (and similar to one another) than the other
patterns. Therefore, we define:
M := max kxi k ,	(278)
i
N
γ = X pi 6	,	(279)
i=l+1
l
1-γ = Xpi ≥ 1 -	,	(280)
i=1
Pi :=	pi- 6 Pi∕(1 — e) ,	(281)
1	- γ
l
X Pi = 1 ,	(282)
i=1
1l
mχ = 7	"i，	(283)
mmax = max kxi — mx k .	(284)
16i6l
M is an upper bound on the Euclidean norm of the patterns, which are vectors. e is an upper bound
on the probability γ of not choosing one of the first l patterns, while 1 — e is a lower bound the
probability (1 — γ) of choosing one of the first l patterns. mx is the arithmetic mean (the center)
of the first l patterns. mmax is the maximal distance of the patterns to the center mχ . P is the
probability p normalized for the first l patterns.
The variance of the first l patterns is
Varp [xi：i]
xi
—EPixi
i=1
—EPixi
i=1
EPi	xi
i=1
(285)
T
43
We have shown that a fixed point exists. We want to know how fast the iteration converges to the
fixed point. Let mχ be the fixed point of the iteration f in the sphere Sm. Using the mean value
theorem Lemma A32, We have with Jm = R1 J(λξ + (1 - λ)mχ) dλ:
kf(ξ) — mXk = kf(ξ) — f(mX)k 6 Jmk2 kξ - mXk	(286)
According to Lemma A8 the following bounds on the norm kJk2 of the Jacobian of the fixed point
iteration hold. The γ-bound for kJk2 is
Jk2 6 β ((1 - γ) m2maχ + Y 2(2 - Y) M2) ,	(287)
while the -bound for kJk2 is:
Jk2 6 β ( m2max + e 2(2 - e) M2) .	(288)
From the last condition we require for a contraction mapping:
β m2max < 1 .	(289)
We want to see how large is. The separation of center mx from data X = (xl+1, . . . , xN) is
∆m	= min	mTx mx	- mTx xj	= mTx mx	- max mTx xj	.	(290)
j,l<j x	x	x	j,l<j x
We need the separation ∆m of X = λξ + (1 - λ)mχ from the data.
∆m = min (XTmχ — XTXj) .	(291)
j,l<j
We compute a lower bound on ∆m. Using the Cauchy-Schwarz inequality, we obtain for 1 6 j 6 N:
IXTXj - mTXjI 6 ∣∣X - mχk∣∣Xj∣∣ 6 ∣∣X - mχk M .	(292)
We have the lower bound
∆m ≥ min ((mTmχ - IlX - mχ∣ M) - (mTXj + IlX - mχ∣∣ M))	(293)
j,l<j
=—2 ∣X — mχ∣ M + min (mTmχ — mTXj) = ∆m — 2 ∣∣X — mχ∣ M .
j,l<j x	x
Since
∣∣X - mxk = I∣λξ + (1 - λ)mχ - mχk	(294)
6 λ ∣∣ξ - mχ∣∣ + (1 - λ) ∣mχ - mχ∣
6 max{∣∣ξ - mχ∣∣,∣∣mX - mχ∣∣},
we have
∆m ≥ ∆m - 2 max{∣ξ - mχ∣∣,∣∣mX - mχ∣} M .	(295)
e = (N - l)exp(- β (∆m - 2 max{∣ξ - mχ∣∣,∣∣mX - mχ∣∣} M)) .	(296)
A.1.6 Properties of Fixed Points Near Stored Pattern
In Subsection A.1.5.3 many stable states that are fixed points near the stored patterns are considered.
We now consider this case. In the fist subsection we investigate the storage capacity if all patterns are
sufficiently separated so that metastable states do not appear. In the next subsection we look into the
updates required and error when retrieving the stored patterns. For metastable states we can do the
same analyses if each metastable state is treated as one state like one pattern.
We see a trade-off that is known from classical Hopfield networks and for modern Hopfield networks.
Small separation ∆i of the pattern Xi from the other patterns gives high storage capacity. However
the convergence speed is lower and the retrieval error higher. In contrast, large separation ∆i of the
pattern Xi from the other pattern allows the retrieval of patterns with one update step and exponentially
low error.
44
A.1.6.1 Exponentially Many Patterns can be Stored. From Subsection A.1.5.3 need some
definitions. We assume to have N patterns, the separation of pattern xi from the other patterns
{x1, . . . , xi-1, xi+1, . . . , xN} is ∆i, defined as
∆i = min xiT xi - xiT xj = xiT xi - max xiT xj .	(297)
j,j 6=i	i	i	i	j,j6=i i
The pattern is separated from the other data if 0 < ∆i . The separation ∆i can also be expressed as
δ = min 1 (kxi『-kxjk2 + Ilxi - Xj『)	(298)
j,j 6=i 2
=1 Ilxik2 - 1 max (kxj『-kxi - xj『).
For IxiI = Ixj I we have ∆i = 1/2 minj,j6=i Ixi - xj I2. The sphere Si with center xi is defined
as
si = {ξlkξ-xik 6 βN1M}∙	(299)
The maximal length of a pattern isM = maxi Ixi I.
We next define what we mean with storing and retrieving a pattern.
Definition 5 (Pattern Stored and Retrieved). We assume that around every pattern xi a sphere Si is
g^ven. We say χ is stored ifthere is a single fixed point x* ∈ Si to which all points ξ ∈ Si converge,
and Si ∩ Sj = 0 for i = j. We say xi is retrieved for a given e ifiteration (update rule) Eq. (92) gives
a point X that is at least e -close to the single fixed point x* ∈ Si. The retrieval error is kxi 一 xik.
The sphere Si around pattern xi can be any a sphere and do not have the specific sphere defined in
Def. 3.
For a query ξ ∈ Si to converge to a fixed point xi* ∈ Si we required for the application of Banach
fixed point theorem and for ensuring a contraction mapping the following inequality:
∆i ≥ -2N + 1 ln(2 (N - 1) NβM2) .	(300)
This is the assumption in Lemma A7 to ensure a fixed point in sphere Si. Since replacing (N 一 1)N
by N 2 gives
-2N + 1 ln (2 N2-m 2) > -2N + 1 ln (2(N - 1) N-M2) ,	(301)
the inequality follows from following master inequality
∆i ≥ ɪ + 1 ln (2 N2 β M2) ,	(302)
-N -
Ifwe assume that Si∩Sj 6= 0 with i 6= j, then the triangle inequality with a point from the intersection
gives
2
kxi - xjk 6 β N M .	(303)
Therefore, we have using the Cauchy-Schwarz inequality:
22
∆i 6 xi (Xi - xj) 6 kxik kxi - xjk 6 M β N M = β N .	(304)
The last inequality is a contraction to Eq. (302) if we assume that
1 < 2 (N - 1) N β M2 .	(305)
With this assumption, the spheres Si and Sj do not intersect. Therefore, each xi has its separate fixed
point in Si . We define
∆min = min ∆i	(306)
16i6N
45
to obtain the master inequality
△min ≥ -ɪ + 1 ln (2 N2 β M2) .	(307)
βN β
•Patterns on a sphere.
For simplicity and in accordance with the results of the classical Hopfield network, we assume all
patterns being on a sphere with radius M :
∀i : kxi k = M .	(308)
Under assumption Eq. (305) we have only to show that the master inequality Eq. (307) is fulfilled for
each xi to have a separate fixed point near each xi .
We defined αij as the angle between xi and xj . The minimal angle αmin between two data points is
αmin = min αij .	(309)
16i<j6N
On the sphere with radius M we have
△min = min M2(1 - cos(αij)) = M2(1 - cos(αmin)) ,	(310)
16i<j6N
therefore it is sufficient to show the master inequality on the sphere:
M2 (1 - cos(amin)) ≥ β N + β ln (2 N2 β M2) .	(311)
Under assumption Eq. (305) we have only to show that the master inequality Eq. (307) is fulfilled
for △min . We consider patterns on the sphere, therefore the master inequality Eq. (307) becomes
Eq. (311). First we show results when pattern positions on the sphere are constructed and △min is
ensured. Then we move on to random patterns on a sphere, where △min becomes a random variable.
•Storage capacity for patterns placed on the sphere.
Next theorem says how many patterns we can stored (fixed point with attraction basin near pattern) if
we are allowed to place them on the sphere.
Theorem A3 (Storage Capacity (M=2): Placed Patterns). We assume β = 1 and patterns on
the sphere with radius M. If M = 2√d — 1 and the dimension d of the space is d ≥ 4 or if
M = 1.7ʌ/d — 1 and the dimension d Ofthe space is d ≥ 50, then the number ofpatterns N that can
be stored (fixed point with attraction basin near pattern) is at least
N = 22(d-1) .	(312)
Proof. For random patterns on the sphere, we have to show that the master inequality Eq. (311)
holds:
M2 (1 - cos(amin)) ≥ Q N + 万 ln (2 N2 β M2) .	(313)
βN β
We now place the patterns equidistant on the sphere where the pattern are separated by an angle αmin :
∀i : min αij = αmin
j,j 6=i
In a d-dimensional space we can place
(314)
2π	d-1
(315)
αmin
points on the sphere. In a spherical coordinate system a pattern differs from its most closest patterns
by an angle αmin and there are d — 1 angles. Solving for αmin gives
2π
αmin = Nι∕(d-i).
(316)
N
46
The number of patterns that can be stored is determined by the largest N that fulfils
M2 (1 - cos (Ni2π-1))) ≥ β2N + 1ln(2 N2 βM2).	(317)
We setN = 22(d-1) and obtain for Eq. (317):
M2 (1 - cos (2)) ≥ β 23(d-1) + β ln (2 β M2) + β 4(d - I)In2 .	(318)
This inequality is equivalent to
β M2 ≥ 22(d-1)-1 + ln (2 β M2) + 4 (d - I)In 2 .	(319)
The last inequality can be fulfilled with M = K√d - 1 and proper K. For β = 1, d = 4 and K = 2
the inequality is fulfilled. The left hand side minus the right hand side is 4(d - 1) - 1/22(d-1)-1 -
ln(8(d - 1)) -4(d- 1) ln2. Its derivative with respect to d is strict positive. Therefore, the inequality
holds for d ≥ 4.
For β = 1, d = 50 and K = 1.7 the inequality is fulfilled. The left hand side minus the right hand
side is 2.89(d - 1) - 1/22(d-1)-1 - ln(5.78(d - 1)) - 4(d - 1) ln 2. Its derivative with respect to d
is strict positive. Therefore, the inequality holds for d ≥ 50.
□
If we want to store considerably more patterns, then we have to increase the length of the vectors or
the dimension of the space where the vectors live. The next theorem shows results for the number of
patterns N with N = 23(d-1).
Theorem A4 (Storage Capacity (M=5): Placed Patterns). We assume β = 1 and patterns on
the sphere with radius M. If M = 5 ʌ/d — 1 and the dimension d of the space is d ≥ 3 or if
M = 4ʌ/d — 1 and the dimension d ofthe space is d ≥ 13, then the number ofpatterns N that can
be stored (fixed point with attraction basin near pattern) is at least
N = 23(d-1) .	(320)
Proof. We set N = 23(d-1) and obtain for Eq. (317):
M2 (1 - cos (∏)) ≥ β⅛) + 1ln (2 βM2) + 16(d- 1)ln2 .	(321)
This inequality is equivalent to
βM2 (1 - √2) ≥ 23(d-1)-1 + ln (2 βM2) + 6(d - 1)ln2 .	(322)
The last inequality can be fulfilled with M = K√d - 1 and proper K. For β = 1, d = 13 and
K = 4 the inequality is fulfilled. The left hand side minus the right hand side is 4.686292(d -
1) - 1/23(d-1)-1 - ln(32(d - 1)) - 6(d - 1) ln 2. Its derivative with respect to d is strict positive.
Therefore, the inequality holds for d ≥ 13.
For β = 1, d = 3 and K = 5 the inequality is fulfilled. The left hand side minus the right hand side
is 7.32233(d - 1) - 1/23(d-1)-1 - ln(50(d - 1)) - 6(d - 1) ln 2. Its derivative with respect to d is
strict positive. Therefore, the inequality holds for d ≥ 3.
□
•Storage capacity for random patterns on the sphere.
47
Next we investigate random points on the sphere. Under assumption Eq. (305) we have to show
that the master inequality Eq. (311) is fulfilled for αmin, where now αmin is now a random variable.
We use results on the distribution of the minimal angles between random patterns on a sphere
according to Cai et al. (2013) and Brauchart et al. (2018). Theorem 2 in Cai et al. (2013) gives the
distribution of the minimal angle for random patterns on the unit sphere. Proposition 3.5 in Brauchart
et al. (2018) gives a lower bound on the probability of the minimal angle being larger than a given
constant. We require this proposition to derive the probability of pattern having a minimal angle
αmin. Proposition 3.6 in Brauchart et al. (2018) gives the expectation of the minimal angle.
We will prove high probability bounds for the expected storage capacity. We need the following
tail-bound on αmin (the minimal angle of random patterns on a sphere):
Lemma A13 ((Brauchart et al., 2018)). Let d be the dimension of the pattern space,
.=1	Γ((d +1)/2)
Kd := d √∏	Γ(d∕2).
and δ > 0 such that κd2-1 δ(d-1) 6 L Then
Pr(Nd-1 αmin ≥ δ) ≥ 1 - K- δd-1 .
(323)
(324)
Proof. The statement of the lemma is Eq. (3-6) from Proposition 3.5 in Brauchart et al. (2018). □
Next we derive upper and lower bounds on the constant κd since we require them later for proving
storage capacity bounds.
Lemma A14. For κd defined in Eq. (323) we have the following bounds for every d ≥ 1:
-------1 ,	6 Kd 6 exp(1/12)
exp(1/6) eπd	2πd
<1.
(325)
Proof. We use for x > 0 the following bound related to Stirling’s approximation formula for the
gamma function, c.f. (Olver et al., 2010, (5.6.1)):
1
< Γ(x) (2 π)- 1X1 - X exp(x)
< exp(⅛
(326)
Using Stirling’s formula Eq. (326), we upper bound Kd:
_	1	Γ((d + 1)/2)	1 exp (6(d+1)) exp (- d+1)(d+1 )2
= - ;= -，_ ∙_:--- < - =-------------------;--:------
d √π	r(d/2)	d √π	exp (- d) (d) d - 1
1	/	1	\ /	1、2 d exp (*)
d√πeexpl6(d+i)J [1 + d) V2 6 √2^√d.
(327)
For the first inequality, We applied Eq. (326), while for the second We used (1 + d )d < e for d ≥ 1.
Next, we lower bound Kd by again applying Stirling’s formula Eq. (326):
d
=ɪ Γ((d +1)/2) > ɪ exp (-号)(d+1 )2
d √π	r(d/2)	d √π exp (61d) exp (-d)(d) d-1
d I--
______1	— y rd ≥_________1_____,
d √πe exp (61d)__________________________d) V 2 exp (1) √eπd
where the last inequality holds because of monotonicity of (1 + d )d and using the fact that for d = 1
it takes on the value 2.	□
We require a bound on cos to bound the master inequality Eq. (311).
48
Lemma A15. For 0 6 x 6 π the function cos can be upper bounded by:
Cos(X) 6 1 — x- .	(329)
5
Proof. We use the infinite product representation of cos, c.f. (Olver et al., 2010, (4.22.2)):
∞	4 x2
Cos(X) = Y (1 - (2n - 1)2 ∏2
n=1
Since it holds that
1____4x— 6 1
(2n — 1)2 π2
(330)
(331)
for |x| 6 π and n ≥ 2, we can get the following upper bound on Eq. (330):
cos(x) 6
n=1
4 x2
1 —---------—
(2n — 1)2π2
—
1 —与
π2
4 x2
9 π2
(332)
1—
1—
40 x2
9 π2
24 x2
9 π2
16 x4
E61
40 x2 16 x2
9 π2 + 9 π2
1—
2
x2
^5
+
6
The last but one inequality uses X 6 π, which implies x∕π 6 1. Thus Eq. (329) is proven.
□
•Exponential storage capacity: the base c as a function of the parameter β, the radius of the sphere
M, the probability p, and the dimension d of the space.
We express the number N of stored patterns by an exponential function with base c > 1 and an
exponent linear in d. We derive constraints on he base c as a function of β, the radius of the sphere
M , the probability p that all patterns can be stored, and the dimension d of the space. With β > 0,
K > 0, and d ≥ 2 (to ensure a sphere), the following theorem gives our main result.
Theorem A5 (Storage Capacity (Main): Random Patterns). We assume a failure probability 0 <
P 6 1 and randomly chosen patterns on the sphere with radius M := K√d — 1. We define
2
a :=———-(1 + ln(2 β K2 P (d - 1))) , b :
b
2 K2 β
5
C :=----：---：------—.
Wo(eχp(α + ln(b))
(333)
where W0 is the upper branch of the Lambert W function (Olver et al., 2010, (4.13)) and ensure
4
d — 1
c≥
(334)
Then with probability 1 — P, the number of random patterns that can be stored is
d—1
N ≥ pc c "ɪ .
(335)
Therefore it is proven for c ≥ 3.1546 with β = 1, K = 3, d = 20 andP = 0.001 (a + ln(b) > 1.27)
and proven for c ≥ 1.3718 with β = 1, K = 1, d = 75, andP = 0.001 (a + ln(b) < —0.94).
Proof. We consider the probability that the master inequality Eq. (311) is fulfilled:
Pr M2(1 — Cos(αmin))) ≥
2
βN
1 ln(2 N2 βM2)) ≥ 1 — p .
(336)
49
Using Eq. (329), we have:
1 - coSmmin) ≥ 1 αmin .
Therefore, with probability 1 - p the storage capacity is largest N that fulfills
Pr	αmin
5
This inequality is equivalent to
β2N + 1ln (2 N 2 βM 2)) ≥ 1 — P.
ββ
Pr N d-1 αmin ≥
√5 N d-1
-2- + 1 ln (2 N2 βM2
βN + β ' β
≥ 1 - p.
We use Eq. (324) to obtain:
Pr 卜d-1 αmin ≥√5M-1 (号 + 1ln(2 N 2 βM 2
d-1
≥ 1 - κd-1 5d-1 N2 M-(d-1) (-2- + 1 ln (2 N2 β M2)) ,
2	βN β
For Eq. (339) to be fulfilled, it is sufficient that
d-1
号 5d-1 N2 MTdT β-NN + 1ln(2 N2 BM)Y-P 6 0 .
(337)
(338)
(339)
(340)
(341)
≥
M
If we insert the assumption Eq. (334) of the theorem into Eq. (335), then we obtain N ≥ 2. We now
apply the upper bound κd-ι∕2 < κd-ι < 1 from Eq. (325) and the upper bound βN 6 β from
N ≥ 2 to inequality Eq. (341). In the resulting inequality We insert N = √pcd-1 to check whether
it is fulfilled with this special value of N and obtain:
5 d-1 p C d-1 M TdT) fɪ + 1 ln(2 Pc d-1 βM2
ββ
d-1
~7Γ~
6 p.
(342)
Dividing by p, inserting M = K√d - 1, and exponentiation of the left and right side by d-ɪ gives:
K 2 ↑d- 1) (1 + 1 ln (2 βc d-1 pK2 (d — 1))) — 1 6 0 .
After some algebraic manipulation, this inequality can be written as
a c + c ln(c) - b 6 0 ,
where we used
2
a :=———-(1 + ln(2 β K2 P (d - 1))) , b :
2 K2 β
-5-
We determine the value c of c which makes the inequality Eq. (344) equal to zero. We solve
a c + c ln(^) — b = O
(343)
(344)
(345)
for c:
ac + c ln(^) - b = O	(346)
⇔ a + ln(c) = b/c
⇔ a + ln(b) + ln(c∕b) = b/c
⇔ b/c + ln(b∕c) = a + ln(b)
⇔ b/c exp(b∕^) = exp(α + ln(b))
⇔ b/c = Wo(exp(a + ln(b)))
b
⇔ c =-------:----:--------.
Wo(exp(a + ln(b))
50
where W0 is the upper branch of the Lambert W function (see Def. A6). Hence, the solution is
C =	.
W0 (exp(a + ln(b))
(347)
The solution exist, since the Lambert function W0(x) (Olver et al., 2010, (4.13)) is defined for
-1/e < x and we have 0 < exp(a + ln(b).
Since C fulfills inequality Eq. (344) and therefore also Eq. (342), We have a lower bound on the
storage capacity N:
(348)
Next we aim at a lower bound on C which does not use the Lambert W function (Olver et al., 2010,
(4.13)). Therefore, we upper bound W0(exp(a + ln(b)) to obtain a lower bound on C, therefore, also
a lower bound on the storage capacity N. The lower bound is given in the next corollary.
Corollary A1. We assume a failure probability 0 < p 6 1 and randomly chosen patterns on the
sphere with radius M = K√d — 1. We define
2
a := d一ι (1 + ln(2 β K2 P (d — 1))),
2 K2 β
b :=------
5
Using the omega COnStant Ω ≈ 0.56714329 we set
b ιrι (ω exp(a + InQ)) + 1、
b ln 1	Ω(1 + Ω) J
a + ln(b)
b (a + ln(b))-a + ln(b) + 1
for a + ln(b) 6 0 ,
for a + ln(b) > 0
(349)
and ensure
C≥
(350)
Then with probability 1 — p, the number of random patterns that can be stored is
一 d-1
N ≥ √pc — .	(351)
Examples are C ≥ 3.1444 for β = 1, K = 3, d = 20 and p = 0.001 (a + ln(b) > 1.27) and
C ≥ 1.2585 for β = 1 K = 1, d = 75, andp = 0.001 (a + ln(b) < —0.94).
Proof. We lower bound the C defined in Theorem A5. According to (Hoorfar & Hassani, 2008,
Theorem 2.3) We have for any real U and y > e:
…(U)) 6 ln (*⅛+f
(352)
C
b
_ d— 1
N ≥ √p C —.
4
d— 1
□
To upper bound W0(x) for x ∈ [0, 1], We set
y = 1∕Wo(1) = 1∕Ω = expΩ = — 1∕lnΩ ≈ 1.76322 ,
where the Omega constant Ω is
Ω
(353)
dt
-∞ (et — t)2 + ∏2
-1
— 1 ≈ 0.56714329.
(354)
∞
See for these equations the special values of the Lambert W function in Lemma A31. We have the
upper bound on W0:
exp(u) + 1∕Ω∖	1 ΩΩ exp(u) + 1
W0(eXP(U)) 6 M 1 + ln(1∕Ω) ) = M Ω(1+ Ω)
(355)
51
At the right hand side of interval [0, 1], we have u = 0 and exp(u) = 1 and get:
ln (Ω(l1+⅛) = ln (力=-Ing) = O = W0⑴.	(356)
Therefore, the bound is tight at the right hand side of of interval [0, 1], that is for exp(u) = 1, i.e.
u = 0. We have derived an bound for W0(exp(u)) with exp(u) ∈ [0, 1] or, equivalently, u ∈ [-∞, 0].
We obtain from Hoorfar & Hassani (2008, Corollary 2.6) the following bound on W0(exp(u)) for
1 < exp(u), or, equivalently 0 < u:
u
Wo(exp(u)) 6 U1 + U .
(357)
A lower bound on c is obtained via the upper bounds Eq. (357) and Eq.(355) on Wo as Wo > 0. We
set u = a + ln(b) and obtain
{in (ω exp(a + In(I)) + 1 ʌ 1
I ω (1 + P+ ln(bj
(a + ln(b))- a + ln(b) + 1
for a + in(b) 6 0 ,
for a + in(b) > 0
(358)
We insert this bound into Eq. (347), the solution for c, to obtain the statement of the theorem.
□
•Exponential storage capacity: the dimension d of the space as a function of the parameter β, the
radius of the sphere M, and the probability p.
We express the number N of stored patterns by an exponential function with base c > 1 and an
exponent linear in d. We derive constraints on the dimension d of the space as a function of β,
the radius of the sphere M , the probability p that all patterns can be stored, and the base of the
exponential storage capacity. The following theorem gives this result.
Theorem A6 (Storage Capacity (d computed): Random Patterns). We assume a failure probability
0 < p 6 1 and randomly chosen patterns on the sphere with radius M = Kyd _ 1. We define
B, b:
a = *)
d = {1；
5c
a W(a exp(-b))
exp(-b)
1 + in (2 pβK2),
for a 6= 0 ,
for a = 0 ,
(359)
—
where W is the Lambert W function (Olver et al., 2010, (4.13)). For 0 < a the function W is the
upper branch W0 and for a < 0 we use the lower branch W-1. If we ensure that
4
C ≥ (√p)	,	- e 6 a eχp(-b),	(360)
then with probability 1 - p, the number of random patterns that can be stored is
一 d-1
N ≥ √p CF .	(361)
Proof. We consider the probability that the master inequality Eq. (311) is fulfilled:
Pr (M 2(1 - cos(amin))) ≥ βN + - in (2 N2 βM 2)) ≥ 1 - p.
(362)
Using Eq. (329), we have:
1 - cos(αmin) ≥ - αmin .
Therefore, with probability 1 - p the storage capacity is largest N that fulfills
Pr
(2庐 αmin
≥ β2N + 1ln(2N2 BM2))
≥ 1 - p.
(363)
(364)
52
This inequality is equivalent to
Pr (N d-1 αmin ≥ √5 N j (ɪ + 1 ln(2 N2 βM2))] ≥ 1 - p. (365)
M βN β
We use Eq. (324) to obtain:
Pr (Nd-1 αmin ≥ √5M—~ (β2N + 1 ln (2 N2 β M2)) )	(366)
d-1
≥ 1 - κd-1 5d-1 N2 MTdT)
-	2
For Eq. (365) to be fulfilled, it is sufficient that
d-1
κd-1 5d-1 N2 MTdT) (βN + 1 ln (2 N2 βM2)) 2 - P 6 0 .	(367)
β2N + 1ln(2 N 2 βM 2))
If we insert the assumption Eq. (360) of the theorem into Eq. (361), then we obtain N ≥ 2. We now
apply the upper bound κd-1∕2 < κd-1 < 1 from Eq. (325) and the upper bound βN 6 β from
N ≥ 2 to inequality Eq. (367). In the resulting inequality We insert N = √pcd-1 to check whether
it is fulfilled with this special value of N and obtain:
d-1
5d-1 Pcd-1 MTdT) (1 + 1 ln(2Pcd-1 βM2)) 2 6 p .	(368)
Dividing by p, inserting M = K√d - 1, and exponentiation of the left and right side by d-ɪ gives:
K⅛) (1 + 1ln(2βcd-1 PK2 (d- 1)))- 1 6 0.	(369)
This inequality Eq. (369) can be reformulated as:
1 + ln(2 p β cd-1 K2 (d - 1)) - (d - 1) K β 6 0 .	(370)
5c
Using
a := ln2c) - K2cβ， b ：= 1 + ln (2PeK2),
(371)
we write inequality Eq. (370) as
ln(d - 1) + a(d- 1) + b 6 0 .	(372)
We determine the value d of d which makes the inequality Eq. (372) equal to zero. We solve
, , O .	, O .	.
ln(d - 1) + a (d - 1) + b = 0 .	(373)
. O
for d
For a 6= 0 we have
,	, O .	, O .	.
ln(d - 1) + a (d - 1) + b = 0	(374)
⇔ a (d - 1) + ln(d - 1) = - b
⇔ (d - 1) exp(a (d - 1)) = exp(-b)
⇔ a (d — 1)exp(a (d — 1)) = a exp(-b)
⇔ a (d - 1) = W(a exp(-b))
1
⇔ d — 1 = — W (a exp(-b))
1
⇔ d = 1 + — W (a exp(-b)),
53
where W is the Lambert W function (see Def. A6). For a > 0 we have to use the upper branch W0
of the Lambert W function and for a < 0 we use the lower branch W-1 of the Lambert W function
(Olver et al., 2010, (4.13)). We have to ensure that -1/e 6 a exp(-b) for a solution to exist. For
a = 0 we have d = 1 + exp(-b).
Hence, the solution is
1
d = 1 + - W (a exp(-b)) .	(375)
Since d fulfills inequality Eq. (369) and therefore also Eq. (368), we have a lower bound on the
storage capacity N:
一 d-1
N ≥ √p C- .	(376)
□
Corollary A2. We assume a failure probability 0 < p 6 1 and randomly chosen patterns on the
sphere with radius M = K√d — 1. We define
a :=竽-κ52cβ , b := 1 + ln(2 pβK2),
d =1 + -(- ln(-a) + b) ,	(377)
a
and ensure
4
c ≥ (_)	,	— — 6 a exp(—b) , a < 0 ,	(378)
then with probability 1 - p, the number of random patterns that can be stored is
一 d-1
N ≥ √p CF .	(379)
Setting β = 1, K = 3, c = 2 andp = 0.001 yields d < 24.
Proof. For a < 0 the Eq. (359) from Theorem (A6) can be written as
d = 1 + W-i(aexp(-b))=]+ W-i(- exp (-(- ln(-a) + b - 1) - 1))
aa
From Alzahrani & Salem (2018, Theorem 3.1) we get the following bound on W-1:
e
------1 (U + 1) < W-ι(— exp(—U — 1)) < 一 (U + 1).
for u > 0. We apply Eq. (381) to Eq. (380) with u = - ln(-a) + b - 1.
Since a < 0 we get
d > 1 + -ln(-a) + b
a
(380)
(381)
(382)
□
•Storage capacity for the expected minimal separation instead of the probability that all patterns can
be stored. In contrast to the previous paragraph, we want to argue about the storage capacity for the
expected minimal separation. Therefore, we will use the following bound on the expectation of αmin
(minimal angle), which gives also a bound on the expected of ∆min (minimal separation):
Lemma A16 (Proposition 3.6 in Brauchart et al. (2018)). We have the following lower bound on the
expectation of αmin :
2	Γ(d)	A d-1 ,	1	,	d- d-1
E NE amin ≥	---------巴一丁丁	Γ(1 +------)----------L := Cd-ι. (383)
2(d - 1) √∏ Γ(d-1)	d - VΓ(2+ d-τ)	d1 '	)
The bound is valid for all N ≥ 2 and d ≥ 2.
54
Let us start with some preliminary estimates. First of all we need some asymptotics for the constant
Cd-1 in Eq. (383):
Lemma A17. The following estimate holds for d ≥ 2:
ln(d +1)
Cd ≥ 1 ---------;---
d
(384)
Proof. The recursion formula for the Gamma function is (Olver et al., 2010, (5.5.1)):
Γ(x + 1) = x Γ(x) .	(385)
We use Eq.(325) and the fact that dd ≥ 1 for d ≥ 1 to obtain:
Cd ≥ (2 √d)dΓ(1 + d) (d +1)- d = (2 √d)d (d +1)- d > (d +1)d (386)
d r(2 + d)	1 - d
=exp(-； ln(d +1)) ≥ 1 — ɪ ln(d + 1),
where in the last step we used the elementary inequality exp(x) ≥ 1 + x, which follows from the
mean value theorem.	□
The next theorem states the number of stored patterns for the expected minimal separation.
Theorem A7 (Storage Capacity (expected separation): Random Patterns). We assume patterns on
the sphere with radius M = K√d — 1 that are randomly chosen. Thenfor all values C ≥ 1 for which
1	(d - 1) K2 c-1(1 - ln(d - 1) )2 ≥ τ⅛r + 1 ln(2 Cd-1 β (d - 1) K2)	(387)
5	(d - 1) β C-ɪ β ∖	/
holds, the number of stored patterns for the expected minimal separation is at least
d-1
N = C F .	(388)
The inequality Eq. (387) is e.g. fulfilled with β = 1, K = 3, C = 2 and d ≥ 17.
Proof. Instead of considering the probability that the master inequality Eq. (311) is fulfilled we now
consider whether this inequality is fulfilled for the expected minimal distance. We consider the
expectation of the minimal distance ∆min :
E[∆min] = E[M2(1 - cos(αmin)))] = M2(1 - E[cos(αmin))]) .	(389)
For this expectation, the master inequality Eq. (311) becomes
M2(1 - E[cos(αmin))]) ≥ -2- + 1 ln(2 N2 βM2) .	(390)
βN β
We want to find the largest N that fulfills this inequality.
We apply Eq. (329) and Jensen’s inequality to deduce the following lower bound:
1	- Eicos(amin)] ≥ 5 E [αmin] ≥ 5 EIamin]2 .	(391)
Now we use Eq. (383) and Eq. (384) to arrive at
E[amin]2 ≥ N-d-1 E[Nd-1 amin]2 ≥ N-d-1 Cd-I ≥ N-d-1 (1 - Iny -I) )2 , (392)
(d-1)
for sufficiently large d. Thus in order to fulfill Eq. (390), it is enough to find values that satisfy
Eq. (387).
□
55
A.1.6.2 Retrieval of Patterns with One Update and Small Retrieval Error. Retrieval of a
pattern Xi for fixed point x* and query ξ is defined Viaan e by ∣∣f (ξ) - x"∣ < e, that is, the update
is -close to the fixed point. The update rule retrieves a pattern with one update for well separated
patterns, that is, ∆i is large.
Theorem A8 (Pattern RetrieVal with One Update). With query ξ, after one update the distance of the
new point f(ξ) to the fixed point xi* is exponentially small in the separation ∆i. The precise bounds
using the Jacobian J = fξ) and its value Jm in the mean value theorem are:
∣f(ξ) - xi*∣ 6 ∣Jm∣2 ∣ξ - xi*∣ ,	(393)
∣Jm ∣2 6 2 β N M2 (N - 1) exp(- β (∆i - 2 max{∣ξ - xi ∣, ∣xi* - xi ∣} M)) .
(394)
For given e and sufficient large ∆i, we have ∣f(ξ) - xi* ∣ < e, that is, retrieval with one update.
Proof. From Eq. (180) we haVe
∣Jm∣2 6 2βNM2 (N -1)exp(-β (∆i - 2 max{∣ξ - xi∣,∣xi* - xi∣}M)) . (395)
After eVery iteration the mapped point f(ξ) is closer to the fixed point xi* than the original point xi:
∣f(ξ) - xi*∣ 6 ∣Jm∣2∣ξ - xi*∣ .	(396)
For giVen e and sufficient large ∆i, we haVe ∣f (ξ) - xi* ∣ < e, since ∣Jm∣2 foes exponentially fast
to zero with increasing ∆%.
We want to estimate how large ∆i is. For xi we haVe:
∆i = min xiT xi - xiT xj = xiT xi - max xiT xj .	(397)
j,j 6=i	i	i	i	j,j6=i i
To estimate how large ∆i is, assume Vectors x ∈ Rd and y ∈ Rd that haVe as components standard
normally distributed Values. The expected Value of the separation of two points with normally
distributed components is
d	dd
E xTx - xTy = XE xj2 + XE [xj] XE [yj] = d .	(398)
The Variance of the separation of two points with normally distributed components is
Var [xτx — xTy] = E [(xτX — XTy)2] — d2	(399)
dd	d
= XE[xj4]	+ X E[xj2]	E[x2k]	— 2 XE[xj3]E[yj]	—
j=1	j=1,k=1,k6=j	j=1
dd
2 X E [xj2] E [xk] E [yk] + XE [xj2] E [yj2] +
j=1,k=1,k6=j	j=1
d
X	E [xj] E [yj] E [xk] E [yk] — d2
j=1,k=1,k6=j
= 3d + d(d— 1) + d — d2 = 3d.
The expected Value for the separation of two random Vectors giVes:
kJm∣2 6 2 βNM2 (N — 1)exp(- β (d - 2 max{∣ξ — Xik,∣x* - Xi∣} M)) .	(400)
For the exponential storage We set M = 2√d — 1. We see the Lipschitz constant IlJmk2 decreases
exponentially with the dimension. Therefore, ∣f(ξ) — xi* ∣ is exponentially small after just one
update. Therefore, the fixed point is well retrieVed after one update.
The retrieVal error decreases exponentially with the separation ∆i .
56
Theorem A9 (Exponentially Small Retrieval Error). The retrieval error kf (ξ) - xi k of pattern xi
is bounded by
kf(ξ) - XiIl 6 2(N - 1) exp(- β (∆i - 2 max{∣∣ξ - Xik, ||x； - Xi∣∣} M)) M (401)
andfor Ilxi — x"∣ 6 2^1M together with Ilxi - ξ∣∣ 6 号M by
Ilxi - xik 6 2 e (N - 1) M exp(- β ∆i) .	(402)
Proof. We compute the retrieval error which is just If(ξ) - xiI. From Lemma A4 we have
Ixi - f(ξ)I 6 2M,	(403)
From Eq. (179) we have
e = (N - 1)exp(- β (∆i - 2 max{∣ξ - xi∣∣,∣H - xik} M)) .	(404)
For kxi - xi k 6 2βM and kxi - ξk 6 2βM Eq. (404) gives
e 6 e (N - 1) M exp(- β ∆i) .	(405)
□
A.1.7 Learning Associations
We consider three cases of learning associations, i.e. three cases of how sets are associated. (i) Non
of the sets is mapped in an associative space. The raw state pattern rn is the state (query) pattern
ξn, i.e. ξn = rn, and the raw stored pattern ys is the stored pattern (key), i.e. xs = ys . (ii) Either
one of the sets is mapped to the space of the other set or an association matrix is learned. (iia) The
state patterns are equal to the raw patterns, i.e. ξn = rn, and raw stored patterns are mapped via
W to the space of the state patterns, i.e. xs = Wys. (iib) The stored patterns are equal to the raw
patterns, i.e. xs = ys, and raw state patterns are mapped via W to the space of the stored patterns,
i.e. ξn = WTrn. (iic) The matrix W is an association matrix. We will compute the derivative of
the new state pattern with respect to W, which is valid for all sub-cases (iib)-(iic). (iii) Both set of
patterns are mapped in a common associative space. A raw state pattern rn is mapped by WQ to a
state pattern (query) ξn, that is ξn = WQrn . A raw stored pattern ys is mapped via WK to stored
pattern (key) xs, that is xs = WKys. We will compute the derivative of the new state pattern with
respect to both WQ and WK .
A.1.7.1 Association of Raw Patterns - No Mapping in an Associative Space. The sets are
associated via their raw patterns, i.e. the raw state pattern rn is the state (query) pattern ξn, i.e.
ξn = rn, and raw stored pattern ys is the stored pattern (key), i.e. xs = ys. There is no mapping in
an associative space.
The update rule is
ξnew = X p ,	(406)
where we used
p = softmax(β XTξ) .	(407)
The derivative with respect to ξ is
∂ξnew
β X (diag(p) - PPT) XT
(408)
The derivative with respect to X is
∂aτ ξnew
∂ X
apτ + β X (diag(p) - ppτ) (ξτa).
(409)
These derivatives allow to apply the chain rule if a Hopfield layer is integrated into a deep neural
network.
57
A.1.7.2 Learning an Association Matrix - Only One Set is Mapped in an Associative Space.
Only one of the sets R or Y is mapped in the space of the patterns of the other set. Case (a): the
state patterns are equal to the raw patterns ξn = rn and raw stored patterns are mapped via W to
the space of the state patterns, i.e. xs = Wys. Case (b): the stored patterns are equal to the raw
patterns xs = ys and raw state patterns are mapped via W to the space of the stored patterns, i.e.
ξn = W T rn . Case (c): the matrix W associates the sets R and Y . This case also includes that
W T = WKT WQ , which is treated in next subsection. The next subsection focuses on a low rank
approximation of W by defining the dimension dk of associative space and use the matrices WKT
and WQ to define W , or equivalently to map R and Y into the associative space.
From a mathematical point of view all these case are equal as they lead to the same update rule.
Therefore, we consider in the following Case (a) with xs = Wys and ξn = rn. Still, the following
formula are valid for all three cases (a)-(c).
The update rule is
ξnew = W Y p ,	(410)
where we used
p = softmax(β YTWTξ) .	(411)
We consider the state (query) pattern ξ with result ξnew :
ξnew = W Y p = W Y softmax(βYTWTξ)	(412)
For multiple updates this update rule has to be used. However for a single update, or the last update
we consider a simplified update rule.
Since new state vector ξnew is projected by a weight matrix WV to another vector, we consider the
simplified update rule:
	ξnew =	Yp = Y softmax(β YTWTξ)		(413)
The derivative with respect to W is				
∂aT ξnew	∂ ξnew	∂aT ξnew	∂ξnew ∂(WT ξ)	∂aT ξnew	
∂W	=∂W	∂ξnew	= ∂(W T ξ)	∂W	∂ ξnew	.	(414) (414)
	∂ξnew d(WTξ) = β Y (diag(P)- ppT) YT			(415)
∂aT ξnew
∂ξnew
a.
(416)
We have the product of the 3-dimensional tensor d(∂Wwξ with the vector a which gives a 2-
dimensional tensor, i.e. a matrix:
∂(WTξ) ∂aTξnew _ ∂(WTξ)
∂W	∂ξnew	=	∂W
(417)
∂aTξnew
∂W
β Y (diag(p) - Ppr) YT(ξτa) = J (ξτa),
where J is the Jacobian of the update rule defined in Eq. (59).
To obtain the derivative of the full update rule Eq. (412) we have to add the term
a pTYT
and include the factor W to get
∂aTξnew
∂W
a pTYT
a pTYT
+ β W Y (diag(p) - ppT) YT(ξra)
+ W J (ξTa) .
(418)
(419)
(420)
58
A.1.7.3 Learning Two Association Mappings - Both Sets are Mapped in an Associative Space.
Both sets R and Y are mapped in an associative space. Every raw state pattern rn is mapped via
WQ to a state pattern (query) ξn = WQrn . Every raw stored pattern ys is mapped via WK to a
stored pattern (key) xs = WKys. In the last subsection we considered a single matrix W. For
W T = WKT WQ we have the case of the last subsection. However in this subsection we are looking
for a low rank approximation of W . Toward this end we define the dimension dk of associative space
and use the matrices WKT and WQ to map to the associative space.
The update rule is
ξnew = X p ,	(421)
where we used
p = softmax(β XTξ) .	(422)
We consider raw state patterns rn that are mapped to state patterns ξn = WQrn with QT =
Ξ = WQR and raw stored pattern ys that are mapped to stored patterns xs = WKys with
KT = X = WKY . The update rule is
ξnew = WK Y p = WK Y softmax(β YTWKTWQ r) .	(423)
Since new state vector ξnew is projected by a weight matrix WV to another vector, we consider the
simplified update rule:
ξnew = Y p = Y softmax(β YTWKTWQ r) .	(424)
For the simplified update rule, the vector ξnew does not live in the associative space but in the space
of raw stored pattern y. However WK would map it to the associative space.
•Derivative with respect to WQ. The derivative with respect to WQ is
∂aT ξnew	∂ξnew ∂aT ξnew
—：------=--------—：------
∂ Wq	∂Wq	∂ξnew
∂ξnew	∂(Wq r) ∂aτξnew
∂(WQ r)	∂Wq	∂ξnew
(425)
∂ξnew
∂(WQ r)
β Y (diag(p) - PpT) YT WK
(426)
∂aT ξnew
∂ξ new
a.
(427)
We have the product of the 3-dimensional tensor d∂WQr) With the vector a which gives a 2-
dimensional tensor, i.e. a matrix:
∂(Wq r) ∂aτξnew
∂Wq	∂ξnew
∂(Wq r)
∂Wq
a = rTaI .
(428)
∂ ατ ξnew
∂ WQ
β Y (diag(p) - ppτ) YT WK(rτa) = J WK(rτa) ,	(429)
where J is the Jacobian of the update rule defined in Eq. (59).
To obtain the derivative of the full update rule Eq. (423) we have to include the factor WK , then get
∂aτ ξnew
∂Wq
β Wk Y (diag(p) - ppτ) YT WKK(rτa) = WK J WK (rτa).
(430)
•Derivative with respect to WK. The derivative with respect to WK is
∂aτ ξnew	∂ξnew ∂aτ ξnew	∂ξnew	∂(WKτWQ r) ∂aτ ξnew
-:	 = -----:	 = -:-m----------:----:-
∂WK------------------------------------------∂Wk-∂ξnew-∂(WTWQ r)-∂Wk-∂ξnew
(431)
59
∂ξnew
∂(WKWq r)
β Y (diag(p) 一 PpT) YT
(432)
∂aT ξnew
∂ξnew
a.
(433)
We have the product of the 3-dimensional tensor 'WW^ with the vector a which gives a 2-dimensional
tensor, i.e. a matrix:
∂(WKWq r) ∂aτξnew
∂Wk	∂ξnew
d(WWK^ a =WgTTaI
(434)
∂aTξnew
∂WK
β Y (diag(p) - Ppr) YT(WQIrTa) = J(WQIrTa),
(435)
where J is the Jacobian of the update rule defined in Eq. (59).
To obtain the derivative of the full update rule Eq. (423) we have to add the term
a pTYT	(436)
and to include the factor WK, then get
∂aTξnew
∂Wκ	= a PT Y T + β WK Y (diag(p) - PpT) Y T (WQI rT a)	(437)
= a pTYT + WK J (WQT rT a) .
A.1.8 Infinite Many Patterns and Forgetting Patterns
In the next subsection we show how the new Hopfield networks can be used for auto-regressive tasks
by causal masking. In the following subsection, we introduce forgetting to the new Hopfield networks
by adding a negative value to the softmax which is larger if the pattern was observed more in the past.
A.1.8.1 Infinite Many Patterns. The new Hopfield networks can be used for auto-regressive
tasks, that is time series prediction and similar. Causal masking masks out the future by a large
negative value in the softmax.
We assume to have infinite many stored patterns (keys) x1 , x2 , . . . that are represented by the infinite
matrix
X = (x1, x2, . . . , ) .
The pattern index is now a time index, that is, we observe xt at time t.
The pattern matrix at time t is
The query at time t is ξt .
Xt = (x1 , x2, . . . , xt) .
For Mt = max16i6t kxtk, the energy function at time t is Et
Et
一 lse(β, Xtr ξt) + 2 ξT ξt + β-1 ln t + 2 Mt
―β-1 ln (X exp(βxTξt)) + 1 ξTξt + β-1 lnt + 1 Mt .
(438)
(439)
(440)
(441)
The update rule is
ξtnew = Xtpt = Xt softmax(β XtT ξt),
(442)
60
where we used
pt = softmax(β XtTξt) .
(443)
We can use an infinite pattern matrix with an infinite softmax when using causal masking. The pattern
matrix at time t is
Xt = (x1,x2, . . . ,xt, -αξt, -αξt, . . .) ,
with the query ξt and α → ∞. The energy function at time t is Et
(444)
Et
-lse(β, XT ξt) + 2 ξT ξt + β-1 ln t + 2 Mt
(445)
bαc
- β-1 ln	exp(βxiTξt) +	exp(-βαkξtk2)	+
i=1
β T ln t + 2 Mt.
For α → ∞ and kξt k > 0 this becomes
i=t+1
1T
2 ξt ξt +
(446)
Et
- lse(β, XtTξt) +
2 ξT ξt + β-1 ln t + 2 M2
(447)
- β-1 ln
exp(βxT ξt)) + 1 ξT ξt + β-1 ln t
+ 2 Mt2
(448)
t
A.1.8.2 Forgetting Patterns. We introduce forgetting to the new Hopfield networks by adding a
negative value in the softmax which increases with patterns that are more in the past.
We assume to have infinite many patterns x1 , x2 , . . . that are represented by the infinite matrix
X = (x1, x2, . . . , ) .
The pattern index is now a time index, that is, we observe xt at time t.
The pattern matrix at time t is
The query at time t is ξt .
Xt = (x1 , x2 , . . . , xt ) .
The energy function with forgetting parameter γ at time t is Et
Et
- lse(β,XTξt - Mt- 1,t- 2,..∙, O)T) + 2ξTξt + β-1 lnt + 2M2
- β-1ln X exp(βxiTξt - γ(t - i))
+ 2 ξTξt + β T ln t + 2 Mt2.
(449)
(450)
(451)
(452)
The update rule is
ξtnew = Xt pt = Xt softmax(βXtTξt) ,	(453)
where we used
pt = softmax(βXtTξt ) .	(454)
A.1.9 Number of Spurious States
The energy E is defined as
— lse(β, XTξ) + 2ξTξ + β-1 ln N + 2M2
- β-1ln X exp(βxiTξ)
+ βT ln N + 1 ξTξ + 2 M2 .
(455)
(456)
E
61
Since the negative exponential function is strict monotonic decreasing, exp(-E) has minima, where
E has maxima, and has maxima, where as has minima E.
exp(-E)
exp(lse(β, XT ξ))
NX i=1 NX 1i= NX i=
exp(βxiT ξ)
exp(βxiT ξ)
exp(β (xiT ξ
exp(- 2ξTξ)C
β-1
exp(- 1ξTξ)C
9χp(- β 2ξTE))	C
β-1
-1 ξT ξ))	C
(457)
1T
exp(2 β Xi Xi
-2 β (ξ - Xi)T(ξ - Xi)))	C
(XXλ(xi,β) G(ξ;Xi,βT I))	C,
where C is a positive constant, λ(xi, β) = exp(2βXTXi) and G(ξ; Xi, β-1I) is the Gaussian with
mean Xi and covariance matrix β-1I.
Since C is a positive constant and xβ-1 = exp(β-1 lnx) is strict monotonic for positive x, the
minima of E are the maxima of
N
X λ(Xi,β) G(ξ; Xi,β-1 I) .	(458)
i=1
In Carreira-Perpindn & Williams (2003) it was shown that Eq. (458) can have more than N modes,
that is, more than N maxima.
A.2 Properties of Softmax, Log-Sum-Exponential, Legendre Transform,
Lambert W Function
For β > 0, the softmax is defined as
Definition A1 (Softmax).
p = softmax(βX)	(459)
Pi = [softmax(βX)]i = £，(ex)、.	(460)
k exp(βxk )
We also need the log-sum-exp function (lse), defined as
Definition A2 (Log-Sum-Exp Function).
lse(β, X) = β-1 ln X exp(βxi) .	(461)
62
We can formulate the lse in another base:
βa = ^,
ln a
lse(β, x) = β-1 ln X exp(β xi)
= (βa ln a)-1 ln X exp(βa ln a xi)
= (βa)-1 loga XN aβa xi	.
In particular, the base a = 2 can be used to speed up computations.
Next, we give the relation between the softmax and the lse function.
Lemma A18. The softmax is the gradient of the lse:
Softmax(βx) = Vχlse(β, x).
(462)
(463)
(464)
In the next lemma we report some important properties of the lse function.
Lemma A19. We define
N
L := zTx - β-1 X zi ln zi	(465)
i=1
with L ≥ zT x. The lse is the maximum of L on the N -dimensional simplex D with D = {z |
Pizi = 1,0 6 zi}:
N
lse(β, x) = max zTx - β-1	zi lnzi .	(466)
z∈D
i=1
The softmax p = softmax(βx) is the argument of the maximum of L on the N -dimensional simplex
D with D = {z | Pizi = 1,0 6 zi}:
N
p = softmax(βx) = arg max zTx - β-1	zi ln zi .	(467)
z∈D
i=1
Proof. Eq. (466) is obtained from Equation (8) in Gao & Pavel (2017) and Eq. (467) from Equa-
tion (11) in Gao & PaVel (2017).	□
From a physical point of view, the lse function represents the “free energy” in statistical thermody-
namics (Gao & PaVel, 2017).
Next we consider the Jacobian of the softmax and its properties.
Lemma A20. The Jacobian Js of the softmax p = softmax(βx) is
∂softmax(βx)	T
Js =	∂x-------- = β (diag(p) — PpT) ,	(468)
which gives the elements
[Js]ij =	βpi(1-pi) fori=j .	(469)
-βpipj	for i 6= j
Next we show that Js has eigenValue 0.
Lemma A21. The Jacobian Js of the softmax function p = softmax(βx) has a zero eigenvalue with
eigenvector 1.
63
Proof.
[Js1]i = β (Pi(I- Pi) - Epipj) = β Pi(1 - EPj) =0 .	(47O)
j,j 6=i	j
□
Next we show that 0 is the smallest eigenvalue of Js, therefore Js is positive semi-definite but not
(strict) positive definite.
Lemma A22. The Jacobian Js of the softmax p = softmax(βξ) is symmetric and positive semi-
definite.
Proof. For an arbitrary z, we have
ZT (diag(p) - Ppr) Z = XPizl - (XPizi)	(471)
=	XPizi2!XPi! - XPizi!	≥ 0 .
The last inequality hold true because the Cauchy-Schwarz inequality says (aT a)(bT b) ≥ (aTb)2,
which is the last inequality with ai = zi√Pi and b = √Pi. Consequently (diag(p) - PPT) is
positive semi-definite.
Alternatively Pi Pi zi2 - (PiPizi)2 can be viewed as the expected second moment minus the mean
squared which gives the variance that is larger equal to zero.
The Jacobian is 0 < β times a positive semi-definite matrix, which is a positive semi-definite
matrix.	□
Moreover, the softmax is a monotonic map, as described in the next lemma.
Lemma A23. The softmax softmax(βx) is monotone for β > 0, that is,
(softmax(βx) - softmax(βx0))T (x - x0) ≥ 0 .	(472)
Proof. We use the version of mean value theorem Lemma A32 with the symmetric matrix Jsm =
R01 Js(λx + (1 - λ)x0) dλ:
softmax(x) - softmax(x0) = Jsm (x - x0) .	(473)
Therefore
(softmax(x) - softmax(x0))T (x - x0) = (x - x0)T Jsm (x
since Jsm is positive semi-definite. For all λ the Jacobians Js (λx +
semi-definite according to Lemma A22. Since
xTJsmx = Z xTJs(λx + (1 - λ)x0) x dλ ≥
0
x0) ≥ 0 ,	(474)
(1 - λ)x0 ) are positive
(475)
—
0
is an integral over positive values for every x, Jsm is positive semi-definite, too.
□
Next we give upper bounds on the norm of Js .
Lemma A24. For a softmax P = softmax(βx) with m = maxiPi(1 -Pi), the spectral norm of the
Jacobian Js of the softmax is bounded:
kJsk2	6	2mβ ,	(476)
kJsk1	6	2mβ ,	(477)
kJsk∞	6	2mβ .	(478)
64
In particular everywhere holds
kJsk2 6 1 β .	(479)
If pmax = maxi pi ≥ 1 - ≥ 0.5, then for the spectral norm of the Jacobian holds
kJsk2 6 2β - 22 β < 2β .	(480)
Proof. We consider the maximum absolute column sum norm
kAk1 = mjax X |aij|	(481)
i
and the maximum absolute row sum norm
kAk∞ = miax X |aij| .	(482)
j
We have for A = Js = β diag(p) - ppT
X laij| = β (Pi(I-Pi) + X Pipj) = βPi (I - 2Pi + XPj)	(483)
j	j,j 6=i	j
= 2 β Pi (1 - Pi ) 6 2 m β ,
X |aij |	= β (Pj	(1-Pj)	+ X	PjPi	) = βPj	(1 -	2Pj	+ XPi)	(484)
i	i,i6=j	i
= 2 β Pj (1 - Pj ) 6 2 m β .
Therefore, we have
kJsk1 6 2mβ,	(485)
kJsk∞ 6 2 mβ,	(486)
kJsk2 6 qjskιMsk∞ 6 2 mβ .	(487)
The last inequality is a direct consequence of Holder,s inequality.
For 0 6 Pi 6 1, we have Pi (1 - Pi) 6 0.25. Therefore, m 6 0.25 for all values ofPi.
If Pmax ≥ 1 - ≥ 0.5 ( 6 0.5), then 1 - Pmax 6 and for Pi 6= Pmax Pi 6 . The derivative
∂x(1 一 x)∕∂x = 1 一 2x > 0 for x < 0.5, therefore x(1 一 x) increases with X for X < 0.5. Using
x = 1 - Pmax and for Pi 6= Pmax x = Pi, we obtain Pi(1 - Pi) 6 (1 - ) for all i. Consequently,
we have m 6 e(1 - e).
Using the bounds on the norm of the Jacobian, we give some Lipschitz properties of the softmax
function.
LemmaA25. ThesOftmaxfunctiOn P = Softmax(βx) is (β∕2)-Lipschitz. ThesOftmaxfunctiOn P =
softmax(βx) is (2β m)-Lipschitz in a convex environment U for which m = maxx∈U maxiPi(1 一
Pi). ForPmaX = minχ∈u maxiPi = 1-e,thesoftmaxfunctionP = Softmax(βx) is (2βe)-Lipschitz.
FOrβ < 2m, the sOftmax P = softmax(β x) is cOntractive in U On which m is defined.
PrOOf. The version of mean value theorem Lemma A32 states for the symmetric matrix Jsm =
R01 J(λx + (1 一 λ)x0) dλ:
Softmax(x) 一 Softmax(x0) = Jsm (x 一 x0) .	(488)
According to Lemma A24 for all X = λx + (1 — λ)x0)
IIJs(X)∣∣2 6 2 m β,	(489)
65
where m = maxiPi(I — Pi). Since X ∈ U and x0 ∈ U We have X ∈ U, since U is convex. For
m = maxχ∈u maxipi(1 — Pi) We have fh 6 m for all fh. Therefore, We have
IlJs(X)k2 6 2 mβ	(490)
Which also holds for the mean:
IJsmI2 6 2 mβ .	(491)
Therefore,
Isoftmax(X) — softmax(X0)I 6 IJsm I2 IX — X0I 6 2 m β IX — X0 I .	(492)
From Lemma A24 We knoW m 6 1/4 globally. For Pmax = minx∈U maxi Pi = 1 — We have
according to Lemma A24: m 6 e.	□
For completeness We present a result about cocoercivity of the softmax:
LemmaA26. For m = maxχ∈u maxi pi(1 — Pi), softmaxfunction P = Softmax(βx) is 1∕(2mβ)-
cocoercive in U, that is,
(softmax(X) — softmax(X0))T (X — X0) ≥
-----^ksoftmax(X) — Softmax(X0)∣.
2mβ
(493)
In particular the SOftmaXfUnctiOn P = softmax(βx) is (2∕β)-cocoercive everywhere. With PmaX
mi□x∈u maxi Pi = 1 — e, the SOftmaXfUnctiOn P = softmax(βX) is 1∕(2βe)-cocoercive in U.
Proof. We apply the Baillon-Haddad theorem (e.g. Theorem 1 in Gao & Pavel (2017)) together With
Lemma A25.	□
Finally, We introduce the Legendre transform and use it to describe further properties of the lse. We
start With the definition of the convex conjugate.
Definition A3 (Convex Conjugate). The Convex Conjugate (Legendre-Fenchel transform) of a
function f from a Hilbert Space X to [—8, ∞] is f * which is defined as
f *(x*) = sup(xtx* — f(x)) , X* ∈ X	(494)
x∈X
See page 219 Def. 13.1 in Bauschke & Combettes (2017) and page 134 in Garling (2017). Next We
define the Legendre transform, Which is a more restrictive version of the convex conjugate.
Definition A4 (Legendre Transform). The Legendre transform of a conveX function f from a conveX
set X ⊂ Rn to R (f : X → R) is f*, which is defined as
f*(X*) = sup (XT X* — f(X)) , X* ∈ X* ,	(495)
x∈X
X* =	X* ∈ Rn | sup (XT X* — f (X)) < ∞	.	(496)
x∈X
See page 91 in Boyd & Vandenberghe (2009).
Definition A5 (Epi-Sum). Let f and g be two functions from X to (—8, ∞], then the infimal
convolution (or epi-sum) of f and g is
fg : X → [—8, 8] , X 7→ inf (f(y) +g(X — y))	(497)
y∈X
See Def. 12.1 in Bauschke & Combettes (2017).
Lemma A27. Let f and g be functions from X to (—8, 8]. Then the following hold:
1.	ConveX Conjugate of norm squared
2k.k2 .
(498)
66
2.	Convex Conjugate of a function multiplied by scalar 0 < α ∈ R
(α f/=α f"(Ja).
3.	Convex Conjugate of the sum of a function and a scalar β ∈ R
(f + β)" = f" - β.
(499)
(500)
4.	Convex Conjugate of affine transformation of the arguments. Let A be a non-singular matrix
and b a vector
(f (Ax + b))* = f * (A-Tx*) - bτA-Tx" .	(501)
5.	Convex Conjugate of epi-sums
(fg)* = f*+g* .	(502)
Proof. 1. Since h(t) := t2 is a non-negative convex function and h(t) = 0 ^⇒ t =
0 we have because of Proposition 11.3.3 in Garling (2017) that h (kxk)* = h* (kx* k).
Additionally, by example (a) on page 137 We get for 1 < p < ∞ and 1 + 1 = 1 that
Itlp *	lt*lq
(Lp-J = Lq-. Putting all together We get the desired result. The same result can also be
deduced from page 222 Example 13.6 in Bauschke & Combettes (2017).
2.	FolloWs immediately from the definition since
αf*
x*	T x*
—— =a SUP XT ——
α	x∈X α
—
SuP (xT x* - af (x)) = (af)*(x*)
x∈X
3.	(f+β)* := SuPx∈X xTx* - f(x) -β =: f* -β
4.
(f (Ax + b))* (x*) = sup (XTx* — f (Ax + b))
x∈X
= sup (Ax + b)T A-T x* - f (Ax + b) - bT A-T x*
x∈X
=sup (yTA-Tx* — f (y)) — bτA-Tx*
y∈X
=f "(A-τx*) — bτ A-T x*
5.	From Proposition 13.24 (i) in Bauschke & Combettes (2017) and Proposition 11.4.2 in
Garling (2017) We get
(f g)* (x*) = sup xTx* — inf (f (y) —g(x — y))
x∈X	y∈X
= sup xTx* — f(y) — g(x — y)
x,y∈X
=su* ((yTx* — f(y)) + ((X — y)Tx* — g(x — y)))
= f,*(x*) + g*(x*)
□
Lemma A28. The Legendre transform of the lse is the negative entropy function, restricted to the
probability simplex and vice versa. For the log-sum exponential
f(x) = ln X exp(xi)
(503)
67
the Legendre transform is the negative entropy function, restricted to the probability simplex:
f *(x*)
Ei=I xi In(W)
∞
for 0 6 琮 and Pn=I 琮=1
otherwise
(504)
For the negative entropy function, restricted to the probability simplex:
f(x)
Pin=1 xiln(xi) for 0 6 xi and Pin=1 xi = 1
∞	otherwise
(505)
the Legendre transform is the log-sum exponential
f*(x*) = ln (XXexp(W)
(506)
Proof. See page 93 Example 3.25 in Boyd & Vandenberghe (2009) and (Gao & Pavel, 2017). If
f is a regular convex function (lower semi-continuous convex function), then f** = f according
to page 135 Exercise 11.2.3 in Garling (2017). If f is lower semi-continuous and convex, then
f ** = f according to Theorem 13.37 (Fenchel-MoreaU) in BaUschke & Combettes (2017). The
log-sum-exponential is continuous and convex.	□
Lemma A29. Let XXT be non-singular and X a Hilbert space. We define
X* = {a | 0 6 XT (XXT)-1 a , ITXT (XXT)-1 a = l} .	(507)
and
XV = {a | a = XTξ , ξ ∈ X} .	(508)
The Legendre transform of lse(β, XTξ ) with ξ ∈ X is
(lse(β, Xtξ))* (ξ*) = (lse(β, v))* (XT (XXT)-1 ξ*) ,	(509)
with ξ* ∈ X* and V ∈ XV. The domain of (lse(β, XTξ))* is X*.
Furthermore we have
(lse(β, Xtξ))** = lse(β, Xtξ) .	(510)
Proof. We use the definition of the Legendre transform:
(lse(β, XTξ))* (ξ*) = SUp ξTξ* — lse(β, XTξ)	(511)
ξ∈X
=SUp (XTξ)Τ XT (XXT)-1 ξ* - lse(β, Xtξ)
ξ∈X
=sup vτXT (XXT)-1 ξ* - lse(β, V)
= SUp vTv* - lSe(β, v)
=(lse(β, v))*(v*) = (lse(β, v))* (XT (XXT)-1 ξ*),
where We used v* = XT (XXT) 1 ξ*.
According to page 93 Example 3.25 in Boyd & Vandenberghe (2009), the equations for the maximum
maxv∈χv vτv* 一 lse(β, v) are solvable if and only if 0 < v* = XT (XXT) 1 ξ* and 1τv* =
1τXT (XXT)-1 ξ* = 1. Therefore, we assumed ξ* ∈ X*.
The domain of (lse(β, XTξ))* is X*, since on page 93 Example 3.25 in Boyd & Vandenberghe
(2009) it was shown that outside X* the SUpv∈Xv vTv* - lSe(β, v) is not bounded.
68
Using
p=softmax(β X T ξ) ,
(512)
the Hessian of lse(β, XTξ)
∂2lse(β, XTξ)
∂ξ2
β X (diag(p) - PPT) XT
(513)
is positive semi-definite since diag(P) - PPT is positive semi-definite according to Lemma A22.
Therefore, lse(β, XTξ) is convex and continuous.
If f is a regular convex function (lower semi-continuous convex function), then f ** = f according to
page 135 Exercise 11.2.3 in Garling (2017). If f is lower semi-continuous and convex, then f ** = f
according to Theorem 13.37 (Fenchel-Moreau) in Bauschke & Combettes (2017). Consequently we
have
(lse(β, XTξ))** = lse(β, XTξ) .	(514)
□
We introduce the Lambert W function and some of its properties, since it is needed to derive bounds
on the storage capacity of our new Hopfield networks.
Definition A6 (Lambert Function). The Lambert W function (Olver et al., 2010, (4.13)) is the inverse
function of
f(y) = yey .	(515)
The Lambert W function has an upper branch W0 for -1 6 y and a lower branch W-1 for y 6 -1.
We use W if a formula holds for both branches. We have
W (x) = y ⇒ yey = x .	(516)
We present some identities for the Lambert W function (Olver et al., 2010, (4.13)):
Lemma A30. Identities for the Lambert W function are
W(x) eW (x) W(xex) eW (x)	x,	(517) x,	(518) x ,	(519) W(x)
e-W (x)	W(x) —,	(520) x
enW (x)	;(Wb )：	(521)
W0 (x ln x)	二 ln x for x ≥ - ,	(522)
W-1 (x ln x)	二 ln X for X 6 - ,	(523)
W(x)	=ln	Xy for x ≥ - 1 ,	(524) W(x)	e
w n	nxn i!二 W (x)n-7	W(x) for n, x > 0 ,	(525)
W(x) + W(y) W0 (一学); W-1 (-学)二	=W (xy (W1X) + Wb)) for χ,y > 0,	(526) - ln x for 0 < x 6 e ,	(527) - ln x for x > e ,	(528)
e- W(- lnx)	= W(- lnX)for x = 1 .	(529) - ln x
69
We also present some special values for the Lambert W function (Olver et al., 2010, (4.13)):
Lemma A31.
W(0)	=0,	(530)
W(e)	=1,	(531)
W (-e)	= -1 ,	(532)
W (e1+e)	= e,	(533)
W (2 ln 2)	= ln2,	(534)
W(1)	=ω ,	(535)
W(1)	= e-W⑴=ln (Wil)) = - ln W⑴，	(536)
π	iπ	
W (-2)	=	 2 ,	(537)
W (-1)	≈ -0.31813 + 1.33723i ,	(538)
where the Omega constant Ω is
-1
- 1 ≈ 0.56714329.	(539)
We need in some proofs a version of the mean value theorem as given in the next lemma.
Lemma A32 (Mean Value Theorem). Let U ⊂ Rn be open, f : U → Rm continuously differentiable,
and x ∈ U as well as h ∈ Rn vectors such that the line segment x + th for 0 6 t 6 1 is in U. Then
the following holds:
f(x + h) - f(x) = Z J(x + t h) dt	h ,	(540)
where J is the Jacobian of f and the integral of the matrix is component-wise.
Proof. Let f1, . . . , fm denote the components of f and define gi : [0, 1] → R by
gi(t) = fi(x + t h) ,
(541)
then we obtain
fi(x + h) - fi(x) = gi(1) - gi(0)
(542)
Z1 g0(t) dt
0
1
+ t h) dt	hj .
01(XX ∂j(X+t h) h) dt
The statement follows since the Jacobian J has as entries ∂fi.
□
A.3 Modern Hopfield Networks: Binary States (Krotov and Hopfield)
A.3.1 Modern Hopfield Networks: Introduction
A.3.1.1 Additional Memory and Attention for Neural Networks. Modern Hopfield networks
may serve as additional memory for neural networks. Different approaches have been suggested
to equip neural networks with an additional memory beyond recurrent connections. The neural
Turing machine (NTM) is a neural network equipped with an external memory and an attention
process (Graves et al., 2014). The NTM can write to the memory and can read from it. A memory
network (Weston et al., 2014) consists of a memory together with the components: (1) input feature
map (converts the incoming input to the internal feature representation) (2) generalization (updates
old memories given the new input), (3) output feature map (produces a new output), (4) response
70
(converts the output into the response format). Memory networks are generalized to an end-to-end
trained model, where the arg max memory call is replaced by a differentiable softmax (Sukhbaatar
et al., 2015a;b). Linear Memory Network use a linear autoencoder for sequences as a memory (Carta
et al., 2020).
To enhance RNNs with additional associative memory like Hopfield networks have been proposed
(Ba et al., 2016a;b). The associative memory stores hidden states of the RNN, retrieves stored states if
they are similar to actual ones, and has a forgetting parameter. The forgetting and storing parameters
of the RNN associative memory have been generalized to learned matrices (Zhang & Zhou, 2017).
LSTMs with associative memory via Holographic Reduced Representations have been proposed
(Danihelka et al., 2016).
Recently most approaches to new memories are based on attention. The neural Turing machine
(NTM) is equipped with an external memory and an attention process (Graves et al., 2014). End
to end memory networks (EMN) make the attention scheme of memory networks (Weston et al.,
2014) differentiable by replacing arg max through a softmax (Sukhbaatar et al., 2015a;b). EMN
with dot products became very popular and implement a key-value attention (Daniluk et al., 2017) for
self-attention. An enhancement of EMN is the transformer (Vaswani et al., 2017a;b) and its extensions
(Dehghani et al., 2018). The transformer had great impact on the natural language processing (NLP)
community as new records in NLP benchmarks have been achieved (Vaswani et al., 2017a;b). MEMO
uses the transformer attention mechanism for reasoning over longer distances (Banino et al., 2020).
Current state-of-the-art for language processing is a transformer architecture called “the Bidirectional
Encoder Representations from Transformers” (BERT) (Devlin et al., 2018; 2019).
A.3.1.2 Modern Hopfield networks: Overview. The storage capacity of classical binary Hop-
field networks (Hopfield, 1982) has been shown to be very limited. In a d-dimensional space, the
standard Hopfield model can store d uncorrelated patterns without errors but only Cd/ ln(d) random
patterns with C < 1/2 for a fixed stable pattern or C < 1/4 if all patterns are stable (McEliece
et al., 1987). The same bound holds for nonlinear learning rules (Mazza, 1997). Using tricks-of-trade
and allowing small retrieval errors, the storage capacity is about 0.138d (Crisanti et al., 1986; Hertz
et al., 1991; Torres et al., 2002). If the learning rule is not related to the Hebb rule then up to d
patterns can be stored (Abu-Mostafa & StJacques, 1985). Using Hopfield networks with non-zero
diagonal matrices, the storage can be increased to Cd ln(d) (Folli et al., 2017). In contrast to the
storage capacity, the number of energy minima (spurious states, stable states) of Hopfield networks is
exponentially in d (Tanaka & Edwards, 1980; Bruck & Roychowdhury, 1990; Wainrib & Touboul,
2013).
Recent advances in the field of binary Hopfield networks (Hopfield, 1982) led to new properties
of Hopfield networks. The stability of spurious states or metastable states was sensibly reduced
by a Hamiltonian treatment for the new relativistic Hopfield model (Barra et al., 2018). Recently
the storage capacity of Hopfield networks could be increased by new energy functions. Interaction
functions of the form F(x) = xn lead to storage capacity of αndn-1, where αn depends on the
allowed error probability (Krotov & Hopfield, 2016; 2018; Demircigil et al., 2017) (see (Krotov &
Hopfield, 2018) for the non-binary case). Interaction functions of the form F(x) = xn lead to storage
n-1
capacity of an： , for Cn > 2(2n - 3)!! (Demircigil etal., 2017).
Interaction functions of the form F(x) = exp(x) lead to exponential storage capacity of 2d/2 where
all stored patterns are fixed points but the radius of attraction vanishes (Demircigil et al., 2017). It
has been shown that the network converges with high probability after one update (Demircigil et al.,
2017).
A.3.2 Energy and Update Rule for Binary Modern Hopfield Networks
We follow (Demircigil et al., 2017) where the goal is to store a set of input data x1, . . . , xN that are
represented by the matrix
X = (x1, . . . , xN) .	(543)
The xi is pattern with binary components xij ∈ {-1, +1} for all i and j. ξ is the actual state of the
units of the Hopfield model. Krotov and Hopfield (Krotov & Hopfield, 2016) defined the energy
function E with the interaction function F that evaluates the dot product between patterns xi and the
71
actual state ξ:
N
E= - X F (ξτxi)	(544)
i=1
with F(a) = an, where n = 2 gives the energy function of the classical Hopfield network. This allows
to store αndn-1 patterns (Krotov & Hopfield, 2016). Krotov and Hopfield (Krotov & Hopfield, 2016)
suggested for minimizing this energy an asynchronous updating dynamics T = (Tj) for component
ξj:
N
Tj(ξ) ：= Sgn X(F(Xij + XXiI ξι) — F(- Xij + XXil ξι))	(545)
While Krotov and Hopfield used F(a) = an, Demircigil et al. (Demircigil et al., 2017) went a
step further and analyzed the model with the energy function F(a) = exp(a), which leads to an
exponential storage capacity of N = 2d/2 . Furthermore with a single update the final pattern is
recovered with high probability. These statements are given in next theorem.
Theorem A10 (Storage Capacity for Binary Modern Hopfield Nets (Demircigil et al. 2017)). Con-
sider the generalized Hopfield model with the dynamics described in Eq. (545) and interaction
function F given by F(X) = ex. For a fixed 0 < α < ln(2)/2 let N = exp (αd) + 1 and let
x1, . . . , xN be N patterns chosen uniformly at random from {—1, +1}d. Moreover fix % ∈ [0, 1/2).
For any i and any xei taken uniformly at random from the Hamming sphere with radius %d centered in
xi, S(xi, %d), where %d is assumed to be an integer, it holds that
Pr (∃i ∃j : Tj (xei) 6= Xij) → 0 ,
if α is chosen in dependence of % such that
/ I(1 — 2%)
α < -2-
with
I : a → ( ((1 + a) ln(1 + a) + (1 — a) ln(1 — a)).
Proof. The proof can be found in Demircigil et al. (2017).
□
The number of patterns N = exp (αd) + 1 is exponential in the number d of components. The result
Pr (∃i ∃j : Tj (xei) 6= Xij) → 0
means that one update for each component is sufficient to recover the pattern with high probability.
The constraint α < I(1-2%) on α gives the trade-off between the radius of attraction %d and the
number N = exp (αd) + 1 of pattern that can be stored.
Theorem A10 in particular implies that
Pr (∃i ∃j : Tj (xi) 6= Xij) → 0
as d → ∞, i.e. with a probability converging to 1, all the patterns are fixed points of the dynamics. In
this case we can have a → I(P = ln(2)∕2.
Krotov and Hopfield define the update dynamics Tj (ξ) in Eq. (545) via energy differences of the
energy in Eq. (544). First we express the energy in Eq. (544) with F(a) = exp(a) (Demircigil et al.,
2017) by the lse function. Then we use the mean value theorem to express the update dynamics Tj (ξ)
in Eq. (545) by the softmax function. For simplicity, we set β = 1 in the following. There exists a
v ∈ [—1, 1] with
Tj (ξ)	= sgn	h— E(ξj	= 1) +	E(ξj	= —1)i	= sgn	hexp(lse(ξj	= 1)) — exp(lse(ξj	= —1))i
sgn
sgn
h- (2ej-)TVξE岛=v)i = Sgn 卜χp(lse(ξj = V)) (2ej)Tlse(ξ∂ξ V)i
(546)
exp(lse(ξj
sgn [X softmax
= 1)) (2ej )T X softmax(X T ξ(ξj = v))i
(XTξ(ξj = v))]ji = sgn h[Xp(ξj = v)]ji ,
72
where ej is the Cartesian unit vector with a one at position j and zeros elsewhere, [.]j is the projection
to the j -th component, and
p = softmax(XT ξ) .
(547)
A.4 Hopfield Update Rule is Attention of The Transformer
The Hopfield network update rule is the attention mechanism used in transformer and BERT models
(see Fig. A.2). To see this, we assume N stored (key) patterns yi and S state (query) patterns ri that
are mapped to the Hopfield space of dimension dk . We set xi = WKTyi, ξi = WQTri, and multiply
the result of our update rule with WV . The matrices Y = (y1, . . . , yN)T and R = (r1, . . . , rS)T
combine the yi and ri as row vectors. We define the matrices XT = K = Y WK, ΞT = Q =
RWq, and V = YWK WV = X T WV ,where WK ∈ Rdy ×dk, WQ ∈ Rdr ×dk, WV ∈ Rdk ×d.
If β = 1 /√dk and SoftmaX ∈ RN is changed to a row vector, we obtain for the update rule Eq. (3)
multiplied by WV :
SoftmaX(1/Pdk Q KT) V = SoftmaX (β RWQ WKYT) YWK WV .	(548)
The left part of Eq. (548) is the transformer attention. Besides the attention mechanism, Hopfield
networks allow for other functionalities in deep network architectures, which we introduce via specific
layers in the next section. The right part of Eq. (548) serves as starting point for these specific layers.
Figure A.2: We generalized the energy of binary modern Hopfield networks for allowing continuous
states while keeping fast convergence and storage capacity properties. We defined for the new energy
also a new update rule that minimizes the energy. The new update rule is the attention mechanism
of the transformer. Formulae are modified to express SoftmaX as row vector as for transformers.
"="-sign means "keeps the properties".
A.5 Experiments
A.5. 1 Experiment 1: Attention in Transformers described by Hopfield dynamics
A.5.1.1 Analysis of operating modes of the heads of a pre-trained BERT model. We analyzed
pre-trained BERT models from Hugging Face Inc. (Wolf et al., 2019) according to these operating
classes. In Fig. A.3 in the appendix the distribution of the pre-trained bert-base-cased model is
depicted (for other models see appendix Section A.5.1.4). Operating classes (II) (large metastable
states) and (IV) (small metastable states) are often observed in the middle layers. Operating class (I)
(averaging over a very large number of patterns) is abundant in lower layers. Similar observations
have been reported in other studies (Toneva & Wehbe, 2019a;b; Tay et al., 2020). Operating class
(III) (medium metastable states) is predominant in the last layers.
A.5.1.2 Experimental Setup. Transformer architectures are known for their high computational
demands. To investigate the learning dynamics of such a model and at the same time keeping training
time manageable, we adopted the BERT-small setting from ELECTRA (Clark et al., 2020). It has
12 layers, 4 heads and a reduced hidden size, the sequence length is shortened from 512 to 128
tokens and the batch size is reduced from 256 to 128. Additionally, the hidden dimension is reduced
from 768 to 256 and the embedding dimension is reduced from 768 to 128 (Clark et al., 2020). The
training of such a BERT-small model for 1.45 million update steps takes roughly four days on a
single NVIDIA V100 GPU.
73
Head 1 Head 2 Head 3 Head 4 Head 5 Head 6 Head 7 Head 8 Head 9 Head 10 Head 11 Head 12
A
3
II-IaAeJ OlJ6」8Ae-l ∞」3Ae-I N」3Ae-l 9」8Ae-I gAen m J8A3 Z」8Ae-I ι」8AB-I

Illlllllllllllk 片 * » 匕曰三 e
hr I Hr H HrHrh	三4 看£
H IHHH	Il II
Uiiiiiihiiiiiiimiiiiiiiiiii",

丁 一“ H 卜7 h， K K K K7 % / W
匚H院三三，七/总W W4W
IiiiiiiiiiiiiiiR K & a 三』& w
III ♦札Br三W W 44W《W
[ H H	+	金
卜〜会卷〈高〈44金上≡4
0 1∞ »0 3∞ «0	0 UO a∞ XD	0 IM aeo JM 4W 0 1∞ »0 3∞ «0	0 UO a∞ XO	0 1∞ »0 3∞ «0	0 UO a∞ XO «0	0 1∞ »0 3∞ «0	0 UO a∞ XO ««	0 1∞ »0 3∞ «0	0 UO a∞ XO	0 1∞ MO vx> Se
k patterns k patterns k patterns k patterns	k patterns	k patterns k patterns k patterns k patterns	k patterns	k patterns	k patterns
Figure A.3: Analysis of operating modes of the heads of a pre-trained BERT model. For each head
in each layer, the distribution of the minimal number k of patterns required to sum up the softmax
values to 0.90 is displayed as a violin plot in a panel. k indicates the size of a metastable state. The
bold number in the center of each panel gives the median k of the distribution. The heads in each
layer are sorted according to k. Attention heads belong to the class they mainly operate in. Class
(IV) in blue: Small metastable state or fixed point close to a single pattern, which is abundant in
the middle layers (6, 7, and 8). Class (II) in orange: Large metastable state, which is prominent in
middle layers (3, 4, and 5). Class (I) in red: Very large metastable state or global fixed point, which
is predominant in the first layer. These heads can potentially be replaced by averaging operations.
Class (III) in green: Medium metastable state, which is frequently observed in higher layers. We
hypothesize that these heads are used to collect information required to perform the respective task.
These heads should be the main target to improve transformer and BERT models.
74
As the code base we use the transformers repository from Hugging Face, Inc (Wolf et al., 2019). We
aim to reproduce the dataset of Devlin et al. (2019) as close as possible, which consists of the English
Wikipedia dataset and the Toronto BookCorpus dataset (Zhu et al., 2015). Due to recent copyright
claims the later is not publicly available anymore. Therefore, the pre-training experiments use an
uncased snapshot of the original BookCorpus dataset.
A.5.1.3 Hopfield Operating Classes of Transformer and BERT Models. To better understand
how operation modes in attention heads develop, we tracked the distribution of counts k (see main
paper) over time in a BERT-small model. At the end of training we visualized the count distribution,
grouped into four classes (see Figure A.4). The thresholds for the classes were chosen according to
the thresholds of Figure 2 in the main paper. However, they are divided by a factor of 4 to adapt to
the shorter sequence length of 128 compared to 512. From this plot it is clear, that the attention in
heads of Class IV commit very early to the operating class of small metastable states.
A.5.1.4 Learning Dynamics of Transformer and BERT Models. To observe this behavior in
the early phase of training, we created a ridge plot of the distributions of counts k for the first 20, 000
steps (see Figure A.5 (a)). This plot shows that the attention in heads of middle layers often change
the operation mode to Class IV around 9, 000 to 10, 000 steps. At the same time the second big
drop in the loss occurs. The question arises whether this is functionally important or whether it is an
artefact which could be even harmful. To check if the attention mechanism is still able to learn after
the change in the operation mode we analyzed the gradient flow through the softmax function. For
every token we calculate the Frobenius norm of the Jacobian of the softmax over multiple samples.
Then, for every head we plot the distribution of the norm (see Figure A.5(b)). The gradients with
respect to the weights are determined by the Jacobian J defined in Eq. (59) as can be seen in Eq. (418),
Eq. (429), and Eq. (435). We can see that the attention in heads of Class IV remain almost unchanged
during the rest of the training.
A.5.1.5 Attention Heads Replaced by Gaussian Averaging Layers. The self-attention mecha-
nism proposed in Vaswani et al. (2017a) utilizes the softmax function to compute the coefficients
of a convex combination over the embedded tokens, where the softmax is conditioned on the input.
However, our analysis showed that especially in lower layers many heads perform averaging over a
very large number of patterns. This suggests that at this level neither the dependency on the input
nor a fine grained attention to individual positions is necessary. As an alternative to the original
mechanism we propose Gaussian averaging heads which are computationally more efficient. Here,
the Softmax function is replaced by a discrete Gaussian kernel, where the location μ and the scale σ
are learned. In detail, for a sequence length of N tokens we are given a vector of location parame-
ters μ = (μι,..., μN )T and a vector of corresponding scale parameters σ = (σι,..., σN )T. We
subdivide the interval [-1, 1] into N equidistant supporting points {sj}jN=1, where
―(j- 1)- 0.5 (N - 1)
Sj =	0.5 (N - 1)	.
The attention [A]i,j from the i-th token to the j-th position is calculated as
[。:exP 1 2( T B
where zi normalizes the i-th row of the attention matrix A to sum up to one:
Zi = XexP , 1(个『I
For initialization we uniformly sample a location vector μ ∈ [-1, 1]n and a scale vector σ ∈
[0.75, 1.25]N per head. A simple way to consider the individual position of each token at initialization
is to use the supporting points μ% = Si (see Figure A.6). In practice no difference to the random
initialization was observed.
•Number of parameters. Gaussian averaging heads can reduce the number of parameters significantly.
For an input size of N tokens, there are 2 ∙ N parameters per head. In contrast, a standard self-attention
head with word embedding dimension dy and projection dimension dk has two weight matrices
75
Head 1
Head 2
Head 3
Head 4
一				一										
卜	6			卜	7			卜						
k	2				3			一	6				1	
														
				1				L				(L		
	2			I	3			∖Γ	8				0	
L	5			L				L				A		
r								V	8一			3	3	
0	50	100	0	50	100	0	50	100	0	50	100
k PattennS k PattennS k PattennS k PattennS
Figure A.4: Left: Ridge plots of the distribution of counts k over time for BERT-small Right:
Violin plot of counts k after 1, 450000 steps, divided into the four classes from the main paper. The
thresholds were adapted to the shorter sequence length.
76
(a) Densities
(b) Norm of Jacobian
Figure A.5: (a): change of count density during training is depicted for the first 20, 000 steps. (b): the
corresponding distribution of the Frobenius norm of the Jacobian of the softmax function is depicted.
The gradients with respect to the weights are determined by the Jacobian J defined in Eq. (59) as can
be seen in Eq. (418), Eq. (429), and Eq. (435).
77
Wq, WK ∈ Rdk ×dy, which together amount to 2 ∙ dk ∙ dy parameters. As a concrete example, the
BERT-base model from Devlin et al. (2019) has an embedding dimension dy = 768, a projection
dimension dk = 64 and a sequence length of N = 512. Compared to the Gaussian head, in this
case (2 ∙ 768 ∙ 64)/(2 ∙ 512) = 95.5 times more parameters are trained for the attention mechanism
itself. Only for very long sequences (and given that the word embedding dimension stays the same)
the dependence on N may become a disadvantage. But of course, due to the independence from
the input the Gaussian averaging head is less expressive in comparison to the original attention
mechanism. A recently proposed input independent replacement for self-attention is the so called
Random Synthesizer (Tay et al., 2020). Here the softmax-attention is directly parametrized with an
N X N matrix. This amounts to 0.5 ∙ N more parameters than Gaussian averaging.
0.012
0.010
0.008
0.006
0.004
0.002
0.000
0	20	40	60	80	100	120
token
Figure A.6: Attentions of a Gaussian averaging head at initialization for sequence length N = 128.
Every line depicts one Gaussian kernel. Here, the location parameters are initialized with the value of
the supporting points μi = s〃
A.5.2 Experiment 2: Multiple Instance Learning Datasets.
A.5.2.1 Immune Repertoire Classification. An architecture called DeepRC, is based on our
modern Hopfield networks, for immune repertoire classification and compared to other machine
learning approaches. For DeepRC, we consider immune repertoires as input objects, which are
represented as bags of instances. In a bag, each instance is an immune receptor sequence and each
bag can contain a large number of sequences. At its core, DeepRC consists of a modern Hopfield
network that extracts information from each repertoire. The stored patterns (keys) are representations
of the immune amino acid sequences (instances) that are obtained by an 1D convolutional network
with position encoding. Each state pattern (query) is static and learned via backpropagation. For
details see Widrich et al. (2020a;b).
Our new Hopfield network has been integrated into a deep learning architecture for immune repertoire
classification, a massive multiple instance learning task (Widrich et al., 2020a;b). Theorem 3 states
that modern Hopfield networks possess an exponential storage capacity which enables to tackle
massive multiple instance learning (MIL) problems (Dietterich et al., 1997). Immune repertoire
classification (Emerson et al., 2017) typically requires to extract few patterns from a large set of
sequences, the repertoire, that are indicative for the respective immune status. Most MIL methods
fail due the large number of instances.
Data is obtained by experimentally observed immune receptors as well as simulated sequences
sequence motifs (Akbar et al., 2019; Weber et al., 2020) with low yet varying degrees of frequency
are implanted. Four different categories of datasets are constructed: (a) Simulated immunosequencing
data with implanted motifs, (b) immunosequencing data generated by long short-term memory
(LSTM) with implanted motifs, (c) real-world immunosequencing data with implanted motifs, and (d)
real-world immunosequencing data with known immune status (Emerson et al., 2017). Categories (a),
(b), and (d) contain approx. 300,000 instances per immune repertoire. With over 30 billion sequences
in total, this represents one of the largest multiple instance learning experiments ever conducted
(Carbonneau et al., 2018). Despite the massive number of instances as well as the low frequency
78
of sequences indicative of the respective immune status, deep learning architectures with modern
Hopfield networks outperform all competing methods with respect to average area under the ROC
curve in all four categories, (a), (b), (c) and (d) (for details see Widrich et al. (2020a)).
We evaluate and compare the performance of DeepRC to a set of machine learning methods that
serve as baseline, were suggested, or can readily be adapted to immune repertoire classification. The
methods comprise (i) known motif, which counts how often the known implanted motifs occur, (ii)
Support Vector Machine (SVM) approach that uses a fixed mapping from a bag of sequences to
the corresponding k-mer counts and used the MinMax and Jaccard kernel, (iii) k-Nearest Neighbor
(KNN) with k-mer representation, transforming MinMax and Jaccard kernel to distances, (iv) logistic
regression on the k-mer representation, (v) burden test that first identifies sequences or k-mers and
then computes a burden score per individual, and (vi) logistic multiple instance learning (lMIL).
On the real-world dataset DeepRC achieved an AUC of 0.832 ± 0.022, followed by the SVM with
MinMax kernel (AUC 0.825 ± 0.022) and the burden test with an AUC of 0.699 ± 0.041. Overall on
all datasets, DeepRC outperformed all competing methods with respect to average AUC (see Widrich
et al. (2020a;b)).
Table A.1 reports the average performance in the simulated immunosequencing datasets (last column)
and the performance on datasets of the remaining three categories. DeepRC outperforms all competing
methods with respect to average AUC. Across categories, the runner-up methods are either the SVM
for MIL problems with MinMax kernel or the burden test.
Real-world Real-world data with implanted signals	LSTM-generated data	Simulated
CMV OM 1% OM 0.1% MM 1% MM 0.1%	10%	1%	0.5%	0.1%	0.05% avg.
DeepRC	0.832	± 0.022	1.00 ± 0.00	0.98± 0.01	1.00± 0.00 0.94±0.01	1.00± 0.00	1.00± 0.00	1.00± 0.00 1.00± 0.00 1.00± 0.00	0.846± 0.223
SVM(MM)	0.825 ± 0.022	1.00 ± 0.00	0.58± 0.02	1.00± 0.00 0.53±0.02	1.00± 0.00	1.00± 0.00	1.00± 0.00 1.00± 0.00 0.99± 0.01	0.827± 0.210
SVM(J)	0.546	± 0.021	0.99 ± 0.00	0.53± 0.02	1.00± 0.00 0.57±0.02	0.98± 0.04	1.00± 0.00	1.00± 0.00 0.90± 0.04 0.77± 0.07	0.550± 0.080
KNN (MM)	0.679 ± 0.076	0.74 ± 0.24	0.49± 0.03	0.67± 0.18 0.50±0.02	0.70± 0.27	0.72± 0.26	0.73± 0.26 0.54± 0.16 0.52± 0.15	0.634± 0.129
KNN (J)	0.534	± 0.039	0.65 ± 0.16	0.48± 0.03	0.70± 0.20 0.51±0.03	0.70± 0.29	0.61± 0.24	0.52± 0.16 0.55± 0.19 0.54± 0.19	0.501± 0.007
Log. regr.	0.607	± 0.058	1.00 ± 0.00	0.54± 0.04	0.99± 0.00 0.51±0.04	1.00± 0.00	1.00± 0.00	0.93± 0.15 0.60± 0.19 0.43± 0.16	0.826± 0.211
Burden test	0.699 ± 0.041	1.00 ± 0.00	0.64± 0.05	1.00± 0.00 0.89±0.02	1.00± 0.00	1.00± 0.00	1.00± 0.00 1.00± 0.00 0.79± 0.28	0.549± 0.074
Log. MIL(KMER)	0.582 ± 0.065	0.54 ± 0.07	0.51± 0.03	0.99± 0.00 0.62±0.15	1.00± 0.00	0.72± 0.11	0.64± 0.14 0.57± 0.15 0.53± 0.13	0.665± 0.224
Log. MIL (TCRβ)	0.515 ± 0.073	0.50 ± 0.03	0.50± 0.02	0.99± 0.00 0.78±0.03	0.54± 0.09	0.57± 0.16	0.47± 0.09 0.51 ± 0.07 0.50± 0.12	0.501± 0.016
Known motif b.	-	1.00 ± 0.00 0.70± 0.03 0.99± 0.00 0.62±0.04 1.00± 0.00 1.00± 0.00 1.00± 0.00 1.00± 0.00 1.00± 0.00 0.890± 0.168
Known motif c.	—	0.92 ± 0.00 0.56± 0.03 0.65± 0.03 0.52±0.03 1.00± 0.00 1.00± 0.00 0.99± 0.01 0.72± 0.09 0.63± 0.09 0.738± 0.202
Table A.1: Results immune repertoire classification across all datasets. Results are given in terms
of AUC of the competing methods on all datasets. The reported errors are standard deviations
across 5 cross-validation (CV) folds (except for the column “Simulated”). Real-world CMV:
Average performance over 5 CV folds on the cytomegalovirus (CMV) dataset Emerson et al. (2017).
Real-world data with implanted signals: Average performance over 5 CV folds for each of the
four datasets. A signal was implanted with a frequency (=wittness rate) of 1% or 0.1%. Either a
single motif (“OM”) or multiple motifs (“MM”) were implanted. LSTM-generated data: Average
performance over 5 CV folds for each of the 5 datasets. In each dataset, a signal was implanted with
a frequency of 10%, 1%, 0.5%, 0.1%, and 0.05%, respectively. Simulated: Here we report the mean
over 18 simulated datasets with implanted signals and varying difficulties. The error reported is the
standard deviation of the AUC values across the 18 datasets.
A.5.2.2 Multiple Instance Learning Benchmark Datasets. Classical benchmarking datasets
comprise UCSB breast cancer classification (Kandemir et al., 2014), and the Elephant, Fox, Tiger
datasets (Andrews et al., 2003).
Elephant, Fox and Tiger are MIL datasets for image annotation which comprise color images from the
Corel dataset that have been preprocessed and segmented. An image consists of a set of segments (or
blobs), each characterized by color, texture and shape descriptors. The datasets have 100 positive and
100 negative example images. The latter have been randomly drawn from a pool of photos of other
animals. Elephant has 1391 instances and 230 features. Fox has 1320 instances and 230 features.
Tiger has 1220 instances and 230 features. Furthermore, we use the UCSB breast cancer classification
(Kandemir et al., 2014) dataset, which consists of 2,002 instances across 58 input objects. An
instance represents a patch of a histopathological image of cancerous or normal tissue. The layer
HopfieldPooling is used, which allows for computing a per-input-object representation by
79
parameter	values
learning rates	{10-3, 10-5 }
learning rate decay (γ)	{0.98, 0.96, 0.94}
embedding layers	{1, 2, 3}
layer widths	{32, 64, 256, 1024, 2048}
number of heads	{8, 12, 16, 32}
head dimensions	{16, 32, 64}
scaling factors	{0.1, 1.0, 10.0}
hidden dimensions	{32, 64, 128}
bag dropout	{0.0,0.75}	
Table A.2: Hyperparameter search-space of a manual hyperparameter selection on the respective
validation sets of the Elephant, Fox, Tiger and UCSB breast cancer datasets.
extracting an average of instances that are indicative for one of the two classes. The input to the
HopfieldPooling layer is a set of embedded instances Y and a trainable but fixed state (query)
pattern Q used for averaging of class-indicative instances. This averaging enables a compression
of variable-sized bags to a fixed-sized representation to discriminate the bags. We performed a
manual hyperparameter search on a validation set. In detail, we used the following architecture to
perform the given task on the Elephant, Fox, Tiger and UCSCB breast cancer datasets: (I) we apply
fully connected linear embedding layers with ReLU activation. (II) The output of this embedding
serves as the input to our HopfieldPooling layer where the above described pooling operation
is performed. (III) Thereafter we use ’ReLU - Linear blocks’ as the final linear output layers that
perform the classification. Among other hyperparameters, different hidden layer widths (for the
fully connected pre- and post-HopfieldPooling layers), learning rates and batch sizes were tried.
Additionally our focus resided on the hyperparameters of the HopfieldPooling layer. Among
those were the number of heads, the head dimension and the scaling factor β. All models were trained
for 160 epochs using the AdamW optimizer (Loshchilov & Hutter, 2017) with exponential learning
rate decay (see Table A.2), and validated by 10-fold nested cross validation repeated five times with
different splits on the data sets. The reported ROC AUC scores are the average of these repetitions.
As overfitting imposed quite a problem, bag dropout was applied as the regularization technique of
choice.
80
A.5.3 Experiment 3: Classification on Small UCI Benchmark Datasets
A.5.3.1 Motivation. Datasets with a small number of samples, like the UCI benchmark datasets,
are particularly difficult for neural networks to generalize on. In contrast to their performance on
larger datasets, they are consistently outperformed by methods like e.g. gradient boosting, random
forests (RF) and support vector machines (SVMs). Finding samples or even learning prototypes that
are highly indicative for the class of a sample (query) suggest the use of Hopfield networks. We
applied a modern Hopfield network via the layer Hopfield. The input vector is mapped to R using
a self-normalizing net (SNN) and WK is learned, where the dimension of WK (the number of stored
fixed pattern) is a hyperparameter. The output Z of Hopfield enters the output layer.
A.5.3.2 Methods compared. Modern Hopfield networks via the layer Hopfield are compared to
17 groups of methods (Femgndez-Delgado et al., 2014; Klambauer et al., 2017a):
1.	Support Vector Machines
2.	Random Forest
3.	Multivariate adaptive regression splines (MARS)
4.	Boosting
5.	Rule-based Methods
6.	Logistic and Multinomial Regression (LMR)
7.	Discriminant Analysis (DA)
8.	Bagging
9.	Nearest Neighbor
10.	Decision Trees
11.	Other Ensembles
12.	Neural Networks (standard NN, BatchNorm, WeighNorm, MSRAinit, LayerNorm, ResNet,
Self-Normalizing Nets)
13.	Bayesian Methods
14.	Other Methods
15.	Generalized linear models (GLM)
16.	Partial Least Squares and Principal Component Regression (PLSR)
17.	Stacking (Wolpert)
A.5.3.3 Experimental design and implementation details. As specified in the main paper, we
consider 75 datasets of the UC Irvine Machine Learning Repository, which contain less than 1, 000
samples per dataset, following the dataset separation into large and small dataset in Klambauer et al.
(2017a). On each dataset, we performed a grid-search to determine the best hyperparameter setting
and model per dataset. The hyperparameter search-space of the grid-search is listed in Table A.3. All
models were trained for 100 epochs with a mini-batch size of 4 samples using the cross entropy loss
and the PyTorch SGD module for stochastic gradient descent without momentum and without weight
decay or dropout. After each epoch, the model accuracy was computed on a separated validation set.
Using early stopping, the model with the best validation set accuracy averaged over 16 consecutive
epochs was selected as final model. This final model was then evaluated against a separated test set
to determine the accuracy, as reported in Tables 2 and Table uci_detailed_results.csv in
the supplemental materials.
As network architecture, we use {0, 1, 7} fully connected embedding layers with SELU Klambauer
et al. (2017a) activation functions and {32, 128, 1024} hidden units per embedding layer. These
embedding layers are followed by the layer Hopfield. The number of hidden units is also used as
number of dimensions for the Hopfield association space with a number of {1, 32} heads. The layer
Hopfield is followed by a mapping to the output vector, which has as dimension the number of
classes. Finally, the softmax function is applied to obtain the predicted probability for a class.
81
parameter	values
learning rates	{005}
embedding layers	{0, 1, 7}
hidden units	{32, 128, 1024}
heads	{1, 32}
β	{1.0, 0.1, 0.001}
# stored patterns	{1, 8} ∙ n_classes
Table A.3: Hyperparameter search-space for grid-search on small UCI benchmark datasets. All
models were trained for 100 epochs using stochastic gradient descent with early stopping based on
the validation set accuracy and a minibatch size of 4 samples. The number of stored patterns is
depending on the number of target classes of the individual tasks.
A.5.3.4 Results. We compared the performance of 25 methods based on their method rank. For
this we computed the rank per method per dataset based on the accuracy on the test set, which was
then averaged over all 75 datasets for each method to obtain the method rank. For the baseline
methods we used the scores summarized by (Klambauer et al., 2017a).
82
parameter	values
beta	{0.0001, 0.001, 0.01, 0.1, 0.2, 0.3}
learning rates	{0.0002}
heads	{1, 32, 128, 512}
dropout	{0.0, 0.1, 0.2}
state-pattern bias	{0.0, -0.1, -0.125, 0.15, -0.2}
association-activation	{None, LeakyReLU }
state- and stored-pattern static	{False, True}
normalize state- and stored-pattern	{False, True}
normalize association projection	{False, True}
learnable Stored-Pattem	{False, True}
Table A.4: Hyperparameter search-space for grid-search on HIV, BACE, BBBP and SIDER. All
models were trained if applicable for 4 epochs using Adam and a batch size of 1 sample.
A.5.4 Experiment 4: Drug Design Benchmark Datasets
A.5.4.1 Experimental design and implementation details. We test Hopfield layers on 4 clas-
sification datasets from MoleculeNet (Wu et al., 2017), which are challenging for deep learning
methods. The first dataset is HIV, which was introduced by the Drug Therapeutics Program (DTP)
AIDS Antiviral Screen. The second dataset is BACE, which has IC50 measurements for binding
affinities of inhibitors (molecules) to the human β-secretase 1 (BACE-1). The third dataset is BBBP
(blood-brain barrier permeability), which stems from modeling and predicting the blood-brain barrier
permeability (Martins et al., 2012). The fourth dataset is SIDER (Side Effect Resource) Kuhn et al.
(2016) and contains 1427 approved drugs. These datasets represent four areas of modeling tasks in
drug discovery, concretely to develop accurate models for predicting a) new anti-virals (HIV), b) new
protein inhibitors (BACE), c) metabolic effects (BBBP), and d) side effects of a chemical compound
(SIDER).
We implemented a Hopfield layer HopfieldLayer, in which we used the training-input as stored-
pattern Y or key, the training-label as pattern-projection Y WV or value and the input as state-pattern
R or query. As described in section A.6 by concatenation of input zi and target ti the matrices WK
and WV can be designed such that inside the softmax the input zi is used and outside the softmax
the target ti .
All hyperparameters were selected on separate validation sets and we selected the model with the
highest validation AUC on five different random splits.
A.5.4.2 Results. We compared the Hopfield layer Hopfieldlayer to Support Vector Ma-
chines (SVMs)(Cortes & Vapnik, 1995; SchOlkoPf & Smola, 2002), Extreme Gradient Boosting
(XGBoost) (Chen & Guestrin, 2016), Random Forest (RF) (Breiman, 2001), Deep Neural Net-
works (DNNs) (LeCun et al., 2015; Schmidhuber, 2015), and to graph neural networks (GNN) like
Graph Convolutional Networks (GCNs) (Kipf & Welling, 2016), Graph Attention Networks (GATs)
(Velickovic et al., 2018), Message Passing Neural Networks (MPNNs) (Gnmer et al., 2017), and
Attentive FP (Xiong et al., 2020). Our architecture with HopfieldLayer has reached state-of-the-
art for predicting side effects on SIDER 0.672 ± 0.019 as well as for predicting β-secretase BACE
0.902 ± 0.023. See Table A.5 for all results, where the results of other methods are taken from Jiang
et al. (2020).
83
Table A.5: Results on drug design benchmark datasets. Predictive performance (ROCAUC) on test
set as reported by Jiang et al. (2020) for 50 random splits
Model	HIV	BACE	BBBP	SIDER
SVM	0.822 ± 0.020	0.893 ± 0.020	0.919 ± 0.028	0.630 ± 0.021
XGBoost	0.816 ± 0.020	0.889 ± 0.021	0.926 ± 0.026	0.642 ± 0.020
RF	0.820 ± 0.016	0.890 ± 0.022	0.927 ± 0.025	0.646 ± 0.022
GCN	0.834 ± 0.025	0.898 ± 0.019	0.903 ± 0.027	0.634 ± 0.026
GAT	0.826 ± 0.030	0.886 ± 0.023	0.898 ± 0.033	0.627 ± 0.024
DNN	0.797 ± 0.018	0.890 ± 0.024	0.898 ± 0.033	0.627 ± 0.024
MPNN	0.811 ± 0.031	0.838 ± 0.027	0.879 ± 0.037	0.598 ± 0.031
Attentive FP	0.822 ± 0.026	0.876 ± 0.023	0.887 ± 0.032	0.623 ± 0.026
Hopfield (ours)	0.815 ± 0.023	0.902 ± 0.023	0.910 ± 0.026	0.672 ± 0.019
A.6 PyTorch Implementation of Hopfield Layers
The implementation is available at: https://github.com/ml-jku/hopfield-layers
A.6.1 Introduction
In this section, we describe the implementation of Hopfield layers in PyTorch (Paszke et al., 2017;
2019) and, additionally, provide a brief usage manual. Possible applications for a Hopfield layer in a
deep network architecture comprise:
•	multiple instance learning (MIL) (Dietterich et al., 1997),
•	processing of and learning with point sets (Qi et al., 2017a;b; Xu et al., 2018),
•	set-based and permutation invariant learning (Guttenberg et al., 2016; Ravanbakhsh et al.,
2016; Zaheer et al., 2017; Korshunova et al., 2018; Ilse et al., 2018; Zhai et al., 2020),
•	attention-based learning (Vaswani et al., 2017a),
•	associative learning,
•	natural language processing,
•	sequence analysis and time series prediction, and
•	storing and retrieving reference or experienced data, e.g. to store training data and retrieve it
by the model or to store experiences for reinforcement learning.
The Hopfield layer in a deep neural network architecture can implement:
•	a memory (storage) with associative retrieval (Danihelka et al., 2016; Ba et al., 2016a),
•	conditional pooling and averaging operations (Wang et al., 2018; Ilse et al., 2020),
•	combining data by associations (Agrawal et al., 1993),
•	associative credit assignment (e.g. Rescorla-Wagner model or value estimation) (Sutton &
Barto, 2018), and
•	attention mechanisms (Vaswani et al., 2017a; Bahdanau et al., 2014).
In particular, a Hopfield layer can substitute attention layers in architectures of transformer and BERT
models. The Hopfield layer is designed to be used as plug-in replacement for existing layers like
•	pooling layers (max-pooling or average pooling),
•	permutation equivariant layers (Guttenberg et al., 2016; Ravanbakhsh et al., 2016),
•	GRU & LSTM layers, and
•	attention layers.
84
In contrast to classical Hopfield networks, the Hopfield layer is based on the modern Hopfield
networks with continuous states that have increased storage capacity, as discussed in the main paper.
Like classical Hopfield networks, the dynamics of the single heads of a Hopfield layer follow a
energy minimization dynamics. The energy minimization empowers our Hopfield layer with several
advantages over other architectural designs like memory cells, associative memory, or attention
mechanisms. For example, the Hopfield layer has more functionality than a transformer self-attention
layer (Vaswani et al., 2017a) as described in Sec. A.6.2. Possible use cases are given in Sec. A.6.3.
Source code will be provided under github.
A.6.2 Functionality
Non-standard functionalities that are added by a Hopfield layer are
•	Association of two sets,
•	Multiple Updates for precise fixed points,
•	Variable Beta that determines the kind of fixed points,
•	Dimension of the associative space for controlling the storage capacity,
•	Static Patterns for fixed pattern search, and
•	Pattern Normalization to control the fixed point dynamics by norm of the patterns and shift
of the patterns.
A functional sketch of our Hopfield layer is shown in Fig. A.7.
•Association of two sets. The Hopfield layer makes it possible to associate two sets of vectors. This
general functionality allows
•	for transformer-like self-attention,
•	for decoder-encoder attention,
•	for time series prediction (maybe with positional encoding),
•	for sequence analysis,
•	for multiple instance learning,
•	for learning with point sets,
•	for combining data sources by associations,
•	for constructing a memory,
•	for averaging and pooling operations, and
•	for many more.
The first set of vectors consists of S raw state patterns R = (r1 , . . . , rS)T with rs ∈ Rdr and
the second set of vectors consists of N raw stored patterns Y = (y1, . . . , yN)T with yi ∈ Rdy .
Both the S raw state patterns and N raw stored patterns are mapped to an associative space in Rdk
via the matrices WQ ∈ Rdr ×dk and WK ∈ Rdy ×dk, respectively. We define a matrix Q (ΞT) of
state patterns ξn = WQrn in an associative space Rdk and a matrix K (XT) of stored patterns
xi = WKys in the associative space Rdk :
Q = ΞT = R WQ ,	(549)
K = XT = Y WK .	(550)
In the main paper, Eq. (3) defines the novel update rule:
ξnew = f(ξ) = X softmax(β XTξ) ,	(551)
For multiple patterns, Eq. (3) becomes:
Ξnew = f(Ξ) = X softmax(β XTΞ) ,	(552)
85
where Ξ = (ξ1, . . . , ξN) is the matrix of N state (query) patterns, X is the matrix of stored (key)
patterns, and Ξnew is the matrix of new state patterns, which are averages over stored patterns. A
new state pattern can also be very similar to a single stored pattern, in which case we call the stored
pattern to be retrieved.
These matrices allow to rewrite Eq. (552) as:
(Qnew)T = KT softmax(β K QT) .	(553)
For β = 1/√dk and changing in Eq. (553) Softmax ∈ RN to a row vector (and evaluating a row
vector), we obtain:
Qnew = SoftmaX(1/Pdk Q KT) K ,	(554)
where Qnew is again the matrix of new state patterns. The new state patterns Ξnew are projected
via WV to the result patterns Z = ΞnewWV , where WV ∈ Rdk ×dv . With the pattern projection
V = K WV , we obtain the update rule Eq. (10) from the main paper:
Z = SoftmaX(1/pdk Q KT) V .	(555)
•Multiple Updates. The update Eq. (553) can be iteratively applied to the initial state ξ of every
Hopfield layer head. After the last update, the new states Ξnew are projected via WV to the result
patterns Z = Ξnew WV . Therefore, the Hopfield layer allows multiple update steps in the forward
pass without changing the number of parameters. The number of update steps can be given for every
Hopfield head individually. Furthermore, it is possible to set a threshold for the number of updates
of every Hopfield head based on kξ - ξnew k2 . In the general case of multiple initial states Ξ, the
maximum over the individual norms is taken.
•Variable β. In the main paper, we have identified β as a crucial parameter for the fixed point
dynamics of the Hopfield network, which governs the operating mode of the attention heads. In
appendix, e.g. in Lemma A7 or in Eq. (102) and Eq. (103), we showed that the characteristics of the
fixed points of the new modern Hopfield network are determined by: β, M (maximal pattern norm),
mmax (spread of the similar patterns), and kmx k (center of the similar patterns). Low values of β
induce global averaging and higher values of β metastable states. In the transformer attention, the β
parameter is set to β = 1/√dk as in Eq. (555). The Hopfield layer, however, allows to freely choose
β > 0, since the fixed point dynamics does not only depend on the dimension of the associative space
dk. Additionally, β heavily influences the gradient flow to the matrices WQ and WK . Thus, finding
the right β for the respective application can be crucial.
•	Variable dimension of the associative space. Theorem A5 says that the storage capacity of the
modern Hopfield network grows exponentially with the dimension of the associative space. However
higher dimension of the associative space also means less averaging and smaller metastable states.
The dimension of the associative space trades off storage capacity against the size of metastable
states, e.g. over how many pattern is averaged. In Eq. (550) and in Eq. (549), we assumed N raw
state patterns R = (r1, . . . , rN)T and S raw stored patterns Y = (y1, . . . , yS)T that are mapped to
a dk-dimensional associative space via the matrices WQ ∈ Rdr×dk and WK ∈ Rdy ×dk, respectively.
In the associative space Rdk, we obtain the state patterns Q = ΞT = RWQ and the stored patterns
K = XT = Y WK. The Hopfield view relates the dimension dk to the number of input patterns
N that have to be processed. The storage capacity depends exponentially on the dimension dk (the
dimension of the associative space) and the size to metastable states is governed by this dimension,
too. Consequently, dk should be chosen with respect to the number N of patterns one wants to store
and the desired size of metastable states, which is the number of patterns one wants to average over.
For example, if the input consists of many low dimensional input patterns, it makes sense to project
the patterns into a higher dimensional space to allow a proper fixed point dynamics. Intuitively, this
coincides with the construction of a richer feature space for the patterns.
•	Static Patterns. In Eq. (550) and Eq. (549), the N raw state patterns R = (r1, . . . , rN)T and
S raw stored patterns Y = (y1 , . . . , yS)T are mapped to an associative space via the matrices
WQ ∈ Rdr×dk and WK ∈ Rdy×dk, which gives the state patterns Q = ΞT = RWQ and the stored
patterns K = XT = Y WK . We allow for static state and static stored patterns. Static pattern
means that the pattern does not depend on the network input, i.e. it is determined by the bias weights
and remains constant across different network inputs. Static state patterns allow to determine whether
86
particular fixed patterns are among the stored patterns and vice versa. The static pattern functionality
is typically needed if particular patterns must be identified in the data, e.g. as described for immune
repertoire classification in the main paper, where a fixed dk-dimensional state vector ξ is used.
•	Pattern Normalization. In the appendix, e.g. in Lemma A7 or in Eq. (102) and Eq. (103), we showed
that the characteristics of the fixed points of the new modern Hopfield network are determined by:
β, M (maximal pattern norm), mmax (spread of the similar patterns), and kmx k (center of the
similar patterns). We already discussed the parameter β while the spread of the similar patterns
mmax is given by the data. The remaining variables M and mx that both control the fixed point
dynamics are adjusted pattern normalization. M is the maximal pattern norm and mx the center of
the similar patterns. Theorem A5 says that larger M allows for more patterns to be stored. However,
the size of metastable states will decrease with increasing M . The vector mx says how well the
(similar) patterns are centered. If the norm kmx k is large, then this leads to smaller metastable states.
The two parameters M and mx are controlled by pattern normalization and determine the size and
convergence properties of metastable states. These two parameters are important for creating large
gradients if heads start with global averaging which has small gradient. These two parameters can
shift a head towards small metastable states which have largest gradient as shown in Fig. A.5(b). We
allow for three different pattern normalizations:
•	pattern normalization of the input patterns,
•	pattern normalization after mapping into the associative space,
•	no pattern normalization.
The default setting is a pattern normalization of the input patterns.
A.6.3 Usage
As outlined in Sec. A.6.1, there are a variety of possible use cases for the Hopfield layer, e.g. to
build memory networks or transformer models. The goal of the implementation is therefore to
provide an easy to use Hopfield module that can be used in a wide range of applications, be it as
part of a larger architecture or as a standalone module. Consequently, the focus of the Hopfield
layer interface is set on its core parameters: the association of two sets, the scaling parameter
β, the maximum number of updates, the dimension of the associative space, the possible usage
of static patterns, and the pattern normalization. The integration into the PyTorch framework is
built such that with all the above functionalities disabled, the “HopfieldEncoderLayer” and the
“HopfieldDecoderLayer”, both extensions of the Hopfield module, can be used as a one-to-one plug-in
replacement for the TransformerEncoderLayer and the TransformerDecoderLayer, respectively, of
the PyTorch transformer module.
The Hopfield layer can be used to implement or to substitute different layers:
•	Pooling layers: We consider the Hopfield layer as a pooling layer if only one static state
(query) pattern exists. Then, it is de facto a pooling over the sequence, which results from
the softmax values applied on the stored patterns. Therefore, our Hopfield layer can act as a
pooling layer.
•	Permutation equivariant layers: Our Hopfield layer can be used as a plug-in replacement
for permutation equivariant layers. Since the Hopfield layer is an associative memory it
assumes no dependency between the input patterns.
•	GRU & LSTM layers: Our Hopfield layer can be used as a plug-in replacement for GRU
& LSTM layers. Optionally, for substituting GRU & LSTM layers, positional encoding
might be considered.
•	Attention layers: Our Hopfield layer can act as an attention layer, where state (query) and
stored (key) patterns are different, and need to be associated.
•	Finally, the extensions of the Hopfield layer are able to operate as a self-attention layer
(HopfieldEncoderLayer) and as cross-attention layer (HopfieldDecoderLayer), as described
in (Vaswani et al., 2017a). As such, it can be used as building block of transformer-based or
general architectures.
87
V
RY
Y
Figure A.7: A flowchart of the Hopfield layer. First, the raw state (query) patterns R and the raw
stored (key) patterns Y are optionally normalized (with layer normalization), projected and optionally
normalized (with layer normalization) again. The default setting is a layer normalization of the input
patterns, and no layer normalization of the projected patterns. The raw stored patterns Y can in
principle be also two different input tensors. Optionally, multiple updates take place in the projected
space of Q and K. This update rule is obtained e.g. from the full update Eq. (423) or the simplified
update Eq. (424) in the appendix.
88
References
Y. Abu-Mostafa and J.-M. StJacques. Information capacity of the Hopfield model. IEEE Transactions
on Information Theory, 31, 1985. doi: 10.1109/tit.1985.1057069.
R.	Agrawal, T. Imieliundefinedski, and A. Swami. Mining association rules between sets of items in
large databases. SIGMOD Rec.,22(2):207-216,1993. doi: 10.1145/170036.170072.
R. Akbar, P A. Robert, M. Pavlovic, J. R. Jeliazkov, I. Snapkov, A. Slabodkin, C. R. Weber,
L. Scheffer, E. Miho, I. H. Haff, et al. A compact vocabulary of paratope-epitope interactions
enables predictability of antibody-antigen binding. bioRxiv, 2019.
F. Alzahrani and A. Salem. Sharp bounds for the lambert w function. Integral Transforms and Special
Functions, 29(12):971-978, 2018.
S.	Andrews, I. Tsochantaridis, and T. Hofmann. Support vector machines for multiple-instance
learning. In S. Becker, S. Thrun, and K. Obermayer (eds.), Advances in Neural Information
Processing Systems 15, pp. 577-584. MIT Press, 2003.
J. Ba, G. E. Hinton, V. Mnih, J. Z. Leibo, and C. Ionescu. Using fast weights to attend to the recent
past. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in
Neural Information Processing Systems 29, pp. 4331-4339. Curran Associates, Inc., 2016a.
J. Ba, G. E. Hinton, V. Mnih, J. Z. Leibo, and C. Ionescu. Using fast weights to attend to the recent
past. ArXiv, 1610.06258, 2016b.
D. Bahdanau, K. Cho, and Y. Bengio. Neural machine translation by jointly learning to align and
translate. ArXiv, 1409.0473, 2014. appeared in ICRL 2015.
A. Banino, A. P. Badia, R. Koster, M.J. Chadwick, V. Zambaldi, D. Hassabis, C. Barry, M. Botvinick,
D. Kumaran, and C. Blundell. MEMO: a deep network for flexible combination of episodic
memories. ArXiv, 2001.10913, 2020.
A. Barra, M. Beccaria, and A. Fachechi. A new mechanical approach to handle generalized Hopfield
neural networks. Neural Networks, 106:205-222, 2018. doi: 10.1016/j.neunet.2018.07.010.
H. H. Bauschke and P. L. Combettes. Convex Analysis and Monotone Operator Theory in Hilbert
Spaces. Cham: Springer International Publishing, 2nd edition, 2017. ISBN 978-3-319-48310-8.
doi: 10.1007/978-3-319-48311-5.
S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 7th edition, 2009.
ISBN 978-0-521-83378-3.
J. S. Brauchart, A. B. Reznikov, E. B. Saff, I. H. Sloan, Y. G. Wang, and R. S. Womersley. Random
point sets on the sphere - hole radii, covering, and separation. Experimental Mathematics, 27(1):
62-81, 2018. doi: 10.1080/10586458.2016.1226209.
L.	Breiman. Random forests. Machine Learning, 45(1):5-32, 2001. doi: 10.1023/A:1010933404324.
J. Bruck and V. P. Roychowdhury. On the number of spurious memories in the Hopfield model. IEEE
Transactions on Information Theory, 36(2):393-397, 1990.
T. Cai, J. Fan, and T. Jiang. Distributions of angles in random packing on spheres. Journal of Machine
Learning Research, 14(21):1837-1864, 2013.
M.-A. Carbonneau, V. Cheplygina, E. Granger, and G. Gagnon. Multiple instance learning: a survey
of problem characteristics and applications. Pattern Recognition, 77:329-353, 2018.
MarC-Andre Carbonneau, Eric Granger, Alexandre J. Raymond, and Ghyslain Gagnon. Ro-
bust multiple-instance learning ensembles using random subspace instance selection. Pat-
tern Recognition, 58:83 - 99, 2016. ISSN 0031-3203. doi: https://doi.org/10.1016/j.
patcog.2016.03.035. URL http://www.sciencedirect.com/science/article/
pii/S0031320316300346.
89
M.	Carreira-Perpindn and C. K. I. Williams. An isotropic Gaussian mixture can have more modes
than components. Technical Report EDI-INF-RR-0185, The University of Edinburgh, School of
Informatics, 2003.
A. Carta, A. Sperduti, and D. Bacciu. Encoding-based memory modules for recurrent neural networks.
ArXiv, 2001.11771, 2020.
T. Chen and C. Guestrin. XGBoost: A scalable tree boosting system. In Proceedings of the 22nd
ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp. 785-794.
ACM, 2016. doi: 10.1145/2939672.2939785.
Y. Chen, J. Bi, and J. Z. Wang. MILES: Multiple-instance learning via embedded instance selection.
IEEE Transactions on Pattern Analysis and Machine Intelligence, 28(12):1931-1947, 2006.
V Cheplygina, DM Tax, and M Loog. Dissimilarity-based ensembles for multiple instance learning.
IEEE transactions on neural networks and learning systems, 27(6):1379, 2016.
K. Cho, B. vanMerrienboer, C. Gulcehre, D. Bahdanau, F. Bougares, H. Schwenk, and Y. Bengio.
Learning phrase representations using RNN encoder-decoder for statistical machine translation. In
Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP),
pp. 1724-1734. Association for Computational Linguistics, 2014. doi: 10.3115/v1/D14-1179.
K. Clark, M.-T. Luong, Q. V. Le, and C. D. Manning. ELECTRA: Pre-training text encoders as
discriminators rather than generators. ArXiv, 2003.10555, 2020. appeared in ICLR 2020.
C. Cortes and V. Vapnik. Support-vector networks. Machine learning, 20(3):273-297, 1995.
A. Crisanti, D. J. Amit, and H. Gutfreund. Saturation level of the Hopfield model for neural network.
Europhysics Letters (EPL), 2(4):337-341, 1986. doi: 10.1209/0295-5075/2/4/012.
I.	Danihelka, G. Wayne, B. Uria, N. Kalchbrenner, and A. Graves. Associative long short-term
memory. In M. F. Balcan and K. Q. Weinberger (eds.), Proceedings of The 33rd International
Conference on Machine Learning, volume 48 of Proceedings of Machine Learning Research, pp.
1986-1994, New York, USA, 2016.
M. Daniluk, T. Rocktaschel, J. WelbL and S. Riedel. Frustratingly short attention spans in neural
language modeling. ArXiv, 1702.04521, 2017. appeared in ICRL 2017.
M. Dehghani, S. Gouws, O. Vinyals, J. Uszkoreit, and L. Kaiser. Universal transformers. ArXiv,
1807.03819, 2018. Published at ICLR 2019.
M. Demircigil, J. Heusel, M. Lowe, S. Upgang, and F. Vermet. On a model of associative memory
with huge storage capacity. Journal of Statistical Physics, 168(2):288-299, 2017.
J.	Devlin, M.-W. Chang, K. Lee, and K. Toutanova. BERT: pre-training of deep bidirectional
transformers for language understanding. ArXiv, 1810.04805, 2018.
J. Devlin, M.-W. Chang, K. Lee, and K. Toutanova. BERT: pre-training of deep bidirectional trans-
formers for language understanding. In Proceedings of the 2019 Conference of the North American
Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume
1 (Long and Short Papers), pp. 4171-4186. Association for Computational Linguistics, 2019.
T. G. Dietterich, R. H. Lathrop, and T. Lozano-PCrez. Solving the multiple instance problem with
axis-parallel rectangles. Artificial Intelligence, 89(1-2):31-71, 1997.
R. O. Emerson, W. S. DeWitt, M. Vignali, J. Gravley, J. K. Hu, E. J. Osborne, C. Desmarais,
M. Klinger, C. S. Carlson, J. A. Hansen, et al. Immunosequencing identifies signatures of
cytomegalovirus exposure history and HLA-mediated effects on the T cell repertoire. Nature
Genetics, 49(5):659, 2017.
M. Ferndndez-Delgado, E. Cernadas, S. Barro, and D. Amorim. Do we need hundreds of classifiers
to solve real world classification problems? The Journal of Machine Learning Research, 15(1):
3133-3181, 2014.
90
V. Folli, M. Leonetti, and G. Ruocco. On the maximum storage capacity of the Hopfield model.
Frontiers in Computational Neuroscience, 10(144), 2017. doi: 10.3389/fncom.2016.00144.
B. Gao and L. Pavel. On the properties of the softmax function with application in game theory and
reinforcement learning. ArXiv, 1704.00805, 2017.
D. J. H. Garling. Analysis on Polish Spaces and an Introduction to Optimal Transportation. London
Mathematical Society Student Texts. Cambridge University Press, 2017. ISBN 1108421571. doi:
10.1017/9781108377362.
J. Gilmer, S. S. Schoenholz, P. F. Riley, O. Vinyals, and G. E. Dahl. Neural message passing for
quantum chemistry. In Proceedings of the 34th International Conference on Machine Learning
(ICML), volume 70, pp. 1263-1272. JMLR.org, 2017.
A. Graves, G. Wayne, and I. Danihelka. Neural turing machines. ArXiv, 1410.5401, 2014.
N. Guttenberg, N. Virgo, O. Witkowski, H. Aoki, and R. Kanai. Permutation-equivariant neural
networks applied to dynamics prediction. arXiv, 1612.04530, 2016.
J. Hertz, A. Krogh, and R. G. Palmer. Introduction to the Theory of Neural Computation. Addison-
Wesley Longman Publishing Co., Inc., Redwood City, CA, 1991. ISBN 0201503956.
S. Hochreiter. Untersuchungen ZU dynamischen neuronalen Netzen. Diploma thesis, Institut fur Infor-
matik, Lehrstuhl Prof. Brauer, Technische Universitat Munchen, 1991. Advisor: J. Schmidhuber.
S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural Comput., 9(8):1735-1780, 1997.
A. Hoorfar and M. Hassani. Inequalities on the Lambert w function and hyperpower function. Journal
of Inequalities in Pure and Applied Mathematics, 9(2):1-5, 2008.
J. J. Hopfield. Neural networks and physical systems with emergent collective computational abilities.
Proceedings of the National Academy of Sciences, 79(8):2554-2558, 1982.
J. J. Hopfield. Neurons with graded response have collective computational properties like those of
two-state neurons. Proceedings of the National Academy of Sciences, 81(10):3088-3092, 1984.
doi: 10.1073/pnas.81.10.3088.
M. Ilse, J. M. Tomczak, and M. Welling. Attention-based deep multiple instance learning. Interna-
tional Conference on Machine Learning (ICML), pp. 3376-3391, 2018.
M. Ilse, J. M. Tomczak, and M. Welling. Deep multiple instance learning for digital histopathology.
In Handbook of Medical Image Computing and Computer Assisted Intervention, pp. 521-546.
Elsevier, 2020.
D. Jiang, Z. Wu, C.-Y. Hsieh, G. Chen, B. Liao, Z. Wang, C. Shen, D. Cao, J. Wu, and T. Hou. Could
graph neural networks learn better molecular representation for drug discovery? a comparison
study of descriptor-based and graph-based models. Journal of Cheminformatics, 2020. doi:
10.21203/rs.3.rs-81439/v1.
M. Kandemir, C. Zhang, and F. A. Hamprecht. Empowering multiple instance histopathology
cancer diagnosis by cell graphs. In International Conference on Medical Image Computing and
Computer-Assisted Intervention, pp. 228-235. Springer, 2014.
M. M. R. Khan, R. B. Arif, M. A. B. Siddique, and M. R. Oishe. Study and observation of the
variation of accuracies of KNN, SVM, LMNN, ENN algorithms on eleven different datasets from
UCI machine learning repository. In 4th International Conference on Electrical Engineering and
Information & Communication Technology (iCEEiCT), pp. 124-129. IEEE, 2018.
T. N. Kipf and M. Welling. Semi-supervised classification with graph convolutional networks. ArXiv,
1609.02907, 2016. in International Conference On Learning Representations (ICLR) 2017.
G. Klambauer, T. Unterthiner, A. Mayr, and S. Hochreiter. Self-normalizing neural networks. In
Advances in Neural Information Processing Systems, pp. 971-980, 2017a.
91
G. Klambauer, T. Unterthiner, A. Mayr, and S. Hochreiter. Self-normalizing neural networks. ArXiv,
1706.02515, 2017b.
P. Koiran. Dynamics of discrete time, continuous state Hopfield networks. Neural Computation, 6(3):
459-468,1994. doi: 10.1162∕neco.1994.6.3.459.
I. Korshunova, J. Degrave, F. Huszar, Y. Gal, A. Gretton, and J. Dambre. BRUNO: A deep recurrent
model for exchangeable data. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-
Bianchi, and R. Garnett (eds.), Advances in Neural Information Processing Systems 31, pp.
7190-7198. Curran Associates, Inc., 2018.
D. Krotov and J. J. Hopfield. Dense associative memory for pattern recognition. In D. D. Lee,
M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in Neural Information
Processing Systems, pp. 1172-1180. Curran Associates, Inc., 2016.
D. Krotov and J. J. Hopfield. Dense associative memory is robust to adversarial inputs. Neural
Computation, 30(12):3151-3167, 2018.
D.	Krotov and J. J. Hopfield. Large associative memory problem in neurobiology and machine
learning. ArXiv, 2008.06996, 2020.
E.	S. KUgUkaSCI and M. G. Baydogan. Bag encoding strategies in multiple instance learning problems.
Information Sciences, 467:559-578, 2018.
M. Kuhn, I. Letunic, L. J. Jensen, and P. Bork. The SIDER database of drugs and side effects. Nucleic
Acids Research, 44(D1):D1075-D1079, 2016. doi: 10.1093/nar/gkv1075.
Y. LeCun, Y. Bengio, and G. Hinton. Deep learning. Nature, 521:436-444, 2015.
T. Lipp and S. Boyd. Variations and extension of the convex-concave procedure. Optimization and
Engineering, 17(2):263-287, 2016. doi: 10.1007/s11081-015-9294-x.
Ilya Loshchilov and Frank Hutter. Decoupled weight decay regularization. arXiv preprint
arXiv:1711.05101, 2017.
O. Maron and T. Lozano-PCrez. A framework for multiple-instance learning. In M. I. Jordan, M. J.
Kearns, and S. A. Solla (eds.), Advances in Neural Information Processing Systems, pp. 570-576.
MIT Press, 1998.
I. F. Martins, A. L. Teixeira, L. Pinheiro, and A. O. Falcao. A Bayesian approach to in silico
blood-brain barrier penetration modeling. Journal of Chemical Information and Modeling, 52(6):
1686-1697, 2012. doi: 10.1021/ci300124c.
C. Mazza. On the storage capacity of nonlinear neural networks. Neural Networks, 10(4):593-597,
1997. doi: 10.1016/S0893-6080(97)00017-8.
R. J. McEliece, E. C. Posner, E. R. Rodemich, and S. S. Venkatesh. The capacity of the Hopfield
associative memory. IEEE Trans. Inf. Theor., 33(4):461-482, 1987. doi: 10.1109/TIT.1987.
1057328.
R. R. Meyer. Sufficient conditions for the convergence of monotonic mathematical programming
algorithms. Journal of Computer and System Sciences, 12(1):108-121, 1976. doi: 10.1016/
S0022-0000(76)80021-9.
F. W. J. Olver, D. W. Lozier, R. F. Boisvert, and C. W. Clark. NIST handbook of mathematical
functions. Cambridge University Press, 1 pap/cdr edition, 2010. ISBN 9780521192255.
A. Paszke, S. Gross, S. Chintala, G. Chanan, E. Yang, Z. DeVito, Z. Lin, A. Desmaison, L. Antiga, and
A. Lerer. Automatic differentiation in PyTorch. In Workshop in Advances in Neural Information
Processing Systems (NeurIPS), 2017.
A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin, N. Gimelshein,
L. Antiga, et al. PyTorch: An imperative style, high-performance deep learning library. In Advances
in Neural Information Processing Systems, pp. 8026-8037, 2019.
92
C. R. Qi, H. Su, M. Kaichun, and L. J. Guibas. PointNet: Deep learning on point sets for 3d
classification and segmentation. In IEEE Conference on Computer Vision and Pattern Recognition
(CVPR),pp.77-85,2017a. doi:10.1109/CVPR.2017.16.
C. R. Qi, L. Yi, H. Su, and L. J. Guibas. PointNet++: Deep hierarchical feature learning on point sets
in a metric space. In 31st International Conference on Neural Information Processing Systems, pp.
5105-5114. Curran Associates Inc., 2017b.
A. Rangarajan, S. Gold, and E. Mjolsness. A novel optimizing network architecture with applications.
Neural Computation, 8(5):1041-1060, 1996. doi: 10.1162/neco.1996.8.5.1041.
A. Rangarajan, A. Yuille, and Eric E. Mjolsness. Convergence properties of the softassign
quadratic assignment algorithm. Neural Computation, 11(6):1455-1474, 1999. doi: 10.1162/
089976699300016313.
S. Ravanbakhsh, J. Schneider, and B. Poczos. Deep learning with sets and point clouds. arXiv,
1611.04500, 2016.
I. Schlag and J. Schmidhuber. Learning to reason with third order tensor products. In S. Bengio,
H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett (eds.), Advances in
Neural Information Processing Systems 31, pp. 9981-9993. Curran Associates, Inc., 2018.
I. Schlag, P. Smolensky, R. Fernandez, N. Jojic, J. Schmidhuber, and J. Gao. Enhancing the
transformer with explicit relational encoding for math problem solving. arXiv, 1910.06611, 2019.
I. Schlag, K. Irie, and J. Schmidhuber. Linear transformers are secretly fast weight memory systems.
arXiv, 2102.11174, 2021.
J. Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent
networks. In Neural Computations, Volume: 4, Issue: 1, pp. 131 - 139. MIT Press, 1992.
J. Schmidhuber. Deep learning in neural networks: An overview. Neural Networks, 61:85-117, 2015.
doi: 10.1016/j.neunet.2014.09.003.
B. SChOlkOPf and A. J. Smola. Learning with Kernels - Support Vector Machines, Regularization,
Optimization, and Beyond. MIT Press, Cambridge, MA, 2002.
B. K. Sriperumbudur and G. R. Lanckriet. On the convergence of the concave-convex procedure. In
Y. Bengio, D. Schuurmans, J. D. Lafferty, C. K. I. Williams, and A. Culotta (eds.), Advances in
Neural Information Processing Systems 22, pp. 1759-1767. Curran Associates, Inc., 2009.
G. Subramanian, B. Ramsundar, V. Pande, and R. A. Denny. Computational modeling of β-Secretase
1 (BACE-1) inhibitors using ligand based approaches. Journal of Chemical Information and
Modeling, 56(10):1936-1949, 2016. doi: 10.1021/acs.jcim.6b00290.
S. Sukhbaatar, A. Szlam, J. Weston, and R. Fergus. End-to-end memory networks. In C. Cortes,
N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett (eds.), Advances in Neural Information
Processing Systems 28, pp. 2440-2448. Curran Associates, Inc., 2015a.
S. Sukhbaatar, A. Szlam, J. Weston, and R. Fergus. End-to-end memory networks. ArXiv, 1503.08895,
2015b.
R. S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. MIT Press, Cambridge,
MA, 2 edition, 2018.
F. Tanaka and S. F. Edwards. Analytic theory of the ground state properties ofa spin glass. I. Ising spin
glass. Journal of Physics F: Metal Physics, 10(12):2769-2778, 1980. doi: 10.1088/0305-4608/10/
12/017.
Y. Tay, D. Bahri, D. Metzler, D.-C. Juan, Z. Zhao, and C. Zheng. Synthesizer: Rethinking self-
attention in transformer models. ArXiv, 2005.00743, 2020.
93
M. Toneva and L. Wehbe. Interpreting and improving natural-language processing (in machines)
with natural language-processing (in the brain). In H. Wallach, H. Larochelle, A. Beygelzimer,
F. d'Alche-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information Processing Systems
32, pp.14954-14964. Curran Associates, Inc., 2019a.
M. Toneva and L. Wehbe. Interpreting and improving natural-language processing (in machines)
with natural language-processing (in the brain). arXiv, 1905.11833, 2019b.
J. J. Torres, L. Pantic, and Hilbert H. J. Kappen. Storage capacity of attractor neural networks with
depressing synapses. Phys. Rev. E, 66:061910, 2002. doi: 10.1103/PhysRevE.66.061910.
A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polo-
sukhin. Attention is all you need. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus,
S. Vishwanathan, and R. Garnett (eds.), Advances in Neural Information Processing Systems 30,
pp. 5998-6008. Curran Associates, Inc., 2017a.
A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin.
Attention is all you need. ArXiv, 1706.03762, 2017b.
P. VeliCkoviC, G. Cucurull, A. Casanova, A. Romero, P. Lio, and Y. Bengio. Graph attention networks.
arXiv, 1710.10903, 2018. in International Conference On Learning Representations (ICLR) 2018.
M. Wainberg, B. Alipanahi, and B. J. Frey. Are random forests truly the best classifiers? The Journal
of Machine Learning Research, 17(1):3837-3841, 2016.
G. Wainrib and J. Touboul. Topological and dynamical complexity of random neural networks. Phys.
Rev. Lett., 110:118101, 2013. doi: 10.1103/PhysRevLett.110.118101.
J. Wang. Solving the multiple-instance problem: A lazy learning approach. In Proceedings of the
17th International Conference on Machine Learning (ICML), 2000.
X. Wang, Y. Yan, P. Tang, X. Bai, and W. Liu. Revisiting multiple instance neural networks. Pattern
Recognition, 74:15-24, 2018.
C. R. Weber, R. Akbar, A. Yermanos, M. PavloviC, I. Snapkov, G. K. Sandve, S. T. Reddy, and
V. Greiff. immuneSIM: tunable multi-feature simulation of B- and T-cell receptor repertoires
for immunoinformatics benchmarking. Bioinformatics, 36(11):3594-3596, 2020. doi: 10.1093/
bioinformatics/btaa158.
J. Weston, S. Chopra, and A. Bordes. Memory networks. ArXiv, 1410.3916, 2014.
M. Widrich, B. Schafl, M. PavloviC, H. Ramsauer, L. Gruber, M. Holzleitner, J. Brandstetter, G. K.
Sandve, V. Greiff, S. Hochreiter, and G. Klambauer. Modern Hopfield networks and attention for
immune repertoire classification. ArXiv, 2007.13505, 2020a.
M. Widrich, B. Schafl, M. Pavlovic, H. Ramsauer, L. Gruber, M. Holzleitner, J. Brandstetter, G. K.
Sandve, V. Greiff, S. Hochreiter, and G. Klambauer. Modern Hopfield networks and attention for
immune repertoire classification. In Advances in Neural Information Processing Systems. Curran
Associates, Inc., 2020b.
T. Wolf, L. Debut, V. Sanh, J. Chaumond, C. Delangue, A. Moi, P. Cistac, T. Rault, R. Louf,
M. Funtowicz, and J. Brew. HuggingFace’s transformers: State-of-the-art natural language
processing. ArXiv, 1910.03771, 2019.
J. C. F. Wu. On the convergence properties of the em algorithm. Ann. Statist., 11(1):95-103, 1983.
doi: 10.1214/aos/1176346060.
X. Wu, X. Liu, W. Li, and Q. Wu. Improved expressivity through dendritic neural networks. In
S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett (eds.),
Advances in Neural Information Processing Systems 31, pp. 8057-8068. Curran Associates, Inc.,
2018.
Z. Wu, B. Ramsundar, E. N. Feinberg, J. Gomes, C. Geniesse, A. S. Pappu, K. Leswing, and V. Pande.
MoleculeNet: A benchmark for molecular machine learning. arXiv, 1703.00564, 2017.
94
Z. Xiong, D. Wang, X. Liu, F. Zhong, X. Wan, X. Li, Z. Li, X. Luo, K. Chen, H. Jiang, and
M. Zheng. Pushing the boundaries of molecular representation for drug discovery with the
graph attention mechanism. Journal of Medicinal Chemistry, 63(16):8749-8760, 2θ20. doi:
10.1021/acs.jmedchem.9b00959.
Y. Xu, T. Fan, M. Xu, L. Zeng, and Y. Qiao. SpiderCNN: Deep learning on point sets with
parameterized convolutional filters. In V. Ferrari, M. Hebert, C. Sminchisescu, and Y. Weiss (eds.),
European Conference on Computer Vision (ECCV), pp. 90-105. Springer International Publishing,
2018.
A. L. Yuille and A. Rangarajan. The concave-convex procedure (CCCP). In T. G. Dietterich,
S. Becker, and Z. Ghahramani (eds.), Advances in Neural Information Processing Systems 14, pp.
1033-1040. MIT Press, 2002.
A. L. Yuille and A. Rangarajan. The concave-convex procedure. Neural Computation, 15(4):915-936,
2003. doi: 10.1162/08997660360581958.
M. Zaheer, S. Kottur, S. Ravanbakhsh, B. Poczos, R. R. Salakhutdinov, and A. J. Smola. Deep sets.
In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett
(eds.), Advances in Neural Information Processing Systems 30, pp. 3391-3401. Curran Associates,
Inc., 2017.
W. I. Zangwill. Nonlinear programming: a unified approach. Prentice-Hall international series in
management. Englewood Cliffs, N.J., 1969. ISBN 9780136235798.
S. Zhai, W. Talbott, M. A. Bautista, C. Guestrin, and J. M. Susskind. Set distribution networks: a
generative model for sets of images. arXiv, 2006.10705, 2020.
W. Zhang and B. Zhou. Learning to update auto-associative memory in recurrent neural networks for
improving sequence memorization. ArXiv, 1709.06493, 2017.
Y. Zhu, R. Kiros, R. S. Zemel, R. Salakhutdinov, R. Urtasun, A. Torralba, and S. Fidler. Aligning
books and movies: Towards story-like visual explanations by watching movies and reading books.
Proceedings of the IEEE international conference on computer vision, pp. 19-27, 2015. arXiv
1506.06724.
95