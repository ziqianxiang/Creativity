Published as a conference paper at ICLR 2021
Image Augmentation Is All You Need:
Regularizing Deep Reinforcement Learning
from Pixels
Denis Yarats*
New York University & Facebook AI Research
denisyarats@cs.nyu.edu
Ilya Kostrikov*
New York University
kostrikov@cs.nyu.edu
Rob Fergus
New York University
fergus@cs.nyu.edu
Ab stract
Existing model-free reinforcement learning (RL) approaches are effective when
trained on states but struggle to learn directly from image observations. We
propose an augmentation technique that can be applied to standard model-free
RL algorithms, enabling robust learning directly from pixels without the need
for auxiliary losses or pre-training. The approach leverages input perturbations
commonly used in computer vision tasks to transform input examples, as well
as regularizing the value function and policy. Our approach reaches a new state-
of-the-art performance on DeepMind control suite and Atari 100k benchmark,
surpassing previous model-free (Haarnoja et al., 2018; van Hasselt et al., 2019a),
model-based (Hafner et al., 2019; Lee et al., 2019; Hafner et al., 2018; Kaiser et al.,
2019) and contrastive learning (Srinivas et al., 2020) approaches. It also closes the
gap between state-based and image-based RL training. Our method, which we dub
DrQ: Data-regularized Q, can be combined with any model-free RL algorithm.
To the best of our knowledge, our approach is the first effective data augmentation
method for RL on these benchmarks.
1	Introduction
Sample-efficient deep reinforcement learning (RL) algorithms capable of directly training from image
pixels would open up many real-world applications in control and robotics. However, simultaneously
training a convolutional encoder alongside a policy network is challenging when given limited
environment interaction, strong correlation between samples and a typically sparse reward signal.
Limited supervision is a common problem across AI and two approaches are commonly taken: (i)
training with an additional auxiliary losses, such as those based on self-supervised learning (SSL)
and (ii) training with data augmentation.
A wide range of auxiliary loss functions have been proposed to augment supervised objectives, e.g.
weight regularization, noise injection (Hinton et al., 2012), or various forms of auto-encoder (Kingma
et al., 2014). In RL, reconstruction losses (Jaderberg et al., 2017; Yarats et al., 2019) or SSL objectives
(Dwibedi et al., 2018; Srinivas et al., 2020) are used. However, these objectives are unrelated to the
task at hand, thus have no guarantee of inducing an appropriate representation for the policy network.
SSL losses are highly effective in the large data regime, e.g. in domains such as vision (Chen et al.,
2020; He et al., 2019) and NLP (Collobert et al., 2011; Devlin et al., 2018) where large (unlabeled)
datasets are readily available. However, in sample-efficient RL, training data is more limited due to
restricted interaction between the agent and the environment, limiting their effectiveness.
Data augmentation methods are widely used in vision and speech domains, where output-invariant
perturbations can easily be applied to the labeled input examples. Surprisingly, data augmentation
* Equal contribution. Author ordering determined by coin flip. Both authors are corresponding.
1
Published as a conference paper at ICLR 2021
has received little attention in the RL community. In this paper we propose augmentation approaches
appropriate for sample-efficient RL and comprehensively evaluate them. The key idea of our approach
is to use standard image transformations to perturb input observations, as well as regularizing the
Q-function learned by the critic so that different transformations of the same input image have
similar Q-function values. No further modifications to standard actor-critic algorithms are required.
Our study is, to the best of our knowledge, the first careful examination of image augmentation in
sample-efficient RL.
The main contributions of the paper are as follows: (i) the first to demonstrate that data augmentation
greatly improves performance when training model-free RL algorithms from images; (ii) introducing
a natural way to exploit MDP structure through two mechanisms for regularizing the value function,
in a manner that is generally applicable to model-free RL and (iii) setting a new state-of-the-art
performance on the standard DeepMind control suite (Tassa et al., 2018), closing the gap between
learning from states, and Atari 100k (Kaiser et al., 2019) benchmarks.
2	Related Work
Data Augmentation in Computer Vision Data augmentation via image transformations has been
used to improve generalization since the inception of convolutional networks (Becker & Hinton,
1992; Simard et al., 2003; LeCun et al., 1989; Ciresan et al., 2011; Ciregan et al., 2012). Following
AlexNet (Krizhevsky et al., 2012), they have become a standard part of training pipelines. For object
classification tasks, the transformations are selected to avoid changing the semantic category, i.e.
translations, scales, color shifts, etc. While a similar set of transformations are potentially applicable
to control tasks, the RL context does require modifications to be made to the underlying algorithm.
Data augmentation methods have also been used in the context of self-supervised learning. Dosovit-
skiy et al. (2016) use per-exemplar perturbations in a unsupervised classification framework. More
recently, several approaches (Chen et al., 2020; He et al., 2019; Misra & van der Maaten, 2019)
have used invariance to imposed image transformations in contrastive learning schemes, producing
state-of-the-art results on downstream recognition tasks. By contrast, our scheme addresses control
tasks, utilizing different types of invariance.
Data Augmentation in RL In contrast to computer vision, data augmentation is rarely used in RL.
Certain approaches implicitly adopt it, for example Levine et al. (2018); Kalashnikov et al. (2018)
use image augmentation as part of the AlexNet training pipeline without analysing the benefits
occurring from it, thus being overlooked in subsequent work. HER (Andrychowicz et al., 2017)
exploits information about the observation space by goal and reward relabeling, which can be viewed
as a way to perform data augmentation. Other work uses data augmentation to improve generalization
in domain transfer (Cobbe et al., 2018). However, the classical image transformations used in
vision have not previously been shown to definitively help on standard RL benchmarks. Concurrent
with our work, RAD (Laskin et al., 2020) performs an exploration of different data augmentation
approaches, but is limited to transformations of the image alone, without the additional augmentation
of the Q-function used in our approach. Moreover, RAD can be regarded as a special case of our
algorithm. Multiple follow ups to our initial preprint appeared on ArXiv (Raileanu et al., 2020; Okada
& Taniguchi, 2020), using similar techniques on other tasks, thus supporting the effectiveness and
generality of data augmentation in RL.
Continuous Control from Pixels There are a variety of methods addressing the sample-efficiency
of RL algorithms that directly learn from pixels. The most prominent approaches for this can be
classified into two groups, model-based and model-free methods. The model-based methods attempt
to learn the system dynamics in order to acquire a compact latent representation of high-dimensional
observations to later perform policy search (Hafner et al., 2018; Lee et al., 2019; Hafner et al., 2019).
In contrast, the model-free methods either learn the latent representation indirectly by optimizing the
RL objective (Barth-Maron et al., 2018; Abdolmaleki et al., 2018) or by employing auxiliary losses
that provide additional supervision (Yarats et al., 2019; Srinivas et al., 2020; Sermanet et al., 2018;
Dwibedi et al., 2018). Our approach is complementary to these methods and can be combined with
them to improve performance.
2
Published as a conference paper at ICLR 2021
3	Background
Reinforcement Learning from Images We formulate image-based control as an infinite-horizon
partially observable Markov decision process (POMDP) (Bellman, 1957; Kaelbling et al., 1998). An
POMDP can be described as the tuple (O, A,p, r, γ), where O is the high-dimensional observation
space (image pixels), A is the action space, the transition dynamics P = Pr(ot∖o≤t, at) capture the
probability distribution over the next observation o0t given the history of previous observations o≤t
and current action at, r : O × A → R is the reward function that maps the current observation and
action to a reward rt = r(o≤t, at), and γ ∈ [0, 1) is a discount factor. Per common practice (Mnih
et al., 2013), throughout the paper the POMDP is converted into an MDP (Bellman, 1957) by stacking
several consecutive image observations into a state st = {ot, ot-1, ot-2, . . .}. For simplicity we
redefine the transition dynamics p = P r(s0t∖st, at) and the reward function rt = r(st, at). We then
aim to find a policy ∏(at∖st) that maximizes the cumulative discounted return En [P∞=ι Ytrt ∖at 〜
π(∙∖st),st 〜P(∙∖st,at),s1 〜P(∙)].
Soft Actor-Critic The Soft Actor-Critic (SAC) (Haarnoja et al., 2018) learns a state-action value
function Qθ , a stochastic policy πθ and a temperature α to find an optimal policy for an MDP
(S, A, p, r, γ) by optimizing a γ-discounted maximum-entropy objective (Ziebart et al., 2008). θ is
used generically to denote the parameters updated through training in each part of the model.
Deep Q-learning DQN (Mnih et al., 2013) also learns a convolutional neural net to approximate
Q-function over states and actions. The main difference is that DQN operates on discrete actions
spaces, thus the policy can be directly inferred from Q-values. In practice, the standard version
of DQN is frequently combined with a set of refinements that improve performance and training
stability, commonly known as Rainbow (van Hasselt et al., 2015). For simplicity, the rest of the paper
describes a generic actor-critic algorithm rather than DQN or SAC in particular. Further background
on DQN and SAC can be found in Appendix A.
4	Sample Efficient Reinforcement Learning from Pixels
4.1	Optimality Invariant Image Transformations for Q function
We first introduce a general framework for regularizing the value function through transformations of
the input state. For a given task, we define an optimality invariant state transformation f : S × T → S
as a mapping that preserves the Q-values
Q(s, a) = Q(f (s, ν), a) for all s ∈ S, a ∈ A and ν ∈ T.
where V are the parameters of f (∙), drawn from the set of all possible parameters T. One example of
such transformations are the random image translations successfully applied in the previous section.
For every state, the transformations allow the generation of several surrogate states with the same
Q-values, thus providing a mechanism to reduce the variance of Q-function estimation. In particular,
for an arbitrary distribution of states μ(∙) and policy π, instead of using a single sample s* 〜μ(∙),
a 〜∏(∙∖s*) estimation of the following expectation
Es〜μ(∙) [Q(s, a)] ≈ Q(S*,a*)
a 〜π(∙∣ s)
we generate K samples via random transformations and obtain an estimate with lower variance
1K
E s〜μ(∙) [Q(s, a)] ≈ K £Q(f (s*, Vk),ak) where Vk ∈ Tand ak 〜π(∙∖f (s*, νk)').
a~π(Ts)	k=ι
This suggests two distinct ways to regularize Q-function. First, we use the data augmentation to
compute the target values for every transition tuple (Si, ai, ri, S0i) as
1K
yi = Ti + YKEQθ(J(Si ν0,k),ai,k)where ai,k 〜π(∙∖f (si, ν0,k))	⑴
k=1
3
Published as a conference paper at ICLR 2021
where νi0,k ∈ T corresponds to a transformation parameter of s0i. Then the Q-function is updated
using these targets through an SGD update using learning rate λθ
1N
θ 一 θ - λθNe N ɪ2(Qθ(f(si, Vi) ,ai) - yi) .	(2)
i=1
In tandem, we note that the same target from Equation (1) can be used for different augmentations of
si , resulting in the second regularization approach
1 N,M
θ J θ - λθ Re NM ^X (Qθ (f (si, νi,m), ai) - yi)2.	(3)
i=1,m=1
When both regularization methods are used, νi,m and νi0,k are drawn independently.
4.2	Practical Instantiation of Optimality Invariant Image Transformation
A range of successful image augmentation techniques have been developed in computer vision
(Ciregan et al., 2012; Ciresan et al., 2011; Simard et al., 2003; Krizhevsky et al., 2012; Chen et al.,
2020). These apply transformations to the input image for which the task labels are invariant, e.g. for
object recognition tasks, image flips and rotations do not alter the semantic label. However, tasks in
RL differ significantly from those in vision and in many cases the reward would not be preserved by
these transformations. We examine image transformations from Chen et al. (2020) (random shifts,
random cutouts, horizontal/vertical flips, rotations and intensity shifts) in Appendix E and conclude
that random shifts strike a good balance between simplicity and performance, we therefore limit our
choice of transformation function f (∙) to random shifts.
We apply shifts to the images sampled from the replay buffer. For example, images from the
DeepMind control suite used in our experiments are 84 × 84. We pad each side by 4 pixels (by
repeating boundary pixels) and then select a random 84 × 84 crop, yielding the original image shifted
by ±4 pixels. This procedure is repeated every time an image is sampled from the replay buffer.
4.3	Our approach: Data-regularized Q (DrQ)
Our approach, DrQ, is the union of the three separate regularization mechanisms introduced above:
1.	transformations of the input image (Section 4.2).
2.	averaging the Q target over K image transformations (Equation (1)).
3.	averaging the Q function itself over M image transformations (Equation (3)).
Algorithm 1 details how they are incorporated into a generic pixel-based off-policy actor-critic
algorithm. Note that if [K=1,M=1] then DrQ reverts to image transformations alone, this makes
applying DrQ to any model-free RL algorithm straightforward.
For the experiments in this paper, we pair DrQ with SAC (Haarnoja et al., 2018) and DQN (Mnih
et al., 2013), popular model-free algorithms for control in continuous and discrete action spaces
respectively. We select image shifts as the class of image transformations f, with ν ± 4, as explained
in Section 4.2.
5	Experiments
5.1	Ablation Experiment
Figure 1 shows the effect of image shift augmentation applied to three tasks from the DeepMind
control suite (Tassa et al., 2018). Figure 1a shows unmodified SAC (Haarnoja et al., 2018) parameter-
ized with different image encoders, taken from: NatureDQN (Mnih et al., 2013), Dreamer (Hafner
et al., 2019), Impala (Espeholt et al., 2018), SAC-AE (Yarats et al., 2019), and D4PG (Barth-Maron
et al., 2018). The encoders vary significantly in their architecture and capacity, with parameter
4
Published as a conference paper at ICLR 2021
Algorithm 1 DrQ: Data-regularized Q applied to a generic off-policy actor critic algorithm.
Black: unmodified off-policy actor-critic.
Orange: image transformation.
Green: target Q augmentation.
Blue: Q augmentation.
Hyperparameters: Total number of environment steps T , mini-batch size N, learning rate λθ,
target network update rate τ, image transformation f, number of target Q augmentations K,
number of Q augmentations M .
for each timestep t = 1..T do
at 〜∏(∙∣st)
st 〜P(Ist,a∕
DjD∪ (st, at, r(st, a。, st)	. Add a transition to the replay buffer
UPDATECRITIC(D)
UPDATEACTOR(D) . Data augmentation is applied to the samples for actor training as well
end for
procedure UPDATECRITIC(D)
{(si, a%, ri, si)}N=ι 〜D	. Sample a mini batch from the replay buffer
(ν0 k∣ν0 k 〜U(T), i = 1..N,k = 1..k}	. Uniformly sample target augmentations
for each i = 1..N do
ai 〜π(Isi) or ai,k 〜π" f (Si, ν0,k)),k = 1..K
Qi = qΘ0(si,ai) or Qi = K PK=I qΘ0(f (si,ν0,k),ai,k)
y J r(si, ai) + γQi
end for
{νi,m∖νi,m 〜U(T), i = 1..N,m = 1..M}	. Uniformly sample Q augmentations
JQ(O) = N PN=ι(Qθ(si,ai) - yi)2 or Jq(Θ) = NMPZm=ι(Qθ(f(si,Vi,m),ai)-yi)2
θ J θ 一 λθ Vθ Jq(O)	. Update the critic
θ0 J (1 - τ)θ0 + τθ	. Update the critic target
end procedure
counts ranging from 220k to 2.4M. None of these train satisfactorily, with performance decreasing
for the larger capacity models. Figure 1b shows SAC with the application of our random shifts
transformation of the input images (i.e. just Section 4.2, not Q augmentation also). The results
for all encoder architectures improve dramatically, suggesting that our method is general and can
assist many different encoder architectures. To the best of our knowledge, this is the first successful
demonstration of applying image augmentation on the standard benchmarks for continuous control.
Furthermore, Figure 2 shows the full DrQ, with both image shifts and Q augmentation (Section 4.1),
as well as ablated versions. Q augmentation provides additional consistent gain over image shift
augmentation alone (full results are in Appendix F).
5.2 DeepMind Control Suite Experiments
In this section we evaluate our algorithm (DrQ) on the two commonly used benchmarks based
on the DeepMind control suite (Tassa et al., 2018), namely the PlaNet (Hafner et al., 2018) and
Dreamer (Hafner et al., 2019) setups. Throughout these experiments all hyper-parameters of the
algorithm are kept fixed: the actor and critic neural networks are trained using the Adam opti-
mizer (Kingma & Ba, 2014) with default parameters and a mini-batch size of 512 1. For SAC, the
soft target update rate τ is 0.01, initial temperature is 0.1, and target network and the actor updates
are made every 2 critic updates (as in Yarats et al. (2019)). We use the image encoder architecture
from SAC-AE (Yarats et al., 2019) and follow their training procedure. The full set of parameters
can be found in Appendix B. Following Henderson et al. (2018), the models are trained using 10
different seeds; for every seed the mean episode returns are computed every 10000 environment steps,
averaging over 10 episodes. All figures plot the mean performance over the 10 seeds, together with ±
1 standard deviation shading. We compare our DrQ approach to leading model-free and model-based
1Note that DrQ does not utilize additional information beyond transitions sampled from the replay buffer (i.e.
does not use more observations per mini-batch), thus the mini-batch size is the same as for unmodified SAC.
5
Published as a conference paper at ICLR 2021
EnsHφpo-dw
Cartpole Swingup
Encoder Arch
—SAC + )mpa∣a Enc (0.22M)
----SAC + DQN Enc (0.24M)
SAC + Dreamer Enc (0.80M1
—SAC 4 SAC'AE Enc (1.91M1
----SAC + D4PG Enc (2.44M1
UJns°=φpo-dw
Environment Steps (×iθβ)
FmgerSpin
BOO
600
400
200
0
0.0	0.2	0.4	0.6	0.8
Environment Steps (×1O6)
(a)	Unmodified SAC.
Encoder Arch
SAC 4 Impala Enc (0.22M)
SAC + IXJN Enc (0.24M)
SAC + DreamerEnc (0.8(M
SAC + SAOAE Enc (1.91M)
SAC + D4PG Enc (2.44M1
UJns°=φpo-dw
1000 -
WalkerWaIk
UMOaer Artn
----SAC + Impala Enc (0∙22M}
—SAC + DQN Enc (0.24M)
---- SAC + Dreamer Enc (0.80M1
---- SAC + SAGAE Enc (1.91M)
-1SAC + D4PG Enc (2.44MJ
0.0	0.2	0.4	0.6	0.B	1.0
Environment Steps (×1O6)

EnsHφpo-dw
Cartpole Swingup
0.2	0.4	0.6	0.B	1.0
Environment Steps (×iθβ)
UJnsHφpo-dw
FingerSpin
0.0	0.2	0.4	0.6	0.B	1.0
Environment Steps (×1O6)
UJnsHφpo-dw
WalkerWaIk
Encoder Arch
----SAC + Impala Enc (0∙22M}
----SAC + DQN Enc (0.24M)
SAC + Dreamer Enc (0.80M)
----SAC + SAf>AE Enc (1∙91M}
----SAC + D4PG Enc (2.44 M)
0.0	0.2	0.4	0.6	0.B	1.0
Environment Steps (×1O6)
(b)	SAC with random shifts augmentation.
Figure 1: The performance of SAC trained from pixels on the DeepMind control suite using image
encoder networks of different capacity (network architectures taken from recent RL algorithms, with
parameter count indicated). (a): unmodified SAC. Task performance can be seen to get worse as
the capacity of the encoder increases. For Walker Walk (right), all architectures provide mediocre
performance, demonstrating the inability of SAC to train directly from pixels on harder problems.
(b): SAC combined with image augmentation in the form of random shifts. The task performance is
now similar for all architectures, regardless of their capacity, which suggests the generality of our
method. There is also a clear performance improvement relative to (a), particularly for the more
challenging Walker Walk task.
Cheetah Run
BOO
700
U 600
S 500
Φ 400
8 300
2200
100
0
0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00
Environment Steps (×iθβ)
1200
1000
BOO
600
400
200
0
Reacher Easy
FιΛ⅝ggj⅞⅞⅛gia
S ∙∙∙∙..
0.00 0.25 0.50 0.75 X.OO 1.25 1.50 1.75 2.00
No Augmentation
[K=l,M=l]
DrQ [ir=2lλf=l]
—DrQ [ir=Slλf=3]
u∙lnsHφpo-dw
Environment Steps (×iθβ)
Environment Steps (×iθβ)

Figure 2: Different combinations of our three regularization techniques on tasks from (Tassa et al.,
2018) using SAC. Black: standard SAC. Blue: DrQ [K=1,M=1], SAC augmented with random shifts.
Red: DrQ [K=2,M=1], random shifts + Target Q augmentations. Purple: DrQ [K=2,M=2], random
shifts + Target Q + Q augmentations. All three regularization methods correspond to Algorithm 1
with different K,M showing clear gains when both Target Q and Q augmentations are used.
approaches: PlaNet (Hafner et al., 2018), SAC-AE (Yarats et al., 2019), SLAC (Lee et al., 2019),
CURL (Srinivas et al., 2020) and Dreamer (Hafner et al., 2019). The comparisons use the results
provided by the authors of the corresponding papers.
PlaNet Benchmark (Hafner et al., 2018) consists of six challenging control tasks from (Tassa et al.,
2018) with different traits. The benchmark specifies a different action-repeat hyper-parameter for
each of the six tasks2. Following common practice (Hafner et al., 2018; Lee et al., 2019; Yarats et al.,
2This means the number of training observations is a fraction of the environment steps (e.g. an episode of
1000 steps with action-repeat 4 results in 250 training observations).
6
Published as a conference paper at ICLR 2021
Ball In Cup Catch
---CURL
---SLAC
Agent
---SAC State
—PIaNet
----SACnAE
-DrQ (Ours)
0.0	0.1	0.2	0.3	04	0.5
Environment Steps (×iθβ)
FingerSpin
u∙lns°=φpo-dw
Cartpole Swingup
0.1	0.2	0.3	0.4	0.5
Environment Steps (×iθβ)
Reacher Easy
u∙lnsHφpo-dw
Cheetah Run
0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00
Environment Steps (×iθβ)
Agent
----SAC State
—PlaNet
---CURL
—SAf>AE
SLAC
DrQ (Ours)
0.0	0.1	0.2	0.3	0.4	0.5
∈≡sαφpo-dw
---PlaNet
---CURL
---SAC-AE
DrQ (Ours)
0.1	0.2	0.30.4	0.5
Environment Steps (×iθβ)
Environment Steps (×iθβ)
WaIkerWaIk
u∙lnsHφpo-dw

X
Figure 3: The PlaNet benchmark. Our algorithm (DrQ [K=2,M=2]) outperforms the other methods
and demonstrates the state-of-the-art performance. Furthermore, on several tasks DrQ is able to
match the upper-bound performance of SAC trained directly on internal state, rather than images.
Finally, our algorithm not only shows improved sample-efficiency relative to other approaches, but is
also faster in terms of wall clock time.
2019; Mnih et al., 2013), we report the performance using true environment steps, thus are invariant
to the action-repeat hyper-parameter. Aside from action-repeat, all other hyper-parameters of our
algorithm are fixed across the six tasks, using the values previously detailed.
Figure 3 compares DrQ [K=2,M=2] to PlaNet (Hafner et al., 2018), SAC-AE (Yarats et al., 2019),
CURL (Srinivas et al., 2020), SLAC (Lee et al., 2019), and an upper bound performance provided by
SAC (Haarnoja et al., 2018) that directly learns from internal states. We use the version of SLAC that
performs one gradient update per an environment step to ensure a fair comparison to other approaches.
DrQ achieves state-of-the-art performance on this benchmark on all the tasks, despite being much
simpler than other methods. Furthermore, since DrQ does not learn a model (Hafner et al., 2018; Lee
et al., 2019) or any auxiliary tasks (Srinivas et al., 2020), the wall clock time also compares favorably
to the other methods.
In Table 1 we also compare performance given at a fixed number of environment interactions (e.g.
100k and 500k). Furthermore, in Appendix G we demonstrate that DrQ is robust to significant
changes in hyper-parameter settings.
Dreamer Benchmark is a more extensive testbed that was introduced in Dreamer (Hafner et al.,
2019), featuring a diverse set of tasks from the DeepMind control suite. Tasks involving sparse reward
were excluded (e.g. Acrobot and Quadruped) since they require modification of SAC to incorporate
multi-step returns (Barth-Maron et al., 2018), which is beyond the scope of this work. We evaluate
on the remaining 15 tasks, fixing the action-repeat hyper-parameter to 2 as in Hafner et al. (2019).
We compare DrQ [K=2,M=2] to Dreamer (Hafner et al., 2019) and the upper-bound performance of
SAC (Haarnoja et al., 2018) from states3. Again, we keep all the hyper-parameters of our algorithm
fixed across all the tasks. In Figure 4, DrQ demonstrates the state-of-the-art results by collectively
outperforming Dreamer (Hafner et al., 2019), although Dreamer is superior on 3 of the 15 tasks
(Walker Run, Cartpole Swingup Sparse and Pendulum Swingup). On many tasks DrQ approaches
the upper-bound performance of SAC (Haarnoja et al., 2018) trained directly on states.
3No other publicly reported results are available for the other methods due to the recency of the
Dreamer (Hafner et al., 2019) benchmark.
7
Published as a conference paper at ICLR 2021
Table 1: The PlaNet benchmark at 100k and 500k environment stePs. Our method (DrQ [K=2,M=2])
outPerforms other aPProaches in both the data-efficient (100k) and asymPtotic Performance (500k)
regimes. Random shifts only version (e.g. DrQ [K=1,M=1]) has a comPetitive Performance but
is consistently inferior to DrQ [K=2,M=2], Particularly for 100k stePs. We emPhasize, that both
versions of DrQ use exactly the same number of interactions with both the environment and rePlay
buffer. Note that DrQ [K=1,M=1] is almost identical to RAD (Laskin et al., 2020), modulo some
hyPer-Parameter differences.
500k SteP scores	DrQ [K=2,M=2]	DrQ [K=1,M=1]	CURL	PlaNet	SAC-AE	SLAC	SAC State
Finger Spin	938±103	913±151	874±151	718±40	914±107	771±203	927±43
Cartpole Swingup	868±10	845±39	861±30	787±46	730±152	-	870±7
Reacher EaSy	942±71	857±120	904±94	588±471	601±135	-	975±5
Cheetah Run	660±96	460±59	500±91	568±21	544±50	629±74	772±60
WalkerWalk	921 ±45	897±47	906±56	478±164	858±82	865±97	964±8
Ball In Cup Catch	963±9	961±12	958±13	939±43	810±121	959±4	979±6
100kstep scores							
Finger Spin	901±104	744±144	779±108	560±77	747±130	680±130	672±76
Cartpole Swingup	759±92	537±119	592±170	563±73	276±38	-	812±45
Reacher Easy	601±213	451±210	517±113	82±174	225±164	-	919±123
Cheetah Run	344±67	250±58	307±48	252±173	240±38	391±47	228±95
WalkerWalk	612±164	501±68	344±132	221±43	395±58	428±74	604±317
Ball In Cup Catch	913±53	667±146	772±241	710±217	338±196	607±173	957±26
Cartpole Balance Sparse
Wm名"MeldW
Wm名"Meld3
Cartpole Balance
a。 aι az as oλ a*
Environment St9∞ (×10*)
Wm名"Meld3
o-7
OO
Cartpole Swlngup
a。 az oλ M a* i.«
ErwIenMent Steps (xio∙)
a« 0.2 a« a« a* ι.o
Environment St9∞ (×10*)
::
too -
m
f BSKSlaU
*βe"
—SACWe
——ɪreomer
—ι>o(σwτ)
Envtn>nment St9∞ (×1O∙)
FIngerSpIn
Hopper Hop
WO
WO
m
TW
。
HopperStand
f BSKSlaU
f BSKSlaU
0-00 0.25 0.50 0-75 LOO 12* 1.S> I.W 2.00
Environment St9∞ (×10*)
SJC s⅛⅛
ɑww
IXl(OWl)
«o«
—XB0⅛
——ɑww
—ι>q (ŋvi)
f BSKSlaU
WaIkerStand
Q8 Q2S Qg AIS 1.8 1.2S 1.S0 1.7S 2.8
ErwIenMent Steps (xio∙)
f BSKSlaU
TOO
Pendulum SWlngUP
α∞ CNS αso ατs too us i.w IK 2.∞
Environment Steps (×ιo*)
W αso αιs i.8 us ι∙so ι∙τs 2.8
ErwlenMent Steps (xio∙)
Reacher Easy
"βe∙<
SACSWe
leaner
Reacher Hard
T8-，	-
Q8 ɑ:s ɑw ατs lw us ι,so
Environment St9∞ (xlθ∙)
B,
ɑww
IXl(OWl)
ι∙ιs 2-<x>
S*CSB⅛
α∞ 0.25 0.5« 0.7S 1.00 1.25 1.39 L75 Z3
Envtn>nment St9∞ (×1O∙)
a<x> as aso aτs ι∙w i.:s ι∙so its za
Envtn>nment St9∞ {xlθ1)
■oe™
SKSWΛ
⅛eomer
<xιt0*ι)
■ee"
SACSwe
1(XX>
Walker Wallc
(Og
s*cs⅛⅛
9.9	0.2 a« m a* ι.o 9.9	0.2	04 a« a* ι.o
Envlionment StβM (×ιo*)	Environment Sikm (×io*)




Figure 4: The Dreamer benchmark. Our method (DrQ [K=2,M=2]) again demonstrates superior
performance over Dreamer on 12 out 15 selected tasks. In many cases it also reaches the upper-bound
performance of SAC that learns directly from states.
5.3 Atari 100k Experiments
We evaluate DrQ [K=1,M=1] on the Atari 100k benchmark (Kaiser et al., 2019) - a SamPle-
constrained evaluation for discrete control algorithms. The underlying RL approach to which DrQ is
aPPlied is a DQN, combined with double Q-learning (van Hasselt et al., 2015), n-steP returns (Mnih
et al., 2016), and dueling critic architecture (Wang et al., 2015). As Per common Practice (Kaiser
et al., 2019; van Hasselt et al., 2019a), we evaluate our agent for 125k environment stePs at the end
of training and average its Performance over 5 random seeds. Figure 5 shows the median human-
normalized ePisode returns Performance (as in Mnih et al. (2013)) of the underlying model, which we
refer to as Efficient DQN, in Pink. When DrQ is added there is a significant increase in Performance
(cyan), surPassing OTRainbow (Kielak, 2020) and Data Efficient Rainbow (van Hasselt et al., 2019a).
DrQ is also suPerior to CURL (Srinivas et al., 2020) that uses an auxiliary loss built on toP of a
hybrid between OTRainbow and Efficient rainbow. DrQ combined with Efficient DQN thus achieves
state-of-the-art Performance, desPite being significantly simPler than the other aPProaches. The
exPerimental setuP and full results are detailed in APPendix C and APPendix D resPectively.
8
Published as a conference paper at ICLR 2021
SEm ①」P ①--roEJ OU uroEnu uro-p ① W
0.00
0.25
0.20
0.15
0.10
0.05
Rainbow
SimPLe OTRainbow Eff. Rainbow OT∕Eff. Rainbow Eff. DQN Eff. DQN
+CURL	+DrQ (Ours)
Figure 5: The Atari 100k benchmark. Compared to a set of leading baselines, our method (DrQ
[K=1,M=1], combined with Efficient DQN) achieves the state-of-the-art performance, despite being
considerably simpler. Note the large improvement that results from adding DrQ to Efficient DQN
(pink vs cyan). By contrast, the gains from CURL, that utilizes tricks from both Data Efficient
Rainbow and OTRainbow, are more modest over the underlying RL methods.
6	Conclusion
We have introduced a regularization technique, based on image shifts and Q-function augmentation,
that significantly improves the performance of model-free RL algorithms trained directly from images.
In contrast to the concurrent work of Laskin et al. (2020), which is a special case of DrQ, our method
exploits the MDP structure of the problem, demonstrating gains over image augmentations alone.
Our method is easy to implement and adds a negligible computational burden. We compared our
method to state-of-the-art approaches on the DeepMind control suite, outperforming them on the
majority of tasks and closing the gap with state-based training. On the Atari 100k benchmark DrQ
outperforms other SOTA methods in the median metric. To the best of our knowledge, this is the
first convincing demonstration of the utility of data augmentation on these standard benchmarks.
Furthermore, we demonstrate the method to be robust to the choice of hyper-parameters.
9
Published as a conference paper at ICLR 2021
References
Abbas Abdolmaleki, Jost Tobias Springenberg, Yuval Tassa, Remi Munos, Nicolas Heess, and Martin
Riedmiller. Maximum a posteriori policy optimisation. arXiv preprint arXiv:1806.06920, 2018.
Marcin Andrychowicz, Filip Wolski, Alex Ray, Jonas Schneider, Rachel Fong, Peter Welinder, Bob
McGrew, Josh Tobin, OpenAI Pieter Abbeel, and Wojciech Zaremba. Hindsight experience replay.
In Advances in neural information processing Systems, pp. 5048-5058, 2017.
Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E. Hinton. Layer normalization. arXiv e-prints,
2016.
Gabriel Barth-Maron, Matthew W. Hoffman, David Budden, Will Dabney, Dan Horgan, Dhruva
TB, Alistair Muldal, Nicolas Heess, and Timothy Lillicrap. Distributional policy gradients. In
International Conference on Learning Representations, 2018.
S. Becker and G. E. Hinton. Self-organizing neural network that discovers surfaces in random-dot
stereograms. Nature, 1992.
Richard Bellman. A markovian decision process. Indiana Univ. Math. J., 1957.
Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A simple framework for
contrastive learning of visual representations. arXiv preprint arXiv:2002.05709, 2020.
Dan Ciregan, Ueli Meier, and Jurgen Schmidhuber. Multi-column deep neural networks for image
classification. In 2012 IEEE conference on computer vision and pattern recognition, pp. 3642-3649,
2012.
Dan C Ciresan, Ueli Meier, Jonathan Masci, Luca M Gambardella, and Jurgen Schmidhuber. High-
performance neural networks for visual object classification. arXiv preprint arXiv:1102.0183,
2011.
Karl Cobbe, Oleg Klimov, Chris Hesse, Taehoon Kim, and John Schulman. Quantifying generalization
in reinforcement learning. arXiv preprint arXiv:1812.02341, 2018.
Ronan Collobert, Jason Weston, Leon Bottou, Michael Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
Natural language processing (almost) from scratch. Journal of machine learning research, 2011.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep
bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.
Terrance DeVries and Graham W Taylor. Improved regularization of convolutional neural networks
with cutout. arXiv preprint arXiv:1708.04552, 2017.
Alexey Dosovitskiy, Philipp Fischer, Jost Tobias Springenberg, Martin Riedmiller, and Thomas
Brox. Discriminative unsupervised feature learning with exemplar convolutional neural networks.
TPAMI, 2016.
Debidatta Dwibedi, Jonathan Tompson, Corey Lynch, and Pierre Sermanet. Learning actionable
representations from visual observations. CoRR, 2018.
Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymir Mnih, Tom Ward, Yotam
Doron, Vlad Firoiu, Tim Harley, Iain Dunning, et al. Impala: Scalable distributed deep-rl with
importance weighted actor-learner architectures. arXiv preprint arXiv:1802.01561, 2018.
Scott Fujimoto, Herke van Hoof, and David Meger. Addressing function approximation error in
actor-critic methods. In Proceedings of the 35th International Conference on Machine Learning,
ICML 2018, Stockholmsmassan, Stockholm, Sweden, July 10-15, 2018, 2018.
Tuomas Haarnoja, Aurick Zhou, Kristian Hartikainen, George Tucker, Sehoon Ha, Jie Tan, Vikash
Kumar, Henry Zhu, Abhishek Gupta, Pieter Abbeel, et al. Soft actor-critic algorithms and
applications. arXiv preprint arXiv:1812.05905, 2018.
10
Published as a conference paper at ICLR 2021
Danijar Hafner, Timothy Lillicrap, Ian Fischer, Ruben Villegas, David Ha, Honglak Lee, and James
Davidson. Learning latent dynamics for planning from pixels. arXiv preprint arXiv:1811.04551,
2018.
Danijar Hafner, Timothy Lillicrap, Jimmy Ba, and Mohammad Norouzi. Dream to control: Learning
behaviors by latent imagination. arXiv preprint arXiv:1912.01603, 2019.
Kaiming He, Haoqi Fan, Yuxin Wu, Saining Xie, and Ross Girshick. Momentum contrast for
unsupervised visual representation learning. arXiv preprint arXiv:1911.05722, 2019.
Peter Henderson, Riashat Islam, Philip Bachman, Joelle Pineau, Doina Precup, and David Meger.
Deep reinforcement learning that matters. Thirty-Second AAAI Conference On Artificial Intelli-
gence (AAAI), 2018.
Geoffrey E Hinton, Nitish Srivastava, Alex Krizhevsky, Ilya Sutskever, and Ruslan R Salakhutdinov.
Improving neural networks by preventing co-adaptation of feature detectors. arXiv preprint
arXiv:1207.0580, 2012.
Max Jaderberg, Volodymyr Mnih, Wojciech Czarnecki, Tom Schaul, Joel Z. Leibo, David Silver, and
Koray Kavukcuoglu. Reinforcement learning with unsupervised auxiliary tasks. International
Conference on Learning Representations, 2017.
Leslie Pack Kaelbling, Michael L Littman, and Anthony R Cassandra. Planning and acting in partially
observable stochastic domains. Artificial intelligence, 1998.
Lukasz Kaiser, Mohammad Babaeizadeh, Piotr Milos, Blazej Osinski, Roy H. Campbell, Konrad
Czechowski, Dumitru Erhan, Chelsea Finn, Piotr Kozakowski, Sergey Levine, Ryan Sepassi,
George Tucker, and Henryk Michalewski. Model-based reinforcement learning for atari. arXiv
preprint arXiv:1903.00374, 2019.
Dmitry Kalashnikov, Alex Irpan, Peter Pastor, Julian Ibarz, Alexander Herzog, Eric Jang, Deirdre
Quillen, Ethan Holly, Mrinal Kalakrishnan, Vincent Vanhoucke, et al. Qt-opt: Scalable deep
reinforcement learning for vision-based robotic manipulation. arXiv preprint arXiv:1806.10293,
2018.
Kacper Piotr Kielak. Do recent advancements in model-based deep reinforcement learning really
improve data efficiency? openreview, 2020. URL https://openreview.net/forum?
id=Bke9u1HFwB.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Durk P Kingma, Shakir Mohamed, Danilo Jimenez Rezende, and Max Welling. Semi-supervised
learning with deep generative models. In Advances in neural information processing systems, pp.
3581-3589, 2014.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolu-
tional neural networks. In Advances in neural information processing systems, 2012.
Michael Laskin, Kimin Lee, Adam Stooke, Lerrel Pinto, Pieter Abbeel, and Aravind Srinivas.
Reinforcement learning with augmented data, 2020.
Yann LeCun, Bernhard Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne
Hubbard, and Lawrence D Jackel. Backpropagation applied to handwritten zip code recognition.
Neural computation, 1989.
A. X. Lee, A. Nagabandi, P. Abbeel, and S. Levine. Stochastic latent actor-critic: Deep reinforcement
learning with a latent variable model. arXiv e-prints, 2019.
Sergey Levine, Peter Pastor, Alex Krizhevsky, Julian Ibarz, and Deirdre Quillen. Learning hand-
eye coordination for robotic grasping with deep learning and large-scale data collection. The
International Journal of Robotics Research, 37(4-5):421-436, 2018.
11
Published as a conference paper at ICLR 2021
Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. CoRR,
2015.
Ishan Misra and Laurens van der Maaten. Self-supervised learning of pretext-invariant representations.
arXiv:1912.01991, 2019.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan
Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv e-prints,
2013.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy P. Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. CoRR, 2016.
Masashi Okada and Tadahiro Taniguchi. Dreaming: Model-based reinforcement learning by latent
imagination without reconstruction. arXiv preprint arXiv:2007.14535, 2020.
Roberta Raileanu, Max Goldstein, Denis Yarats, Ilya Kostrikov, and Rob Fergus. Automatic data
augmentation for generalization in deep reinforcement learning. 2020.
Edgar Riba, Dmytro Mishkin, Daniel Ponsa, Ethan Rublee, and Gary Bradski. Kornia: an open
source differentiable computer vision library for pytorch. In The IEEE Winter Conference on
Applications ofComputer Vision, pp. 3674-3683, 2020.
Andrew M. Saxe, James L. McClelland, and Surya Ganguli. Exact solutions to the nonlinear dynamics
of learning in deep linear neural networks. arXiv e-prints, 2013.
Pierre Sermanet, Corey Lynch, Yevgen Chebotar, Jasmine Hsu, Eric Jang, Stefan Schaal, Sergey
Levine, and Google Brain. Time-contrastive networks: Self-supervised learning from video. In
2018 IEEE International Conference on Robotics and Automation (ICRA), pp. 1134-1141. IEEE,
2018.
Patrice Y Simard, David Steinkraus, John C Platt, et al. Best practices for convolutional neural
networks applied to visual document analysis. In Icdar, 2003.
Aravind Srinivas, Michael Laskin, and Pieter Abbeel. Curl: Contrastive unsupervised representations
for reinforcement learning. arXiv preprint arXiv:2004.04136, 2020.
Yuval Tassa, Yotam Doron, Alistair Muldal, Tom Erez, Yazhe Li, Diego de Las Casas, David Budden,
Abbas Abdolmaleki, Josh Merel, Andrew Lefrancq, et al. Deepmind control suite. arXiv preprint
arXiv:1801.00690, 2018.
Hado van Hasselt, Arthur Guez, and David Silver. Deep reinforcement learning with double q-
learning. arXiv e-prints, 2015.
Hado van Hasselt, Matteo Hessel, and John Aslanides. When to use parametric models in reinforce-
ment learning? arXiv preprint arXiv:1906.05243, 2019a.
Hado P van Hasselt, Matteo Hessel, and John Aslanides. When to use parametric models in
reinforcement learning? In Advances in Neural Information Processing Systems, 2019b.
Ziyu Wang, Tom Schaul, Matteo Hessel, Hado Van Hasselt, Marc Lanctot, and Nando De Freitas.
Dueling network architectures for deep reinforcement learning. arXiv preprint arXiv:1511.06581,
2015.
Denis Yarats and Ilya Kostrikov. Soft actor-critic (sac) implementation in pytorch. https://
github.com/denisyarats/pytorch_sac, 2020.
Denis Yarats, Amy Zhang, Ilya Kostrikov, Brandon Amos, Joelle Pineau, and Rob Fergus. Im-
proving sample efficiency in model-free reinforcement learning from images. arXiv preprint
arXiv:1910.01741, 2019.
Brian D. Ziebart, Andrew Maas, J. Andrew Bagnell, and Anind K. Dey. Maximum entropy inverse
reinforcement learning. In Proceedings of the 23rd National Conference on Artificial Intelligence -
Volume 3, 2008.
12
Published as a conference paper at ICLR 2021
Appendix
A	Extended Background
Reinforcement Learning from Images We formulate image-based control as an infinite-horizon
partially observable Markov decision process (POMDP) (Bellman, 1957; Kaelbling et al., 1998). An
POMDP can be described as the tuple (O, A,p, r, γ), where O is the high-dimensional observation
space (image pixels), A is the action space, the transition dynamics P = Pr(ot∖o≤t, at) capture the
probability distribution over the next observation o0t given the history of previous observations o≤t
and current action at, r : O × A → R is the reward function that maps the current observation and
action to a reward rt = r(o≤t, at), and γ ∈ [0, 1) is a discount factor. Per common practice (Mnih
et al., 2013), throughout the paper the POMDP is converted into an MDP (Bellman, 1957) by stacking
several consecutive image observations into a state st = {ot, ot-1, ot-2, . . .}. For simplicity we
redefine the transition dynamics p = P r(s0t∖st, at) and the reward function rt = r(st, at). We then
aim to find a policy π(at∖st) that maximizes the cumulative discounted return En[P∞= 1 γtrt∖at 〜
π(∙∖st),st 〜P(∙∖st,at),s1 〜P(∙)].
Soft Actor-Critic The Soft Actor-Critic (SAC) (Haarnoja et al., 2018) learns a state-action value
function Qθ , a stochastic policy πθ and a temperature α to find an optimal policy for an MDP
(S, A, p, r, γ) by optimizing a γ-discounted maximum-entropy objective (Ziebart et al., 2008). θ is
used generically to denote the parameters updated through training in each part of the model. The actor
policy ∏θ(at∖st) is a parametric tanh-GaUSSian that given St samples at = tanh(μθ(St) + σθ(St)E),
where E 〜N(0,1) and μθ and ◎§ are parametric mean and standard deviation.
The policy evaluation step learns the critic Qθ(St, at) network by optimizing a single-step of the soft
Bellman residual
JQ(D) = E(st,at ,st)〜D [(Qθ (St, at) - yt)2]
at^π(∙lst)
yt = r(St, at) + γ[Qθ0(S0t, a0t) - αlogπθ(a0t∖S0t)],
where D is a replay buffer of transitions, θ0 is an exponential moving average of the weights as done
in (Lillicrap et al., 2015). SAC uses clipped double-Q learning (van Hasselt et al., 2015; Fujimoto
et al., 2018), which we omit from our notation for simplicity but employ in practice.
The policy improvement step then fits the actor policy πθ(at∖St) network by optimizing the objective
Jn(D)= E"D[Dkl(∏θ(∙∖st)∖∖ exp{1 Qθ(st, ∙)})]∙
tα
Finally, the temperature α is learned with the loss
Ja(D) = E St 〜D	[-a log ∏θ (at∖st) — αH],
at 〜∏θ(∙∣st)
where H ∈ R is the target entropy hyper-parameter that the policy tries to match, which in practice is
usually set to HH = -∖A∖.
Deep Q-learning DQN (Mnih et al., 2013) also learns a convolutional neural net to approximate
Q-function over states and actions. The main difference is that DQN operates on discrete actions
spaces, thus the policy can be directly inferred from Q-values. The parameters of DQN are updated
by optimizing the squared residual error
JQ (D)= E(st,at,st)〜D [(Qθ(St,at) - yt)2]
yt = r(St, at) + γ max Qθ0 (S0t, a0)∙
a0
In practice, the standard version of DQN is frequently combined with a set of tricks that improve
performance and training stability, wildly known as Rainbow (van Hasselt et al., 2015).
13
Published as a conference paper at ICLR 2021
B	The DeepMind Control Suite Experiments Setup
Our PyTorch SAC (Haarnoja et al., 2018) implementation is based off of Yarats & Kostrikov (2020).
B.1	Actor and Critic Networks
We employ clipped double Q-learning (van Hasselt et al., 2015; Fujimoto et al., 2018) for the critic,
where each Q-function is parametrized as a 3-layer MLP with ReLU activations after each layer
except of the last. The actor is also a 3-layer MLP with ReLUs that outputs mean and covariance for
the diagonal Gaussian that represents the policy. The hidden dimension is set to 1024 for both the
critic and actor.
B.2	Encoder Network
We employ an encoder architecture from Yarats et al. (2019). This encoder consists of four convo-
lutional layers with 3 × 3 kernels and 32 channels. The ReLU activation is applied after each conv
layer. We use stride to 1 everywhere, except of the first conv layer, which has stride 2. The output
of the convnet is feed into a single fully-connected layer normalized by LayerNorm (Ba et al.,
2016). Finally, we apply tanh nonlinearity to the 50 dimensional output of the fully-connected
layer. We initialize the weight matrix of fully-connected and convolutional layers with the orthogonal
initialization (Saxe et al., 2013) and set the bias to be zero.
The actor and critic networks both have separate encoders, although we share the weights of the conv
layers between them. Furthermore, only the critic optimizer is allowed to update these weights (e.g.
we stop the gradients from the actor before they propagate to the shared conv layers).
B.3	Training and Evaluation Setup
Our agent first collects 1000 seed observations using a random policy. The further training obser-
vations are collected by sampling actions from the current policy. We perform one training update
every time we receive a new observation. In cases where we use action repeat, the number of training
observations is only a fraction of the environment steps (e.g. a 1000 steps episode at action repeat 4
will only results into 250 training observations). We evaluate our agent every 10000 true environment
steps by computing the average episode return over 10 evaluation episodes. During evaluation we
take the mean policy action instead of sampling.
B.4	PlaNet and Dreamer Benchmarks
We consider two evaluation setups that were introduced in PlaNet (Hafner et al., 2018) and
Dreamer (Hafner et al., 2019), both using tasks from the DeepMind control suite (Tassa et al., 2018).
The PlaNet benchmark consists of six tasks of various traits. Importantly, the benchmark proposed to
use a different action repeat hyper-parameter for each task, which we summarize in Table 2.
The Dreamer benchmark considers an extended set of tasks, which makes it more difficult that the
PlaNet setup. Additionally, this benchmark requires to use the same set hyper-parameters for each
task, including action repeat (set to 2), which further increases the difficulty.
Table 2: The action repeat hyper-parameter used for each task in the PlaNet benchmark.
Task name	Action repeat
Cartpole SWingUP	8
Reacher Easy	4
Cheetah Run	4
Finger Spin	2
Ball In Cup Catch	4
Walker wM	2
14
Published as a conference paper at ICLR 2021
B.5	Pixels Preprocessing
We construct an observational input as an 3-stack of consecutive frames (Mnih et al., 2013), where
each frame is a RGB rendering of size 84 × 84 from the 0th camera. We then divide each pixel by
255 to scale it down to [0, 1] range.
B.6	Other Hyper Parameters
Due to computational constraints for all the continuous control ablation experiments in the main
paper and appendix we use a minibatch size of 128, while for the main results we use minibatch of
size 512. In Table 3 we provide a comprehensive overview of all the other hyper-parameters.
Table 3: An overview of used hyper-parameters in the DeepMind control suite experiments.
Parameter	Setting
Replay buffer capacity	100000
Seed steps	1000
Ablations minibatch size	128
Main results minibatch size	512
Discount Y	0.99
Optimizer	Adam
Learning rate	10-3
Critic target update frequency	2
Critic Q-function soft-update rate T	0.01
Actor update frequency	2
Actor log stddev bounds	[—10, 2]
Init temperature	0.1
15
Published as a conference paper at ICLR 2021
C The Atari 100k Experiments Setup
For ease of reproducibility in Table 4 we report the hyper-parameter settings used in the Atari 100k
experiments. We largely reuse the hyper-parameters from OTRainbow (Kielak, 2020), but adapt them
for DQN (Mnih et al., 2013). Per common practise, we average performance of our agent over 5
random seeds. The evaluation is done for 125k environment steps at the end of training for 100k
environment steps.
Table 4: A complete overview of hyper parameters used in the Atari 100k experiments.
Parameter	Setting
Data augmentation Grey-scaling Observation down-sampling Frames stacked Action repetitions Reward clipping Terminal on loss of life Max frames per episode Update Dueling Target network: update period Discount factor Minibatch size Optimizer Optimizer: learning rate Optimizer: βι Optimizer: β2 Optimizer: E Max gradient norm Training steps Evaluation steps Min replay size for sampling Memory size Replay period every Multi-step return length Q network: channels Q network: filter size Q network: stride Q network: hidden units Non-linearity Exploration e-decay	Random shifts and Intensity True 84 X 84 4 4 [-1,1] True 108k Double Q True 1 0.99 32 Adam 0.0001 0.9 0.999 0.00015 10 100k 125k 1600 Unbounded 1 step 10 32,64,64 8 × 8, 4 × 4, 3 × 3 4, 2,1 512 ReLU e-greedy 	5000	
16
Published as a conference paper at ICLR 2021
D Full Atari 100k Results
Besides reporting in Figure 5 median human-normalized episode returns over the 26 Atari games
used in (Kaiser et al., 2019), we also provide the mean episode return for each individual game
in Table 5.
Table 5: Mean episode returns on each of 26 Atari games from the setup in Kaiser et al. (2019). The
results are recorded at the end of training and averaged across 5 random seeds (the CURL’s results
are averaged over 3 seeds as reported in Srinivas et al. (2020)). On each game we mark as bold the
highest score. Our method demonstrates better overall performance (as reported in Figure 5).
Game	Rainbow	SimPLe	OTRainbow	Eff. Rainbow	OT/Eff. Rainbow +CURL	Eff. DQN	Eff. DQN +DrQ (Ours)
Alien	-3187-	616.9	8247	739.9	1148.2	558.1	702.5
Amidar	32.5	88.0	82.8	188.6	232.3	63.7	100.2
Assault	231.0	527.2	351.9	431.2	543.7	589.5	490.3
Asterix	243.6	1128.3	628.5	470.8	524.3	341.9	577.9
BankHeist	15.6	34.2	182.1	51.0	193.7	74.0	205.3
BattleZone	2360.0	5184.4	4060.6	10124.6	11208.0	4760.8	6240.0
Boxing	-24.8	9.1	2.5	0.2	4.8	-1.8	5.1
Breakout	1.2	16.4	9.8	1.9	18.2	7.3	14.3
ChopperCommand	120.0	1246.9	1033.3	861.8	1198.0	624.4	870.1
CrazyClimber	2254.5	62583.6	21327.8	16185.3	27805.6	5430.6	20072.2
DemonAttack	163.6	208.1	711.8	508.0	834.0	403.5	1086.0
Freeway	0.0	20.3	25.0	27.9	27.9	3.7	20.0
Frostbite	60.2	254.7	231.6	866.8	924.0	202.9	889.9
Gopher	431.2	771.0	778.0	349.5	801.4	320.8	678.0
Hero	487.0	2656.6	6458.8	6857.0	6235.1	2200.1	4083.7
Jamesbond	47.4	125.3	112.3	301.6	400.1	133.2	330.3
Kangaroo	0.0	323.1	605.4	779.3	345.3	448.6	1282.6
Krull	1468.0	4539.9	3277.9	2851.5	3833.6	2999.0	4163.0
KungFuMaster	0.0	17257.2	5722.2	14346.1	14280.0	2020.9	7649.0
MsPacman	67.0	1480.0	941.9	1204.1	1492.8	872.0	1015.9
Pong	-20.6	12.8	1.3	-19.3	2.1	-19.4	-17.1
PrivateEye	0.0	58.3	100.0	97.8	105.2	351.3	-50.4
Qbert	123.5	1288.8	509.3	1152.9	1225.6	627.5	769.1
RoadRunner	1588.5	5640.6	2696.7	9600.0	6786.7	1491.9	8296.3
Seaquest	131.7	683.3	286.9	354.1	408.0	240.1	299.4
UpNDown	504.6	3350.3	2847.6	2877.4	2735.2	2901.7	3134.8
Median human-normalised episode returns	0.020	0.135	0.208	0.147	0.240	0.094	0.270
E Image Augmentations Ablation
Following (Chen et al., 2020), we evaluate popular image augmentation techniques, namely random
shifts, cutouts, vertical and horizontal flips, random rotations and imagewise intensity jittering. Below,
we provide a comprehensive overview of each augmentation. Furthermore, we examine effectiveness
of these techniques in Figure 6.
Random Shift We bring our attention to random shifts that are commonly used to regularize neural
networks trained on small images (Becker & Hinton, 1992; Simard et al., 2003; LeCun et al., 1989;
Ciresan et al., 2011; Ciregan et al., 2012). In our implementation of this method images of size
84 × 84 are padded each side by 4 pixels (by repeating boundary pixels) and then randomly cropped
back to the original 84 × 84 size.
Cutout Cutouts introduced in DeVries & Taylor (2017) represent a generalization of Dropout (Hin-
ton et al., 2012). Instead of masking individual pixels cutouts mask square regions. Since image
pixels can be highly correlated, this technique is proven to improve training of neural networks.
Horizontal/Vertical Flip This technique simply flips an image either horizontally or vertically
with probability 0.1.
Rotate Here, an image is rotated by r degrees, where r is uniformly sampled from [-5, -5].
17
Published as a conference paper at ICLR 2021
Intensity Each N × C × 84 × 84 image tensor is multiplied by a single scalar s, which is computed
as S = μ + σ ∙ clip(r, -2,2), where r 〜N(0,1). For our experiments We use μ = 1.0 and σ = 0.1.
∈≡sαφpo-dw
Ball In Cup Catch
0.0	0.1	0.2	0.3	0.4	0.5
Environment Steps (×iθβ)
FingerSpin
Cartpole Swingup
Environment Steps (×iθβ)
Cheetah Run
0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00
Environment Steps (×1O6)
UJn*j9Bφpo-dw
Augmentation
—Random Shift
Cutout
Horizontal Flip
Intensity
----None
Rotate
Vertical Flip
UJn*j9Bφpo-dw
Reacher Easy
WaIkerWaIk
Augmentation
—Random Shift
Cutout
Horizontal Flip
----Intensity
None
≈ Rotate
Vertical Flip


0.0	0.1	0.2	0.3	0.4	0.5	0.0	0.1	0.2	0.3	0-4	0.5	0.0	0.2	0.4	0.6 O-B 1.0
Environment Steps (×1O6)	Environment Steps (×1O6)	Environment Steps (×1O6)
Figure 6: Various image augmentations have different effect on the agent’s performance. Overall, we
conclude that using image augmentations helps to fight overfitting. Moreover, we notice that random
shifts proven to be the most effective technique for tasks from the DeepMind control suite.
Implementation Finally, we provide Python-like implementation for the aforementioned augmen-
tations powered by Kornia (Riba et al., 2020).
import torch
import torch.nn as nn
import kornia.augmentation as aug
random_shift = nn.Sequential(nn.ReplicationPad2d(4),aug.RandomCrop((84, 84)))
cutout = aug.RandomErasing(p=0.5)
h_flip = aug.RandomHorizontalFlip(p=0.1)
v_flip = aug.RandomVerticalFlip(p=0.1)
rotate = aug.RandomRotation(degrees=5.0)
intensity = Intensity(scale=0.1)
class Intensity(nn.Module):
def __init__(self, scale):
super().__init__()
self.scale = scale
def forward(self, x):
r = torch.randn((x.size(0), 1, 1, 1), device=x.device)
noise = 1.0 + (self.scale * r.clamp(-2.0, 2.0))
return x noise
18
Published as a conference paper at ICLR 2021
F K and M Hyper-parameters Ablation
We further ablate the K,M hyper-parameters from Algorithm 1 to understand their effect on perfor-
mance. In Figure 7 we observe that increase values of K,M improves the agent’s performance. We
choose to use the [K=2,M=2] parametrization as it strikes a good balance between performance and
computational demands.
∈3sαφpo-dw
Ball In Cup Catch
Cartpole Swingup
Cheetah Run
FingerSpin
——DrQ [K=l,M=l]
---- DrQ [ir=Slλf=3]
---- DrQ [ir=4lλf=4]
---- DrQ [ir=8lλf=8]
0.0	0.1	0.2	0.3	0.4	0.5
Environment Steps (×1O6)
Figure 7: Increasing values of K,M hyper-parameters generally correlates positively with the agent’s
performance, especially on the harder tasks, such as Cheetah Run.
Reacher Easy
0.0	0.1	0.2	0.3	0-4	0.5
Environment Steps (×1O6)
UJn*j9Bφpo-dw
WalkerWalk
0.0	0.2	0.4	0.6 O-B 1.0
Environment Steps (×1O6)
G Robustness Investigation
To demonstrate the robustness of our approach (Henderson et al., 2018), we perform a comprehensive
study on the effect different hyper-parameter choices have on performance. A review of prior work
(Hafner et al., 2018; 2019; Lee et al., 2019; Srinivas et al., 2020) shows consistent values for discount
γ = 0.99 and target update rate τ = 0.01 parameters, but variability on network architectures,
mini-batch sizes, learning rates. Since our method is based on SAC (Haarnoja et al., 2018), we also
check whether the initial value of the temperature is important, as it plays a crucial role in the initial
phase of exploration. We omit search over network architectures since Figure 1b shows our method
to be robust to the exact choice. We thus focus on three hyper-parameters: mini-batch size, learning
rate, and initial temperature.
Due to computational demands, experiments are restricted to a subset of tasks from Tassa et al. (2018):
Walker Walk, Cartpole Swingup, and Finger Spin. These were selected to be diverse, requiring
different behaviors including locomotion and goal reaching. A grid search is performed over mini-
batch sizes {128, 256, 512}, learning rates {0.0001, 0.0005, 0.001, 0.005}, and initial temperatures
{0.005, 0.01, 0.05, 0.1}. We follow the experimental setup from Appendix B, except that only 3 seeds
are used due to the computation limitations, but since variance is low the results are representative.
19
Published as a conference paper at ICLR 2021
Batch s Ize-128
Inlt Temperatu re- 0.005
9.9 αz ««	«« a« l。
Environment Stepe (×1θ∙)
Inlt Temperature-0.01
LanAi。KaK
——UtatLOXn
—UMInK
—u*>αoαι
—U*><UX6
«2 a« «« a« l。
LeWnE W?
LK-IMam
LM-IMKe
iλb0j3Cπ
LH-IM as
Inlt Temperature-0.1
LeQn«10 HalV
—UfcHOXn
—IMΛOS
—L»-aocn
—u⅜-ααs
Envlittnment Steps (×lθ∙)
InItTemperatu re- 0.005
LenmElW
—LK-⅛MO1
--Ut-OJMCe
--IKaiMMl
—LK-IMOS
Inlt Temperature-0.01
L>*"ao0π
u*-αooos
—L»-aocn
—3(LooS
«2 a« «« a« l。
Environment S½ps (×1θ∙)
InItTeniperature-O-OS
a« «2 a« αe a« ɪ-o
Envlittnment Steps (×lθ∙)
Intt Temperature-O-1
V.V We	口。 v∙s ∣-v
Envlittnment Steps (×lθ∙)
αv 0.2	o.« α* «.« ɪ-o
Environment Stepe (×1θ∙)
InItTemperature-O-OOS
0.2	0-4 a。 as ɪ-o
Environment Steps {×10,)
V.V We	口。 v∙s ∣-v
Envlittnment Steps (×lθ∙)
Inlt TemPeratUre=0.01
IoOO
E≡sz s-u3-aw
ao αz a* a。 o-s ɪ-o
EnvInjnment Steps (×10e)
s-u3-au
(λV We	"。 V.S I-V
Environment Stepe {x1fl∙)
Inlt Temperature-0.05
Intt Temperature-O-1
——IMjiOn
—LfcaoaB
—u⅜-ααn
—lΛ∙Λ00S
ao αz a* a。 o-s ɪ-o
EnvInjnment Steps (×10e)
E≡sz ⅞3-au
E≡sz ⅞3-au
E≡sz ⅞3-au
UlmewMId3

(a) Walker Walk.
rd 3d Stf SoO-O
£me&UJ。” W
Batch SIze-128
o.<x»i c<xx>s awι aa»
Learning Rag
Batch size-256
io Sd 10。 Sod
mmκ∙lw
o.<x»i c<xx» αwι aa»
Learning Rag
Batch size-512
ɑoroɪ aooos αooι αoo⅜
Learning Rag
-ɪooo
-SOO
WO
«0
28
O
-IOOO
-SOO
WO
«0
28
O
-IOOO
-SOO
WO
«0
28
O
Inlt Tem peratu re- 0.005
IOW
Inlt TarrICarat“ro—C "C'
as
Environment Steps {xlθ∙)
LCVlaB n
——u⅛OJMtn
——uw>j»«
——IMan
——UtaaaK
as I
Environment Steps {xlθ∙)
Inlt Temperature≡0-005
—IMJgtn
—Ut-OJMtB
—LR-β∙001
—LK-OJMS
UIrWePφβ-s
Lew^∏o∙*⅛
—IMIgtn
—UWlglS
UInIeWMId3
UInIeWMId3
Inlt Temperature-0.01
αo aι «2 as a« as
Envl π>nmβnt Steps {xlθ∙)
Inlt TemPeratUre=0.01
M o-i az as a*
Envl π>nmβnt Stops (×10f)
Envl π>nmβnt Steps {xlθ∙)
teon*x>Haw
—Waxra
—IM-IMUB
---IRaCLOCn
—IMIoaS
Inlt Tem peratu re-0.05
αι ɑz as a« as
Environment Steps {×lθ∙)
Inlt Tem ρerature≡0-05
nit Temperature-0.0]
LeWrtno
LK-OJMn
Λ-0Λ)∣B
LR-o ajι
LK-OMS
InItTemperatu re- 0.1
a« ai «2 as a« as
Environment Steps {xlθ∙)
Intt Tem ρerature≡0-05
woo
SOO
500
•00
28
O
M ai «2 as a« as
Envl π>nmβnt Steps {xlθ∙)
Intt TemPeratUre=0.1
I。 Sd 10。 Sod
Wmmκ"∙ltw
ETS ɑvsɪu
UInmePMIda
(b) Cartpole Swingup.
Batch s Ize-128
g - 874 9S 9S1 SSO
aβm aβow awι aβw
LMmIn9 Ras
Batch size-256
a own a ooos aooι aoo⅜
LMmIn9 RatB
Batch Slze-512
Inlt Temperatu re- 0.005
woo
Td Sa TOG Soa
B-ImebdUlOIBU-
97»	tn
«7*	sso
9*1	SSl
sso	m
o-ɪwoi
∞e 9∏
979	«7*
tn «72
«7S	9*i
a<xxu awι ag«s
Learning Rag
ai ɑz as a« as
Environment S½ps (×1θ∙)
InItTemperatu re- 0.005
—LK-IMOS
as
Inlt Temperatu re- 0.005
««
Environment Stepe (x1θ∙)
LeWnkIaW
—Ut-OJMCn
—iλb0jm<s
—lκ><MMl
—Ut-CUias
a« ai az as a， as
Environment Steps {xW∙)
LeWTlE ⅛⅛
Ui-CUMm
ICOO
e»
eoo
«x)
200
O
Inlt Temperature-0.01
InItTen
«« αι «2 as a« as
Envlittnment Steps (×lθ∙)
Inlt Temperature-0.01
«00
β∞
400
28
O
InItTemperatureaO.OS
Inlt Temperature-0.05
o-o o-ι az as a4 as
Environment Stepe (×1θ∙)
I nit Tem peratu re-0.05
LamkiOW
lΛ-0Λ001
- uτ-aj3as
ικ><Mi<n
LK-IMlK
ai
«2
as
a«
Environment Steps {x1θ∙)
as
In It Tem perature-0.1
'loan
'aims
•am
——
Envlittnment Steps (×lθ∙)
Inlt Tem peratu re-0.1
«« as
Envlittnment Steps (×lθ∙)
Inlt Tem peratu re-0.1
u*-ao0π
UtaIMns
IMan
—g(LooS
U*-iL∣M5
«2
as
a«
as
Envlittnment Steps (×lθ∙)
■SS?ll
c^≡sz ⅞s-au
c^≡sz ⅞s-au
c^≡sz ⅞s-au
E≡sz ɑsɑu
UlmewMId3
(c) Finger Spin.
Figure 8: A robustness study of our algorithm (DrQ) to changes in mini-batch size, learning rate,
and initial temperature hyper-parameters on three different tasks from (Tassa et al., 2018). Each row
corresponds to a different mini-batch size. The low variance of the curves and heat-maps shows DrQ
to be generally robust to exact hyper-parameter settings.
20
Published as a conference paper at ICLR 2021
Figure 8 shows performance curves for each configuration as well as a heat map over the mean
performance of the final evaluation episodes, similar to Mnih et al. (2016). Our method demonstrates
good stability and is largely invariant to the studied hyper-parameters. We emphasize that for
simplicity the experiments in Section 5 use the default learning rate of Adam (Kingma & Ba, 2014)
(0.001), even though it is not always optimal.
H Improved Data-Efficient Reinforcement Learning from Pixels
Our method allows to generate many various transformations from a training observation due to
the data augmentation strategy. Thus, we further investigate whether performing more training
updates per an environment step can lead to even better sample-efficiency. Following van Hasselt
et al. (2019b) we compare a single update with a mini-batch of 512 transitions with 4 updates with 4
different mini-batches of size 128 samples each. Performing more updates per an environment step
leads to even worse over-fitting on some tasks without data augmentation (see Figure 9a), while our
method DrQ, that takes advantage of data augmentation, demonstrates improved sample-efficiency
(see Figure 9b).
∈≡sa 8po-dw
0	20	40	60 BO 100
Environment Steps (×1O3)
寸———-----------------------
B00600400200
0ln⅞H 8poJ2dw
Cartpole Swingup
Agent
!---- SAC	(Batch-128,N-IJ
----SAC (Ba⅛h-128.N-4J
----SAC (Batch-512,N-l)
20	40	60 BO 100
Environment Steps (×1O3)
0	20	40	60 BO 100
Environment Steps (×1O3)
∈≡sαφpo-dw
(a) Unmodified SAC.
一 一——一——
yuu600400
0lnsH 8po∙2dw
Cheetah Run
500
400
c
S 300
U.
ω
8 200
d
UJ
100
0	20	40	60 BO 100
Environment Steps (×1O3)
(b) Our method DrQ.
Figure 9: In the data-efficient regime, where we measure performance at 100k environment steps,
DrQ is able to enhance its efficiency by performing more training iterations per an environment step.
This is because DrQ allows to generate various transformations for a training observation.
21