Figure 1: Transform2Act learns a transform-and-control policy that first applies transform actions todesign an agent and then controls the designed agent to interact with the environment. The giraffe-like agent obtained by Transform2Act can run extremely fast and remain stable (see video).
Figure 2: Transform2Act divides an episode into three stages: (1) Skeleton transform stage, wheresub-policy πθs changes the agent’s skeleton by adding or removing joints; (2) Attribute transformstage, where sub-policy πθz changes joint attributes (e.g., length, size); (3) Execution stage, sub-policy πθe selects control actions for the newly-designed agent to interact with the environment.
Figure 3: Baseline comparison. For each environment, we plot the mean and standard deviation oftotal rewards against the number of simulation steps for all methods, and show their final designs.
Figure 4: Ablation studies. The plots indicate that GNNs and JSMLPs both contribute to theperformance and stability of our approach greatly.
Figure 5: Effect of JSMLPs. Designs without JSMLPs are overly symmetric with little per-jointspecialization, which leads to worse performance.
Figure 6: Baseline comparison of continuous design optimization for finetuning expert designs. Theexpert designs are taken from OpenAI Gym, where we use Hopper for 2D Locomotion and GapCrosser, Ant for 3D Locomotion, and Gym Swimmer for our Swimmer.
Figure 7: An example of the joint indexing used by the JSMLPs in our approach. Every non-rootjoint is indexed by the path from the root to the joint. Starting from an empty index string at theroot, every time we go to the i-th child of the current joint, we add i to the left side of the indexstring. For example, the joint ‘211’ gets its index because to reach the joint from the root, we needto first go the first child ‘1’ of the root, and then go to the first child ‘11’ of joint ‘1’, and then go tothe second child ‘211’ of joint ‘11’, which is the target joint.
Figure 8: Designs process of Transform2Act for the 2D Locomotion environment. We visualize thedesign after each skeleton transform action. For better visualization, we use the joint attributes afterthe attribute transform stage.
Figure 9: Designs process of Transform2Act for the 3D Locomotion environment. We visualize thedesign after each skeleton transform action. For better visualization, we use the joint attributes afterthe attribute transform stage.
Figure 10: Designs process of Transform2Act for the Swimmer environment. We visualize thedesign after each skeleton transform action. For better visualization, we use the joint attributes afterthe attribute transform stage.
Figure 11: A random agent in each of the four environments.
