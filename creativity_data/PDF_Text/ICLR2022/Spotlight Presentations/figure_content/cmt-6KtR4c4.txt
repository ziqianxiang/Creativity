Figure 1: Improvements over TransCoder. The first function returns whether an input integer is odd and istranslated from Python to Java. The translation of TransCoder does not compile because the == operator hasprecedence over & in Java, and parentheses are required unlike in Python. The second example is a functionthat prints an integer in base two, which is translated from Java to Python. TransCoder translates does notmodify the expression x/=2, even though it corresponds to the integer division in Java and to the float divisionin Python. In the third example, a function reversing a char array, TransCoder does not manage to translatethe Java Stack object into the right Python object and uses the unsafe str parameter name. In all three cases,TransCoder-ST manages to leverage the semantics contained in unit tests to translate the function correctly.
Figure 2: Our iterative self-training method. Using EvoSuite, we generate unit tests in Java, Python andC++ corresponding to several input Java functions. With a machine translation model (e.g. TransCoder), wegenerate several candidate translations of the the Java function in Python and C++. Generated translations thatpass the unit tests are used to create a parallel dataset on which we fine-tune the model. Discarding translationsthat fail the unit tests reduces the noise of data coming from the back-translation process, and significantlyimproves the overall performance of the model.
Figure 3: A unit test generated by EvoSuite. The Java function clamps the given value a between the givenmin and max. This test case is not sufficient to test the semantics of the function thoroughly but could be partof a suitable test suite. See Figure 5 in the Appendix for a generated test suite with a high mutation score.
Figure 4: Example of disagreement between our multilingual tests and the test set of TransCoder. Thegold translation is only equivalent to the input Java function on a small domain where there is no integeroverflow and does not pass our unit tests. The version that passes the unit tests casts uses the np.int32 type,reproducing the behaviour of the original Java code but causing it to fail some of the unit tests of TransCoder.
Figure 5:	A generated unit test suite with high mutation score. The mutation score of this testsuite is 95% and we selected it in our dataset for pseudo-labelling. The third test case (i.e. test2)may be too strict as it would make translations using the python int type fail the unit tests.
Figure 6:	A test suite with a good mutation score but only one assert. Even though it containsonly one test and one assert, this test suite tests the semantics of the function on the left properlysince it only returns a constant and its mutation score is 100%. We found that test suites with goodmutation scores and only one assert generally correspond to uninteresting input functions. Removingthese functions and tests from our dataset for self labelling improves the performance of our model.
Figure 7:	A mutant generated by the “Replace arithmetic operator” mutation in EvoSuite. The< operator in the return statement is replaced with >.
Figure 8:	Histogram of mutation scores for our generated unit tests. We select about 40% of theunit tests with our threshold at 0.9. Many of the remaining unit tests have a mutation score of 0.
Figure 9:	Python to C++ translation examples. TransCoder sometimes fails to capture the se-mantics of the incoming code and translates them to other expressions that could occur in similarcontexts. Self-training helps the model to avoid such mistakes.
Figure 10:	Python to Java translation examples. Similarly to Python to C++, TransCoder oftenfails to get the right semantics, especially for conditions where it can hallucinate extra clauses orwrite incorrect comparisons. TransCoder-ST often solves these issues.
Figure 11:	C++ to Python translation examples. For C++ to Python translation, many of the errorsof TransCoder come from incorrectly translated conditions, wrong operators and badly translatedfunctions. TransCoder-ST better comprehends the semantics of the code and is generally able tosolve these issues.
Figure 12:	C++ to Java translation examples. In the first example computed the mini-mum XOR between two elements of an array, TransCoder erroneously translates INT_MAX intoInteger.MIN_VALUE. This value is used in similar contexts (i.e. to compute a maximum in-stead of a minimum) but is inappropriate here. TransCoder-ST manages to correct this and outputs afunction with the right semantics. In the second example, where the function computes the size of thelargest subset of elements of the list that could form a sequence of consecutive integers, TransCoder-ST manages to translate the semantics of S.find(arr[i]-1)==S.end() appropriately whileTransCoder translates it into its negation.
Figure 13:	Java to C++ translation examples. In the first example, which returns whether agiven string corner is present at the beginning and at the end of a string str, TransCodercompletely fails to translate the last logical expression correctly while TransCoder-ST managesto translate the logic to get the right substrings and to return the right output. The second exam-ple is a line defining a priority queue extracted from the kthLargestSum function in the test set ofTransCoder. The PriorityQueue object in Java returns the smallest elements first by default,while priority_queue in C++ returns the largest. TransCoder, which was not trained on anysemantic signal, manages to instantiate a priority queue object but instantiates a max queue insteadof a min queue. TransCoder-ST, which was trained with some supervised signal directly linked tothe semantics of the code, manages to instantiate the right type of priority queue.
Figure 14:	Translation examples for Java to Python. When translating to Python, TransCoderwas often failing to distinguish between float division (/) and integer division (//). It also oftenconfuses other operations, for instance * and **. Training on self-created labels often solves thisissue.
Figure 15:	Our parallel unit tests lead to the generation of more general solutions using tem-plates. Solutions using templates can pass the unit tests for several parameter types, while guessingthe wrong parameter type can lead to some errors. Solutions using templates succeed more often,are more likely to appear in the parallel data we generate and, as a result, in our model’s generations.
