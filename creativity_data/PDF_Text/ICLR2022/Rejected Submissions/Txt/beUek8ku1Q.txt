Under review as a conference paper at ICLR 2022
k-MEDIAN CLUSTERING VIA METRIC EMBEDDING:
Towards Better Initialization with Privacy
Anonymous authors
Paper under double-blind review
Ab stract
In clustering algorithms, the choice of initial centers is crucial for the quality of
the learned clusters. We propose a new initialization scheme for the k-median
problem in the general metric space (e.g., discrete space induced by graphs), based
on the construction of metric embedding tree structure of the data. From the tree,
we propose a novel and efficient search algorithm for good initial centers that
can be used subsequently for the local search algorithm. Our method, named the
HST initialization, can also be easily extended to the setting of differential privacy
(DP) to generate private initial centers. Theoretically, the initial centers from HST
initialization can achieve lower error than those from another popular initialization
method, k-median++, in the non-DP setting. Moreover, with privacy constraint,
we show that the error of applying DP local search followed by our private HST
initialization improves previous results, and approaches the known lower bound
within a small factor. Empirically, experiments are conducted to demonstrate the
effectiveness of our methods.
1	Introduction
Clustering is an important problem in unsupervised learning that has been widely used in social
network analysis, sensor networks, etc. (Punj & Stewart, 1983; Dhillon & Modha, 2001; Banerjee
et al., 2005; Abbasi & Younis, 2007). The goal of clustering is to partition a set of data points into
clusters such that items in the same cluster are expected to be similar, while items in different clusters
should be different. This is concretely measured by the sum of distances (or squared distances)
between each point to its nearest cluster center. One conventional notion to evaluate a clustering
algorithms is: with high probability,
cost(C, D) ≤γOPTk(D)+ξ,
where C is the centers output by the algorithm and cost(C, D) is some cost function defined for
C on the dataset D. OPTk (D) is the cost of optimal (oracle) k-median solution on D. When
everything is clear from context, we will use OPT for short. Here, γ is called multiplicative error
and ξ is called additive error. Alternatively, we may also use the notion of expected cost.
Two popularly studied clustering problems are 1) the k-median problem, and 2) the k-means prob-
lem. The origin of k-median dates back to the 1970’s (e.g., Kaufman et al. (1977)), where one
tries to find the best location of facilities that minimizes the cost measured by the distance between
clients and facilities. Formally, given a set of points D and a distance measure, the goal is to find k
center points minimizing the sum of absolute distances of each sample point to its nearest center. In
k-means, the objective is to minimize the sum of squared distances instead. There are two popular
clustering algorithms. One heuristic is the Lloyd’s algorithm (Lloyd, 1982), which is built upon an
iterative distortion minimization approach. In most cases, this method can only be applied to nu-
merical data, typically in the Euclidean space. Clustering in general metric spaces (discrete spaces)
is also important and useful when dealing with, for example, the graph data, where Lloyd’s method
is no longer applicable. A more broadly applicable approach, the local search method (Kanungo
et al., 2002; Arya et al., 2004), has also been widely studied. It iteratively finds the optimal swap be-
tween the center set and non-center data points to keep lowering the cost. Local search can achieve
a constant approximation ratio (γ = O(1)) to the optimal solution for k-median (Arya et al., 2004).
Initialization of cluster centers. It is well-known that the performance of clustering can be highly
sensitive to initialization. If clustering starts with good initial centers (i.e., with small approxi-
mation error), the algorithm may use fewer iterations to find a better solution. The k-median++
1
Under review as a conference paper at ICLR 2022
algorithm (Arthur & Vassilvitskii, 2007) iteratively selects k data points as initial centers, favoring
distant points in a probabilistic way (see Appendix A for more details). Intuitively, the initial cen-
ters tend to be well spread over the data points (i.e., over different clusters). The produced initial
center is proved to have O(log k) multiplicative error. Followup works of k-means++ further im-
proved its efficiency and scalability, e.g., Bahmani et al. (2012); Bachem et al. (2016); Lattanzi &
Sohler (2019). In this work, we propose a new initialization framework based on metric embedding
methods, with comparable approximation error and running time as k-median++. Importantly, our
initialization scheme can be conveniently combined with the notion of differential privacy.
Clustering with Differential Privacy. The concept of differential privacy (Dwork, 2006; McSherry
& Talwar, 2007) has been popular to rigorously define and resolve the problem of keeping useful
information for model learning, while protecting privacy for each individual. Private k-means prob-
lem has been widely studied, e.g., Feldman et al. (2009); Nock et al. (2016); Feldman et al. (2017),
mostly in the Euclidean space. The paper (Balcan et al., 2017) considered identifying a good candi-
date set (in a private manner) of centers before applying private local search, which yields O(log3 n)
multiplicative error and O((k2 + d) log5 n) additive error. Later on, the Euclidean k-means errors
are further improved to Y = O⑴ and ξ = O(k1.01 ∙d0∙51 + k1.5) by Stemmer & Kaplan (2018), with
more advanced candidate set selection. Huang & Liu (2018) gave an optimal algorithm in terms of
minimizing Wasserstein distance under some data separability condition.
For private k-median clustering, Feldman et al. (2009) considered the problem in high dimensional
Euclidean space. However, it is rather difficult to extend their analysis to more general metrics
in discrete spaces (e.g., on graphs). The strategy of Balcan et al. (2017) to form a candidate cen-
ter set could as well be adopted to k-median, which leads to O(log3/2 n) multiplicative error and
O((k2 +d) log3 n) additive error in high dimensional Euclidean space. Gupta et al. (2010) proposed
a private method for the classical local search heuristic in discrete space, which applies to both k-
medians and k-means. In order to cast privacy on each swapping step, the authors applied the
exponential mechanism of McSherry & Talwar (2007). Their method produced an -differentially
private solution with cost 6OPT + O(4k2 log2 n/), where 4 is the diameter of point set.
The main contributions of this work include :
•	We introduce Hierarchically Well-Separated Tree (HST), a metric embedding tree structure,
to the k-median clustering problem. Once the HST is constructed using the data samples,
we provide an efficient sampling strategy to select the initial center set, with an approxima-
tion factor O(log min{k, 4}) in the non-private setting, which is O(log min{k, d}) when
4 = O(d) (e.g., bounded data). This improves the O(log k) error of k-means/median++
in e.g., the lower dimensional Euclidean space.
•	The main strength of our HST initialization method is that it could be effectively adapted
to differential privacy (DP). The so-called DP-HST algorithm is -DP and outputs initial
centers with O(log n) multiplicative error and O(-1 4k2 log2 n) additive error. Moreover,
running DP-local search starting from this initialization gives O(1) multiplicative error and
O(-14k2(log log n) log n) additive error, which improves previous results towards the
well-known lower bound O(-14k log(n/k)) on the additive error (Gupta et al., 2010)
within a small O(k log log n) factor. To our knowledge, this is the first center initialization
method with differential privacy guarantee and improved error rate in general metrics.
•	We conduct experiments on simulated and real-world datasets to demonstrate the effective-
ness of our methods. In both non-private and private settings, our proposed HST-based
approach achieves smaller cost at initialization than k-median++, which may also lead to
improvements in the final clustering quality. Our private algorithm can also save computa-
tional costs by reaching a good solution with fewer iterations.
2	Preliminaries
Definition 2.1 (Differential Privacy (DP) (Dwork, 2006)). If for any two adjacent data sets D and
D0 with symmetric difference ofsize one, for any O ⊂ Range(A), an algorithm A satisfies
Pr[A(D) ∈ O] ≤ eePr[A(D0) ∈ O],
then algorithm A is said to be e-differentially private.
2
Under review as a conference paper at ICLR 2022
Intuitively, differential privacy requires that after removing any observation, the output of D0 should
not be too different from that of the original dataset D. Smaller indicates stronger privacy, which,
however, usually sacrifices utility. Thus, one of the central topics in differential privacy literature is
to balance the utility-privacy trade-off.
To achieve DP, it is common to introduce noise to the data or the algorithm output. The Laplace
mechanism adds Laplace(η(f)/) noise to the output, which is known to achieve -DP. The expo-
nential mechanism is also a tool for many DP algorithms. Let O be the set of feasible outputs. The
utility function q : D × O → R is what we aim to maximize. The exponential mechanism outputs
an element o ∈ O with probability P[A(D) = o] α exp(,霏O)), where D is the input dataset and
η(f) = sup|D-D0 |=1 |f (D) - f (D0)| is the sensitivity of f. Both mechanisms will be used in the
design of our proposed DP approach.
k-Median Clustering. Following the framework of Arya et al. (2004); Gupta et al. (2010), the
problem of k-median clustering (DP and non-DP) studied in our paper is stated as below.
Definition 2.2 (k-median). Given a universe point set U and a metric ρ : U × U → R, let D ⊆ U
be a set of demand points. The goal of DP k-median is to pick F ⊆ U with |F | = k to minimize
Private k-median:	cost(F, D) =	min ρ(v, f).
v∈D f∈F
(1)
At the same time, the output F is required to be -differentially private to D. For standard non-
private k-median, we assume U = D and minimize
k-median:	cost(F, U) =	min ρ(v, f).
v∈U f∈F
(2)
We may drop “F ” and use “cost(D)” or “cost(U)” if there is no risk of ambiguity.
To better understand the DP clustering problem, we provide an real-world example as follows.
Example 2.1. Consider U to be the universe of all users in a social network (e.g., Twitter). Each
user (account) is public, but also has some private information that can only be seen by the data
holder. Let D be users grouped by some information that might be set as private. Suppose a third
party plans to collaborate with the most influential users in D for e.g., commercial purposes, thus
requesting the cluster centers of D. In this case, we need a strategy to safely release the centers,
while protecting the individuals in D from being identified (since the membership of D is private).
The local search procedure for k-median proposed by Arya et al. (2004) is summarized in Algo-
rithm 1. First we randomly pick k points in U as the initial centers. In each iteration, we search over
all x ∈ F and y ∈ U, and do the SWaP F J F - {χ} + {y} such that F - {χ} + {y} improves the
cost of F the most (if more than factor (1 - α∕k) where α > 0 is a hyper-parameter). We repeat the
procedure until no such swap exists. Arya et al. (2004) showed that the output centers F achieves 5
approximation error to the optimal solution, i.e., cost(F) ≤ 5OPT .
Algorithm 1: Local search for k-median clustering (Arya et al., 2004)
Input: Data points U, parameter k, constant ɑ
Initialization: Randomly select k points from U as initial center set F
while ∃ X ∈ F, y ∈ U s.t. cost (F — {x} + {y}) ≤ (1 — α∕k)cost(F) do
Select (x, y) ∈ Fi X (D \ Fi) with argminχ,y{co^t(F - {x} + {y})}
Swap operation: F J F - {x} + {y}
Output: Center set F
3	Initialization via Hierarchically Well-Separated Tree (HST)
In this section, we propose our new initialization scheme for k-median clustering, and provide our
analysis in the non-private case solving (2). The idea is based on the metric embedding theory. We
will start with an introduction to the main tool used in our approach.
3
Under review as a conference paper at ICLR 2022
Figure 1: An illustrative example of a 3-level padded decomposition and corresponding 2-HST.
Left: The thickness of the ball represents the level. The color corresponds to the levels in the HST
in the right panel. "4"'S are the center nodes of partitions (balls), and “x”'S are non-center data
points. Right: The resulting 2-HST generated from the padded decomposition.
3.1	Hierarchically Well- S eparated Tree (HST)
In this paper, for an L-level tree, we will count levels in descending order down the tree. That is, the
root is level L, and its children form level L - 1, and etc. We use hv to denote the level of v, and
ni be the number of nodes at level i. The Hierarchically Well-Separated Tree (HST) is based on the
padded decompositions of a general metric space in a hierarchical manner (Fakcharoenphol et al.,
2004). Let (U, ρ) be a metric space with |U| = n, and we will refer to this metric space without
specific clarification. A β-padded decomposition of U is a probabilistic distribution of partitions
of U such that the diameter of each cluster Ui ∈ U is at most β, i.e., ρ(u, v) ≤ β, ∀u, v ∈ Ui,
i = 1, ..., k. Based on the this, we will adopt the standard 2-HST for our algorithm design.
Definition 3.1. Assume the smallest distance between u, v ∈ U is 1, and 4 = maxu,v∈U ρ(u, v). A
2-Hierarchically Well-Separated Tree (2-HST) is an edge-weighted rooted tree T, such that an edge
between any pair of two nodes of level i - 1 and level i has length at most 4/2L-i.
We briefly describe the construction of 2-HST, and place the detailed algorithm in Algorithm 7 in
the Appendix A. We first find a padded decomposition PL = {PL,1, ..., PL,nL} of U with parameter
β = 4/2. The center of each partition in PL,j serves as a root node in level L. Then, we re-do a
padded decomposition for each partition PL,j , to find sub-partitions with diameter β = 4/4, and
set the corresponding centers as the nodes in level L - 1, and so on. Each partition at level i is
obtained with β = 4/2L-i. This process proceeds until a node has a single point, or a pre-specified
tree depth is reached. In Figure 1, we provide an example of L = 3-level 2-HST (left panel), along
with its underlying padded decompositions (right panel).
HST induces a tree metric, which will be related to the general metric in our analysis. It is worth
mentioning that, there are polynomial time algorithms for computing an exact k-median solution in
the tree metric (Tamir (1996); Shah (2003)). However, the dynamic programming algorithms have
high complexity (O(kn2) and O(k2nh) where h is at least O(log n), respectively), making them
unsuitable to serve the purpose of fast initialization. Moreover, it is unknown how to apply them
effectively to the private case. Hence, next, we propose a novel tree search algorithm that is very
efficient, produces a O(1) approximation error in the tree metric, and can be extended to DP easily.
3.2	HST Initialization Algorithm
Let L = log ∆ and suppose T is a level-L 2-HST in (U, ρ), where for simplicity we assume L is an
integer. Fora node v at level i, we use T(v) to denote the subtree rooted at v. Let Nv = |T (v)| be the
number of data points in T(v). The sampling strategy for initial centers is presented in Algorithm 2,
which has two phases: subtree search and leaf search.
Subtree search. The first step is to identify the subtrees that contain the k centers. To begin with, k
initial centers Ci are picked from T who have the largest Score(V) = N(V) ∙ 2hv. This is intuitive,
since to get a good clustering, we typically want the ball surrounding each center to include more
data points. Next, we do a screening over C1: if there is any ancestor-descendant pair of nodes, we
remove the ancestor from C1. If the current size of C1 is smaller than k, we repeat the process until
k centers are chosen (we do not re-select nodes in C1 and their ancestors). This way, C1 contains k
4
Under review as a conference paper at ICLR 2022
Algorithm 2: HST initialization - NDP (Non-Differentially Private)
Input: U, 4, k
Initialization: L = log 4, Co = 0, Ci = 0
Call Algorithm 7 to build a level-L 2-HST T based on input U
for each node v in T do
Nv -|U ∩ T(v)|
score(v) - Nv ∙ 2hv
while |C1 | < k do
Add top (k - |C1 |) nodes with highest score in T to C1
for each v ∈ C1 do
I	Ci	=	Ci	\ {v}, if ∃	v0	∈	Ci	that v0	is a descendant	of V
C0 = FIND-LEAF(T,C1)
Output: Initial center set C0 ⊆ U
Algorithm 3: FIND-LEAF (T, Ci)
Input: T, Ci
Initialization: C0 = 0
for each node v in Ci do
while v is not a leaf node do
I V J argw max{Nw ,w ∈ Ch(V)}, where ch(v) denotes the children nodes of V
Add v to C0
Output: Initial center set C0 ⊆ U
root nodes of k disjoint subtrees. For any node w with T(w) ∩ Ci = 0 and a node v ∈ Ci, ifw is
not an ancestor of v, then score(w) ≤ score(v).
Leaf search. After we find Ci the set ofk subtrees, the next step is to find the center in each subtree
using Algorithm 3 (“FIND-LEAF”). We employ a greedy search strategy, by finding the child node
with largest score level by level, until a leaf is found. This approach is intuitive since the diameter
of the partition ball exponentially decays with the level. Therefore, we are in a sense focusing more
and more on the region with higher density (i.e., with more data points).
The time complexity is given as below, considering the Euclidean space as an example.
Proposition 3.1 (Complexity). Algorithm 2 takes O(dn log n) time in the Euclidean space.
Remark 3.1. The complexity of HST initialization is in general comparable to the O(dnk) of k-
median++. Our algorithm would be faster if k, the number of centers, is larger. See Appendix B for
a numerical comparison of the running time.
3.3	Approximation Error of HST Initialization
Firstly, we show that the initial center set produced by Algorithm 2 is already a good approximation
to the optimal k-median solution. Let ρT (x, y) = dT (x, y) denote the “2-HST metric” between x
and y in the 2-HST T, where dT (x, y) is the tree distance between nodes x and y in T. In 2-HST,
by Definition 3.1 and 4 = 2L, in the analysis we assume equivalently that the edge weight of the
i-th level 2i-i. The crucial step of our analysis is to examine the approximation error in terms of
the 2-HST metric, after which the error can be easily adapted to the general metrics by Lemma 3.2.
Lemma 3.2. (Bartal, 1996). In a metric space (U, ρ) with |U| = n and diameter 4, it holds that
E[ρT (x, y)] = O(min{log n, log 4})ρ(x, y). InRd, E[ρT (x, y)] = O(d)ρ(x, y).
Recall C0, Ci from Algorithm 2. We define
costkT (U) =	xm∈iCn ρT(x,y),
y∈U	0
costkT0(U, Ci) =	min	min ρT (x, y),
k	|F∩T(v)∣ = i,∀v∈Cι 4，x∈F
y∈U
(3)
(4)
5
Under review as a conference paper at ICLR 2022
OPTkT(U) = F	UmiFn	k	m∈iFn ρT (x,	y)	≡	mCi0n	costkT0(U,C10).	(5)
,l L y∈u	1
For simplicity, we will use costkT0(U) to denote costkT 0 (U, C1). Here, OP TkT (5) is the cost of
the global optimal solution with 2-HST metric. The last equality in (5) holds because the optimal
centers set can always located in k disjoint subtrees, as each leaf only contain one point. (3) is the
k-median cost with 2-HST metric of the output C0 of Algorithm 2. (4) is the oracle cost after the
subtrees are chosen. That is, it represents the optimal cost to pick one center from each subtree in
C1 . Firstly, we bound the approximation error of the subtree search process.
Lemma 3.3 (Subtree search). costkT0(U) ≤ 5OP TkT (U).
Next, we show that the greedy leaf search (Algorithm 3) only has constant extra multiplicative error.
Lemma 3.4 (Leaf search). costkT (U) ≤ 2costkT0(U).
Combining Lemma 3.3 and Lemma 3.4, we have the next Theorem.
Theorem 3.5	(2-HST error). Running Algorithm 2, we have costkT (U) ≤ 10OP TkT (U).
Thus, HST-initialization produces an O(1) approximation to OPT in the 2-HST metric. Define
costk (U) as (2) for our HST centers, and the optimal cost w.r.t. ρ as
OPTk(U)
|Fm|i=nk	mx∈iFnρ(x,y).
y∈U
(6)
We have the following result in the general metric space based on Lemma 3.2.
Theorem 3.6.	Running Algorithm 2 gives E [costk (U)] = O(min{log n, log 4})OP Tk (U).
Remark 3.2. In the Euclidean space, Makarychev et al. (2019) proved O(log k) random projections
suffice for k-median to achieve O(1) error. Thus, if 4 = O(d) (e.g., bounded data), by Lemma 3.2,
there exists an algorithm with HST initialization that achieves O(log(min{d, k})) error, which is
better than O(log k) of k-median++ when d is small.
NDP-HST Local Search. We can apply standard local search starting from the HST initialization
in Algorithm 1. We call it the NDP-HST (“NDP” stands for “Non-Differentially Private”) method,
with the following guarantee.
Theorem 3.7.	NDP-HST achieves O(1) approximation in expected O(k log min{log n, log 4})
number of iterations for input in general metric space.
Before ending this section, we remark that HST initialization and the analysis can be extended to
k-means clustering analogously (see Appendix D). In a general metric space, E[costkm(U)] =
O(min{log n, log 4})2OP Tkm(U) where costkm (U) is the optimal k-means cost.
4	HST Initialization with Differential Privacy
In this section, we consider private HST initialization method. Recall in this setting, U is the universe
of data points, and D ⊂ U is a demand set that needs to be clustered with privacy. Since U is public,
running initialization algorithms on U would preserve the privacy of D. Yet, this might be too
expensive, and in many cases one would probably want to incorporate some information about D
in the initialization, since D could be a very imbalanced subset of U. For example, D may only
contain data points from one cluster, out of tens of clusters in U. In this case, initialization on U
is likely to pick initial centers in multiple clusters, which would not be helpful for clustering on D .
Next, we show how our HST initialization can be easily combined with differential privacy that at
the same time contains information about the demand set D, leading to improved approximation
error (Theorem 4.3) and empirical clustering performance (Section 5).
Again, suppose T is an L = log 4-level 2-HST of universe U in a general metric space. Denote
Nv = |T (v) ∩ D| for a node point v. Our private HST initialization is similar to the non-private
Algorithm 2. To gain privacy, we perturb Nv by adding i.i.d. Laplace noise:
Nv = Nv + LaPS °,
6
Under review as a conference paper at ICLR 2022
Algorithm 4: HST initialization with differential privacy
Input: U, D, 4, k,
Build a level-L 2-HST T based on input U
for each node v in T do
Nv -|D ∩ T(v)|
Nv ― Nv + Lap$LfV )∕e)
Score(V) — N(V) ∙ 2hv
Based on Nv, apply the same strategy as Algorithm 2: find C1; C0 = FIND-LEAF(C1)
Output: Private initial center set C0 ⊆ U
where Lap(2(L-hv)/) is a Laplace random number with rate 2(L-hv)/. We will use the perturbed
Nv for node sampling instead of the true value Nv, as described in Algorithm 4. The DP guarantee
of this initialization scheme is straightforward by the composition of the Laplace mechanisms.
Theorem 4.1.	Algorithm 4 is -differentially private.
Proof. For each level i, the subtrees T(V, i) are disjoint to each other. The privacy used in i-th level
is e/2(L-i), and the total privacy is Pi e/2(LT) < e.	□
We now consider the approximation error. As the structure of the analysis is similar to the non-DP
case, we present the main result here and defer the detailed proofs to Appendix C.
Theorem 4.2.	Algorithm 4 outputs an initial center set such that
E[costk(D)] = O(log n)(OP Tk (D) + ke-14 log n).
DP-HST Local Search. Similarly, we can use private HST initialization to improve the performance
of private k-median local search, which is presented in Algorithm 5. After initialization, the DP local
search procedure follows Gupta et al. (2010) using the exponential mechanism.
Algorithm 5: DP-HST local search
Input: U, demand points D ⊆ U, parameter k, e, T
Initialization: F1 the private initial centers generated by Algorithm 4 with privacy e/2
Set parameter e0 = 24(T+黄
for i = 1 to T do
Select (x, y) ∈ Fi × (V \ Fi) with prob. proportional to exp(-e0 × (cost(Fi - {x} + {y}))
Let Fi+1 - Fi - {x} + {y}
Select j from {1, 2, ..., T + 1} with probability proportional to exp(-e0 × cost(Fj))
Output: F = Fj the private center set
Theorem 4.3.	Algorithm 5 achieves e-differential privacy. The output centers admit
costk(D) ≤ 6OP Tk(D) + O(e-1k24(log log n) log n)
with probability (1 - 1/poly(n)), with T = O(k log log n) iterations.
The DP local search with random initialization (Gupta et al., 2010) has 6 multiplicative error and
O(e-14k2 log2 n) additive error. Our result improves the logn term to log logn in the additive er-
ror. Meanwhile, the number of iterations needed is improved from T = O(k log n) to O(k log log n)
(see Appendix B for an empirical justification). Notably, it has been shown in Gupta et al. (2010)
that for k-median problem, the lower bounds on the multiplicative and additive error of any e-DP al-
gorithm are O(1) and O(e-14k log(n/k)), respectively. Our result matches the lower bound on the
multiplicative error, and the additive error is only worse than the bound by a factor of O(k log log n)
which is typically small in many cases. Thus, our private HST initialization method pushes the ap-
proximation error of private local search closer to the lower bound. To our knowledge, Theorem 4.3
is the first result in literature to improve the error ofDP local search in general metric space.
7
Under review as a conference paper at ICLR 2022
5	Experiments
We numerically test the proposed methods on two problems—clustering in an Euclidean space and
on a graph. Our results show that the proposed HST initialization can improve the performance of
using k-median++ initialization in both non-private and private clustering tasks.
5.1	Datasets and Algorithms
Discrete Euclidean space. Following Balcan et al. (2017), we test k-median clustering on the
MNIST hand-written digit dataset (LeCun et al., 1998) with 10 natural clusters (digit 0 to 9). We
set U as 10000 randomly chosen data points. We choose the demand set D using two strategies: 1)
“balance”, where we randomly choose 500 samples from U; 2) “imbalance”, where D contains 500
random samples from U only from digit “0” and “8” (two clusters). We note that, the imbalanced D
is a very practical setting in real-world scenarios, where data are typically not uniformly distributed.
On this dataset, we test clustering with both l1 and l2 distance as the underlying metric.
Metric space induced by graph. Random graphs have been widely considered in testing k-median
methods (Balcan et al., 2013; Todo et al., 2019). The construction of graphs follows a similar
approach as the synthetic pmedinfo graphs provided by the popular OR-Library (Beasley, 1990).
The metric ρ for this experiment is the shortest (weighted) path distance on graph. To generate a
size n graph, we first randomly split the nodes into 10 clusters. Within each cluster, each pair of
nodes is connected with probability 0.2 and weight drawn from standard uniform distribution. For
each pair of clusters, we randomly connect some nodes from each cluster, with weights following
uniform [0.5, r]. A larger r makes the graph more separable, i.e., clusters are farther from each other
(see Appendix B for example graphs). We present two cases: r = 1 and r = 100. For this task, U
has 3000 nodes, and the private set D is chosen using similar “balanced” and “imbalanced” scheme
as described above. In the imbalanced case, we choose D randomly from only two clusters.
Algorithms. We compare the following clustering algorithms in both non-DP and DP setting.
•	NDP-rand: Local search on D with random initialization (Algorithm 1).
•	NDP-kmedian++: Algorithm 1 with k-median++ initialization.
•	NDP-HST: Algorithm 1 with HST initialization, as described in Section 3.
•	DP-rand: Standard private local search algorithm (Gupta et al., 2010), which is Algo-
rithm 5 with initial centers randomly chosen from U.
•	DP-kmedian++: Algorithm 5 with k-median++ initialization run on U.
•	DP-HST: Private local search with HST-initialization (Algorithm 5). For non-private tasks,
we set L = 6. For private clustering, we use L = 8.
For non-DP methods, we set α = 10-3 in Algorithm 1 and the maximum number of iterations as
20. To examine the quality of initialization as well as the final centers, We report both the cost at
initialization and the cost of the final output. For DP methods, we run the algorithms for T = 20
steps and report the results with = 1. We test k ∈ {2, 5, 10, 15, 20}. The average cost over T
iterations is reported for more robustness. All results are averaged over 10 independent repetitions.
5.2	Results
The results on MNIST dataset are given in Figure 2 for l1 (left two columns) and l2 (right two
columns) metric. The comparisons are similar in both cases.
•	We see that the initial centers generated by HST has lower k-median cost than k-median++
and random initialization, for both non-DP and DP setting, and for both balanced and
imbalanced demand set D. This confirms that the proposed HST initialization is more
powerful than k-median++ in finding good initial centers.
•	From the final k-median cost plots, we also observe lower cost of HST approaches in DP
clustering. In the non-DP case, the curves overlap, which means despite that HST offers
better initial centers, local search can always find a good solution eventually.
8
Under review as a conference paper at ICLR 2022
x104	Balanced D
ISOo -E--U-
'%∙.?
-S--NDP-HST
-Q--NDP-Kmedian++
书∙NDP-rand
DP-HST
—j-DP-kmedian++
-Δ DP-rand
MNIST - ∣i
■5
20
Imbalanced D
10
k
ISOo -E_1一U-
∙ ∙ J ' JL J ∖
5 43∙
ISOo UE-PoE，
5.5
5
MNIST
-S-NDP-HST
-Θ-NDP-kmedian++
奇∙NDP-rand
DP-HST
—j-DP-kmedian++
/ DP-rand
3.5 l
2
Balanced D
5000
10
15
— ∣1
一二 4000
3500 l
2
Balanced D
45 4500手
5
10
15
20
MNIST - ∣2
-EI-NDP-HST
f-θ-NDP-kmedian++
令 NDP-rand
DP-HST
-j-DP-kmedian++
2 DP-rand
ISoo UE-PgIX
k	k	k
x104	Imbalanced D
6
5500
-∣1
3500 l
2
Imbalanced D
1 5000
而 4500
4000
5
10
15
20
MNIST - ∣2
Imbalanced D
-S-NDP-HST
-Θ-NDP-kmedian++
令 NDP-rand
DP-HST
—j-DP-kmedian++
/ DP-rand
ISO。UE-PgIX
4 4
5

k	k
Figure 2:	k-median cost on MNIST dataset. 1st row: balanced D. 2nd row: imbalanced D .
Column 1 & 3: initial cost. Column 2 & 4: final k-median cost.
Balanced D
Balanced D
,0,0
O O
O 5
00 -E_1一U-
GRAPH r = 10.
5	10	15	20
Imbalanced D
-S-NDP-HST
-θ-NDP-kmedian++
-^--NDP-rand
DP-HST
—j-DP-kmedian++
DP-rand
Is。。UE-POuJi
300
GRAPH r = - 100
-S-NDP-HST
-θ-NDP-kmedian++
书∙NDP-rand
DP-HST
—i—DP-kmedian++
-Δ DP-rand
100
Balanced D
飞80
二60
GRAPH r = 1
5
15
20
10
k
-S-NDP-HST
-Θ-NDP-kmedian++
令 NDP-rand
DP-HST
—j—DP-kmedian++
4 DP-rand
-Q--NDP-HST
-Θ~NDP-kmedian++
寻 NDP-rand
DP-HST
,-j-DP-kmedian++
DP-rand
Imbalanced D
-Q-NDP-HST
-θ-NDP-kmedian++
令 NDP-rand
DP-HST
—j-DP-kmedian++
DP-rand
40
20
800∣------'-----
I GRAPH r = 100
60
-S-NDP-HST
-θ-NDP-kmedian++
令 NDP-rand
DP-HST
—f—DP-kmedian++
工 DP-rand_______
10
15
-/,；■
-Si*
20
5
20
15
10
k
Imbalanced D
GRAPH r = 100
I 200
α>
E 100
0
-Q-NDP-HST
-Θ-NDP-kmedian++
令 NDP-rand
DP-HST
—f—DP-kmedian++
4 DP-rand
100
2	5	10	15	20
40 l
2
Imbalanced D
80
80
6
40
8 60
GRAPH r= 1
GRAPH r = 1
5
10
15
5
20 l
2
20 l
20	2
10
~0∙∙
15
M>
20
2
5
Figure 3:	k-median costs on graph dataset. 1st row: balanced D. 2nd row: imbalanced D.
• The advantage of HST in both initial and final cost is more significant when D is an imbal-
anced subset of U. As mentioned before, this is because our HST initialization approach
also privately incorporates the information of D.
The set of results on the graph dataset is reported in Figure 3, which gives us similar conclusion. In
all cases, our proposed HST method finds better initial centers with smaller cost than k-median++. In
terms of the final clustering output, HST again considerably outperforms k-median++ in the private
and imbalanced D setting, for both r = 100 (highly separable graph) and r = 1 (less separable
graph). The improvement of HST over k-median++ is especially significant in the harder tasks
when r = 1, i.e., the clusters are nearly mixed up.
6 Conclusion
In this paper, we propose a new initialization framework for the k-median problem in general dis-
crete metric space. Our approach is called HST, which leverages tools from metric embedding
theory. Our novel tree search approach has comparable efficiency and cost to k-median++ initializa-
tion. Moreover, we propose differentially private (DP) HST center initialization algorithm, which
adapts to the private demand point set, leading to better clustering performance. When combined
with subsequent DP local search heuristic, our algorithm is able to improve the addition error of
prior works, which is close to the theoretical lower bound within a small factor. Experiments with
Euclidean metrics and graph metrics verify the effectiveness of our methods.
9
Under review as a conference paper at ICLR 2022
References
Ameer Ahmed Abbasi and Mohamed F. Younis. A survey on clustering algorithms for wireless
sensor networks. Comput Commun.,30(14-15):2826-2841,2007.
David Arthur and Sergei Vassilvitskii. k-means++: the advantages of careful seeding. In Proceed-
ings of the Eighteenth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2007, New
Orleans, Louisiana, USA, January 7-9, 2007, pp. 1027-1035, 2007.
Vijay Arya, Naveen Garg, Rohit Khandekar, Adam Meyerson, Kamesh Munagala, and Vinayaka
Pandit. Local search heuristics for k-median and facility location problems. SIAM J. Comput., 33
(3):544-562, 2004.
Olivier Bachem, Mario Lucic, S. Hamed Hassani, and Andreas Krause. Approximate k-means++ in
sublinear time. In Dale Schuurmans and Michael P. Wellman (eds.), Proceedings of the Thirtieth
AAAI Conference on Artificial Intelligence, February 12-17, 2016, Phoenix, Arizona, USA, pp.
1459-1467. AAAI Press, 2016.
Bahman Bahmani, Benjamin Moseley, Andrea Vattani, Ravi Kumar, and Sergei Vassilvitskii. Scal-
able k-means++. Proc. VLDB Endow., 5(7):622-633, 2012.
Maria-Florina Balcan, Steven Ehrlich, and Yingyu Liang. Distributed k-means and k-median cluster-
ing on general communication topologies. In Advances in Neural Information Processing Systems
26: 27th Annual Conference on Neural Information Processing Systems 2013. Proceedings of a
meeting held December 5-8, 2013, Lake Tahoe, Nevada, United States, pp. 1995-2003, 2013.
Maria-Florina Balcan, Travis Dick, Yingyu Liang, Wenlong Mou, and Hongyang Zhang. Differen-
tially private clustering in high-dimensional euclidean spaces. In Proceedings of the 34th Interna-
tional Conference on Machine Learning, ICML 2017, Sydney, NSW, Australia, 6-11 August 2017,
pp. 322-331, 2017.
Arindam Banerjee, Srujana Merugu, Inderjit S. Dhillon, and Joydeep Ghosh. Clustering with breg-
man divergences. J. Mach. Learn. Res., 6:1705-1749, 2005.
Yair Bartal. Probabilistic approximations of metric spaces and its algorithmic applications. In 37th
Annual Symposium on Foundations of Computer Science, FOCS ’96, Burlington, Vermont, USA,
14-16 October, 1996, pp. 184-193. IEEE Computer Society, 1996.
John E Beasley. Or-library: distributing test problems by electronic mail. Journal of the operational
research society, 41(11):1069-1072, 1990.
Inderjit S. Dhillon and Dharmendra S. Modha. Concept decompositions for large sparse text data
using clustering. Mach. Learn., 42(1/2):143-175, 2001.
Cynthia Dwork. Differential privacy. In Automata, Languages and Programming, 33rd International
Colloquium, ICALP 2006, Venice, Italy, July 10-14, 2006, Proceedings, Part II, pp. 1-12, 2006.
Jittat Fakcharoenphol, Satish Rao, and Kunal Talwar. A tight bound on approximating arbitrary
metrics by tree metrics. J. Comput. Syst. Sci., 69(3):485-497, 2004.
D. Feldman, C. Xiang, R. Zhu, and D. Rus. Coresets for differentially private k-means clustering
and applications to privacy in mobile sensor networks. In 2017 16th ACM/IEEE International
Conference on Information Processing in Sensor Networks (IPSN), pp. 3-16, 2017.
Dan Feldman, Amos Fiat, Haim Kaplan, and Kobbi Nissim. Private coresets. In Proceedings of the
41st Annual ACM Symposium on Theory of Computing, STOC 2009, Bethesda, MD, USA, May
31 - June 2, 2009, pp. 361-370, 2009.
Anupam Gupta, Katrina Ligett, Frank McSherry, Aaron Roth, and Kunal Talwar. Differentially
private combinatorial optimization. In Proceedings of the Twenty-First Annual ACM-SIAM Sym-
posium on Discrete Algorithms, SODA 2010, Austin, Texas, USA, January 17-19, 2010, pp. 1106-
1125, 2010.
10
Under review as a conference paper at ICLR 2022
Zhiyi Huang and Jinyan Liu. Optimal differentially private algorithms for k-means clustering. In
Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database
Systems, Houston, TX, USA, June 10-15, 2018,pp. 395-408, 2018.
Tapas Kanungo, David M. Mount, Nathan S. Netanyahu, Christine D. Piatko, Ruth Silverman, and
Angela Y. Wu. A local search approximation algorithm for k-means clustering. In Proceedings of
the 18th Annual Symposium on Computational Geometry, Barcelona, Spain, June 5-7, 2002, pp.
10-18, 2002.
Leon Kaufman, Marc Vanden Eede, and Pierre Hansen. A plant and warehouse location problem.
Journal of the Operational Research Society, 28(3):547-554, 1977.
Silvio Lattanzi and Christian Sohler. A better k-means++ algorithm via local search. In Proceedings
of the 36th International Conference on Machine Learning, ICML 2019, 9-15 June 2019, Long
Beach, California, USA, volume 97 of Proceedings of Machine Learning Research, pp. 3662-
3671. PMLR, 2019.
Yann LeCun, Leon Bottou, YoshUa Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
S. Lloyd. Least squares quantization in pcm. IEEE Transactions on Information Theory, 28(2):
129-137, 1982.
Konstantin Makarychev, Yury Makarychev, and Ilya P. Razenshteyn. Performance of johnson-
lindenstrauss transform for k-means and k-medians clustering. In Proceedings of the 51st Annual
ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26,
2019, pp. 1027-1038. ACM, 2019.
Frank McSherry and Kunal Talwar. Mechanism design via differential privacy. In 48th Annual IEEE
Symposium on Foundations of Computer Science (FOCS 2007), October 20-23, 2007, Providence,
RI, USA, Proceedings, pp. 94-103, 2007.
Richard Nock, Raphael Canyasse, Roksana Boreli, and Frank Nielsen. k-variates++: more pluses
in the k-means++. In Proceedings of the 33nd International Conference on Machine Learning,
ICML 2016, New York City, NY, USA, June 19-24, 2016, pp. 145-154, 2016.
Girish Punj and David W Stewart. Cluster analysis in marketing research: Review and suggestions
for application. Journal of marketing research, 20(2):134-148, 1983.
Rahul Shah. Faster algorithms for k-median problem on trees with smaller heights. Technical report,
2003.
Uri Stemmer and Haim Kaplan. Differentially private k-means with constant multiplicative error.
In Advances in Neural Information Processing Systems 31: Annual Conference on Neural In-
formation Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montreal, Canada, pp.
5436-5446, 2018.
Arie Tamir. An o(pn2) algorithm for the p-median and related problems on tree graphs. Oper. Res.
Lett., 19(2):59-64, 1996.
Keisuke Todo, Atsuyoshi Nakamura, and Mineichi Kudo. A fast approximate algorithm for k-
median problem on a graph. 15th International Workshop on Mining and Learning with Graphs,
2019.
11
Under review as a conference paper at ICLR 2022
A Postponed Algorithms
A.1 k-MEDIAN++
In the paper, we compared our HST initialization mainly with another (perhaps most well-known)
initialization algorithm for clustering, the k-median++ (Arthur & Vassilvitskii, 2007). For reference,
we present the concrete procedures in Algorithm 6. Here, the function D(u, C) is the shortest
distance from a data point u to the closest (center) point in set C . Arthur & Vassilvitskii (2007)
showed that the output centers C by k-median++ achieves O(log k) approximation error, in O(dnk)
time.
Algorithm 6: k-median++ (Arthur & Vassilvitskii, 2007)
Input: Data points U, number of centers k
Set C = [ ]
Randomly pick a point c1 in U and set C = C ∪ {c1}
for i = 2 to k do
	Select ci = U ∈ U with probability P u	D(u,C) ∈u D(u0,C)
	C=C∪{ci}	
Output: k-median++ initial center set C		
A.2 Constructing a 2-HST
As presented in Algorithm 7, the construction starts by applying a permutation π on U, such that in
following steps the points are picked in a random sequence. We first find a padded decomposition
PL = {PL,1, ..., PL,nL } of U with parameter β = 4/2. The center of each partition in PL,j serves
as a root node in level L. Then, we re-do a padded decomposition for each partition PL,j , to find
sub-partitions with diameter β = 4/4, and set the corresponding centers as the nodes in level L - 1,
and so on. Each partition at level i is obtained with β = 4/2L-i. This process proceeds until a
node has a single point, or a pre-specified tree depth is reached. In Figure 1, we provide an example
of L = 3-level 2-HST (left panel), along with its underlying padded decompositions (right panel).
Algorithm 7: Build 2-HST(U, L
Input: Data points U with diameter 4, L
Randomly pick a point in U as the root node of T
Let r = 4/2
Apply a permutation π on U // so points will be chosen in a random sequence
for each v ∈ U do
Set Cv = [v]
for each u ∈ U do
A Add U ∈ U to Cv if d(v, U) ≤ r and U / Uv，=。C√
Set the non-empty clusters Cv as the children nodes ofT
for each non-empty cluster Cv do
I RUn 2-HST(Cv, L 一 1) to extend the tree T; stop until L levels or reaching a leaf node
Output: 2-HST T
12
Under review as a conference paper at ICLR 2022
B	More Experiments
B.1	Examples of Graph Data
In Figure 4, we plot two example graphs (subgraphs of 50 nodes) with r = 100 and r = 1. When
r = 100, the graph is highly separable (i.e., clusters are far from each other). When r = 1, the
clusters are harder to be distinguished from each other.
Figure 4: Example of synthetic graphs: subgraph of 50 nodes. Left: r = 1. Right: r = 100. Darker
and thicker edged have smaller distance. When r = 100, the graph is more separable.
B.2	RUNNING TIME COMPARISON WITH k-MEDIAN++
In Proposition 3.1, we show that our HST initialization algorithm admits O(dn log n) complexity
when considering the Euclidean space. With a smart implementation of Algorithm 6 where each
data point tracks its distance to the current closest candidate center in C, k-median++ has O(dnk)
running time. Therefore, the running time of our algorithm is in general comparable to k-median++.
Our method would run faster if k = Ω(log n). In Figure 5, We plot the empirical running time
of HST initialization against k-median++, on MNIST dataset with l2 distance (similar comparison
holds for l1). From the left subfigure, we see that k-median++ becomes slower with increasing k,
and our method is more efficient when k > 20. In the right panel, we observe that the running
time of both methods increases with larger sample size n. Our HST algorithm has a slightly faster
increasing rate, which is predicted by the complexity comparison (nlogn v.s. n). However, this
difference in log n factor would not be too significant unless the sample size is extremely large.
Overall, our numerical results suggest that in general, the proposed HST initialization would have
similar efficiency as k-median++ in common practical scenarios.
0.6
0.8
0.4
0.4
0.2
0τ
2
0τ-------1------1------1-------
500	1000	2000	3000	5000
5
10
k
20
30
n
Figure 5: Empirical time comparision of HST initialization v.s. k-median++, on MNIST dataset
with l2 distance. Left: The running time against k, on a subset ofn = 2000 data points. Right: The
running time against n, with k = 20 centers.
13
Under review as a conference paper at ICLR 2022
B.3	Improved Iteration Cost of DP-HST
In Theorem 4.3, we show that under differential privacy constraints, the proposed DP-HST (Algo-
rithm 5) improves both the approximation error and the number of iterations required to find a good
solution of classical DP local search (Gupta et al., 2010). In this section, we provide some numerical
results to justify the theory.
First, we need to properly measure the iteration cost of DP local search. This is because, unlike the
non-private clustering, the k-median cost after each iteration in DP local search is not decreasing
monotonically, due to the probabilistic exponential mechanism. To this end, for the cost sequence
with length T = 20, we compute its moving average sequence with window size 5. Attaining the
minimal value of the moving average indicates that the algorithm has found a “local optimum”, i.e.,
it has reached a “neighborhood” of solutions with small clustering cost. Thus, we use the number of
iterations to reach such local optimum as the measure of iteration cost. The results are provided in
Figure 6. We see that on all the tasks (MNIST with l1 and l2 distance, and graph dataset with r = 1
and r = 100), DP-HST has significantly smaller iterations cost. In Figure 7, we further report the
k-median cost of the best solution in T iterations found by each DP algorithm. We see that DP-HST
again provide the smallest cost. This additional set of experiments again validates the claims of
Theorem 4.3, that DP-HST is able to found better initial centers in fewer iterations.
6
ISoo U-Eol SUO4E-I9-
4 2
MNIST - 11
*DP-HST
—|—DP-kmedian++
-A-DP-rand
10K
2()
8 6 4
4 2
ISO。U-LUo+-»SUO+3E-I9-
6 4 2 0 8 6
ISO。U-Eol ω⊂o⅛1-φ⅛
ISO。U-E Ol SU04E」①一一
GRAPH r = 1
*DP-HST
-H DP-kmedian++
-Δ-DP-rand
10k
2()
Figure 6: Iteration cost to reach a locally optimal solution, on MNIST and graph datasets with
different k. The demand set is an imbalanced subset of the universe.
IS8 UE-P①Ee U-LU
k
Figure 7: The k-median cost of the best solution found by each differentially private algorithm. The
demand set is an imbalanced subset of the universe. Same comparison holds on graph data.
8
5
5
6 4 2 0 8
5
5
14
Under review as a conference paper at ICLR 2022
C Proofs
The following composition result of differential privacy will be used in our proof.
Theorem C.1 (Composition Theorem (DWork, 2006)). If Algorithms Ai, b2,…,Am are
e1,e2,…,em differentially private respectively, then the union (Ai(D), A2(D),…,Am(D)) is
Pim=i i-DP.
C.1 Proof of Lemma 3.3
Proof. Consider the intermediate output of Algorithm 2, Ci = {vi, v2, ..., vk}, Which is the set of
roots of the minimal subtrees each containing exactly one output center C0 . Suppose one of the
optimal “root set" that minimizes (4) is C； = {vi, v2,…,Vk }. If Ci = C；, the proof is done. Thus,
We prove the case for Ci = C；. Note that T(v), v ∈ Ci are disjoint subtrees. We have the following
reasoning.
•	Case 1: for some i, j0, vi is a descendant node of vj0 . Since the optimal center point f； is a
leaf node by the definition of (4), We knoW that there must exist one child node of vj0 that
expands a subtree Which contains f； . Therefore, We can alWays replace vj0 by one of its
child nodes. Hence, We can assume that vi is not a descendant of vj0 .
Note that, We have score(vj0 ) ≤ score(vi) if vj0 ∈/ Ci； ∩Ci. Algorithm 2 sorts all the nodes
based on cost value, and it Would have more priority to pick vj0 than vi if score(vj0 ) >
score(vi) and vi is not a child node of vj0 .
•	Case 2: for some i, j0, vj0 is a descendant ofvi. In this case, optimal center point f；, Which
is a leaf of T(vi), must also be a leaf node of T (vj0 ). We can simply replace Ci With the
sWap Ci \ {vi} + {vj0 } Which does not change costkT 0 (U). Hence, We can assume that vj0
is not a descendant of vi .
•	Case 3: OtherWise. By the construction of Ci, We knoW that score(vj0 ) ≤
min{score(vi), i = 1, ..., k} When vj0 ∈ Ci； \ Ci. Consider the sWap betWeen Ci and
C；. By the definition of tree distance, we have OPTT(U) ≥ Pv∈ci、$ Nvi2hvi, since
{T(vi), vi ∈ Ci \ Ci；} does not contain any center of the optimal solution determined by
Ci； (which is also the optimal “root set” for OPTkT (U)).
Thus, we only need to consider Case 3. Let us consider the optimal clustering with center set be
C； = {ci；, c2；, ..., c；k} (each center cj； is a leaf of subtree whose root be c0j), and Sj0 be the leaves
assigned to cj；. Let Sj denote the set of leaves in Sj0 whose distance to cj； is strictly smaller than its
distance to any centers in Ci . Let Pj denote the union of paths between leaves of Sj to its closest
center in Ci. Let Vj be the nodes in Pj with highest level satisfying T(Vj) ∩ Ci = 0. The score of
Vj is 2hvj0 N(Vj) That means the swap with a center Vj into Ci can only reduce 4 ∙ 2hvj0 N(vj0) to
CoStT0(U) (the tree distance between any leaf in Sj and its closest center in Ci is at most 4 ∙ 2hvj0).
We just use Vj0 to represent Vj00 for later part of this proof for simplicity. By our reasoning, summing
all the swaps over Ci； \ Ci gives
costkT0(U) - OPTkT(U) ≤ 4 X	Nvj0 2hvj0 ,
vj ∈C'V∖C1
OPTkT(U) ≥ X	Nvi2hvi .
vi∈Cι∖C1
Also, based on our discussion on Case 1, it holds that
Nv0 2hv0j - Nvi2hvi ≤ 0.
Summing them together, we have CoStTO(U) ≤ 5OPTT(U).	□
15
Under review as a conference paper at ICLR 2022
C.2 Proof of Lemma 3.4
Proof. Since the subtrees in C1 are disjoint, it suffices to consider one subtree with root v. With a
little abuse of notation, let cost1T 0(v, U) denote the optimal k-median cost within the point set T(v)
with one center in 2-HST:
cost1T 0 (v, U) = min	ρT(x,y),	(7)
x∈T (v)
y∈T(v)
which is the optimal cost within the subtree. Suppose v has more than one children u, w, ..., other-
wise the optimal center is clear. Suppose the optimal solution of cost1T0(v, U) chooses a leaf node
in T (u), and our HST initialization algorithm picks a leaf of T (w). If u = w, then HST chooses the
optimal one where the argument holds trivially. Thus, we consider u 6= w. We have the following
two observations:
•	Since one needs to pick a leaf of T(u) to minimize cost1T 0(v, U), we have cost1T0(v, U) ≥
Px∈ch(v) x=u Nx ∙ 2hx where Ch(U) denotes the children nodes of u.
•	By our greedy strategy, CostT(v,U) ≤ Px∈ch(u) Nx ∙ 2hx ≤ CostT0(v,U) + Nu ∙ 2hu.
Since hu = hw , we have
2hu ∙ (Nu - Nw) ≤ 0,
since our algorithm picks subtree roots with highest scores. Then we have Cost1T(v, U) ≤
CostT0(v, U) + Nw ∙ 2hw ≤ 2costT0(v, U). Since the subtrees in Ci are disjoint, the union of
centers for OPT1T(v, U), v ∈ C1 forms the optimal centers with size k. Note that, for any data
point p ∈ U \ Ci, the tree distance ρT (p, f) for ∀f that is a leaf node of T (v), v ∈ Ci is the same.
That is, the choice of leaf in T (v) as the center does not affect the k-median cost under 2-HST
metric. Therefore, union bound over k subtree costs completes the proof.	□
C.3 Proof of Proposition 3.1
Proof. It is known that the 2-HST can be constructed in O(dn log n) (Bartal, 1996). The subtree
search in Algorithm 2 involves at most sorting all the nodes in the HST based on the score, which
takes O(nlogn). We use a priority queue to store the nodes in Ci. When we insert a new node v
into queue, its parent node (if existing in the queue) would be removed from the queue. The number
of nodes is O(n) and each operation (insertion, deletion) in a priority queue based on score has
O(log n) complexity. Lastly, the total time to obtain C0 is O(n), as the FIND-LEAF only requires
a top down scan in k disjoint subtrees of T. Summing parts together proves the claim.	□
(8)
(9)
(10)
C.4 Proof of Theorem 4.2
Similarly, we prove the error in general metric by first analyzing the error in 2-HST metric. Then the
result follows from Lemma 3.2. Let CostkT (D), CostkT0 (D) and OP TkT (D) be defined analogously
to (3), (4) and (5), where “y ∈ U” in the summation is changed into “y ∈ D” since D is the demand
set. That is,
CostkT (D) =	min ρT(x,y),
x∈C0
y∈D
CostkT 0(D, Ci) =	min	min ρT (x, y),
k '	)	|F∩T(v)∣ = 1,∀v∈Cι 乙 x∈F	,
y∈D
OP TkT (D) = F DmiFn k X m∈iFn ρT (x, y) ≡ mCi0n CostkT 0(D, Ci0)
⊂ ,| |= y∈D x∈	1
We have the following.
Lemma C.2. CostkT (D) ≤ 10OP TkT (D) + 10Ck-i 4 log n with probability 1 - 4k/nc.
16
Under review as a conference paper at ICLR 2022
Proof. The result follows by combining the following Lemma C.4, Lemma C.5, and applying union
bound.	□
Lemma C.3. For any node v in T, with probability 1 一 1/nc, |Nv ∙ 2hv — Nv ∙ 2hv | ≤c-14 log n.
Proof. Since Nv = Nv + Lap(2(L-hv)/2/(), we have
Pr[∣Nv — Nv | ≥ x/(] = exp(-x/2(L-hv)).
As L = log 4, we have
Pr[∣Nv — Nv | ≥ X4/(2hv e)] ≤ exp(-x).
Hence, for some constant c > 0,
Pr[∣Nv ∙ 2hν - Nv ∙ 2hν | ≤ ce-14 log n] ≥ 1 - exp(-c log n) = 1 - 1/nc.
□
Lemma C.4 (DP Subtree Search). With probability 1 - 2k/nc, costkT 0(D) ≤ 5OP TkT (D) +
4cke-14 log n.
Proof. The proof is similar to that of Lemma 3.3. Consider the intermediate output of Algorithm 2,
C1 = {v1, v2, ..., vk}, which is the set of roots of the minimal disjoint subtrees each containing
exactly one output center C°. Suppose one of the optimal “root set" that minimizes (4) is C； =
{v1, v2,…,Vk }. Assume C1 = C；. By the same argument as the proof of Lemma 3.3, We consider
for some i, j such that vi 6= vj0, where vi is not a descendent of vj0 and vj0 is either a descendent
of vi. By the construction of C1, We knoW that score(vj0 ) ≤ min{score(vi), i = 1, ..., k} When
vj0 ∈ C1； \ C1. Consider the sWap betWeen C1 and C1；. By the definition of tree distance, We have
OPTT(U) ≥ Pva∈ci\c* Nvi2hvi, since {T(vi), Vi ∈ Ci \ C； } does not contain any center of the
optimal solution determined by C1； (Which is also the optimal “root set” for OP TkT). Let us consider
the optimal clustering With center set be C； = {c；1, c2；, ..., c；k} (each center cj； is a leaf of subtree
Whose root be c0j), and Sj0 be the leaves assigned to cj；. Let Sj denote the set of leaves in Sj0 Whose
distance to cj； is strictly smaller than its distance to any centers in C1. Let Pj denote the union of
paths betWeen leaves of Sj to its closest center in C1 . Let Vj00 be the nodes in Pj With highest level
satisfying T(νj0) ∩ Ci = 0. The score of Vj is 2hvj0 N(Vj) That means the swap with a center Vj
into Ci can only reduce 4 ∙ 2hv00 N(Vj) to CoStT0(U) (the tree distance between any leaf in Sj and
its closest center in Ci is at most 4 ∙ 2hvj0). We just use Vj to represent Vj for later part of this proof
for simplicity. Summing all the swaps over Ci； \ Ci, we obtain
costkT0(U) - OPTkT(U) ≤ 4 X	Nvj0 2hvj0,
vj ∈C'V∖Cι
OPTkT(U) ≥	X	Nvi2hvi .
vi∈Cι∖C1
Applying union bound with Lemma C.3, with probability 1 - 2/nc, we have
Nv0 2hvj0 - Nvi2hvi ≤ 2ce-i4logn.
Consequently, we have with probability, 1 - 2k/nc,
costkT 0(D) ≤ 5OP TkT (D) + 4c|Ci \Ci；|e-i4logn
≤ 5OP TkT (D) + 4cke-i4 log n.
□
Lemma C.5 (DP Leaf Search). With probability 1 - 2k/nc, Algorithm 4 produces initial centers
with costkT (D) ≤ 2costkT 0(D) + 2cke-i4 log n.
17
Under review as a conference paper at ICLR 2022
Proof. The proof strategy follows Lemma 3.4. We first consider one subtree with root v. Let
cost1T 0(v, U) denote the optimal k-median cost within the point set T(v) with one center in 2-HST:
cost1T 0(v, D) = min X	ρT (x, y).	(11)
x∈T (v)
y∈T (v)∩D
Suppose v has more than one children u, w, ..., and the optimal solution of cost1T 0 (v, U) chooses a
leaf node in T (u), and our HST initialization algorithm picks a leaf of T (w). If u = w, then HST
chooses the optimal one where the argument holds trivially. Thus, we consider u 6= w. We have the
following two observations:
•	Since one needs to pick a leaf of T(u) to minimize cost1T 0(v, U), we have cost1T0(v, U) ≥
Pχ∈ch(v) x=u Nx ∙ 2hx where Ch(U) denotes the children nodes of u.
•	By our greedy strategy, CoStT(v, U) ≤ Px∈ch(u) Nx ∙ 2hx ≤ costT0(v, U) + Nu ∙ 2hu.
As hu = hw , leveraging Lemma C.3, with probability 1 - 2/nc,
2hu ∙(Nu - Nw) ≤ 2hu (Nu - Nw) + 2ce-14 log n
≤ 2C-14 log n.
since our algorithm picks subtree roots with highest scores. Then we have CoSt1T (v, D) ≤
CoStT0(v, D) + NW ∙ 2hu + 2ce-14 log n ≤ 2costT0(v, D) + 2ce-14 log n with high probabil-
ity. Lastly, applying union bound over the disjoint k subtrees gives the desired result.	□
C.5 Proof of Theorem 4.3
Proof. The privacy analysis is straightforward, by using the composition theorem (Theorem C.1).
Since the sensitivity of cost(∙) is 4, in each SWaP iteration the privacy budget is e∕2(T + 1). Also,
we spend another e/2(T + 1) privacy for picking a output. Hence, the total privacy is e/2 for local
search. Algorithm 4 takes e/2 DP budget for initialization, so the total privacy is e.
The analysis of the approximation error follows from Gupta et al. (2010), where the initial cost is
reduced by our private HST method. We need the following two lemmas.
Lemma C.6 (Gupta et al. (2010)). Assume the solution to the optimal utility is unique. For any
output o ∈ O of 24e-DP exponential mechanism on dataset D, it holds for ∀t > 0 that
P r[q(D, o) ≤ max q(D, o) - (ln |O| + t)/e] ≤ e-t,
o∈O
where |O| is the size of the output set.
Lemma C.7 (Arya et al. (2004)). For any set F ⊆ D with |F | = k, there exists some swap (x, y)
such that the local search method admits
CoStk(F, D)- CoStk (F -{x} + {y}, D) ≥ CoStk (FD - 5。PT(D).
k
From Lemma C.7, we know that when CoStk(Fi, D) > 6OPT(D), there exists a swap (x, y) s.t.
CoStk(Fi -{χ} + {y},D) ≤ (1 - 6k)CoStk(Fi, D).
At each iteration, there are at most n2 possible outputs (i.e., possible swaps), i.e., |。| = n2. Using
Lemma C.6 with t = 2 log n, for ∀i,
pr[CoStk (Fi+ι, D) ≥ CoStk (F+i, D)+4 -e- ] ≥ 1 - 1∕n2,
where CoStk(F+ι, D) is the minimum cost among iteration 1,2,…，t + 1. Hence, we have that as
long as CoSt(Fi, D) > 6OPT(D) + 24"gn, the improvement in cost is at least by a factor of
18
Under review as a conference paper at ICLR 2022
(1 一 6ik). By Theorem 4.2, We have Costk (Fι, D) ≤ C (log n)(6OPT (D) + 6k4 log n/e) for some
constant C > 0. Let T = 6Ck log log n. We have that
E[cost(Fi, D)] ≤ (6OP T (D) + 6ke-14 log n)C(log n)(1 一 1/6k)6Ck log log n
24k log n
≤ 6OPT(D) + 6ke-14 log n ≤ 6OPT(D) + —.
Therefore, With probability at least (1 一 T/n2), there exists an i <= T s.t. cost(Fi, D) ≤
6OPT(D) + 24k[og n. Then by using the Lemma C.7, one will pick an Fj with additional additive
error 4 ln n/e0 to the min{cost(Fj, D), j = 1, 2, ..., T} With probability 1 一 1/n2. Consequently,
we know that the expected additive error is
24k4 log n/e0 + 4 log n/e0 = O(e-1k24(log log n) log n),
with probability 1 一 1/poly(n).
□
D EXTEND HST INITIALIZATION TO k-MEANS
Naturally, our HST method can also be applied to k-means clustering problem. In this section, we
extend the HST to k-means and provide some brief analysis similar to k-median. We present the
analysis in the non-private case, which can then be easily adapted to the private case. Define the
following costs for k-means.
costkTm(U) =	xm∈iCn0 ρT (x, y)2
y∈U	0
costkTm0(U, C1) = min	min ρT (x, y)2,
km	|F∩T(v)∣ = 1,∀v∈Cι	x∈F
y∈U
OPTkm(U )=F ⊂min∣=kX min ρT (x, y)2 ≡ min costkTm0(U,C10).
⊂ ,| |= y∈Ux	1
(12)
(13)
(14)
For simplicity, we will use costkTm0(U) to denote costkTm0(U, C1) if everything is clear from context.
Here, OP TkTm (14) is the cost of the global optimal solution with 2-HST metric.
Lemma D.1 (Subtree search). costkTm0(U) ≤ 17OP TkTm(U).
Proof. The analysis is similar with the proof of Lemma 3.3. Thus, we mainly highlight the differ-
ence. Let us just use some notations the same as in Lemma 3.3 here. Let us consider the clustering
with center set be C * = {冷脸…,Ck } (each center Cj is a leaf of subtree whose root be cj), and
Sj be the leaves assigned to Cj in optimal k-means clustering in tree metric. Let Sj denote the set
of leaves in Sj0 whose distance to Cj* is strictly smaller than its distance to any centers in C1 . Let Pj
denote the union of paths between leaves of Sj to its closest center in C1 . Let vj00 be the nodes in
Pj with highest level satisfying T(Vj0) ∩ C1 = 0. The score of Vj is 2hvj0 N(Vj). That means the
swap with a center vj into Ci can only reduce (4 ∙ 2 vj0 )2N(Vj) to CostTm0(U). WejUSt use Vj to
represent Vj00 for later part of this proof for simplicity. By our reasoning, summing all the swaps over
C1j \ C1 gives
CostTm (U)-OPTkm(U) ≤ X	Nvj ∙ (4 ∙ 2hvj)2,
Vj ∈C1∖Cι
OPTkTm(U) ≥	X	Nvi(2hvi )2.
Vi∈Cι∖C1
Also, based on our discussion on Case 1, it holds that
Nv0 2hv0j - Nvi 2hvi ≤ 0.
Summing them together, we have CostTm (U) ≤ 17OPTkm(U).	口
19
Under review as a conference paper at ICLR 2022
Next, we show that the greedy leaf search strategy (Algorithm 3) only leads to an extra multiplicative
error of 2.
Lemma D.2 (Leaf search). costkTm (U) ≤ 2costkTm0 (U).
Proof. Since the subtrees in C1 are disjoint, it suffices to consider one subtree with root v. With a
little abuse of notation, let cost1T0(v, U) denote the optimal k-means cost within the point set T(v)
with one center in 2-HST:
cost1T0(v, U) = min X ρT (x, y)2,	(15)
x∈T (v)
y∈T(v)
which is the optimal cost within the subtree. Suppose v has more than one children u, w, ..., other-
wise the optimal center is clear. Suppose the optimal solution of cost1T0(v, U) chooses a leaf node
in T (u), and our HST initialization algorithm picks a leaf of T (w). If u = w, then HST chooses the
optimal one where the argument holds trivially. Thus, we consider u 6= w. We have the following
two observations:
•	Since one needs to pick a leaf of T(u) to minimize cost1T 0(v, U), we have cost1T0(v, U) ≥
Pχ∈ch(v) x=u Nx ∙ (2hx )2 where ch(u) denotes the children nodes of u.
•	By our greedy strategy,costT(v,U) ≤ Px∈ch(u) Nx∙(2hx产 ≤ costT0(v,U)+Nu∙(2hu产.
Since hu = hw , we have
2hu ∙ (Nu - Nw) ≤ 0,
since our algorithm picks subtree roots with highest scores. Then we have cost1T(v, U) ≤
CostT0(v, U) + Nw ∙ (2hw )2 ≤ 2costT0(v, U). Since the subtrees in C1 are disjoint, the union
of centers for OP T1T (v, U), v ∈ C1 forms the optimal centers with size k. Note that, for any data
point p ∈ U \ C1, the tree distance ρT (p, f) for ∀f that is a leaf node of T (v), v ∈ C1 is the same.
That is, the choice of leaf in T (v) as the center does not affect the k-median cost under 2-HST
metric. Therefore, union bound over k subtree costs completes the proof.	□
We are ready to state the error bound for our proposed HST initialization (Algorithm 2), which is a
natural combination of Lemma D.1 and Lemma D.2.
Theorem D.3 (HST initialization). costkTm (U) ≤ 34OP TkTm (U).
We have the following result based on Lemma 3.2.
Theorem D.4. In a general metric space,
E [costkm (U)] = O(min{log n, log 4})2OP Tkm(U).
20