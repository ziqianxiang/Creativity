Under review as a conference paper at ICLR 2022
Stochastic Projective Splitting:
Solving Saddle-Point Problems with Multiple
Regularizers
Anonymous authors
Paper under double-blind review
Ab stract
We present a new, stochastic variant of the projective splitting (PS) family of
algorithms for monotone inclusion problems. It can solve min-max and noncoop-
erative game formulations arising in applications such as robust ML without the
convergence issues associated with gradient descent-ascent, the current de facto
standard approach in ML applications. Our proposal is the first version of PS able
to use stochastic gradient oracles. It can solve min-max games while handling
multiple constraints and nonsmooth regularizers via projection and proximal op-
erators. Unlike other stochastic splitting methods that can solve such problems,
our method does not rely on a product-space reformulation of the original problem.
We prove almost-sure convergence of the iterates to the solution and a convergence
rate for the expected residual. By working with monotone inclusions rather than
variational inequalities, our analysis avoids the drawbacks of measuring conver-
gence through the restricted gap function. We close with numerical experiments on
a distributionally robust sparse logistic regression problem.
1	Introduction
The most prominent application of optimization in ML is empirical risk minimization. However,
inspired by the success of GANs (Goodfellow et al., 2014). , ML practitioners have developed more
complicated min-max and adversarial optimization formulations (Yu et al., 2021; Kuhn et al., 2019;
Shafieezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin et al., 2020; Namkoong & Duchi, 2016;
Huang et al., 2017; Wadsworth et al., 2018; Zhang et al., 2018; Edwards & Storkey, 2015; Celis
& Keswani, 2019). Solving these multi-player games leads to issues not seen when minimizing a
single-player loss function. The competitive nature of a game leads to rotational dynamics that can
cause intuitive gradient-based methods to fail to converge (Gidel et al., 2019; Daskalakis et al., 2018;
Hsieh et al., 2020).
A mathematical framework underlying both convex optimization and saddle-point problems is the
monotone inclusion problem; see Ryu & Boyd (2016) for an introduction. Methods developed
for monotone inclusions will converge for convex-concave, games as they are explicitly designed
to handle such problems’ governing dynamics. In recent years, monotone inclusion methods and
theory have started to receive attention in the ML community (Diakonikolas, 2020; Liu et al., 2021;
Ryu et al., 2020; Pathak & Wainwright, 2020), with a focus on monotone variational inequalities,
which form a special case of monotone inclusions (Antonakopoulos et al., 2019; Gidel et al., 2019;
Daskalakis et al., 2018; Hsieh et al., 2020; Mertikopoulos et al., 2019).
The most prevalent methods for solving min-max games inML are variants of gradient descent-ascent
(GDA). This method alternates between a gradient-descent step for the minimizing player and a
gradient-ascent step for the maximizing player. Unfortunately, GDA requires additional assumptions
to converge on convex-concave games, and it even fails for some simple 2D bilinear games (Gidel
et al., 2019, Prop. 1). While there have been several approaches to modify either GDA (Chavdarova
et al., 2021; Grnarova et al., 2021; Balduzzi et al., 2018) or the underlying game objective (Mescheder
et al., 2018; Nagarajan & Kolter, 2017; Mescheder et al., 2017) to ensure convergence, this paper
instead develops a method for solving monotone inclusions that can naturally handle game dynamics.
1
Under review as a conference paper at ICLR 2022
Our approach builds upon the recently proposed projective splitting (PS) method with forward
steps (Johnstone & Eckstein, 2020b). PS is designed specifically for solving monotone inclusions,
thus does not fall prey to the convergence issues that plague GDA, at least for convex-concave games.
PS is within the general class of projective splitting methods invented by Eckstein & Svaiter (2008)
and developed further in Eckstein & Svaiter (2009); Alotaibi et al. (2014); Combettes & Eckstein
(2018); Eckstein (2017); Johnstone & Eckstein (2019; 2021; 2020a). These methods work by creating
a separating hyperplane between the current iterate and the solution and then moving closer to the
solution by projecting the current iterate onto this hyperplane (see Section 3 for an overview). Other
than being able to natively handle game dynamics, the primary advantage of PS is that it fully splits
problems involving an arbitrary number of regularizers and constraints. “Full splitting” means that the
method can handle multiple regularizers and constraints through their respective individual proximal
and projection operators, along with the smooth terms via gradients. What makes this useful is that
many of the regularizers used in ML have proximal operators that are relatively easy to compute; see
for example Parikh & Boyd (2013).
Despite these advantages, the preexisting PS framework has a significant drawback: it requires
deterministic gradient oracles. This feature makes it impractical for application to large datasets for
which stochastic oracles may be the only feasible option.
Contributions The primary contribution of this work is a new projective splitting algorithm that
allows for a stochastic gradient oracle. We call the method stochastic projective splitting (SPS). Our
method “fully splits” the monotone inclusion problem
Find z ∈ Rd s.t. 0 ∈ Pin=1 Ai(z) + B(z),	(1)
where B is monotone and L-Lipschitz and each Ai is maximal monotone and typically set valued,
usually arising from a constraint or a nonsmooth regularizer in the underlying optimization problem
or game; see for example Ryu & Boyd (2016) for definitions. For some example ML applications
of (1), see Section 2 and Appendix A. Here, an algorithm that “fully splits” (1) means one whose
computational steps each involve only the individual operators A1, . . . , An, B. Ours is the first
method that can accomplish full splitting without a product-space reformulation that recasts (1) as a
two-operator problem on a higher-dimensional space, a tactic whose disadvantages are discussed in
Appendix F.7. Our method interrogates the Lipschitz operator B through a stochastic oracle. Previous
methods splitting (1) have either required a deterministic oracle for B, or have made far more
restrictive assumptions on the noise or the operators (Briceno-Arias & Combettes, 2011; Combettes &
Pesquet, 2012; Malitsky & Tam, 2020; Bot et al., 2019; Van Dung & Vu, 2021) than we will require
below. However, the stochastic methods of Alacaoglu et al. (2021) and Bohm et al. (2020), when
combined with a product-space reformulation, can solve (1) when all the Ai are subdifferentials of
convex functions; see Section 6.
When moving away from a deterministic gradient oracle in projective splitting, a key difficulty is that
the generated hyperplanes do not guarantee separation between the solution and the current point. We
solve this issue by relaxing the projection: we only update each iterate in the direction of the noisy
projection and scale its movement by a decreasing stepsize that allows for control of the stochastic
error. Using the framework of stochastic quasi-Fejer monotonicity (Combettes & Pesquet, 2015),
we prove almost-sure convergence of the final iterate and do not require averaging of the iterates
(Theorem 1, Section 5). We also provide a non-asymptotic convergence rate for the approximation
residual (Theorem 2, Section 5).
A special case of SPS is the recently-developed Double Stepsize Extragradient Method (DSEG) (Hsieh
et al., 2020). When n = 0 and therefore only B is present in (1), DSEG and SPS coincide. Thus, our
method extends DSEG to allow for regularizers and constraints. Our analysis also provides a new
interpretation for DSEG as a special case of projective splitting. Our nonasymptotic convergence rate
for SPS also applies to DSEG under no additional assumptions. By contrast, the original convergence
rate analysis for DSEG requires either strong monotonicity or an error bound.
We close with numerical experiments on a distributionally robust sparse logistic regression problem.
This is a nonsmooth convex-concave min-max problem which can be converted to (1) with n = 2
set-valued operators. On this problems class, SPS compares well to the possible alternative splitting
methods.
2
Under review as a conference paper at ICLR 2022
Non-monotone problems The work of Hsieh et al. (2020) included a local convergence analysis
for DSEG applied to locally monotone problems. For min-max problems, if the objective is locally
convex-concave at a solution and DSEG is initialized in close proximity, then for small enough
stepsizes it converges to the solution with high probability. It is possible to extend this result to SPS,
along with our convergence rate analysis. This result is beyond the scope of this work, but Appendix
J provides a proof sketch.
2	Background on Monotone Inclusions
Since they are so important to SPS, this section provides some background material regarding mono-
tone inclusions, along with their connections to convex optimization, games, and ML. Appendix G
discusses their connections to variational inequalities. For a more thorough treatment, we refer
to Bauschke & Combettes (2017). See Appendix A for a longer discussion of the applications of
monotone inclusions to ML along with several examples.
Fundamentals Let f : Rd → R ∪ {∞} be closed, convex, and proper (CCP). Recall that its
subdifferential ∂f is given by ∂f (x) =. {g : f(y) ≥ f(x) + g> (y - x)}. The map ∂f has the
property
u ∈ ∂f(x),v ∈ ∂f (y) =⇒ (u - v)>(x - y) ≥ 0,
and any point-to-set map having this property is called a monotone operator. A monotone operator
T is called maximal if no additional points can be included in the image T (x) of any x ∈ Rd
without violating the above property (Bauschke & Combettes, 2017, Def. 20.20). Subgradient maps
of CCP functions are maximal (Bauschke & Combettes, 2017, Thm. 20.25). A minimizer of f is
any x* such that 0 ∈ ∂f (x*). This is perhaps the simplest example of a monotone inclusion, the
problem of finding x such that 0 ∈ T (x), where T is a monotone operator. If f is smooth, then
∂f (x) = {Vf (x)} for all x, and the monotone inclusion 0 ∈ ∂f (x) is equivalent to the first-order
optimality condition 0 = Vf (x).
Under certain regularity conditions (Bauschke & Combettes, 2017, Cor. 16.5), minimizing a sum of
CCP functions f1, . . . , fn is equivalent to solving the monotone inclusion formed from the sum of
their subdifferentials:
nn
x* ∈ arg min X fi(x) u⇒ 0 ∈ X∂fi(x*).	(2)
x∈Rd i=1	i=1
As throughout this paper for all set addition operations, the summation on the right-hand side of (2)
is the Minkowski sum Pin=1 Si = {Pin=1 si | si ∈ Si ∀i ∈ 1..n}. For a convex set X, a constraint
x ∈ C for some convex set C may be imposed by setting one of the fi to be the indicator function ιC,
defined by ιC (x) = 0 for x ∈ C and ιC (x) = +∞ for x 6∈ C. Indicator functions of closed convex
sets are CCP (Bauschke & Combettes, 2017, Ex. 1.25), and the subgradient map of ιC is also referred
to as the normal cone map NC of C (Bauschke & Combettes, 2017, Def. 6.37). Multiple constraints
may be imposed by including multiple indicator functions in (2).
ML applications The form (2) can be used to model ML problems with multiple constraints and/or
nonsmooth regularizers, including sparse and overlapping group lasso (Jacob et al., 2009), sparse and
low-rank matrix estimation problems (Richard et al., 2012), and rare feature selection (Yan & Bien,
2020); see Pedregosa & Gidel (2018) for an overview.
Games Consider a two-player noncooperative game in which each player tries to selfishly minimize
its own loss, with each loss depending on the actions of both players. Typically, the goal is to find a
Nash equilibrium, in which neither player can improve its loss by changing strategy:
x* ∈ arg min F (x, y*) and y* ∈ arg min G(x*, y).	(3)
x∈Θ	y∈Ω
Assuming that the admissible strategy sets Θ ⊆ Rdx and Ω ⊆ Rdy are closed and convex and that
F and G are differentiable, then writing the first-order necessary conditions for each optimization
problem in (3) yields
0 ∈	VyG(X*,y*)	+ "x*)× n侬*)).	⑷
3
Under review as a conference paper at ICLR 2022
If G = -F, then (3) is a min-max game. IfF is also convex in x and concave in y, then B : (x, y) 7→
(VχF(x, y), -VyF(x, y))> is monotone1 on Rdx+dy (Rockafellar, 1970). In many applications, B
is also Lipschitz continuous. In this situation, (4) is a monotone inclusion involving two operators
B and Nθ×ω, With B being Lipschitz. Using the simultaneous version of GDA on (3) is equivalent
to applying the forward-backward method (FB) (Bauschke & Combettes, 2017, Thm. 26.14) to (4).
HoWever, convergence of FB requires that the operator B be cocoercive (Bauschke & Combettes,
2017, Def. 4.10), and not merely Lipschitz (Bauschke & Combettes, 2017, Thm. 26.14). Thus,
simultaneous GDA fails to converge for (3) Without additional assumptions; see Gidel et al. (2019,
Prop. 1) for a simple counterexample.
Regularizers and further constraints may be imposed by adding more operators to (4). For example,
if one Wished to apply a (nonsmooth) convex regularizer r : Rdx → R ∪ {+∞} to the x variables
and a similar regularizer d : Rdy → R ∪ {+∞} to the y variables, one Would add the operator
A2 : (x, y) 7→ ∂r(x) × ∂d(y) to the right-hand side of (4).
ML applications of games Distributionally robust supervised learning (DRSL) is an emerging
frameWork for improving the stability and reliability of ML models in the face of distributional
shifts (Yu et al., 2021; Kuhn et al., 2019; Shafieezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin
et al., 2020; Namkoong & Duchi, 2016). Common approaches to DRSL formulate the problem as
a min-max game betWeen a learner selecting the model parameters and an adversary selecting a
Worst-case distribution subject to some ambiguity set around the observed empirical distribution.
This min-max problem is often further reduced to either a finite-dimensional saddlepoint problem or
a convex optimization problem.
DRSL is a source of games With multiple constraints/regularizers. One such formulation, based on
Yu et al. (2021), is discussed in the experiments beloW. The Work in Namkoong & Duchi (2016) uses
an ambiguity set based on f -divergences, While Sinha et al. (2018) introduce a Lagrangian relaxation
of the Wasserstein ball. When applied to models utilizing multiple regularizers (Jacob et al., 2009;
Richard et al., 2012; Yan & Bien, 2020), both of these approaches lead to min-max problems With
multiple regularizers.
Other applications of games in ML, although typically nonconvex, include generative adversarial net-
Works (GANs) (GoodfelloW et al., 2014; Arjovsky et al., 2017; Loizou et al., 2020; 2021; Mishchenko
et al., 2020), fair classification (WadsWorth et al., 2018; Zhang et al., 2018; EdWards & Storkey, 2015;
Celis & KesWani, 2019), and adversarial privacy (Huang et al., 2017).
Resolvents, proximal operators, and projections A fundamental computational primitive for
solving monotone inclusions is the resolvent. The resolvent of a monotone operator A is defined to
be JA =. (I + A)-1, Where I is the identity operator and the inverse of any operator T is simply
T -1 : x 7→ {y : Ty 3 x}. If A is maximal monotone, then for any ρ > 0, JρA is single valued,
nonexpansive, and has domain equal to Rd (Bauschke & Combettes, 2017, Thm. 21.1 and Prop.
23.8). Resolvents generalize proximal operators of convex functions: the proximal operator of a CCP
function f is
proxρf (t) = argmin {ρf(x) + (1∕2)kx - t『}.
x∈Rd
It is easily proved that proxρf = Jρ∂f. Like proximal operators, resolvents generalize projection
onto convex sets: if f = ιC , then JρNC = proxρf = projC for any ρ > 0. In many ML applications,
proximal operators, and hence resolvents, are relatively straightforWard to compute. For examples,
see Parikh & Boyd (2013, Sec. 6).
Operator splitting methods Operator splitting methods attempt to solve monotone inclusions such
as (1) by a sequence of operations that each involve only one of the operators A1, . . . , An, B. Such
methods are often presented in the context of convex optimization problems like (2), but typically
apply more generally to monotone inclusions such as (1). In the specific context of (1), each iteration
of such a method ideally handles each Ai via its resolvent and the Lipschitz operator B by explicit
(not stochastic) evaluation. This is a feasible approach if the original problem can be decomposed in
1Sufficient conditions for the monotonicity of (4) in the case Where G 6= -F are discussed in e.g. Scutari
etal.(2014); Briceno-Arias & Combettes (2θl3).
4
Under review as a conference paper at ICLR 2022
such a way that the resolvents of each Ai are relatively inexpensive to compute, and full evaluations
of B are possible. Although not discussed here, more general formulations in which matrices couple
the arguments of the operators can broaden the applicability of operator splitting methods.
3 The Projective Splitting Framework
Before introducing our proposed method, we give a brief introduction to the projective splitting class
of methods.
The extended solution set Projective splitting is a primal-dual framework and operates in an
extended space of primal and dual variables. Rather than directly finding a solution to (1), we find a
point in the extended solution set (or Kuhn-Tucker set)
S =. (z, w1, . . . ,wn+1) wi ∈ Ai(z)∀i ∈ 1..n, wn+1 = B(z), Pin=+11 wi = 0 .	(5)
Given p* = (z^,wɪ ..., wn+ι) ∈ S, it is straightforward to see that z* solves (1). Conversely, given
a solution z* to (1), there must exist w*,..., Wn+ɪ such that (z*,w*,..., Wn+ɪ) ∈ S. Suppose
p* = (z*,w*..., Wn+ɪ) ∈ S. Since z* solves (1), z* is typically referred to as a primal solution.
The vectors w*,..., Wn+ɪ solve a dual inclusion not described here, and are therefore called a dual
solution. It can be shown that S is closed and convex; see for example Johnstone & Eckstein (2020b).
We will assume throughout that a solution to (1) exists, therefore the set S is nonempty.
Separator-projection framework Projective splitting methods are instances of the general
separator-projection algorithmic framework for locating a member of a closed convex set S within
a linear space P . Each iteration k of algorithms drawn from this framework operates by finding a
set Hk that separates the current iterate pk ∈ P from S, meaning that S is entirely in the set and
pk typically is not. One then attempts to “move closer" to S by projecting the pk onto Hk. In the
particular case of projective splitting applied to the problem (1) using (5), we select the space P to be
P=.	(z,w1,...,wn+1) ∈ R(n+2)d Pin=+11 wi =0 ,
(6)
and each separating set Hk to be the half space {p ∈ P | 夕k (P) ≤ 0} generated by an affine function
ψk : P → R. The general intention is to construct 夕k such that 夕k (pk) > 0, but 夕k(p*) ≤ 0 for all
p* ∈ S. The construction employed for Wk in the case of (1) and (5)is of the form
Wk(z,w1, . . . ,wn+1) =. Pin=+11hz - xik,yik - wii
(7)
for some points (xik, yik) ∈ R2d, i ∈ 1..(n + 1), that must be carefully chosen (see below). Any
function of the form (7) can be shown to be affine when restricted to P. As mentioned above, the
standard separator-projection algorithm obtains its next iterate pk+1 by projecting pk onto Hk. This
calculation involves the usual projection step for a half space, namely
pk+1 = pk - αkNWk,	where	αk = Wk(pk)/kNWkk2,
and the gradient NWk is computed relative to P, thus resulting in pk+1 ∈ P, i.e. NWk
(Pn+11 yk,xk - xk,∙∙∙,Xn+ι - Xk) whereXk = nɪɪ Pn+1 xk.
(8)
4 Proposed Method
The proposed method is given in Algorithm 1 and called Stochastic Projective Splitting (SPS). Unlike
prior versions of projective splitting, SPS does not employ the stepsize αk of (8) that places the next
iterate exactly on the hyperplane given by Wk (p) = 0. Instead, it simply moves in the direction -NWk
with a pre-defined stepsize {αk}. This fundamental change is required to deal with the stochastic
noise on lines 6 and 8. This noise could lead to the usual choice of αk defined in (8) being unstable
and difficult to analyze. In order to guarantee convergence, the parameters αk and ρk must be chosen
to satisfy certain conditions given below. Note that the gradient is calculated with respect to the
subspace P defined in (6); since the algorithm is initialized within P, it remains in P, within which
Wk is affine. Collectively, the updates on lines 9-10 are equivalent to pk+1 = pk - αkNWk, where
pk = (zk, w1k, . . . , wnk+1).
5
Under review as a conference paper at ICLR 2022
Note that SPS does not explicitly evaluate 夕k, which is only used in the analysis, but it does keep
track of (xik, yik) for i ∈ 1..(n + 1). The algorithm’s memory requirements scale linearly with the
number of nonsmooth operators n in the inclusion (1), with the simplest implementation storing
(3n+ 5)d working-vector elements. This requirement can be reduced to (n+ 7)d through a technique
discussed in Appendix H. In most applications, n will be small, for example 2 or 3.
Updating (xik, yik) The variables (xik, yik) are updated on lines 3-8 of Algorithm 1, in which ek
and Ek are Rd-valued random variables defined on a probability space (Ω, F, P). For B We use a
new, noisy version of the two-forward-step procedure from Johnstone & Eckstein (2020b). For each
Ai, i ∈ 1..n, we use the same resolvent step used in previous projective splitting papers, originating
with (Eckstein & Svaiter, 2008). In the case Ek = ek = 0, the selection of the (xik, yik) is identical to
that proposed by Johnstone & Eckstein (2020b), resulting in the hyperplane {p :夕k (P) = 0} strictly
separating pk from S .
SPS achieves full splitting of (1): each Ai is processed separately using a resolvent and the Lipschitz
term B is processed via a stochastic gradient oracle. When the Ai arise from regularizers or
constraints, as discussed in Section 2, their resolvents can be readily computed so long as their
respective proximal/projection operators have a convenient form.
Noise assumptions Let Fk =. σ(p* 1 , . . . , pk ) and Ek =. σ(Ek ). The stochastic estimators for the
gradients, rk and ynk+1, are assumed to be unbiased, that is, the noise terms have mean 0 conditioned
on the past:
E[Ek|Fk] = 0, E[ek|Fk] =0 a.s.	(9)
We impose the following mild assumptions on the variance of the noise:
EkEkk2 * * * * * * * *|Fk ≤N1+N2kB(zk)k2 a.s.	(10)
Ekekk2|Fk,Ek ≤ N3+N4kB(xkn+1)k2 a.s.,	(11)
where 0 ≤ N1, N2, N3, N4 < ∞. We do not require ek and Ek to be independent of one another.
Stepsize choices The stepsizes ρk and αk are assumed to be deterministic. A constant stepsize
choice which attains a non-asymptotic convergence rate will be considered in the next section
(Theorem 2). The stepsize conditions we will impose to guarantee almost-sure convergence (Theorem
1) are
P∞=1 αkPk = ∞, P∞=1 αk < ∞,	P∞=1 a®Pk < ∞, and Pk ≤ ρ < 1/L.	(12)
For example, in the case L = 1, a particular choice which satisfies these constraints is
αk = k-0.5-p for 0 < p < 0.5, and Pk = k-0.5+t for p ≤ t < 0.5p + 0.25.
For simplicity, the stepsizes τ used for the resolvent updates in lines 3-5 are fixed, but they could be
allowed to vary with both i and k so long as they have finite positive lower and upper bounds.
Algorithm 1: Stochastic Projective Splitting (SPS)
Input : p1 = (z1,w11, . . . ,wn1+1) s.t. Pin=+11 wi1 = 0, {αk,Pk}k∞=1,τ > 0
for k = 1, 2, . . . do
for i ∈ 1..n do
tik = zk + τwik
xik = JτAi (tik)
L yk = TT(tk -Xk)
rk = B(zk) + Ek	// Ek is unknown noise term
xkn+1 = zk - Pk (rk - wnk+1)
ynk+1 = B(xkn+1) + ek	// ek is unknown noise term
zk+1 = zk - αk Pin=+11 yik
_ wk+1 = Wk - ak(Xk - n⅛ pn+ι1χk) i ∈ 1..(n + 1)
1
2
3
4
5
6
7
8
9
10
6
Under review as a conference paper at ICLR 2022
5	Main Theoretical Results
Theorem 1.	Suppose A1, . . . , An are maximal monotone, B is L-Lipschitz and monotone, and a
solution to (1) exists. For Algorithm 1, suppose (9)-(12) hold. Then with probability one it holds that
Zk → z*, where z* solves (1). Further, with probability one, Xk → z* for i = 1,...,n.
Proof sketch Theorem 1 is proved in Appendix C, but we provide a brief sketch here. The proof
begins by deriving a simple recursion inspired by the analysis of SGD (Robbins & Monro, 1951).
Since pk+1 = pk - αk V^k, a step of projective splitting can be viewed as GD applied to the affine
hyperplane generator function Wk. Thus, for any p* ∈ P,
kpk+1 - p*k2 = kpk - p*k2 - 2αkhVψk ,pk - p*i + a ∣∣V°k k2
= kpk -p*k2 -2αk(Wk(pk) -Wk(p*))+α2kkVWkk2,	(13)
where in the second equation we have used that Wk (p) is affine on P. The basic strategy is to show
that, for any p* ∈ S ,
E[kVWkk2|Fk] ≤ C1kpk -p*k2+C2 a.s.
for some C1,C2 > 0. This condition allows one to establish stochastic quasi-Fej6r monotonicity
(SQFM) (Combettes & Pesquet, 2015, Proposition 2.3) of the iterates to S. One consequence of
SQFM is that with probability one there exists a subsequence vk such that Wvk (pvk) - Wvk (p*)
converges to 0. Furthermore, roughly speaking, we show that Wk(pk) - Wk(p*) provides an upper
bound on the following “approximation residual" for SPS:
Gk =. Pin=1kyik-wikk2+Pin=1kzk-xikk2+kB(zk)-wnk+1k2.	(14)
Gk provides an approximation error for SPS, as formalized in the following lemma:
Lemma 1. For SPS, pk = (zk, w1k, . . . , wnk+1) ∈ S if and only ifGk = 0.
Since yik ∈ Ai(xik) for i ∈ 1..n, having Gk = 0 implies that zk = xik, wik = yik, and thus
wik ∈ Ai(zk) for i ∈ 1..n. Since wnk+1 = B(zk) and Pin=+11 wik = 0, it follows that zk solves (1).
The reverse direction is proved in Appendix D.
The quantity Gk generalizes the role played by the norm of the gradient in algorithms for smooth
optimization. In particular, in the special case where n = 0 and B(z) = Vf (z) for some smooth
convex function f, one has Gk = kVf(zk)k2.
Combining the properties of Gk with other results following from SQFM (such as boundedness) will
allow us to derive almost-sure convergence of the iterates to a solution of (1).
Convergence rate We can also establish non-asymptotic convergence rates for the approximation
residual Gk:
Theorem 2.	Fix the total iterations K ≥ 1 of Algorithm 1 and set
∀k = 1, . . . , K : ρk = ρ =. min nK -1/4, 1/2Lo	and αk = Cfρ2	(15)
for some Cf > 0. Suppose (9)-(11) hold. Then
(1/K)PjK=1E[Gj] = O(K-1/4)
where the constants are given (along with the proof) in Appendix E.
Theorem 2 implies that if we pick an iterate J uniformly at random from 1..K, then the expected
value of GJ is O(K-1/4). As far as we know, this is the first convergence rate for a stochastic full-
splitting method solving (1) in the general discontinuous (i.e. set-valued) monotone inclusion case,
and it is not clear whether it can be improved, either by a better analysis or a better method. Faster
rates are certainly possible for deterministic methods under various continuity assumptions; Tseng’s
method obtains O(K-1) rate (Monteiro & Svaiter, 2010) and the accelerated Halpern iteration under
Lipschitz continuity obtains O(K-2) rate (Diakonikolas, 2020). While our rate may seem slow, it
is worth remembering that (1) features n discontinuous operators Ai, so we expect rates at least as
slow as nonsmooth convex optimization, but perhaps worse because (1) is far more general than
convex optimization. For a different error metric, the restricted gap function, in the special case of
variational inequalities, faster rates have been established in Juditsky et al. (2011) and Bohm et al.
(2020). However, it is unclear how to relate the restricted gap function to Gk, so these rates may not
be directly comparable to Theorem 2.
7
Under review as a conference paper at ICLR 2022
6	Related Work
Arguably the three most popular classes of operator splitting algorithms are forward-backward
splitting (FB) (Combettes & Pesquet, 2011), Douglas-Rachford splitting (DR) (Lions & Mercier,
1979), and Tseng’s method (Tseng, 2000). The extragradient method (EG) is similar to Tseng’s
method, but has more projection steps per iteration and only applies to variational inequalities
(Korpelevich, 1977; Nemirovski, 2004; Li et al., 2021). The popular Alternating Direction Method
of Multipliers (ADMM), in its standard form, is a dual application of DR (Gabay, 1983). The
three-operator splitting method (Davis & Yin, 2017) can only be applied to (1) if B is cocoercive
rather than merely Lipchitz, and thus its usefulness is mostly limited to optimization applications and
not games. FB, DR, and Tseng’s method apply to monotone inclusions involving two operators, with
varying assumptions on one of the operators. It is possible to derive splitting methods for the more
complicated inclusion (1), involving more than two operators, by applying an appropriate 2-operator
splitting method such as Tseng's method to a product-space reformulation (PSR) (BriceEo-Arias &
Combettes, 2011; Combettes & Pesquet, 2012) (for more on PSR, see Appendix F). The recently
developed forward-reflected-backward (FRB) method (Malitsky & Tam, 2020) can be used in the
same way. However, there are several disadvantages to using a PSR, as discussed in Appendix F.7.
By using a PSR, the stochastic methods of Alacaoglu et al. (2021) and Bohm et al. (2020) can be
applied to (1) in the case that each Ai is a subdifferential. Both of these methods are analyzed in terms
of the restricted gap function. This merit function has a drawback compared with our approximation
residual in that it requires one to find a bound for the iterates. However, Alacaoglu et al. (2021) and
Bohm et al. (2020) do not provide such a bound, meaning that their convergence rate results are
somewhat incomplete. We discuss this issue in Appendix G.
Theoretical convergence of the method of Bohm et al. (2020) requires the use of averaging, since
the final iterate does not converge for certain problems (Hsieh et al., 2020). Empirically, averaging
tends to be slow and to destroy regularizer-induced structural properties such as sparsity or low
matrix rank, so its utility is largely theoretical and it is usually avoided in practice. Furthermore,
averaging loses even its theoretical benefits for nonconvex problems, so its use in such cases is rarer
still. Another drawback of the analysis of Bohm et al. (2020) is that, unlike in SPS, the resolvent
(proximal) stepsizes also need to vanish.
The method of Alacaoglu et al. (2021) applies variance reduction techniques to FRB. It only applies
to finite-sum problems and requires the periodic computation of a full batch gradient, making it
somewhat less flexible and scalable than our method. On the other hand, it has an accelerated ergodic
rate for the restricted gap function in the variational inequality setting. We compare the empirical
performance of SPS with Alacaoglu et al. (2021), Bohm et al. (2020), and several deterministic
methods using PSR in the numerical experiments described in Section 7.
Additional related work is discussed in Appendix B.
7	Experiments
We now present some numerical results on distributionally robust supervised learning (DRSL)
problems. We follow the approach of Yu et al. (2021), which introduced a min-max formulation of
Wasserstein DRSL. While other approaches reduce the problem to convex optimization, Yu et al.
(2021) reduce it to a finite-dimensional min-max problem amenable to the use of stochastic methods
on large datasets. However, unlike our proposed SPS method, the variance-reduced extragradient
method that Yu et al. (2021) propose cannot handle multiple nonsmooth regularizers or constraints on
the model parameters. Consequently, we consider distributionally robust sparse logistic regression
(DRSLR), a problem class equivalent to that considered in Yu et al. (2021), but with an added `1
regularizer, a standard tool to induce sparsity. See the Appendix I for the full problem definition.
We compared our SPS method to several methods for solving DRSLR for a collection of real datasets
from the LIBSVM repository (Chang & Lin, 2011). We implemented SPS with αk = Cdk-0.51 and
ρk = Cdk-0.25 and called it SPS-decay. We also implement SPS with the fixed stepsize given in (15)
and called it SPS-fixed. We compared the method to deterministic projective splitting (Johnstone &
Eckstein, 2020b) and the following methods based on PSR: Tseng’s method (Tseng, 2000; Combettes
& Pesquet, 2012), the forward-reflected-backward (FRB) method (Malitsky & Tam, 2020), the
8
Under review as a conference paper at ICLR 2022
Figure 1: Approximation residual versus running time for three LIBSVM benchmark datasets,
with the markers at 10-iteration intervals. Left: epsilon, middle: SUSY, right: real-sim. For the
stochastic algorithms (SPS, S-Tseng, and FRB-VR), we plot the median results over 10 trials, with
unit standard deviation horizontal error bars for the running time and the vertical error bars displaying
the min-to-max range of the approximation residual. The code is provided in the supplementary
material.
stochastic Tseng (S-Tseng) method of Bohm et al. (2020), and the variance-reduced stochastic FRB
method (Alacaoglu et al., 2021), abbreviated FRB-VR. The S-Tseng and FRB-VR algorithms appear
to be the only stochastic splitting methods other than SPS applicable to the tested problem class.
Figure 1 show results for three LIBSVM standard datasets: epsilon2 (m = 4 ∙ 105, d = 2000),
SUSY (Baldi et al., 2014; Dua & Graff, 2017) (m = 2 ∙ 106, d = 18), and real-sim3 (m = 72,309,
d= 20,958).
To measure the progress of the algorithms, we used the “approximation residual” Rk defined in
Appendix F. As with Gk, having Rk = 0 implies that zk solves (1). We use Rk instead of Gk
because it is also possible to compute essentially the same measure of convergence from the iterates
of the other tested algorithms, establishing a fair comparison. Appendix F provides the details of the
derivation of the residual measure for each algorithm, explores the relationship between Rk and Gk,
and provides additional implementation details.
Figure 1 plots the approximation residual versus running time for all seven algorithms under consid-
eration. The computations were performed using Python 3.8.3 and numpy on a 2019 MacBook Pro
with a 2.4GHz 8-core Intel I9 processor and 32GB of RAM . Being a stochastic method, SPS-decay
seems to outperform the deterministic methods at obtaining a medium-accuracy solution quickly. It
also seems to outperform the stochastic PSR-based methods S-Tseng and FRB-VR.
8	Conclusions and Future Work
We have developed and analyzed a stochastic splitting method that can handle min-max problems
with multiple regularizers and constraints. Going forward, this development should make it possible
to incorporate regularizers and constraints into adversarial formulations trained from large datasets.
Recent versions of deterministic projective splitting (Combettes & Eckstein, 2018; Johnstone &
Eckstein, 2020b) allow for asynchronous and incremental operation, meaning that not all operators
need to be activated at every iteration, with some calculations proceeding with stale inputs. Such
characteristics make projective splitting well-suited to distributed implementations. Many of our SPS
results may be extended to allow for these variations, but we leave those extensions to future work.
References
Ahmet Alacaoglu, Yura Malitsky, and Volkan Cevher. Forward-reflected-backward method with
variance reduction. Computational Optimization and Applications, 2021. Available online.
2 Original data source http://largescale.ml.tu- berlin.de/instructions/
3 Original data source https://people.cs.umass.edu/~mccallum/data.html
9
Under review as a conference paper at ICLR 2022
Abdullah Alotaibi, Patrick L Combettes, and Naseer Shahzad. Solving coupled composite mono-
tone inclusions by successive Fejer approximations of their KUhn-TUcker Set SIAM Journal on
Optimization, 24(4):2076-2095, 2014.
Kimon Antonakopoulos, Veronica Belmega, and Panayotis Mertikopoulos. An adaptive mirror-
prox method for variational inequalities with singular operators. In H. Wallach, H. Larochelle,
A. Beygelzimer, F. d'Alche-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information
Processing Systems, volume 32. Curran Associates, 2019.
Martin Arjovsky, Soumith Chintala, and Leon Bottou. Wasserstein generative adversarial networks.
In Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on
Machine Learning, volume 70 of Proceedings of Machine Learning Research, pp. 214-223, 06-11
Aug 2017.
Pierre Baldi, Peter Sadowski, and Daniel Whiteson. Searching for exotic particles in high-energy
physics with deep learning. Nature communications, 5(1):1-9, 2014.
David Balduzzi, Sebastien Racaniere, James Martens, Jakob Foerster, Karl Tuyls, and Thore Graepel.
The mechanics of n-player differentiable games. In Jennifer Dy and Andreas Krause (eds.),
Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings
of Machine Learning Research, pp. 354-363. PMLR, 10-15 Jul 2018.
Heinz H Bauschke and Patrick L Combettes. Convex analysis and monotone operator theory in
Hilbert spaces. Springer, 2nd edition, 2017.
Axel Bohm, Michael Sedlmayer, Erno Robert Csetnek, and Radu Ioan BoJ Two steps at a time 一
taking GAN training in stride with Tseng’s method. arXiv preprint arXiv:2006.09033, 2020.
Radu Ioan Bot, Panayotis Mertikopoulos, Mathias Staudigl, and Phan Tu Vuong. Forward-backward-
forward methods with variance reduction for stochastic variational inequalities. arXiv preprint
arXiv:1902.03355, 2019.
Luis M Briceno-Arias and Patrick L Combettes. A monotone+skew splitting model for composite
monotone inclusions in duality. SIAM Journal on Optimization, 21(4):1230-1250, 2011.
Luis M Briceno-Arias and Patrick L Combettes. Monotone operator methods for Nash equilibria
in non-potential games. In Computational and Analytical Mathematics, volume 50 of Springer
Proceedings in Mathematics and Statistics, pp. 143-159. Springer, 2013.
L Elisa Celis and Vijay Keswani. Improved adversarial learning for fair classification. arXiv preprint
arXiv:1901.10443, 2019.
Chih-Chung Chang and Chih-Jen Lin. LIBSVM: A library for support vector machines. ACM
Transactions on Intelligent Systems and Technology, 2:27:1-27:27, 2011. Software available at
http://www.csie.ntu.edu.tw/~cjlin/libsvm.
Tatjana Chavdarova, Matteo Pagliardini, Sebastian U Stich, FrangOiS Fleuret, and Martin Jaggi.
Taming GANs with lookahead-minmax. In International Conference on Learning Representations,
2021. URL https://openreview.net/forum?id=ZW0yXJyNmoG.
Patrick L. Combettes and Jonathan Eckstein. Asynchronous block-iterative primal-dual decomposition
methods for monotone inclusions. Mathematical Programming, 168(1-2):645-672, 2018.
Patrick L Combettes and Jean-Christophe Pesquet. Proximal splitting methods in signal processing.
In H.H. Bauschke, R.S.S. Burachik, P.L. Combettes, V. Elser, D.R. Luke, and H. Wolkowicz (eds.),
Fixed-Point Algorithms for Inverse Problems in Science and Engineering, pp. 185-212. Springer,
2011.
Patrick L Combettes and Jean-Christophe Pesquet. Primal-dual splitting algorithm for solving
inclusions with mixtures of composite, Lipschitzian, and parallel-sum type monotone operators.
Set-Valued and variational analysis, 20(2):307-330, 2012.
Patrick L Combettes and Jean-Christophe Pesquet. Stochastic quasi-Fejer block-coordinate fixed
point iterations with random sweeping. SIAM Journal on Optimization, 25(2):1221-1248, 2015.
10
Under review as a conference paper at ICLR 2022
Constantinos Daskalakis, Andrew Ilyas, Vasilis Syrgkanis, and Haoyang Zeng. Training GANs
with optimism. In International Conference on Learning Representations, 2018. URL https:
//openreview.net/forum?id=SJJySbbAZ.
Damek Davis and Wotao Yin. A three-operator splitting scheme and its optimization applications.
Set-Valued and Variational Analysis, 25(4):829-858, 2017.
Jelena Diakonikolas. Halpern iteration for near-optimal and parameter-free monotone inclusion and
strong solutions to variational inequalities. In Conference on Learning Theory, pp. 1428-1451.
PMLR, 2020.
Dheeru Dua and Casey Graff. UCI machine learning repository, 2017. URL http://archive.
ics.uci.edu/ml.
Jonathan Eckstein. A simplified form of block-iterative operator splitting and an asynchronous
algorithm resembling the multi-block alternating direction method of multipliers. Journal of
Optimization Theory and Applications, 173(1):155-182, 2017.
Jonathan Eckstein and Benar Fux Svaiter. A family of projective splitting methods for the sum of
two maximal monotone operators. Mathematical Programming, 111(1):173-199, 2008.
Jonathan Eckstein and Benar Fux Svaiter. General projective splitting methods for sums of maximal
monotone operators. SIAM Journal on Control and Optimization, 48(2):787-811, 2009.
Harrison Edwards and Amos Storkey. Censoring representations with an adversary. arXiv preprint
arXiv:1511.05897, 2015.
Daniel Gabay. Applications of the method of multipliers to variational inequalities. In M. Fortin and
R. Glowinski (eds.), Augmented Lagrangian Methods: Applications to the Solution of Boundary
Value Problems, chapter IX, pp. 299-340. North-Holland, Amsterdam, 1983.
Gauthier GideL Hugo Berard, Gaetan Vignoud, Pascal Vincent, and Simon Lacoste-JUlien. A
variational inequality perspective on generative adversarial networks. In International Confer-
ence on Learning Representations, 2019. URL https://openreview.net/forum?id=
r1laEnA5Ym.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Z. Ghahramani, M. Welling,
C. Cortes, N. Lawrence, and K. Q. Weinberger (eds.), Advances in Neural Information Processing
Systems, volume 27. Curran Associates, 2014.
Paulina Grnarova, Yannic Kilcher, Kfir Y Levy, Aurelien Lucchi, and Thomas Hofmann. Generative
minimization networks: Training GANs without competition. arXiv preprint arXiv:2103.12685,
2021.
Patrick T Harker and Jong-Shi Pang. Finite-dimensional variational inequality and nonlinear comple-
mentarity problems: a survey of theory, algorithms and applications. Mathematical programming,
48(1):161-220, 1990.
Yu-Guan Hsieh, Franck Iutzeler, J6r6me Malick, and Panayotis Mertikopoulos. On the convergence
of single-call stochastic extra-gradient methods. In H. Wallach, H. Larochelle, A. Beygelzimer,
F. d'Alche-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information Processing Systems,
volume 32. Curran Associates, 2019.
Yu-Guan Hsieh, Franck Iutzeler, J6r6me Malick, and Panayotis Mertikopoulos. Explore aggres-
sively, update conservatively: Stochastic extragradient methods with variable stepsize scaling.
In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Advances in Neural
Information Processing Systems, volume 33, pp. 16223-16234. Curran Associates, 2020.
Chong Huang, Peter Kairouz, Xiao Chen, Lalitha Sankar, and Ram Rajagopal. Context-aware
generative adversarial privacy. Entropy, 19(12):656, 2017.
11
Under review as a conference paper at ICLR 2022
Laurent Jacob, Guillaume Obozinski, and Jean-Philippe Vert. Group lasso with overlaps and graph
lasso. In Leon Bottou and Michael Littman (eds.), Proceedings ofthe 26th International Conference
on Machine Learning,pp. 433-440, Montreal, June 2009. OmniPress.
Patrick R Johnstone and Jonathan Eckstein. Convergence rates for projective splitting. SIAM Journal
on Optimization, 29(3):1931-1957, 2019.
Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps only requires
continuity. Optimization Letters, 14(1):229-247, 2020a.
Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps. Mathematical
Programming, 2020b. Published online, to appear in print.
Patrick R Johnstone and Jonathan Eckstein. Single-forward-step projective splitting: exploiting
cocoercivity. Computational Optimization and Applications, 78(1):125-166, 2021.
Anatoli Juditsky, Arkadi Nemirovski, and Claire Tauvel. Solving variational inequalities with
stochastic mirror-prox algorithm. Stochastic Systems, 1(1):17-58, 2011.
GM Korpelevich. Extragradient method for finding saddle points and other problems. Matekon, 13
(4):35-49, 1977.
Daniel Kuhn, Peyman Mohajerin Esfahani, Viet Anh Nguyen, and Soroosh Shafieezadeh-Abadeh.
Wasserstein distributionally robust optimization: Theory and applications in machine learning.
In Serguei Netessine (ed.), Operations Research & Management Science in the Age of Analytics,
Tutorials in Operations Research, pp. 130-166. INFORMS, 2019.
Chris Junchi Li, Yaodong Yu, Nicolas Loizou, Gauthier Gidel, Yi Ma, Nicolas Le Roux, and Michael I
Jordan. On the convergence of stochastic extragradient for bilinear games with restarted iteration
averaging. arXiv preprint arXiv:2107.00464, 2021.
Tianyi Lin, Chi Jin, and Michael Jordan. On gradient descent ascent for nonconvex-concave minimax
problems. In Hal Daume III and Aarti Singh (eds.), Proceedings of the 37th International
Conference on Machine Learning, volume 119 of Proceedings of Machine Learning Research, pp.
6083-6093. PMLR, 2020.
Pierre-Louis Lions and Bertrand Mercier. Splitting algorithms for the sum of two nonlinear operators.
SIAM Journal on Numerical Analysis, 16(6):964-979, 1979.
Mingrui Liu, Hassan Rafique, Qihang Lin, and Tianbao Yang. First-order convergence theory for
weakly-convex-weakly-concave min-max problems. Journal of Machine Learning Research, 22
(169):1-34, 2021.
Nicolas Loizou, Hugo Berard, Alexia Jolicoeur-Martineau, Pascal Vincent, Simon Lacoste-Julien, and
Ioannis Mitliagkas. Stochastic hamiltonian gradient methods for smooth games. In International
Conference on Machine Learning, pp. 6370-6381. PMLR, 2020.
Nicolas Loizou, Hugo Berard, Gauthier Gidel, Ioannis Mitliagkas, and Simon Lacoste-Julien. Stochas-
tic gradient descent-ascent and consensus optimization for smooth games: Convergence analysis
under expected co-coercivity. arXiv preprint arXiv:2107.00052, 2021.
Yura Malitsky and Matthew K Tam. A forward-backward splitting method for monotone inclusions
without cocoercivity. SIAM Journal on Optimization, 30(2):1451-1472, 2020.
Panayotis Mertikopoulos, Bruno Lecouat, Houssam Zenati, Chuan-Sheng Foo, Vijay Chandrasekhar,
and Georgios Piliouras. Optimistic mirror descent in saddle-point problems: Going the extra(-
gradient) mile. In International Conference on Learning Representations, 2019. URL https:
//openreview.net/pdf?id=Bkg8jjC9KQ.
Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. The numerics of GANs. In I. Guyon, U. V.
Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in
Neural Information Processing Systems, volume 30. Curran Associates, 2017.
12
Under review as a conference paper at ICLR 2022
Lars Mescheder, Andreas Geiger, and Sebastian Nowozin. Which training methods for GANs do
actually converge? In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International
Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp.
3481-3490. PMLR, 2018.
Konstantin Mishchenko, Dmitry Kovalev, Egor Shulgin, Peter Richtdrik, and Yura Malitsky. Revisit-
ing stochastic extragradient. In International Conference on Artificial Intelligence and Statistics,
pp. 4573T582. PMLR, 2020.
Aryan Mokhtari, Asuman E Ozdaglar, and Sarath Pattathil. Convergence rate of o(1/k) for optimistic
gradient and extragradient methods in smooth convex-concave saddle point problems. SIAM
Journal on Optimization, 30(4):3230-3251, 2020.
Renato DC Monteiro and Benar Fux Svaiter. On the complexity of the hybrid proximal extragradient
method for the iterates and the ergodic mean. SIAM Journal on Optimization, 20(6):2755-2787,
2010.
Vaishnavh Nagarajan and J. Zico Kolter. Gradient descent GAN optimization is locally stable. In
I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.),
Advances in Neural Information Processing Systems, volume 30. Curran Associates, 2017.
Hongseok Namkoong and John C Duchi. Stochastic gradient methods for distributionally robust
optimization with f -divergences. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett
(eds.), Advances in Neural Information Processing Systems, volume 29. Curran Associates, 2016.
Arkadi Nemirovski. Prox-method with rate of convergence O(1/t) for variational inequalities with
Lipschitz continuous monotone operators and smooth convex-concave saddle point problems.
SIAM Journal on Optimization, 15(1):229-251, 2004.
Yurii Nesterov. Dual extrapolation and its applications to solving variational inequalities and related
problems. Mathematical Programming, 109(2):319-344, 2007.
Neal Parikh and Stephen Boyd. Proximal algorithms. Foundations and Trends in Optimization, 1(3):
123-231, 2013.
Reese Pathak and Martin J Wainwright. Fedsplit: an algorithmic framework for fast federated
optimization. In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Ad-
vances in Neural Information Processing Systems, volume 33, pp. 7057-7066. Curran Asso-
ciates, Inc., 2020. URL https://proceedings.neurips.cc/paper/2020/file/
4ebd440d99504722d80de606ea8507da-Paper.pdf.
Fabian Pedregosa and Gauthier Gidel. Adaptive three-operator splitting. In Jennifer Dy and Andreas
Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, volume 80
of Proceedings of Machine Learning Research, pp. 4085-4094. PMLR, 10-15 Jul 2018.
Fabian Pedregosa, Kilian Fatras, and Mattia Casotto. Proximal splitting meets variance reduction. In
Kamalika Chaudhuri and Masashi Sugiyama (eds.), Proceedings of the Twenty-Second Interna-
tional Conference on Artificial Intelligence and Statistics, volume 89 of Proceedings of Machine
Learning Research, pp. 1-10. PMLR, 16-18 Apr 2019.
Emile Richard, Pierre-Andre Savalle, and Nicolas Vayatis. Estimation of simultaneously sparse and
low rank matrices. In John Langford and Joelle Pineau (eds.), Proceedings of the 29th International
Conference on Machine Learning, pp. 1351-1358. Omnipress, 2012.
Herbert Robbins and Sutton Monro. A stochastic approximation method. The annals of mathematical
statistics, pp. 400-407, 1951.
R Tyrrell Rockafellar. Monotone operators associated with saddle-functions and minimax problems.
Nonlinear functional analysis, 18(part 1):397-407, 1970.
Ernest K Ryu and Stephen Boyd. Primer on monotone operator methods. Appl. Comput. Math, 15(1):
3-43, 2016.
13
Under review as a conference paper at ICLR 2022
Ernest K. Ryu, Kun Yuan, and Wotao Yin. Ode analysis of stochastic gradient methods with optimism
and anchoring for minimax problems, 2020.
Gesualdo Scutari, Francisco Facchinei, Jong-Shi Pang, and Daniel P Palomar. Real and complex
monotone communication games. IEEE Transactions on Information Theory, 60(7):4197-4231,
2014.
Soroosh Shafieezadeh-Abadeh, Peyman Mohajerin Esfahani, and Daniel Kuhn. Distributionally
robust logistic regression. In Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama,
and Roman Garnett (eds.), Advances in Neural Information Processing Systems, volume 28, pp.
1576-1584. Curran Associates, 2015.
Aman Sinha, Hongseok Namkoong, and John Duchi. Certifying some distributional robustness with
principled adversarial training. In International Conference on Learning Representations, 2018.
URL https://openreview.net/forum?id=Hk6kPgZA-.
Paul Tseng. A modified forward-backward splitting method for maximal monotone mappings. SIAM
Journal on Control and Optimization, 38(2):431-446, 2000.
Nguyen Van Dung and Bang Cong Vu. Convergence analysis of the stochastic reflected forward-
backward splitting algorithm. arXiv preprint arXiv:2102.08906, 2021.
Christina Wadsworth, Francesca Vera, and Chris Piech. Achieving fairness through adversarial
learning: an application to recidivism prediction. arXiv preprint arXiv:1807.00199, 2018.
Xiaohan Yan and Jacob Bien. Rare feature selection in high dimensions. Journal of the American
Statistical Association, 2020. Published online, to appear in print.
Yaodong Yu, Tianyi Lin, Eric Mazumdar, and Michael I Jordan. Fast distributionally robust learning
with variance reduced min-max optimization. arXiv preprint arXiv:2104.13326, 2021.
Alp Yurtsever, Bang Cong Vu, and Volkan Cevher. Stochastic three-composite convex minimization.
In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in Neural
Information Processing Systems, volume 29. Curran Associates, 2016.
Brian Hu Zhang, Blake Lemoine, and Margaret Mitchell. Mitigating unwanted biases with adversarial
learning. In Proceedings of the 2018 AAAI/ACM Conference on AI, Ethics, and Society, pp. 335-
340, 2018.
A ML Applications of the Monotone Inclusion (1)
There are two main classes of applications of (1) in ML: optimization problems and saddle-point
games.
Optimization Problems In this case the monotone inclusion arises from finding the zero of a
sum of subgradients of convex functions, as discussed in Section 2. It is typical in ML to solve the
empirical risk minimization problem
1m	n
miRd m XXXf (x)+XXX ri(x)
(16)
over a size-m dataset. Usually, the gradient of the loss function fj for each datapoint j is Lipschitz
continuous. The terms ri may be regularizers used to reduce overfitting or encourage structural
properties such as sparsity or low matrix rank. They also may represent constraints on the parameters
such as nonnegativity or the being in the probability simplex. Crucially, these regularizers are rarely
differentiable. The first-order necessary condition for the solution of (16) is
n
0 ∈ Vf(x*) + X∂ri(x*),	(17)
14
Under review as a conference paper at ICLR 2022
where f (x)二m Pjm=I fj(x), thus Vf (x)=* Pjm=I Pfj(x). The inclusion (17) is a special case
of (1), and our method may use the standard stochastic oracle for Vf (x), namely
|Bi XB Vfj (Z)
which subsamples a randomly selected minibatch of datapoints B ∈ {1, . . . , m}.
Games Consider the following nonsmooth Nash equilibrium problem
n1	n2
x* ∈ arg min F(x,y*) + ^X r%(x) and y* ∈ arg min G(x*,y) + ^X di(y).	(18)
x∈Rdx	i=1	y∈Rdy	i=1
The terms Pin=1 1ri (x) and Pin=21 di(y) once again represent regularizers and constraints on each
player’s strategy. Note that min-max (saddle-point) problems correspond to having F(x, y) =
-G(x, y). Under appropriate convexity conditions and constraint qualifications, the solutions of (18)
correspond to the solutions of the following monotone inclusion in the form of (1):
0∈
VxF(x*,y*)
VyG(x*, y*)
max{n1,n2}
+ X	(∂ri(x*) × ∂di(y*))
i=1
(19)
where for i > min{n1, n2} we include “dummy functions", either ri (x) = 0 when n1 < n2 or
di(y) = 0 when n1 < n2. If the functions F and G arise as averages in the same we as f in (16),
then our method may again use a stochastic oracle for them.
Distributionally-Robust ML One example application of (19) is distributionally-robust ML, as
demonstrated in the numerical experiment in Section 7. The full problem statement is given in
Appendix I.
Lagrangian Duality Another application of (19) is constrained optimization via Lagrangian duality.
Consider
min f(x) +	ri(x)
x∈Rd	i=1
s.t.	hj (x) ≤ 0 j = 1, . . . , p.
As in (16), f is a loss function and the ri may represent regularizers and (“simple”) constraints;
in addition, there are p functional constraints on the model parameters x. Introducing Lagrange
multipliers γ ∈ Rp , the problem can be written as
min max
x∈Rd γ∈Rp+
np
f(x) +	ri (x) +	γj hj (x)
i=1	j=1
Under appropriate convexity conditions and constraint-qualifications, this reduces to the following
inclusion in the form of (1):
0 ∈ ]Vf(x) + -¾γjVhj(Xl + X (∂r,(x*) ×{0})
i=1
where h(x) = [h1(x), h2(x), . . . , hp(x)]>. For certain choices of h, such as linear or quadratic
functions, the first term above is monotone and (locally) Lipschitz continuous (Alacaoglu et al.,
2021).
Bilinear Games with Many Constraints Finally, consider the bilinear saddlepoint problem subject
to multiple constraints:
min max x>Dy s.t. x ∈ Cj1 j = 1, . . . , n1,
x∈Rd y∈Rd
y ∈ Cj2 j = 1, . . . ,n2.
15
Under review as a conference paper at ICLR 2022
Under some regularity conditions, this problem reduces to the inclusion
- n * "I	maχ{nι,n2}
0 ∈	-D>x*	+ X	(NCI (χ*) × NCj (y*))，
j=1
where we introduce additional “dummy” sets Cj1 = Rd or Cj2 = Rd when n1 6= n2 . The first term
is linear and skew symmetric, and therefore can easily be shown to be Lipschitz continuous and
monotone. If all the constraint sets are closed and convex, then the rest of the terms are maximal
monotone, then the problem is of the form (1), meaning that projective splitting may be applied,
possibly using a stochastic oracle for the first term.
B Additional Related Work
The preprint by Bot et al. (2019) develops a stochastic version of Tseng’s method under the require-
ment that the noise variance converges to 0. In ML, this could be achieved with the use of perpetually
increasing batch sizes, a strategy that is impractical in many scenarios. The stochastic version of
FRB proposed by Van Dung & Vu (2021) has more practical noise requirements, but has stronger
assumptions on the problem which are rarely satisfied in ML applications: either uniform/strong
monotonicity or a bounded domain. The papers by Yurtsever et al. (2016) and Pedregosa et al.
(2019) consider stochastic variants of three-operator splitting, but require B in (1) to be cocoercive,
essentially restricting them to optimization problems.
There are several alternatives to the (stochastic) extragradient method that reduce the number of
gradient evaluations per iteration from two to one (Hsieh et al., 2019; Malitsky & Tam, 2020; Gidel
et al., 2019). However, these methods have more stringent stepsize limits, making it unclear a priori
whether they will outperform two-step methods.
DSEG is a stochastic version of EG (Hsieh et al., 2020). The primary innovation of DSEG is using
different stepsizes for the extrapolation and update steps, thereby resolving some of the convergence
issues affecting stochastic EG. As noted earlier, DSEG is the special case of our SPS method in which
n = 0, that is, no regularizers/constraints are present in the underlying game. The analysis in (Hsieh
et al., 2020) also did not consider the fixed stepsize choice given in Theorem 2.
In the context of GANs, several methods have been developed based on a variational inequal-
ity/monotone inclusion approach (Gidel et al., 2019; Daskalakis et al., 2018; Hsieh et al., 2019; 2020;
Bohm et al., 2020). Many of these papers point out that variational inequalities provide a principled
framework for studying the GAN training problem and correcting some of the flaws in the standard
method GDA.
C Proof of Theorem 1
C.1 Stochastic Quasi-Fejer Monotonicity
The key to the analysis is showing that the algorithm satisfies Stochastic Quasi-Fejer Monotonicity
(Combettes & Pesquet, 2015).
Lemma 2 ((Combettes & Pesquet, 2015), Proposition 2.3). Suppose pk is a sequence of Rd-valued
random variables defined on a probability space (Ω, F, P). Let Fk = σ(p1,...,pk). Let F be a
nonempty, closed subset of Rd. Suppose that, for every p ∈ F, there exists χk(p) ≥ 0, ηk (p) ≥
0, νk(p) ≥ 0 such that Pk∞=1 χk (p) < ∞, Pk∞=1 ηk(p) < ∞ and
(∀k∈N) E[kpk+1 - pk2|Fk] ≤ (1+χk(p))kpk-pk2-νk(p)+ηk(p).
Then the following hold:
1.	(∀p ∈ F) :	Pk∞=1 νk(p) < ∞ a.s.
2.	pk is bounded a.s.
3.	There exists Ω such that P [Ω] = 1 and {∣∣pk (ω) 一 Pk} converges for every ω ∈ Ω and
p ∈ F.
16
Under review as a conference paper at ICLR 2022
C.2 Important Recursion for SPS
The following lemma summarizes the key recursion satisfied by Algorithm 1, to which we will apply
Lemma 2. Recall that L is the Lipschitz constant of B .
Lemma 3. For Algorithm 1, suppose (9)一(11) hold and
Pk ≤ ρ< 1/L.	(20)
Let
nn
Tk = T X kyk - Wkk2 + h X kzk -Xkk2 + 2(1 - ρL)kB(zk) - wk+ιk2
ρ i=1	ρτ i=1
then for all p* ∈ S, with probability one
E[kpk+1 -P*k2∣Fk] ≤ (1 + Cιɑk + C3αkPk)kpk -p*∣∣2 - a®PkTk + C2αk + C4αkPk (21)
where C1 , . . . , C4 are nonegative constants defined in (33), (34), (48), and (49) below, respectively.
Note that Tk is a scaled version of the approximation residual Gk defined in (14).
We proceed to first prove Lemma 3 and then exploit the implications of Lemma 2. Referring to (10)
and (11), let N =. maxj∈1..4 Nj. To simplify the constants, we will use N in place of Nj for the
noise variance bounds given in (10)-(11).
C.3 Upper Bounding the Gradient
Throughout the analysis, We fix some p* = (z* ,w；..., Wn+1) ∈ S. All statements are with
probability one (almost surely), but for brevity we will omit this unless it needs to be emphasized.
In this section, We derive appropriate upper bounds for k▽夕k ∣∣2 to use in (13). We begin with Nz夕k:
=1
2
n2	n2
≤ 2kynk+1k2 + 2 X yik =2B(xkn+1)+ek2+2Xyik
i=1	i=1
n2
≤4kB(xkn+1)k2+2Xyik +4kekk2.
i=1
Now next take expectations with respect to Fk and Ek, and use the bound on the variance of the noise
in (11), obtaining
where we have used that yik is Fk-measurable for i ∈ 1..n. Thus, taking expectations over Ek
conditioned on Fk yields
n2
E [kVz^kk2∣Fk] ≤ 4(N +1)E[∣B(xn+ι)∣2∣Fk] + 2∣∣Xyk∣∣ +4N.	(22)
i=1
We will now bound the two terms on the right side of (22).
C.3.1 First Term in (22)
First, note that
kB(zk)k2 = kB(zk) - B(z*) + B(z*))k2
≤ 2kB(zk) - B(z*)k2 + 2kB(z*)k2
≤ 2L2kzk - z*k2 + 2kB(z*)k2
≤ 2L2kpk -p*k2 + 2kB(z*)k2.	(23)
17
Under review as a conference paper at ICLR 2022
Now, returning to the first term on the right of (22), we have
kB(xn+1)k2 = kB(zk) + B(xn+1) - B(Zk)k2
≤ 2∣∣B(zk)∣∣2 + 2∣∣B(*+J- B(Zk)II2
≤ 2∣∣B(zk)∣∣2 + 2L2∣⅛ι-zkk2
≤ 4L2∣∣pk -p*∣∣2 +4∣∣B(z*)∣∣2 + 2L2∣∣x% - zk∣∣2	(24)
where we have used (23) to obtain (24).
For the third term in (24), we have from the calculation on line 7 of the algorithm that
Xln+1 - zk = -Pk(rk - wk+1) = -Pk(B(zk) + J - wk+1),
and therefore
lM+ι-zk I2 = Pk ∣∣B(zk)+ ek - wk+ι∣∣2
≤ P2kB(zk)+ ek - wk』2
≤ 3ρ2(∣∣B(zk)∣∣2 + IIekk2 + ∣∣w3∣∣2).
We next take expectations conditioned on Fk and use the noise variance bound (10) to obtain
E[kx% - zkk2 |Fk] ≤ E[3ρ2(∣∣B(zk)∣∣2 + Ilekk2 + ∣∣w%∣∣2) |Fk]
≤ 3P2((N +1)kB(zk)∣2 + ∣∣wn+ι∣∣2 + N).
Therefore
E[∣M+1 - zkk21 Fk] ≤ 6ρ2((N + 1)kB(zk)k2 + ∣∣wk+1- w^+i∣2 + IlWn+/|2) + 3ρ2N
=6ρ2(2(N + 1)L2∣∣pk -p*∣∣2 +2(N +1)∣∣B(z*)∣∣2
+ 忖3- W"/2 + IB(z*)∣∣2) +3ρ2N
≤ 6ρ2(2(N +1)L2∣∣pk -p*∣∣2 + ∣∣wk+1 - Wn+1I2)
+ 18ρ2(N +1)∣∣B(z*)∣∣2 +3ρ2N
≤ 18P2(N +1)((L2 + 1)Mk -p*∣∣2 + ∣∣B(z*)∣∣2) +3ρ2N	(25)
where in the equality uses (23) and wn+1 = B(z*). Combining (24) and (25), we arrive at
E [∣∣B(xn+1)∣∣2∣Fk] ≤ 4L2 [1 + 9ρ2(L2 + 1)(N +1)] Mk -p*∣∣2
+ 4(1 + 9ρ2L2(N + 1)) ∣∣B(z*)∣∣2 + 6ρ2L2 N.	(26)
C.3.2 Second term in (22)
For i ∈ 1..n, line 5 of the algorithm may be rearranged into yk = T-1(zk - Xk)+ Wf, so
n2	n	2
∣∣X WI =∣∣X(TT(Zk-χk)+wk)∣∣
i=1	i=1
≤ 2 ∣∣τ-1 X(zk -Xk)『+ 2∣∣Xwk∣∣2
i=1	i=1
n	n	2
≤ 2nτ-2 X IlZk -瑞2 + 2 ∣ 区 wk∣∣
i=1	i=1
n	n	n	2
≤4n2τ-2∣∣zk -z*∣∣2 + 4nτ-2X∣∣z* -瑞2 + 4nXnW -w"∣2 + 4 ∣ ∣χw*∣∣
i=1	i=1	i=1
n	n	2
≤ 4n2(τ-2 + 1)Mk - p*∣∣2 +4nτ-2 X ∣∣z*-瑞2 +4 ∣ ∣X w*∣∣ .	(27)
i=1	i=1
18
Under review as a conference paper at ICLR 2022
By the definition of the solution set S in (5), w* ∈ Ai(z*), so z* + Twi ∈ (I + τAi)(z^), and since
the resolvent is single-valued (Bauschke & Combettes, 2017, Cor. 23.9) we therefore obtain
z* = (I+ τAi)-1(I+ τAi)(z*) = JτAi(z* + τwi*).
From lines 3 and 4 of the algorithm, we also have xik = JτAi (zk + τwik) for i ∈ 1..n. Thus, using
the nonexpansiveness of the resolvent (Bauschke & Combettes, 2017, Def. 4.1 and Cor. 23.9), we
have
nn
X kz* - xikk2 = X JτAi(zk + τwik) - JτAi(z* + τwi*)2
i=1	i=1
n
≤Xkzk+τwik-z*-τwi*k2
i=1
n
= Xkzk-z* +τ(wik-wi*)k2
i=1
n
≤ 2nkzk -z*k2+2τ2Xkwik -wi*k2
i=1
≤ 2(n + τ 2)kpk -p*k2.	(28)
Combining (27) and (28) yields
n2	n2
Xyik	≤ 12n2τ-2(n+τ2)kpk -p*k2 +4 Xwi* .	(29)
i=1	i=1
Combining (26) and (29) with (22) yields
E[kVz3kk2∣ Fk] ≤ 24 [(1 + 9ρ2)(L2 + 1)2(N + 1)2 + n2τ-2(n + τ2)] ∣∣pk - p*∣∣2
n2
+ 16(N +1)(l + 9ρ2L2(N +1))∣∣B(z*)∣∣2 +8∣X WM
i=1
+ 24ρ2L2 (N + 1)N + 4N.	(30)
C.3.3 Dual Gradient Norm
Considering that Vψk is taken with respect to the subspace P, the gradients with respect to the dual
variables are — see for example Eckstein & Svaiter (2009) — for each i ∈ 1..(n + 1),
kvwiφk k2 = Ilxk- n+ι X xkll = Il n+ι X(Xk -Xx )11
j=1	j=1
n+1
≤ X kXik - Xjkk2
j=1
n+1
≤ 2 X(kxk-zk k2 + kzk - Xk k2)
j=1
Summing this inequality for i ∈ 1..(n + 1) and collecting terms yields
n+1	n+1
X kVwiH2 ≤ 4(n +1) X kxk -Zkk2,
i=1	i=1
19
Under review as a conference paper at ICLR 2022
so taking expectations conditioned on Fk produces
n+1	n+1
X E[kVwiψkk2 |Fk] ≤ 4(n +1) X E[kxk-zkk2 |Fk]
i=1	i=1
n
≤ 4(n + 1)E[kxkn+1 -zkk2|Fk]+4(n+1)XE[kxik-zkk2|Fk]
i=1
≤ 4(n + 1)E[kxkn+1 -zkk2|Fk]
n
+ 8(n + 1) XEU/ - z*k2 | Fk] + 8(n + 1)2∣∣zk - z*k2
i=1
≤ 4(n + 1)E[kxkn+1 -zkk2|Fk]
n
+ 8(n + 1) XE[kxk - z*k2∣Fk] + 8(n +1)2kpk -P*k2
i=1
≤ 8(n + 1)[3n + 2τ2 + 1 + 9ρ2(L2 + 1)(N + 1)] ∣∣pk -p*『
+ 72ρ2(n +1)(N + 1)∣∣B(z*)k2 + 12ρ2 (n + 1)N,	(31)
where the final inequality employs (25) and (28).
All told, using (30) and (31) and simplifying the constants, one obtains
n+1
E[kV^kk2 |Fk] = E[kVzψkk2 |Fk] + XE[kVwi^k2Fk]
i=1
≤ CIkpk -P*k2 + C2,	(32)
where
Ci = 24(1 + 10ρ2)(n + 1)(L2 + 1)2(N + 1)2
+ 8(n + 1) (2τ2 + 6(n +1) + 1 + 3(n + 1)2τ-2)	(33)
and
n
。2 = 16(N +1) [1 + 4ρ2(n + 1) + 9ρ2L2(N +1)] ∣∣B(z*)k2 +8∣∣ Xw"∣2
i=1
+ 12ρ2N (2L2(N + 1) + n +1) + 4N.	(34)
C.4 LOWER BOUND FOR 夕k-GAP
Recalling (13), that is,
kpk+1 - p*k2 = kpk -p*k2 - 2α∙k3k(pk)-中k(p*)) + αk|V以『.
We may use the gradient bound from (32) to obtain
E[kpk+1 - p* k2 | Fk ] ≤ (1 + Ci αk )kpk - p* k2 - 2αkE[^k (pk) - Wk (p*) | Fk ]+ C?&(35)
We now focus on finding a lower bound for the term E[wk(pk) - Wk(p*) | Fk], which We call the
“Wk-gap”. Recall that forp = (z, wi, . . . , wn+i),
n+i
Wk(p) =	hz - xik,yik - wii.
i=i
For each i ∈ 1..(n +1), define Wi,k(p) = hz-Xk,yk - wii∙ We will call E[wi,k(pk) - Wi,k(p*) |Fk]
the “Wi,k-gap”. Note that Wk(p) = Pin=+ii Wi,k(p).
20
Under review as a conference paper at ICLR 2022
C.5 LOWER BOUND FOR 夕i,k-GAP OVER i ∈ 1..n
For i ∈ 1..n, we have from line 5 of the algorithm that
zk - xik = τ(yik - wik).
Since 夕i,k (Pk) = (zk - xk,yf - WJk), one may conclude that for i ∈ 1..n,
ψi,k(pk ) = T kyk- Wk k2 + ^ kzk - xk k2.
2	2τ
On the other hand, for p* ∈ S and i ∈ 1..n, one also has
-中i,k(P*) = hz* - xk, wi - yki ≥ 0	(36)
by the monotonicity of Ai. Therefore, for i ∈ 1..n, it holds that
中i,k(pk)-中i,k(p*) ≥ 2kyk - Wkk2 + 2τkzk - χkk2,
and taking expectations conditioned on Fk leads to
ES,k(Pk)- Rk(p*) | Fk] ≥ 2kyk - wkk2 + 2τkzk - xkk2	(37)
where we have used that xik and yik are both Fk-measurable for i ∈ 1..n.
C.6 LOWER BOUND FOR 夕n+ι,k-GAP
From lines 6-7 of the algorithm, we have
zk - xkn+1 = ρk(B(zk) - Wnk+1 + k).
Therefore,
Ψn+ι,k(Pk) = hzk - xn+1,yk+1 - wk+ιi	(38)
= hzk - xkn+1, B(zk) - Wnk+1i + hzk - xkn+1, ynk+1 - B(zk)i
= ρkhB(zk) - Wnk+1 + k, B(zk) - Wnk+1i + hzk - xkn+1, ynk+1 - B(zk)i
= ρkkB(zk) - Wnk+1k2 + hzk - xkn+1, ynk+1 - B(zk)i + ρkhk, B(zk) - Wnk+1i
(=a)ρkkB(zk)-Wnk+1k2+hzk-xkn+1,B(xkn+1)-B(zk)i+hzk -xkn+1,eki
+ ρkhk, B(zk) -Wnk+1i
≥ρkkB(zk)-Wnk+1k2 - Lkzk - xkn+1k2 + hzk -xkn+1,eki
+ ρkhk, B(zk) -Wnk+1i
= ρkkB(zk) - Wnk+1k2 - Lkρk(B(zk) - Wnk+1 + k)k2 + hzk - xkn+1, eki
+ ρkhk, B(zk) -Wnk+1i
=ρkkB(zk)-Wnk+1k2-ρ2kLkB(zk)-Wnk+1+kk2+hzk-xkn+1,eki
+ ρkhk, B(zk) -Wnk+1i
= ρk(1 - ρkL)kB(zk) - Wnk+1k2 -ρ2kLkkk2+hzk-xkn+1,eki
+ρk(1-2ρkL)hk,B(zk) - Wnk+1i,	(39)
where equality (a) uses line 8 of the algorithm and the inequality employs the Cauchy-Schwartz
inequality followed by Lipschitz continuity of B .
On the other hand,
-ψn+1,k (p*) = hz* - xn+1,wn+1 - yk+1i
= hz*-xkn+1,B(z*)-B(xik)i+hxkn+1-z*,eki
≥ hxkn+1 - z*, eki,	(40)
21
Under review as a conference paper at ICLR 2022
where the second equality uses line 8 of the algorithm and the inequality follows from the monotonicity
of B.
Combining (39) and (40) yields
P n+1,k (Pk)-2 n+1,k (p*) ≥ Pk (I-Pk L)kB(zk ) - wk+1k2 + Pk (I- 2ρk L)Kk, B(Zk ) - wk+li
+ hzk - xn+1, eki + hXn+1 - z*,eki- P"Wk2
=Pk(1-PkL)kB(zk)-wnk+1k2-P2kLkkk2
+Pk(1-2PkL)hk,B(zk)-wnk+1i+hzk -z*,eki.	(41)
Now, if we take expectations conditioned on Fk and use (9), we obtain
Ehzk - z*, eki Fk = hzk -z*,E[ek |Fk]i =0.	(42)
Similarly, (9) also yields
E hk, B(zk) - wnk+1i Fk = E[k|Fk], B(zk) - wnk+1 = 0.	(43)
Thus, using (42) and (43) and taking expectations of (41) yields
E[P n+1,k (Pk ) -2 n+1,k (p*) |Fk] ≥ ρk (I- ρk L)IIB(Zk ) - Wk+1 k 2 - ρkLE[k 小 ll2|Fk ]
≥ Pk(1- ρL)∣B(zk) - wk+ιk2 - PkNL(1 + ∣B(zk)k2),
(44)
where in the second inequality we used (12) and the noise variance bound (10). Recall from (12) that
1 - PL > 0.
Next, we remark that
lB(Zk)l2 = lB(Zk) - B(Z*) + B(Z*)l2
≤ 2L2lZk -Z*l2+2lB(Z*)l2 ≤ 2L2lPk - P*l2 + 2lB(Z*)l2.
Substituting this inequality into (44) yields
E[P n+1,k (Pk)-2 n+1,k (P*)∣Fk] ≥ Pk (I- PL)IlB(.zk ) - wk+1k2
-2P2kNL3lPk-P*l2-P2kNL(1+2lB(Z*)l2).	(45)
Finalizing the lower bound on the ψk -gap Summing (37) over i ∈ 1..n and using (45) yields
n+1
Esk (Pk)- ψk (p*)|Fk ] = X ESi,k (Pk) -中 i,k (p*)lFk]
i=1
nn
≥ 2 X kyk -Wkk2 + ^ X kzk -Xkk2
i=1	τ i=1
+ Pk(1 - PL)kB(zk) - wk+ιk2 - 2PkNL3kPk - P*k2
- P2kNL(1 + 2kB(Z*)k2).	(46)
C.7 Establishing Stochastic Quasi-Fejer Monotonicity
Returning to (35),
E[kPk+1 -P*k2 |Fk] ≤ (1 + Ciak)∣∣Pk -P*k2 - 2αkE[^k(Pk) - Ψk(p*) |Fk] + C2ɑk,
we may now substitute (46) for the expectation on the right-hand side. First, define
nn
Tk = T X kyk - Wkk2 + 赤 X kzk -xkk2 + 2(1 - PL)kB(zk) - wk+ik2,
P i=1	Pτ i=1
after which we may use (46) in (35) to yield
E[kPk+1 - P* k2 | Fk] ≤ (1 + C1α2k + C3 αk P2k)kPk - P* k2 - αkPkTk + C2α2k + C4 αk P2k (47)
where C1 and C2 are defined as before in (33) and (34) and
C3 = 4NL3	(48)
C4 = 2N L(1 + 2kB(z*)k2).	(49)
This completes the proof of Lemma 3.
22
Under review as a conference paper at ICLR 2022
C.8 A Convergence Lemma
Before establishing almost-sure convergence, we need the following lemma to derive convergence
of the iterates from convergence of Tk defined above. Note that a more elaborate result would be
needed in an infinite-dimensional setting.
Lemma 4. For deterministic sequences zk ∈ R(n+1)d, {(wik)in=+11} ∈ P, and {(xik, yik)in=+11} ∈
R2(n+1)d, suppose that yik ∈ Ai(xik) for i ∈ 1..n, Pin=+11 wik = 0,
nn
ξ1 X kyik - wikk2 3 + ξ2 X kzk - xikk2 + ξ3kB(zk) - wnk+1k2 →0	(50)
i=1	i=1
for scalars ξι, ξ2,ξ3 > 0, andPk = (Zk, wk,..., wk+ι) → P= (Z, Wι,..., Wn+ι). ThenP ∈ S
Proof. Fix any i ∈ {1,..., n}. Since ∣∣yk - Wk∣∣ → 0 by (50) and Wk → Wi, We also have
yk → Wi. Similarly, (50) also implies that ∣∣zk - Xkk → 0, so from zk → Z We also have Xk → z.
Since yf ∈ Ai(Xk) and (Xk,yf) → (Z,Wi), (Bauschke & CombetteS, 2017, Prop. 20.37) implies
Wi ∈ Ai(Z). Since i was arbitrary, the preceding conclusions hold for i ∈ 1..n.
Now, (50) also implies that ∣∣B(zk) - Wkk+ik → 0. Therefore, since Wn+、→ Wn+ι, we also have
B(zk) → Wn+ι. Much as before, since (zk,B(zk)) → (Z,W^n+ι), we may apply (Bauschke &
Combettes, 2017, Prop. 20.37) to conclude that that zυn,+ ι = B(Z).
Since the linear subspace P defined in (6) must be closed, the limit (Z, z^ι,..., z^n+ι) of
{(zk, Wk ,...,Wk+ι)} ⊂ P must be in P, hence £=1 Wi = 0.
Thus, the point P = (Z,W1,...,Wn+1) satisfies Wi ∈ Ai(Z) for i ∈ 1..n, Wn+1 = B(Z), and
pn+11 Wi = 0. These are the three conditions defining membership in S from (5), so P ∈ S.	□
C.9 Finishing the Proof of Theorem 1
Given Pk α2k < ∞, and P αkρ2k < ∞, (47) satisfies the conditions of Stochastic Quasi-Fejer
Monotonicity as given in Lemma 2. By applying Lemma 2, we conclude that there exist Ω1, Ω2, Ω3
such that P[Ωi] = 1 for i = 1, 2, 3 and
1. forall V ∈ Ω1
∞
αkρkTk(v) < ∞,	(51)
k=1
2. for all V ∈ Ω2, andp* ∈ S, kPk(V) -p*∣ converges to a finite nonnegative random-variable,
3. for all V ∈ Ω3, Pk(v) remains bounded.
Since P∞=1 akPk = ∞, (51) implies that for all V ∈ Ω1 there exists a subsequence qk (v) such that
Tqk(v) →0.	(52)
Let Ω0 = Ω1 ∩ Ω2 ∩ Ω3 and note that P[Ω0] = 1. Choose V ∈ Ω0. Since Pk(V) remains bounded, so
does Pqk (v) (V) for qk(V) defined above in (52). Thus there exists a subsequence rk(V) ⊆ qk(V) and
P(V) ∈ R(n+2)d such thatPrk(V)(V) → j^(v). But since Tqk(V) → 0, it also follows that Trk(V) → 0,
that is,
nn
=X kyrk(V)(V)-Wrk(V)(V)k2 + =τ X 忖"(V)(V)-Xrk(V)(V)k2
ρ i=1	ρτ i=1
+ 2(1 - ρL)∣B(Zrk(V)(v)) - Wn⅛)(V)k2 → 0.
We then have from Lemma 4 that P(V) ∈ S.
23
Under review as a conference paper at ICLR 2022
Since Prk(V)(V) → p(v), it follows that kPrk(V)(V) -p(v)k → 0. But since p(v) ∈ S, kpk(v) -p(v)k
converges by point 2 above. Thus
lim kpk(V) — p(v)k = lim ∣∣prk(v)(v) — p(v)k = 0.
k→∞	k→∞
Therefore Pk (V) → P(V) ∈ S. Thus there exists P ∈ S such that Pk → P a.s., which completes the
proof of Theorem 1.
C.10 Two Additional Results
In this section, We prove two additional useful results about SPS. First, that Xk → Z (a.s.) for
i = 1, . . . , n. Second, that Gk → 0 (a.s.).
Note that
xik = JτAi (zk + τwik)
and since zk and wik convergence a.s., so does xik. Consider the subsequence qk (V) such that (52)
holds. Then
zqk (V) - xiqk (V) → 0
thus
xqk(V) → z
xi	→ z.
Since Xk converges to some limit (a.s.), that limit must be Z.
Recall that
Gk=. Pin=1∣yik-wik∣2+Pin=1∣zk-Xik∣2+∣B(zk)-wnk+1∣2.
We have shown that zk and Xik share the same limit for i = 1, . . . , n (a.s.). Therefore zk - Xik → 0
(a.s.). Since
yik -wik =τ-1(zk-Xik),
it follows that yik - wik → 0 (a.s.) for i = 1, . . . , n. Therefore
Gk → IIB(Z)- wn+1∣∣2.
But since (z, Wi,..., Wn+ι) ∈ S, Wn+1 = B(Z) implying that Gk → 0 (a.s.).
D	Proof of Lemma 1
If Gk = 0, then
∀i = 1, . . . , n :	yik = Wik and Zk = Xik .	(53)
Since yik ∈ Ai(Xik) for i = 1, . . . , n, (53) implies that that
∀i ∈ 1..n :	Wik ∈ Ai(Zk).	(54)
Furthermore Gk = 0 also implies that Wnk+1 = B(Zk). Finally, since Pin=+11 Wik = 0, we have that
(Zk,W1k,...,Wnk+1) ∈S.
Conversely, suppose (Zk, W1k, . . . , Wnk+1) ∈ S. The definition of S implies that B(Zk) = Wnk+1 and
furthermore that Wik ∈ Ai(Zk) for i ∈ 1..n. For any i ∈ 1..n, considering line 3 of Algorithm 1,
we may write tik = Zk + τWik ∈ (I + τAi)(Zk), implying Zk ∈ (I + τAi)-1(tik). But since the
resolvent JτAi = (I + τAi)-1 is single-valued (Bauschke & Combettes, 2017, Prop. 23.8), we must
have Zk = (I + τAi)-1(tik). Thus, by line 4, we have Xik = Zk. We may also derive from line 5 that
yik=τ-1(tik-Xik)=τ-1(Zk+τWik-Zk)=Wik.
Thus, since Xik = Zk and yik = Wik for i = 1, . . . , n and Wnk+1 = B(Zk), we have that Gk = 0.
24
Under review as a conference paper at ICLR 2022
E Proof of Theorem 2
In addition to the proof, we provide a more detailed statement of the theorem:
Theorem 3. Fix the total iterations K ≥ 1 of Algorithm 1 and set
∀k = 1, . . . ,K :
∀k = 1, . . . ,K :
ρk = ρ =. min K-1/4
(55)
(56)
for some Cf > 0. Suppose (9)-(11) hold. Thenfor any p* ∈ S,
1 XX EQ] / 8L3 exp (Cf(CI + C3)) (H ι ≠∣ ∣2 Cf c2 + c4 ∖
K M E[Gj] ≤ Cf min{τ,τ-i}K (kp - p k + CCrTC3)
1 XX e[g 1 ≤ exP(Cf(CI + C3))
K ɪ-j j — Cf min{τ,τ-1}K1/4
(kp1- p*k2 +
Cf C2 + C4 A
Cf Ci + C3 )
forK< (2L)4 (57)
for K ≥ (2L)4. (58)
where Gk is the approximation residual defined in (14), and C1 , C2 , C3, C4 are the nonegative
constants defined in (33), (34), (48), and (49), respectively. Therefore,
1K
K ∑E[Gj]=O(KT/4).
K j=1
Proof. Fix αk = α and ρk = ρ, where α and ρ are the respective right-hand sides of (55)-(56).
Lemma 3 implies that (21) so long as (9)-(11) hold and the stepsize ρ satisfies ρ < L-1. Since
P = min {k T4,2L
1
≤——,
—2L,
we conclude that (21) applies.
Rewriting (21) with αk = α and ρk = ρ, we have
E[kpk+1 - p* k2 | Fk] ≤ (1 + Ciα2 + C3αρ2)kpk — p* k2 — αρTk + C2α2 + C4αρ2.
Therefore, taking expectations over Fk , we have
Ekpk+i -p*k2 ≤ (1 + Ciα2 + C3αρ2)Ekpk -p*k2 - αρETk +C2α2 +C4αρ2.	(59)
Recall that
nn
Tk = T X kyk - Wi k2 + -τ X kzk -Xkk2 + 2(1 — ρL)kB(zk) - wk+1k2,
ρ i=i	ρ i=i
where for the first two terms We have simply set P = P because the stepsize is constant. However,
for the final term, we will still use an upper bound, p, on ρ. In the current setting, we know that
p ≤ (1∕2)L-i and therefore we may set P = (1∕2)L-i. Thus 1 一 pL =1/2, leading to
nn
PETk =τ X Ekyik -wikk2+τ-i X Ekzk - xikk2 + PEkB(zk) - wnk+ik2.
i=i	i=i
Let
nn
Uk=. EkB(zk) - wnk+ik2	Wk=. τ XEkyik-wikk2+τ-i X Ekzk - xikk2,
i=i	i=i
so that
PETk = PUk + Wk ,
and also let
Vk =. Ekpk - p*k2.
25
Under review as a conference paper at ICLR 2022
Using these definitions in (59) we write
Vk+1 ≤ (1 + gα2 + C3ɑρ2)Vk — αρUk — αWk + CqjO1 + C4αρ2.
Therefore,
Vk+1 + αρUk + αWk ≤ (1 + C102 + C3αp2)Vk + Cqo2 + C40ρ2
k	k	k-1	k-1
O Vk+1 + αρfUj + a£Wj ≤ (1 + C102 + C3αρ2)Vk + αρfUj + a^Wj
+ CqQ2 + C40ρ2
-	k-1	k-1
≤ (1 + CiQ2 + C3αρ2) Vk + QP X Uj + Q X Wj
_	j=i	j=i
+ C2(Q + C4Qρ^,
where we have used that Uk, Wk ≥ 0. Letting
k-1	k-1
Rk = Vk + QP X Uj + Q X Wj,
j=i	j=i
we then have
Rk + 1 ≤ (1 + CiQ2 + C3αρi2)Rk + CqQ2 + C4Qρ2,
which implies
Rk+i ≤ (1 + CiQ2 + C3Qρ2)kRi + (CqQ2 + C4Qρ2)〉：(1 + CiQ2 + C3Qρ2)k j .
j=i
Now,
〉：(1 + CiQ2 + C3αρ2)k-j =)：(1 + CiQ2 + C3Qρ2)j
j=i	j=0
=(1 + Ci q2 + C3Qρ2)k — 1
=(1 + CiQ2 + C3Qρ2) — 1
=(1 + Ci Q2 + C3Qρ2)k — 1
=	CiQ2 + C3Qρ2
≤ (1 + Ci Q2 + C3Qρ2)k
-	CiQ2 + C3Qρ2	.
Therefore,
Rk+i ≤ (1 + Ciq2 + C3Qρ2)k(Ri + C2qQ + C4QP2).
∖	CiQ2 + G3QΡ2√
Fix the number of iterations K ≥ 1. Now
P = min KK-i/4, ɪ \ ≤ —二 ≤ 1.
P I , 2L I ≤ Ki/4 ≤
Therefore,
K	K	K
QP X(Uj + Wj) ≤ QP X Uj + Q X Wj
≤ RK+i
≤ (1 + CiQ2 + C3Qρ2)κ
Ri +
CqQ2 + C4Qρ2
CiQ2 + C3Qρ2
26
Under review as a conference paper at ICLR 2022
Dividing through by αρK, we obtain
1 χX'(ττ I (l +	C	α~+ C1α2 + C3αρ2)K	(P l	C2α2	+ C4αρ2 ʌ
κ M(Uj+ Wj)	≤-------αρκ-------(RI +	c1ɑ2	+ C3αρ2 )，
(60)
and since α =Cfρ2 , we also have
C202 + C4aρ2 _ Cf C2 + C4
C1α2 + C3αρ2 = Cf C1 + C3
Furthermore,
P ≤ K- 4 =⇒ α ≤ Cf K- 2.
Substituting these into (60) yields
1 + Cf(Cf [I +C3)
αρK
Cf C2 + C4 A
Cf Ci + C3 )
exp(Cf(CfCi + C3)) (R + CfC2 + C4 λ
αρK	V 1 + Cf Ci + C3)
(61)
where we have used that for any t ≥ 0, 1 + t/K ≤ et/K, so therefore (1 + t/K)K ≤ et.
The worst-case rates in terms of K occur when ρ = K-1/4 andα = CfK-1/2. This is the case
when K ≥ (2L)4. Substituting these into the denominator yields, for K ≥ (2L)4, that
1 XX(U 1 WieXP(Cf(Cf CI + C3)) (P 1 Cf C2 + C4 ʌ
K M(Uj+ Wj) ≤---------CfKi/4------(RI + Cf Ci + C3 )-
Thus, since Gk ≤ maX{τ, τ-1} (Uk + Wk) , we obtain
⅛ XXE[Gj] ≤ ", TT} eXpf fCI + C3)) (kpi -娟2 + ∣⅞4⅜)，
K j=i	CfKi/4	CfCi + C3
which is (58).
When K < (2L)4, (57) can similarly be obtained by substituting ρ = (2L)-i andα	= Cf (2L)-2
into (61).	□
F	Approximation Residuals
In this section we derive the approximation residual used to assess the performance of the algorithms
in the numerical experiments. This residual relies on the following product-space reformulation
of (1).
F.1 Product-Space Reformulation and Residual Principle
Recall (1), the monotone inclusion we are solving:
n
Find z ∈ Rd : 0 ∈ X Ai(z) + B(z).
i=i
In this section we demonstrate a “product-space" reformulation of (1) which allows us to rewrite
it in a standard form involving just two operators, one maximal monotone and the other monotone
and Lipschitz. This approach was pioneered in (Briceno-Arias & Combettes, 2011; COmbettes &
Pesquet, 2012). Along with allowing for a simple definition of an approximation residual as a measure
of approximation error in solving (1), it allows one to apply operator splitting methods originally
formulated for two operators to problems such as (1) for any finite n.
27
Under review as a conference paper at ICLR 2022
Observe that solving (1) is equivalent to
Find (w1, . . . , wn, z) ∈ R(n+1)d :	wi ∈ Ai(z),	i ∈ 1..n
n
0 ∈ Xwi + B(z).
i=1
This formulation resembles that of the extended solution set S used in projective spitting, as given
in (5), except that it combines the final two conditions in the definition of S , and thus does not need
the final dual variable wn+1. From the definition of the inverse of an operator, the above formulation
is equivalent to
Find (w1, . . . , wn, z) ∈ R(n+1)d :	0 ∈ Ai-1 (wi) - z, i ∈ 1..n
n
0 ∈ Xwi + B(z).
i=1
These conditions are in turn equivalent to finding (w1 , . . . , wn , z) ∈ R(n+1)d such that
0 ∈ A (w1, . . . , wn, z) + B(w1, . . . , wn, z),	(62)
where A is the set-valued map
A (w1, . . . , wn, z) 7→ A1-1(w1) × A2-1 (w2) × . . . × An-1(wn) × {0}	(63)
and B is the single-valued operator
	-0 ∙	・	0 -I		-W1 -	Γ 0	.	
B(w1 , . . . , wn , z) 7→	. . .	.. ..		. . .	. +	.	.	(64)
	0 ∙	・	0 -I		Wn	0	
	_ I ∙	・ I 0		z	B(z)	
It is easily established that B is maximal monotone and Lipschitz continuous, while A is maximal
monotone. Letting T =. A + B, it follows from (Bauschke & Combettes, 2017, Proposition
20.23) that T is maximal monotone. Thus, we have reformulated (1) as the monotone inclusion
0 ∈ T (q) for q in the product space R(n+1)d. A vector z ∈ Rd solves (1) if and only if there exists
(w1, . . . , wn) ∈ Rnd such that 0 ∈ T (q), where q = (w1, . . . , wn, z).
For any pair (q, v) such that v ∈ T (q), kvk2 represents an approximation residual for q in the sense
that v = 0 implies q is a solution to (62). One may take kvk2 as a measure of the error of q as an
approximate solution to (62), and it can only be 0 if q is a solution. Given two approximate solutions
q1 and q2 with certificates v1 ∈ T(q1) and v2 ∈ T (q2), we will treat q1 as a “better” approximate
solution than q2 if kv1 k2 < kv2k2. Doing so is somewhat analogous to the practice, common in
optimization, of using the gradient kVf (x)k2 as a measure of quality of an approximate minimizer
of some differentiable function f. However, note that since T (q1) is a set, there may exist elements
of T (q1) with smaller norm than v1. Thus any given certificate v1 only corresponds to an upper
bound on dist2(0, T (q1)).
F.2 Approximation Residual for Projective Splitting
In SPS (Algorithm 1), for i ∈ 1..n, the pairs (xik, yik) are chosen so that yik ∈ Ai (xik). This can be
seen from the definition of the resolvent. Thus xik ∈ Ai-1 (yik). Observe that
Xk - Zk
.
Vk 三	Jk	∈ T(yk,…，yk,zk).	(65)
kk
xn - z
B(zk) + Pin=1 yik
The approximation residual for SPS is thus
Rk=. kvkk2 = Xn kzk - xikk2 + B(zk) + Xn yik2	(66)
i=1	i=1
28
Under review as a conference paper at ICLR 2022
which is an approximation residual for (y1k, . . . , ynk, zk) in the sense defined above. We may relate
Rk to the approximation residual Gk for SPS from Section 5 as follows:
n
Rk =Xkzk-xikk2+
i=1
n
= Xkzk -xikk2+
i=1
n
B(zk)+Xyik
i=1
n	n+1
B(zk)+Xyik-Xwik
i=1	i=1
n
≤ Xkzk -xikk2+2kB(zk) -
wn+1k2+2
i=1
2
n
X(yik -wik)
i=1
nn
≤ Xkzk -xikk2+2kB(zk) -
wn+1k2+2nXyik-wik2
i=1	i=1
≤ 2nGk
where in the second equality we have used the fact that Pin=+11 wik = 0. Thus, Rk has the same
convergence rate as Gk given in Theorem 2.
Note that while the certificate given in (65) focuses on the primal iterate zk , it may be changed to
focus on any xik for i = 1, . . . , n, by using
kk
x1 - xi
vik
xk - xk
B(xik)n+Pin=1yik
∈ T(y1k,...,ynk,xik).
The approximation residual kvikk2 may also be shown to have the same rate as Gk by following
similar derivations to those above for Rk .
F.3 Tseng’ s method
Tseng’s method (Tseng, 2000) can be applied to (62), resulting in the following recursion with iterates
qk,qk ∈ R(n+1)d:
qk = JaA (qk — αB(qk))	(67)
qk+1 = qk + α(B(qk) - B(qk)),	(68)
where A and B are defined in (63) and (64). The resolvent of A may be readily computed from the
resolvents of the Ai using Moreau’s identity (Bauschke & Combettes, 2017, Proposition 23.20).
Analogous to SPS, Tseng’s method has an approximation residual, which in this case is an element of
T (qqk ). In particular, using the general properties of resolvent operators as applied to JαA, we have
1(qk - qk) - B(qk) ∈ A(qk).
α
Also, rearranging (68) produces
1(qk — qk+1)+ B(qk) = B(qk).
α
Adding these two relations produces
1(qk — qk+1) ∈ A(qk) + B(qk) = T(qk)
α
Therefore,
RTseng = * kqk — qk+1k2
represents a measure of the approximation error for Tseng’s method equivalent to Rk defined in (66)
for SPS.
29
Under review as a conference paper at ICLR 2022
F.4 FRB
The forward-reflected-backward method (FRB) (Malitsky & Tam, 2020) is another method that may
be applied to the splitting T = A + B for A and B as defined in (63) and (64). Doing so yields
recursion
qk+1 = JaA(qk — α(2B(qk) - B(qk-1)))
Following similar arguments to those for Tseng’s method, it can be shown that
VkRB = 1 (qk-1 — qk) + BH) + B(qk-2) - 2B(qk-1) ∈ TH).
α
Thus, FRB admits the following approximation residual equivalent to Rk for SPS:
RFkRB =. kvFkRBk2.
Finally, we remark that the stepsizes used in both the Tseng and FRB methods can be chosen via a
linesearch procedure that we do not detail here.
F.5 Stochastic Tseng Method
The stochastic version of Tseng's method of (Bohm et al., 2020) (S-Tseng) may be applied to the
inclusion 0 ∈ A (q) + B(q), since the operator A may be written as a subdifferential. However,
unlike the deterministic Tseng method, it does not produce a valid residual. Note also that S-Tseng
outputs an ergodic sequence qekrg. To construct a residual for the ergodic sequence, we compute a
deterministic step of Tseng’s method according to (67)-(68), starting at qekrg. That is, letting
qk = JaA dg- B(q 旨g))
qk+1 = qk + α(B(q旨g) - B(qk)),
we can then compute essentially the same residual as in Section F.3,
Rk-TSeng ==⅛ kqkrg - qk+1k2.
To construct the stochastic oracle for S-Tseng, We assumed B(Z)=* Pm=I Bi(z). Then We used
0
	-0 ∙	・	0 -I -		-wι -	
B(w1 , . . . , wn , Z) 7→	.	. . 0 ∙ _ I ∙	.. ... ・	0	-I ・	I	0		. . . Wn Z	+
0
∣B∣ Pj∈B Bj (Z)
(69)
for some minibatch B ∈ {1, . . . , m}.
F.6 Variance-Reduced FRB
The FRB-VR method of Alacaoglu et al. (2021) can also be applied to 0 ∈ A (q) + B(q), using the
same stochastic oracle B defined in (69). if we let the iterates of FRB-VR be (qk,pk), then line 4 of
Algorithm 1 of Alacaoglu et al. (2021) can be Written as
qk = qk - T(B(Pk) + B(qk) - B(Pk))	(70)
qk+1 = JT A (qk).	(71)
Once again, the method does not directly produce a residual, but one can be developed from the
algorithm definition as follows: (71) yields T-1(qk - qk+1) ∈ A(qk+1) and hence
τ-1(qk - qk+1) + B(qk+1) ∈ (A + B)(qk+1).
Therefore we use the residual
RFRB-VR =IITT(qk - qk+1) + B(qk+1)k2.
Figure 1 plots Rk for SPS, RkTseng for Tseng’s method, RFkRB for FRB, RSk-Tseng for S-Tseng, and
RFkRB-VR for FRB-VR.
30
Under review as a conference paper at ICLR 2022
F.7 B enefits and Drawbacks of the Product Space Reformulation
The main benefit of the product space reformulation (PSR) is that it allows one to use familiar
2-operator splitting schemes for solving 0 ∈ A (q) + B(q) to solve the more complicated recursion
(1). However, one drawback of this approach is that the operator B, defined in (64), combines a
skew-symmetric consensus matrix with the Lipschitz operator B . Treating B as a single operator
necessitates using a single stepsize for both of its constituent operators, but the B component will
generally have a much larger Lipschitz constant than the skew part, necessitating a smaller stepsize
than is ideal for the skew operator. This difficulty can be countered by using different stepsizes
for the primal and dual components, but that strategy introduces additional tuning parameters. In
other works, methods based on PSR have exhibited slower convergence than deterministic projective
splitting methods (Johnstone & Eckstein, 2021; 2020b). However, in our experiments in Section 7,
the performance is comparable.
G	Variational Inequalities
For a mapping B : Rd → Rd and a closed and convex set C, the variational inequality problem
(Harker & Pang, 1990) is to find z* ∈ C such that
B(z*)>(z - z*) ≥ 0,∀z ∈ C.	(72)
Consider the normal cone mapping discussed in Section 2 and defined as
NC(x) =. {g : g>(y - x) ≤ 0 ∀y ∈ C}
It is easily seen that (72) is equivalent to finding z* such that -B(z*) ∈ NC(z*). Hence, if B is
monotone, (72) is equivalent to the monotone inclusion
0 ∈ B(z*)+NC(z*).	(73)
Thus, monotone variational inequalities are a special case of monotone inclusions with two operators,
one of which is single-valued and the other is the normal cone map of the constraint set C . As a
consequence, methods for monotone inclusions can be used to solve monotone variational inequality
problems. The reverse, however, may not be true. For example, the analysis of the extragradient
method (Korpelevich, 1977) relies on the second operator NC in (73) being a normal cone, as opposed
to a more general monotone operator. We are not aware of any direct extension of the extragradient
method’s analysis allowing a more general resolvent to be used in place of the projection map
corresponding to NC .
The Restricted Gap Function There is a disadvantage to pursuing convergence rates based on
variational inequalities (as in BOhm et al. (2020) and Alacaoglu et al. (2021)) rather than monotone
inclusions. Convergence rate analyses for variational inequalities focus on the gap function:
GC (z) =. sup B(z0)> (z - z0).	(74)
z0∈C
It can be shown that GC (z) ≥ 0 and GC (z) = 0 if and only if z solves (72). However, (74) is
meaningless for most problems, since unless C is compact, GC (z) is typically equal to +∞ for any
nonsolution (Diakonikolas, 2020). Thus researchers instead focus on the restricted gap function
(Nesterov, 2007)
GC2 (z) =. sup B(z0)> (z - z0).	(75)
z0 ∈C2
where C2 is an arbitrary compact set. However, now the results are only meaningful over the set C2 .
Thus, C2 must be chosen large enough so that the iterates of the algorithm remain in the interior of
C2 (BOhm et al., 2020). Further, the convergence rate bound depends on the diameter of C2 . For
some algorithms (Mokhtari et al., 2020) a valid set is provided which bounds the iterates. However
BOhm et al. (2020) and Alacaoglu et al. (2021) do not provide one, although in principle it could be
done so long as the ergodic sequence can be bounded almost-surely. Thus, the convergence rates
depending on (75) in BOhm et al. (2020) and Alacaoglu et al. (2021) are somewhat incomplete in that
they depend on unknown constants.
In contrast, rates based on the approximation residual in the monotone inclusion setting, including
ours given in (57)-(58), completely avoid this pitfall. There is no need to select a compact set
containing the algorithm’s iterates and the constants in our rates are all explicit or depend on standard
quantities such as the initial distance to a solution.
31
Under review as a conference paper at ICLR 2022
H	Memory-Saving Technique for SPS
The variables tik , xik, and yik on lines 3-5 of SPS are stored in variables t, x and y. Another two
variables X and y keep track of Pn= 1 Xk and Pn= 1 yf. The dual variables are stored as Wi for
i ∈ 1..n and the primal variable as z. Once x = xik is computed, the ith dual variable wi can be
partially updated as Wi — Wi - αkx. Once all the operators have been processed, the update for each
dual variable may be completed via Wi — Wi + αk(n + 1)-1X. Also, the primal update is computed
as Z J Z — akyj. During the calculation loop for the Xk, yf, the terms in approximation residual Rk
may also be accumulated one by one. The total total number of vector elements that must be stored is
(n + 7)d.
I Additional Information About the Numerical Experiments
We solve the following convex-concave min-max problem:
min max
β∈Rd γ∈Rm
λ∈R
s.t.
1m
S λ(δ - K) +-ɪ2 ψ(hxi, βi) +
m i=1
m
XYi(OihXi,βi - λκ) + CkekI
i=1
(76)
kβk2 ≤ λ∕(Lψ + 1)	kγk∞ ≤ 1.
1
m
)
This model is identical to that of (Yu et al., 2021, Thm. 4.3) except for the addition of the `1
regularization term ckβ k1 , where c ≥ 0 is a given constant. The goal is to learn the model weights β
from a training dataset of m feature vectors Xi and corresponding labels yi. Rather than computing
the expected loss over the training set, the formulation uses, for each β, the worst possible distribution
within a Wasserstein-metric ball around the empirical distribution of the {(Xi,Oi)}, with the parameter
δ ≥ 0 giving the diameter of the ball and the parameter κ ≥ 0 specifying the relative weighting of
features and labels. The variables γ and λ parameterize the selection of this worst-case distribution in
response to the model weights β. Finally, Ψ is the logistic loss kernel t 7→ log(et + e-t) and LΨ = 1
is the corresponding Lipschitz constant. In all the experiments, we set δ = κ = 1 and c = 10-3.
We now show how we converted this problem to the form (1) for our experiments. Let Z be a
shorthand for (λ, β, γ), and define
1m	1m
L(z) = λ(δ - κ) + m X 田(信，βi) + m X、8囱, βi- λκ).
i=1
i=1
The first-order necessary and sufficient conditions for the convex-concave saddlepoint problem in
(76) are
0∈B(Z)+A1(Z)+A2(Z)
where the vector field B(Z) is defined as
B(Z)=	v"L(Z)
-Vγ L(Z)
(77)
(78)
with
vλ,βL(Z)
δ - K(I + m1 Pm=I Yi)
m Pm=I W0(hXi, ei)Xi + m1 Pm=I YiyiXi
and
m (yihXi,ei—λκ)
VY L(Z)=	.
_ mm (ym hXm,βi - λκ)
It is readily confirmed that B defined in this manner is Lipschitz. The monotonicity of B follows
from its being the generalized gradient of a convex-concave saddle function (Rockafellar, 1970).
32
Under review as a conference paper at ICLR 2022
For the set-valued operators, A1 (z) corresponds to the constraints and A2 (z) to the nonsmooth `1
regularizer, and are defined as
A1 (z) =. NC1 (λ, β) × NC2 (γ),
where
Ci = {(λ,β) : kβk2 ≤ λ∕(Lψ + 1)} and	C? = {γ : ∣∣γ∣∣∞ ≤ 1},
and
A2(z) =. {01×1} ×c∂kβk1 × {0m×1}.
Here, the notation 0p×1 denotes the p-dimensional vector of all zeros. C1 is a scaled version of
the second-order cone, well known to be a closed convex set, while C? is the unit ball of the '∞
norm, also closed and convex. Since A1 is a normal cone map of a closed convex set and A2 is the
subgradient map of a closed proper convex function (the scaled 1-norm), both of these operators are
maximal monotone and problem (77) is a special case of (1) for n = 2.
Stochastic oracle implementation
be written as
The operator B : Rm+d+1 7→
Rm+d+1, defined in (78), can
m
B(Z) = m X Bi(Z)
i=1
where
Bi (Z) =.
δ - κ(1 +γi)
ψ0(h^i,βi)^i + Yiyixi
0(i-1)×1
-(yihxi,βi - λκ)
0(m-i)×1
In our SPS experiments, the stochastic oracle for B is simply B(Z)=这 Pi∈B Bi(Z) for some
minibatch B ⊆ {1, . . . ,m}. We used a batchsize of 100.
Resolvent computations The resolvent of A1 is readily constructed from the projection maps of
the simple sets C1 and C?, while the resolvent A? involves the proximal operator of the `1 norm.
Specifically,
JρA1 (Z)
projC1(λ,β)
projC2(γ)
01×1
and jpA2 (Z) =	Proxρc∣Hde)
0m×1
The constraint Ci is a scaled second-order cone and C? is the '∞ ball, both of which have closed-form
projections. The proximal operator of the `1 norm is the well-known soft-thresholding operator
(Parikh & Boyd, 2013, Section 6.5.2). Therefore all resolvents in the formulation may be computed
quickly and accurately.
SPS stepsize choices For the stepsize in SPS, We ordinarily require Pk ≤ ρ < 1/L for the global
Lipschitz constant L of B. However, since the global Lipschitz constant may be pessimistic, better
performance can often be achieved by experimenting with larger stepsizes. If divergence is observed,
then the stepsize can be decreased. This type of strategy is common for SGD and similar stochastic
methods. Thus, for SPS-decay we set αk = Cdk-0.5i and ρk = Cdk-0.?5, and performed a grid
search to select the best Cd from {0.1, 0.5, 1, 5, 10}, arriving at Cd = 1 for epsilon and SUSY, and
Cd = 0.5 for real-sim. For SPS-fixed we used ρ = K-i/4 and α = Cfρ?, and performed a grid
search to select Cf over {0.1, 0.5, 1, 5, 10}, arriving at Cf = 1 for epsilon and real-sim, and Cf = 5
for SUSY. The total number of iterations for SPS-fixed was chosen as follows: For the epsilon dataset,
we used K = 5000, for SUSY we used K = 200, and for real-sim we used K = 1000.
33
Under review as a conference paper at ICLR 2022
Figure 2: Approximation residual versus epoch for three LIBSVM benchmark datasets. Left: epsilon,
middle: SUSY, right: real-sim.
Parameter choices for the other algorithms All methods are initialized at the same random point.
For Tseng’s method, we used the backtracking linesearch variant with an initial stepsize of 1, θ = 0.8,
and a stepsize reduction factor of 0.7. For FRB, we used the backtracking linesearch variant with the
same settings as for Tseng’s method. For deterministic PS, we used a fixed stepsize of 0.9/L. For
the stochastic Tseng's method of Bohm et al. (2020), the stepsize αk must satisfy: Pk=I αk = ∞
and k∞=1 α2k < ∞. So we set αk = Ck-d and perform a grid search over {C, d} in the range
[10-4, 10] × [0.51, 1], checking 5 × 5 values to find the best setting for each of the three problems.
The selected values are in Table 1.
	epsilon	SUSY	real-sim
C	0.56	0.56	0.77
d	0.6	0.6	0.55
Table 1: Parameter Values for S-Tseng
The work of Bohm et al. (2020) also introduced FBFp, a stochastic version of Tseng’s method that
reuses a previously-computed gradient and therefore only needs one additional gradient calculation
per iteration. In our experiments, the performance of the two methods was about the same, so we
only report the performance of stoch. Tseng’s method.
For variance-reduced FRB, the main parameter is the probability p. We hand-tuned p,arriving at
p = 0.01 for all problems. We set the stepsize to its maximum allowed value of
1 — vz1 - p
T =--------------
2L
Plots versus Epoch Figure 2 plots the performance of each method versus epoch (i.e. data pass).
This shows an even more dramatic benefit for the stochastic methods than the plots versus time,
since at each iteration the stochastic methods only need to process small amounts of data, whereas
deterministic methods must process all of it. We believe these benefits do not fully manifest
themselves in the plots versus time due to overheads in each iteration of the stochastic methods,
multithreading providing a boost for the deterministic methods, memory access patterns, and other
practical considerations.
Fraction of Nonzero Entries versus Running time Figure 3 plots the fraction of nonzero entries
in the iterates of each method versus running time. For each method, we used output of PrOxck “1.
We observe that our methods produce sparse intermediate iterates for two of the three problems. This
is one of the benefits of proximal splitting algorithms in general, including our method. For the other
problem, SUSY, no method produces sparse iterates, suggesting that c should be increased if sparse
solutions are desired.
34
Under review as a conference paper at ICLR 2022
Figure 3: Fraction of nonzero entries versus running time for the three datasets. Left: epsilon, middle:
SUSY, right: real-sim.
J Local Convergence on Non-Monotone Problems
The work by Hsieh et al. (2020) provides a local convergence analysis for DSEG applied to locally
monotone problems. Recall that DSEG is equivalent to the special case of SPS for which n = 0.
While extending this result to the more general setting of SPS is beyond the scope of this manuscript,
we next provide a preliminary sketch of how the analysis of Hsieh et al. (2020) might be generalized
to our setting. We leave a formal proof to future work.
Sketch of assumptions and main result The first assumption needed is the existence ofan isolated
solution p* = (z*,wf,..., Wn+，∈ S. We then require that there exists a ball Br (z*), centered at
z*, throughout which the operator B is “well-behaved”, meaning that it satisfies monotonicity and
Lipschitz continuity. In addition, we need each Ai, for i ∈ 1..n, to be maximal monotone within this
ball. Outside of the ball, the operators do not need to be monotone or Lipschitz.
Following (Hsieh et al., 2020, Assumption 20), the noise variance assumptions are slightly stronger
than in the monotone case. In particular, we require that E[kk kq |Fk] ≤ Nq and E[kekkq|Fk] ≤ Nq
for some q > 2. As before, the noise must be zero-mean. Finally, the stepsize requirements are also
slightly stronger than (12), having the added assumption that k∞=1 ρqk < ∞.
With these assumptions, the goal is to show that, so long as the initial point p1 is sufficiently close to
p*, then with high probability pk converges to p*.
Proof strategy The initial strategy is to develop the following recursion, satisfied by SPS, that does
not (yet) utilize local monotonicity or Lipschitz continuity:
kpk+1 - p*k2 ≤ (1 + c1α2k)kpk -p*k2 - c2αkρk(Tk0 + lk + rk) - c3αk(rk0 + qk)
+ c1 ak (kek ∣∣2 + kJ ∣∣2 + c4)+ c5αk qk
for appropriate constants c1 . . . c5 ≥ 0. In this inequality, we use
nn
Tk = T X kyk - Wkk2 + =τ X kzk - Xkk2,
ρ i=1	ρ i=1
n
lk =. Xhz* - xik, Wi* - yiki + z* - xkn+1, Wi* - B(xkn+1),
i=1
rk = hek,B(Xk)- wk+ιi,
rk0 =. hzk -z*,eki,
qk = (P-I- d∕2)kXk - Zk k2 - kXk - Zk kkB(Xk) - B(Zk )k
dk = Pk kek kkBxn+1 - Bxk k + 2d kBXn+1 - B<+ι k2,
2d
(79)
where
Xk = zk - Pk (B(Zk) - wk+1
d = I-L
=1 + ρ∕2,
(80)
35
Under review as a conference paper at ICLR 2022
with L being the local LiPschitz constant of B on Br (z*). The iterate Xk is the analog of the iterate
工	.	.	一 _____
Xt+1/2 used in Hsieh et al. (2020).
The recursion (79) is derived by once again starting from (13) and following the arguments leading to
(35), but this time not taking conditional expectations. In particular, the upper bounds on ∣∣Vz夕k k2
and IlVwiψk∣∣2 contribute the terms cιαk (Ilekk2 + ∣∣ek∣∣2 + c4) and cιαk∣pk 一p*∣2. For i ∈ 1..n,
the "2i,k-gap" term,山布卡(Pk) 一 2i,k(p*), is dealt with in a similar manner to Section C.5, but this
time not using monotonicity as in (36). This contributes Tk0 and the first term in lk. Finally, as we
sketch below, the “夕n+ι,k-gap" term contributes rk, Nk, qk, qk, and the last term in lk.
For the Wn+ι,k-gap”, that is,夕n+ι,k(Pk) 一 夕n+ι,k(p*), we have to depart from the analysis in
Section C.6 and use an alternative argument involving Xk. We now provide some details of this
argument: in the following, we use Bz as shorthand for B(z) for any vector z ∈ Rd. We begin the
analysis with
Ψn+1,k (Pk ) = hzk - xn+1,yk+1 - wk+1i
=hzk - xn+ι, Bxn+ι 一 wn+ιi + (zk - χn+ι, ek).	⑻)
、-------{-----}
part of rk0
The final term will combine with the term(xf+i — z*, eki coming from
-3n+1,k(P* ) = hz* - xn+1 ,wn+1 - yf+1i
=hz* 一 xn+ι, wn+i - BXn+ii + hxn+i - z*, en+ii	(82)
to yield rk above. Equation (82) also yields the second term in Ik. Using that Xk 一 χkb+ι = Pka, we
rewrite the first term in (81) as
hzk - xn+i, Bxn+i - wk+ii =(zk 一 χk, Bxn+i - wnk+ii +(xk - xk+i, Bxn+i - w3〉
=(zk -	Xk,	Bxn+i	- wk+ii	+ Pk (ek, Bxn+i	- wk+ii
=(zk -	Xk,	Bxn+i	— wk+ii	+ Pk (ek, Bxn+i	— BXki	(83)
+ Pk hek, BXk — wk+ii .
、-------{z-------}
rk
Next, the terms in (83) admit the lower bound
hzk - Xk, Bxn+i - wk+ii + Pkhek, Bxn+i - BXki
≥ hzk 一 Xk, Bxn+i - wk+ii -PkkekkkBxn+i - BXkk ∙
、---------------------------------------{z----------}
first part of qk0
Considering the first term on right-hand side of this bound, we also have
(zk 一 Xk, Bxn+i	- wn+ii =	(zk	一 Xk, BXk	- wk+ii	+ (zk 一 Xk,Bxn+i 一 BXki
≥	(zk	- Xk, BXk	- wk+ii	- dkzk - Xkk2 — 2dkBXk -	Bxn+ik2
、-------{-----------}
second part of qk0
for any d > 0, using Young’s inequality. Finally, for the first two terms of the right-hand side of the
above relation, we may write
(zk-Xk,BXk - wn+ii — dkzk - Xkk2
=(zk 一 Xk,Bzk - wn+ii + (zk 一 Xk,BXk 一 Bzki - dkzk - Xk||2
≥ (P-J d∕2)kzk - Xk k2 Tlzk - Xk kkBXk 一 Bzk k,
'--------------------V----------------------}
qk
36
Under review as a conference paper at ICLR 2022
where in the final inequality we use the Cauchy-Schwartz inequality and substitute Bzk - wnk+1 =
P-1(zk - Xk)，from the definition of Xk in (80). We have now accounted for all the terms appearing
in (79).
The recursion (79) is analogous to equation (F.7) on page 24 of Hsieh et al. (2020) and provides
the starting point for the local convergence analysis. The next step would be to derive an analog of
Theorem F.1. of Hsieh et al. (2020) using (79). The following translation to the notation of Theorem
F.1. could be used (note that Hsieh et al. (2020) uses t for iteration counter):
Dk = IIpk -p*∣∣2,
ζk = c2αkρk(Tk0 + lk) + c3αkqk,
ξk = -c2αkρkrk - c3αkrk0 ,
χk = c1αk(kek k2 + IIEk k2 + kpk - p*∣∣2 + c4)+ c5αk qk,
and the event E∞ρ is translated to
E∞ = {xf+l ∈ Br (Z) χk ∈ Bρr (z* ),pk ∈ Bρr (p* ) for all k = 1, 2,…} ∙
An analog of Theorem 2 of Hsieh et al. (2020) could then be developed based on this result.
37