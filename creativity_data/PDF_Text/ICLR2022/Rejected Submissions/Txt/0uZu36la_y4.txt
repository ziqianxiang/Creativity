Under review as a conference paper at ICLR 2022
Protect the weak:	Class-focused online
LEARNING FOR ADVERSARIAL TRAINING
Anonymous authors
Paper under double-blind review
Ab stract
Adversarial training promises a defense against adversarial perturbations in terms
of average accuracy. In this work, we identify that the focus on the average ac-
curacy metric can create vulnerabilities to the “weakest” class. For instance, on
CIFAR10, where the average accuracy is 47%, the worst class accuracy can be as
low as 14%. The performance sacrifice of the weakest class can be detrimental
for real-world systems, if indeed the threat model can adversarially choose the
class to attack. To this end, we propose to explicitly minimize the worst class er-
ror, which results in a min-max-max optimization formulation. We provide high
probability convergence guarantees of the worst class loss for our method, dubbed
as class focused online learning (CFOL), using techniques from the online learn-
ing community. CFOL can be plugged into existing training setups with virtually
no overhead in computation. We observe significant improvements on the worst
class accuracy of 30% for CIFAR10. We also observe consistent behavior across
CIFAR100 and STL10. Intriugingly, we find that minimizing the worst case can
even sometimes improve the average.
1	Introduction
The susceptibility of neural networks to adversarial noise (Goodfellow et al., 2014; Szegedy et al.,
2013) has been a grave concern over the launch of such systems in real-world applications. Sev-
eral techniques defending such attacks that optimize the average performance have been proposed
(Papernot et al., 2016; Raghunathan et al., 2018; Guo et al., 2017; Madry et al., 2017; Zhang et al.,
2019). In response, even stronger attacks have been proposed (Carlini & Wagner, 2016; Engstrom
et al., 2018; Carlini, 2019). Indeed, recent studies demonstrate that regardless of the defense there
exists an attack that can lower the average performance of the system (Shafahi et al., 2018).
In this work, we argue that the average performance is not the only criterion that is of interest
for real-world applications. For classification, in particular, optimizing the average performance
provides no guarantees for the “weakest” class. This is critical in scenarios where an attacker can
pick the class adversarially in addition to the adversarial perturbation. It turns out that the worst
performing class can indeed be much worse than the average in adversarial training. This difference
is already present in clean training but we critically observe, that the gap between the average and the
worst, is greatly exacerbated in adversarial training. This gap can already be observed on CIFAR10
where the accuracy across classes is far from uniform with 47% average robust accuracy while the
worst class is 14% (see Figure 1). The effect is even more prevalent when more classes are present
as in CIFAR100 where we observe that the worst class has zero accuracy while the best has 70% (see
Appendix C where we include multiple other datasets). Despite the focus on adverarial training, we
note that the same effect can be observed for robust evaluation after clean training (see Figure 4).
This dramatic drop in accuracy for the weakest classes begs for different approaches than the clas-
sical empirical risk minimization (ERM), which focuses squarely on the average loss. We suggest
a simple alternative, which we dub class focused online learning (CFOL), that can be plugged into
existing adversarial training procedures. Instead of minimizing the average performance over the
dataset we sample from an adversarial distribution over classes that is learned jointly with the model
parameters. In this way we aim at becoming robust to an attacker that can adversarially choose the
class. The focus of this paper is thus on the robust accuracy of the weakest classes instead of the
average robust accuracy.
1
Under review as a conference paper at ICLR 2022
1.0 -T
>.L
2 0.8 -
3 0.6-
ω
W 0.4-
c
(Q
”.2-
0.0
Clean training
■ ■ --■ ■ ■・
Iiiiiiiiiii
1.0 J
>.
2 0.8-
ra 0.6
W 0.4
0.0
Adversa rial training
Ih■■川 ∣∣
Figure 1: The error across classes is already not perfectly uniform in clean training on CIFAR10.
However, this phenomenon is significantly worsened in adversarial training when considering the
robust accuracy. That is, some classes perform much worse than the average. The worst class
accuracy and average accuracy is depicted with a red and black line respectively.
⅞ 0-2
Concretely, we make the following contributions:
•	We propose a simple solution which relies on the classical bandit algorithm from the online
learning literature, namely the Exponential-weight algorithm for Exploration and Exploita-
tion (Exp3) (Auer et al., 2002). The method is directly compatible with standard adversar-
ial training procedures (Madry et al., 2017), by replacing the empirical distribution with an
adaptively learned adversarial distribution over classes.
•	We carry out extensive experiments comparing CFOL against three strong baselines across
three datasets, where we consistently observe that CFOL improves the weakest classes.
•	We support the empirical results with high probability convergence guarantees for the worst
class accuracy and establish direct connection with the conditional value at risk (CVaR)
(Rockafellar et al., 2000) uncertainty set from the distributional robust optimization.
Overview We define our new objective in Section 2, followed by the description of the proposed
method in Section 3. In Section 3.1 we prove convergence guarantees. We then move to the empiri-
cal work in Section 4, where we observe and resolve the issue of robust overfitting in the context of
the worst class. Our main empirical findings are covered in Section 5 and we conclude in Section 6.
1.1 Related work
Adversarial examples Goodfellow et al. (2014); Szegedy et al. (2013) are the first to make the
important observation that deep neural networks are vulnerable to small adversarially perturbation
of the input. Since then, there has been a growing body of literature addressing this safety critical
issue, spanning from certified robust model (Raghunathan et al., 2018), distillation (Papernot et al.,
2016), input augmentation (Guo et al., 2017), to adversarial training (Madry et al., 2017; Zhang
et al., 2019). We focus on adversarial training in this paper. While certified robustness is desirable,
adversarial training remains one of the most successful defenses in practice.
In a concurrent work Tian et al. (2021) independently observe the non-uniform accuracy over classes
in adversarial training, further strengthening the case that lack of class-wise robustness is indeed an
issue. However, they mainly focus on constructing an attack that can enlarge this disparity.
Minimizing the maximum Connected to our method is that of focused online learning (FOL)
(Shalev-Shwartz & Wexler, 2016), which similarly takes a bandit approach, but instead re-weights
the distribution over the N training examples, independent of the class label. This naturally leads
to a convergence rate in terms of the number of examples N instead of the number of classes k for
which usually k N. We compare in more detail theoretically and empirically in Section 3.1 and
Section 5 respectively.
Interpolations between average and maximum loss have been considered in various other settings:
for class imbalanced datasets (Lin et al., 2017), in federated learning (Li et al., 2019), and more
generally the tilted empirical risk minimization (Li et al., 2020; Lee et al., 2020).
2
Under review as a conference paper at ICLR 2022
Distributional robust optimization The accuracy over the worst class can be seen as a particular
re-weighing the data distribution which adversarially assigns all weight to a single class. Worst
case perturbation of the data distribution have more generally been studied under the framework of
distributional robust stochastic optimization (DRO) (Ben-Tal et al., 2013; Shapiro, 2017). Instead of
attempting to minimizing the empirical risk on a training distribution P0 , this framework considers
some uncertainty set around the training distribution U(P0) and seeks to minimize the worst case
risk within this set, suPq∈u(p0)Ex~q['(x)].
A choice of uncertainty set, which has been given significant attention in the community, is condi-
tional value at risk (CVaR), which aims at minimizing the weighted average of the tail risk (Rock-
afellar et al., 2000; Levy et al., 2020; Kawaguchi & Lu, 2020; Fan et al., 2017; Curi et al., 2019).
CVaR has been specialized to a re-weighting over class labels, namely labeled conditional value at
risk (LCVaR) (Xu et al., 2020). This was originally derived in the context of imbalanced dataset to
re-balance the classes. It is still applicable in our setting and we thus provide a comparison. The
original empirical work of (Xu et al., 2020) only considers the full-batch setting. We complement
this by demonstrating LCVaR in a stochastic setting.
In Duchi et al. (2019); Duchi & Namkoong (2018) they are, similarly to our setting, interested in
uniform performance over various groups. However, these groups are assumed to be latent subpop-
ulations, which introduces significant complications. It is thus concerned with a different setting, an
example being training on a dataset implicitly consisting of multiple text corpora.
CFOL can also be formulated in the framework of DRO by choosing an uncertainty set that can
re-weight the k class-conditional risks. The precise definition is given in Appendix B.1. We further
establish a direct connection between the uncertainty sets of CFOL and CVaR that we make precise
in Appendix B.1, which also contains a summary of the most relevant related methods in Table 4.
2 Problem formulation and preliminaries
Notation The underlying data distribution is denoted by D with examples x ∈ Rd and classes
y ∈ [k]. A given iteration is characterized by t ∈ [T], while pty indicates the yth index of the
tth iterate. The indicator function is denoted with 1{boolean} and unif(n) indicates the uniform
distribution over n elements. An overview of the notation is provided in Appendix A.
In classification, We are normally interested in minimizing the population risk E(χ,y)~D ['(θ, x, y)]
over our model parameters θ ∈ Rp , where ` is some loss function of θ and example x ∈ Rd with
an associated class y ∈ [k]. Madry et al. (2017) formalized adversarially training by modifying
this objective with an adversarial perturbation to each example. That is, we instead want to find a
parameterization θ of our predictive model which solves the following optimization problem:
min L(θ) :
E(x,y)~D max '(θ,x + δ,y)
(1)
where each x is now perturbed by adversarial noise δ ∈ S ⊆ Rd . Common choices of S include
norm-ball constraints as in Madry et al. (2017) or bounding some notion of perceptual distance
(Laidlaw et al., 2020). When the distribution over classes is uniform this is implicitly minimizing
the average loss over all class. This does not guarantee high accuracy for the worst class as illustrated
in Figure 1, since we only know with certainty that max ≥ avg.
Instead, we will focus on a different objective, namely minimizing the worst class-conditioned risk:
minmax < Ly(θ) := Eχ~p0(∙∣y)
θ y∈[k]
max `(θ, x + δ, y )
(2)
This follows the philosophy that “a chain is only as strong as its weakest link”. In our particular
setting it models a scenario where the attacker can adversarially choose what class the model is
evaluated on. In safety critical application, such as autonomous driving, modeling even just a single
class wrong can still have catastrophic consequences.
As the maximum in Equation 2 is a discrete maximization problem its treatment requires more care.
We will take a common approach and construct a convex relaxation to this problem in Section 3.
3
Under review as a conference paper at ICLR 2022
Class sampling distribution
0.15-
0.10-
0.00
IlllnIIU
Figure 2: Contrary to ERM, which samples the examples uniformly, CFOL samples from an adap-
tive distribution. The learned adversarial distribution is non-uniform over the classes in CIFAR10
when using adversarial training. As expected, the hardest classes are also most frequently sampled.
3 Method
Since we do not have access to the true distribution D, we will instead minimize over the provided
empirical distribution. Let Ny be the set of data point indices for class y such that the total number
of examples is N = Pyk=1 |Ny|. Then, we are interested in minimizing the maximum empirical
class-conditioned risk,
1
maxLy(θ) :=	max'(θ,Xi + δ,y).
y∈[k]	|Ny| i∈Ny δ∈S
(3)
We relax this discrete problem to a continuous problem over the simplex ∆k,
k
max
y∈[k]
Lby(θ) ≤
pm∈a∆xk	pyLby(θ).
y=1
(4)
Note that equality is attained when p is a dirac on the argmax over classes.
Equation 4 leaves us with a two-player zero-sum game between the model parameters θ and the
class distribution p. From the perspective of p it is just a linear objective, albeit adversarially picked
by the model. This immediately let us use a no-regret algorithm under simplex constraint, namely
Hedge (Freund & Schapire, 1997):
k
Wy=WyT- ηLy(θt), pty=eχp (Wy)/ Xeχp (Wy).
(Hedge)
y=1
To show convergence for (Hedge) the loss needs to satisfy certain assumptions. In our case of
classification, the loss is the zero-one loss '(θ, x, y) = l[hθ(x) = y], where hθ(∙) is the predictive
model. Hence, the loss is bounded, which is a sufficient requirement.
Note that (Hedge) relies on zero-order information of the loss, which we indeed have available.
However, in the current form, (Hedge) requires so called full information over the k dimensional
loss vector. In other words, we need to compute Ly(θ) for all y ∈ [k] at every iteration. When
accessing the data through mini-batches, it is strictly not possible to compute even an estimate for
each y if the number of classes is larger than the batch size.
Following the seminal work of Auer et al. (2002), we instead construct an unbiased estimator of the
k dimensional loss vector L(θt) := (L1(θt), ..., Lk(θt))> based on a sampled class yt from some
distribution yt 〜pt. This stochastic formulation further lets US estimate the class conditioned risk
Lyt (θt) with an unbiased sample i 〜unif(∣Nyt |). This leaves US with the following estimator,
Lt = J LyMMPty y = yt
otherwise
(5)
0
4
Under review as a conference paper at ICLR 2022
Algorithm 1: Class focused online learning (CFOL)
Algorithm parameters: a step rule ModelUpdate for the model satisfying Assumption 1,
adversarial step-size η > 0, uniform mixing parameter γ = 1/2, and the loss Ly,i (θ).
Initialization: Set w0 = 0 such that q0 and p0 are uniform.
foreach t in 0..T do
yt 〜pt ；	// sample class
it 〜unif(∣Nyt |) ;	// sample uniformly from class
θt+1 = ModelUpdate(θt, Lyt,it (θt)) ;	// update model parameters
t	tt
Ly = l{y=yt}Ly,it (θt)/Py ∀y ；	// construct estimator
t+1 t	t
wyt+1 = wyt - ηLty ∀y ;	// update the adv. class distribution
qy+1 = exp (wy+1) / Pk=I exp (wj+1) ∀y;
pt+1 = Y k + (I-Y)qy+1 ∀y;
end foreach
where Ly,i (θ) := maxδ∈S ` (θ, xi + δ, y). It is easy to verify that this estimator is unbiased,
bt
Ey〜PhLyi= (1 -py) ∙ 0 + Py ∙ ~y-t- = Ly(θt).	⑹
py
For ease of presentation the estimator only uses a single sample but this can trivially be extended to
a mini-batch where classes are drawn i.i.d. from Pt .
We could pick Pt to be the learned adversarial distribution, but it is well known that this can lead to
unbounded regret if some Pty is small (see Appendix A for definition of regret). Auer et al. (2002)
resolves this problem with Exp3, which instead learns a distribution qt, then mixes it with a uniform
distribution, to eventually sample from Py = Y1 + (1 - Y)qy where Y ∈ (0, 1). Intuitively, this
enforces exploration. In the general case this Y needs to be picked carefully and small enough, but
similarly to Shalev-Shwartz & Wexler (2016), we show that Y = 1/2 suffice in our setting.
Our algorithm thus updates qt+1 with (Hedge) using the estimator Let with sample drawn from Pt and
subsequently plays Pt+1 . CFOL in conjunction with the simultaneous update of the minimization
player can be found in algorithm 1 with an example of a learned distribution Pt in Figure 2.
Practically, the scheme bears negligible computational overhead over ERM since the softmax re-
quired to sample is of the same dimensionality as the softmax used in the forward pass through
the model. This computation is negligible in comparison with backpropagating through the entire
model. For further details on the implementation we refer to Appendix C.4
3.1	Conv ergence r ate
To understand what kind of result we can expect, it is worth entertaining a hypothetical worst case
scenario. Imagine a classification problem where one class is much harder to model than the re-
maining classes. We would expect the learning algorithm to require exposure to examples from the
hard class in order to model that class appropriately—otherwise the classes would not be distinct.
From this one can see why ERM might be slow. The algorithm would naively pass over the entire
dataset in order to improve the hard class using only the fraction of examples belonging that class.
In contrast, if we can adaptively focus on the difficult class, we can avoid spending time on classes
that are already improved sufficiently. As long as we can adapt fast enough, as expressed through
the regret of the adversary, we should be able to improve on the convergence rate for the worst class.
We will now make this intuition precise by establishing a high probability convergence guarantee for
the worst class loss analogue to that of FOL. For this we will assume that the model parameterized
by θ enjoys a so called mistake bound of C (Shalev-Shwartz et al., 2011, p. 288). The proof is
deferred to appendix A.
5
Under review as a conference paper at ICLR 2022
Assumption 1. For any sequence of classes (y1, ..., yT) ∈ [k]T and class conditioned sample in-
dices (i1, ..., iT) with it ∈ Nyt the model enjoys the following bound for some C0 < ∞ and
C = max{k log k, C0},
T
XLyt,it(θt)≤C.	(7)
t=1
Remark 1. The requirement C ≥ k log k will be needed to satisfy the mild step-size requirement
η ≤ 2k in Lemma 1. In most settings the smallest C0 is some fraction of the number of iterations T,
which in turn is much larger than the number of classes k, so C = C0 .
With this at hand we are ready to state the convergence of the worst class-conditioned empirical risk.
Theorem 1. If algorithm 1 is run on bounded rewards Lyt,it (θt) ∈ [0, 1] ∀t with step-size η =
，log k∕(4kC), mixing parameter Y = 1∕2 and the model satisfies Assumption 1, then after T
iterations with probability at least 1 - δ,
1 S b (j “ 6C，4k log(2k∕δ) (1 + 2k) log(2k∕δ) ,2log(2k∕δ) 2log(2k∕δ)
max n j=1 Ly (θ)≤ 亍+—√T—+------------------------3T--------+—√n— +	3n
(8)
for an ensemble ofsize n where tj % Unif(T) for j ∈ [n].
To contextualize Theorem 1, let us consider the simple case of linear binary classification mentioned
in Shalev-Shwartz & Wexler (2016). In this setting SGD needs O(CN) iterations to obtain a con-
sistent hypothesis. In contrast, the iteration requirement of FOL decomposes into a sum O(C + N)
which is much smaller since both C and N are large. When we are only concerned with the con-
vergence of the worst class we show that CFOL can converge as O(C + k) where usually k C.
Connecting this back to our motivational example in the beginning of this section, this sum decom-
position exactly captures our intuition. That is, adaptively focusing the class distribution can avoid
the learning algorithm from needlessly going over all k classes in order to improve just one of them.
From Theorem 1 we also see that we need an ensemble of size n = Ω(dlog(k∕δ)∕ε2), which has
only mild dependency on the number of classes k. If we wanted to drive the worst class error εto
zero the dependency on ε would be problematic. However, for adversarial training, even in the best
case of the CIFAR10 dataset, the average error is larger than 1∕2. We can expect the worst class error
to be even worse, so that only a small n is required. In practice, a single model turns out to suffice.
Note that the maximum upper bounds the average, so by minimizing this upper bound as in The-
orem 1, we are implicitly still minimizing the usual average loss. In addition, Theorem 1 shows
that a mixing parameter of γ = 1∕2 is sufficient for minimizing the worst class loss. Effectively, the
average loss is still directly being minimized, but only through half of the sampled examples.
4	Experimental setup: overcoming robust overfitting
Robust overfitting is a well-documented challenge in adversarial training (Rice et al., 2020; Pang
et al., 2020). This phenomenon is characterized by a rapid drop in the validation accuracy shortly
after the first piecewise step-size decay. The reported models in the literature are indeed early
stopped prior to the second step-size decay (e.g., in Madry et al. (2017); Zhang et al. (2019)). This
is particularly problematic when interested in the worst class accuracy, which might not be aligned
with the average performance across training epochs. Below, we conduct preliminary experiments
on CIFAR10 confirming this problem and propose a solution. We adopt the setup for adversarial
training with PGD in Madry et al. (2017) with the stepsize scheduling from Zhang et al. (2019). We
consider adversarial training on the empirical distribution (ERM-AT) and adversarial training on the
jointly learned adversarially class distribution (CFOL-AT).
With ERM-AT the worst class has only 14% robust test accuracy when early stopping based on the
average accuracy. Early stopping based on the worst class can improve on the worst class accuracy,
but only marginally, as we show in the supplementary (see Table 5). This minor improvement comes
at a huge cost for the average accuracy which drops from 47% to 38%. Ideally both metrics should
instead increase monotonically.
6
Under review as a conference paper at ICLR 2022
Table 1: Robust accuracy on CIFAR10 under early stopping without temporal ensembling. The
number in parenthesis indicates the epoch of piecewise constant step-size decay. For CFOL-AT to
consistently converge it was necessary to decay earlier than the usual decay at epoch 75. Fortunately,
known regularization techniques mitigate this problem which leads to our main results in Section 5.
	ERM-AT (75)	ERM-AT (33)	CFOL-AT (33)
Average	0.47	0.45	0.42
Worst class	0.14	0.13	0.27
For CFOL-AT the problem of robust overfitting presents itself differently. The worst class accuracy
improves much more rapidly, reaching 27% even when early stopped based on the average accuracy.
Note that this is not surprising and is in line with the convergence rate derived in Section 3.1. The
implication is that we are required to run CFOL-AT for a shorter time to get consistent performance
and carefully select the step-size decay point. This limited training time, due to the earlier overfitting,
unfortunately restricts the expressivity of the model. We show comparison with both ERM-AT with
similar early step-size decay and also more standard step-size decay of Zhang et al. (2019) in Table 1.
Although we see a significant improvement from 14% to 27% in terms of the worst class we ideally
want the method be stable for more iterations.
To avoid the root problem of overfitting, we regularize the training objective. We adopt temporal
ensembling (TE) which is a regularization technique that was shown to mitigate overfitting in ad-
versarial training (Laine & Aila, 2016; Dong et al., 2021). This allows us to reliably run CFOL-AT
under exactly the same training configuration as ERM-AT and thus prevents further hyperparameter
tuning. Additionally, TE leads to a more fair comparison with ERM-AT, which enjoys an improve-
ment in terms of the worst class robust accuracy from 14% to 21%. We make use of this additional
regularization in all subsequent experiments. In this work we focus on the robust accuracy. How-
ever, we add a cautionary note, since we observe that TE can lead to a reduction in clean accuracy
(see Table 6).
5	Experiments
We consider the common adversarial setting where the constraint set of the attacker S is '∞-bounded
attacks. We test on three datasets with different dimensionality, number of examples per class and
number of classes. Specifically, we consider CIFAR10, CIFAR100 and STL10 (Krizhevsky et al.,
2009; Coates et al., 2011) (see Appendix C.2 for further details).
Hyper-parameters Unless otherwise noted, we use the standard adversarial training setup of a
ResNet50 network (He et al., 2016) with a learning rate τ = 0.1, momentum of 0.9, weight decay
of 5 ∙ 10-4, batch size of 128 (Madry et al., 2017) with a piece-wise constant weight decay of 0.1 at
epoch 75 and 90 for a total of 100 epochs according to Zhang et al. (2019), as well as regularizing
with temporal ensembling as explained in Section 4. For the attack we similarly adopt the common
attack radius of 8/255 using 7 steps of projected gradient descent (PGD) with a step-size of 2/255
(Madry et al., 2017). For STL10 we adopt the learning rate τ = 0.01 and use a batch-size of 64 to
fit it inside our hardware. For evaluation we use the stronger attack of 20 step PGD.
Baselines With this setup we compare our proposed method, CFOL, against empirical risk mini-
mization (ERM), labeled conditional value at risk (LCVaR) (Xu et al., 2020) and focused online
learning (FOL) (Shalev-Shwartz & Wexler, 2016). We add the suffix ”AT” to all methods to indicate
that the training examples are adversarially perturbed according to adversarial training of Madry
et al. (2017). We consider ERM-AT as the core baseline, while we also implement FOL-AT and
LCVaR-AT as alternative methods that can improve the worst performing class. For fair compar-
ison, and to match existing literature, we do early stopping based on the average robust accuracy
on the hold-out set. More details on hyperparameters and implementation can be found in Ap-
pendix C.1 and Appendix C.4 respectively. In Table 10 we additionally provide experiments for a
variant of CFOL-AT which instead reweighs the gradients.
Metrics We report the average accuracy, the worst class accuracy and the accuracy across the 20%
worst classes (referred to as the 20% tail) for both clean (accclean) and robust accuracy (accrob). The
7
Under review as a conference paper at ICLR 2022
mean and standard deviation in all tables are computed over 5 independent executions. We note that
the aim is not to be state-of-the-art but rather provide a fair comparison between the methods.
The first core experiment is conducted on CIFAR10. In Table 2 the quantitative results are re-
ported with the accuracy per class illustrated in Figure 3. The results reveal that all methods other
than ERM-AT improve the worst performing class with CFOL-AT obtaining higher accuracy in the
weakest class than all methods in both the clean and the robust case. Interestingly, FOL-AT per-
forms better than LCVaR-AT, so for the next experiments we simply consider FOL as the non-ERM
comparison method.
The results for the remaining datasets can be found in Table 3. The results exhibit similar patterns
to the experiment on CIFAR10, where CFOL-AT improves both the worst performing class and the
20% tail. In the supplementary, we also provide results for early stopped models using the best worst
class accuracy from the validation set (see Table 7), larger attack radius (see Table 8), and a different
test time attack (see Table 9). In all cases, we observe that CFOL-AT has consistently improved
accuracy with respect to the weakest class (and the 20% tail). We note that early stopping based on
the worst class is not sufficient to make ERM-AT competitive with CFOL-AT.
We find that CFOL-AT consistently improves the accuracy for both the worst class and the 20% tail
across the three datasets. At the same time, the average performance only suffers a minor reduction.
The improvement seem to be even more noticeable in terms of the clean accuracy. Interestingly,
FOL-AT improves even the average accuracy on CIFAR10 while having small variance, suggestion
that sometimes focusing on the worst cases can improve the average.
Table 2: Accuracy on CIFAR10. For both clean test accuracy (accclean) and robust test accuracy
(accrob) we report the average, 20% worst classes and the worst class. We compare our method
(CFOL-AT) with standard adversarial training (ERM-AT) and two baselines (LCVaR-AT and FOL-
AT). CFOL-AT significantly improves the robust accuracy for both the worst class and the 20% tail,
while only incurring a small reduction in the average robust accuracy in comparison with ERM-AT.
	ERM-AT	CFOL-AT	LCVaR-AT	FOL-AT
Average	0.74 ± 0.01	0.75 ± 0.00	0.75 ± 0.01	0.79 ± 0.01
accclean	20% tail	0.52 ± 0.03	0.66 ± 0.01	0.54 ± 0.02	0.61 ± 0.03
Worst class	0.48 ± 0.04	0.63 ± 0.02	0.51 ± 0.03	0.56 ± 0.03
Average	0.47 ± 0.02	0.46 ± 0.00	0.46 ± 0.03	0.50 ± 0.00
accrob	20% tail	0.24 ± 0.02	0.31 ± 0.02	0.23 ± 0.02	0.28 ± 0.02
Worst class	0.21 ± 0.02	0.30 ± 0.01	0.20 ± 0.01	0.22 ± 0.03
ERM-AT
CFOL-AT
H*i -id 豹
i4ltι⅛⅜⅛⅛ i Illnlllll
U. U Iiiiiiiiii	U. U Iiiiiiiiii
0.0
0.0
Figure 3: The robust test accuracy for CFOL-AT and ERM-AT over classes. The horizontal black
and red line depicts the average and worst class accuracy over the classes respectively. The im-
provement in the minimum accuracy is notable when using CFOL-AT, while there is only marginal
difference in the average accuracy.
8
Under review as a conference paper at ICLR 2022
Table 3: Clean test accuracy (accclean) and robust test accuracy (accrob) on CIFAR100 and STL10.
We compare our method (CFOL-AT) with standard adversarial training (ERM-AT) and two base-
lines (LCVaR-AT and FOL-AT). CFOL-AT consistently improves the worst class accuracy as well
as the 20% worst tail.
	ERM-AT			CFOL-AT	FOL-AT
		Average	0.54 ± 0.02	0.52 ± 0.05	0.53 ± 0.01
	accclean	20% tail	0.30 ± 0.04	0.35 ± 0.06	0.31 ± 0.04
CIFAR100		Worst class	0.12 ± 0.04	0.19 ± 0.04	0.17 ± 0.04
		Average	0.27 ± 0.00	0.24 ± 0.02	0.26 ± 0.00
	accrob	20% tail	0.07 ± 0.02	0.09 ± 0.03	0.07 ± 0.02
		Worst class	0.01 ± 0.01	0.03 ± 0.02	0.01 ± 0.01
		Average	0.55 ± 0.03	0.55 ± 0.02	0.54 ± 0.02
	accclean	20% tail	0.25 ± 0.10	0.42 ± 0.08	0.27 ± 0.07
STL10		Worst class	0.23 ± 0.09	0.38 ± 0.07	0.22 ± 0.02
		Average	0.35 ± 0.01	0.34 ± 0.01	0.35 ± 0.01
	accrob	20% tail	0.09 ± 0.03	0.18 ± 0.03	0.11 ± 0.04
		Worst class	0.07 ± 0.03	0.16 ± 0.03	0.07 ± 0.01
6	Conclusion
In this work, we have introduced a method for class focused online learning (CFOL), which samples
from an adversarial learned distribution over classes. We establish high probability convergence
results of the worst class for CFOL through a specialized regret analysis. In the context of adversarial
examples this is motivated by an adversarial threat model in which the attacker chooses what class
to evaluate on in addition to the perturbation. We conduct a thorough empirical validation on three
datasets. The empirical results for adversarial training consistently demonstrate the improvement
over the weakest classes. The work opens up for multiple interesting research avenues. Firstly, our
method can also be applied in non-adversarial settings, and in the future we intend to look further
into the challenging cases of non-uniform distribution over classes. Secondly, it remains open to
establish generalization bounds for CFOL. Finally, it is interesting to understand why adversarial
perturbations leads to inhomogeneous accuracies over classes.
References
Jean-Yves Audibert, Sebastien Bubeck, and Remi Munos. Bandit view on noisy optimization. In
Optimization for Machine Learning, chapter 1. MIT Press, optimization for machine learning
edition, January 2010.
Peter Auer, Nicolo Cesa-Bianchi, Yoav Freund, and Robert E. SchaPire. The nonstoChastic multi-
armed bandit problem. SIAM Journal on Computing, 32(1):48-77, January 2002. ISSN 0097-
5397, 1095-7111. doi: 10.1137/S0097539701398375.
Aharon Ben-Tal, Dick Den Hertog, Anja De Waegenaere, Bertrand Melenberg, and Gijs Rennen.
Robust solutions of optimization problems affected by uncertain probabilities. Management Sci-
ence, 59(2):341-357, 2013.
Nicholas Carlini. Is ami (attacks meet interpretability) robust to adversarial examples? arXiv
preprint arXiv:1902.02322, 2019.
Nicholas Carlini and David Wagner. Defensive distillation is not robust to adversarial examples.
arXiv preprint arXiv:1607.04311, 2016.
Adam Coates, Andrew Ng, and Honglak Lee. An analysis of single-layer networks in unsupervised
feature learning. In Proceedings of the fourteenth international conference on artificial intelli-
gence and statistics, pp. 215-223. JMLR Workshop and Conference Proceedings, 2011.
9
Under review as a conference paper at ICLR 2022
Francesco Croce and Matthias Hein. Reliable evaluation of adversarial robustness with an ensemble
of diverse parameter-free attacks. In International conference on machine learning, pp. 2206-
2216. PMLR, 2020.
Sebastian Curi, Kfir Levy, Stefanie Jegelka, Andreas Krause, et al. Adaptive sampling for stochastic
risk-averse learning. arXiv preprint arXiv:1910.12511, 2019.
Yinpeng Dong, Ke Xu, Xiao Yang, Tianyu Pang, Zhijie Deng, Hang Su, and Jun Zhu. Exploring
memorization in adversarial training. arXiv preprint arXiv:2106.01606, 2021.
John Duchi and Hongseok Namkoong. Learning models with uniform performance via distribution-
ally robust optimization. arXiv preprint arXiv:1810.08750, 2018.
John C Duchi, Tatsunori Hashimoto, and Hongseok Namkoong. Distributionally robust losses
against mixture covariate shifts. Under review, 2019.
Logan Engstrom, Andrew Ilyas, and Anish Athalye. Evaluating and understanding the robustness
of adversarial logit pairing. arXiv preprint arXiv:1807.10272, 2018.
Yanbo Fan, Siwei Lyu, Yiming Ying, and Bao-Gang Hu. Learning with average top-k loss. arXiv
preprint arXiv:1705.08826, 2017.
Yoav Freund and Robert E Schapire. A decision-theoretic generalization of on-line learning and an
application to boosting. Journal of computer and system sciences, 55(1):119-139, 1997.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014.
Chuan Guo, Mayank Rana, Moustapha Cisse, and Laurens Van Der Maaten. Countering adversarial
images using input transformations. arXiv preprint arXiv:1711.00117, 2017.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016.
Kenji Kawaguchi and Haihao Lu. Ordered sgd: A new stochastic optimization framework for em-
pirical risk minimization. In International Conference on Artificial Intelligence and Statistics, pp.
669-679. PMLR, 2020.
Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images.
2009.
Cassidy Laidlaw, Sahil Singla, and Soheil Feizi. Perceptual adversarial robustness: Defense against
unseen threat models. arXiv preprint arXiv:2006.12655, 2020.
Samuli Laine and Timo Aila. Temporal ensembling for semi-supervised learning. arXiv preprint
arXiv:1610.02242, 2016.
Jaeho Lee, Sejun Park, and Jinwoo Shin. Learning bounds for risk-sensitive learning. arXiv preprint
arXiv:2006.08138, 2020.
Daniel Levy, Yair Carmon, John C Duchi, and Aaron Sidford. Large-scale methods for distribution-
ally robust optimization. arXiv preprint arXiv:2010.05893, 2020.
Tian Li, Maziar Sanjabi, Ahmad Beirami, and Virginia Smith. Fair resource allocation in federated
learning. arXiv preprint arXiv:1905.10497, 2019.
Tian Li, Ahmad Beirami, Maziar Sanjabi, and Virginia Smith. Tilted empirical risk minimization.
arXiv preprint arXiv:2007.01162, 2020.
TsUng-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, and Piotr Dollar. Focal loss for dense
object detection. In Proceedings of the IEEE international conference on computer vision, pp.
2980-2988, 2017.
10
Under review as a conference paper at ICLR 2022
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu.
Towards deep learning models resistant to adversarial attacks. arXiv preprint arXiv:1706.06083,
2017.
Tianyu Pang, Xiao Yang, Yinpeng Dong, Hang Su, and Jun Zhu. Bag of tricks for adversarial
training. arXiv preprint arXiv:2010.00467, 2020.
Nicolas Papernot, Patrick McDaniel, Xi Wu, Somesh Jha, and Ananthram Swami. Distillation as a
defense to adversarial perturbations against deep neural networks. In 2016 IEEE symposium on
security and privacy (SP),pp. 582-597. IEEE, 2016.
Aditi Raghunathan, Jacob Steinhardt, and Percy Liang. Certified defenses against adversarial exam-
ples. arXiv preprint arXiv:1801.09344, 2018.
Leslie Rice, Eric Wong, and Zico Kolter. Overfitting in adversarially robust deep learning. In
International Conference on Machine Learning, pp. 8093-8104. PMLR, 2020.
R Tyrrell Rockafellar, Stanislav Uryasev, et al. Optimization of conditional value-at-risk. Journal
of risk, 2:21-42, 2000.
Ali Shafahi, W Ronny Huang, Christoph Studer, Soheil Feizi, and Tom Goldstein. Are adversarial
examples inevitable? arXiv preprint arXiv:1809.02104, 2018.
Shai Shalev-Shwartz and Yonatan Wexler. Minimizing the maximal loss: How and why. In Inter-
national Conference on Machine Learning, pp. 793-801. PMLR, 2016.
Shai Shalev-Shwartz et al. Online learning and online convex optimization. Foundations and trends
in Machine Learning, 4(2):107-194, 2011.
Alexander Shapiro. Distributionally robust stochastic programming. SIAM Journal on Optimization,
27(4):2258-2275, 2017.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
Qi Tian, Kun Kuang, Kelu Jiang, Fei Wu, and Yisen Wang. Analysis and applications of class-wise
robustness in adversarial training. arXiv preprint arXiv:2105.14240, 2021.
Ziyu Xu, Chen Dan, Justin Khim, and Pradeep Ravikumar. Class-weighted classification: Trade-
offs and robust approaches. In International Conference on Machine Learning, pp. 10544-10554.
PMLR, 2020.
Hongyang Zhang, Yaodong Yu, Jiantao Jiao, Eric Xing, Laurent El Ghaoui, and Michael Jordan.
Theoretically principled trade-off between robustness and accuracy. In International Conference
on Machine Learning, pp. 7472-7482. PMLR, 2019.
11
Under review as a conference paper at ICLR 2022
A Convergence analysis
A. 1 Preliminary and notation
Consider the abstract online learning problem where for every t ∈ [T] the player chooses an action
Xt and subsequently the environment reveals the loss function l(∙,yt). As traditional in the online
learning literature we will measure performance in terms of regret, which compares our sequence of
choices {xt }tT=1 with a fixed strategy in hindsight u,
TT
RT (u) = X l(xt, yt) - mxinXl(u,yt).	(9)
t=1	x t=1
If we, instead of minimizing over losses l, maximize over rewards r we define regret as,
TT
RT (u) = max X r(u, yt) - X r(xt, yt).	(10)
x
t=1	t=1
When we allow randomized strategy, as in the bandit setting, RT becomes a random variable that
we wish to upper bound with high probability. For convenience we include an overview over the
notation defined and used in Section 2 and Section 3 below.
k	Number of classes
T	Number of iterations
Pty	The yth index of the tth iterate
!{boolean}	The indicator function
unif (n)	Discrete uniform distribution over n elements
Ny	Set of data point indices for class y ∈ [k]
N = Pyk=1 |Ny|	The size of the data set
Ly,i (θ) := maχδ∈S ` (θ, xi	+ δ, y) Loss on a particular example
b1 Ly (θ) := ∣Ny∣ ∑i∈Ny Ly,i	(θ)	The empirical class-conditioned risk
P ∕c∖	∕?	∕C∖	P / Zi∖ ∖ T	EI	.	CIl	♦ ♦	1	1	-∣∙ .∙	1	♦ 1 L (θ) := (L1 (θ) , . . . , Lk (θ))>	The vector of all empirical class-conditioned risks	
Lty := Ly,i (θt)	Class-conditioned estimator at iteration t with i 〜 unif(|Ny|)
A.2 Convergence results
We restate Algorithm 1 while leaving out the details of the classifier for convenience. Initialize w0
such that q0 and p0 are uniform. Then Exp3 proceeds for every t ∈ [T] as follows:
1.	Draw class yt 〜pt
2.	Observe a scalar reward Ltyt
tt	t
3.	Construct estimator Ly = Lyt l{y=yt}/Py ∀y
4.	Update distribution
≠-Ul	十	τr≠
wt+1 = wt - ηLt
qy+1 = eχp (wy+1) / Py=I eχp (wy+1) ∀y
py+1 = Y k +(I- Y )qy+1 ∀y
We can bound the regret of Exp3 (Auer et al., 2002) in our setting, even when the mixing parameter
Y is not small as otherwise usually required, by following a similar argument as Shalev-Shwartz &
Wexler (2016).
For this We will use the relationship between P and q throughout. From Py = Y + (1 - Y )qy it can
easily be verified that,
≤ ≤ - and qy ≤ --— for all y.	(11)
Py Y	Py	1 - Y
12
Under review as a conference paper at ICLR 2022
Lemma 1. IfExp3 is run on bounded rewards Lyt ∈ [0,1] ∀t with η ≤ γ∕k then
RTdv (U)=X hu,Lti- X "W； XXXLy
(12)
Lt
Proof. We can write the estimator vector as Lt = + evt
pyt y
where eyt is a canonical basis vector.
By assumption we have Ltyt ∈ [0, 1]. Combining this with the bound on 1∕py in Equation 11 we
1	t / L / C	11	EI ∙ 1	♦	1 /Cl 1	CI	.	. 1 CCT Λ EI	C CC∖	1	. 1
have Lty ≤ k∕γ for all y. This lets us invoke (Shalev-Shwartz et al., 2011, Thm 2.22) as long as the
step-size η is small enough. Specifically, we have that if η ≤ 1∕Lety ≤ γ∕k
T	T	Tk
X hu,Lti- X hqt,Lti≤ 叶 + η ∑∑ qy (Ly )2.
t=1	t=1	t=1 y=1
(13)
1 ʌ	1 ∙	t	1	1	. 1	1 ∙ . ∙	Γ∙	1 ■	. ∙	Λ Λ	. ∙ 1 i~ .1	1	1
By expanding Lty and applying the inequalities from Equation 11 we can get rid of the dependency
on q and p,
等+η XXXX qy (Ly )2 ≤ 等+η XXX M (Lyt )2
η t=1 y=1	η t=1 (pyt)
T
≤ 也 + η X ɪ(Lyt )2
η t=1 (1 -γ)γ y
≤ logk +	ηk	X Lt
≤ F + [可=yt,
where the last line uses the boundedness assumption Lty ∈ [0, 1] ∀y.
(14)
It is apparent that we need to control the sum of losses. We will do so by assuming that the model
admits a mistake bound as in Shalev-Shwartz & Wexler (2016); Shalev-Shwartz et al. (2011).
Assumption 1. For any sequence of classes (y1, ..., yT) ∈ [k]T and class conditioned sample
indices (i1, ..., iT) with it ∈ Nyt the model enjoys the following bound for some C0 < ∞ and
C = max{k log k, C0},
T
X Lyt,it (θt) ≤ C.	(15)
t=1
Recall that we need to bound Lty := Ly,it (θt), where y are picked adversarially and it are sampled
uniformly, so the above is sufficient.
Lemma 2. If the model satisfies Assumption 1 and algorithm 1 is run on bounded rewards
Lytit (θt) ∈ [0,1] ∀t with step-size η = ,log k∕(4kC) and mixing coefficient Y = 1∕2 then
T
Xhu,LLti ≤ 6C.	(16)
t=1
Proof. By expanding and rearranging Lemma 1,
T
Xhu,LLti ≤
t=1
log k
η
(17)
as long as η ≤ γ∕k. Then by using our favorite inequality in Equation 11 and under Assumption 1,
log k
η
log k
η
J+⅛ )C,
(18)
13
Under review as a conference paper at ICLR 2022
To maximize (1 - γ)γ) we now pick γ = 1/2 so that,
logk + (7τJ + ɪ) C ≤ logk + (4ηk + 2) C.	(19)
η (1 - γ)γ	1 - γ	η
For η, notice that it appears in two of the terms. To minimize the bound respect to η We pick
η = ʌ/log k∕(4kC) such that loηgk = 4ηkC, which leaves Us with,
logk + (4ηk + 2)C ≤ 2,4kClog k + 2C.	(20)
η
From the first term it is clear that since C ≥ k log k by assumption then the original step-size
requirement ofη ≤ 1/2k is satisfies. In this case we can additionally simplify further,
2P4kC log k + 2C ≤ 6C.	(21)
This still only gives us a bound on a stochastic object. We will now relate it to the empirical class
conditional risk Ly(θ) by using standard concentration bounds. To be more precise, we want to
t
show that by picking u = ey in hu, Lti we concentrate to Ly (θ). Following Shalev-Shwartz &
Wexler (2016) we adopt their use of a Bernstein’s type inequality.
Lemma 3 (e.g. Audibert et al. (2010, Thm. 1.2)). Let A1, ..., AT be a martingale differ-
ence sequence with respect to a Markovian sequence B1, ..., BT and assume |At| ≤ V and
E At2 | B1 , . . . , Bt ≤ s. Then for any δ ∈ (0, 1),
P (T XX At ≤ ps」V^0g≡! ≥ 1 - δ.	(22)
Lemma 4. If algorithm 1 is run on bounded rewards Lyt,it (θt) ∈ [0, 1] ∀t with step-size η =
，log k∕(4kC), mixing coefficient Y = 1∕2 and the model SatisfiesAssumption 1, thenforany y ∈ [k]
we obtain have the following bound with probability at least 1 一 δ∕k,
1 XX b (An < 6C	P4k log(k∕δ)	(1 + 2k) log (k∕δ)
T⅛Ly (θ) ≤ 亍 + ―√T— +---------------3T-----.	(23)
Proof. Pick any y ∈ [k] and let u = ey in hu, Lti. By construction the following defines a martingale
difference sequence,
At = Ly (θt) -hey, Lti = Ly (θt) - hey, ~t~ Lyt,it (θt)eyt i.	(24)
pyt
In particular note that it is uniformly sampled. To apply the Bernstein’s type inequality we just need
to bound |At| and E At2 | qt, θt . For |At| we can crudely bound it as,
IAt | ≤ ILy (θt )| + Ihey, ~Γ Lytit (θt)eyt i| ≤ 1 + 二，	(25)
pyt	γ
To bound the variance observe that we have the following:
E hhey, Leti2 I
k
qt,θti≤X
y0=1
(Pty )2 E [Ly0,i(θt)2 | θt] (ey)y0
(with i 〜unif(∣Nyo |) ∀y0)
:E hLy,i W)[ θti
py
1k
≤ —r ≤ -.
p pty - Y
It follows that E [At2 I qt, θt] ≤ k∕γ
(by Equation 11)
14
Under review as a conference paper at ICLR 2022
Invoking Lemma 3 We get the following bound with probability at least 1 - δ∕k,
1T	1T
T X Ly W) ≤ T Xhey ,Lt i +
t=1	t=1
J2k bg (W)	(1 + Y)log(k∕δ)
√T	+	3t
(26)
By bounding the first term on the right hand side with Lemma 2 and taking γ = 1∕2 we obtain,
1 X b (At)‹ 6C J P4k log (k/" i (1 + 2k)IOg(A/"	nηλ
T⅛Ly (θ) ≤ 亍 + —√t— +----------------3T-------	(27)
This completes the proof.
We are now ready to state the main theorem.
Theorem 1. If algorithm 1 is run on bounded rewards Lyt,it (θt) ∈ [0, 1] ∀t with step-size η =
，log k∕(4kC), mixing parameter Y = 1∕2 and the model satisfies Assumption 1, then after T
iterations with probability at least 1 - δ,
1 S b /At八 “ 6C, P4k log(2k∕δ) (1 + 2k) log(2k∕δ) ,2log(2k∕δ) 2log(2k∕δ)
max n j=1 Ly (θ ) ≤ TF+-√T—+-----------------------3T----------+—√n— +	3n
(28)
iid
for an ensemble ofsize n where tj 〜Unif(T) for j ∈ [n].
Proof. If we fix y and let tj iiid Unif(T) , then the following is a martingale difference sequence,
1T
Aj= Ly (θj) - T ELy (θt) ,	(29)
t=1
for which it is easy to see that |Aj | ≤ 2 and Aj2 ≤ 1 given boundedness of the loss. This readily let
us apply Lemma 3 with high probability 1 - δ∕2k. Combining this with the bound of Lemma 4 with
probability 1 - δ∕2k by using a union bound completes the proof.
B	CVAR
Conditional value at risk (CVaR) is the expected loss conditioned on being larger than the (1 - α)-
quantile. This has a distributional robust interpretation which for a discrete distribution can be
written as,
CVaRα (θ, P0) := sUp
p∈∆m
s.t. kpk∞ ≤α1m}∙
(30)
The optimal p of the above problem places uniform mass on the tail. Practically we can compute
this best response by sorting the losses {'(θ, Xi)}i in descending order and assigning αm mass per
index until saturation.
Primal CVaR When m is large a stochastic variant is necessary. To obtain a stochastic subgradient
for the model parameter, the naive approach is to compute a stochastic best response over a mini-
batch. This has been studied in detail in (Levy et al., 2020).
Dual CVaR An alternative formulation relies on strong duality of CVaR originally showed in
(Rockafellar et al., 2000),
CVaRa (θ, Po) = inf | λ +ɪ X (' (θ, Xi)- λ)+I .	(31)
λ∈R	αm	+
In practice, one approach is to jointly minimize λ and the model parameters by computing stochastic
gradients as done in (Curi et al., 2019). Alternatively, we can find a close form solution for λ under
a mini-batch (see e.g. (Xu et al., 2020, Appendix I.1)).
15
Under review as a conference paper at ICLR 2022
In comparison CFOL acts directly on the probability distribution similarly to primal CVaR. How-
ever, instead of finding a best response on a uniformly sampled mini-batch it updates the weights
iteratively and samples accordingly (see algorithm 1). Despite this difference, it is interesting that
a direct connection can be established between the uncertainty sets of the methods. The following
section is dedicated to this.
To be pedantic it is worth pointing out a minor discrepancy when applying CVaR in the context
of deep learning. Common architectures such as ResNets incorporates batch normalization which
updates the running mean and variance on the forward pass. The implication is that the entire mini-
batch is used to update these statistics despite the gradient computation only relying on the worst
subset. This makes implementation in this setting slightly more convoluted.
B.1 Relationship with CVaR
Exp3 is run with a uniform mixing to enforce exploration. This turns out to imply the necessary and
sufficient condition for CVaR. We make this precise in the following lemma:
Lemma 5. Let P be a uniform mixing P = Y+ + (1 — γ)q with an arbitrary distribution q ∈ ∆m
and E ∈ [0,1] such that the distribution has a lower bound on each element Pi ≥ Y 煮.Then an
upper bound is implicitly implied on each element, kpk∞ := maxi=[m] Pi ≤ 1 — (mmI)Y.
Proof. Consider Pi for any i. At least (m — 1) m of the mass must be on other components so
Pi ≤ 1 — (mm1)γ. The result follows.	□
Corollary 1. Consider the uncertainty set of Exp3,
UExp3 (Po) = Pp ∈ ∆m | Pi ≥ Yɪ ∀i
m
(32)
Given that the above lower bound is only introduced for practical reasons, we might as well consider
an instantiation of CVaR which turns out to be a proper relaxation,
UCVaR (Po) = Pp ∈ ∆m | kPk∞ ≤	(33)
αm
with α = (ι-γ)m+γ. This leaves US with thefollowing primal formulation,
CVaRα (θ, Po) := sup
p∈∆m
s.t.帆岛 ≤ αm}.
(34)
Proof. From Lemma 5 and since CVaR requires ∣∣p∣∣∞ ≤ Om We have,
By simple algebra we have,
which completes the proof.
kPk∞ ≤ 1 - (m-1γ
m
1
(1 — Y)m+ Y,
1
αm
(35)
(36)
□
So if the starting point of the uncertainty set is the simplex and the uniform mixing in Exp3 is
therefore only for tractability reasons, then we might as well minimize the CVaR objective instead.
This could even potentially lead to a more robust solution as the uncertainty set is larger (since the
upper bound in U CVaR does not imply the lower bound in UExp3).
There are two things to keep in mind though. First, α should not be too small since the optimization
problem gets harder. It is informative to consider the case where Y = 1/2 such that α = m+ι.
From this it becomes clear that the recasting as CVaR only works for small m. Secondly, despite
the uncertainty sets being related, the training dynamics, and thus the obtained solution, can be
drastically different, as we also observe experimentally in Section 5. For instance CVaR is known
16
Under review as a conference paper at ICLR 2022
Table 4: Summary of methods where N is the number of samples and k is the number of classes.
The discrete distribution p either governs the distribution over all N samples or over the k classes
depending on the algorithm (see columns).
Uncertainty set
UExp3 (Po) = {p ∈ ∆m | Pi ≥ εm ∀i}
UCVaR (Po) = {p ∈ ∆m ∣kpk∞ ≤ Om}
Over data point (m = N)
FOL (ShaleV-ShWartz & Wexler, 2016)
CVaR (Levy et al., 2020)
Over class labels (m = k)
CFOL (ours)
LCVaR (Xu et al., 2020)
for haVing high Variance (Curi et al., 2019) While the uniform mixing in CFOL preVents this. It is
Worth noting that despite this uniform mixing We are still able to shoW conVergence for CFOL in
terms of the Worst class in Section 3.1.
In Table 4 We proVide an oVerVieW of the different methods induced by the choice of uncertainty set.
C Experiments
(a) kδk∞ = 1/255
(b) kδk∞ = 2/255
Figure 4: Robust test accuracy under different norm-ball sizes after clean training on CIFAR10. The
non-uniform distribution oVer class accuracies, eVen after clean training, indicates that the inferior
performance on some classes is nota consequence of adVersarial training. Rather, the inhomogeneity
after perturbation seems to be an inherent feature of the dataset.
Table 5: Robust accuracy after early stopping ERM-AT based on different metrics of the Validation
set. The indicated performance is on the test set. Notice that We only improVe the Worst class
marginally While suffering significantly in terms of aVerage accuracy if We early stop based on the
Worst class.
Early stopping metrics AVerage robust accuracy Worst class robust accuracy		
AVerage	0.47	0.38
Worst class	0.14	0.18
Table 6: Comparison betWeen standard adVersarial training (ERM-AT) With and Without temporal
ensembling (TE). TE improVes the robust accuracy on the Worst class While maintaining the aVerage
robust accuracy. HoWeVer, TE leads to a drop in terms of the clean accuracy.
		ERM-AT	ERM-AT (TE)
accclean	AVerage	082	0.74
	Worst class	0.54	0.51
accrob	AVerage	^^047	0.47
	Worst class	0.14	0.23
17
Under review as a conference paper at ICLR 2022
ɪ °	Clean training
δ10.8- ■	■_____________________.
l-l	III
ιιιιιιιιι
Figure 5: Clean training and adversarial training on CIFAR100 (top) and STL10 (bottom) using
ERM-AT with PGD-7 attacks at train time and PGD-20 attacks at test time for the robust test ac-
curacy. The CIFAR100 classes are sorted for convenience. Notice that CIFAR100 has a class with
zero robust accuracy with adversarial training.
ɪ	Adversarial training
X32∙lnuue ls∙,l lsnqo≈
ERM-AT	CFOL-AT
&0.6-
CFOL-AT
Figure 6: Robust class accuracy for CIFAR100 and STL10 respectively. Vertical black error bars in-
dicate one standard deviation. The red and black horizontal line indicates the minimum and average
respectively. The classes on both ERM-AT and CFOL-AT are ordered according to the accuracy on
ERM to make comparison easier.
≡≡⅛⅛
0.0
18
Under review as a conference paper at ICLR 2022
Table 7: For fair comparison we also consider early stopping based on the worst class accuracy on
the hold-out set. As can be observed the results for CFOL-AT do not differ significantly from early
stopping using the average robust accuracy, so standard training setups do not have to be modified
further.
			ERM-AT	CFOL-AT	FOL-AT
		Average	0.70 ± 0.05	0.73 ± 0.01	0.75 ± 0.01
	accclean	20% tail	0.53 ± 0.04	0.64 ± 0.04	0.59 ± 0.02
CIFAR10		Worst class	0.52 ± 0.03	0.62 ± 0.03	0.57 ± 0.01
		Average	0.44 ± 0.04	0.46 ± 0.01	0.48 ± 0.01
	accrob	20% tail	0.25 ± 0.01	0.33 ± 0.03	0.29 ± 0.02
		Worst class	0.24 ± 0.01	0.31 ± 0.02	0.27 ± 0.02
		Average	0.55 ± 0.01	0.51 ± 0.04	0.55 ± 0.01
	accclean	20% tail	0.33 ± 0.04	0.34 ± 0.06	0.33 ± 0.04
CIFAR100		Worst class	0.18 ± 0.02	0.19 ± 0.04	0.17 ± 0.03
		Average	0.27 ± 0.00	0.24 ± 0.02	0.26 ± 0.01
	accrob	20% tail	0.07 ± 0.02	0.09 ± 0.03	0.07 ± 0.02
		Worst class	0.01 ± 0.01	0.02 ± 0.02	0.01 ± 0.00
		Average	0.50 ± 0.05	0.54 ± 0.03	0.54 ± 0.02
	accclean	20% tail	0.28 ± 0.11	0.42 ± 0.08	0.35 ± 0.10
STL10		Worst class	0.23 ± 0.09	0.38 ± 0.09	0.29 ± 0.09
		Average	0.31 ± 0.03	0.33 ± 0.01	0.33 ± 0.03
	accrob	20% tail	0.10 ± 0.04	0.20 ± 0.02	0.14 ± 0.03
		Worst class	0.08 ± 0.04	0.17 ± 0.05	0.11 ± 0.02
Table 8: Comparison between different sizes of '∞-ball attacks on CIFAR10. The same constraint
is used at both training and test time. When the attack size is increased beyond the usual 8/255
constraint we still observe that CFOL-AT increases the robust accuracy for the weakest classes
while taking a minor drop in the average robust accuracy. Interestingly, the gap between ERM-AT
and CFOL-AT seems to enlarge. See Appendix C.2 for more detail on the attack hyperparameters.
				ERM-AT		CFOL-AT
				Average	0.73 ± 0.01	0.75 ± 0.00
			accclean	20% tail	0.51 ± 0.03	0.66 ± 0.01
kδk∞	≤	8/255		Worst class	0.47 ± 0.03	0.63 ± 0.02
				Average	0.47 ± 0.03	0.46 ± 0.00
			accrob	20% tail	0.24 ± 0.02	0.31 ± 0.02
				Worst class	0.20 ± 0.02	0.30 ± 0.01
				Average	0.63 ± 0.01	0.63 ± 0.01
			accclean	20% tail	0.31 ± 0.02	0.53 ± 0.01
kδk∞	≤	12/255		Worst class	0.26 ± 0.02	0.51 ± 0.01
				Average	0.38 ± 0.00	0.35 ± 0.00
			accrob	20% tail	0.12 ± 0.01	0.23 ± 0.02
				Worst class	0.09 ± 0.01	0.22 ± 0.02
19
Under review as a conference paper at ICLR 2022
Table 9: Model performance on CIFAR10 under AutoAttack (Croce & Hein, 2020). The models
still uses 7 steps of PGD at training time with a '∞-constraint of 8∕255. Only at test time is the attack
exchanged with AutoAttack under the same constraint. CFOL-AT is robust to AutoAttack in the
sense that the worst class performance is still improved. However, as expected, the performance is
worse for both methods in comparison with their respective 20-step PGD based attacks at test time.
	ERM-AT		CFOL-AT
	Average	0.74 ± 0.01	0.75 ± 0.00
accclean	20% tail	0.52 ± 0.03	0.66 ± 0.01
	Worst class	0.48 ± 0.04	0.63 ± 0.02
	Average	0.41 ± 0.03	0.40 ± 0.00
accrob	20% tail	0.17 ± 0.02	0.21 ± 0.02
	Worst class	0.12 ± 0.01	0.20 ± 0.01
Table 10: Reweighted variant of CFOL. Algorithm 1 samples from the adversarial distribution
p. Alternatively one can sample data points uniformly and instead reweight the gradients for the
model using p. In expectation, an update of these two schemes are equivalent. To see why,
observe that in CFOL the model has access to the gradient VθLy,i(θ). We can obtain an un-
biased estimator by instead reweighting a uniformly sampled class, i.e. Ey〜p,i [VθLy,i(θ)] =
Ey〜unif(k),i [kpyVLy,i(θ)]. With classes sampled uniformly the unbiased estimator for the ad-
versary becomes Ly『= l{y,=y}Lyk ∀y0. Thus, one update of CFOL and the reweighted variant
are equivalent in expectation. However, note that we additionally depended on the internals of the
model’s update rule and that the immediate equivalence we get is only in expectation. We test the
reweighted variant of CFOL-AT on CIFAR10 and observe similar results as for CFOL-AT.
	Average	accclean 20% tail	Worst class	Average	accrob 20% tail	Worst class
CFOL-AT (reweighted)	0.75	0.64	0.64	0.45	0.31	0.31
C.1 Hyperparameters
In this section we provide additional details to the hyperparameters specified in Section 5.
For all experiment we use data augmentation in the form of random cropping, random horizontal flip,
color jitter and 2 degrees random rotations. For temporal ensembling (TE) we use the parameters
in (Dong et al., 2021) and set the momentum to 0.9, balancing weight parameter to 30 along a
Gaussian ramp-up curve until epoch 50. See Appendix C.3 for precise definition of the regularization
technique.
For CFOL-AT We used the adversarial step-size η = 5 ∙ 10-6 across all datasets and the same
parameters as for ERM-AT described in Section 5. CFOL-AT seems to be reasonable robust to step-
size choice as seen in Table 11. Similarly for FOL-AT we use the same parameters as for ERM-AT
and set η = 5 ∙ 10-7 after optimizing based on the worst class robust accuracy. With both methods
we make an exception with STL10, where, due to the fewer iterations induced by the 5 times smaller
dataset, we scale the adversarial step-size linearly by the dataset ratio 5, such that an equally strong
attack can be obtained.
The adversarial step-size picked for both FOL-AT and CFOL-AT is smaller in practice than theory
suggests. This suggests that the mistake bound in Assumption 1 is not satisfied for any sequence.
Instead we rely on the sampling process to be only mildly adversarial initially as implicitly enforced
by the small adversarial step-size. It is an interesting future direction to incorporate this implicit
tempering directly into the mixing parameter γ instead.
For LCVaR-AT we first optimized over the size of the uncertainty set by adjusting the parameter α.
Despite getting reasonable performance for some run with α = 0.2 the method turned out to have
large variance. For this reason we explored reducing the model learning rate τ for which we found
that τ = 0.05 gave better performance while having much smaller variance. It is not surprising that
20
Under review as a conference paper at ICLR 2022
the method requires smaller step-sizes given how CVaR methods assign higher weight to a fraction
of the batch at every iteration as explained in Appendix B. Maybe unnecessarily meticulous, we
also ensure that temporal ensembling indeed improves model performance for LCVaR-AT by also
running the method without the regularization. Our instantiation of LCVaR-AT used for comparison
thus uses α = 0.2 and τ = 0.05.
The hyperparameter exploration can be found in Table 11.
Table 11: Hyperparameter exploration for CFOL-AT, LCVaR-AT and FOL-AT.
Parameters	accrob	accclean
	TE	T	η			α	Average	Worst class	Average	Worst class
	Yes	0.1	1	×	10-6	-	0.49	0.30	0.75	0.56
CFOL-AT	Yes	0.1	2	×	10-6	-	0.49	0.30	0.76	0.61
	Yes	0.1	5	×	10-6	-	0.47	0.30	0.76	0.65
	Yes	0.1	5	×	10-5	-	0.46	0.31	0.75	0.64
	No	0.1	-			-0.2-	0.44	0.15	0.81	0.56
	Yes	0.01	-			0.2	0.48	0.20	0.75	0.49
LCVaR-AT	Yes	0.05	-			0.2	0.48	0.22	0.74	0.52
	Yes	0.1	-			0.1	0.34	0.16	0.59	0.34
	Yes	0.1	-			0.2	0.46	0.20	0.73	0.50
	Yes	0.1	-			0.5	0.48	0.19	0.76	0.49
	Yes	0.1	2.5		× 10-7	-	0.50	0.19	0.77	0.48
FOL-AT	Yes	0.1	5	×	10-7	-	0.50	0.24	0.79	0.60
	Yes	0.1	1	×	10-6	-	0.50	0.22	0.80	0.55
C.2 Experimental setup
In this section we provide additional details for the experimental setup specified in Section 5. The
experiments are conducted on the following three datasets:
CIFAR10 50,000 training examples of 32 × 32 dimensional images and 10 classes.
CIFAR100 50,000 training examples of 32 × 32 dimensional images and 100 classes.
STL10 5000 training examples of 96 × 96 dimensional images and 10 classes.
As noted in Section 5 we use the average robust accuracy to early stop the model. In contrast with
common practice though, we use a validation set instead of the test set to avoid overfitting to the
test set. The class accuracies across the remaining two datasets, CIFAR100 and STL10, can be
found in Figure 6. We also include results when the model is early stopped based on the worst class
accuracy on the validation set in Table 7. The mean and standard deviation in all tables and figures
are computed over 5 runs. However, for CIFAR100 we conduct 6 experiments and pick the top 5 to
compute the statistics since all methods had one outlier with significantly worst performance.
A radius of 8/255 is used for the '∞ -constraint attack unless otherwise noted. For training We use 7
steps of PGD and a stepsize of 2/255. At test time we use 20 steps of PGD with a stepsize of 2.5 ×
8/2255. For 12∕255-bounded attacks we scale the training stepsize and test stepsize proportionally.
C.3 Temporal ensembling
Let fθ : Rd → Rk be a model parameterized by θ that assigns a probability distribution over the k
classes for any x ∈ Rd. Temporal ensembling (Laine & Aila, 2016; Dong et al., 2021) computes
a so called ensemble prediction for a given data example xi by maintaining an average over past
predictions, Vi J T ∙ Vi + (1 - T) ∙ fθ (xi), where T is the momentum term. Let' (fθ (X + δ), y)
be the training objective. A regularizing term is added to the training objective that encourages
predictions to stay close to Vi ,
n
min X max {' (fθ (Xi + δ) ,yi) + ω(t) ∙ kfθ (Xi + δ) -Vik2 卜
i=1	∈
(37)
21
Under review as a conference paper at ICLR 2022
where ω(t) is the balancing weight parameter. Usually ω(t) interpolates from 0 to some constant ω
along a Gaussian rampup curve. That is, ω(t) = ω ∙ exp (-5(1 - t)2) where t = min{皿表Phch, 1}.
C.4 Implementation
We provide pytorch pseudo code for how CFOL can be integrated into existing training setups in
Listing 1. FOL is similar in structure, but additionally requires associating a unique index with each
training example. This allows the sampling method to re-weight each example individually.
For LCVaR we use the implementation of (Xu et al., 2020), which uses the dual CVaR formulation
described in Appendix B. More specifically, LCVaR uses the variant which finds a closed form
solution for λ, since this was observed to be both faster and more stable in their work.
from torch.utils.data import DataLoader
sampler = ClassSampler(dataset, gamma=0.5)
dataloader = DataLoader(dataset, ..., sampler=sampler)
# Training loop:
for img,y in iter(dataloader):
#	attack img
#	compute gradients and update model
#	compute logits
adv_loss = logits.argmax(dim=-1) != y
sampler.batch_update(y, eta * adv_loss)
Listing 1: Pseudo code for CFOL.
22