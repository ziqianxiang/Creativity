Figure 1: Three coding schemes are tested: 1) random coding/ALONE, 2) hashing-based coding/theproposed method, and 3) learning-based coding scheme with autoencoder. For GloVe embeddings,we apply the hashing-based coding method on the pre-trained embedding. For metapath2vecand metapath2vec++ embeddings, we apply the hashing-based coding method on either the pre-trained embedding or the adjacency matrix from the graph. The horizontal line labeled with “raw”shows the performance of the original embeddings’ performance without any compression. The y-axis of each sub-figure is the performance measurement (the higher the better). See Section 5.1 formore details.
Figure 2: In this toy example, each codebook has 4 vectors (c = 4) and there are 4 distinctcodebooks (m = 4). There are two variants of the adopted decoder models: 1) a light version wherethe codebooks are NOT trainable and 2) a full version where the codebooks are trainable. W0 is atrainable vector for rescaling the intermediate representation (see Section 3.2).
Figure 3: The experiments are performed on metapath2vec for 100 times under two different bitlength settings: 24 bits and 32 bits. The distribution of the 100 outcomes (i.e., number of collisions)for each method is shown in the figure. The number of collisions is lower for median thresholdcomparing to zero threshold.
Figure 4:	The proposedmethod can be integrated withthe GraphSage model. TheCode Lookup is used to lookup the corresponding binarycode for each input node. TheDecoder is the system pre-sented in Figure 2 and con-verts the input binary codes toembeddings.
Figure 5: The experiment is performed on metapath2vec++ for 100 times under two differ-ent bit length settings: 24 bits and 32 bits. The distribution of the 100 outcomes (i.e., number ofcollisions) for each method is shown in the figure. The number of collisions is lower for medianthreshold comparing to zero threshold.
Figure 6: The experiment is performed for 100 times in four different scenarios with GloVeembedding: 1) 20 bit code, 2) 24 bit code, 3) 28 bit code, 4) 32 bit code. The distribution of the100 outcomes (i.e., number of collisions) for each method is shown in the figure. The number ofcollisions is lower for median threshold comparing to zero threshold.
