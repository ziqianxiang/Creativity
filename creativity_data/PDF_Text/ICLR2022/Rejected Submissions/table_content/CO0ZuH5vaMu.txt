Table 1: Match accuracy of parallel datasets created using various document similarity methods.
Table 2: Pseudo-match accuracy of datasets created by different document similarity methods on 50subsampled problems from CodeNet. Pseudo-match accuracy computes True if the matched codesample is from the same problem set, and False otherwise.
Table 3: Model performance on the Java 什 C# dataset matched using various document similaritymethods. Each method introduces a different amount of noise in the resulting dataset (see Table 1)thereby affecting the performance.
Table 4: Most similar code samples across various language pairs asidentified by the WMD metricC → Python dataset: Similarity: 0.75#include <stdio.h>#include <math.h>int main(){int n;int i;double x1, x2, x3, y1, y2, y3, px, py, r;scanf("%d", &n);for(i = 0; i < n; i++){scanf("%lf %lf %lf %lf %lf %lf",,→ , &y2, &x3, &y3);&x1, &y1, &x2px = ((y2 - y3)*(x1*x1 + y1*y1) + (y3 - y1)*(,→ x2*x2 + y2*y2) + (y1 - y2)*(x3*x3 +,→ y3*y3))/(2*(x1*(y2 - y3) + x2*(y3 -,→ y1) + x3*(y1 - y2)));py = ((x2 - x3)*(x1*x1 + y1*y1) + (x3 - x1)*(
Table 5: Number of data samples for each code translation dataset. Each row represents the sourcelanguage, while each column represents the target language. Due to the skewed number of submis-sions in different languages in the CodeNet dataset, we see the same in the created parallel dataset.
Table 6: Examples of correct and incorrect translations given the sourcecode to a PLBART model fine-tuned on a dataset matched using theWMD metricC → Python translation		Source C code	Correct Python translation	Incorrect Python translation#include <stdio.h> int main(void) { long n; scanf("%ld", &n); long a[n]; for (long i = 0; i < n; i++) { scanf("%ld", &a[i]); } for (long i = 0; i < n; i++) { if (a[i]%2 != 0) { printf("first\n"); return 0; } } printf("second\n"); return 0; }	n = int(input()) a = list(map(int, input().split() ,→ )) for i in range(n): if a[i]%2 != 0: print("first") exit() print("second")	n = int(input()) a = list(map(int, input().split() ,→ )) for i in range(n): if a[i]%2 == 0: print("first") exit() print("second")C# → Java translation		Source C# code	Correct Java translation	Incorrect Java translationusing System; namespace Tenka1A { class Program { static void Main(string[] args) { string[] input = Console. ,→ ReadLine().Split(’ ’); int A = int.Parse(input[0]); int B = int.Parse(input[1]); int C = int.Parse(input[2]); bool flg = false; if (A > B) { if (C > B&&A>C) { flg = true; } }else if (B>A) { if (B>C&&C>A) { flg=true; } } if (flg) { Console.WriteLine("Yes"); } else { Console.WriteLine("No"); } } } }	import java.util.Scanner; public class Main { public static void main(String[] ,→ args) { Scanner sc = new Scanner(System. ,→ in); int A = sc.nextInt(); int B = sc.nextInt(); int C = sc.nextInt(); boolean flg = false; if (A > B) { if (C > B && A>C) { flg = true; } } else if (A < B) { if (B>C && C>A) { flg = true; } } if (flg) { System.out.println("Yes"); } else { System.out.println("No"); } } }	import java.util.Scanner; public class Main { public static void main(String[] ,→ args) { Scanner sc = new Scanner(System. ,→ in); int A = sc.nextInt(); int B = sc.nextInt(); int C = sc.nextInt(); boolean flg = false; if (A > B) { if (C > B && A>C) { flg = true; } } else if (A < B) { if (B>C && A>C) { flg = true; } } if (flg) { System.out.println("Yes"); } else { System.out.println("No"); } sc.close(); } }C++ → Ruby translation		Source C++ code	Correct RUby translation	Incorrect Ruby translation19Under review as a conference paper at ICLR 2022#include <cstdio> #include <iostream> #include <algorithm> #include <cstring> #include <cmath> using namespace std; typedef long long LL; int n,k,ans = 0,flg = 0; int a[500005]; int mx[500005] = {0}; int main(){ ios::sync_with_stdio(false); cin >> n; memset(mx,-0x3f,sizeof(mx)); mx[0] = 0; for(int i = 1;i <= n;i ++) cin ,→ >> a[i]; for(int i = 1;i <= n;i ++){ if(a[i] == 1) flg = 1; mx[a[i]] = max(mx[a[i]],mx[a[i] ,→ - 1] + 1); ans = max(ans,mx[a[i]]); } if(!flg) cout << -1 << endl; else cout << n - ans << endl; return 0; }	N = gets.to_i as = gets.split.map(&:to_i) mx = Array.new(N + 1, -Float:: ,→ INFINITY) mx[0] = 0 as.each do |a| if a == 1 mx[a] = 1 elsif mx[a] < mx[a - 1] mx[a] = mx[a - 1] + 1 end end puts N - mx.max	N = gets.to_i as = gets.split.map(&:to_i) mx = Array.new(N + 1, -Float:: ,→ INFINITY) mx[0] = 0 as.each do |a| if a == 1 mx[a] = 1 elsif mx[a] < mx[a - 1] mx[a] = mx[a - 1] + 1 end end ans = N - (mx.max + 1) puts ansJava → Ruby translation		Source Java code	Correct RUby translation	Incorrect Ruby translationimport java.util.HashMap; import java.util.Map; import java.util.Scanner; public class Main { public static void main(String[] ,→ args) throws Exception ,→	{ // File file = new File("test. ,→ txt"); // Scanner sc = new Scanner(file ,→ ); Scanner sc = new Scanner(System. ,→ in); int n = sc.nextInt(); Map<Integer, Boolean> map = new ,→ HashMap<>(); for(int i = 0; i < n; i++){ int a = sc.nextInt(); if(null != map.get(a)){ System.out.println("NO"); sc.close(); return; }else{ map.put(a, true);; } } sc.close(); System.out.println("YES"); } }	n = gets.to_i a = gets.split.map(&:to_i) h = Hash.new(0) a.each do |i| h[i] += 1 end puts h.values.all? { |v| v == 1 } ,→	? "YES" : "NO"	n = gets.to_i a = gets.split.map(&:to_i) h = Hash.new(0) a.each do |i| h[i] += 1 end puts h.values.all? { |v| v == 0 } ,→	? "YES" : "NO"Javascript → C translation		Source JavaScript code	Correct C translation	Incorrect C translation20
