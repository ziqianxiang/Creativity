Published as a conference paper at ICLR 2022
Autoregressive Diffusion Models
Emiel Hoogeboom； Alexey A. Gritsenko, Jasmijn Bastings, Ben Poole,
Rianne van den Berg, Tim Salimans
Google Research
e.hoogeboom@uva.nl,{agritsenko,pooleb,bastings,salimans}@google.com,
riannevdberg@gmail.com
Ab stract
We introduce Autoregressive Diffusion Models (ARDMs), a model class encom-
passing and generalizing order-agnostic autoregressive models (Uria et al., 2014)
and absorbing discrete diffusion (Austin et al., 2021), which we show are special
cases of ARDMs under mild assumptions. ARDMs are simple to implement and
easy to train. Unlike standard ARMs, they do not require causal masking of model
representations, and can be trained using an efficient objective similar to modern
probabilistic diffusion models that scales favourably to highly-dimensional data.
At test time, ARDMs support parallel generation which can be adapted to fit any
given generation budget. We find that ARDMs require significantly fewer steps
than discrete diffusion models to attain the same performance. Finally, we apply
ARDMs to lossless compression, and show that they are uniquely suited to this
task. Contrary to existing approaches based on bits-back coding, ARDMs obtain
compelling results not only on complete datasets, but also on compressing single
data points. Moreover, this can be done using a modest number of network calls
for (de)compression due to the model’s adaptable parallel generation.
1 Introduction
Deep generative models have made great progress in modelling different sources of data, such as
images, text and audio. These models have a wide variety of applications, such as denoising, in-
painting, translating and representation learning. A popular type of likelihood-based models are
Autoregressive Models (ARMs). ARMs model a high-dimensional joint distribution as a factor-
ization of conditionals using the probability chain rule. Although very effective, ARMs require a
pre-specified order in which to generate data, which may not be an obvious choice for some data
modalities, for example images. Further, although the likelihood of ARMs can be retrieved with a
single neural network call, sampling from a model requires the same number of network calls as the
dimensionality of the data.
Recently, modern probabilistic diffusion models have introduced a new training paradigm: Instead
of optimizing the entire likelihood of a datapoint, a component of the likelihood bound can be
sampled and optimized instead. Works on diffusion on discrete spaces (Sohl-Dickstein et al., 2015;
* Work done during as research intern at Google Brain.
Figure 1: Generation of Autoregressive Diffusion Models for the generation order σ = (3, 1, 2, 4).
Filled circles in the first and third layers represent respectively the input and output variables, and
the middle layer represents internal activations of the network.
1
Published as a conference paper at ICLR 2022
Hoogeboom et al., 2021; Austin et al., 2021) describe a discrete destruction process for which the
inverse generative process is learned with categorical distributions. However, the length of these
processes may need to be large to attain good performance, which leads to a large number of network
calls to sample from or evaluate the likelihood with discrete diffusion.
In this work we introduce Autoregressive Diffusion Models (ARDMs), a variant of autoregressive
models that learns to generate in any order. ARDMs generalize order agnostic autoregressive models
and discrete diffusion models. We show that ARDMs have several benefits: In contrast to standard
ARMs, they impose no architectural constraints on the neural networks used to predict the dis-
tribution parameters. Further, ARDMs require significantly fewer steps than absorbing models to
attain the same performance. In addition, using dynamic programming approaches developed for
diffusion models, ARDMs can be parallelized to generate multiple tokens simultaneously without a
substantial reduction in performance. Empirically we demonstrate that ARDMs perform similarly
to or better than discrete diffusion models while being more efficient in modelling steps. The main
contributions of this paper can be summarized as follows: 1) We introduce ARDMs, a variant of
order-agnostic ARMs which include the ability to upscale variables. 2) We derive an equivalence
between ARDMs and absorbing diffusion under a continuous time limit. 3) We show that ARDMs
can have parallelized inference and generation processes, a property that among other things admits
competitive lossless compression with a modest number of network calls.
2	Background
ARMs factorize a multivariate distribution into a product of D univariate distributions using the
probability chain rule. In this case the log-likelihood of such as model is given by:
D
log p(x) =	logp(xt |x<t),	(1)
t=1
where x<t is shorthand for x1, x2, . . . , xt-1. ARMs are trained by ensuring that the neural network
has a triangular dependency structure, for instance implemented via causal masking. Although
this allows parallelized computation of the likelihood for all conditional distributions at once, to
sample from the model it requires D iterative sampling steps xi 〜p(xi), χ2 〜p(χ2 |xi) towards
XD 〜p(xD ∣X1,X2, . . . ,XD-l).
Order Agnostic ARMs Order Agnostic ARMs (OA-ARMs) (Uria et al., 2014) generate variables
with a random ordering σ ∈ SD , where SD represents a set of all permutations of the integers
1, . . . , D . The log-likelihood of this model is given by:
D
log p(x) ≥ Eσ 〜U (SD)	log P(Xσ(t)∣Xσ(<t)).	(2)
t=1
This can be seen as a latent variable model and the log-likelihood is derived via Jensen’s inequality:
logp(x) = logEσ〜U(SD)p(x∣σ) ≥ Eσ〜U(SD) logp(x∣σ).
Mind that hereafter we leave out σ in our notation to avoid clutter. One approach to train OA-ARMs
is the procedure as described by Yang et al. (2019) for XLNet. It takes a permutation equivariant
network such as a Transformer that is causally masked. Then, inputs are permuted and outputs
are permuted back according to a given order, which models the sequence in that specific order.
However, such approaches typically suffer in likelihood score and cannot be combined with simple
non-equivariant transformations such as convolutional layers.
Discrete Diffusion Discrete diffusion models define a destruction process on discrete data. An
example is absorbing diffusion (Austin et al., 2021), for which each variable has a probability of
decaying to an absorbing state. The opposite process to the destruction process is the learned gen-
erative process. This generative process models the distribution over variables that are currently
absorbed, and generates these with a probability.
3	Autoregressive Diffusion Models
We introduce Autoregressive Diffusion Models (ARDMs). ARDMs generate variables in an arbi-
trary order, one by one. Further, ARDMs are able to upscale variables, such as the bit values of a
2
Published as a conference paper at ICLR 2022
Algorithm 1 Sampling from OA-ARDMs
Input: Network f
Output: Sample x
Initialize x = 0
Sample σ 〜U(SD)
for t in {1, . . . , D} do
m J (σ < t) and n J (σ = t)
x0 〜C(x|f (m Θ x))
x J (1 - n)	x + n x0
Algorithm 2 Optimizing OA-ARDMs
Input: Datapoint x, Network f
Output: ELBO L
Sample t 〜U(1,...,D)
Sample σ 〜U(SD)
Compute m J (σ < t)
l J (1 - m) Θ log C(x|f(m Θ x))
Lt J D-1t+ι Sum(I)
LJ D ∙ Lt
pixel. Unlike standard ARMs, ARDMs are trained on a single step in the objective, as in modern
diffusion models. In addition, both sampling and inference of ARDMs can be parallelized using
dynamic programming with minimal degradation in log-likelihood.
Order Agnostic ARDMs The main difficulty of parameterizing an autoregressive model from
an engineering perspective, is the need to enforce the triangular or causal dependence. Especially
for 2D signals, this triangular dependence is difficult to enforce for arbitrary orders (Jain et al.,
2020) and tedious design is needed for multi-scale architectures (Salimans et al., 2017). To relax
this requirement, we take inspiration from modern diffusion-based generative models. Using these
insights, we derive an objective that is only optimized for a single step at a time. Starting at Equa-
tion 2, a different objective for an order agnostic ARM can be derived, by replacing the summation
over t by an expectation that is appropriately re-weighted:
log P(X) ≥ Eσ 〜U (SD ) PD=Ilog p(xσ(t)lxσ(<t))
=Eσ 〜U (SD )D ∙ Et 〜U (1,...,D) log P(Xσ(t)∣Xσ(<t))
=D ∙ Et 〜U (1,...,D)Eσ 〜U (SD ) D -1t + 1 Pk∈σ(≥t) log P(Xk lxσ(<t))
Compactly, we can write the expected lower bound as:
log P(X) ≥ Et 〜U (1,...,D)[D ∙ Lt ], where Lt = D _； + 1 Eσ 〜U(SD) X log P(Xk ∣Xσ(<t)).
k∈σ(≥t)
Here the term Lt represents the likelihood component for step t. Importantly, we do not need to
optimize for all Lt terms of a datapoint simultaneously. Instead, for each datapoint in a minibatch
a single Lt term is optimized where t is sampled from a uniform distribution. This objective was
originally proposed by Uria et al. (2014) to train order-agnostic ARMs. We will develop ARDMs
starting from this perspective and refer to the special case of an order-agnostic ARM, as an order ag-
nostic ARDM (OA-ARDM). Interestingly, each Lt component can be seen as a BERT-like training
objective (Devlin et al., 2019), where exactly D - t + 1 tokens are masked and subsequently pre-
dicted. Therefore, an OA-ARDM is trained as a collection of D BERTs with loss terms Lt, which
contain the reweighting term。二十].Another insight is that this generative process is very similar
to absorbing diffusion, where the model aims to generate absorbed (or masked) variables. In certain
situations we might want to refer to loss terms instead of likelihood terms, so we define Lt = -Lt.
Parametrization We desire a parametrization for the
model distribution logP(Xk∣Xσ(<t)) for k ∈ σ(≥ t) for
all σ and t. For each σ and t it is in principle allowed
to have an entirely new neural network. However, this
would be very inconvenient as the number of t grows as
O(D) and the number of σ grows as O(D!). Instead,
a single neural network is utilized and shared for dif-
ferent σ and t. This is implemented by masking vari-
ables at the input, and predicting those at the output. To
be precise, we let X ∈ X = {1, 2, . . . , K}D represent
discrete variables with K classes and a neural network
f : X → RD×K that outputs probability vectors for
each dimension. Conditioning is done via masking: For
a given permutation array σ , we compute the element-
wise comparison m = σ < t which produces a Boolean
Figure 2: ARDM training step. This
step optimizes for step t = 2 for all
possible permutations σ simultaneously
which satisfy σ(1) = 3.
3
Published as a conference paper at ICLR 2022
mask. The mask is then used by predicting θ = f(m x), where denotes element-wise
multiplication. For each location k ∈ σ(≥ t), the log probability vectors θk are used. Letting
C(Xk ∣θk) denote a categorical distribution over Xk with class probabilities θk, We choose to model
log(χk ∣Xσ(<t)) = log C (Xk ∣θk). The locations of these relevant indices k ∈ σ(≥ t) are retrieved
by using the opposite mask 1 - m. The procedure to sample and optimize an ARDM with this
parametrization are given in Algorithms 1 and 2. A training step is visualized in Figure 2. Note that
opposed to Figure 1 where only a single output was used per step, in the train step all dimensions
that were masked are predicted simultaneously. Therefore, there are multiple variables to predict
which ensures there is sufficient signal to optimize the model.
For clarity some of the implementation details have been left out in the explanation above. However,
given that these are important for practical implementations, they are specified in the following. The
input to the function f may be different depending on the data modality: For images and audio,
the mask is applied to the input so that values are zero after feature normalization. The mask itself
is also concatenated to the input as an input representation, which allows the model to identify
whether a value is actually zero, or the value is in the absorbing state zero. For language the input
representation is augmented and absorbed values are instead set to a new class K + 1, in which case
there is no need to provide the mask itself as input to the model. More generally, we can represent
the masked state as an absorbing state vector a which has the same shape as x but only contains
a pre-specified value. The input to the network is then not the masked m x, but instead the
combination m x + (1 - m) a. In addition, the network f may also take the time component
t as input as is typically done in diffusion models (Ho et al., 2020). In summary the network takes
some additional inputs as θ = f(i, m, t) where i = m x + (1 - m) a and the processing of
x may be different depending on the type of data.
3.1	Parallelized ARDMs
An important property of our parametrization is that the distribution over multiple variables is pre-
dicted at the same time. In this section, we will leverage this parameterization to allow parallel
independent generation of variables. Essentially, we desire distributions over Xσ(t+k) for positive k
while conditioning only on xσ(<t). First we make an observation regarding a connection between
predicting future variables and our likelihood terms: For k = 1, 2, . . . , D - t:
Eσ [ log p(xσ(t+k) lxσ(<t))] = Eσ [ log P(Xσ(t) | xσ (<t) J = Lt,	(3)
due to the uniform expectation over permutations. In other words, it does not matter which step
t + k the model predicts, in expectation these all have the same associated likelihood. As a result,
order agnostic generation of k tokens independently, starting from the t-th variable will result in a
log-probability contribution of k ∙ Lt in a single step, whereas the traditional approach would take
k steps at the cost of Pik=1 Lt+i . This knowledge is sufficient to construct a dynamic programming
algorithm as described by Watson et al. (2021) to compute how many parallel steps to take at which
moment, given a budget. Since dynamic programming is typically described from a minimization
perspective we define the loss component Lt = -Lt, which is measured in bits. In terms of loss,
generating k variables at timestep t will cost k ∙ Lt bits. Further, we define the transition cost matrix
Lt,t+k = k ∙ Lt for positive integers k and Lt+k,t = 0 otherwise. So Lt,t+k exactly describes how
much it costs to model the next k variables in parallel starting at the t-th position for all relevant t
and k. Using this transition cost matrix, the dynamic programming algorithm can be utilized to find
which steps should be parallelized. For instance, in the example in Figure 3 a hypothetical 20-step
problem is given a budget of 5 steps. Typically, the algorithm will spend more steps on regions with
large differences between Lt components and fewer steps on regions where the Lt components are
--------tf. Lt
f1fl□∏n∏∏∏πnπnnnnnn-
Figure 3: Loss components for Parallelized ARDMs using a budget of 5 steps for a problem of 20
steps. Left: individual loss component for every step. Right: parallelized policy extracted from the
dynamic programming algorithm. Components of the same height are modelled simultaneously, so
they are inferred and generated in parallel.
4
Published as a conference paper at ICLR 2022
approximately equal. Parallelizing an ARDM may incur some cost, as for a well-calibrated model:
Lt = Eσ [ log p(Xσ(t+1)∣Xσ(<t))] ≤ Eσ [ lθg p(Xσ (t+1) | Xσ (<t + 1) )] = Lt + 1,	(4)
but can be traded off for faster generation because fewer steps are used. In other words, the loss com-
ponents Lt are monotonically decreasing over t and parallelizing a model incurs a cost, which the
algorithm aims to minimize. Recall that this is under the assumption that model is well-calibrated,
which is observed in practice. See Figure 3 for an example of a parallelized schedule.
3.2	Depth Upscaling ARDMs
Order agnostic ARDMs learn to generate variables in random order. As a result, decisions on very
detailed information (such as the least significant bit in an image) are modelled relatively early in
the generative process. Instead, we can structure the process into stages, where for each stage a
refinement of the variable is generated. We refer to this process as upscaling. For example, instead
of generating an entire 256-categorical variables at once, we can first generate the most significant
bit, and then the subsequent bits in order of significance. To define the process, it is helpful to first
imagine the opposite process to upscaling, which is the destructive process downscaling. Formally,
we can define maps via transition matrices P(i) that define how a data variable downscales from its
data value towards a common absorbing state. For simplicity assume single dimensional variables
at this moment. Denote the absorbing state as a one-hot vector x(0), where all values are zero except
at a prespecified index a so that x(a0) = 1. From a diffusion perspective, upscaling is complementary
to a downscaling destruction process where each variable decays by zeroing its least significant bit.
Let P(1), . . . , P(S) define a sequence of downscaling maps so that for any categorical one-hot data
variable X(S) ∈ {0,1}K, it holds that P(I) ∙ ... ∙ P(S) ∙ X(S) = x(0). In other words, any category
K decays to the common absorbing state after S downscaling maps. We now define the upscal-
ing generative process by learning the reverse of the downscaling map, specifically by modelling
P(X(S)IX(S-I)) ∙ ... ∙ p(x(2)|X(I))P(X(1)). The transition matrices allow easy transitions between
the different stage variable X(i) via the following rules:
X(S) = P(S+I)X(S+1) = P(s+1)X(S),	where P(S) = P(S) ∙ P(s+1) ∙ ... ∙ P(S).
The matrices P(i+1) are computed as cumulative matrix multiplications, and allow a transition di-
rectly from a datapoint X(S) to the corresponding downscaled variable X(i). This is particularly
useful during training, where the model will only be optimized for a single specific stage per data-
point. For implementations it is generally useful to
define P(S+1)
I as an identity matrix so that
the above equation also holds when s = S. To train Upscale ARDMs, we can extend Algorithm 2:
In addition to sampling a timestep t, a stage i 〜U(1,...,S) to optimize is sampled. For this par-
ticular stage, the ARDM models P(X(S) |X(S-1)) by sampling a permutation σ within the stage and
a timestep t within the stage. Every term P(X(S) |X(S-1)) represents a stage that is modelled with
an order agnostic ARDM. This highlights an interesting property of ARDMs: Although sampling
from a model may take up to D ∙ S steps, the training complexity has not changed by modelling
multiple stages. As a result, one can experiment with adding an arbitrary number of stages with-
out an increase in computational complexity during training. Depth upscaling is reminiscent of the
upscaling networks proposed in (Kalchbrenner et al., 2018; Menick & Kalchbrenner, 2019), with
the important differences that Upscale ARDMs model the variables order-agnostic and only utilize
a single neural network to parametrize all stages. For a more detailed explanation that includes the
dimensionality of the variables {X(S)} see Appendix A.
Bit Upscaling Depth upscaling is easiest demonstrated with an example, bit-upscaling. Consider
the task of generating a standard image with pixel values {0, . . . , 255} so that an image with D
dimensions can be represented by X(8) ∈ {0, 1}D×256 in onehot notation. Imagine a downscaling
process defined by the function that removes the i least significant bits: lsb§(k) = [k/2SC ∙ 2s, via
this function we can define our transition matrices:
Pl(,8k+1-S) = 1 if l = lsbS(k) and k ∈ Im(lsbS-1)	otherwise	Pl(,8k+1-S) = 0,
where {P(S)} are indexed starting at zero. Notice that in this case 8 stages to map every value to the
absorbing state 0, because lsb8(k) = 0 for any k ∈ {0, . . . , 255}. See Figure 4 for a visualization
of such matrices for a problem with less categories.
5
Published as a conference paper at ICLR 2022
□	□ Era	E□
E□
□ □	E□
H
P⑴	P⑵	P⑶
_口」」」_] □ΞE□	E□
m
Iiii	m
H
P⑴	P⑵	P⑶
Figure 4: Bit upscaling matrices for data with eight categories and hence three stages, meaning
S = 3. Entries that are white represent zeros, coloured entries represent ones.
Depth upscaling is not confined to bits, and indeed a more general formulation is given by the
downscaling map l = [k/b' ∙ bs, for a branching factor b. When b is set to 2, the bit upscaling
transitions are retrieved as a special case. When b is set to higher values, then variables can be
generated in fewer stages, S = dlogb (K)e to be exact. This allows for a unique trade-off between
the number of steps the model takes and the complexity that each modelling step inhibits. Other
hand-crafted transitions are also imaginable, not excluding transitions that augment the space to
new categories, but these are not considered in this paper.
Parametrization of the Upscaling Distributions Although it is now defined how a datapoint
x(S) downscales to x(S-1) , . . . , x(1) and to its absorbing state x(0), it is not immediately clear to
parametrize the distributions p(x(s) |x(s-1)). Two methods can be used to parametrize the distri-
bution. The first is a direct parametrization. In the example of the bit-upscaling model above, one
models the s-th significant bits given the (s - 1)-th significant bits. The direct parametrization is
generally more computationally efficient, as it requires only distribution parameter outputs that are
relevant for the current stage. This is especially useful when the number of classes is large (such as
with audio, which has 216 classes). However, it can be somewhat tedious to figure out exactly which
classes are relevant and should be modelled.
Alternatively we can use a data parametrization which is similar to the parametrization in Austin
et al. (2021). An important difference with their work is that the downscaling matrices P(s) represent
deterministic maps while theirs represent a stochastic process. For this parametrization, the network
f outputs a probability vector θ that matches the shape of the data x(S), which transformed and
converted to the relevant probabilities in stage s via:
P(S)Tx(s-1) G P(s + 1)θ
θ(s) = ------------ξξtʒ-------- where P(X(S)Ix(S-I)) = C(x(s) ∣θ(s)).
X(S-I)TP S θ
The advantage of this parametrization is that one only has to define the transition matrices {P(S)}.
As a result, the appropriate probabilities can be automatically computed which is ideal for experi-
mentation with new downscaling processes. The disadvantage may be that modelling full probabil-
ity vectors for problems with high number of classes may be expensive and not even fit in memory.
Empirically in our experiments on image data we find that there is no meaningful performance dif-
ference between the two parametrizations.
4	Related Work
Autoregressive Models Autoregressive Models (ARMs) factorize a joint distribution into a prod-
uct of conditional distributions (Bengio & Bengio, 2000; Larochelle & Murray, 2011). Advances
in deep learning have allowed tremendous progress on various modalities, such as images (van den
Oord et al., 2016b; Child et al., 2019, i.a.), audio (van den Oord et al., 2016a; Kalchbrenner et al.,
2018, i.a.), and text (Bengio et al., 2003; Graves, 2013; Melis et al., 2018; Merity et al., 2018; Brown
et al., 2020, i.a.), where for the latter they are referred to as language models.
Although evaluating the likelihood of a datapoint is generally efficient with ARMs, sampling re-
quires an iterative process with as many network calls as the dimensionality of the data. Parallelized
ARM approaches often rely either on cutting many dependencies in the conditioning (Reed et al.,
2017) which tend to suffer in log-likelihood. Alternatively, ARMs can be solved using fixed-point
iteration algorithms in fewer steps without sacrificing log-likelihood (Wiggers & Hoogeboom, 2020;
Song et al., 2021), but these methods typically still require a large number of steps to converge.
Order agnostic sequence modelling was introduced in (Uria et al., 2014) and utilizes the same objec-
tive as AO-ARDMs to optimize the model, operating by masking and predicting variables. Differ-
ent from their method, ARDMs have more choices in absorbing states, parallelization support and
6
Published as a conference paper at ICLR 2022
Table 1: Order Agnostic model performance (in bpc) on the text8 dataset. The OA-Transformer learns arbitrary orders by permuting inputs and outputs as described in XLNet. A Transformer learning only a single order achieves 1.35 bpc.			Table 2: Order Agnostic modelling perfor- mance (in bpd) on the CIFAR-10 dataset. The upscaling model generates groups of four most significant categories, equivalent to 2 bits at a time.		
Model	Steps	NLL	Model	Steps	NLL
OA-Transformer D3PM-uniform	250 1000	1.64 1.61 ±0.020	ARDM-OA Parallel ARDM-OA	3072 50	2.69 ± 0.005 2.74
D3PM-absorbing D3PM-absorbing OA-ARDM (ours)	1000 256 250	1.45 ±0.020 1.47 1.43 ±0.001	ARDM-Upscale 4 Parallel ARDM-Upscale 4	4 × 3072 4×50	2.64 ± 0.002 2.68
D3PM-absorbing Parallelized OA-ARDM (ours)	20 20	1.56 ±0.040 1.51 ±0.007	D3PM Absorbing D3PM Gaussian	1000 1000	4.40 3.44 ± 0.007
depth upscaling techniques, in addition to modern advances to fit larger scale data. An alternative
approach for order agnostic modelling is via causally masked permutation equivariant models such
as Transformers (Yang et al., 2019; Alcorn & Nguyen, 2021), but these have had limited success in
likelihood-based tasks. In (Ghazvininejad et al., 2019) a mask predict method is proposed, although
it does not contain a likelihood analysis. In other work, mixtures of ARMs over certain orders are
trained by overriding convolutional routines for masking (Jain et al., 2020). In a different context in
(Liu et al., 2018) graph edges connected to a node are modelled without order. However, the model
is not entirely order agnostic because it models edges centered around focus nodes.
Diffusion Models Diffusion models learn to denoise a Gaussian base distribution into the dis-
tribution of the data via a chain of latent variables (Song & Ermon, 2019; Sohl-Dickstein et al.,
2015; Ho et al., 2020). Diffusion and score-matching methods have shown large improvements in
image (Dhariwal & Nichol, 2021) and audio sample quality (Chen et al., 2020; Kong et al., 2021), as
well as likelihood improvements with variational interpretations of diffusion models (Kingma et al.,
2021; Huang et al., 2021). Although faster sampling schedules for continuous diffusion models have
been explored (Jolicoeur-Martineau et al., 2021; Kong & Ping, 2021), little is known about shorter
generative processes for discrete diffusion.
Discrete diffusion models operate directly on discrete spaces. In Sohl-Dickstein et al. (2015) dif-
fusion for binary data was proposed which was extended for categorical data in Hoogeboom et al.
(2021). Whereas these approaches uniformly resample categories, in Austin et al. (2021) a wide
variety of transition distributions was proposed. This work finds that absorbing diffusion produces
the best performing models in log-likelihood for text data, but these models still demand a large
number of steps. OA-ARDMs are equivalent to the infinite time limit of absorbing diffusion, which
makes them maximally expressive. Simultaneously, ARDMs upper bound the number of steps to
the dimensionality of the data. More details on the connections between these model types are in
Appendix C. Other discrete diffusion processes have been explored in (Johnson et al., 2021).
5	Results
Order Agnostic Modelling To better understand how ARDMs compare to other order agnostic
generative models, we study their performance on a character modelling task using the text8 dataset
(Mahoney, 2011). ARDMs are compared to D3PMs that model the inverse absorbing diffusion
process (Austin et al., 2021), and causally masked Transformers that are directly optimized on ran-
domly permuted sequences as done in XLNet (Yang et al., 2019). The different methods all use the
same underlying neural network architecture which is the Transformer used in (Austin et al., 2021),
which has 12 layers, 786 hidden dimensions and 12 heads. For the OA-Transformer baseline the ar-
chitecture is causally masked, and inputs are permuted to model the sequence in a specific order. In
addition to the standard positional embeddings for the input, the embeddings for the output are also
concatenated to the token embedding. This can be seen as an implicit method to condition on the
permutation that is currently generated. The specific hyperparameters of the optimization procedure
are specified in Appendix D and are the same as reported in (Austin et al., 2021), with the exception
of a different learning rate schedule and further train steps.
Performance of these methods is presented in Table 1. Firstly, the OA-Transformer baseline does not
perform very well compared to the other models. This result matches the behaviour that was found
7
Published as a conference paper at ICLR 2022
Figure 5: Visualization of x through the generative process for an ARDM Upscale 4 model.
by Yang et al. (2019), who observed underfitting behaviour and limited the task complexity by only
predicting a subset of the permuted tokens. Further, as expected the performance of our OA-ARDM
with 1.43 bpc is very close to the performance of D3PM-absorbing at 1000 steps with 1.45 bpc.
This is expected, since OA-ARDMs are equivalent to the continuous time limit of D3PM-absorbing
models. For sequences containing only 250 dimensions, the D3PM schedule with 1000 steps starts
to approximate the jump process where generally only a single variable is absorbed at a time. The
important takeaway from this comparison is that OA-ARDMs perform similar to large-steps D3PM
absorbing models while only requiring a quarter of the steps. When the D3PM model is forced
to take 256 steps which is comparable to our OA-ARDM model, then its performance degrades
further towards 1.47 bpd. In addition, a Parallelized ARDM with only 20 steps has a performance of
1.51 bpd over a similar D3PM which has 1.56 bpd. This pattern translates to CIFAR-10 (Krizhevsky
et al., 2009) where ARDMs also outperform D3PMs and degrade more gracefully under fewer steps.
This comparison to D3PM is however less direct, as the underlying architectures differ.
Lossless Compression To validate that ARDMs can form a viable basis for practical neural
network-based compressors, we study their performance when compressing CIFAR-10 images and
comparing them to existing methods. Since ARDMs provide probabilities for a sequence of sym-
bols, they can be directly used together with an off-the-shelf entropy coder for lossless compression.
In this experiment we use the range-based entropy coder rANS (Duda, 2009). To use ARDMs the
order of the coding process needs to be fixed for all images. To avoid an unlucky sample, before
coding we evaluate the log-likelihood of a few random permutations on the train set and pick the
best performing one. Empirically, there is very little difference in performance (< 0.02 bpd) between
different permutations.
Several deep learning based lossless compression methods in literature rely on bits-back coding
(Townsend et al., 2019), such as LBB (Ho et al., 2019), HiLLoC (Townsend et al., 2020) and VDM
(Kingma et al., 2021). Although bits-back coding methods can perform well on large datasets, they
have a large overhead when used as per-image compressors. This is caused by the large number
of initial bits that are required. Further, the dataset is often interlinked, meaning that if an image
in the middle of the dataset needs to be accessed, it requires all images earlier in the bitstream to
also be decompressed. Therefore per-image compression is important for practical applications,
because it is desirable to be able to send a specific image without sending an entire dataset. On
the other hand, direct compressors such as L3C (Mentzer et al., 2019), IDF (Hoogeboom et al.,
2019) and IDF++ (van den Berg et al., 2021) do not incur an intial message overhead and their
dataset performance translates directly to per-image compression. A more conventional codec is
FLIF (Sneyers & Wuille, 2016), which is a recent lossless compression codec with machine learning
components that outperforms traditional codecs such as PNG.
Performance of ARDMs and related methods in literature is presented in Table 3. ARDMs signif-
icantly outperform all methods on compression per image, requiring only 2.71 bpd versus 3.26 for
the next best performing model, IDF++. In addition, even compared to a setting where an entire
dataset needs to be compressed, ARDMs perform competitively to VDM, which attain 2.72 bpd.
Moreover, ARDMs degrade more gracefully when fewer steps are used to encode the data.
Note that the lossless compressor based on VDM was trained on non-augmented data, whereas the
best-performing likelihood model of Kingma et al. (2021) was trained with data augmentation. As
a result, it is likely that their dataset compression results could be somewhat improved when trained
on augmented CIFAR-10. Also, it is not a coincedence that HiLLoC and FLIF have the exact
same compression per image performance. HiLLoC compresses the first few images using the FLIF
format to fill the initial bitstream, and compresses the remaining images in the dataset with bits-back
coding (Townsend et al., 2020). As a result, on a per-image compression benchmark the method is
equivalent to FLIF.
Effects of Depth-Upscaling A natural question that might arise is how standard order-agnostic
modelling performs compared to order agnostic bit-upscaling, and how bit-upscaling compares to
8
Published as a conference paper at ICLR 2022
Table 3: CIFAR-10 lossless compression performance (in bpd).
Model	Steps	Compression per image	Dataset compression
VDM (Kingma et al., 2021)	1000	≥ 8	2.72
VDM (Kingma et al., 2021)	500	≥8	2.72
OA-ARDM (ours)	500	2.73	2.73
ARDM-Upscale 4 (ours)	500	2.71	2.71
VDM (Kingma et al., 2021)	100	≥ 8	2.91
OA-ARDM (ours)	100	2.75	2.75
ARDM-Upscale 4 (ours)	100	2.76	2.76
LBB (Ho et al., 2019)		≥ 8	3.12
IDF (Hoogeboom et al., 2019)		3.34	3.34
IDF++ (van den Berg et al., 2021)		3.26	3.26
HiLLoC (Townsend et al., 2020)		4.19	3.56
FLIF (Sneyers & Wuille, 2016)		4.19	4.19
Table 4: Audio (SC09) depth upscaling test set performance (in bpd). A WaveNet baseline learning only a single order achieves 7.77 bpd.			Table 5: Image (CIFAR-10) depth upscaling performance (in bpd).		
Model	Steps	Performance	Model	Steps	Performance
OA-ARDM	D = 16000	7.93	OA-ARDM	D = 3072	2.69
ARDM Upscale 256	~^2 × D ^^	6.36	ARDM Upscale 16	2 × D	2.67
ARDM Upscale 16	4×D	6.30	ARDM Upscale 4	4×D	2.64
ARDM Upscale 4	8×D	6.29	ARDM Upscale 2	8×D	2.67
ARDM Upscale 2	16 × D	6.29			
the upscaling with larger values. Due to the constant training complexity of ARDMs, one can easily
train models that have generative processes of arbitrary length. To test this, we train ARDMs on
image data from CIFAR-10 and audio data from SC09 (Warden, 2018). For the audio data, the total
number of categories is 216, which is typically too large in terms of memory to model as a single
softmax distribution. For that reason, the single stage OA-ARDM is trained using a discretized
logistic distribution because it is computationally cheaper for a high number of categories. For the
same reason, the Upscale ARDMs for audio can only be trained using the direct parametrization,
whereas for images they are trained with the data parametrization.
For images, the best performing model has an upscaling factor of 4 with 2.64 bpd (see Table 5)
and for audio the best performing model upscales by a factor of 2 or 4 with 6.29 bpd (see Table 4).
The hypothesis is that as the upscale factor becomes smaller, the generative process generally be-
comes more structured and easier to model. However, although for audio this pattern is consistently
observed, for images an upscale factor of 4 has better performance than an upscale factor of 2. It
is possible that for certain data, at some point smaller upscale factors give diminishing returns for
performance. We hypothesize that by prolonging the generative process, the model may get less gra-
dient signal per optimization step, leading to the decreased performance of smaller upscale factors
in some situations.
6	Limitations and Conclusion
Notwithstanding the good results in this paper, there are some limitations to ARDMs. 1) Even
though ARDMs outperform all other order-agnostic approaches on text, there is still a gap to the
performance of single-order autoregressive models. In preliminary experiments, upscale variants
for language did not perform better than the order-agnostic versions. 2) In the current description,
ARDMs model discrete variables. In principle one could also define absorbing processes for con-
tinuous distributions. 3) Finally, in this work we have focused on optimizing for log-likelihood,
because it directly corresponds to coding length in lossless compression. However when optimizing
for other objectives such as sample quality, different architectural choices may give better results.
In conclusion, we introduced ARDMs, a new class of models at the intersection of autoregressive
models and discrete diffusion models. ARDMs perform competitively with existing generative mod-
els, and outperform competing approaches on per-image lossless compression.
9
Published as a conference paper at ICLR 2022
Reproducibility and Ethics S tatement
To ensure the work is as reproducible as possible, in this paper we have described in detail both
the training algorithms and the sampling algorithms. The main ideas are presented in Section 3,
and further clarifications that may be important for re-implementation are given in Appendix A.
The hyperparameter settings to run experiments are presented in Section 5 and further clarified in
Appendix D. In addition, we plan to release the code that can be used to reproduce the experimental
results in this paper.
In terms of ethics, we do not see immediate concerns for the models we introduce. However, deep
generative models have a wide variety of applications such as representation learning, image inpaint-
ing, special effects in video, outlier detection and drug design. On the other hand, the generation
of images, text and video may have negative downstream applications such as making false media
seem realistic. Further, to the best of our knowledge no datasets were used that have known ethical
issues.
References
TensorFlow Datasets, a collection of ready-to-use datasets. https://www.tensorflow.org/
datasets.
Michael A. Alcorn and Anh Nguyen. The DEformer: An order-agnostic distribution estimating
transformer. In ICML Workshop on Invertible Neural Networks, Normalizing Flows, and Explicit
Likelihood Models, 2021.
Jacob Austin, Daniel D. Johnson, Jonathan Ho, Daniel Tarlow, and Rianne van den Berg. Structured
denoising diffusion models in discrete state-spaces. CoRR, abs/2107.03006, 2021.
Samy Bengio and Yoshua Bengio. Taking on the curse of dimensionality in joint distributions using
neural networks. IEEE Trans. Neural Networks Learn. Syst., 2000.
Yoshua Bengio, Rejean Ducharme, Pascal Vincent, and Christian Janvin. A neural probabilistic
language model. The journal of machine learning research, 3:1137-1155, 2003.
Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhari-
wal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal,
Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M.
Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin,
Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford,
Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Advances in Neu-
ral Information Processing Systems 33: Annual Conference on Neural Information Processing
Systems 2020, NeurIPS, 2020.
Nanxin Chen, Yu Zhang, Heiga Zen, Ron J Weiss, Mohammad Norouzi, and William Chan. Wave-
Grad: Estimating gradients for waveform generation. arXiv preprint arXiv:2009.00713, 2020.
Rewon Child. Very deep vaes generalize autoregressive models and can outperform them on images.
In 9th International Conference on Learning Representations, ICLR. OpenReview.net, 2021.
Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse
transformers. CoRR, abs/1904.10509, 2019. URL http://arxiv.org/abs/1904.10509.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: pre-training of deep
bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of
the North American Chapter ofthe Association for Computational Linguistics: Human Language
Technologies, NAACL-HLT, pp. 4171-4186. Association for Computational Linguistics, 2019.
Prafulla Dhariwal and Alex Nichol. Diffusion models beat gans on image synthesis. CoRR,
abs/2105.05233, 2021.
Jarek Duda. Asymmetric numeral systems. arXiv preprint arXiv:0902.0271, 2009.
10
Published as a conference paper at ICLR 2022
Stefan Elfwing, Eiji Uchibe, and Kenji Doya. Sigmoid-weighted linear units for neural network
function approximation in reinforcement learning. Neural Networks, 107:3-11, 2018.
Marjan Ghazvininejad, Omer Levy, Yinhan Liu, and Luke Zettlemoyer. Mask-predict: Parallel de-
coding of conditional masked language models. In Kentaro Inui, Jing Jiang, Vincent Ng, and
Xiaojun Wan (eds.), Proceedings of the 2019 Conference on Empirical Methods in Natural Lan-
guage Processing and the 9th International Joint Conference on Natural Language Processing,
EMNLP-IJCNLP, 2019.
Alex Graves. Generating sequences with recurrent neural networks. CoRR, abs/1308.0850, 2013.
URL http://arxiv.org/abs/1308.0850.
Jonathan Ho, Evan Lohn, and Pieter Abbeel. Compression with flows via local bits-back coding. In
Advances in Neural Information Processing Systems 32: Annual Conference on Neural Informa-
tion Processing Systems 2019, NeurIPS, 2019.
Jonathan Ho, Ajay Jain, and Pieter Abbeel. Denoising diffusion probabilistic models. In Hugo
Larochelle, Marc’Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin
(eds.), Advances in Neural Information Processing Systems 33: Annual Conference on Neural
Information Processing Systems 2020, NeurIPS, 2020.
Emiel Hoogeboom, Jorn W. T. Peters, Rianne van den Berg, and Max Welling. Integer discrete flows
and lossless compression. In Advances in Neural Information Processing Systems 32: Annual
Conference on Neural Information Processing Systems 2019, 2019.
Emiel Hoogeboom, Didrik Nielsen, Priyank Jaini, Patrick Forr6, and Max Welling. Argmax flows
and multinomial diffusion: Learning categorical distributions. CoRR, abs/2102.05379, 2021.
Chin-Wei Huang, Jae Hyun Lim, and Aaron C. Courville. A variational perspective on diffusion-
based generative models and score matching. CoRR, abs/2106.02808, 2021. URL https://
arxiv.org/abs/2106.02808.
Ajay Jain, Pieter Abbeel, and Deepak Pathak. Locally masked convolution for autoregressive mod-
els. In Ryan P. Adams and Vibhav Gogate (eds.), Proceedings of the Thirty-Sixth Conference on
Uncertainty in Artificial Intelligence, UAI, 2020.
Daniel D. Johnson, Jacob Austin, Rianne van den Berg, and Daniel Tarlow. Beyond in-place cor-
ruption: Insertion and deletion in denoising probabilistic models. CoRR, abs/2107.07675, 2021.
Alexia Jolicoeur-Martineau, Ke Li, R6mi Pich6-Taillefer, Tal Kachman, and Ioannis Mitliagkas.
Gotta go fast when generating data with score-based models. CoRR, abs/2105.14080, 2021.
Heewoo Jun, Rewon Child, Mark Chen, John Schulman, Aditya Ramesh, Alec Radford, and Ilya
Sutskever. Distribution augmentation for generative modeling. In Proceedings of the 37th Inter-
national Conference on Machine Learning, ICML, 2020.
Nal Kalchbrenner, Erich Elsen, Karen Simonyan, Seb Noury, Norman Casagrande, Edward Lock-
hart, Florian Stimberg, Aaron van den Oord, Sander Dieleman, and Koray KavUkcUoglu. Efficient
neural audio synthesis. In Proceedings of the 35th International Conference on Machine Learn-
ing, ICML, 2018.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Diederik P. Kingma, Tim Salimans, Ben Poole, and Jonathan Ho. Variational diffUsion models.
CoRR, abs/2107.00630, 2021.
Zhifeng Kong and Wei Ping. On fast sampling of diffUsion probabilistic models.	CoRR,
abs/2106.00132, 2021. URL https://arxiv.org/abs/2106.00132.
Zhifeng Kong, Wei Ping, Jiaji HUang, Kexin Zhao, and Bryan Catanzaro. DiffWave: A versatile dif-
fUsion model for aUdio synthesis. In 9th International Conference on Learning Representations,
ICLR, 2021.
11
Published as a conference paper at ICLR 2022
Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images.
2009.
Hugo Larochelle and Iain Murray. The neural autoregressive distribution estimator. In Proceed-
ings of the Fourteenth International Conference on Artificial Intelligence and Statistics, AISTATS,
2011.
Qi Liu, Miltiadis Allamanis, Marc Brockschmidt, and Alexander L. Gaunt. Constrained graph vari-
ational autoencoders for molecule design. In Samy Bengio, Hanna M. Wallach, Hugo Larochelle,
Kristen Grauman, Nicold Cesa-Bianchi, and Roman Garnett (eds.), Advances in Neural Informa-
tion Processing Systems 31: Annual Conference on Neural Information Processing Systems 2018,
NeurIPS, pp. 7806-7815, 2018.
Matt Mahoney. Large text compression benchmark, 2011.
Ggbor Melis, Chris Dyer, and Phil Blunsom. On the state of the art of evaluation in neu-
ral language models. In International Conference on Learning Representations, 2018. URL
https://openreview.net/forum?id=ByJHuTgA-.
Jacob Menick and Nal Kalchbrenner. Generating high fidelity images with subscale pixel networks
and multidimensional upscaling. In 7th International Conference on Learning Representations,
ICLR, 2019.
Fabian Mentzer, Eirikur Agustsson, Michael Tschannen, Radu Timofte, and Luc Van Gool. Practical
full resolution learned lossless image compression. In IEEE Conference on Computer Vision and
Pattern Recognition, CVPR, pp. 10629-10638. Computer Vision Foundation / IEEE, 2019.
Stephen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and optimizing LSTM
language models. In International Conference on Learning Representations, 2018. URL https:
//openreview.net/forum?id=SyyGPP0TZ.
Alexander Quinn Nichol and Prafulla Dhariwal. Improved denoising diffusion probabilistic models.
In Marina Meila and Tong Zhang (eds.), Proceedings of the 38th International Conference on
Machine Learning, ICML, 2021.
Scott E. Reed, Aaron van den Oord, Nal Kalchbrenner, Sergio Gomez Colmenarejo, Ziyu Wang,
Yutian Chen, Dan Belov, and Nando de Freitas. Parallel multiscale autoregressive density estima-
tion. In Proceedings of the 34th International Conference on Machine Learning, ICML, 2017.
Tim Salimans, Andrej Karpathy, Xi Chen, and Diederik P. Kingma. PixelCNN++: Improving the
PixelCNN with discretized logistic mixture likelihood and other modifications. In 5th Interna-
tional Conference on Learning Representations, ICLR 2017. OpenReview.net, 2017.
Samarth Sinha and Adji B. Dieng. Consistency regularization for variational auto-encoders. CoRR,
abs/2105.14859, 2021.
Jon Sneyers and Pieter Wuille. FLIF: free lossless image format based on MANIAC compression.
In 2016 IEEE International Conference on Image Processing, ICIP, pp. 66-70. IEEE, 2016.
Jascha Sohl-Dickstein, Eric A. Weiss, Niru Maheswaranathan, and Surya Ganguli. Deep unsuper-
vised learning using nonequilibrium thermodynamics. In Francis R. Bach and David M. Blei
(eds.), Proceedings of the 32nd International Conference on Machine Learning, ICML, 2015.
Yang Song and Stefano Ermon. Generative modeling by estimating gradients of the data distribu-
tion. In Advances in Neural Information Processing Systems 32: Annual Conference on Neural
Information Processing Systems 2019, NeurIPS, 2019.
Yang Song, Chenlin Meng, Renjie Liao, and Stefano Ermon. Accelerating feedforward computation
via parallel nonlinear equation solving. In Proceedings of the 38th International Conference on
Machine Learning, ICML, 2021.
James Townsend, Tom Bird, and David Barber. Practical lossless compression with latent variables
using bits back coding. CoRR, abs/1901.04866, 2019.
12
Published as a conference paper at ICLR 2022
James Townsend, Thomas Bird, Julius Kunze, and David Barber. Hilloc: lossless image com-
pression with hierarchical latent variable models. In 8th International Conference on Learning
Representations, ICLR 2020, Addis Ababa, Ethiopia, 2020.
Benigno Uria, Iain Murray, and Hugo Larochelle. A deep and tractable density estimator. In Pro-
ceedings of the 31th International Conference on Machine Learning, ICML 2014, Beijing, China,
21-26 June 2014, volume 32 of JMLR Workshop and Conference Proceedings, pp. 467-475.
JMLR.org, 2014.
Arash Vahdat and Jan Kautz. NVAE: A deep hierarchical variational autoencoder. In Advances in
Neural Information Processing Systems 33: Annual Conference on Neural Information Process-
ing Systems 2020, NeurIPS, 2020.
Rianne van den Berg, Alexey A. Gritsenko, Mostafa Dehghani, Casper Kaae S0nderby, and Tim
Salimans. IDF++: analyzing and improving integer discrete flows for lossless compression. In
9th International Conference on Learning Representations, ICLR. OpenReview.net, 2021.
Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves,
Nal Kalchbrenner, Andrew W. Senior, and Koray Kavukcuoglu. Wavenet: A generative model
for raw audio. In The 9th ISCA Speech Synthesis Workshop, 2016a.
Aaron van den Oord, Nal Kalchbrenner, and Koray Kavukcuoglu. Pixel recurrent neural networks.
In Maria-Florina Balcan and Kilian Q. Weinberger (eds.), Proceedings of the 33nd International
Conference on Machine Learning, ICML, 2016b.
P. Warden. Speech Commands: A Dataset for Limited-Vocabulary Speech Recognition. ArXiv
e-prints, 2018. URL https://arxiv.org/abs/1804.03209.
Daniel Watson, Jonathan Ho, Mohammad Norouzi, and William Chan. Learning to efficiently
sample from diffusion probabilistic models. CoRR, abs/2106.03802, 2021. URL https:
//arxiv.org/abs/2106.03802.
Auke J. Wiggers and Emiel Hoogeboom. Predictive sampling with forecasting autoregressive mod-
els. In Proceedings of the 37th International Conference on Machine Learning, ICML, 2020.
Zhilin Yang, Zihang Dai, Yiming Yang, Jaime G. Carbonell, Ruslan Salakhutdinov, and Quoc V. Le.
XLNet: Generalized autoregressive pretraining for language understanding. In Advances in Neu-
ral Information Processing Systems 32: Annual Conference on Neural Information Processing
Systems 2019, NeurIPS, 2019.
13
Published as a conference paper at ICLR 2022
A	Further Details of Autoregressive Diffusion
Next to given descriptions, the implementation has been open-sourced at https://github.com/
google-research/google-research/tree/master/autoregressive_diffusion.
A.1 Depth Upscaling
This section explains further details that are important to optimize and sample from Depth
Upscaling ARDMs, which are summarized in Algorithm 3 and 4. Recall that for depth-
upscaling models, the variables are modelled in stages x* (1) * * * , . . . , x(S) and the model learns
p(x(S) |x(S-1)), . . . , p(x(1) |x(0)). Here x(0) is a constant absorbing state and x(S) represents the
data. The transition matrices {P(s) } describe the destructive maps which end up in the absorbing
state. They form the destructive counterpart of the generative process.
Instead of optimizing for all stages simultaneously, We sample a stage uniformly S 〜U (1,...,S)
and optimize for that stage. Here the cumulative matrix products P(S) allow us to directly transition
to a specific stage, since X(S) = P(s+1)x(S). To be precise, for a single dimension i the variable
(s)	(s)
xi is represented as a onehot vector and then transformed using the matrix multiplication xi =
=^-(s+1) (S)	1 ♦ 1	.	1 .	.	1 ♦ I. ♦	.	1 ♦ [	[	] 11	.
P	xi . For multiple dimensions this matrix multiplication is applied individually, meaning
that P(s+1)x(S) = (p(s+1)χ1S), P(s+1)χ2S),..., P(s+1)χDS)) = (XIS),…,XD)) = x(s).
For a optimization step, a stage S 〜 U (1,...,S) and a step t 〜 U (1,...,D) are sampled, in
addition to a permutation σ 〜U(SD). Then using the cumulative matrices, from a datapoint X =
X(S) the variables X(S) and X(S-1) are computed. As before, the mask m = σ < t gives the
locations of the variables that are conditioned on. For those locations the values in X(S) may already
be accessed. For the opposite locations 1 - m, instead the values from X(S-1) are accessed. This
leads to the expression for the input i = mX(S) + (1 -m)X(S-1). The target of the network will
be to predict a distribution for X(S) at the locations at 1 - m. The network will take in the computed
input i together with variables to clarify in which stage of the generative process the model is,
m, S and t. In case of the data parametrization, the probabilities θ are appropriately normalized
and reweighted to θ(S) using transitions {P(s)}. Then, the log probabilities logC(X(S)∣θ(S)) are
computed elementwise over dimensions and subsequently masked with 1 - m. These quantities are
then summed and reweighted to get a stochastic estimate for the ELBO.
For the sampling, the model traverses through each stage, and for each stage through every dimen-
sion in a different order. In each step the network together with the transition matrices produces a
probability vector θ(S) from which elementwise samples are taken x0 〜 C(X(S) ∣θ(S)), but only the
values at locations n J (σ = t) are filled in, corresponding to the current generation step. By
traversing through all steps and stages, the variable X(S) is generated.
Algorithm 3 Sampling from Upscale-ARDMs
Input: Network f
Output: Sample X
Initialize X = X(0)
for S in {1, . . . , S } do
Sample σ 〜U(SD)
for t in {1, . . . , D} do
mJσ<t
n J (σ = t)
θ J f(X, m, S,t)
θ(S) (X P(S)TX © P(S+1)θ
X0 〜C(X(S)∣θ(S))
X J (1 - n) © X + n © X0
Algorithm 4 Optimizing Upscale-ARDMs
Input: Datapoint X, Network f
Output: ELBO L
Sample S 〜U(1,...,S)
Sample t 〜U(1,...,D)
Sample σ 〜U(SD)
x(s) j P(S+1)X and X(ST) J P(S)X
Compute m J σ < t
i J m © X(S) + (1 - m) © X(S-1)
θ J f(i,m,S,t)
θ(S) X P(S)TX(S-I) © P(S+1)θ
It J (1 — m) © logC(X(S) ∣θ(S))
L J D-D+1 sum(lt)
14
Published as a conference paper at ICLR 2022
A.2 Details on Parallelized ARDMs
This section discusses further details on Parallelized ARDMs, and provides a JAX version of the
dynamic programming algorithm from (Watson et al., 2021) that was written in NumPy. Since
the algorithm scales with O(D3) this implementation is important to scale to larger dimensional
problems. To clarify, the upscale ARDMs can be seen as a S sequential OA-ARDMs that model
p(x(s) |x(s-1)), and when a parallel schedule is computed, it is computed for each stage separately.
It is also possible to run the dynamic programming algorithm for all S ∙ D steps simultaneously,
which could even choose to distribute steps unevenly over stages, but that is not done in this paper.
Recall that to run the algorithm a matrix L is needed which gives the cost of travelling from one
generation step to another. It is constructed so that Lt,t+k = k ∙ Lt for positive k and 0 otherwise,
which represents the cost of generating k variables in parallel where Lt is the loss component.
In practice this is implemented via a cumulative sum of a triangular mask. This part is relatively
computationally cheap.
import jax
from jax import numpy as jnp
import numpy as np
def get_nelbo_matrix ( loss_components : np . ndarray) :
num_timesteps = len(loss_components)
#	Creates multiplicative mask . E . g . if num_timesteps = 3 then :
#	[1	2	3]
#	triu	=	[0	1	2] .
#	[0	0	1]
triu	=	np . triu ( np . ones (( num_timesteps , num_timesteps)))
triu = np . cumsum(triu [: : -1] , axis =0) [ : : - 1]
#	Comput e nelbos [s , t] whi ch contains - logp (x_s | x_t)
nelbos_ = loss_components [ : , None] * triu
#	Pad last row / first column .
nelbos = np . zeros (( num_timesteps + 1 , num_timesteps + 1))
nelbos [: -1 , 1 : ] = nelbos_
return nelbos
The most expensive part of the algorithm is the loop which has computational complexity O(D3).
This is the most important extension of the NumPy version and reduces runtime from 5 minutes to
about 2 seconds for D = 3072, which would be very impractical to run for our audio experiments
where D = 16000, which now take less than half a minute to run. Through JAX this loop is XLA-
compiled with the scan operation, limiting overhead when running the algorithm.
@jax . jit
def inner_cost_and_dimension_loop (
nelbos : jnp . ndarray , first_cost : jnp . ndarray) :
""" Inner jax - loop that computes the cost and dimension matrices .
num_timesteps = first_cost . shape [0] - 1
def compute_next_cost (prev_cost : jnp . ndarray , _ : jnp . ndarray):
bpds = prev_cost [: , None] + nelbos
new_dimension = jnp . argmin ( bpds , axis =0)
new_cost = jnp . min ( bpds , axis =0)
return new_cost , (new_cost , new_dimension)
_ , ( costs , dimensions) = jax . lax . scan (
compute_next_cost , init=first_cost ,
xs=jnp . arange (1 , num_timesteps +1))
return costs , dimensions
15
Published as a conference paper at ICLR 2022
The inner algorithm logic is then called via the function below. It first builds the loss transition
matrix L which is referred to as nelbos and then calls the inner loop. As an output it gives the cost
and dimension matrices that can be used to 1) find an optimal path and 2) describe how expensive
such paths are. As can be seen in Figure 6, the running average of the loss components {Lt } might
be somewhat noisy, which can negatively influence the algorithm. As a straightforward method to
reduce variance of the values {Lt }, they are sorted before they are given to the algorithm. This
is uniquely possible for ARDMs, as we expect Lt to be monotonically decreasing over t (see also
Equation 4). For Upscale ARDMs that have multiple stages, the loss components are seperately
sorted per stage.
def get_cost_and_dimension_matrices ( loss_components : np . ndarray) :
""" Compute cost and assignment matrices , in JAX . """
num_timesteps = len ( loss_components)
#	First row of the costs matrix .
first_cost = np . full (( num_timesteps + 1 , ) , np . inf)
first_cost [0] = 0
first_cost = jnp . array(first_cost)
# First row of the dimens i ons matrix . The first row just contains -1
# and is never used , but this way it aligns with the cost matrix .
first_dimension = jnp . full (( num_timesteps + 1) , -1 , dtype = np . int32)
# nelbos [s , t] is going to contain the value logp(x_s | x_t)
nelbos = jnp . array ( get_nelbo_matrix ( loss_components))
costs , dimensions = inner_cost_and_dimension_loop (nelbos , first_cost)
# Concatenate first rows to the matrices .
costs = jnp . concatenate ([ first_cost [ None , :] , costs] , axis =0)
dimensions = jnp . concatenate ( [ first_dimension [ None , :] , dimens i ons] ,
axis =0)
costs = np . array (costs)
dimensions = np . array (dimensions)
return costs , dimensions
The final part of this algorithm is used to retrieve the path that needs to be taken to attain a certain
cost. This algorithm takes as input a budget and the cost & dimension matrices, and returns the
corresponding path to traverse.
def get_optimal_path_with_budget (budget : int , costs : np . ndarray ,
dimensions : np . ndarray):
num_timesteps = len(costs) - 1
t = num_timesteps
path = np . zeros (budget , dtype =np . int32)
cost = costs [budget , num_timesteps]
for k in reversed (range (1 , budget +1)) :
t = dimens i ons [k , t]
path[k-1] = t
return path , cost
16
Published as a conference paper at ICLR 2022
B Additional Results
B.1 Relation to other likelihood-based generative models
In this section we show how ARDMs perform compared to existing likelihood based generative
models in literature. These results are presented in Table 6. The best performing model is the
Variational Diffusion Model (VDM) (Kingma et al., 2021). ARDMs perform competitively with a
best score of 2.64 bpd, and are the best performing model among discrete diffusion approaches.
Table 6: CIFAR-10 generative modelling.
Model	Type	NLL
ARDM-AO (ours)	Discrete Diffusion ∪ ARM	2.69
ARDM-Upscale 4 (ours)	Discrete Diffusion ∪ ARM	2.64
D3PM Gaussian (Austin et al., 2021)	Discrete Diffusion	3.44
DDPM (Ho et al., 2020)	Diffusion	3.69
Improved DDPM (Nichol & Dhariwal, 2021)	Diffusion	2.94
VDM (Kingma et al., 2021)	Diffusion	2.49
PixelCNN++ (Salimans et al., 2017)	ARM	2.92
SPN (Menick & Kalchbrenner, 2019)	ARM	2.90
Sparse Transformer (Jun et al., 2020)	ARM	2.52
NVAE (Vahdat & Kautz, 2020)	VAE	2.91
Very Deep VAE (Child, 2021)	VAE	2.87
CR-VAE (Sinha & Dieng, 2021)	VAE	2.52
B.2	Additional audio experiments
In Table 7 we present additional experimental results from our best Upscale ARDM model for the
SC09 dataset (branching factor 4), in which we consider smaller computational budgets. Recall that
dimensionality D = 16000 for SC09 data.
B.3	Loss components over time
Since the training algorithm estimates the NLL by sampling a step t for each input in the batch,
we can collect and keep track of the loss components {Lt } and plot them as a function of t (see
Figure 6). These are collected by updating an exponential moving average during training, and
are used in the dynamic programming routine. As expected by Equation 4, the components Lt are
monotonically decreasing over the step t within a stage. The height is re-normalized so that the
average height represents the total bits per dimension. As a result, in the upscale model the value
divided by number of stages S represents the actual uncertainty of generating that token.
The loss plot of the upscale model allows for interesting observations: For instance, After an initially
high uncertainty (≈ 8/S = 2 bits) the most significant bits become increasingly easier to model very
fast (< 2/S = 0.5 bits). In contrast, for each stage that follows, the average height of that stages
increases. This indicates that the model is more uncertain for the less significant bits. This can be a
combination of two things: The model may have more difficulty in modelling these less significant
Table 7: Audio (SC09) depth upscaling test set performance (in bpd) for various computational
budgets.
Model	Steps	Performance
ARDM Upscale 4	8 × 16000	6.29
ARDM Upscale 4	8 × 1000	6.30
	8 × 500	6.30
	8 × 100	6.32
	8 × 50	6.32
17
Published as a conference paper at ICLR 2022
bits (i.e. high KL between data and model distribution), and the data distribution may be more
uncertain in those regions (i.e. high entropy of the data distribution).
Figure 6: Loss components over model step on CIFAR-10. The height is normalized so that the
average represents the total bits per dimension. Left: loss terms for the OA-ARDM. Right: loss
terms for the ARDM-Upscale 4, which comprises four stages.
B.4	Samples from ARDMs
Language Sampling from ARDMs can be visualized at different steps t to highlight the genera-
tive process. Recall that for models trained on language, the absorbing state augments the space,
meaning that an additional index that is added for the absorbing state. We visualize this token by the
underscore character ‘_’. The process at four selected steps in the process are presented in Figure 7,
where the last sentence represents the resulting sample.
___________________________________________________x_____________________________________________
___________i______________________________________________________________________________n______
_________________________i_________________________________f____
to____li________egy_f____________c___________ _____x___i___e_________rt s___k________________r i
______ i__i s___l__e___e ________a____h___ _ot_____________l____________c_e__pr_ __j___ __er_t_onal_w_a
___s_in__________________________________________________________________me_c_i_i__a_ m_d_s_f_
to_r__li_e s_rategy for______m___c_________h_ __n_ex_eri__ce_______hort s_rike b_r__wheth_r i
_ ___se i__is__el__er__e fo__g__a_l s_h__e _ot__t__l_y u_s_c_e__pr______________ i_j e__ __erational w_a
po_s_in_t___g_me_ca_ u__i_d__i__a_ m_d_l u__e___s___d fy__g
to r__l i_e s_rat egy for autom__ics o_ i__the c_n ex_eri e_ce_fo_ short s_rike_bombers_wheth_r i
n r_use it_is deli_erate for ga_auls ha_e _ot_ntially u_s_cke__pro_f___ i_j ect __erational w_a
po_s in t_e_game_car us_i_divid_a_ mod_l urre___s___de__i fyi_g
to realize strategy for automatics or it the can experience for short strike bombers whether i
n reuse it is deliberate for gasauls have potentially unsucked proof or inj ect operational wea
pons in the game car us individual model urreali se identifying
s_____________________________________________________________________________________________________________________________________________
______________________________________________________________________ _____________________________________________________________________t_t
___________________________________________________________________________________________________________________d_
e_s__e___ows___ _____r___c
e_______f_____b__s__el_i__ ____d
s___c_________he_
i ___ __ ___ ___a____ma_____i___e b_____r_______bl_ ___________d
______o_g_____e___o_ a___d__t______e____m____t___________ __m__
t_n_a___ i_land__omp___t__n_
l e_s_re_shows___ t___ro__c t__n_o__t_e _ta___f_____by_sa_el_i_e _o_rd______ro__s __c_ _en__ he_
ita_e __ ___ ___a__y_mai__fi s_ e b__u_r____________________________________bl_ e_ __r_a__d_n_a__tin_a__s i_land_comp__it_on_
__d_g_orge__c_e___on a___d_ltum _eak__mongst_e__e___a_ _om__
leisure shows__t t_e
itage of t__ _ata__y
_nd george_ clea_son
_rot_ction o__the sta__ fal_s by sa_ellite _o ard_a_d troo_s __ce tenu_ he
main_fi sh e b__uer__ ___b l _ el _erpa _d_n_a_ tin_a__s island compo_i t_on
a__ diltum peak among s the ge___a_ _omm_
leisure shows it the protection
ritage of the catalay main fish
and georges clearson and diltum
of the stamp falls by satellite board and troops lace tenua he
e b fuerta e robla el serpa eden at tingalas island composition
peak among s the general c ommu
Figure 7:	Two generative processes of an OA-ARDM trained on text8. The resulting sample from
the model is at the bottom of each frame.
18
Published as a conference paper at ICLR 2022
Images The generative processes for images are visualized in Figure 8. In constrast with the
language model, here the absorbing state takes on a specific value in the domain of the image itself.
In the case of OA-ARDMs, the absorbing state is 128 so that it is 0 when normalized in the network
architecture. In constrast, the absorbing state of the Upscale ARDM is 0 because it is defined by
zeroing least significant bits until everything is zero. The right-most grid represents the resulting
samples from the model. The generative processes are very different: whereas the upscale ARDM
first generates a coarses version of the images with fewer bits, the order agnostic ARDM generates
each value at once.
(a) Generative process of an Upscale 4 ARDM. This model was trained without data augmentation and with
dropout, which explains that all images are generated upright. The performance of this model is approximately
2.71 bpd whereas the same model trained with data augmentation has 2.64 bpd.
(b) Generative process of an OA-ARDM, starting at the absorbing state a. This model was trained with data
augmentation, which is known to somewhat degrade sample quality and naturally sometimes samples rotated
or reflected images.
Figure 8:	Visualization of the generative process for x, ending with the resulting samples at the
right-most grid.
19
Published as a conference paper at ICLR 2022
C Equivalence of AO-ARDMs and Absorbing Diffusion in
CONTINUOUS TIME
In this section we examine the connection between absorbing diffusion and AO-ARDMs more
closely. We start with a description of the independent process of absorbing diffusion as used in
(Austin et al., 2021) and highlight potential complications of this process. Then, we will show that
AO-ARDMs are equivalent to a continuous-time version of absorbing diffusion models.
The Independent Absorbing Process from Austin et al.
In absorbing diffusion as described by (Austin et al., 2021), each dimension can independently
get absorbed with some small probability for each time step. Specifically, letting a vector x(t)
represent a Markov process as a collection of random variables index by integers t, where x(0) is
the data distribution. Each dimension xi(t) as an equal and independent chance of getting absorbed
according to rate γ(t) at index t to the absorbing state ai. Define the cumulative chance of retaining
the state as α(t) = Qtτ =1 (1 - γ(τ)). This allows the direct expression for the distribution over
xi(t) as categorical on data and the absorbing state {xi(0), ai} with probabilities {α(t), 1 - α(t)}.
Typically, the decay rate γ is chosen so that α(T ) = 0 for some large integer T . For example in
(Austin et al., 2021) it is set T = 1000 for most experiments. We refer to the absorbing process
from (Austin et al., 2021) as an independent absorbing process, due to its independent absorbing
probabilities between dimensions.
The reverse of this absorbing process is the generative process. As described above, the chance
of a dimension absorbing is independent. As a result when T is small, it is inevitable that multi-
ple dimensions decay at once. This has a direct consequence for the generative process, which is
parametrized to model dimensions independently. The generative process will have to model the
variables of these multiple absorbed dimensions as an independent factorized distribution, which
causes a loss in modelling performance. This problem can be overcome by setting T to a larger
value. Indeed, when T is larger the chance of multiple dimensions decaying at once decreases. Dur-
ing training, T can be set arbitrarily high without incurring costs. However, to sample or evaluate
the likelihood of a specific datapoint, the computational cost scales directly with T so it is desired
to keep T as low as possible.
As an example, consider the experiment from (Austin et al., 2021) where text sequences of length
256 are modelled using a 1000 timestep absorbing diffusion model. When sampling from this model,
at least 744 of the neural network forward passes do nothing to the latent variable and are needless
compute. When T is reduced, performance degrades. In addition, it can be difficult to determine
beforehand how high a T should be sufficient, and it depends on the data and the decay rate.
ARDMs model the reverse of a Fixed Absorbing Process
Our ARDMs can be viewed as learning the generative process of a slightly modified absorbing
process. Instead of independent absorbing costs, exactly one dimension decays at a time step until
all dimensions have been absorbed. Since only one variable decays at a time, we refer to this process
as a fixed absorbing process. This ensures that T = D exactly, where D is the dimensionality of the
data.
An equivalent way to describe this process is by sampling a permutation of the indices 1, . . . , D
and decaying in that order towards the absorbing state. The corresponding generative process is
then modelling the variables exact opposite order of the permutation: an AO-ARDM. As a result the
generative process with a fixed absorbing process process only requires at most D steps.
ARDMs are equivalent to Continuous Time Absorbing Models
The absorbing diffusion model from (Austin et al., 2021) can be relaxed to continuous time. Define
a continuous-time discrete-space absorbing-state Markov process as a collection of Markov random
variables {x(t)} in dimension D, parameterized by t ∈ R+ . Starting in state x(0), each of the ele-
ments xi(t) of the state vector independently decays towards an absorbing state a at rate γ(t), such
that at time t the distribution on the vector elements is categorical on {xi(0), ai}, with probabilities
{α(t), 1 - α(t)}, with α(t) = exp(- R0t γ(s)ds). This last equivalence is obtained via the first order
logarithmic Taylor expansion log(1 - x) ≈ -x which holds for the small γ(s)ds.
An equivalent way of describing this stochastic process is as a finite set of D random transition times
{τi} fori ∈ {1, . . . , N} describing the time where the element xi has transitioned into the absorbing
20
Published as a conference paper at ICLR 2022
state. Specifically, we say that τi is the latest time for which xi is non-yet absorbed, so xi (t) = ai
for t > τi . From this perspective, x is only changing at the transition times τi and remains the same
at other times. Then, the reverse process to model {x(t)} for all t is equivalent to only modelling
the finite dimensional {xi (τi), τi}. In other words, to model the reverse process, we only need to
model the transition times {τi } and the variable right before it was absorbed.
To show an equivalence between the continuous time absorbing process and ARDMs, we will show
that we can model the reverse process given by {xi(τi), τi} by sampling the transition times inde-
pendently, and by using an AO-ARDM for the transitions in x.
The distributions {τi } are already known, they are given by the distribution with the cumulative
distribution function 1 - α(t). That leaves the modelling of {xi(τi)} to model the reverse process.
An important question that now arises is whether the transition times {τi } provide any additional
information in modelling the variables {xi (τi)}. Apart from knowing that the variable will be
un-absorbed, the answer is no. This is because the values are distributed as the data distribution
so Xi(0)∣x(t) 〜 Xi(Ti)|x(t) and the actual continuous value of Ti does not matter, specifically
{xi(0)} ⊥ {τi}∣x(t).
As a consequence, the model for the reverse process does not need to be conditioned on the precise
values {Ti} and can instead be solely conditioned on xi(Ti+1) to model xi(Ti) for all dimensions i.
Recall that this process is equivalent to the generative process of our AO-ARDM: Each new timestep,
a new dimension of the variable is modelled. The order in which the variables are modelled depends
on the decay times {Ti}, and since these are all identically distributed, the order is uniform over all
possible permutations.
We claim that we can write the VLB as follows:
log p(x(0)) ≥ Eq(x(>0)|x(0)) log p(x(> 0)) + log p(x(0)|x(> 0)) - log q(x(> 0)|x(0))
= Eq(τ1,...,τD)	logp(x(Ti)|x(Ti+1)) - KL(q(T1, . . . ,TD)|p(T1, . . . ,TD))
i
=Eσ〜U(Sd) ElOgP(Xσ(i)∣Xσ(<i)),
i
where x(> 0) denotes all values of x(t) for t > 0. The first equivalence follows from the above
described equivalent representation of the continuous process. And indeed when the transition times
and the values of x at the transition times are given, the remaining variables of the continuous
process can be reconstructed so it can be ensured that:
KL(q(x|x(T1), . . . , x(TD), T1, . . . , TD)|p(x|x(T1), . . . , x(TD), T1, . . . , TD)) = 0.
In addition, recall that any transition variable is distributed according to any chosen cumulative
distribution α(t). Therefore, we can simply set our generative process to the same distribution,
which ensures that:
KL(q(T1, . . . , TD)|p(T1, . . . , TD)) = 0.
At this point we observe that the sampling times only determine the order in which the dimensions
x are modelled. In fact when modelling x(Ti)|x(Ti+1) only one dimension dimension changes from
Ti+1 to Ti. Since all {Ti} are independently and equally distributed, the distribution over the order
of {Ti} is uniform. A subtle detail is that the reverse of the order ofTi describes the generative order
since we model timestep Ti given Ti+1 . Nevertheless, since the distribution over orders is uniform,
the distribution over reverse orders is also uniform. Therefore:
Eq(τι,…,td ) ElOg P(X(Ti)Ix(Ti+l)) = Eσ 〜U (Sd) ElOg P(xσ(i) lxσ(<i)),
ii
where the latter equation contains the same omitted notation as in the main paper: The model is
aware which dimensions are conditioned on and which are not. In practical terms, this means that
xσ(<i) should be viewed as a masked vector and not as an order-less set. For the curious reader,
technically the ability to move from order-less to the structured masked vector is enabled by condi-
tioning on σ. In summary, modelling the generative process ofa continuous absorbing jump process
is equivalent to an AO-ARDM. This is beneficial, as viewing the model as an AO-ARDM gives a
simple bound to the number of required steps and allows an easier perspective on the model and its
implementation.
21
Published as a conference paper at ICLR 2022
D Experimental Details
In this section further details are given on the experimental setup.
Images For CIFAR10 (Krizhevsky et al., 2009) we train the model using a fixed number of steps
using the typical splits and evaluate the test log-likelihood after 3000 epochs of training. The results
that are reported with standard deviations results are based on runs with three different initial seeds.
The other results are based on single-run experiments. The runs take approximately 2 weeks to
complete training on 8 TPUv4 devices, although good performance (≈ 2.8 bits per dimension) is
already achieved after a couple of days.
As a base architecture for the OA-ARDM and the Upscale ARDMs, the exact same U-Net architec-
ture as in (Kingma et al., 2021) are used. This architecture has 32 ResBlocks at resolution 32 × 32,
a single middle attention layer and then another 32 ResBlocks at resolution 32 × 32. Throughout
the network feature maps have 256 channels. This architecture is typical for NLL optimization and
lossless compression, which typically require many high-resolution feature maps (Mentzer et al.,
2019). The models are trained for 3000 epochs with Adam using a learning rate of 0.0001 and beta
parameters (0.9 / 0.999). The input processing uses a combination of the floating point represen-
tation and an embedding layer. The integer-valued input is put through a simple normalization by
dividing by the total number of classes, and subtracting 0.5. To this normalized input the mask m
is then concatenated. In the case of upscale ARDMs, the current stage in one-hot representation
is also converted to a mask with S channels, and is also part of m. So in that case m has S + 1
channels. Then a 3 × 3 convolutional layer maps the concatenated inputs to 3/4 of the channels. In
addition, the integers are also fed through an embedding layer to 1/4 of the channels. These two
outputs are then combined which produces the feature maps with 256 channels. This is given as
an input to the U-Net architecture as described above. Following Austin et al. (2021) we include
the Cross-EntroPy (CE) objective LCE = Et〜U(i,…,d) [d(D - t + 1)Lt] (i.e. the unnormalized
likelihood components), with a small factor of 0.001. However, in an experiment without the LCE
loss included, no substantial differences in Performance were found for our ARDMs. Since the like-
lihood of the dataset is estimated with the ARDM objective, the results are comPuted over multiPle
dataset Passes to reduce the stochastic effects from samPling t and σ. For evaluation the exPonential
moving average of the Parameters is used with a momentum coefficient of 0.9999. The models are
trained with a batch size of 128. The gradient is cliPPed at 100.
Language For the text8 dataset (Mahoney, 2011)1 We train using the typical 90 ∙ 106/5 ∙ 106/5 ∙ 106
sPlits in characters. Because the text8 dataset is a long string of characters, there is Predictive infor-
mation betWeen segments When chunked. For this reason there is a big difference betWeen model
performance in literature in the reported scores on the text8 benchmark. Some methods consider
a larger context before the current sequence, Which greatly improves the information available to
the model and gives better log-likelihoods. The runs take approximately a Week to complete on 4
TPUv4 devices.
Since We are interested in the pure modelling capacity of models, We folloW (Hoogeboom et al.,
2021; Austin et al., 2021) and consider chunked text segments without any additional context. HoW-
ever, since the text8 splits are not evenly divisible by 256, We slightly adjust the chunk size to 250
characters, to avoid dropping the last batch. We validated empirically With a baseline Transformer
that this small change does not meaningfully change the performance With the 256 version. For
reference, a baseline 12 layer Transformer attains 1.35 bpc on this problem.
As a base architecture, We use a 12 layer Transformer as used in (Austin et al., 2021). It has 768
dimensions, 12 heads, 3072 MLP dimensions. For the ARDM architectures We folloWed (Austin
et al., 2021) and used a batch size of 512 With no dropout. For standard language model baseline,
since We observed overfitting the batch size Was loWered and dropout of 0.1 Was added. The mod-
els are trained for 3 ∙ 106 training steps. ARDMs are optimized with Adam with a learning rate of
0.0005 Which has a linear Warm-up for the first 5000 steps. The additional LCE loss Was included
with a factor 0.0001. The gradient is clipped at 0.25. For evaluation the exponential moving aver-
age of the parameters is used with a momentum coefficient of 0.995. All models use a sinusoidal
1
http://mattmahoney.net/dc/text8.zip
22
Published as a conference paper at ICLR 2022
positional embedding. However, the OA-Transformer based on the XLNet approach (Yang et al.,
2019) requires both the input and target positional embeddings to infer which permutation currently
needs to be generated. In (Alcorn & Nguyen, 2021), this is handled by interleaving input and target
nodes in the sequence. A downside to this approach is that is increases the sequence length by two,
which increases the quadratic computational complexity of the attention layers by four. In contrast,
we concatenate the input and target embeddings, which does not alter the sequence length.
Audio For audio experiments we used a subset of the SC09 dataset (Warden, 2018) obtained by
filtering out all non-digit commands from the dataset without changing the structure of the train/-
validation/test splits. The resulting dataset contains 31158/3643/4107 training/validation/test audio
clips that are 1 second long and sampled at 16 kHz. In a few rare cases when the audio clips were
shorter than 1 second, we right-padded them with zeros; and all considered models were trained and
evaluated on padded data. A Tensorflow Datasets TFD version of this dataset is provided with the
open-source code. Training takes approximately 4 days.
For both, the AO-ARDM as well as the Upscale ARDM experiments, we closely followed the Dif-
fWave setup (Kong et al., 2021) in terms of the network architecture and size, bit adapted the input
embedding layer to take input masks into account. Specifically, we used a non-causal WaveNet
(van den Oord et al., 2016a) architecture with 36 blocks, 256 channels and a dilation cycle of 11 (i.e.
maximum dilation of 2048); input embedding were obtained by concatenating 1) 64-channel em-
beddings of integer input values; with 2) 192-channel mask and continuous input value embeddings
output by a width 3 convolution; the shared time embedding was obtained by mapping the standard
256-channel sine and cosine representation through two dense layers with 1024 features and Swish
nonlinearities (Elfwing et al., 2018).
Audio AO-ARDM and Upscale ARDM models were trained using the Adam optimizer (Kingma &
Ba, 2014) with beta paramters 0.9 / 0.999 for 106 steps with a batch size of 256 and a linear learning
rate warm-up over the first 15000 steps followed by a constant learning rate of 10-4. During training
we tracked an exponential moving average (EMA) of the model parameters using a momentum of
0.995, and employed the EMA parameters during evaluation. As in the case of image ARDMs, the
models were optimized using a combination of the ELBO and CE objectives - the latter taken with
a tiny weight of 10-4. No further regularisation was used.
Due to the large output space (216 classes) audio AO-ARDM modelled the output distribution using a
mixture of discretized logistics (DMoL) with 30 components, although we experimentally found the
number of components to not make a big difference. To aid with training, the DMoL was initialized
as an approximately uniform distribution with different mixtures responsible for the different parts
of this distribution; and gradients with an L2 norm larger than 1000 were re-normalized. Owing to
the smaller per-stage output space, we were able to utilize the categorical softmax parameterization
for the Upscale ARDMs. Empirically we observed this model class to demonstrate a more stable
training behaviour (in a addition to significantly improved likelihoods), which we (partially) attribute
to the choice of parametrization.
For our autoregressive single-order baseline we sought to deviate from the above AO-ARDM setup
as little as possible, and used a causal version of the WaveNet architecture above. However, we
observed that the single-order baseline overfits quickly on the training data. To overcome this, we
found it necessary to use weight decay (0.01), smaller batch size (64) and fewer channels (128) for
the baseline model.
23