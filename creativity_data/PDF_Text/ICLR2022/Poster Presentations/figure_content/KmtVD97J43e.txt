Figure 1: Overview of the Synchromesh framework. Given the user’s query, high-relevanceexamples are first retrieved with Target Similarity Tuning (TST). Then, a program is incrementallysampled via Constrained Semantic Decoding (CSD), which queries a completion engine (CE) toenforce constraints during code generation without re-training or fine-tuning the language model.
Figure 2:	Example of Target Similarity Tuning improving example selection for synthesizing a SQLquery. In (a), the prompt example missed the key query structure (grouping and counting). With thisexample, GPT-3 generates an invalid query (b). With TST, we retrieve a relevant example whichGPT-3 successfully adapts to answer the user’s question (c).
Figure 3:	Example on CSD generating a SQL query. Given the prompt, GPT-3 makes a mistake (a)when generating the JOIN condition. CSD is able to prevent this error by (b) keeping track of tablealiases and constraining the model to respect the database schema.
Figure 4: (a) Accuracy and (b) validity of Codex predictions with and without Synchromeshon SMCalFlow as a function of the ground-truth program length. We map program lengths topercentiles, and round to the closest multiple of 10%. Error bands correspond to standard error.
Figure 5: Illustration of implementation and conceptual errors in Vega-Lite. CSD can avoid gener-ating the invalid Vega-Lite mark type “scatterplot”, though conceptual errors can still remain.
Figure 6: ValidPrefix(s) determines if s is in the prefix-closure Lc of L given the completion engine CLfor L. CSD(M, ΣM) returns a string generated by the model M ensuring that the string’s underlying tokensequence is consistent with the completion engine CL .
Figure 7: Illustration of the token misalignment problem in Vega-Lite. Colors denote Vega-Litetokens, which match how the completion engine works (and what are its completion points). Verticallines denote how GPT-3 tokenizes this program.
Figure 8: (a) Accuracy and (b) validity of Codex predictions with and without Synchromesh onSQL as a function of the ground-truth program length. We map program lengths to percentiles, andround to the closest multiple of 10%. Error bands correspond to standard error.
Figure 9: Benefit of CSD: The left plot is generated by Codex without CSD, but it has an overflowinglegend and it also raises a warning about missing values. Using CSD, we generate the plot on rightthat generates no runtime warning or error.
