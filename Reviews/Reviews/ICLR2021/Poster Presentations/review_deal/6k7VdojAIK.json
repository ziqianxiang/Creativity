{
    "Decision": {
        "title": "Final Decision",
        "decision": "Accept (Poster)",
        "comment": "I think this is a very solid and good work in the topic of \"Practical Massive Parallel MCTS.\"   I think it will be good to open up perspectives among ICLR's audience going beyond just Deep Learning and Machine Learning. I also noted a lot of positive comments during the evaluation and discussion period.\n\nStill, it was a borderline case and not an easy decision (primarily because of the concerns raised by R3 towards the end of the discussion period). In the end the program committee decided that the paper does meet the bar.  We think that the work is interesting and original, though not without weaknesses.\n"
    },
    "Reviews": [
        {
            "title": "new approach to MCTS parallelization seems to be useful",
            "review": "The authors present an approach to parallelize MCTS on a large number of processors. Out of potentially many different applications, they chose to use the domain of molecular design, and show improved performance over several baselines, including some baselines using non-parallel MCTS. Impressively, this is achieved in very little wall time.\n \n \nStrengths:\n-  Very simple idea (this is good), straightforward execution, no faff\n- The approach is non domain specific, and could be applied in many different areas\n- Good empirical results\n\n \nWeaknesses:\n- Not very fancy from the ML side\n- The validation is weak, and to some extent outdated. I understand that drug design application is only an example, however, nevertheless I would strongly suggest that the authors run the more challenging guacamol benchmark, since the benchmarks the authors use are know to be very easy (see https://github.com/BenevolentAI/guacamol / https://pubs.acs.org/doi/abs/10.1021/acs.jcim.8b00839 )\n \nQuestion:\n- How much tuning of the size of the virtual loss is required to optimally use the provided CPUs?\n- By using the virtual loss, do we lose some of the theoretical guarantees of UCT?\n \nAll in all, I think this paper could in my opinion be accepted at ICLR if the authors commit to running the harder guacamol benchmarks for the camera ready version.",
            "rating": "7: Good paper, accept",
            "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"
        },
        {
            "title": "Significant speedup for MCTS algorithms for the Molecular Design problems. The technical contribution is rather limited.",
            "review": "In this work the authors apply a distributed parallel Monte-Carlo Tree Search (MCTS) algorithm to the Molecular Design problem. The goal of this paper is to speed-up the computation needed by an MCTS algorithm using parallelization over multiple machines. The authors show how to modify a previously successful parallel MCTS algorithm (namely, TDS-DF-UCT) to address its shortcoming that leads to shallow and wide trees. The modification that is performed changes the way that the history on the nodes are stored and propagated, which leads the algorithm to construct trees with more similar characteristics with those constructed by a sequential algorithm that is allowed to use time equal to the number of processors times the time required by the parallel implementation.\n\nThe authors then apply their algorithm to the molecular design problem using a pre-trained GRU-based model for rollout and expansion, and compared the quality of the method with non-parallel implementations (that are allowed to use time equal to the time of the parallel algorithm times the number of CPUs used; the goal is to obtain solutions with quality close to the performance of such algorithms), and to existing parallel implementations of MCTS algorithms (that lead to non-ideal MCTS tree structures). The experiments show that, in terms of quality, the proposed parallel MCTS algorithm outperforms the rest of the parallel MCTS algorithms, given the same amount of time, and performs closer to the non-parallel implementation which takes much more time. \n\nFinally, the authors compare their method, in terms of quality, to state-of-the-art algorithms for the problem and show that their method outperforms the rest of the methods significantly.\n\nPROS:\n+ The experimental results show that the proposed algorithms coupled with the necessary model achieve very good parallelization\n+ The proposed algorithm outperforms the state-of-the-art approaches on an application to the Molecular Design problem\n+ This is the first work that applied the distributed parallel MCTS algorithms for the Molecular Design problem\n\nCONS:\n- The technical contribution of the paper seems rather incremental to previous work on parallel MCTS algorithms\n\nThe proposed method shows a significant speedup for the molecular design problem, and for nearly-linear speedup similar solution quality is achieved. Although I'm not an expert in Molecular Design, it seems to me that this work should also be of interest to people in Computational Chemistry. On the other hand, the new methodology is not tight to the specific application and might find applications to other problems where MCTS algorithms were found to be successful. \nMy main complaint is the incremental technical contribution of the paper, which is limited to adapting the history message passing and storing in the parallel MCTS method proposed by (Yoshizoe et al 2011). On the other hand, it is evident that this small change to the algorithm is able to achieve a much more desirable MCTS tree structure and performance. \n\nOverall, I tend to be positive about the paper, given it's claimed significant contribution in the application to the Molecular Design problem.  \n\nSmall things:\n* In Table 2, how long did you let the competitor algorithms run? Was it again 10 minutes?\n* Is the massively parallel terminology widely used for distributed parallel algorithms? This conflicts with the terminology for the Massively Parallel Computation model, which is an abstraction of MapReduce, Hadoop, and other systems. I suggest using \"Distributed Parallel\".\n* \"the the\" in page 3.",
            "rating": "5: Marginally below acceptance threshold",
            "confidence": "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper"
        },
        {
            "title": "Improves MCTS scalability significantly, nice application and strong results. Algorithm description and analysis could be more detailed.",
            "review": "Summary: The paper proposes a new algorithm to scale up parallel MCTS. The proposed method, MP-MCTS is a modified version of previous efforts to parallelize MCTS (TDS-UCT, TDS-df-UCT), all using virtual loss and modern MCTS enhancements (NN-guided selection learned offline). In exchange for small additional memory requirement, MP-MCTS is able to grow significantly deeper trees at much higher levels of parallelism. Overall, the approach is shown to be quite effective at constructing deeper trees efficiently on large MPI clusters and aligns nicely with results in the single-worker MCTS literature (shallow vs deep trees). The experimental section is nicely detailed and shows strong performance gains over the state of the art in molecular design. Overall, this seems to be a very successful scale-up of MCTS, resulting in a new state-of-the-art result in molecular design. The algorithmic description is a bit thin right now. Please consider including a detailed discussion of the pseudo-code.\n\nStrengths:\n  + Intuitively clear, reasonably well-written. The illustrative example is very helpful.\n  + Proposed algorithm significantly advances the state-of-the-art in distributed, parallel MCTS.\n  + Nicely detailed set of experiments showing intuitively clear results.\n  + The paper does a good job of making its contributions clear relative to the broader body of work in MCTS and molecular design.\n\nAreas of improvement:\n  - The main algorithmic descriptions (Section 3) feel a bit \"thin\". Details of the algorithmic contributions are difficult to spot on the first read. I had to refer to Algorithms 1 and 2 in the Appendix to understand what was really happening and the pseudo-code seems incomplete. Please consider bringing those 2 algorithms in to the main paper (although space could be tight). Also, pseudo-code for TDS-df-UCT seems to be missing.\n  - I'm not sure I fully understood the reasons behind TDS-df-UCT's shallower trees. It seems to have something to do with the search tree being biased towards making local changes (rather than propagating info at every leaf up to the root) but the paper hand-waves a bit about this aspect (\"It is presumed that TDS-df-UCT does too few backpropagations\"). Figure 5a and 5b illustrate the issues empirically which is nice, but I think a more careful explanation and / or analysis of the root cause would better motivate MP-MCTS.\n  - The terminology about workers and home processors feels like it could be simplified a bit. If I understand correctly, each node in the tree is mapped to exactly one worker (MPI process = core). Any message sent to that node will be processed by the assigned worker. Is there more to it than this?\n\nQuestions\n  * Why does TDS-df-UCT generate shallow trees?\n  * What does `node = LookUpHashTable(node)` do? \n  * Is the if-else expression in Algorithms 1 and 2 correct? Shouldn't an unsuccessful hash table lookup result in expansion rather than selection? Also, what happens to `new_node`?\n  * What exactly is the difference between worker and home processor? Doesn't the same worker handle every message sent to the tree nodes it's been assigned to?\n  * Will you be releasing source code? I didn't see any links and the pseudo-code is incomplete.\n\n\nUPDATE: I thank the authors for their detailed feedback and updated paper. I'm a bit more in favor of acceptance of the paper now. ",
            "rating": "8: Top 50% of accepted papers, clear accept",
            "confidence": "3: The reviewer is fairly confident that the evaluation is correct"
        },
        {
            "title": "An application of a novel parallel MCTS that synthesizes novel molecules and outperforms the state-of-the-art",
            "review": "In this paper, the authors propose a novel parallelized implementation of Monte\nCarlo Tree Search (MCTS) that is evaluated in a molecule design domain. The MCTS\nloop uses the outcomes from prior iterations to guide future expansion of the\nsearch tree --- this complicates attempts to parallelize the algorithm, since\nsuch approaches will need to perform some degree of speculative expansion.\nHash-driven parallelization methods --- where each node in the search tree is\n\"owned\" by a worker --- have been used in the past, together with a \"virtual loss\"\naccounting system and message passing, to successfully parallelize MCTS. By\nincluding a statistics history table in the messages, the TDS-DF-UCT algorithm\nhas been shown to scale successfully with up to 100 workers by reducing\ncommunication congestion. The authors propose a simple modification to\nTDS-DF-UCT called MP-MCTS --- namely, storing the history table in each node,\ninstead of including it in the messages --- which significantly boosts the\nscalability of the algorithm.\n\nIn the remainder of the paper, the authors evaluate MP-MCTS in a molecule\nsynthesis domain, one which has recently drawn significant attention from the ML\ncommunity. The goal in this problem is to design novel molecules that maximize a\nparticular physicochemical property (in this case, a logP measure with\npenalties), which is a standard in this area. An RNN pre-trained on a database\nof drug molecules is used to generate candidate children at each node in the\nsearch tree, as well as to perform the rollouts. The authors demonstrate that\nMP-MCTS displays much better scaling behavior compared to prior parallel MCTS\nimplementations (TDS-UCT and TDS-DF-UCT) with up to 1024 workers. They also\nshow striking improvements over prior state-of-the-art methods for molecule\nsynthesis.\n\nStrengths of the paper:\n  + MCTS methods are of broad interest to the AI/ML community and this paper\n    offers an interesting application of the algorithm to a new, non-traditional\n    domain that has already drawn prior interest from ML researchers (including\n    publications at NeurIPS, ICML etc.).\n  + The parallel implementation of MCTS described is general and could be\n    applied to other problems.\n  + The proposed enhancement, while relatively straightforward, nevertheless\n    appears to offer significant gains, thus making it easy to adopt.\n  + The paper is well-written, organized and easy to follow.\n\nAreas for improvement/questions for the authors:\n  - While the results in Table 1 are convincing, I found the results in Table 2\n    less so, since computational resources have not been controlled for. While\n    there is merit to simply comparing the best molecules found by each method,\n    one does have to wonder how well something MolecularRNN might do with the\n    equivalent of 1024*10 core minutes.\n  - I found that the paper's reasons for MP-MCTS's gains over TDS-DF-UCT\n    somewhat unclear. Is it the fact that the messages that need to be passed\n    between workers are smaller in size? I also didn't understand what caused\n    TDS-DF-UCT to build wider/shallower trees. A slightly more detailed\n    discussion of this would be welcome and strengthen the paper.\n\nOn balance, I find it noteworthy that such a subtle tweak to an established\nalgorithm produces such significant improvement in performance on this domain.\nWhile there are some methodological questions and some claims that may need\ntempering, I think the results are sufficiently interesting for me to recommend\nACCEPTANCE.\n\nMinor comment:\n  - On page 3, the authors write: \"and a level d node denotes the d-th symbol\n    in a SMILES string\". I found this a little confusing at first. I might\n    consider rephrasing this along the lines of: \"each path through the tree\n    represents a left-to-right enumeration of the characters in the SMILES\n    string\".\n",
            "rating": "7: Good paper, accept",
            "confidence": "3: The reviewer is fairly confident that the evaluation is correct"
        },
        {
            "title": "Parallelizing MCTS for chemical design; it's domain application is currently under-studied.",
            "review": "This paper aims to provide a scalable and competitive molecular design technique based on MCTS. Machine learning guided molecular design is a popular field and many solutions have been developed in the recent years. There is appeal, due to the high dimensionality of search space, to resort to MCTS based approaches that leverage stochastic pruning of the search space as an effective way of making the problem tractable. \n\nPositives: \n- The innovations herein are focused on engineering a parallelizable MTCS algorithm that can explore the space much faster (though it requires much higher compute at once).  This can be a useful tool for faster computation and proposal of drug-like molecules\n\nNegatives: \n- In principle the methods introduced here have little specialized domain relevance to chemical design. I.e. it's unclear why the paper is focused on chemical design and benchmarks itself there. It seems more appropriate to show that the scalability can be general to any MCTS application. As such, it might be better to apply it in spaces where MCTS is already better developed. \n\n- The paper is light on results and their discussion. Instead of spending as much space talking about how MTCS works, which is well known, the authors are better off showing more metrics related to drug-likeness (e.g. QED) or validity checks.  It is unclear if the solutions proposed are actually sensible which could overstate the performance of the method. Adding long chains of carbon to improve the score is a notorious problem for these design methods, and it does seem to be an issue for the designed molecules presented in the appendix. I'm not a chemist so I cannot validate this molecules by eye, but I am quite concerned about the lack of validity checks. \n- Comparison and discussion of more performant methods like Zhou et al 2019 Scientific Reports (optimization of molecules via RL). \n- It is also unclear if the scoring method for logP used in this study is the same as the one used by the other methods mentioned. At least it doesn't seem to match the method used in Zhou et al 2019 or others reported there. \n\nMinor comments\nTable 1 boldface is confusing, it makes more sense to boldface the best performing models. \n\n\n------\n\nI think the paper makes some interesting engineering contributions, but the focus on chemical design is somewhat arbitrary, and the authors don't investigate the domain application with enough depth. Especially, I'm quite concerned about validity of the designed molecules, and lack of clarity that all methods reported herein are actually run with the same scoring method (e.g. the numbers aren't simply picked up from elsewhere when the oracle was different).  If the authors are able to provide more reassurance about the validity of the design, and the soundness of the oracle they have chosen to use, I'm happy to improve my score. ",
            "rating": "3: Clear rejection",
            "confidence": "3: The reviewer is fairly confident that the evaluation is correct"
        }
    ]
}