{
    "Decision": "",
    "Reviews": [
        {
            "title": "A nice proposed idea and new dataset, but with confusing presentation and evaluation",
            "review": "This paper introduces a modification to the wake-sleep algorithm that introduces into the recognition network a cache which holds a small number of high-quality proposed latent variables, and uses discrete sampling from this cache instead of using draws from the recognition network directly. It's a nice idea, but unfortunately the presentation is quite unclear, and the experiments do not really succeed in isolating the effect of this particular contribution.\n\nThere is an extensive introduction and background, which aims to situate this work, but overall it is a bit confusing (and strays a bit afield, e.g. why is there a description of SGD in connection to deep meta-learning? noting that this paper is nearly two pages over length…).  \n\n- Much language is devoted to the idea that a variational autoencoder setting is \"better\" than wake-sleep for learning deep generative models, because it provides a single unifying objective function. This shows up also in language like in table 2 (\"the correct update for q\", whereas the wake-sleep update \"may be heavily biased\"). This doesn't make much sense. There may well be empirical reasons to prefer the performance of a VAE as opposed to wake-sleep, but the issue of whether it \"will converge on a good model\" is clearly an issue in VAEs as well (see, e.g., the \"hacks\" necessary to achieve convergence to a non-spurious optima in [1]). This paper's own experiments seem to show that, for these discrete models, achieving convergence is a non-issue for wake-sleep.\n\n- In section 2.3 it is claimed this \"highlights a bias-variance tension\". This doesn't make any sense; the \"sleep\" update to q in wake-sleep is its own update, and not a biased approximation to the ELBO; there is nothing inherently wrong with the dual objectives used in the wake-sleep agorithm. Each is easily motivated as maximizing a lower bound on the marginal likelihood; the sleep update could alternately be motivated as performing variational inference, simply with a alpha-divergence as the objective.\n\n- There are claims here that the challenges to good VAE performance are due to inaccurate inference networks, but this is not clear at all (see, e.g. [2]).\n\n- Wake-sleep seems to be presented primarily as a straw-man, with little effort to actually benchmark against it or consider its merits. In particular, reweighted wake-sleep [3] and related wake-wake algorithms [4] should address any potential bias concerns, at modest increase in computational cost.\n\n- Given that much of the focus is on how this paper uses a direct estimate of an ELBO, in constrast to wake-sleep, it is completely baffling that this objective function never once appears in the main text of the paper! The only statement of it is in table 2 (which is an incomplete objective, and doesn't include M) and implicitly in the algorithm block itself. Figure 2 is nice as a sales pitch, but it doesn't replace actually writing down the objective functions used for training!\n\n- Why are the latent variables z_i refered to as \"programs\" in section 2.3? This is simply a latent variable, and is a free choice for the model designer depending on problem domain. If the point here is that this is a discrete latent variable, or in some sort of combinatorial / structured space, then say that. \n\n- There is some confusion here about what is a \"prior\" in section 3. A prior is not something which is \"learned\" empirically from data as part of the training (empirical Bayes procedures notwithstanding), A prior is literally a prior belief on parameters. Estimating a marginal distribution p(z), isnot learning a prior, it is doing density / distribution estimation. That's also fine, but (as noted) likely additional regularization is needed. In the VAE setting, the phrase \"marginal posterior\" is often used for q(z) = 1/N \\sum_i q(z_i | x_i), i.e. marginalizing over the data.\n\n- The experiments are all nice examples of discrete domains, and I like the new dataset as a testbed for fitting regular expressions a lot.\n\nIn general, I think this paper would benefit from a much more expanded and clear presentation of the contents of section 3. At the moment, the algorithm is only understandable from a close read of the algorithm block. The core novel idea here is the introduction of the \"memory\" block into the wake-sleep algorithm, but this is only briefly described. Some experiments here which isolate the impact of this memory block on training would be great — for example, how does performance vary given different sizes of the memory? In the experiments, there is not a huge performance gap between the proposed approach and wake-sleep; it would be good to also compare reweighted wake sleep as a comparison. It would also be good to run the importance sampled variant of the proposed approach (or, even, a variant which directly marginalizes over the contents of the memory). In terms of framing, I don't really see what this paper has to do with \"few-shot program learning\", aside from the fact that the test examples happen to be structured domains (it is arguable whether e.g. the compositional kernels are \"programs\").\n\n\n[1] Bowman et al, Generating Sentences from a Continuous Space\n[2] Shu et al, Amortized Inference Regularization\n[3] Bornschein and Bengio, Reweighted wake-sleep\n[4] Le et al, Revisiting Reweighted Wake-Sleep\n\n",
            "rating": "3: Clear rejection",
            "confidence": "5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature"
        },
        {
            "title": "Biased particle-based gradient estimator; no comparison to related algorithms",
            "review": "The paper introduces a new training algorithm for generative latent variable models called Wake-Sleep-Remember (WSR). The authors note that it is related to Wake-Sleep (WS) and is supposed to improve on it. \n\nWSR uses samples from p(x, z) to train the recognition model q(z|x), similarly to WS.  The authors note that the gradient estimator of decoder parameters in WS is biased with respect to the ELBO, because samples are taken from q(z|x) instead of intractable p(z|x). To alleviate this issue, in WSR samples from q are cached (remembered), and p(x, z) is trained on samples from the cache instead of being trained on samples from q directly, which is the case in WS. In particular, the cache has a fixed size of k samples per data point, and samples are weighted according to the log probability under the model p(x, z). Whenever any of the samples in the cache is less probable under the model than a new sample from q (for that data point), it gets replaced by that new sample. The authors argue that this procedure reduces the bias of the decoder update of WS, because the decoder is trained only on “good” samples. \n\nIt is also noted in §2.3¶2 that optimising the ELBO in VAEs and WS relies on the ability of q to match the true posterior exactly - a failure to do so leads to a modification of p.  IWAE [1] and RWS [2] alleviate this issue by importance sampling. Interestingly, WSR could also mitigate this issue, but authors do not comment on that.\n\nWSR is strongly related to RWS, but the authors seem to have missed the connection. Both algorithms require evaluation of p(x, z) on k samples from q at every training iteration. The only difference seems to be that WSR can populate the cache with samples that have very high probability under the model and can reuse the same sample from the cache multiple times to train p. RWS, on the other hand, draws new samples at every training iteration. While both algorithms feature the same computational cost, the approach of RWS is based on importance sampling and the resulting gradient estimator is unbiased (but see [3]). This is unlike WSR, in which samples in the cache are updated with samples that have higher log probability under the model. This can lead to a scenario where the cache contains samples from only one mode of the posterior, or even where it is filled with virtually the same sample replicated k times. This leads to a biased gradient estimator.\n\nThe proposed algorithm is evaluated on three problems: (1) learning cellular automata, (2) composing gaussian process kernels and (3) discovering text concepts, all of which involve discrete latent variables. WSR is compared WS, a VAE with a control variate and a WSR model without a recognition model. The last baseline corresponds to a lesioned version of WSR to gauge how important the cache (memory) is. WSR achieves the highest quantitative results and produces the best looking qualitative results from all considered baselines. Experimental evaluation would be sufficient, if not for the fact that it does not feature comparison to other particle-based inference algorithms like IWAE or RWS, which are closely related to WSR. It is hard to say whether WSR is useful despite its biased gradient estimates, since both IWAE and RWS tend to achieve much better results than VAE and WS, respectively [4].\n\nThe paper is generally well written, but it is confusing in a few places. For instance, the “memory” used in WSR is a type of cache and is unrelated to other (working/external/episodic) memory used in literature - it is purely algorithmic, and not architectural component. It would be clear if it was treated as such. For instance, I the “memory” column in Table 2 confusing.  Moreover, it calls the latent variable “z” a stochastic program, which is not necessary - it is just a discrete latent variable. “ELBo” is typically written as “ELBO”.\n\nIt is an interesting paper, but the authors does not seems to realize that they have introduced significant biased by updating the cache at every training iteration, nor do they notice links to RWS. I believe the paper should be rejected, as it might otherwise be confusing for inexperienced readers.\n\n[1] Burda, Y., Grosse, R.B., & Salakhutdinov, R. (2015). Importance Weighted Autoencoders. CoRR, abs/1509.00519.\n[2] Bornschein, J., & Bengio, Y. (2014). Reweighted Wake-Sleep. CoRR, abs/1406.2751.\n[3] Tucker, G., Lawson, D., Gu, S., & Maddison, C. J. (2018). Doubly Reparameterized Gradient Estimators for Monte Carlo Objectives. arXiv preprint arXiv:1810.04152.\n[4] Le, T.A., Kosiorek, A.R., Siddharth, N., Teh, Y.W., & Wood, F. (2018). Revisiting Reweighted Wake-Sleep. CoRR, abs/1805.10469.",
            "rating": "3: Clear rejection",
            "confidence": "5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature"
        },
        {
            "title": "Interesting idea. Presentation is unclear and requires more work.",
            "review": "In this work the authors propose a learning algorithm for inferring generative programs and the concepts associated with the input data. Specifically, the idea is originated from amortised inference where a generative model (the mapping from the latent to the data) is learned simultaneously with the reverse mapping, i.e., the recognition network, in a joint optimisation framework following variational Bayes. In this work the authors further introduce a memory buffer of highly probable latent samples from the recognition model in order to avoid evaluating programs that are unlikely to have generated the data. The main challenge of the algorithm is the handling of the discrete nature of the latent state.\n\nIn general, as having little experience with programs and automata I found the paper genuinely interesting, but also very confusing. On the positive side, the authors managed to nicely motivate their work and tried to make a direct connection to popular approaches like the VAE and the sleep and wake algorithm. However, even after putting a lot of effort in understanding the paper, I am still not confident that I managed to extract all the important information out of the manuscript.\n\n* More specifically, the paper lacks in clarity and the presentation of the main methodology needs improvement. The proposed algorithm is presented in a rather convoluted way and lacks a proper formulation. Apart from the general equation of the ELBO the rest of the methodology looks more like a guide to follow rather than a scientific presentation of a novel idea. The authors need to put significantly more effort in communicating better their work. It cannot be the case that out of a 10-page paper the whole idea is summarised/compressed in the last two small paragraphs of page 4.\n\n* In these paragraphs (end of page 4) the authors describe the proposed idea of having a memory buffer to store latent samples. They also refer to their joint p(z, x). I have a couple of questions here. First of all, what is the form of it? Furthermore, do we use this probability as weights in order to later resample from the memory to train the generative model?\n\n* Also, in Algorithm 1 different parameters in different distributions are all denoted as \\theta. This is very confusing. I really struggle to follow the algorithm as none of the involved distributions is properly defined, and we do not even know what and how many parameters do we need to optimise. I am also confused with the flow of the algorithm. Is it a single objective that we optimise in one go as the gradient update suggests? Are we optimising in turns? What happened to the KL term of the variational bound? When/where is the prior been updated?\n\n* Regarding the update of the recognition network in the sleep phase. Due to the nature of the optimisation scheme the recognition network is being updated after having access to the optimal (up to that point) variational parameters (do you learn a q(z)?) and prior p(z). This is definitely acceptable, however, it would be fair to do a similar two-step update for the VAE. A similar idea has been studied in [Krishnan et al. 2018].\n[Krishnan et al. 2018] “On the challenges of learning with inference networks on sparse, high-dimensional data”. AISTATS 2018\n\n* In the beginning of Section 3 the authors argue that their work considerably differs from a VAE, because the proposed algorithm tries to recover a distribution of a latent program that generates the observations rather than a latent vector. To my understanding---correct me if I am wrong but it is nowhere mentioned in the main text apart from the caption of Figure 1---a latent program is just a categorical distribution that spits out the alphabet needed to construct the observations. To me this is exactly the same as what VAEs do with just using a categorical variational distribution. The only difference is the discrete nature of the latent variable and the fact that you also try to learn the prior p(z), which you refer to it as inductive bias. Can the authors please comment on that?\n\n* Regarding the discrete latent state and optimisation of VAE the authors use the REINFORCE algorithm. Can a trick similar to Gumbel-softmax [Jang et al. 2017] be exploited for the purposes of this work. Does it make any sense? If yes what are the implications?\n[Jang et al. 2017]. “Categorical Reparameterization with Gumbel-Softmax”. ICLR 2017\n\n* In the experiment in Figure 4 you compare wallclock time of the algorithms. In such a plot I would expect to see different algorithms terminating at different time. This is not the case in the plot, although you explicitly mention that the proposed algorithm requires several times more computation per iteration. Can you please explain? Also, there is no text explaining Figure 7.\n\n---Minor issues---\n* Page 3: “needn’t” → “need not”\n* Page 7: “marginal likelihood p(x|z)” --> this is not the marginal\n* Page 7: “estimates a lower bound on p(x|z)” → the lower bound is on the marginal p(x).\n\nOverall, based on my detailed comments above I believe that the paper is not ready for publication. Thus my recommendation is to reject.\n",
            "rating": "3: Clear rejection",
            "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"
        }
    ]
}