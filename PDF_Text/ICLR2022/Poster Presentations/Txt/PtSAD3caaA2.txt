Published as a conference paper at ICLR 2022
Maximum Entropy RL (Provably) Solves Some
Robust RL Problems
Benjamin Eysenbach	Sergey Levine
Carnegie Mellon University, Google Brain	UC Berkeley, Google Brain
beysenba@cs.cmu.edu
Abstract
Many potential applications of reinforcement learning (RL) require guarantees that
the agent will perform well in the face of disturbances to the dynamics or reward
function. In this paper, we prove theoretically that maximum entropy (MaxEnt)
RL maximizes a lower bound on a robust RL objective, and thus can be used to
learn policies that are robust to some disturbances in the dynamics and the reward
function. While this capability of MaxEnt RL has been observed empirically in
prior work, to the best of our knowledge our work provides the first rigorous proof
and theoretical characterization of the MaxEnt RL robust set. While a number
of prior robust RL algorithms have been designed to handle similar disturbances
to the reward function or dynamics, these methods typically require additional
moving parts and hyperparameters on top of a base RL algorithm. In contrast, our
results suggest that MaxEnt RL by itself is robust to certain disturbances, without
requiring any additional modifications. While this does not imply that MaxEnt RL
is the best available robust RL method, MaxEnt RL is a simple robust RL method
with appealing formal guarantees.
1 Introduction
Many real-world applications of reinforcement
learning (RL) require control policies that not
only maximize reward but continue to do so
when faced with environmental disturbances,
modeling errors, or errors in reward specifica-
tion. These disturbances can arise from human
biases and modeling errors, from non-stationary
aspects of the environment, or actual adversaries
acting in the environment. A number of works
have studied how to train RL algorithms to be
robust to disturbances in the environment (e.g.,
Morimoto & Doya (2005); Pinto et al. (2017);
Tessler et al. (2019)). However, designing robust
RL algorithms requires care, typically requiring
an adversarial optimization problem and intro-
ducing additional hyperparameters (Pinto et al.,
2017; Tessler et al., 2019). Instead of designing
a new robust RL algorithm, we will instead an-
alyze whether an existing RL method, MaxEnt
Figure 1: MaxEnt RL is robust to disturbances.
(Left) We applied both standard RL and MaxEnt RL
to a manipulation task without obstacles, but added ob-
stacles (red squares) during evaluation. We then plot the
position of the object when evaluating the learned poli-
cies (Center) on the original environment and (Right)
on the new environment with an obstacle. The stochastic
policy learned by MaxEnt RL often navigates around the
obstacle, whereas the deterministic policy from standard
RL almost always collides with the obstacle.
RL, offers robustness to perturbations. MaxEnt RL methods are based on the maximum entropy
principle, and augmented the expected reward objective with an entropy maximization term (Ziebart
et al., 2008). Prior work has conjectured that such algorithms should learn robust policies (Haarnoja
et al., 2017; Huang et al., 2019), on account of the close connection between maximum entropy
methods and robustness in supervised learning domains (Grunwald et al., 2004; Ziebart, 2010).
However, despite decades of research on maximum entropy RL methods (Kappen, 2005; Todorov,
2007; Toussaint, 2009; Theodorou et al., 2010), a formal characterization of the robustness properties
of such approaches has proven elusive. To our knowledge, no prior work formally proves that MaxEnt
RL methods are robust, and no prior work characterizes the disturbances against which these methods
1
Published as a conference paper at ICLR 2022
are robust. Showing how to obtain robust policies from existing MaxEnt RL methods, which already
constitute a significant portion of the RL methods in use today (Abdolmaleki et al., 2018; Haarnoja
et al., 2018a; Vieillard et al., 2020), would be useful because it would enable practitioners to leverage
existing, tried-and-true methods to solve robust RL problems.
Stochastic policies, of the sort learned with MaxEnt RL, inject noise into the actions during training,
thereby preparing themselves for deployment in environments with disturbances. For example, in
the robot pushing task shown in Fig. 1, the policy learned by MaxEnt RL pushes the white puck to
the goal using many possible routes. In contrast, (standard) RL learns a deterministic policy, always
using the same route to get to the goal. Now, imagine that this environment is perturbed by adding
the red barrier in Fig. 1. While the policy learned by (standard) RL always collides with this obstacle,
the policy learned by MaxEnt RL uses many routes to solve the task, and some fraction of these
routes continue to solve the task even when the obstacle is present. While a number of prior works
have articulated the intuition that the stochastic policies learned via MaxEnt RL should be robust to
disturbances (Levine, 2018; Abdolmaleki et al., 2018; Lee et al., 2019), no prior work has actually
shown that MaxEnt RL policies are provably robust, nor characterized the set of disturbances to
which they are robust. Applications of MaxEnt RL methods to problems that demand robustness are
likely hampered by a lack of understanding of when such methods are robust, what kinds of reward
functions should be used to obtain the desired type of robustness, and how the task should be set up.
The goal in our work is to make this notion precise, proving that MaxEnt RL is already a robust RL
algorithm, and deriving the robust set for these policies.
The main contribution of this paper is a theoretical characterization of the robustness of existing
MaxEnt RL methods. Specifically, we show that the MaxEnt RL objective is a nontrivial lower bound
on the robust RL objective, for a particular robust set. Importantly, these two objectives use different
reward functions: to learn a policy that maximizes a reward function on a wide range of dynamics
functions, one should apply MaxEnt RL to a pessimistic version of that reward function. MaxEnt
RL is not robust with respect to the reward function it is trained on. As we will show, the robust set
for these methods is non-trivial, and in some important special cases can be quite intuitive. To our
knowledge, our results are the first to formally show robustness of standard MaxEnt RL methods to
dynamics perturbations and characterize their robust set. Importantly, our analysis and experiments
highlight that robustness is only achieved for relatively large entropy coefficients. We validate our
theoretical results on a set of illustrative empirical experiments.
2	Related Work
The study of robustness in controls has a long history, with robust or H∞ control methods proposing
provably robust solutions under various assumptions on the true dynamics (Zhou et al., 1996; Doyle
et al., 2013). RL offers an appealing alternative, since robust RL methods can in principle learn robust
policies without knowing the true dynamics. However, policies learned by standard RL algorithms
often flounder in the face of environmental disturbances (Rajeswaran et al., 2016; Peng et al.,
2018). The problem of learning robust policies that achieve high reward in the face of adversarial
environmental disturbances, often called robust RL, has been well studied in the literature (Bagnell
et al., 2001; Nilim & Ghaoui, 2003; Morimoto & Doya, 2005; Pinto et al., 2017; Tessler et al., 2019;
Russel & Petrik, 2019; Kamalaruban et al., 2020; Russel et al., 2020; 2021; Derman et al., 2021).
Prior robust RL methods are widely-applicable but often require many additional hyperparameters
or components. For example, Bagnell et al. (2001) modify the Bellman backup in a Q-learning by
solving a convex optimization problem in an inner loop, and Tessler et al. (2019) trains an additional
adversary policy via RL.
Robust RL is different from robust control in the traditional sense, which focuses on stability
independent of any reward function (Zhou et al., 1996; Doyle et al., 2013). Robust RL problem
involves estimating a policy’s returns under “similar” MDPs, a problem that has been studied
in terms of distance metrics for MDPs (Lecarpentier et al., 2020). Robust RL is different from
maximizing the average reward across many environments, as done by methods such as domain
randomization (Sadeghi & Levine, 2016; Rajeswaran et al., 2016; Peng et al., 2018). Closely related
to robust RL are prior methods that are robust to disturbances in the reward function (Hadfield-Menell
et al., 2017; Bobu et al., 2020; Michaud et al., 2020), or aim to minimize a cost function in addition
to maximizing reward (Chow et al., 2017; Achiam et al., 2017; Chow et al., 2019; Carrara et al.,
2019; Tang et al., 2020; Thananjeyan et al., 2021). Robust RL is also different from the problem of
2
Published as a conference paper at ICLR 2022
learning transferable or generalizable RL agents (Lazaric, 2012; Zhang et al., 2018; Justesen et al.,
2018; Cobbe et al., 2019), which focuses on the average-case performance on new environments,
rather than the worst-case performance.
3	Preliminaries
We assume that an agent observes states St, takes actions at 〜∏(at | st), and obtains re-
wards r(st,at). The initial state is sampled si 〜pι(sι), and subsequent states are sampled
st+i 〜p(st+ι | st, at). We will use pπ(T) to denote the probability distribution over trajectories
for policy ∏. Episodes have T steps, which we summarize as a trajectory T，(si, ai,…,st, aτ).
Without loss of generality, we can assume that rewards are undiscounted, as any discount can be
addressed by modifying the dynamics to transition to an absorbing state with probability 1 - γ. The
standard RL objective is:
T
arg max ET〜p∏(τ) Tr
π
(st, at) , where pπ (T) = p1 (si)	p(st+i | st, at)π(at | st)dT
t=1
is the distribution over trajectories when using policy π . In fully observed MDPs, there always exists
a deterministic policy as a solution (Puterman, 2014). The MaxEnt RL objective is to maximize the
sum of expected reward and conditional action entropy. Formally, we define this objective in terms of
a policy π, the dynamics p and the reward function r:
JMaxEnt(π; p, r) , Eat〜π(at |st),st + ι〜p(st+ι |st,at) ] ^X r(St, at) + αHπ [at | st] ,	(I)
where Hn [at | st] = JA ∏(at | st)log n但：艮)dat denotes the entropy of the action distribution. The
entropy coefficient α balances the reward term and the entropy term; we use α= 1 in our analysis.
As noted above, the discount factor is omitted because it can be subsumed into the dynamics.
Our main result will be that maximizing the MaxEnt RL objective (Eq. 1) results in robust policies.
We quantify robustness by measuring the reward of a policy when evaluated on a new reward function
r or dynamics function p, which is chosen adversarially from some set:
maχ min 一 Ep(St+ ι∣st,at),∏(at |st) Tr(St, at)
π p∈P r∈R
p∈P ,r∈R
This robust RL objective is defined in terms of the sets of dynamics P and reward functions R.
Our goal is to characterize these sets. The robust RL objective can be interpreted as a two-player,
zero-sum game. The aim is to find a Nash equilibrium. Our goal is to prove that MaxEnt RL (with
a different reward function) optimizes a lower bound this robust objective, and to characterize the
robust sets P and R for which this bound holds.
4	MaxEnt RL and Robust Control
In this section, we prove the conjecture that MaxEnt RL is robust to disturbances in the environment.
Our main result is that MaxEnt RL can be used to maximize a lower bound on a certain robust RL
objective. Importantly, doing this requires that MaxEnt RL be applied to a different, pessimistic,
version of the target reward function. Before presenting our main result, we prove that MaxEnt RL is
robust against disturbances to the reward function. This result is a simple extension of prior work,
and we will use this result for proving our main result about dynamics robustness
4.1	Robustness to Adversarial Reward Functions
We first show that MaxEnt RL is robust to some degree of misspecification in the reward function.
This result may be useful in practical settings with learned reward functions (Fu et al., 2018; Xu &
Denil, 2019; Michaud et al., 2020) or misspecified reward function (Amodei et al., 2016; Clark &
Amodei, 2016). Precisely, the following result will show that applying MaxEnt RL to one reward
function, r(st, at), results in a policy that is guaranteed to also achieve high return on a range of
other reward functions, r(st, at) ∈ R:
3
Published as a conference paper at ICLR 2022
Theorem 4.1. Let dynamics p(st+1 | st, at), policy π(at | st), and reward function r(st, at) be
given. Assume that the reward function is finite and that the policy has support everywhere (i.e.,
π(at | st ) > 0 for all states and actions). Then there exists a positive constant > 0 such that the
MaxEnt RL objective JMaxEnt is equivalent to the robust RL objective defined by the robust set R(π):
min
U ʃ ■
r∈R(∏)
e[ X r(st, at)] = JMaxEnt(不P, r)
∀π,
where the adversary chooses a reward function from the set
R(Tn) , {r(st, at)
exp(r(st, at0) - r(st, at))dat
(2)
Thus, when we use MaxEnt RL with some reward function r, the policy obtained is guaranteed to
also obtain high reward on all similar reward functions r that satisfy Eq. 2. We discuss how MaXEnt
RL can be used to learn policies robust to arbitrary sets of reward functions in Appendix A.10. The
proof can be found in Appendix A.2, and is a simple extension of prior work (Grunwald et al., 2004;
Ziebart et al., 2011). Our proof does not assume that the reward function is bounded nor that the
policy is convex. While the proof is straightforward, it will be useful as an intermediate step when
proving robustness to dynamics in the next subsection.
The robust set R corresponds to reward functions r that are not too much smaller than the original
reward function: the adversary cannot decrease the reward for any state or action too much. The
robust set R depends on the policy, so the adversary has the capability of looking at which states
the policy visits before choosing the adversarial reward function r. For example, the adversary may
choose to apply larger perturbations at states and actions that the agent frequently visits.
4.2	Robustness to Adversarial Dynamics
We now show that MaxEnt RL learns policies that are robust to perturbations to the dynamics.
Importantly, to have MaxEnt RL learn policies that robustly maximize one a reward function, we will
apply MaxEnt RL to a different, pessimistic reward function:
r(st, at, st+ι)，Tlogr(st, at) + H[st+1 | st, at].	(3)
The log(∙) transformation is common in prior work on learning risk-averse policies (Mihatsch &
Neuneier, 2002). The entropy term rewards the policy for vising states that have stochastic dynamics,
which should make the policy harder for the adversary to exploit. In environments that have the
same stochasticity at every state (e.g., LG dynamics), this entropy term becomes a constant and
can be ignored. In more general settings, computing this pessimistic reward function would require
some knowledge of the dynamics. Despite this limitation, we believe that our results may be of
theoretical interest, taking a step towards explaining the empirically-observed robustness properties
of MaxEnt RL.
To formally state our main result, we must define the range of “similar” dynamics functions against
which the policy will be robust. We use the following divergence between two dynamics functions:
d(p,p;τ), X log ZZa×s P⅛+⅛⅛) dat0dst+10.	(4)
This divergence is large when the adversary,s dynamics p(st+ι | st, at) assign low probability to a
transition with high probability in the training environment p. Our main result shows that applying
MaxEnt RL to the pessimistic reward function results in a policy that is robust to these similar
dynamics functions:
Theorem 4.2. Let an MDP with dynamics p(st+1 | st, at) and reward function r(st, at) > 0 be
given. Assume that the dynamics have finite entropy (i.e., H[st+1 | st, at] is finite for all states and
actions). Then there exists a Constant E > H∏* [at | st] such that the MaxEnt RL objective with
dynamics P and reward function r is a lower bound on the robust RL objective
min JMaxEnt(∏;P,r) ≥ exp( JMaxEnt(∏;P, r) + logT),
p∈P(∏)
4
Published as a conference paper at ICLR 2022
where the robust set is defined as
E	∏(at∣st)
p(st+1 |st,at)
[d(P,P； T)] ≤ e
(5)
In defining the robust set, the adversary chooses a dynamics function from the robust Set P inde-
pendently at each time step; our next result (Lemma 4.3) will describe the value of in more detail.
The proof, presented in Appendix A.4, first shows the robustness to reward perturbations implies
robustness to dynamics perturbations and then invokes Theorem 4.1 to show that MaxEnt RL learns
policies that are robust to reward perturbations.
This result can be interpreted in two ways. First, if a user wants to acquire a policy that optimizes
a reward under many possible dynamics, we should run MaxEnt RL with a specific, pessimistic
reward function 尸(st, at,st+ι). This pessimistic reward function depends on the environment
dynamics, so it may be hard to compute without prior knowledge or a good model of the dynamics.
However, in some settings (e.g., dynamics with constant additive noise), we might assume that
H[st+1 | st , at] is approximately constant, in which case we simply set the MaxEnt RL reward to
f(st, at, st+ι) = log r(st, at). Second, this result says that every time a user applies MaxEnt RL,
they are (implicitly) solving a robust RL problem, one defined in terms of a different reward function.
This connection may help explain why prior work has found that the policies learned by MaxEnt RL
tend to be robust against disturbances to the environment (Haarnoja et al., 2019).
Theorem 4.2 relates one MaxEnt RL problem to another (robust) MaxEnt RL problem. We can also
show that MaxEnt RL maximizes a lower bound on an unregularized RL problem.
Corollary 4.2.1. Under the same assumptions as Theorem 4.1 and 4.2, the MaxEnt RL problem is a
lower bound on the robust RL objective:
~ min ~	Ep(st+ι∣st,at),∏(at∣st) Er(St, at) ≥ exP(jMaxEnt(n； P, r) + log T),
p∈P(∏),r∈R(∏)	+
where the robust sets P (π) and R(π) as defined as in Theorem 4.1 and 4.2.
Our next result analyzes the size of the robust set by providing a lower bound on . Doing so proves
that Theorem 4.2 is non-vacuous and will also tell us how to increase the size of the robust set.
Lemma 4.3. Assume that the action space is discrete. Let a reward function r(st, at) and dynamics
p(st+1 | st, at) be given. Let π(at | st) be the corresponding policy learned by MaxEnt RL. Then
the size of (in Eq. 5) satisfies the following:
e = T ∙ E	at〜∏(at∣st),	[Hp[st+1 | St, at]	+ H∏[at	|	St]]	≥ T ∙ E	at〜π(at∣st),	[H∏[at	|	St]].
st+ι~p(st+ι∣st,at)	st+1 〜p(st+ι∣st,at)
This result provides an exact expression for . Perhaps more interesting is the inequality, which says
that the size of the robust set is at least as large as the policy’s entropy. For example, if MaxEnt
RL learns a policy with an entropy of 10 bits, then ≥ 10. This result immediately tells us how
to increase the size of the robust set: run MaxEnt RL with a larger entropy coefficient α. Many
popular implementations of MaxEnt RL automatically tune the entropy coefficient α so that the
policy satisfies an entropy constraint (Haarnoja et al., 2018b). Our derivation here suggests that the
entropy constraint on the policy corresponds to a lower bound on the size of the robust set.
The constraint in the definition of the robust set holds in expectation. Thus, the adversary can make
large perturbations to some transitions and smaller perturbations to other states, as long as the average
perturbation is not too large. Intuitively, the constraint value is the adversary’s “budget,” which it
can use to make large changes to the dynamics in just a few states, or to make smaller changes to the
dynamics in many states.
4.3	Worked Examples
This section provides worked examples of our robustness results. The aim is to build intuition for what
our results show and to show that, in simple problems, the robust set has an intuitive interpretation.
5
Published as a conference paper at ICLR 2022
Figure 2: MaxEnt RL and Robustness to Adversarial Reward Functions: (Left) Applying MaxEnt RL
to one reward function (red dot) yields a policy that is guaranteed to get high reward on many other reward
functions (blue curve). (Center) For each reward function (r(a = 1), r(a = 2)) on that blue curve, we evaluate
the expected return of a stochastic policy. The robust RL problem (for rewards) is to choose the policy whose
worst-case reward (dark blue line) is largest. (Right) Plotting the MaxEnt RL objective (Eq. 1) for those same
policies, we observe that the MaxEnt RL objective is identical to the robust RL objective .
Reward robustness. We present two worked examples of reward robustness. To simplify analysis,
we consider the following, smaller robust set, which effectively corresponds to a weaker adversary:
r(st , at)
log J exp(r(st, at) - r(st, at))dat0 ≤ 提} ⊆ R.
(6)
For the first example, define a 2-armed bandit with the following reward function and corresponding
robust set:
r(a) =	21
a=1
a=2
log	exp(r(a) — f(a))da ≤
A
Fig. 2 (left) plots the original reward function, r as a red dot, and the collection of reward functions,
R, as a blue line. In the center plot we plot the expected reward for each reward in R as a function of
the action a. The robust RL problem in this setting is to choose the policy whose worst-case reward
(dark blue line) is largest. The right plot shows the MaxEnt RL objective. We observe that the robust
RL objective and the MaxEnt RL objectives are equivalent.
For the second example, we use a task with a 1D, bounded action space A = [-10, 10] and a reward
function composed of a task-specific reward rtask and a penalty for deviating from some desired
action a*: r(s, a)，rtask(s, a) — (a — a*)2. The adversary will perturb this desired action by an
amount ∆a and decrease the weight on the control penalty by 50%, resulting in the following reward
function: f(s, a)，rtask(s, a) — 2 (a — (a* + ∆a))2. In this example, the subset of the robust set in
Eq. 6 corresponds to perturbations ∆a that satisfy
∆a2+1 log(2π)+ιog(20) ≤ T
Thus, MaxEnt RL with reward function r yields a policy that is robust against adversaries that perturb
a* by at most ∆a = O(√e). See Appendix A.3 for the full derivation.
Dynamics robustness. The set of dynamics we are robust against, P , has an intuitive interpretation
as those that are sufficiently close to the original dynamics p(st+1 | st , at ). This section shows that,
in the case of linear-Gaussian dynamics (described at the end of this subsection), this set corresponds
to a bounded L2 perturbation of the next state.
Because the robust set in Theorem 4.2 is defined in terms of the policy, the adversary can intelligently
choose where to perturb the dynamics based on the policy’s behavior. Robustness against this
adversary also guarantees robustness against an adversary with a smaller robust set, that does not
depend on the policy:
p(st+ι | St, at)
log JJ	elogP(St+1 |st，at)-logP(St+1 |st，at)dat0dst+10 ≤ *} ⊆ P.
We will use this subset of the robust set in the following worked example.
Consider an MDP with 1D, bounded, states and actions st , at ∈ [—10, 10]. The dynamics are
p(st+ι | St, at) = N (St+1; μ = Ast + B at ,σ = 1) the reward function is r(st, at) = ∣∣st ∣∣2, and
episodes have finite length T . Note that the dynamics entropy H[st+1 | st, at] is constant. We assume
6
Published as a conference paper at ICLR 2022
Figure 3: MaxEnt RL is competitive with prior robust RL methods.
the adversary modifies the dynamics by increasing the standard deviation to ∖∕2 and shifts the bias by
an amount β, resulting in the dynamics p(st+1 | St, at) = N(st+1; μ = Ast + Bat + β,σ = vz2)∙
The robust set defined in Theorem 4.2 specifies that the adversary can choose any value of β that
satisfies 2β2 + log(8√π) + log(20) ≤ e. To apply MaxEnt RL to learn a policy that is robust
to any of these adversarial dynamics, we would use the pessimistic reward function specified by
Theorem 4.2: r(st, at, st+1) = T log ∣∣st ∣∣2. See Appendix A.7 for the full derivation.
4.4	Limitations of Analysis
We identify a few limitations of our analysis that may provide directions for future work. First, our
definition of the robust set is different from the more standard H∞ and KL divergence constraint sets
used in prior work. Determining a relationship between these two different sets would allow future
work to claim that MaxEnt RL is also robust to these more standard constraint sets (see Lecarpentier
et al. (2020)). On the other hand, MaxEnt RL may not be robust to these more conventional constraint
sets. Showing this may inform practitioners about what sorts of robustness they should not except to
reap from MaxEnt RL. A second limitation is the construction of the augmented reward: to learn a
policy that will maximize reward function r under a range of possible dynamics functions, our theory
says to apply MaxEnt RL to a different reward function, r, which includes a term depending on the
dynamics entropy. While this term can be ignored in special MDPs that have the same stochasticity at
every state, in more general MDPs it will be challenging to estimate this augmented reward function.
Determining more tractable ways to estimate this augmented reward function is an important direction
for future work.
5	Numerical Simulations
This section will present numerical simulations verifying our theoretical result that MaxEnt RL
is robust to disturbances in the reward function and dynamics function. We describe our precise
implementation of MaxEnt RL, standard RL, and all environments in Appendix B.
Comparison with prior robust RL methods. We compare MaxEnt RL against two recent robust
RL methods, PR-MDP and NR-MDP (Tessler et al., 2019). These methods construct a two-player
game between a player that chooses actions and a player that perturbs the dynamics or actions. This
recipe for robust RL is common in prior work (Pinto et al., 2017), and we choose to compare to Tessler
et al. (2019) because it is a recent, high-performing instantiation of this recipe. We also include the
DDPG baseline from Tessler et al. (2019). We evaluate all methods on the benchmark tasks used
in Tessler et al. (2019), which involve evaluating in an environment where the masses are different
from the training environment. We ran MaxEnt RL with both small and large entropy coefficients,
evaluating the final policy for 30 episodes and taking the average performance. We repeated this for 5
random seeds to obtain the standard deviation. The results shown in Fig. 3 suggest that MaxEnt RL
with a large entropy coefficient α is at least competitive, if not better, than prior purpose-designed
robust RL methods. Note that MaxEnt RL is substantially simpler than PR-MDP and NR-MDP.
Intuition for why MaxEnt RL is robust. To build intuition into why MaxEnt RL should yield
robust policies, we compared MaxEnt RL (SAC (Haarnoja et al., 2018a)) with standard RL (TD3 (Fu-
jimoto et al., 2018)) on two tasks. On the pusher task, shown in Fig. 1, a new obstacle was added
during evaluation. On the button task, shown in Fig. 4b, the box holding the button was moved closer
or further away from the robot during evaluation. Note that the robust RL objective corresponds to an
adversary choosing the worst-case disturbances to these environments.
Fig. 1 (right) and Fig. 4b (center) show that MaxEnt RL has learned many ways of solving these tasks,
using different routes to push the puck to the goal and using different poses to press the button. Thus,
7
Published as a conference paper at ICLR 2022
(a) Pusher: New Obstacle
Figure 4: Robustness to changes in the dynamics: MaxEnt RL policies learn many ways of solving a task,
making them robust to perturbations such as (Left) new obstacles and (Right) changes in the goal location.
(b) Button: Moved Goal
when we evaluate the MaxEnt RL policy on perturbed environments, it is not surprising that some
of these strategies continue to solve the task. In contrast, the policy learned by standard RL always
uses the same strategy to solve these tasks, so the agent fails when a perturbation to the environment
makes this strategy fail. Quantitatively, Fig. 4a and 4b (right) show that the MaxEnt RL policy is
more robust than a policy trained with standard RL.
In many situations, simply adding noise to the
deterministic policy found by standard RL can
make that policy robust to some disturbances.
MaxEnt RL does something more complex, dy-
namically adjusting the amount of noise depend-
ing on the current state. This capability allows
MaxEnt RL policies to have lower entropy in
some states as needed to ensure high reward. We
study this capability in the 2D navigation task
shown in Fig. 5. The agent starts near the top
left corner and gets reward for navigating to the
bottom right hand corner, but incurs a large cost
for entering the red regions. The policy learned
Figure 5: MaxEnt RL is not standard RL + noise.
by MaxEnt RL has low entropy initially to avoid colliding with the red obstacles, and then increases
its entropy in the second half of the episode. To study robustness, we introduce a new “L”-shaped ob-
stacle for evaluation. The policy learned by MaxEnt RL often navigates around this obstacle, whereas
the policy from standard RL always collides with this obstacle. Adding independent Gaussian noise
to the actions from the standard RL policy can enable that policy to navigate around the obstacle, but
only at the cost of entering the costly red states.
Testing for different types of robustness. Most prior work on robust RL focuses on changing
static attributes of the environment, such as the mass or position of objects (Tessler et al., 2019;
Kamalaruban et al., 2020). However, our analysis suggests that MaxEnt RL is robust against a wider
range of perturbations, which we probe in our next set of experiments.
First, we introduced perturbations in the middle
of an episode. We took the pushing task shown
in Fig. 1 and, instead of adding an obstacle, per-
turbed the XY position of the puck after 20 time
steps. By evaluating the reward of a policy while
varying the size of this perturbation, we can
study the range of disturbances to which Max-
Ent RL is robust. We measured the performance
of MaxEnt RL policies trained with different
entropy coefficients α. The results shown in
Fig. 6 indicate all methods perform well on the
environment without any disturbances, but only
the MaxEnt RL trained with the largest entropy
coefficient is robust to larger disturbances. This
experiment supports our theory that the entropy
coefficient determines the size of the robust set.
disturbance to puck
Figure 6: Robustness to dynamic perturbations:
MaxEnt RL is robust to random external forces applied
to the environment dynamics.
Our analysis suggests that MaxEnt RL is not only robust to random perturbations, but is actually
robust against adversarial perturbations. We next compare MaxEnt RL and standard RL in this
8
Published as a conference paper at ICLR 2022
Figure 7: Robustness to adversarial perturbations of the environment dynamics.
le3HalfCheetah-v2 le3 Hopper-v2	le3 Walker2d-v2 le3 Ant-v2
JBM①」XPUJ-U-UJ
Figure 8: MaxEnt RL policies are robust to disturbances in the reward function.
setting. We trained both algorithms on a peg insertion task shown in Fig. 7 (left). Visualizing the
learned policy, we observe that the standard RL policy always takes the same route to the goal,
whereas the MaxEnt RL policy uses many different routes to get to the goal. For each policy we
found the worst-case perturbation to the hole location using CMA-ES (Hansen, 2016). For small
perturbations, both standard RL and MaxEnt RL achieve a success rate near 100%. However, for
perturbations that are 1.5cm or 2cm in size, only MaxEnt RL continues to solve the task. For larger
perturbations neither method can solve the task. In summary, this experiment highlights that MaxEnt
RL is robust to adversarial disturbances, as predicted by the theory.
Finally, our analysis suggests that MaxEnt RL is also robust to perturbations to the reward function.
To test this theoretical result, we apply MaxEnt RL on four continuous control tasks from the
standard OpenAI Gym (Brockman et al., 2016) benchmark. We compare to SVG-0 (Heess et al.,
2015) (which uses stochastic policy gradients) and to fictitious play (Brown, 1951). In the RL
setting, fictitious play corresponds to modifying standard RL to use an adversarially-chosen reward
function for each Bellman update. We evaluate the policy on an adversarially chosen reward function,
chosen from the set defined in Equation 2. The analytic solution for this worst-case reward function
is r(st, at) = r(St, at) - log π(at | St). Both MaXEnt RL and standard RL can maximize the
cumulative reward (see Fig. 11 in Appendix B), but only MaxEnt RL succeeds as maximizing the
worst-case reward, as shown in Fig. 8. In summary, this experiment supports our proof that MaxEnt
RL solves a robust RL problem for the set of rewards specified in Theorem 4.1.
6 Discussion
In this paper, we formally showed that MaxEnt RL algorithms optimize a bound on a robust RL
objective. This robust RL objective uses a different reward function than the MaxEnt RL objective.
Our analysis characterizes the robust sets for both reward and dynamics perturbations, and provides
intuition for how such algorithms should be used for robust RL problems. To our knowledge, our
work is the first to formally characterize the robustness of MaxEnt RL algorithms, despite the fact that
numerous papers have conjectured that such robustness results may be possible. Our experimental
evaluation shows that, in line with our theoretical findings, simple MaxEnt RL algorithms perform
competitively with (and sometimes better than) recently proposed adversarial robust RL methods on
benchmarks proposed by those works.
Of course, MaxEnt RL methods are not necessarily the ideal approach to robustness: applying such
methods still requires choosing a hyperparameter (the entropy coefficient), and the robust set for
MaxEnt RL is not always simple. Nonetheless, we believe that the analysis in this paper, represents
an important step towards a deeper theoretical understanding of the connections between robustness
and entropy regularization in RL. We hope that this analysis will open the door for the development
of new, simple algorithms for robust RL.
9
Published as a conference paper at ICLR 2022
Acknowledgments We thank Ofir Nachum, Brendan O’Donoghue, Brian Ziebart, and anonymous reviewers
for their feedback on an early drafts. BE is supported by the Fannie and John Hertz Foundation and the National
Science Foundation GFRP (DGE 1745016).
References
Abbas Abdolmaleki, Jost Tobias Springenberg, Yuval Tassa, Remi Munos, Nicolas Heess, and Martin Riedmiller.
Maximum a posteriori policy optimisation. In International Conference on Learning Representations, 2018.
Joshua Achiam, David Held, Aviv Tamar, and Pieter Abbeel. Constrained policy optimization. In International
Conference on Machine Learning, pp. 22-31. PMLR, 2017.
Dario Amodei, Chris Olah, Jacob Steinhardt, Paul Christiano, John Schulman, and Dan ManC. Concrete
problems in AI safety. arXiv preprint arXiv:1606.06565, 2016.
J Andrew Bagnell, Andrew Y Ng, and Jeff G Schneider. Solving uncertain Markov decision processes. 2001.
Andreea Bobu, Dexter RR Scobee, Jaime F Fisac, S Shankar Sastry, and Anca D Dragan. Less is more:
Rethinking probabilistic models of human behavior. In International Conference on Human-Robot Interaction,
pp. 429-437, 2020.
Stephen Boyd, Stephen P Boyd, and Lieven Vandenberghe. Convex optimization. Cambridge University Press,
2004.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and Wojciech
Zaremba. OpenAI Gym. arXiv preprint arXiv:1606.01540, 2016.
George W Brown. Iterative solution of games by fictitious play. Activity analysis of production and allocation,
13(1):374-376, 1951.
Nicolas Carrara, Edouard Leurent, Romain Laroche, Tanguy Urvoy, Odalric-Ambrym Maillard, and Olivier
Pietquin. Budgeted reinforcement learning in continuous state space. In Advances in Neural Information
Processing Systems, pp. 9299-9309, 2019.
Yinlam Chow, Mohammad Ghavamzadeh, Lucas Janson, and Marco Pavone. Risk-constrained reinforcement
learning with percentile risk criteria. The Journal of Machine Learning Research, 18(1):6070-6120, 2017.
Yinlam Chow, Ofir Nachum, Aleksandra Faust, Edgar Duenez-Guzman, and Mohammad Ghavamzadeh.
Lyapunov-based safe policy optimization for continuous control. arXiv preprint arXiv:1901.10031, 2019.
Jack Clark and Dario Amodei. Faulty reward functions in the wild. 2016. URL https://blog.openai.
com/faulty-reward-functions.
Karl Cobbe, Oleg Klimov, Chris Hesse, Taehoon Kim, and John Schulman. Quantifying generalization in
reinforcement learning. In International Conference on Machine Learning, pp. 1282-1289. PMLR, 2019.
Esther Derman, Matthieu Geist, and Shie Mannor. Twice regularized MDPs and the equivalence between
robustness and regularization. Advances in Neural Information Processing Systems, 34, 2021.
John C Doyle, Bruce A Francis, and Allen R Tannenbaum. Feedback control theory. Courier Corporation, 2013.
Benjamin Eysenbach, Shixiang Gu, Julian Ibarz, and Sergey Levine. Leave no trace: Learning to reset for safe
and autonomous reinforcement learning. In International Conference on Learning Representations, 2018.
Benjamin Eysenbach, Ruslan Salakhutdinov, and Sergey Levine. Search on the replay buffer: Bridging planning
and reinforcement learning. Advances in Neural Information Processing Systems, 32, 2019.
Roy Fox, Ari Pakman, and Naftali Tishby. Taming the noise in reinforcement learning via soft updates. In
Uncertainty in Artificial Intelligence, pp. 202-211, 2016.
Justin Fu, Avi Singh, Dibya Ghosh, Larry Yang, and Sergey Levine. Variational inverse control with events: A
general framework for data-driven reward definition. Advances in Neural Information Processing Systems, 31,
2018.
Scott Fujimoto, Herke Hoof, and David Meger. Addressing function approximation error in actor-critic methods.
In International Conference on Machine Learning, pp. 1587-1596. PMLR, 2018.
Peter D Grunwald, A Philip Dawid, et al. Game theory, maximum entropy, minimum discrepancy and robust
bayesian decision theory. the Annals of Statistics, 32(4):1367-1433, 2004.
10
Published as a conference paper at ICLR 2022
Sergio Guadarrama, Anoop Korattikara, Oscar Ramirez, Pablo Castro, Ethan Holly, Sam Fishman, Ke Wang,
Ekaterina Gonina, Chris Harris, Vincent Vanhoucke, et al. TF-Agents: A library for reinforcement learning in
tensorflow, 2018. URL https://github.com/tensorflow/agents.
Tuomas Haarnoja, Haoran Tang, Pieter Abbeel, and Sergey Levine. Reinforcement learning with deep energy-
based policies. In International Conference on Machine Learning, pp. 1352-1361. PMLR, 2017.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maximum
entropy deep reinforcement learning with a stochastic actor. In International Conference on Machine Learning,
pp. 1861-1870. PMLR, 2018a.
Tuomas Haarnoja, Aurick Zhou, Kristian Hartikainen, George Tucker, Sehoon Ha, Jie Tan, Vikash Kumar,
Henry Zhu, Abhishek Gupta, Pieter Abbeel, et al. Soft actor-critic algorithms and applications. arXiv preprint
arXiv:1812.05905, 2018b.
Tuomas Haarnoja, Sehoon Ha, Aurick Zhou, Jie Tan, George Tucker, and Sergey Levine. Learning to walk via
deep reinforcement learning. In Robotics: Science and Systems, 2019.
Dylan Hadfield-Menell, Smitha Milli, Pieter Abbeel, Stuart J Russell, and Anca Dragan. Inverse reward design.
Advances in Neural Information Processing Systems, 30, 2017.
Nikolaus Hansen. The CMA evolution strategy: A tutorial. arXiv preprint arXiv:1604.00772, 2016.
Nicolas Heess, Gregory Wayne, David Silver, Timothy Lillicrap, Tom Erez, and Yuval Tassa. Learning
continuous control policies by stochastic value gradients. In Advances in Neural Information Processing
Systems, pp. 2944-2952, 2015.
Shiyu Huang, Hang Su, Jun Zhu, and Ting Chen. Svqn: Sequential variational soft q-learning networks. In
International Conference on Learning Representations, 2019.
Andrew Ilyas, Shibani Santurkar, Dimitris Tsipras, Logan Engstrom, Brandon Tran, and Aleksander Madry.
Adversarial examples are not bugs, they are features. Advances in Neural Information Processing Systems,
32, 2019.
Niels Justesen, Ruben Rodriguez Torrado, Philip Bontrager, Ahmed Khalifa, Julian Togelius, and Sebastian
Risi. Illuminating generalization in deep reinforcement learning through procedural level generation. arXiv
preprint arXiv:1806.10729, 2018.
Parameswaran Kamalaruban, Yu-Ting Huang, Ya-Ping Hsieh, Paul Rolland, Cheng Shi, and Volkan Cevher. Ro-
bust reinforcement learning via adversarial training with langevin dynamics. Advances in Neural Information
Processing Systems, 33:8127-8138, 2020.
Hilbert J Kappen. Path integrals and symmetry breaking for optimal control theory. Journal of statistical
mechanics: theory and experiment, 2005(11):P11011, 2005.
Alessandro Lazaric. Transfer in reinforcement learning: a framework and a survey. In Reinforcement Learning,
pp. 143-173. Springer, 2012.
Erwan Lecarpentier, David Abel, Kavosh Asadi, Yuu Jinnai, Emmanuel Rachelson, and Michael L Littman.
Lipschitz lifelong reinforcement learning. arXiv preprint arXiv:2001.05411, 2020.
Kyungjae Lee, Sungyub Kim, Sungbin Lim, Sungjoon Choi, and Songhwai Oh. Tsallis reinforcement learning:
A unified framework for maximum entropy reinforcement learning. arXiv preprint arXiv:1902.00137, 2019.
Sergey Levine. Reinforcement learning and control as probabilistic inference: Tutorial and review. arXiv
preprint arXiv:1805.00909, 2018.
Eric J Michaud, Adam Gleave, and Stuart Russell. Understanding learned reward functions. arXiv preprint
arXiv:2012.05862, 2020.
Oliver Mihatsch and Ralph Neuneier. Risk-sensitive reinforcement learning. Machine learning, 49(2-3):267-290,
2002.
Jun Morimoto and Kenji Doya. Robust reinforcement learning. Neural computation, 17(2):335-359, 2005.
Ofir Nachum, Mohammad Norouzi, Kelvin Xu, and Dale Schuurmans. Bridging the gap between value and
policy based reinforcement learning. In Advances in Neural Information Processing Systems, pp. 2775-2785,
2017.
11
Published as a conference paper at ICLR 2022
Arnab Nilim and Laurent Ghaoui. Robustness in markov decision problems with uncertain transition matrices.
Advances in Neural Information Processing Systems,16:839-846, 2003.
Xue Bin Peng, Marcin Andrychowicz, Wojciech Zaremba, and Pieter Abbeel. Sim-to-real transfer of robotic
control with dynamics randomization. In International Conference on Robotics and Automation, pp. 3803-
3810. IEEE, 2018.
Lerrel Pinto, James Davidson, Rahul Sukthankar, and Abhinav Gupta. Robust adversarial reinforcement learning.
In International Conference on Machine Learning, pp. 2817-2826. JMLR. org, 2017.
Martin L Puterman. Markov Decision Processes.: Discrete Stochastic Dynamic Programming. John Wiley &
Sons, 2014.
Aravind Rajeswaran, Sarvjeet Ghotra, Balaraman Ravindran, and Sergey Levine. Epopt: Learning robust neural
network policies using model ensembles. arXiv preprint arXiv:1610.01283, 2016.
R. Tyrrell Rockafellar. Convex Analysis. Princeton University Press, 1970. ISBN 9780691015866. URL
http://www.jstor.org/stable/j.ctt14bs1ff.
Reazul Hasan Russel and Marek Petrik. Beyond confidence regions: Tight bayesian ambiguity sets for robust
MDPs. Advances in Neural Information Processing Systems, 2019.
Reazul Hasan Russel, Bahram Behzadian, and Marek Petrik. Entropic risk constrained soft-robust policy
optimization. arXiv preprint arXiv:2006.11679, 2020.
Reazul Hasan Russel, Mouhacine Benosman, Jeroen Van Baar, and Radu Corcodel. Lyapunov robust constrained-
MDPs: Soft-constrained robustly stable policy optimization under model uncertainty. arXiv preprint
arXiv:2108.02701, 2021.
Fereshteh Sadeghi and Sergey Levine. CAD2RL: Real single-image flight without a single real image. arXiv
preprint arXiv:1611.04201, 2016.
Yichuan Charlie Tang, Jian Zhang, and Ruslan Salakhutdinov. Worst cases policy gradients. In Conference on
Robot Learning, pp. 1078-1093. PMLR, 2020.
Chen Tessler, Yonathan Efroni, and Shie Mannor. Action robust reinforcement learning and applications in
continuous control. In International Conference on Machine Learning, pp. 6215-6224. PMLR, 2019.
Brijen Thananjeyan, Ashwin Balakrishna, Suraj Nair, Michael Luo, Krishnan Srinivasan, Minho Hwang,
Joseph E Gonzalez, Julian Ibarz, Chelsea Finn, and Ken Goldberg. Recovery rl: Safe reinforcement learning
with learned recovery zones. Robotics and Automation Letters, 6(3):4915-4922, 2021.
Evangelos Theodorou, Jonas Buchli, and Stefan Schaal. A generalized path integral control approach to
reinforcement learning. journal of machine learning research, 11(Nov):3137-3181, 2010.
Emanuel Todorov. Linearly-solvable Markov decision problems. In Advances in Neural Information Processing
Systems, pp. 1369-1376, 2007.
Marc Toussaint. Robot trajectory optimization using approximate inference. In International Conference on
Machine Learning, pp. 1049-1056. ACM, 2009.
Nino Vieillard, Olivier Pietquin, and Matthieu Geist. Munchausen reinforcement learning. Advances in Neural
Information Processing Systems, 33:4235-4246, 2020.
Danfei Xu and Misha Denil. Positive-unlabeled reward learning. arXiv preprint arXiv:1911.00459, 2019.
Tianhe Yu, Deirdre Quillen, Zhanpeng He, Ryan Julian, Karol Hausman, Chelsea Finn, and Sergey Levine.
Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning. In Conference on
Robot Learning, pp. 1094-1100. PMLR, 2020.
Chiyuan Zhang, Oriol Vinyals, Remi Munos, and Samy Bengio. A study on overfitting in deep reinforcement
learning. arXiv preprint arXiv:1804.06893, 2018.
Kemin Zhou, John Comstock Doyle, Keith Glover, et al. Robust and optimal control, volume 40. Prentice hall
New Jersey, 1996.
Brian D. Ziebart. Modeling Purposeful Adaptive Behavior with the Principle of Maximum Causal Entropy. PhD
thesis, Carnegie Mellon University, 2010.
Brian D Ziebart, Andrew L Maas, J Andrew Bagnell, Anind K Dey, et al. Maximum entropy inverse reinforcement
learning. In AAAI, volume 8, pp. 1433-1438. Chicago, IL, USA, 2008.
Brian D Ziebart, J Andrew Bagnell, and Anind K Dey. Maximum causal entropy correlated equilibria for markov
games. In International Conference on Autonomous Agents and Multiagent Systems, pp. 207-214, 2011.
12
Published as a conference paper at ICLR 2022
A Proofs
A.1 Useful Lemmas
Before stating the proofs, we recall and prove two (known) identities.
Lemma A.1.
Ep(x,y)[- log p(x | y)]
min Ep(x,y) -f (x, y) + log e
f (x,y)
x0
f(x0,y)
(7)
This identity says that the negative entropy function is the Fenchel dual of the log-sum-exp function.
This identity can be proven using calculus of variations:
Proof. We start by finding the function f(x, y) that optimizes the RHS of Eq. 7. Noting that the RHS
is a convex function of f(x, y), we can find the optimal f(x, y) by taking the derivative and setting it
equal to zero:
d	ef (x,y)
df (x,y) (Ep(X，y)[-f (X,y)] + log X e"x ,yJ = -P(X,y) + PxO ef(χ0,y).
Setting this derivative equal to zero, We see that solution f * (x, y) satisfies
ef* (x,y)
PxJ ef*(χ0,y) = P(X y).
NoW, We observe that P(y) = 1:
P(y) =	P(X, y)
x
ef* (x,y)
=工 P / ef*(x0,y)
x	x0 e
=Px ef*(x,y) =1
=Pxo ef *(x0,y)=.
We then have
p(x | y)
p(x,y)	ef*(x,y)
---------.—------------：---.
Mr1 Pxo ef*(x0,y)
Taking the log of both sides, we have
logp(x | y) = f*(x,y) - logXef*(x0,y).
x0
Multiplying both sides by -1 and taking the expectation w.r.t. p(x, y), we obtain the desired result:
Ep(x,y)[- log p(x | y)] = Ep(x,y)[-f *(x,y)] + log X ef *(x0,y)
= min Ep(x,y)[-f (x, y)] + log X ef(x0,y).
f(x,y)	x0
□
This lemma also holds for functions With more variables, a result that Will be useful When proving
dynamics robustness.
Lemma A.2.
Ep(x,y,z)[-logP(X,y|z)]=f(mx,iyn,z)Ep(x,y,z)
-f(X, y, z) + log	ef(xo,yo,z)
xo,yo
Proof. Simply apply Lemma A.1 to the random variables (X, y) and z.
□
13
Published as a conference paper at ICLR 2022
A.2 Proof of Theorem 4.1
This section will provide a proof of Theorem 4.1.
Proof. We start by restating the objective for robust control with rewards:
一min E	at〜∏(at∣st)	E"st, at)
r∈R(π)	st+1 〜p(st + ι∣st,at) _ t
(8)
We now employ the KKT conditions (Boyd et al., 2004, ChPt 5.5.3). If the robust set TR is strictly
feasibly, then there exists a constraint value ≥ 0 (the dual solution) such that the constrained
problem is equivalent to the relaxed problem with Lagrange multiplier λ = 1:
min E at 〜∏(at∣st)
r	st + ι 〜p(st+ι∣st,at)
ɪ2r(st,at) + log / exp(r(st,at) - r(st,at))dat0 ∙
tA
To clarify exposition, We parameterize r by its deviation from the original reward, ∆r(st, at)，
r(st, at) - r(st, at). We also define ρ∏ (st, at) as the marginal distribution over states and actions
visited by policy π at time t. We now rewrite the relaxed objective in terms of ∆r(st, at):
minE	at〜∏(at∣st)	Er(st, at) - ∆r(st, at) + log / exp(∆r(st, at))daj
r st+ι~p(St+ιlst,aQ	t	JA
=E	at 〜π(at∣st)	I Er(St, at)l
st + 1 〜P(St+ 1lst,aQ L t
+ minE	at〜∏(at∣st)	I -∆-∆r(st, at) + log / exp(∆r(st, at))daj].
r st+ι〜P(St+ι |st ,aQ L t	JA
=E	at 〜π(at∣st)	[X r(St, at)]
st + 1 〜P(St+ 1lst,aS L t
+ minXEρtπ(St,at) - ∆r(St, at) + log	exp(∆r(St, at))dat0 .
rt	A
=E	at〜∏(at∣st)	Er(St, at) - logπ(at | st).
st + ι~P(St+ ιlst,aQ L t	」
The last line follows from applying Lemma A.1.
□
One important note about this proof is that the KKT conditions are applied to the problem of
optimizing the reward function r, which is a convex optimization problem. We do not require that the
policy π(at | st) or the dynamics p(st+1 | st, at) be convex.
A.3 Worked Example of Reward Robustness
We compute the penalty for Example 1 in Section 4.3 using a Gaussian integral:
PENALTY(r, s) = log /	exp(r(s, a) — r(s, a))da
-	10
=log Z exp(-(a — a*)2 + ɪ(a — (a* + ∆a))2)da
-	10	2
=log Z exp(-ɪ(a — (a* + ∆a))2 + ∆a2)da
-	10	2
=∆a2 + 2 log(2π) + log(20).
A.4 Proof of Theorem 4.2
Proof. We now provide the proof of Theorem 4.2. The first step will be to convert the variation in
dynamics into a sort of variation in the reward function. The second step will convert the constrained
robust control objective into an unconstrained (penalized) objective. The third step will show that the
penalty is equivalent to action entropy.
14
Published as a conference paper at ICLR 2022
Step 1: Dynamics variation → reward variation. Our aim is to obtain a lower bound on the
following objective:
一min E	at〜∏(at∣st)	Er(St, at) .
p∈P (π) st+ι~P(st + ι∣st,at) _ t	_
We start by taking a log-transform of this objective, noting that this transformation does not change
the optimal policy as the log function is strictly monotone increasing.
log E	at~π(at∣st)
st+1 〜P(St+ ι∣st,at)
r(St, at) .
t
Note that we assumed that the reward was positive, so the logarithm is well defined. We can write
this objective in terms of the adversarial dynamics using importance weights.
log E at 〜n(at|St)	(Y P(st+ι I SJ at) X r(st, at)
st + 1~p(st+1 lst,at) |_ ∖ t P(St+ 1 | st, at) ) t	_
=logE	at〜∏(at∣st)	exp I log I Er(St,	at)	I +£logp(st+ι	I	st,	at)	- logp(st+ι	I	st, at)	I
st+1~p(St+ 1|SGat) |_	∖	∖ t	Jt	) _|
(a)
≥ E	at 〜π(at∣st)
st+1 〜P(St+1lst,aQ
=E	at~π(at ∣St)
st+ι 〜P(St+ιlst,aQ
(b)
≥ E at~π(at∣St)
St+1 〜P(St+i/t,as
log (X r(st, at)) + X logP(st+ι | st, at) - logp(st+ι | St, at)
log I T X r(st, at) ) +log T + X log P(st+1 | st, at) - log p(st+ι | st, at)
X T1 log r(st, at) + log P(st+1 | st, at) - log p(st+ι | st, at) +log T.
t
(9)
t
t
Both inequalities are applications of Jensen’s inequality. As before, our assumption that the rewards
are positive ensures that the logarithms remain well defined. While the adversary is choosing the
dynamics under which we will evaluate the policy, we are optimizing a lower bound which depends
on a different dynamics function. This step allows us to analyze adversarially-chosen dynamics as
perturbations to the reward.
Step 2: Relaxing the constrained objective To clarify exposition, we will parameterize the
adversarial dynamics as a deviation from the true dynamics:
∆r(st+ι, st, at) = logp(st+ι | St, at) - logp(st+ι | St, at).	(10)
The constraint that the adversarial dynamics integrate to one can be expressed as
p(St+1 |
SsX-------
St, at)e-∆r(st+1,st,at) dSt+1
_________ - /
{^^^^^^^^∖^^^^^^^^^^^^^^^^^^^^^
P(St+ 1|st,at)
1
Using this notation, we can write the lower bound on the robust control problem (Eq. 9) as follows:
min E	at 〜∏(at∣st),	X TlOg r(st, at) - ∆r(st+ι, St, at) +log T
r st+1 〜p(st + 1lst,aG L t	_
s.t.
E	at~∏(at∣St),
St+1 〜p(st + ι∣St,at)
Xt log	A×s
e∆r(St+10,St,at0)dat0dst+10
and
p(st+1 |
JS '------
st, at)e-∆r(St+1,St,at) dst+1
_ - /
{^^^^^^^^^^^^^^^^^^^^^
P(St+ιlst,aJ
(11)
(12)
(13)
≤
1
The constraint in Eq. 12 is the definition of the set of adversarial dynamics P, and the constraint in
Eq. 13 ensures that p(st+ι | st, at) represents a valid probability density function.
Note that ∆r(st+1, st, at) = 0 is a strictly feasible solution to this constrained optimization problem
for > 0. Note also that the problem of optimizing the function ∆r(st, at) is a convex optimization
15
Published as a conference paper at ICLR 2022
problem. We can therefore employ the KKT conditions (Boyd et al., 2004, Chpt. 5.5.3). If the robust
set P is strictly feasibly, then there exists E ≥ 0 (the dual solution) such that the set of solutions P to
the constrained optimization problem Eq. 11 are equivalent to the set of solutions to the following
relaxed objective with Lagrange multiplier λ = 1:
min E
∆r
i	at 〜∏(at∣st),
st + 1 〜P(St+ 1|st ,at)
X 71 logr(st, at) - Δr(st+1, st, at)
t
(14)
+ log
S
e∆r(st+10,st,at0)dat0dst+10
+ log T
s.t.	p(st+1 | st , at)e-∆r(st+10,st,at0)dst+1 = 1	∀st , at.
(15)
This step does not require that the policy π(at | st) or the dynamics P(st+1 | st, at) be convex.
Our next step is to show that the constraint does not affect the solution of this optimization problem.
For any function ∆r(st+1 , st, at), we can add a constant c(st, at) and obtain the same objective
value but now satisfy the constraint. We construct c(st , at) as
c(st, at)
log	P(st+1 |
st, at)e-∆r(st+10,st,at0)dst+1
∀st , at .
1
First, we observe that adding c(st, at) to ∆r does not change the objective:
E	at~π(at∣st),
st + 1 〜p(st+ι∣st,at)
X T logr(st, at) - (Δr(st+1, st, at) + c(st, at))
t
+ log
A×S
e∆r(st+10,st,at0)+c(st,at)dat0dst+10
+ log T
E	at~π(at∣st),
st+1 〜p(st + ι∣st,at)
X TlOgr(st, at) - Δr(st+1, st, at) - c(st, at)
t
+ log
,at)
A×S
e∆r(st+10,st,at0)dat0dst+10
+ log T
E at~π(at∣st),	X TlOgr(st, at) - ∆r(st+ι, st, at) -£(Swat)+小的五)
st+1 〜P(St+ 1|st,at)	t
+ lOg
e∆r(st+10,st,at0)dat0dst+10
+ lOg T.
Second, we observe that the new reward function ∆r(st+1, st, at) + c(st, at) satisfies the constraint
in Eq. 15:
P(st+1 | st, at)e-(∆r(st+10,st,at0)-c(st,at))dst+1
e-c(st,at)	P(st+1 | st, at)e-∆r(st+10,st,at0)dst+1
S
RSP(st+1 | st, at)e-∆r(st+10,St,at0)dst+1 =]
Rsp(st+ι | st, at)eTr(St+10,St,at0)dst+i	^
Thus, constraining ∆r to represent a probability distribution does not affect the solution (value)
to the optimization problem, so we can ignore this constraint without loss of generality. The new,
unconstrained objective is
m∆in E	a~π(at∣st),
s0 〜p(st+ι∣st,at)
X 71 log r(st, at) - ∆r(st+ι, st, at)
t
+ log
A×S
e∆r(st+1,st,at)dat0dst+10
+ logT.
(16)
16
Published as a conference paper at ICLR 2022
Step 3: The penalty is the Fenchel dual of action entropy. We define ρtπ(st, at, st+1) as the
marginal distribution of transitions visited by policy π at time t. We now apply Lemma A.2 to Eq. 16:
m∆in E a~∏(at∣sQ,	X T1log r(st, at) - ∆r(st+ι, st, at)
s0 ^p(st + 1lst ,at) L t
+ log
J-J-
A×S
e∆r(st+1,st0,at0)dat0dst+10
+ log T
(17)
E a-n(at|st),	X 71 log r(st, at) +log T
s0~P(St+1|st,at) L t	_
+ minE .〜冗⑸加), X-∆r(st+ι, st, at) + log //	6闲&+1,融0网0%8七%§七+10
r s0~p(st + ι∣st,at) _ t	JJA×S	.
E a ~ ∏ (at | st),	X 71 log r(st, at) +log T
s0~p(St+1|st,at) L t	_
+ m∆irn	Eρtπ(St ,at ,St+1)
t
-∆r(st+1, st, at) + log	e∆r(St+1,St0,at0)dat0dst+10
A×S
E a~π(atlst),	X T1 log r(st, at) - log p(at, st+1 | St) +log T
s0~p(St+1|st,at) L t	_
E	a~∏(at∣st),	X	T1 log r(st, at)	- log ∏(at	| St)	- log p(st+ι	| st,	at)	+log T
s0~p(St+1|st,at) L t	_
Summary. We have thus shown the follow:
min log JMaxEnt(∏; p,r) ≥ JMaxEnt(∏; P,乃 + log T∙
p∈P
Taking the exponential transform of both sides, we obtain the desired result.
□
A.5 Robustness to Both Rewards and Dynamics
While Theorem 4.2 is phrased in terms of perturbations to the dynamics function, not the reward
function, we now discuss how this result can be used to show that MaxEnt RL is simultaneously
robust to perturbations in the dynamics and the reward function. Define a modified MDP where
the reward is appended to the observation. Then the reward function is the last coordinate of the
observation. In this scenario, robustness to dynamics is equivalent to robustness to rewards.
A.6 HOW BIG IS THE ROBUST SET ()?
Our proof of Theorem 4.2 used duality to argue that there exists an for which MaxEnt RL maximizes
a lower bound on the robust RL objective. However, we did not specify the size of this . This raises
the concern that might be arbitrarily small, even zero, in which case the result would be vacuous. In
this section we provide a proof of Lemma 4.3, which provides a lower bound on the size of the robust
set.
Proof. Our proof proceeds in three steps. We first argue that, at optimality, the constraint on the
adversarial dynamics is tight. This will allow us to treat the constraint as an equality constraint,
rather than an inequality constraint. Second, since this constraint holds with equality, then we can
rearrange the constraint and solve for in terms of the optimal adversarial dynamics. The third step
is to simplify the expression for .
Step 1: The constraint on ∆r holds with equality. Our aim here is to show that the constraint on
∆r in Eq. 12 holds with equality for the optimal ∆r (i.e., that which optimizes Eq. 11).1 The objective
1In the case where there are multiple optimal ∆r, we require that the constraint hold with equality for at
least one of the optimal ∆r.
17
Published as a conference paper at ICLR 2022
in Eq. 11 is linear in ∆r, so there must exist optimal ∆r at the boundary of the constraint (Rockafellar,
1970, Chapter 32).
Step 2: Solving for . Since the solution to the constrained optimization problem in Eq. 11 occurs
at the boundary, the constraint in Eq. 12 holds with equality, immediately telling us the value of :
E = E	at~π(at |st),
st + 1~p(st+1∣st,at)
Xt log A×S
e∆r(st+10,st,at0)dat0dst+10
T ∙ EP(St)
log
A×S
e∆r(st+10,st,at0)dat0dst+10
(18)
where ∆r is the solution to Eq. 17. This identity holds for all states st . The second line above
expresses the expectation over trajectories as an expectation over states, which will simplify the
analysis in the rest of this proof. The factor of T is introduced because we have removed the inner
summation.
Step 3: Simplifying the expression for E. To better understand this value of E, we recall that the
following identity (Lemma A.2) holds for this optimal ∆r:
e∆r(st,at,st+1)
RfA×S eAMsm/st+CdatO, dst+1 = p(at, st+1 | St)	∀st, at, st+1.
We next take the log(∙) of both sides and rearrange terms:
log
A×S
e∆r(st,at0,st+10)dat0, dst+10
∆r(st, at, st+1) - logρ(at,st+1
| st).
Next, we substitute the definition of ∆r (Eq. 10) and factor log ρ(at, st+1 | st):
log
〃
A×S
e∆r(st,at0,st+1
dat , dst+1
0
logp(st+ι | St, at) - logP(st+1 | St, at) - logp(st+ι | St, at) - log ∏(at | St)
-logp(St+ι | St, at) - log∏(at | St).
Substituting this expression into Eq. 18, we obtain a more intuitive expression for E:
E = T ∙ E at~∏(at∣st),	[- logP(§t+1 | St, at) - log ∏(at | St)]
st+1~p(st + 1∣st,at)
=T ∙ E at~π(at∣st),	Hp[St+1 | St, at] + Hn Mt | St]]
st+1~p(st + 1∣st,at)
≥ T ∙ E at~π(at∣st),	[Hπ [at | St]] .
st+1~p(st + 1∣st,at)
The last line follows from our assumption that the state space is discrete, so the entropy Hp [St+1 |
St , at] is non-negative. This same result will hold in environments with continuous state spaces as
long as the (differential) entropy Hp[St+1 | St, at] is non-negative.	口
A.7 Worked Example of Dynamics Robustness
We calculate the penalty using a Gaussian integral:
log ZZ	p(st+1∣st, at) datdst+1
J Ja×s P(St+1 | st, at)
=log []	2exp(-2 (st+ι	—	(Ast	+ Bat))2 + 4(st+1 — (Ast + Bat	— β))2)datdst+ι
=logyy	2exp(- 1(st+ι	-	(Ast	+ Bat - β))2 + 1 β2)datdst+ι
=log 0√4∏Z exp(2β2)dat)
1 Q 一 ， L、 一 ，、
=2 β + log(8√∏) + log(20).
18
Published as a conference paper at ICLR 2022
Figure 9: Effect of Temperature: (Left) For a given reward function (blue dot), we plot the
robust sets for various values of the temperature. Somewhat surprisingly, it appears that increasing
the temperature decreases the set of reward functions that MaxEnt is robust against. (Right) We
examine the opposite: for a given reward function, which other robust sets might contain this reward
function. We observe that robust sets corresponding to larger temperatures (i.e., the red curve) can be
simultaneously robust against more reward functions than robust sets at lower temperatures.
We make two observations about this example. First, the penalty would be infinite if the adversary
dynamics P had the same variance as the true dynamics, p: the adversary must choose dynamics
with higher variance. Second, the penalty depends on the size of the state space. More precisely, the
penalty depends on the region over which the adversary applies their perturbation. The adversary can
incur a smaller penalty by applying the perturbation over a smaller range of states.
A.8 Temperatures
Many algorithms for MaxEnt RL (Haarnoja et al., 2018a; Fox et al., 2016; Nachum et al., 2017)
include a temperature α > 0 to balance the reward and entropy terms:
T
JMaxEnt(π, r) = Eπ	r(st , at) + αHπ [at | st].
t=1
We can gain some intuition into the effect of this temperature on the set of reward functions to which
we are robust. In particular, including a temperature α results in the following robust set:
Rrα
r(st , at) + αust (at) | ust (at) ≥ 0 ∀st , at and
e-ust (at)dat ≤ 1 ∀st
r(st,at) + ust(at) | ust(at) ≥ 0 ∀st,at and
e-ust (at)/adat ≤ 1 ∀st
(19)
A
A
In the second line, we simply moved the temperature from the objective to the constraint by redefining
USt (at) → 1 USt (at).
We visualize the effect of the temperature in Fig. 9. First, we fix a reward function r, and plot
the robust set Rrα for varying values of α. Fig. 9 (left) shows the somewhat surprising result that
increasing the temperature (i.e., putting more weight on the entropy term) makes the policy less
robust. In fact, the robust set for higher temperatures is a strict subset of the robust set for lower
temperatures:
α1 < α2 =⇒ Rrα2 ⊆ Rrα2 .
This statement can be proven by simply noting that the function e-X is an increasing function of a
in Equation 19. It is important to recognize that being robust against more reward functions is not
always desirable. In many cases, to be robust to everything, an optimal policy must do nothing.
We now analyze the temperature in terms of the converse question: if a reward function r0 is included
in a robust set, what other reward functions are included in that robust set? To do this, we take a
reward function r0 , and find robust sets Rrα that include r0 , for varying values of α. As shown in
Fig. 9 (right), if we must be robust to r0 and use a high temperature, the only other reward functions to
which we are robust are those that are similar, or pointwise weakly better, than r0 . In contrast, when
using a small temperature, we are robust against a wide range of reward functions, including those
that are highly dissimilar from our original reward function (i.e., have higher reward for some actions,
lower reward for other actions). Intuitively, increasing the temperature allows us to simultaneously be
robust to a larger set of reward functions.
19
Published as a conference paper at ICLR 2022
A.9 MaxEnt Solves Robust Control for Rewards
In Sec. 4.1, we showed that MaxEnt RL is equivalent to some robust-reward problem. The aim of this
section is to go backwards: given a set of reward functions, can we formulate a MaxEnt RL problem
such that the robust-reward problem and the MaxEnt RL problem have the same solution?
Lemma A.3. For any collection of reward functions R, there exists another reward function r such
that the MaxEnt RL policy w.r.t. r is an optimal robust-reward policy for R:
arg max Eπ
π
T
r(st, at)
t=1
+ Hπ [a | s] ⊆ arg max min Eπ
π	r0∈R
T
X r0(st, at)
t=1
We use set containment, rather than equality, because there may be multiple solutions to the robust-
reward control problem.
Proof. Let ∏ be a solution to the robust-reward control problem:
π* ∈ arg max min En
π	ri ∈R
T
ri(st, at)
t=1
Define the MaxEnt RL reward function as follows:
r(st, at) = log∏*(at | st).
Substituting this reward function in Equation 1, We see that the unique solution is π = π*.	□
Intuitively, this theorem states that we can use MaxEnt RL to solve any robust-reward control
problem that requires robustness with respect to any arbitrary set of rewards, if we can find the right
corresponding reward function r for MaxEnt RL. One way of viewing this theorem is as providing an
avenue to sidestep the challenges of robust-reward optimization. Unfortunately, we will still have
to perform robust optimization to learn this magical reward function, but at least the cost of robust
optimization might be amortized. In some sense, this result is similar to Ilyas et al. (2019).
A.10 Finding the Robust Reward Function
In the previous section, we showed that a policy robust against any set of reward functions R can be
obtained by solving a MaxEnt RL problem. However, this requires calculating a reward function r*
for MaxEnt RL, which is not in general an element in R. In this section, we aim to find the MaxEnt
reward function that results in the optimal policy for the robust-reward control problem. Our main
idea is to find a reward function r* such that its robust set, Rr*, contains the set of reward functions
we want to be robust against, R. That is, for each ri ∈ R, we want
ri(st, at) = r*(st, at) + ust(at)	for some ust(at) satisfying
e-ust (at)dat ≤ 1 ∀st.
Replacing u with r0 -
constraints:
r* , we see that the MaxEnt reward function r must satisfy the following
er*(st,at)-r0(st,at)dat ≤ 1 ∀st ∈ S,r0 ∈ R.
We define R* (R) as the set of reward functions satisfying this constraint w.r.t. reward functions in R:
R*(R) ,	r*
er*(st,at)-r0(st,at)dat ≤ 1 ∀st ∈ S,r0 ∈ R
A
Note that we can satisfy the constraint by making r* arbitrarily negative, so the set R* (R) is non-
empty. We now argue that all any applying MaxEnt RL to any reward function in r* ∈ R* (R) lower
bounds the robust-reward control objective.
Lemma A.4. Let a set of reward functions R be given, and let r* ∈ R*(R) be an arbitrary reward
function belonging to the feasible set of MaxEnt reward functions. Then
T
JMaxEnt(π, r*) ≤ min Eπ	r0(st, at)
r0∈R
t=1
∀π ∈ Π.
A
A
20
Published as a conference paper at ICLR 2022
PJeU XeEE一UJ P①Z=BuJJoU
Figure 10: Approximately solving an arbitrary robust-reward control problem. In this experi-
ment, we aim to solve the robust-reward control problem for an arbitrary set of reward functions.
While we know that MaxEnt RL can be used to solve arbitrary robust-reward control problems exactly,
doing so requires that we already know the optimal policy (§ A.9). Instead, we use the approach
outlined in Sec. A.10, which allows us to approximately solve an arbitrary robust-reward control
problem without knowing the solution apriori. This approach (“LowerBound + MaxEnt”) achieves
near-optimal minimax reward.
Note that this bound holds for all feasible reward functions and all policies, so it also holds for the
maximum r*:
max JMaxEnt(π,r*) ≤ min En
r* ∈R*(R)	r0 ∈R
T
X r0(st , at)
t=1
∀π ∈ Π.
Defining π* = arg maxπ JMaxEnt(π, r*), we get the following inequality:
max	JMaxEnt(π,r*) ≤ min Eπ*
r*∈R*(R),π∈Π	r0∈R
T
X r0(st, at)
t=1
≤ max min Eπ
π∈Π r0∈R
T
X r0(st, at) . (20)
t=1
Thus, we can find the tightest lower bound by finding the policy π and feasibly reward r * that
maximize Equation 20:
max
r,π
T
Eπ X r(st, at)	+ Hπ [at | st]
t=1
(21)
s.t.
er(st,at)-r0(st,at)da≤ 1∀st ∈S,r0 ∈ R.
A
It is useful to note that the constraints are simply LogSumExp functions, which are convex. For
continuous action spaces, we might approximate the constraint via sampling. Given a particular
policy, the optimization problem w.r.t. r has a linear objective and convex constraint, so it can be
solved extremely quickly using a convex optimization toolbox. Moreover, note that the problem can
be solved independently for every state. The optimization problem is not necessarily convex in π .
A.11 Another Computational Experiment
This section presents an experiment to study the approach outlined above. Of particular interest is
whether the lower bound (Eq 20) comes close to the optimal minimax policy.
We will solve robust-reward control problems on 5-armed bandits, where the robust set is a collection
of 5 reward functions, each is drawn from a zero-mean, unit-variance Gaussian. For each reward
function, we add a constant to all of the rewards to make them all positive. Doing so guarantees
that the optimal minimax reward is positive. Since different bandit problems have different optimal
minimax rewards, we will normalize the minimax reward so the maximum possible value is 1.
Our approach, which we refer to as “LowerBound + MaxEnt”, solves the optimization problem in
Equation 21 by alternating between (1) solving a convex optimization problem to find the optimal
reward function, and (2) computing the optimal MaxEnt RL policy for this reward function. Step 1 is
done using CVXPY, while step 2 is done by exponentiating the reward function, and normalizing
it to sum to one. Note that this approach is actually solving a harder problem: it is solving the
robust-reward control problem for a much larger set of reward functions that contains the original set
21
Published as a conference paper at ICLR 2022
of reward functions. Because this approach is solving a more challenging problem, we do not expect
that it will achieve the optimal minimax reward. However, we emphasize that this approach may
be easier to implement than fictitious play, which we compare against. Different from experiments
in Section 4.1, the “LowerBound + MaxEnt” approach assumes access to the full reward function,
not just the rewards for the actions taken. For fair comparison, fictitious play will also use a policy
player that has access to the reward function. Fictitious play is guaranteed to converge to the optimal
minimax policy, so we assume that the minimax reward it converges to is optimal. We compare
against two baselines. The “pointwise minimum policy” finds the optimal policy for a new reward
function formed by taking the pointwise minimum of all reward functions: r(at) = minr∈R r(at).
This strategy is quite simple and intuitive. The other baseline is a “uniform policy” that chooses
actions uniformly at random.
We ran each method on the same set of 10 robust-reward control bandit problems. In Fig. 10, we
plot the (normalized) minimax reward obtained by each method on each problem, as well as the
average performance across all 10 problems. The “LowerBound + MaxEnt” approach converges to
a normalized minimax reward of 0.91, close to the optimal value of 1. In contrast, the “pointwise
minimum policy” and the “uniform policy” perform poorly, obtaining normalized minimax rewards
of 0.56 and 0.60, respectively. In summary, while the method proposed for converting robust-
reward control problems to MaxEnt RL problems does not converge to the optimal minimax policy,
empirically it performs well.
B Experimental Details
B.1 Dynamics Robustness Experiments (Fig. 4)
We trained the MaxEnt RL policy using the SAC implementation from TF Agents (Guadarrama et al.,
2018) with most of the default parameters (unless noted below).
Fig. 4a We used the standard Pusher-v2 task from OpenAI Gym (Brockman et al., 2016). We
used a fixed entropy coefficient of 1e - 2 for the MaxEnt RL results. For the standard RL results,
we used the exact same codebase to avoid introducing any confounding factors, simply setting the
entropy coefficient to a very small value 1e - 5. The obstacle is a series of three axis-aligned blocks
with width 3cm, centered at (0.32, -0.2), (0.35, -0.23), and (0.38, -0.26). We chose these positions to
be roughly along the perpendicular bisector of the line between the puck’s initial position and the
goal. We used 100 episodes of length 100 for evaluating each method. To decrease the variance in
the results, we fixed the initial state of each episode:
qpos = [0., 0., 0., 0., 0., 0., 0., -0.3, -0.2, 0., 0.],
qvel = [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.].
Fig. 4b We used the SawyerButtonPressEnv environment from Metaworld (Yu et al., 2020),
using a maximum episode length of 151. For this experiment, we perturbed the environment by
modifying the observations such that the button appeared to be offset along the Y axis. We recorded
the average performance over 10 episodes. For this environment we used an entropy coefficient of
1e1 for MaxEnt RL and 1e - 100 for standard RL.2 *
Fig. 6 We used the standard Pusher-v2 task from OpenAI Gym (Brockman et al., 2016). We
modified the environment to perturb the XY position of the puck at time t = 20. We randomly
sampled an angle θ 〜Unif[0, 2∏] and displaced the puck in that direction by an amount given by the
disturbance size. For evaluating the average reward of each policy on each disturbance size, we used
100 rollouts of length 151.
Fig. 5 We used a modified version of the 2D navigation task from Eysenbach et al. (2019) with the
following reward function:
r(St, at) = Ilst - (8, 4)T∣∣2 - 10 ∙ I(St ∈ Sobstacle).
Episodes were 48 steps long.
2We used a larger value for the entropy coefficient for standard RL in the previous experiment to avoid
numerical stability problems.
22
Published as a conference paper at ICLR 2022
Fig. 7 We used the peg insertion environment from Eysenbach et al. (2018). Episodes were at most
200 steps long, but terminated as soon as the peg was in the hole. The agent received a reward of
+100 once the peg was in the hole, in addition to the reward shaping terms described in Eysenbach
et al. (2018).
B.2	Reward Robustness Experiments (Fig. 8)
Following Haarnoja et al. (2018a), we use an entropy coefficient of α = 1/5. In Fig. 8, the thick line
is the average over five random seeds (thin lines). Fig. 11 shows the evaluation of all methods on
both the expected reward and the minimax reward objectives. Note that the minimax reward can be
computed analytically as
r(st, at) = r(St, at) - log π(at | St).
B.3	Bandits (Fig. 10)
The mean for arm i, μi, is drawn from a zero-mean, unit-variance GauSSian distribution, μi 〜N(0,1).
When the agent pulls arm i, it observes a noisy reward ri 〜N(μi, 1). The thick line is the average
over 10 random seeds (thin lines).
PJeAAWJ
φ>-⅛-⊃E⊃u
2000 -
1000 -
0-
PBAAWJ
XeUJ-Ll-UJ
MaxEnt RL
RL --------- Fictitious Play
0	500000 1000000	0	500000 1000000	0	500000 1000000	0	500000 1000000
train steps train steps train steps train steps
0-
-2000 -
-4000 -
Figure 11:	(Top) Both RL (SVG) and MaxEnt RL (SAC) effectively maximize expected reward.
(Bottom) Only MaxEnt RL succeeds in maximizing the minimax reward.
C Robust RL Ablation Experiments
We ran additional ablation experiments to study whether simple modifications to the robust RL
baseline from Section 5 (Tessler et al., 2019) would improve results. These experiments will help
discern whether the good performance of MaxEnt RL, relative to the PR-MDP and NR-MDP
baselines, comes from using a more recent RL algorithm (SAC instead of DDPG), or from the entropy
regularization. We used the following ablations:
1.	larger network: We increased the width of all neural networks to 256 units, so that the
network size the exactly the same as for the MaxEnt RL method.
2.	dual critic: Following TD3 (Fujimoto et al., 2018), we added a second Q function and used
the minimum over two (target) Q functions. This change affects not only the actor and critic
updates, but also the updates to the adversary learned by PR/NR-MDP.
3.	more exploration: We increased the exploration noise from 0.2 to 1.0.
We implemented these ablations by modifying the open source code released by Tessler et al. (2019).
The results, shown in Fig. 12, show that these changes do not significantly improve the performance
of the NR-MDP or PR-MDP. Perhaps the one exception is on the Hopper-v2 task, where PR-MDP
with the larger networks is now the best method for large relative masses. The dual critic ablation
generally performs worse than the baseline. We hypothesize that this poor performance is caused by
using the (pessimistic) minimum over two Q functions for updating the adversary, which may result
23
Published as a conference paper at ICLR 2022
in a weaker adversary. This experiment suggests that incorporating the dual critic trick into the action
robustness framework may require some non-trivial design decisions.
HalfCheetah-v2	Walker2d-v2	Hopper-v2
—NR-MDP ------------ NR-MDP (larger network) ---------- NR-MDP (dual critic) -------- NR-MDP (more exploration)
(a) NR-MDP ablations.
HalfCheeta h-v2	Walker2d-v2	Hopper-v2
---- PR-MDP -------- PR-MDP (larger network) ------- PR-MDP (dual critic)
(b) PR-MDP ablations.
——MaxEnt RL (α = 0.0001)	——DDPG ——NR-MDP	——NR-MDP (dual critic)	——PR-MDP (larger network)
— MaxEnt RL (α = 0.1)	--- PR-MDP ------ NR-MDP (larger network) --- NR-MDP (more exploration) -- PR-MDP (dual critic)
(c) Ablation experiments above overlaid on Fig. 3.
Figure 12:	Robust RL Ablation Experiments: Ablations of the action robustness frame-
work (Tessler et al., 2019) that use larger networks, multiple Q functions, or perform more exploration
do not perform significantly better.
24