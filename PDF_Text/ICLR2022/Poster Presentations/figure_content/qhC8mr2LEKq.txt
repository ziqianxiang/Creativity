Figure 1: An overview of CrossBeam. The search builds a set of explored values, starting withthe inputs and constants. It repeatedly loops over all DSL operations, and for each operation, themodel takes the search context and produces argument lists for that operation, choosing among thepreviously-explored values. Executing the operation on the argument lists produces new values.
Figure 2: Model that proposes new candidate programs during search. Each new candidate programconsists of an operation and an argument list. Each argument in the list is a pointer to a valueproduced from a previously explored program.
Figure 3: Results on the two sets of benchmark tasks used in the Bustle paper. For non-deterministic CrossBeam variations, we plot the mean over 5 trials with shading between the min-imum and maximum results over those 5 trials. CROSSBEAM is 15.9× (left) or 25.5× (right) moreefficient than Bustle, in terms of the number of candidate programs needed to reach Bustle’s 15solves (left) or 44 solves (right). Overall, CrossBeam solves 62% more tasks than Bustle.
Figure 4: A. (Top) Our four operators for building logic programs. Each operator builds a newpredicate p from smaller predicates (q, r, b). The disjunct and recursion operators automaticallyhave different forms depending on the arity of their arguments. (Middle) We assume each predicatehas arity 1 or 2, and automatically cast the arity of input predicates as needed using CAST2→1 andCAST 1→2. (Bottom) The three primitive relations given to the system. B. Example program for therelation 3x = y. A cast from arity 1 to arity 2 (zero1→2) is performed automatically. This size 11program represents a recursive Prolog routine with 7 clauses and 5 invented predicates, equivalent tosaying that the relation 3x = y holds for (0, 0) and that it holds for (x, y) if it holds for (x- 1, y-3).
Figure 5: Success rate of different methods on randomly-generated logic tasks in 30 seconds.
Figure 6: The string manipulation DSL used in our experiments, taken from Odena et al. (2021).
Figure 7: Testing on 30 unseen handcrafted test problems. We report whether each system cansynthesize a logic program implementing the target relation, given a 30 second time limit. Cross-Beam uses the Transformer architecture from Appendix A.2 (the MLP architecture solves 1 fewertask). Metagol1 uses metarules corresponding to our logic programming DSL, while Metagol2 usesthe 6 metarules suggested in the official repo,s README. PopperInv uses predicate invention whilePopper does not. Popper2 and PopperInv2 have access to the same primitive predicates that Cross-Beam does (iszero, successor, and isequal) while Popper1 and PopperInv1 only haveaccess to iszero and successor. In principle, logic programs can implement equality by reuseof variables, so We ran both with and without the isequal predicate.
Figure 8: Results on the randomly-generated logic tasks, for different time limits. As the time limitgets shorter, the gap between CrossBeam and other methods increases.
