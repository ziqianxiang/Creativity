Table 1: Size of the parallel datasets generated offline at each iteration.
Table 2: Computational accuracy scores for our methods and baselines. We show the CA@1 metriccomputed with beam size 10. For the baselines, we ran the evaluations again and reported the best resultbetween those reported in the original paper and those we obtained. Both the offline and online self-trainingmethods lead to significant improvements over our baselines for every language pair and direction. Onlineself-training outperforms offline self-training, even after several iterations.
Table 3: CA@n metric for several beam sizes averaged on all language pairs. The value k correspondsto the beam size. For instance, CA@1 k=10 means that we use beam decoding to generate 10 translations,and select the one with the highest score. The best baseline corresponds to taking the best model betweenTransCoder and DOBF for every language pair and direction. The error rate reduction of the offline and onlineself-training methods over the best baseline are high (> 20%) across all CA@N metrics and beam sizes.
Table 4: Ablation study. We show the CA@1 metric computed with greedy decoding at evaluation timeexcept for the last line where the beam size is set to 10. We evaluate models trained with no cache system,without initializing the cache (with or without selecting the tests with a minimum mutation score of 0.9), and abeam size of 1 when generating examples. We also compare the CA@1 score of our full model when evaluatingwith greedy decoding and with beam size 10. Using a pre-filled cache and selecting only the tests with a highmutation score lead to substantially better performance, although these steps are not necessary to outperformour baseline. The online method already performs well with greedy decoding at generation time, but generatingwith beam size 20 further improves the results.
Table 5: Examples of mutation operators in EvoSuite.	Mutation operator	ExplanationDelete call operator Delete field operator Insert Unary Operator Replace arithmetic operator Replace constant operator Replace variable operator	Remove a method invocation Remove a field access and replaces it with a default value (0 / null) Add 1 to, subtract 1 from, or negate a numerical value after it was loaded on the stack Replace an arithmetic operator in an expression with other operators. E.g., +——→ —, * → / Replace constants with the special values -1, 0, +1 Replace variables with other variables of the same typeOriginal Java function	Mutantpublic class CLAMP_CLASS{	public class CLAMP_CLASS{ public static double clamp(	public static double clamp( double a, double min, double max){	double a, double min, double max){ return a<min?min:(a>max?max:a);	return a>min?min:(a>max?max:a);	Figure 7:	A mutant generated by the “Replace arithmetic operator” mutation in EvoSuite. The< operator in the return statement is replaced with >.
Table 6: Extra results table. We show the CA@1 metric computed with beam size 10 for our baselines,and our offline and online methods, the beam reordering, and a model trained from scratch with our dataset.
