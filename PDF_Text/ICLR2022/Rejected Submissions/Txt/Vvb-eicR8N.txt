Under review as a conference paper at ICLR 2022
Learning-Augmented Sketches for Hessians
Anonymous authors
Paper under double-blind review
Ab stract
Sketching is a dimensionality reduction technique where one compresses a matrix
by linear combinations that are chosen at random. A line of work has shown how
to sketch the Hessian to speed up each iteration in a second order method, but such
sketches usually depend only on the matrix at hand, and in a number of cases are
even oblivious to the input matrix. One could instead hope to learn a distribution on
sketching matrices that is optimized for the specific distribution of input matrices.
We show how to design learned sketches for the Hessian in the context of second
order methods. We prove that a smaller sketching dimension of the column space
of a tall matrix is possible, given an oracle that can predict the indices of the rows of
large leverage score. We design such an oracle for various datasets, and this leads to
a faster convergence of the well-studied iterative Hessian sketch procedure, which
applies to a wide range of problems in convex optimization. We show empirically
that learned sketches, compared with their “non-learned” counterparts, do improve
the approximation accuracy for important problems, including LASSO and matrix
estimation with nuclear norm constraints.
1 Introduction
Large-scale optimization problems are abundant and solving them efficiently requires powerful tools
to make the computation practical. This is especially true of second order methods which often are
less practical than first order ones. Although second order methods may have many fewer iterations,
each iteration could involve inverting a large Hessian, which is cubic time; in contrast, first order
methods such as stochastic gradient descent are linear time per iteration.
In order to make second order methods faster in each iteration, a large body of work has looked at
dimensionality reduction techniques, such as sampling, sketching, or approximating the Hessian by a
low rank matrix. See, for example, (Gower et al., 2016; Xu et al., 2016; Pilanci & Wainwright, 2016;
2017; Doikov & RichEik, 2θl8; GoWer et al., 2018; Roosta-Khorasani & Mahoney, 2019; GoWer
et al., 2019; Kylasa et al., 2019; Xu et al., 2020; Li et al., 2020). Our focus is on sketching techniques,
Which often consist of multiplying the Hessian by a random matrix chosen independently of the
Hessian. Sketching has a long history in theoretical computer science (see, e.g., (Woodruff, 2014) for
a survey), and We describe such methods more beloW. A special case of sketching is sampling, Which
in practice is often uniform sampling, and hence oblivious to properties of the actual matrix. Other
times the sampling is non-uniform, and based on squared norms of submatrices of the Hessian or on
the leverage scores of the Hessian.
Our focus is on sketching techniques, and in particular, We consider the frameWork of (Pilanci &
WainWright, 2016; 2017) Which introduces the iterative Hessian sketch and the NeWton sketch, as
Well as the high accuracy refinement given in (van den Brand et al., 2020). If one Were to run
NeWton’s method to find a point Where the gradient is zero, in each iteration one needs to solve an
equation involving the current Hessian and gradient to find the update direction. When the Hessian
can be decomposed as A>A for an n × d matrix A With n	d, then sketching is particularly
suitable. The iterative Hessian sketch Was proposed in Pilanci & WainWright (2016), Where A is
replaced with S ∙ A, for a random matrix S which could be i.i.d. Gaussian or drawn from a more
structured family of random matrices such as the Subsampled Randomized Hadamard Transforms
or COUNT-SKETCH matrices; the latter was done in (Cormode & Dickens, 2019). The Newton
sketch was proposed by Pilanci & Wainwright (2017), which extended sketching methods beyond
constrained least-squares problems to any twice differentiable function subject to a closed convex
constraint set. Using this sketch inside of interior point updates has led to much faster algorithms
1
Under review as a conference paper at ICLR 2022
for an extensive body of convex optimization problems (Pilanci & Wainwright, 2017). By instead
using sketching as a preconditioner, an application of the work of (van den Brand et al., 2020) (see
Appendix E) was able to improve the dependence on the accuracy parameter to logarithmic.
In general, the idea behind sketching is the following. One chooses a random matrix S, drawn from a
certain family of random matrices, and computes SA. IfA is tall-and-thin, then S is short-and-fat, and
thus SA is a small, roughly square matrix. Moreover, SA preserves important properties of A. One
typically desired property is that S is a subspace embedding, meaning that kSAxk2 = (1 ± )kAxk2
for all x simultaneously. An observation exploited in Cormode & Dickens (2019), building off of
the COUNT-SKETCH random matrices S introduced in randomized linear algebra in Clarkson &
Woodruff (2017), is that if S contains a single non-zero entry per column, then SA can be computed
in O(nnz(A)) time, where nnz(A) denotes the number of nonzeros in A. This is also referred to as
input-sparsity running time.
Each iteration of a second order method often involves solving an equation of the form A>Ax = A>b,
where A> A is the Hessian and b is the gradient. For a number of problems, one has access to a
matrix A ∈ Rn×d with n d, which is also an assumption made in Pilanci & Wainwright (2017).
Therefore, the solution x is the minimizer to a constrained least squares regression problem:
min1 kAx -bk2,	⑴
x∈C 2
where C is a convex constraint set in Rd. For the unconstrained case (C = Rd), various classical
sketches that attain the subspace embedding property can provably yield high-accuracy approximate
solutions (see, e.g., (Sarlos, 2006; Nelson & NgUyen, 2013; Cohen, 2016; Clarkson & Woodruff,
2017)); for the general constrained case, the Iterative Hessian Sketch (IHS) was proposed by Pilanci &
Wainwright (2016) as an effective approach and Cormode & Dickens (2019) employed sparse sketches
to achieve input-sparsity running time for IHS. All sketches used in these results are data-oblivious
random sketches.
Learned Sketching. In the last few years, an exciting new notion of learned sketching has emerged.
Here the idea is that one often sees independent samples of matrices A from a distribution D, and
can train a model to learn the entries in a sketching matrix S on these samples. When given a future
sample B, also drawn from D, the learned sketching matrix S will be such that S ∙ B is a much
more accurate compression of B than if S had the same number of rows and were instead drawn
without knowledge of D. Moreover, the learned sketch S is often sparse, therefore allowing S ∙ B to
be applied very quickly. For large datasets B this is particularly important, and distinguishes this
approach from other transfer learning approaches, e.g., (Andrychowicz et al., 2016), which can be
considerably slower in this context.
Learned sketches were first used in the data stream context for finding frequent items (Hsu et al.,
2019) and have subsequently been applied to a number of other problems on large data. For example,
Indyk et al. (2019) showed that learned sketches yield significantly smaller errors for low rank
approximation. Dong et al. (2020) made significant improvements to nearest neighbor search using
learned sketches. More recently, Liu et al. (2020) extended learned sketches to several problems in
numerical linear algebra, including least-squares regression, as well as k-means clustering.
Despite the number of problems that learned sketches have been applied to, they have not been
applied to convex optimization in general. Given that such methods often require solving a large
overdetermined least squares problem in each iteration, it is hopeful that one can improve each
iteration using learned sketches. However, a number of natural questions arise: (1) how should we
learn the sketch? (2) should we apply the same learned sketch in each iteration, or learn it in the next
iteration by training on a data set involving previously learned sketches from prior iterations?
Our Contributions. In this work we answer the above questions and develop the first framework
of learned sketching that applies to a wide number of problems in convex optimization. Namely, we
apply learned sketches to constrained least-squares problems, including LASSO and matrix regression
with nuclear norm constraints. We show empirically that learned sketches demonstrate superior
accuracy over classical oblivious random sketches for each of these problems. All of our learned
sketches S are extremely sparse, meaning that they contain a single non-zero entry per column and
that they can be applied in input-sparsity time. For such sketches, there are two things to learn: the
position of the non-zero entry in each column and the value of the non-zero entry.
2
Under review as a conference paper at ICLR 2022
Following the previous work of Indyk et al. (2019), we choose the position of the nonzero entry in
each column to be uniformly random, while the value of the nonzero entry is learned (the value is
no longer limited to -1 and 1). Here we consider a new learning objective, that is, we optimize the
subspace embedding property of the sketching matrix instead of optimizing the error in the objective
function of the optimization problem we are trying to solve. This demonstrates a significant advantage
over non-learned sketches, and has a fast training time. Our experiments show that the convergence
rate is reduced by 44% over the nonlearned COUNT-SKETCH (a classical extremely sparse sketch)
for the LASSO problem on a real-world dataset. Recall that a smaller convergence rate means a faster
convergence.
We prove theoretically that S can take fewer rows, with optimized positions of nonzero entries,
when the input matrix A has a small number of rows of heavy leverage score. More specifically,
Count-Sketch takes O(d2∕(δe2)) rows with failure probability δ, while our S requires only
O((dPolylog(1∕c) + log(1∕δ))∕e2) rows if A has at most dPolylog(1∕e)∕e2 rows of leverage score
at least /d. This is a quadratic improvement in d and an exponential improvement in δ. Applying S
to A runs in input-sparsity time and the resulting SA may remain sparse if A is sparse. In practice, it
is not necessary to calculate the leverage scores. Instead, we show in our experiments that the indices
of the rows of heavy leverage score can be learned and the induced S achieves a comparable accuracy
for the abovementioned LASSO problem to classical dense sketches such as Gaussian matrices.
Combining both aspects, the value of the nonzero entry and the indices of the rows of heavy leverage
score, we obtain even better learned sketches. For the same LASSO problem, we show empirically
that such learned sketches reduce the convergence rate by a larger 79.9% to 84.6% over non-learned
sketches. Therefore, the learned sketches attain a smaller error within the same number of iterations,
and in fact, within the same limit on the maximum runtime, since our sketches are extremely sparse.
We also study the general framework of convex optimization in van den Brand et al. (2020), and show
that also for sketching-based preconditioning, learned sketches demonstrate considerable advantages.
More precisely, by using a learned sketch with the same number of rows as an oblivious sketch, we
are able to obtain a much better preconditioner With the Same OVeran running time.
2 Preliminaries
Algorithm 1 LEARN-SKETCH: Gradient descent
algorithm for learning the sketch values
Notation. We denote by Sn-1 the unit sphere
in the n-dimensional Euclidean space Rn . For
a matrix A ∈ Rm×n we denote by kAkop its
Require: Atrain = {Ai}iN=1 (Ai ∈ Rn×d), learn-
ing rate α
1:	Randomly initialize p, v for a COUNT-
S ketch-type sketch as described in the text
2:	for t = 0 to steP do
3:	Form S using p, v
4:	Sample batch Abatch from Atrain
5∙	V — V - α a LIS, Abatch)
j ♦	V ∖ V <α α
operator norm, which is defined as kAkop =
suPx∈Sn-1 kAxk2. We also denote by σmax(A)
and σmin(A) the largest and smallest singular
values of A, respectively, and by ColsP(A) the
column space of A. The condition number of A is defined to be K(A) = σmaχ(A)∕σmin(A).
Leverage Scores. We only consider matrices of full column rank1. Suppose that A ∈ Rm×n (m ≥ n)
has full column rank. It has m leverage scores, denoted by τ1 (A), . . . , τm(A), which are defined
as τi(A) = kei>A(A>A)-1A> k22, where {e1, . . . , em} is the canonical basis of Rm. Equivalently,
letting A = UΣV > be the singular value decomposition of A, where U ∈ Rm×n, Σ, V ∈ Rn×n, we
can also write τi(A) = kei>UU> k22 = kei>Uk22, which is the squared `2 norm of the i-th row of U.
Classical Sketches. Below we review several classical sketches that have been used for solving
optimization problems.
•	Gaussian sketch: S = √mG, where G ∈ Rm×n with i.i.d. N(0,1) entries.
•	COUNT- SKETCH: Each column of S has only a single non-zero entry. The position of the
non-zero entry is chosen uniformly over the m entries in the column and the value of the entry
is either +1 or -1, each with probability 1/2. Further, the columns are chosen independently.
•	Sparse Johnson-Lindenstrauss Transform (SJLT): Sis the vertical concatenation ofs independent
COUNT-SKETCH matrices, each of dimension m/s × n.
1This can be assumed w.l.o.g. by adding artbirarily small random noise to the input, or one can first quickly
use sketching to find a subset of columns of maximum rank, and replace the inut with that subset of columns.
3
Under review as a conference paper at ICLR 2022
Count-Sketch-type Sketch. A COUNT-SKETCH-type sketch is characterized by a tuple
(m, n, p, v), where m, n are positive integers and p, v are n-dimensional real vectors, defined as
follows. The sketching matrix S has dimensions m × n and Spi ,i = vi for all 1 ≤ i ≤ n, while
all the other entries of S are 0. When m and n are clear from context, we may characterize such a
sketching matrix by (p, v) only.
Subspace Embeddings. For a matrix A ∈ Rn×d, we say a matrix S ∈ Rm×n is a (1 ± )-subspace
embedding for the column span of A if (1 - ) kAxk2 ≤ kSAxk2 ≤ (1 + ) kAxk2 for all x ∈ Rd.
The classical sketches above, with appropriate parameters, are all subspace embedding matrices with
probability at least 1 - δ; our focus is on COUNT-SKETCH which can be applied in input sparsity
running time. We summarize the parameters needed for a subspace embedding below:
•	Gaussian sketch: m = O((d + log(1∕δ))∕e2). It is a dense matrix and computing SA costs
O(m ∙ nnz(A)) = O(nnz(A)(d + log(l∕δ))∕e2) time.
•	Count-Sketch： m = O(d2∕(δe2)) (Clarkson & Woodruff, 2017). Though the number of
rows is quadratic in d/, the matrix S is sparse and computing SA takes only O(nnz(A)) time.
•	SJLT: m = O(dlog(?)/e2) and has S = O(log(*)/e) non-zeros per column (Nelson & Nguyen,
2013; Cohen, 2016). Computing SA takes O(S nnz(A)) = O(nnz(A) log(4)/e) time.
Iterative Hessian Sketch. The Iterative Hessian Sketching (IHS) method (Pilanci & Wainwright,
2016) solves the constrained least-squares problem (1) by iteratively performing the update
xt+1 = arg min 1 1 ∣∣St+ιA(x - xt)k2 - hA> (b - Axt),x - Xti ∖ ,	(2)
x∈C 2
where St+1 is a sketching matrix. It is not difficult to see that for the unsketched version (St+1 is
the identity matrix) of the minimization above, the optimal solution xt+1 coincides with the optimal
solution to the constrained least squares problem (1). The IHS approximates the Hessian A>A by a
sketched version (St+1A)>(St+1A) to improve runtime, as St+1A typically has very few rows.
Unconstrained Convex Optimization. Consider an unconstrained convex optimization problem
minx f (x), where f is smooth and strongly convex, and its Hessian V2f is Lipschitz continuous.
This problem can be solved by Newton’s method, which iteratively performs the update
xt+1 = xt - arg min (V2f(xt)1/2)>(V2f(xt)1/2)z - Vf (xt) ,	(3)
provided it is given a good initial point x0 . In each step, it requires solving a regression problem of
the form minz A>Az - y2, which, with access to A, can be solved with a fast regression solver
in (van den Brand et al., 2020). The regression solver first computes a preconditioner R via a QR
decomposition such that SAR has orthonormal columns, where S is a sketching matrix, then solves
zb = arg minz0 (AR)>(AR)z0 - y2 by gradient descent and returns Rzb in the end. Here, the point
of sketching is that the QR decomposition of SA can be computed much more efficiently than the
QR decomposition of A, since S has only a small number of rows.
Learning a Sketch. We use the same learning algorithm in (Liu et al., 2020), given in Algorithm 1.
The algorithm aims to minimize the mean loss function L(S, A) = N PN=ι L(S, Ai), where S is the
learned sketch, L(S, A) is the loss function of S applied to a data matrix A, and A= {A1, . . . , AN}
is a (random) subset of training data.
3	Learning-Augmented Subspace Embeddings
In this section we explain two ways to optimize the subspace embedding property of the sketching
matrix. One is to optimize the non-zero positions of the Count-Sketch-type sketch, based on a
trained oracle to identify a superset of the rows of large leverage score. The other is to optimize the
values of the nonzero entries, which may no longer be -1 or 1, via a learning algorithm based on
gradient descent. As we shall see in Section 4 and 5, a better subspace embedding implies a better
convergence rate in the IHS, as well as for the subroutine in unconstrained convex optimization.
3.1	S ketched Learning: Optimizing the Positions
In this section we consider the problem of embedding the column space of a matrix A ∈ Rn×d,
provided that A has a few rows of large leverage score, as well as access to an oracle which reveals a
4
Under review as a conference paper at ICLR 2022
superset of the indices of such rows. Formally, let τi(A) denote the leverage score of the i-th row of
A and let
I * = {i ： Ti(A) ≥ ν}
be the set of rows with large leverage score. Suppose that a superset I ⊇ I * is known to the algorithm.
In the experiments we train an oracle to predict such rows. We can maintain all rows in I explicitly
and apply a COUNT-SKETCH to the remaining rows, i.e., the rows in [n] \ I. Up to permutation of
the rows, we can write
A= AIIc and S = I0 S00 ,	(4)
where S0 is a random COUNT-SKETCH matrix of m rows. Clearly S has a single non-zero entry per
column. We have the following theorem, whose proof is postponed to Section A. Intuitively, the proof
for Count-Sketch in (Clarkson & Woodruff, 2017) handles rows of large leverage score and rows
of small leverage score separately. The rows of large leverage score are to be perfectly hashed while
the rows of small leverage score will concentrate in the sketch by the Hanson-Wright inequality.
Theorem 3.1. Let ν = /d. Suppose that m =O((d∕e2)(polylog(1∕e)+log(1∕δ))), δ ∈ (0,1/m]
and d = Ω((1∕e) polylog(1∕e) log2(1∕δ)). Then, there exists a distribution on S of the form in (4)
with m + |I| rows such that Pr {∀x ∈ ColsP(A)JkSxk2 -∣∣x∣∣2∣ > E ∣∣x∣∣2 } ≤ δ .
Hence, if there happen to be at most d polylog(1∕)∕2 rows of leverage score at least ∕d, the
overall sketch length for embedding colsP(A) can be reduced to O((dPolylog(1∕E) + log(1∕δ))∕E2),
a quadratic improvement in d and an exponential improvement in δ over the original sketch length
of O(d2∕(E2δ)) for COUNT-SKETCH. In the worst case there could be O(d2∕E) such rows, though
empirically we do not observe this. The following is an immediate corollary, by setting δ = 1∕m.
Corollary 3.2. Suppose that d = Ω((1∕e) Polylog(1∕e)) and |I| = O((d∕e2) Polylog(d∕c)) with
ν = E∕d. There exists a distribution on S of the form in (4) with O((d∕E2) Polylog(d∕E)) rows such
that Pr ∀x ∈ colsP(A), kS xk22 - kxk22 > E kxk22 } ≤ E3 .
We remark that our S is of the COUNT-SKETCH type, which has a twofold benefit. First, SA can be
applied in O(nnz(A)) time. This is faster than a chained subspace embedding of the form S2S1A,
where S1 is a COUNT-SKETCH matrix of O(d2∕E2) rows and S2 is a subspace embedding matrix
of O(d∕E2) rows. Computing S1A takes O(nnz(A)) time but computing S2(S1A) will take an
additional time of Poly(d∕E) or O(nnz(S1A) log(d)∕E). The latter terms can be quite large and even
comparable to n if say, n is close to d2. Second, our S allows the sketched matrix SA to be sparse
when A is sparse, while the other designs such as Subsampled Randomized Hadamard Transforms
and Sparse Johnson-Lindentrauss Transforms either would not guarantee that SA is sparse, or would
yield a worse sparsity than a matrix of the COUNT- S KETCH type. The sparsity of SA is also important
for solving regression problems involving B = SA in intermediate steps, as algorithms such as
conjugate gradient, which use matrix-vector products, become more efficient.
We note that approximate leverages scores of all rows can be found in time O(nnz(A) logn +
Poly(d∕E)) (Clarkson & Woodruff, 2017). Hence, one can approximate the leverage score of every
row in a preprocessing step before running the IHS. This time will be amortized by the IHS iterations,
because the matrix A remains the same throughout the process. Moreover, in Section 6, we show that
for a number of real-world datasets, it is possible to learn the indices of the heavy rows. In practice,
one can shrink the size of the superset I by restricting I to the rows with large `2 norms in AI . We
shall demonstrate in Section 6 that this heuristic works well on some real-world datasets.
3.2	S ketched Learning: Optimizing the Values
As mentioned in Section 2, when we fix the positions of the non-zero entries, we aim to optimize
the values by gradient descent. We propose the following objective loss function for the learning
algorithm L(S, Ai) = k(AiRi)>AiRi - IkF, over all the training data, where Ri comes from the
QR-decomposition of SAi = QiRi-1. We found empirically that not squaring this loss function
works better than squaring it. We think one of the reasons is that the version without squaring may
be less sensitive to outliers. The intuition for this loss function is given by the lemma below, whose
proof is deferred to Section B.
5
Under review as a conference paper at ICLR 2022
Lemma 3.3. Suppose that E ∈ (0, 2), S ∈ Rm×n, A ∈ Rn×d hasfull column rank, and SA = QR
is the QR-decomposition of SA. If k(AR-1)>AR-1 - Ikop ≤ E, then S is a (1 ± E)-subspace
embedding of the column space of A.
Lemma 3.3 implies that if the loss function over Atrain is small and the distribution of Atest is similar
to Atrain , it is reasonable to expect that S is a good subspace embedding of Atest . Here we use the
Frobenius norm rather than operator norm in the loss function because it will make the optimization
problem easier to solve, and our empirical results also show that the performance of the Frobenius
norm is better than that of the operator norm.
4	Hessian S ketch
In this section, we consider the minimization prob-
lem
min 11 kSAxk2 - hA>y,xi］ ,	(5)
x∈C	2
which is used as a subroutine for the IHS (cf. (2)).
We present an algorithm with the learned sketch
in Algorithm 2. To analyze its performance, we
define the following quantities (corresponding ex-
actly to the unconstrained case in (Pilanci & Wain-
wright, 2016))
Algorithm 2 Solver for (5)
1: Si J learned sketch, S2 J random sketch
2: (Zi,1,Zi,2) J ESTIMATE(Si, A), i =1,2
3： i J argmini=1,2(Zi,2∕Zi,l)
4: b J solution of (5) with S = Si*
5: return X____________________________
6: function ESTIMATE(S, A)
7:	T J sparse (1±η)-subspace embedding
matrix for d-dimensional subspaces
8:	(Q, R) J QR(T A)
9:	Zb1 J σmin(SAR-1)
10:	Z2 J (1 ± η)-approximation to
(SAR-1)>(SAR-1)-Iop
11:	return (Z1,Z2)
Z1(S) =	inf	kSvk2 *2,	Z2(S) = sup u, (S>S - In)v.
v∈colsp(A)∩Sn-1	u,v∈colsp(A)∩Sn-1
When S is a (1 + E)-subspace embedding of colsp(A), we have Z1(S) ≥1 - E and Z2(S) ≤ 2E.
L	1 1 . 1 .	.	c 5	1 ə 1 . 1
For a general sketching matrix S, the following is the approximation guarantee of Z1 and Z2, which
are estimates of Z1(S) and Z2(S), respectively. The proof is postponed to Appendix C. The main
idea is that AR-1 is well-conditioned, where R is as calculated in Algorithm 2.
Lemma 4.1. Suppose that η ∈ (0,1) is a SmaU constant, A is of full rank and S has poly(d∕η)
rows. Thefunction ESTIMATE(S, A) returns in O((nnz(A) log ^ +poly(d)) time Zi, Z2 which with
1('∩h∩hi 1(v 1( 1(π 1( 0 QQ Sati e/ʌ? ↑h∩)	"1 (S)	V χ V	Z1 (S)	2	Z? (S)	— 0χ	x χ V "2 (S)	_i_	onɔ
PrOUaUIlIIy at e,Lsytι U.沙s satvsjy tιιat	］十n	≤ 乙 1 ≤	］ "	ana	(］十^)2 Jn	≤ 22 ≤ (i η)2	+	Jn.
Similar to Proposition 1 of (Pilanci & Wainwright, 2016), we have the following guarantee. The
proof is postponed to Appendix D.
Theorem 4.2. Let n ∈ (0, ɪ) be a small COnStant. Suppose that A is of full rank and Si and S2
are both COUNT-SKETCH-type sketches with poly(d∕n) rows. Algorithm 2 returns a solution xb
which, with probability at least 0.98, satisfies that ∣∣A(b — x*)∣∣2 ≤ (1 + n)4 5 6 7 8 9 10 11 (min {ɪi,ɪ, z,2 O +
4n) ∣∣Ax*k2 in O(nnz(A) log( 1) + poly(d)) time, where x* = argminχ∈c ∣∣Ax — b∣b is the least-
squares solution.
Theorem 4.2 suggests the following. If the ratio of the learned sketch Z2(Si)∕Zi(Si) is a constant
smaller than that of the random sketch Z2 (S2)∕Z2(S2) and n is a constant fraction of the ratio
gap, then Zi,2∕Zi,i is a constant smaller than Z2,2∕Z2,i, which means that the procedure of IHS
will converge faster with the learned sketch. In particular, if Si is a (1 + Ei)-subspace embedding
matrix for colsp(A) with Ei <1∕3 and n < γ min{|Ei — E2|, Ei, E2} for some small constant
γ > 0, we have Z2(Si)∕Zi(Si) ≤ 3Ei and the guarantee in Theorem 4.2 becomes ∣A(xb — x*)∣2 ≤
O(min{Ei, E2}) ∣Ax* ∣2, that is, a better subspace embedding can lead to a faster convergence.
Hence, if the learned sketch is a better subspace embedding than a random sketch, theoretically we
can obtain a better convergence by setting n small enough; in practice we shall observe this.
Furthermore, if we know the indices of the rows of large leverage scores of A and the assumptions
in Corollary 3.2 are satisfied, We can use O(d2∕e2) rows to obtain a (1 + O( √l∣ pO］；］Og(d/e)))-
subspace embedding using Corollary 3.2, which is almost a √d-factor better than the usual guarantee
6
Under review as a conference paper at ICLR 2022
of a random Count-Sketch matrix of the Same dimension, leading to an algorithm of faster
convergence.
Algorithm 3 Fast Regression Solver for (6)
5 Hessian Regression
1:
2:
3:
In this section, we consider the minimiza-
tion problem
mzin A>Az - y2,
(6)
which is used as a subroutine for the un-
constrained convex optimization problem
minx f (x) with A>A being the Hessian
matrix V2f (x) (See (3)). Here A ∈ Rn×d,
4:
5:
6:
7:
8:
9:
10:
Si J learned sketch, S? J random sketch
(Qi, Ri) J QR(SiA), i = 1, 2
(σi, σi0) J EIG(ARi-1), i = 1, 2 . EIG(B) returns
estimates of σmax(B) and σmin(B)
i* J mini=1,2(σi/σi)
P J R-i
η J ∖/冠2 + ("*)2)
z0 J 0
while A> APzt - y2 ≥ kyk2 do
zt+1 J zt - η(P>A>AP)(P>A>APzt-P>y)
return Pzt
y ∈ Rd, and we have access to A. We incorporate a learned sketch into the fast regression solver in
(van den Brand et al., 2020) and present the algorithm in Algorithm 3.
Here the subroutine EIG(B) applies a (1 + η)-subspace embedding sketch T to B for some small
constant η and returns σmax(TB) and σmin(TB). Since B admits the form of AR, the sketched
matrix TB can be calculated as (TA)R and thus can be computed in O(nnz(A) + poly(d)) time if
T is a COUNT-SKETCH matrix of O(d2) rows. The extreme singular values of TB can be found by
SVD or the Lanczos algorithm.
Similar to Lemma 4.2 in (van den Brand et al., 2020), we have the following guarantee of Algorithm 3.
The proof parallels the proof in (van den Brand et al., 2020) and is postponed to Appendix E.
Theorem 5.1. Suppose that S1 and S2 are both COUNT- SKETCH-type sketches with O(d2 ) rows.
Algorithm 3 returns a solution x0 such that kA>Ax0 - yk2 ≤ kyk2 with probability at least 0.97.
The runtime is O(nnz(A)) + O (nd ∙ (min{σι∕σj, σ? /σ2 })2 ∙ log(κ(A)∕e) + poly(d)).
Remark 5.2. In Algorithm 3, S2 can be chosen to be a subspace embedding matrix for d-dimensional
subspaces, in which case, AR2-1 has condition number close to 1 (see, e.g., p38 of (Woodruff, 2014))
and the full algorithm would run faster than the trivial O(nd2)-time solver to (6).
Remark 5.3. For the original unconstrained convex optimization problem minx f (x), one can run
the entire optimization procedure with learned sketches versus the entire optimization procedure
with random sketches, compare the objective values at the end, and choose the better of the two.
For least-squares, f (x) = ɪ ∣∣Aχ 一 b∣∣2, and the value of f (x) can be approximated efficiently by a
sparse subspace embedding matrix in O(nnz(A) + nnz(b) + poly(d)) time.
6	Experiments
Comparison. We compare the learned sketch against three classical sketches: Gaussian, COUNT-
Sketch, and SJLT (see Section 2) in all experiments. The quantity we compare is a certain error,
defined individually for each problem, in each iteration of the IHS or the internal regression problem
in fast regression. All of our experiments are conducted on a laptop with a 1.90GHz CPU and 16GB
RAM. The offline training is done separately and the training of a single sketch matrix in our dataset
can be finished within 5 minutes using a single GPU. For the learned sketches with learned values of
nonzero entries, we take an average over three independent trials; for all other sketches, we take an
average over five independent trials. The details of the implementation are deferred to Appendix H.
We elaborate on the reason that the horizontal axes in the plots are in terms of iterations rather
than in terms of runtime. The learned matrix S is trained offline only once using the training
data. It is not computed while solving the optimization problem on the test data. Hence, no
additional computational cost is incurred in generating S other than solving the iteration step
using COUNT-SKETCH. Since Gaussian matrices and sparse JL transforms are denser than COUNT-
Sketch matrices, they will be considerably slower in each round. Since we want to understand the
convergence behavior, an iteration count is more revealing than an overall time bound. If our learned
sketch performs no worse with respect to the total number of rounds (which our experiments show),
then it has an even greater advantage in runtime. To substantiate this claim, we show in Appendix F
an error-versus-runtime plot for the task of matrix estimation with nuclear norm constraints.
7
Under review as a conference paper at ICLR 2022
6.1	IHS Experiments: LASSO
We define an instance of LASSO regression to be:
x* = arg min - ∣∣Ax - b∣∣2 ,	(7)
kxk1≤λ 2
where λ is a parameter. We use two real-world datasets:
•	Electric2: residential electric load measurements. Each row of the matrix corresponds to
a different residence. Matrix columns are consecutive measurements from different times.
Ai ∈ R370×9, bi ∈ R370×1, and |(A, b)train| = 320, |(A,b)test| =80.Wesetλ= 15.
•	Greenhouse gas (GHG)3: time series of measured greenhouse gas concentrations in the Califor-
nia atmosphere. Each (A, b) corresponds to a different measurement location. Ai ∈ R327×14,
bi ∈ R327×1, and |(A, b)train| = 400, |(A, b)test | = 100. We set λ = 30.
Experiment Setting: We choose m = 6d, 8d, 10d for both datasets. We consider the error
1 ∣∣Aχ 一 b∣2 一 1 ||Ax* 一 b∣2∙ For the two datasets, We use both the methods proposed in Sec-
tion 3. For the heavy-row Count-Sketch, we allocate 30% of the sketch space to the rows of heavy
leverage score. For the Electric dataset, each row represents a specific residence and the indices of
the heavy rows do not vary much across the matrices in the training data. We select the heavy rows
according to the number of times each row is heavy in the training data for the heavy rows. We also
consider optimizing the non-zero values after identifying the heavy rows. For the GHG dataset, each
row represents a specific time point and the heavy rows are not very concentrated. Nevertheless, we
can find a superset of about 30% of the rows that contains most of the heavy rows, based on the
counts on the training data. Then we prune the superset by selecting the rows with the largest `2
norms, subject to the dimension budget. This will incur an additional computational cost, but the time
is almost the same as the time to read the sub-matrix of these rows, and it can be used in all iterations,
so the time of this step is negligible compared to the total runtime. We might lose a small fraction
of heavy rows, but it only negligibly affects the experiments. The distribution on the indices of the
heavy rows over the dataset is discussed in Appendix G.
Experimental Result: We plot in a logarithmic scale the mean errors of the two datasets in Figures 1
and 2. We see all methods display linear convergence, that is, letting ek denote the error in the k-th
iteration, we have ek ≈ ρke1 for some convergence rate ρ. A smaller convergence rate implies a
faster convergence.
We calculate an estimated rate of convergence ρ = (ek/e1)1/k with k = 10 for the GHG dataset, and
with k = 7 for the Electric dataset. For the GHG dataset, we can see that when the sketch size is
small (m = 6d), the gradient-based learned sketch has a rate of convergence that is 56% of that of
Count-Sketch, and the heavy-rows sketch has a convergence rate that is 86.9%. When the sketch
size is large (m = 10d), the gradient-based learned sketch has a convergence rate that is 63.7%, and
the heavy-rows sketch is 82.1%. For the Electric dataset, both sketches, especially the heavy-rows
sketch, show significant improvements. When the sketch size is small, the combined-learned sketch
has a convergence rate that is just 21.1% of that of sparse JL, and when the sketch size is large, the
combined-learned sketch has a smaller convergence rate that is just 15.4%.
We also conducted IHS experiments for the matrix estimation problem with a nuclear norm constraint
in Appendix F.
α0nBnτ~B9
4 β	8	10
Iteration round
cCUJ≈0τ~60-
2	4 β	8	10
Iteration round
Figure 1: Test error of LASSO in the Green House Gas dataset.
^obv-3Hlαo-
3	4	5	6
Iteration round
7	8	9
2https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014
3https://archive.ics.uci.edu/ml/datasets/Greenhouse+Gas+Observing+Network
8
Under review as a conference paper at ICLR 2022
{JΛU∙,sII60l
{JΛU∙s's
3	4	5
Iteration round
6	7
34567	1	2	3	4	5	6	7	1	2
Iteration round	Iteration round
Figure 2: Test error of LASSO in Electric dataset.
1.4
1.2
1.0
z.w
1.75
1.50
1.25
Figure 3: Test error of the subroutine in fast regression on Electric dataset.
6.2 Fast Regression Experiments
We consider the unconstrained least squares problem minx f(x)
with f (x) = 2 k Ax - b∣∣2 using the Electric dataset.
Training: Note that V2f (x) = A>A, independent of x. In
the t-th round of Newton’s method, by (3), we need to solve
a regression problem minz ∣∣ A>Az - y ∣[ with y = Vf (Xt).	.
Hence, we can use the same two methods in the preceding Figure 4: Test error of fast regres-
subsection to optimize the learned sketch Si . For a general sion on Electric dataset
problem where V2f(x) depends on x, one can take xt to be the solution obtained from Algorithm 3
using the learned sketch St to generate A and y for the (t + 1)-st round, train a learned sketch St+1,
and repeat this process.
Setup for Experiments: For the Electric dataset, we set m = 10d = 90. We compare the heavy-rows
Count-Sketch matrix with the three classical random sketches, Count-Sketch, Gaussian and
Sparse-JL. For the parameter η in Algorithm 3, we set η = 1 in all iterations for heavy-rows sketches.
For the classical random sketches, we set η in the following two ways: (a) η = 1 in all iterations and
(b) η = 1 in the first iteration and η = 0.2 in all subsequent iterations.
Experimental Results: We examine the accuracy of the subproblem (6) and define the error to
be A> ARzt - y 2 / ky k2. We consider the subproblems in the first three iterations of the global
Newton method. The results are plotted in Figure 3. In this task, the Count-Sketch causes a
terrible divergence of the subroutine and is thus omitted in the plots. Still, we observe that in setting
(a) of η, the other two classical sketches cause the subroutine to diverge. In setting (b) of η, the
other two classical sketches lead to convergence but their error is significantly larger than that of the
heavy-rows sketches, in each of the first three calls to the subroutine. The error of the heavy-rows
sketch is less than 0.01 in all iterations of all three subroutine calls, in both setting (a) and (b) of η.
We also plot a figure on the convergence of the global Newton method. Here, for each subroutine, we
only run one iteration, and plot the error of the original least squares problem. The result is shown in
Figure 4, which clearly displays a significantly faster decay with heavy-rows sketches. The rate of
convergence using heavy-rows sketches is 80.6% of that using Gaussian or sparse JL sketches.
C onclus i on. We demonstrated the superiority of using learned sketches over classical random
sketches, for the Iterative Hessian Sketch method which is used for a number of problems in
convex optimization. Compared with random sketches, our learned sketches of the same size yield
considerably faster convergence. We also provably show a better subspace embedding property of a
sketch of the same size given an oracle for predicting a superset of rows with large leverage score.
Our experiments show the construction of such an oracle is possible for real data sets, and they
demonstrate a significant advantage over non-learned sketches for problems in convex optimization.
9
Under review as a conference paper at ICLR 2022
References
Akshay Agrawal, Brandon Amos, Shane T. Barratt, Stephen P. Boyd, Steven Diamond, and J. Zico
Kolter. Differentiable convex optimization layers. In Advances in Neural Information Processing
Systems 32: Annual Conference on Neural Information Processing Systems 2019, NeurIPS 2019,
December 8-14, 2019, Vancouver, BC, Canada,pp. 9558-9570, 2019.
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul,
Brendan Shillingford, and Nando De Freitas. Learning to learn by gradient descent by gradient
descent. In Advances in neural information processing systems, pp. 3981-3989, 2016.
Jean Bourgain, Sjoerd Dirksen, and Jelani Nelson. Toward a unified theory of sparse dimensionality
reduction in Euclidean space. Geometric and Functional Analysis, pp. 1009-1088, 2015.
Stephen Boyd and Lieven Vandenberghe. Convex Optimization. Cambridge University Press, 2004.
Kenneth L. Clarkson and David P. Woodruff. Low-rank approximation and regression in input
sparsity time. J. ACM, 63(6), January 2017. ISSN 0004-5411. doi: 10.1145/3019134. URL
https://doi.org/10.1145/3019134.
Michael B. Cohen. Nearly tight oblivious subspace embeddings by trace inequalities. In Proceedings
of the Twenty-Seventh Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’16, pp.
278-287, USA, 2016. Society for Industrial and Applied Mathematics. ISBN 9781611974331.
Graham Cormode and Charlie Dickens. Iterative hessian sketch in input sparsity time. In Proceedings
of 33rd Conference on Neural Information Processing Systems (NeurIPS), Vancouver, Canada,
2019.
Nikita Doikov and Peter Richtdrik. Randomized block cubic NeWton method. In Proceedings of the
35th International Conference on Machine Learning, ICML2018, Stockholmsmdssan, Stockholm,
Sweden, July 10-15, 2018, pp. 1289-1297, 2018.
Yihe Dong, Piotr Indyk, Ilya P. Razenshteyn, and Tal Wagner. Learning space partitions for nearest
neighbor search. In 8th International Conference on Learning Representations, ICLR 2020, Addis
Ababa, Ethiopia, April 26-30, 2020, 2020.
Robert M. GoWer, Donald Goldfarb, and Peter Richtdrik. Stochastic block BFGS: squeezing more
curvature out of data. In Proceedings of the 33nd International Conference on Machine Learning,
ICML 2016, New York City, NY, USA, June 19-24, 2016, pp. 1869-1878, 2016.
Robert M. GoWer, Filip Hanzely, Peter Richtdrik, and Sebastian U. Stich. Accelerated stochastic
matrix inversion: General theory and speeding up BFGS rules for faster second-order optimiza-
tion. In Advances in Neural Information Processing Systems 31: Annual Conference on Neural
Information Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montreal, Canada, pp.
1626-1636, 2018.
Robert M. GoWer, Dmitry Kovalev, Felix Lieder, and Peter Richtdrik. RSN: randomized subspace
NeWton. In Advances in Neural Information Processing Systems 32: Annual Conference on
Neural Information Processing Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver,
BC, Canada, pp. 614-623, 2019.
Chen-Yu Hsu, Piotr Indyk, Dina Katabi, and Ali Vakilian. Learning-based frequency estimation
algorithms. In 7th International Conference on Learning Representations, ICLR 2019, New
Orleans, LA, USA, May 6-9, 2019, 2019.
Piotr Indyk, Ali Vakilian, and Yang Yuan. Learning-based loW-rank approximations. In Advances in
Neural Information Processing Systems 32: Annual Conference on Neural Information Processing
Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver, BC, Canada, pp. 7400-7410,
2019.
Sudhir B. Kylasa, Fred (Farbod) Roosta, Michael W. Mahoney, and Ananth Grama. GPU accelerated
sub-sampled NeWton’s method for convex classification problems. In Proceedings of the 2019
SIAM International Conference on Data Mining, SDM 2019, Calgary, Alberta, Canada, May 2-4,
2019, pp. 702-710, 2019.
10
Under review as a conference paper at ICLR 2022
Xiang Li, Shusen Wang, and Zhihua Zhang. Do subsampled newton methods work for high-
dimensional data? In The Thirty-Fourth AAAI Conference on Artificial Intelligence, AAAI 2020,
The Thirty-Second Innovative Applications of Artificial Intelligence Conference, IAAI 2020, The
Tenth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2020, New York,
NY USA, February 7-12, 2020,pp. 4723-4730. AAAI Press, 2020.
Simin Liu, Tianrui Liu, Ali Vakilian, Yulin Wan, and David P. Woodruff. On learned sketches for
randomized numerical linear algebra. arXiv:2007.09890 [cs.LG], 2020. URL https://arxiv.org/abs/
2007.09890.
J. Nelson and H. L. Nguyen. Osnap: Faster numerical linear algebra algorithms via sparser subspace
embeddings. In 2013 IEEE 54th Annual Symposium on Foundations of Computer Science, pp.
117-126, 2013.
Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor
Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward
Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner,
Lu Fang, Junjie Bai, and Soumith Chintala. Pytorch: An imperative style, high-performance deep
learning library. In Advances in Neural Information Processing Systems 32: Annual Conference
on Neural Information Processing Systems 2019, NeurIPS 2019, December 8-14, 2019, Vancouver,
BC, Canada, pp. 8024-8035, 2019.
Mert Pilanci and Martin J. Wainwright. Iterative Hessian sketch: Fast and accurate solution approxi-
mation for constrained least-squares. J. Mach. Learn. Res., 17:53:1-53:38, 2016.
Mert Pilanci and Martin J. Wainwright. Newton sketch: A near linear-time optimization algorithm
with linear-quadratic convergence. SIAM J. Optim., 27(1):205-245, 2017.
Farbod Roosta-Khorasani and Michael W. Mahoney. Sub-sampled Newton methods. Math. Program.,
174(1-2):293-326, 2019.
T. Sarlos. Improved approximation algorithms for large matrices via random projections. In 2006
47th Annual IEEE Symposium on Foundations of Computer Science (FOCS’06), pp. 143-152,
2006.
Jan van den Brand, Binghui Peng, Zhao Song, and Omri Weinstein. Training (overparametrized)
neural networksin near-linear time. arXiv:2006.11648 [cs.LG], 2020.
Roman Vershynin. Introduction to the non-asymptotic analysis of random matrices. In Yonina C.
Eldar and Gitta Kutyniok (eds.), Compressed Sensing: Theory and Applications, pp. 210-268.
Cambridge University Press, 2012. doi: 10.1017/CBO9780511794308.006.
David P. Woodruff. Sketching as a tool for numerical linear algebra. 10(1-2):1-157, October 2014.
ISSN 1551-305X. doi: 10.1561/0400000060. URL https://doi.org/10.1561/0400000060.
Peng Xu, Jiyan Yang, Farbod Roosta-Khorasani, Christopher R6, and Michael W. Mahoney. Sub-
sampled Newton methods with non-uniform sampling. In Advances in Neural Information Process-
ing Systems 29: Annual Conference on Neural Information Processing Systems 2016, December
5-10, 2016, Barcelona, Spain, pp. 3000-3008, 2016.
Peng Xu, Fred Roosta, and Michael W. Mahoney. Second-order optimization for non-convex machine
learning: an empirical study. In Proceedings of the 2020 SIAM International Conference on Data
Mining, SDM 2020, Cincinnati, Ohio, USA, May 7-9, 2020, pp. 199-207, 2020.
11
Under review as a conference paper at ICLR 2022
A Proof of Theorem 3.1
First we prove the following lemma.
Lemma A.1. Let δ ∈ (0, 1/m]. It holds with probability at least 1 - δ that
sup	kSxk22 - kxk22 ≤ kxk22 ,
x∈colsp(A)
provided that
m & e-2((d + logm) min{log2(d∕e), log2 m} + dlog(1∕δ)),
1 & e-2ν((log m) min{log2(d∕e), log2 m} + log(1∕δ)) log(1∕δ).
Proof. We shall adapt the proof of Theorem 5 in (Bourgain et al., 2015) to our setting. Let T
denote the unit sphere in colsp(A) and set the sparsity parameter s = 1. Observe that kSxk22 =
kxI k22 + kSxIc k22, and so it suffices to show that
PrnkS0xIck22- kxIck22 >o ≤δ
for x ∈ T. We make the following definition, as in (2.6) of Bourgain et al. (2015):
m
Aδ,x:=	δij Xj ei ® ej,
i=1 j∈Ic
and thus, S0xIc = Aδ,xσ. Also by E kS0xIc k22 = kxIc k22, one has
sup kS0xIck22 - kxIck22 = sup kAδ,xσk22 - E kAδ,xσk22 .	(8)
x∈T	x∈T
Now, in (2.7) of Bourgain et al. (2015) we instead define a seminorm
kxkδ
max
1≤i≤m
(X δijX2]
j∈Ic
1/2
Then (2.8) continues to hold, and (2.9) as well as (2.10) continue to hold if the supremum in the
left-hand side is replaced with the left-hand side of (8). At the beginning of Theorem 5, we define
U (i) to be U, but each row j ∈ Ic is multiplied by δij and each row j ∈ I is zeroed out. Then we
have in the first step of (4.5) that
d	2
XδijXgkhfk,eji ≤ U (i)g2,
j∈Ic	k=1
instead of equality. One can verify that the rest of (4.5) goes through. It remains true that |卜|卜 ≤
(1∕√S) ∣∣∙k2, and thus (4.6) holds. One can verify that the rest of the proof of Theorem 5 in Bourgain
et al. (2015) continues to hold if we replace Pjn=1 with Pj∈Ic and max1≤j≤n with maxj∈I c, noting
that
E X δj kPE ej ∣2 = m X hPE ej ,eji≤ md
j∈Ic	j∈Ic
and
E(U⑴)*U⑴=X(Eδij)ujUj W —.
j∈Ic	m
Thus, the symmetrization inequalities on
X δij ∣PE ej ∣2
and
δijujujj
continue to hold. The result then follows, observing that maxj∈Ic ∣PEej ∣2 ≤ ν.
□
12
Under review as a conference paper at ICLR 2022
The subspace embedding guarantee now follows as a corollary.
Theorem 3.1. Let ν = /d. Suppose that m =Ω((d∕e2)(polylog(1∕e)+log(1∕δ))), δ ∈ (0,1/m)
and d = Ω((1∕e) polylog(1∕e) log2(1∕δ)). Then, there exists a distribution on S with m + |I| rows
such that
Pr n∀x ∈ colsp(A), kSxk22 - kxk22 > kxk22 o ≤ δ.
Proof. One can verify that the two conditions in Lemma A.1 are satisfied if
m
& -d2 (Polylog(d) + log ŋ ,
2	δ
Polylog(d) + log1 ).
δ
d & 1
The last condition is satisfied if
d & 1
polylog (；
□
B Proof of Lemma 3.3
Proof. On the one hand, since Q = SAR is an orthogonal matrix, we have
kxk2 = kQxk2 = kSARxk2.	(9)
On the other hand, the assumption implies that
(ARx)T (ARx) - xT x2 ≤ kxk22 ,
that is,
(1 - ) kxk22 ≤ kARxk22 ≤ (1+)kxk22.	(10)
Combining both (9) and (10) leads to
√T-i IISARxk2 ≤ IIARxk2 ≤ √1Γi IISARxk2, ∀x ∈ Rd
Equivalently, it can be written as
√1= kSAy∣2 ≤ kAy∣2 ≤ √^ kSAy∣2, ∀y ∈ Rd.
1 +	1 -
The claimed result follows from the fact that 1 / √1 + E ≥ 1 - E and 1 / √1 - E ≤ 1 + E whenever
e ∈ (0, √5-1 ].	□
C Proof of Lemma 4.1
Suppose that AR-1 = UW, where U ∈ Rn×d has orthonormal columns, which form an orthonormal
basis of the column space of A. Since T is a subspace embedding of the column space of A with
probability 0.99, it holds for all x ∈ Rd that
+ IlTARTx∣∣2 ≤ IIARTx∣∣2 ≤ 占 IITARTx∣∣2.
Since
IIT AR-1 xII2 = kQxk2 = kxk2
and
kWxk2 = kUWxk2 = IIAR-1xII2	(11)
we have that
ɪɪ^ kx∣∣2 ≤ kWxk2 ≤ 1-kxk2 , X ∈ Rd.	(12)
13
Under review as a conference paper at ICLR 2022
It is easy to see that
ZI(S)=XmdnJSU叽=min kSUW'
and thus,
(1-η) kSUW⅛ ≤ Z1(S) ≤ min(1 + η) kSUW⅛
y6=0	kyk2	y6=0	kyk2
Recall that SUW = SAR-1. We see that
(1 - η)σmin(SAR-1) ≤Z1(S) ≤ (1 + η)σmin(SAR-1).
By definition,
Z2(S) = UT(S>S-In)Uop.
It follows from (12) that
(1-η)2WTUT(STS-In)UWop ≤ Z2(S) ≤ (1+η)2WTUT(STS-In)UWop.
and from (12), (11) and Lemma 5.36 of Vershynin (2012) that
(AR-1)>(AR-1) - Iop ≤ 3η.
Since
WTUT(STS-In)UWop= (AR-1)>(ST S - In)AR-1op
and
(AR-1)>STSAR-1-Iop-(AR-1)>(AR-1)-Iop
≤ (AR-1)>(STS-In)AR-1op
≤ (AR-1)>ST SAR-1 - Iop +(AR-1)>(AR-1) - Iop,
it follows that
(1 - η)2(SAR-1)>SAR-1 - Iop - 3(1 - η)2η
≤ Z2(S)
≤ (1 + η)2(SAR-1)>SAR-1 - Iop + 3(1 + η)2η.
We have so far proved the correctness of the approximation and we shall analyze the runtime below.
Since S and T are sparse, computing SA and TA takes O(nnz(A)) time. The QR decomposition
of TA, which is a matrix of size poly(d∕η) X d, can be computed in poly(d∕η) time. The matrix
SAR-1 can be computed in poly(d) time. Since it has size poly(d∕η) × d, its smallest singular
value can be computed in poly(d∕η) time. To approximate Z? (S), we can use the power method to
estimate ∣∣(SAR-1 )TSAR-1 一 IIIop up toa (1 土 η)-factor in O((nnz(A) + poly(d∕η)) log(1∕η))
time.
D Proof of Theorem 4.2
In Lemma 4.1, we have with probability at least 0.99 that
Z2、(⅛Z2(S) - 3η、1 一 η Z2(S)	3η
— ≥ -----Z---------- ≥ ----------：-- 一 --：--.
Zi ≥	ι-nZ1(S)	≥ (1 + η)2 Zι(S)	Zi(s)
When S is random subspace embedding, it holds with probability at least 0.99 that Z1(S) ≥ 3/4 and
so, by a union bound, it holds with probability at least 0.98 that
Z ≥	1	Z2(S)	4
Zι≥(1+ η)4 Zi(S)	4η,
or,
笫 ≤ (1 + η)4 仔 +4η).
Z1 (S)	Z1
The correctness of our claim then follows from Proposition 1 of Pilanci & Wainwright (2016),
together with the fact that S2 is a random subspace embedding. The runtime follows from Lemma 4.1
and Theorem 2.2 of Cormode & Dickens (2019).
14
Under review as a conference paper at ICLR 2022
E Proof of Theorem 5.1
The proof follows a similar argument to that in (van den Brand et al., 2020, Lemma B.1). In van den
Brand et al. (2020), it is assumed (in our notation) that 3/4 ≤ σmin (AP ) ≤ σmax (AP ) ≤ 5/4
and thus one can set η = 1 in Algorithm 3 and achieve a linear convergence. The only dif-
ference is that here we estimate σmin (AP) and σmax (AP) and set the step size η in the gradi-
ent descent algorithm accordingly. By standard bounds for gradient descent (see, e.g., p468 of
Boyd & Vandenberghe (2004)), with a choice of step size η = 2/(σ2aχ(AP) + σ21in(AP)), after
O((σmaχ(AP)∕σmin(AP))2 log(1∕e)) iterations, we can find Zt such that
IIP>A>AP(Zt- z*)∣∣2 ≤ TlP>A>AP(zo - z*)∣∣2,
where z* = argmin% ∣∣P>A>APz - P>y∣∣2 is the optimal least-squares solution. This establishes
Eq. (11) in the proof in van den Brand et al. (2020), and the rest of the proof follows as in there.
We use three subspace embeddings here, S1, S2 and one used in the EIG subrountine. Each subspace
embedding uses O(d2) rows with a constant distortion parameter and a failure probability of 0.01.
The overall failure probability is thus 0.03.
F IHS Experiments: Matrix Estimation with Nuclear Norm
Constraint
In many applications, for the problem
X* := arg min kAX - Bk2F ,
X∈Rd1 ×d2
it is reasonable to model the matrix X * as having low rank. Similar to the '1-minimization for
compressive sensing, a standard relaxation of the rank constraint is to minimize the nuclear norm of
X, defined as kXk* := Pjm=in1{d1,d2} σj(X), where σj(X) is the j-th largest singular value of X.
Hence, the matrix estimation problem we consider here is
X* := arg min kAX - B k2F such that kX k* ≤ ρ,
X∈Rd1 ×d2
where ρ > 0 is a user-defined radius as a regularization parameter.
We conduct experiments on the following datasets:
• Tunnel4: The data set is a time series of gas concentrations measured by eight sensors in a
wind tunnel. Each (A, B) corresponds to a different data collection trial. Ai ∈ R13530×5, Bi ∈
R13530×6, |(A, B)|train = 144, |(A, B)|test = 36. In our nuclear norm constraint, we set
ρ= 10.
Experiment Setting: We choose m = 7d, 10d for the Tunnel dataset. We consider the error
1 k AX - B∣∣2 - 2 ∣∣AX* - B∣∣2. The leverage scores of this dataset are very uniform. Hence, for
this experiment we only consider optimizing the values of the non-zero entries.
Results of Our Experiments: We plot in a logarithmic scale the mean errors of the two datasets in
Figures 5. We can see that when m = 7d, the gradient-based sketch, based on the first 6 iterations,
has a rate of convergence that is 48% of the random sketch, and when m = 10d, the gradient-based
sketch has a rate of convergence that is 29% of the random sketch.
Runtime of Learned Sketch. As stated in Section 2, our learned sketch matrices S are all COUNT-
S KETCH-type matrices (each column contains a single nonzero entry), the matrix product SA can
thus be computed in O(nnz(A)) time and the overall algorithm is expected to be fast. To verify this,
we plot in an error-versus-runtime plot for matrix estimation with nuclear norm constraint tasks with
m = 10d in Figures 6 (corresponding to the datasets in Figure 5). The runtime consists only of the
time for sketching and solving the optimization problem and does not include the time for loading the
data. We run the same experiment three times. Each time we take an average over all test data. From
the plot we can observe that the learned sketch and Count-Sketch have the fastest runtimes, which
are slightly faster than that of the SJLT and significantly faster than that of the Gaussian sketch.
4https://archive.ics.uci.edu/ml/datasets/Gas+sensor+array+exposed+to+turbulent+gas+mixtures
15
Under review as a conference paper at ICLR 2022
OTT
{JO-0II8-
Figure 5: Test error of matrix estimation with nuclear norm constraint on Tunnel dataset
uot9≡II8-
2
0
CJaua6q
0.2	0.3
runtime
0.4	0.5
-6
Figure 6: Test error of matrix estimation with nuclear norm constraint on Tunnel dataset
G Heavy Leverage Score Rows Distribution over the Dataset
In our experiments, we hypothesize that in real-world data that there may be an underlying pattern
which can help us identify the heavy rows. In the Electric dataset, each row of the matrix corresponds
to a specific residence and the heavy rows are always concentrated on some specific rows; in the
GHG data set, each row corresponds to a specific time point and we can select some specific time
points to be a superset of the heavy rows and then select the heavy rows based on their '2-norm in
this superset.
To exemplify this, we study the heavy leverage score rows distribution over the Electirc dataset. For
a row i ∈ [370], let fi denote the times that row i is heavy out of 320 training data points from the
Electric dataset, where we say row i is heavy if `i ≥ 5d/n. Below we list all 74 pairs (i, fi) with
fi > 0.
(195,320), (278,320), (361,320), (207,317), (227,285), (240,284), (219,270), (275,232), (156,214),
(322,213), (193,196), (190,192), (160,191), (350,181), (63,176), (42,168), (162,148), (356,129),
(363,110), (362,105), (338,95), (215,94), (234,93), (289,81), (97,80), (146,70), (102,67), (98,58),
(48,57), (349,53), (165,46), (101,41), (352,40), (293,34), (344,29), (268,21), (206,20), (217,20),
(327,20), (340,19), (230,18), (359,18), (297,14), (357,14), (161,13), (245,10), (100,8), (85,6), (212,6),
(313,6), (129,5), (130,5), (366,5), (103,4), (204,4), (246,4), (306,4), (138,3), (199,3), (222,3), (360,3),
(87,2), (154,2), (209,2), (123,1), (189,1), (208,1), (214,1), (221,1), (224,1), (228,1), (309,1), (337,1),
(343,1)
Observe that the heavy rows are concentrated on a set of specific row indices. There are only 30 rows
i with fi ≥ 50. We view this as strong evidence for our hypothesis.
H Implementation Details
As we state in Section 3.2, when we fix the positions of the non-zero entries (uniformly chosen in
each column or sampling according to the heavy leverage score distribution), we aim to optimize the
values by gradient descent mentioned in Algorithm 1. Here the loss function is given in Section 3.2.
In our implementation, we use PyTorch (Paszke et al. (2019)), which can compute the gradient
automatically (here we can use torch.qr() and torch.svd() to define our loss function). For a more
16
Under review as a conference paper at ICLR 2022
nuanced loss function, which may be beneficial, one can use the package released in Agrawal et al.
(2019), where the authors studied the problem of computing the gradient of functions which involve
the solution to certain convex optimization problem.
As mentioned in Section 2, each column of the sketch matrix S has exact one non-zero entry.
Hence, the i-th coordinate of p can be seen as the non-zero position of the i-th column of S. In
the implementation, to sample p randomly, we can sample a random integer in {1, . . . , m} for each
coordinate ofp. For the heavy rows mentioned in Section 3.1, we can allocate positions 1, . . . , k to
the k heavy rows, and for the other rows, we randomly sample an integer in {k + 1, . . . , m}. We note
that once the vector p, which contains the information of the nonzero position in each column of S, is
chosen, it will not be changed during the optimization process in Algorithm 1.
Next, we introduce some parameters for our experiments.
•	bs: batch size, the number of training samples used in one iteration.
•	lr: learning rate of the gradient descent(the α in Algorithm 1).
•	iter: the number of iteration for Algorithm 1.
In our experiments, we set bs = 20, iter = 1000 for all dataset. We set lr = 10 for the Green House
Gas dataset and lr = 0.1 for the Electric dataset.
I Additional Experiments for LASSO
In this section, we consider the IHS experiments for LASSO on data of a larger size. The experiment
setting is the same as that in Section 6. We conduct our experiments on the following dataset:
•	Gas Sensor.5 A chemical detection platform composed of 8 chemoresistive gas sen-
sors was exposed to turbulent gas mixtures generated naturally in a wind tunnel. Each
matrix represents the measurements at dense time points during a short time period.
Ai ∈ R95000×19,bi ∈ R95000×1, and |(A, b)train | = 30, |(A, b)test | = 9. Wesetλ = 10.
The results are shown in Table 1. Here we choose m = 300. The leverage scores of the rows on this
dataset is very uniform hence we choose random positions for the nonzero entries and only optimize
the values in the learned sketch. For a matrix of such size, the gaussian sketching matrix is extremely
slow, hence, we only consider the Count-Sketch matrix and the Sparse-JL matrix. From the table
below we can see that the gradient-based learned sketch has a converge rate that is 74.6% of that of
the random sketch.
Table 1: Error of the Sketch Matrix on Gas Senser data
Iteration	4	5	6	7	8	9	10
Learnd(Value-only)	428.13	23.72	1.72	0.092	0.0060	000036	1.8 ∙ 10-5
Count-Sketch	1864.66	122.26	12.30	1.46	0.074	0013	000036
SParse-JL	1897.32	188.31	9.60	1.30	0.16	00098	000048
5https://archive.ics.uci.edu/ml/datasets/Gas+sensor+array+temperature+modulation
17