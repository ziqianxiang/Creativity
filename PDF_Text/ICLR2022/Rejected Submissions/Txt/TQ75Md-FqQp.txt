Under review as a conference paper at ICLR 2022
Efficient and Modular Implicit Differentiation
Anonymous authors
Paper under double-blind review
Ab stract
Automatic differentiation (autodiff) has revolutionized machine learning. It allows
expressing complex computations by composing elementary ones in creative ways
and removes the burden of computing their derivatives by hand. More recently,
differentiation of optimization problem solutions has attracted widespread attention
with applications such as optimization layers, and in bi-level problems such as
hyper-parameter optimization and meta-learning. However, so far, implicit differen-
tiation remained difficult to use for practitioners, as it often required case-by-case
tedious mathematical derivations and implementations. In this paper, we propose
an efficient and modular approach for implicit differentiation of optimization prob-
lems. In our approach, the user defines directly in Python a function F capturing
the optimality conditions of the problem to be differentiated. Once this is done, we
leverage autodiff of F and implicit differentiation to automatically differentiate the
optimization problem. Our approach thus combines the benefits of implicit differ-
entiation and autodiff. It is efficient as it can be added on top of any state-of-the-art
solver and modular as the optimality condition specification is decoupled from
the implicit differentiation mechanism. We show that seemingly simple principles
allow to recover many existing implicit differentiation methods and create new ones
easily. We demonstrate the ease of formulating and solving bi-level optimization
problems using our framework. We also showcase an application to the sensitivity
analysis of molecular dynamics.
1 Introduction
Automatic differentiation (autodiff) is now an inherent part of machine learning software. It allows
to express complex computations by composing elementary ones in creative ways and removes the
tedious burden of computing their derivatives by hand. In parallel, the differentiation of optimization
problem solutions has found many applications. A classical example is bi-level optimization, which
typically involves computing the derivatives of a nested optimization problem in order to solve an
outer one. Examples of applications in machine learning include hyper-parameter optimization
(Chapelle et al., 2002; Seeger, 2008; Pedregosa, 2016; Franceschi et al., 2017; Bertrand et al., 2020;
2021), neural networks (Lorraine et al., 2020), and meta-learning (Franceschi et al., 2018; Rajeswaran
et al., 2019). Another line of active research involving differentiation of optimization problem
solutions are optimization layers (Kim et al., 2017; Amos & Kolter, 2017; Niculae & Blondel, 2017;
Djolonga & Krause, 2017; Gould et al., 2019), which can be used to encourage structured outputs,
and implicit deep networks (Bai et al., 2019; El Ghaoui et al., 2019), which have a smaller memory
footprint than backprop-trained networks.
Since optimization problem solutions typically do not enjoy an explicit formula in terms of their
inputs, autodiff cannot be used directly to differentiate these functions. In recent years, two main
approaches have been developed to circumvent this problem. The first one consists of unrolling the
iterations of an optimization algorithm and using the final iteration as a proxy for the optimization
problem solution (Wengert, 1964; Domke, 2012; Deledalle et al., 2014; Franceschi et al., 2018;
Ablin et al., 2020). This allows to explicitly construct a computational graph relating the algorithm
output to the inputs, on which autodiff can then be used transparently. However, this requires a
reimplementation of the algorithm using the autodiff system, and not all algorithms are necessarily
autodiff friendly. Moreover, forward-mode autodiff has time complexity that scales linearly with
the number of variables and reverse-mode autodiff has memory complexity that scales linearly
with the number of algorithm iterations. In contrast, a second approach consists in implicitly
relating an optimization problem solution to its inputs using optimality conditions. In a machine
learning context, such implicit differentiation has been used for stationarity conditions (Bengio, 2000;
1
Under review as a conference paper at ICLR 2022
Lorraine et al., 2020), KKT conditions (Chapelle et al., 2002; Gould et al., 2016; Amos & Kolter,
2017; Niculae et al., 2018; Niculae & Martins, 2020) and the proximal gradient fixed point (Niculae
& Blondel, 2017; Bertrand et al., 2020; 2021). An advantage of implicit differentiation is that a
solver reimplementation is not needed, allowing to build upon decades of state-of-the-art software.
Although implicit differentiation has a long history in numerical analysis (Griewank & Walther,
2008; Bell & Burke, 2008; Krantz & Parks, 2012; Bonnans & Shapiro, 2013), so far, it remained
difficult to use for practitioners, as it required a case-by-case tedious mathematical derivation and
implementation. CasADi (Andersson et al., 2019) allows to differentiate various optimization and
root finding problem algorithms provided by the library. However, it does not allow to easily add
implicit differentiation on top of existing solvers from optimality conditions expressed by the user, as
we do. A recent tutorial explains how to implement implicit differentiation in JAX (Duvenaud et al.,
2020). However, the tutorial requires the user to take care of low-level technical details and does
not cover a large catalog of optimality condition mappings as we do. Other work (Agrawal et al.,
2019a) attempts to address this issue by adding implicit differentiation on top of cvxpy (Diamond
& Boyd, 2016). This works by reducing all convex optimization problems to a conic program and
using conic programming’s optimality conditions to derive an implicit differentiation formula. While
this approach is very generic, solving a convex optimization problem using a conic programming
solver—an ADMM-based splitting conic solver (O’Donoghue et al., 2016) in the case of cvxpy—is
rarely the state-of-the-art approach for each particular problem instance.
In this work, we adopt a different strategy that makes it easy to add implicit differentiation on top
of any existing solver. In our approach, the user defines directly in Python a mapping function
F capturing the optimality conditions of the problem solved by the algorithm. Once this is done,
we leverage autodiff of F combined with implicit differentiation to automatically differentiate the
optimization problem solution. In this way, our approach is generic, yet it can exploit the efficiency
of state-of-the-art solvers. It therefore combines the benefits of implicit differentiation and autodiff.
To summarize, we make the following contributions.
•	We describe our framework and its JAX implementation (provided in the supplementary material).
Our framework significantly lowers the barrier to use implicit differentiation thanks to the use
of autodiff of the optimality conditions and the seamless integration in JAX. Our framework
significantly extends JAX for numerical optimization, with low-level details all abstracted away.
•	We instantiate our framework on a large catalog of optimality conditions (Table 1), recovering
existing schemes and obtaining new ones, such as the mirror descent fixed point based one.
•	On the theoretical side, we provide new bounds on the Jacobian error when the optimization
problem is only solved approximately, and empirically validate them.
•	We implement four illustrative applications, demonstrating our framework’s ease of use.
Beyond our software implementation, we hope this paper provides a self-contained blueprint for
creating an efficient and modular implementation of implicit differentiation.
Notation. We denote the gradient and Hessian of f: Rd → R evaluated at X ∈ Rd by Vf (x) ∈ Rd
and V2 * * * &f (χ) ∈ Rd×d. We denote the Jacobian of F: Rd → Rp evaluated at X ∈ Rd by ∂F(x) ∈
Rp×d . When f or F have several arguments, we denote the gradient, Hessian and Jacobian in
the ith argument by Vi , Vi2 and ∂i , respectively. The standard probability simplex is denoted by
4d := {X ∈ Rd : kXk1 = 1, X ≥ 0}. For any set C ⊂ Rd, we denote the indicator function
IC : Rd → R ∪ {+∞} where IC (X) = 0 if X ∈ C, IC (X) = +∞ otherwise. For a vector or matrix A,
we note kAk the Frobenius (or Euclidean) norm, and kAkop the operator norm.
2 Combining implicit differentiation and autodiff
2.1 General principles
Overview. Contrary to autodiff through unrolled algorithm iterations, implicit differentiation
typically involves a manual, sometimes complicated, mathematical derivation. For instance, numerous
works (Chapelle et al., 2002; Gould et al., 2016; Amos & Kolter, 2017; Niculae et al., 2018; Niculae
& Martins, 2020) use Karush-Kuhn-Tucker (KKT) conditions in order to relate a constrained
optimization problem’s solution to its inputs, and to manually derive a formula for its derivatives.
The derivation and implementation in these works are always case-by-case.
2
Under review as a conference paper at ICLR 2022
X_train, y_train = load_data() # Load features and labels
def f(x, theta): # Objective function
residual = jnp.dot(X_train, x) - y_train
return (jnp.sum(residual ** 2) + theta * jnp.sum(x ** 2)) / 2
#	Since f is differentiable and unconstrained, the optimality
#	condition F is simply the gradient of f in the 1st argument
F = jax.grad(f, argnums=0)
@custom_root(F)
def ridge_solver(init_x, theta):
del init_x # Initialization not used in this solver
XX = jnp.dot(X_train.T, X_train)
Xy = jnp.dot(X_train.T, y_train)
I = jnp.eye(X_train.shape[1]) # Identity matrix
# Finds the ridge reg solution by solving a linear system
return jnp.linalg.solve(XX + theta * I, Xy)
init_x = None
print(jax.jacobian(ridge_solver, argnums=1)(init_x, 10.0))
Figure 1: Adding implicit differentiation on top of a ridge regression solver. The function f (x, θ)
defines the objective function and the mapping F , here simply equation (4), captures the optimality
conditions. Our decorator @custom_root automatically adds implicit differentiation to the solver
for the user, overriding JAX’s default behavior. The last line evaluates the Jacobian at θ = 10.
In this work, we propose a generic way to easily add implicit differentiation on top of existing solvers.
In our approach, the user defines directly in Python a mapping function F capturing the optimality
conditions of the problem solved by the algorithm. We provide reusable building blocks to easily
express such F. The provided F is then plugged into our Python decorator @custom_root, which
we append on top of the solver declaration we wish to differentiate. Under the hood, we combine
implicit differentiation and autodiff of F to automatically differentiate the optimization problem
solution. A simple illustrative example is given in Figure 1.
Differentiating a root. Let F : Rd ×Rn → Rd be a user-provided mapping, capturing the optimality
conditions of a problem. An optimal solution, denoted x?(θ), should be a root of F:
F(x*(θ), θ) = 0 .	(1)
We can see x? (θ) as an implicitly defined function of θ ∈ Rn, i.e., x? : Rn → Rd. More precisely,
from the implicit function theorem (Griewank & Walther, 2008; Krantz & Parks, 2012), we know
that for (x0, θ0) satisfying F(x0, θ0) = 0 with a continuously differentiable F, if the Jacobian ∂1F
evaluated at (xo, θ0) is a square invertible matrix, then there exists a function χ*(∙) defined on a
neighborhood of θo such that χ？(θ0) = χ0. Furthermore, for all θ in this neighborhood, We have that
F(χ?(θ), θ) = 0 and ∂x?(θ) exists. Using the chain rule, the Jacobian ∂x*(θ) satisfies
∂ιF(x*(θ), θ)∂x*(θ) + ∂2F(x*(θ), θ)=0.
Computing ∂x？(θ) therefore boils down to the resolution of the linear system of equations
-∂1F(x*(θ), θ) ∂x*(θ) = ∂2F(x*(θ), θ) .	(2)
、	{	‘ι"{z"}	、	{	'
A∈Rd×d	J∈Rd×n	B∈Rd×n
When (1) is a one-dimensional root finding problem (d = 1), (2) becomes particularly simple since
we then have Vχ？(θ) = B›/A, where A is a scalar value.
We will show that existing and new implicit differentiation methods all reduce to this simple principle.
We call our approach hybrid, since it combines implicit differentiation (and as such requires solving a
linear system) with autodiff of the optimality conditions F . Our approach is efficient as it can be
added on top of any state-of-the-art solver and modular as the optimality condition specification is
decoupled from the implicit differentiation mechanism. This contrasts with existing works, where
the mathematical derivation and implementation are specific to each optimality condition.
Differentiating a fixed point. We will encounter numerous applications where χ*(θ) is implicitly
defined through a fixed point:
x*(θ) = T(x*(θ),θ),
3
Under review as a conference paper at ICLR 2022
where T : Rd × Rn → Rd. This can be seen as a particular case of (1) by defining the residual
F(x, θ) = T(x, θ) - x .	(3)
In this case, using the chain rule, we have
A = -∂ιF(x*(θ), θ) = I - ∂1T(x*(θ),θ) and B = ∂zF(x*(θ),θ) = ∂2T(x*(θ),θ).
Computing JVPs and VJPs. In most practical scenarios, it is not necessary to explicitly form
the Jacobian matrix, and instead it is sufficient to left-multiply or right-multiply by ∂1 F and ∂2F.
These are called vector-Jacobian product (VJP) and Jacobian-vector product (JVP), and are useful for
integrating x?(θ) with reverse-mode and forward-mode autodiff, respectively. Oftentimes, F will be
explicitly defined. In this case, computing the VJP or JVP can be done via autodiff. In some cases, F
may itself be implicitly defined, for instance when F involves the solution of a variational problem.
In this case, computing the VJP or JVP will itself involve implicit differentiation.
The right-multiplication (JVP) between J = ∂x*(θ) and a vector v, Jv, can be computed efficiently
by solving A(Jv) = Bv. The left-multiplication (VJP) of v> with J, v>J, can be computed by first
solving A>u = v. Then, we can obtain v>J by v>J = u>AJ = u>B. Note that when B changes
but A and v remain the same, we do not need to solve A>u = v once again. This allows to compute
the VJP w.r.t. different variables while solving only one linear system.
To solve these linear systems, we can use the conjugate gradient method (Hestenes et al., 1952) when
A is symmetric positive semi-definite and GMRES (Saad & Schultz, 1986) or BiCGSTAB (Vorst &
van der Vorst, 1992) otherwise. These algorithms are all matrix-free: they only require matrix-vector
products. Thus, all we need from F is its JVPs or VJPs. An alternative to GMRES/BiCGSTAB is to
solve the normal equation AA>u = Av using conjugate gradient. We implement this using JAX’s
automatic transpose routine jax.linear_transpose (Frostig et al., 2021).
Pre-processing and post-processing mappings. Oftentimes, the goal is not to differentiate θ per
se, but the parameters of a function producing θ. One example of such pre-processing is to convert the
parameters to be differentiated from one form to another canonical form, such as a quadratic program
(Amos & Kolter, 2017) or a conic program (Agrawal et al., 2019a). Another example is when x?(θ)
is used as the output of a neural network layer, in which case θ is produced by the previous layer.
Likewise, χ*(θ) will often not be the final output we want to differentiate. One example of such
post-processing is when x?(θ) is the solution of a dual program and we apply the dual-primal mapping
to recover the solution of the primal program. Another example is the application of a loss function,
in order to reduce x? (θ) to a scalar value. We leave the differentiation of such pre/post-processing
mappings to the autodiff system, allowing to compose functions in complex ways.
Implementation details. When a solver function is decorated with @custom_root, we use
jax.custom_jvp and jax.custom_vjp to automatically add custom JVP and VJP rules to
the function, overriding JAX’s default behavior. As mentioned above, we use linear system solvers
based on matrix-vector products and therefore we only need access to F through the JVP or VJP
with ∂1 F and ∂2F. This is done by using jax.jvp and jax.vjp, respectively. Note that, as
in Figure 1, the definition of F will often include a gradient mapping Vif (x, θ). Thankfully,
JAX supports second-order derivatives transparently. For convenience, our library also provides a
@custom_fixed_point decorator, for adding implicit differentiation on top of a solver, given a
fixed point iteration T ; see code examples in Appendix A.
2.2 Examples
We now give various examples of mapping F or fixed point iteration T, recovering existing implicit
differentiation methods and creating new ones. Each choice of F or T implies different trade-offs in
terms of computational oracles; see Table 1. Source code examples are given in Appendix A.
Stationary point condition. The simplest example is to differentiate through the implicit function
x? (θ) = argmin f (x, θ),
x∈Rd
where f : Rd × Rn → R is twice differentiable. In this case, F is simply the gradient mapping
F(x,θ) = V1f (x, θ).	(4)
4
Under review as a conference paper at ICLR 2022
Table 1: Summary of optimality condition mappings. Oracles are accessed through their JVP or VJP.
Name	Equation	Solution needed	Oracles needed
Stationary	(4), (5)	Primal	v1f
KKT	(6)	Primal and dual	Vif, H, G, ∂1H, ∂1G
Proximal gradient	(7)	Primal	Jf ,proxηg
Projected gradient	(9)	Primal	Vif, projC
Mirror descent	(11)	Primal	Vif,proj& V
Newton	(14)	Primal	[V2if (x, θ)]-i, Vif (x, θ)
Block proximal gradient	(15)	Primal	[Vif]j, [proxηg]j
Conic programming	(18)	Residual map root	PrOjRp ×k* ×R+
We then have ∂∖F(x,θ) = V2f (x, θ) and ∂2F(χ,θ) = ∂2V1f (x, θ), the Hessian of f in its first
argument and the Jacobian in the second argument of Vif (x, θ). In practice, We use autodiff to
compute Jacobian products automatically. Equivalently, we can use the gradient descent fixed point
T(x,θ) = x - ηV1f(x, θ),
(5)
for all η > 0. Using (3), it is easy to check that we obtain the same linear system since η cancels out.
KKT conditions. We now show that the KKT conditions, manually differentiated in several works
(Chapelle et al., 2002; Gould et al., 2016; Amos & Kolter, 2017; Niculae et al., 2018; Niculae &
Martins, 2020), fit our framework. As we will see, the key will be to group the optimal primal and
dual variables as our x? (θ). Let US consider the general problem
argmin f(z, θ) subject to G(z, θ) ≤ 0, H(z, θ) = 0,
z∈Rp
where z ∈ Rp is the primal variable, f: Rp ×Rn → R, G: Rp ×Rn → Rr andH: Rp ×Rn → Rq.
The stationarity, primal feasibility and complementary slackness conditions give
V1f(z, θ) + [∂1G(z, θ)]>λ + [∂1H(z, θ)]>ν = 0
H(z,θ) =0
λ ◦ G(z,θ) =0,
(6)
Where ν ∈ Rq and λ ∈ Rr+ are the dual variables, also knoWn as KKT multipliers. The primal
and dual feasibility conditions can be ignored almost everyWhere. The system of (potentially
nonlinear) equations (6) fits our frameWork, as We can group the primal and dual solutions as
x?(θ) = (z*(θ), V?(θ), λ*(θ)) to form the root of a function F(x*(θ),θ), where F: Rd X Rn → Rd
and d = p + q + r. The primal and dual solutions can be obtained from a generic solver, such as
an interior point method. In practice, the above mapping F will be defined directly in Python (see
Figure 7 in Appendix A) and F will be differentiated automatically via autodiff.
Proximal gradient fixed point. Unfortunately, not all algorithms return both primal and dual
solutions. Moreover, if the objective contains non-smooth terms, proximal gradient descent may be
more efficient. We now discuss its fixed point (Niculae & Blondel, 2017; Bertrand et al., 2020; 2021).
Let x? (θ) be implicitly defined as
x? (θ) := argmin f(x, θ) + g(x, θ),
x∈Rd
where f : Rd × Rn → R is twice-differentiable convex and g : Rd × Rn → R is convex but possibly
non-smooth. Let us define the proximity operator associated with g by
proxg(y,θ) := argmin 1 ∣∣x — y∣∣2 + g(x,θ).
x∈Rd 2
To implicitly differentiate x?(θ), we use the fixed point mapping (Parikh & Boyd, 2014, p.150)
T(x,θ) = proxηg(x - ηV1f (x, θ), θ),	(7)
for any step size η > 0. The proximity operator is 1-Lipschitz continuous (Moreau, 1965). By
Rademacher’s theorem, it is differentiable almost everywhere. Many proximity operators enjoy a
closed form and can easily be differentiated, as discussed in Appendix B.
5
Under review as a conference paper at ICLR 2022
Projected gradient fixed point. As a special case, when g(x, θ) is the indicator function IC(θ) (x),
where C(θ) is a convex set depending on θ, we obtain
x? (θ) = argmin f (x, θ).	(8)
x∈C(θ)
The proximity operator proxg becomes the Euclidean projection onto C(θ)
proxg(y,θ) = projC(y,θ) := argmin kx - yk22
x∈C(θ)
and (7) becomes the projected gradient fixed point
T (x,θ) = ProjC (X — ηVιf (x,θ),θ).	(9)
Compared to the KKT conditions, this fixed point is particularly suitable when the projection enjoys
a closed form. We discuss how to comPute the JVP / VJP for a wealth of convex sets in APPendix B.
Mirror descent fixed point. We again consider the case when x?(θ) is implicitly defined as the
solution of (8). We now generalize the Projected gradient fixed Point beyond Euclidean geometry.
Let the Bregman divergence DW : dom(夕)X relint(dom(夕))→ R+ generated by 夕 be defined by
Dφ(x,y) := φ(x) — φ(y) — hvφ(y),x — yi.
We define the Bregman projection of y onto C(θ) ⊆ dom(夕)by
ProjW(y,θ)= argminDW(x, ▽2"(y)).	(10)
x∈C(θ)
Definition (10) includes the mirror map V夕" (y) for convenience. It can be seen as a mapping from
Rd to dom(夕)，ensuring that (10) is well-defined. The mirror descent fixed point mapping is then
X = Vg(X)
y = X — ηVf(χ,θ)
T(X, θ) = projCW(y, θ).	(11)
Because T involves the composition of several functions, manually deriving its JVP/VJP is error
prone. This shows that our approach leveraging autodiff allows to handle more advanced fixed point
mappings. A common example of g is g(X) = hX, log X — 1i, where dom(g) = Rd+. In this case,
DW is the Kullback-Leibler divergence. An advantage of the Kullback-Leibler projection is that it
sometimes easier to compute than the Euclidean projection, as we detail in Appendix B.
Other fixed points. More fixed points are described in Appendix C.
3	Jacobian precision guarantees
In practice, either by the limitations of finite precision arithmetic or because we perform a finite
number of iterations, we rarely reach the exact solution x? (θ), but instead only reach an approximate
solution X and apply the implicit differentiation equation (2) at this approximate solution. This
motivates the need for precision guarantees of this approach. We introduce the following formalism.
Definition 1. Let F : Rd × Rn → Rd be an optimality Criterion mapping. Let A := —∂ιF
and B := ∂2F. We define the Jacobian estimate at (X, θ) as the solution to the linear equation
A(X, θ)J (X, θ) = B(X, θ). It is a function J : Rd × Rn → Rd×n.
It holds by construction that J(x*(Θ),Θ) = ∂x*(Θ). Computing J(X, θ) for an approximate solution
X of x?(Θ) therefore allows to approximate the true Jacobian ∂x？(Θ). In practice, an algorithm used
to solve (1) depends on θ. Note however that, what we compute is not the Jacobian of X(θ), unlike
works differentiating through unrolled algorithm iterations, but an estimate of ∂X? (θ). We therefore
use the notation X, leaving the dependence on θ implicit.
We develop bounds of the form ∣∣ J(X,θ) — ∂x*(Θ) k < CkX — x*(Θ) ∣∣, hence showing that the error
on the estimated Jacobian is at most of the same order as that of X as an approximation of x?(Θ).
These bounds are based on the following main theorem, whose proof is included in Appendix D.
6
Under review as a conference paper at ICLR 2022
Theorem 1 (Jacobian estimate). Let F : Rd × Rn → Rd. Assume that there exist α, β , γ, ε, R > 0
such that A = -∂∖F and B = ∂2F satisfy, for all V ∈ Rd, θ ∈ Rn and X such that kX — x*(θ) k ≤ ε:
A is well-conditioned, Lipschitz: kA(x, θ)v∣∣ ≥ α∣∣vk, ∣∣A(x, θ) — A(x*(θ), θ)kop ≤ YkX — x*(θ)∣∣.
B isboundedandLipsChitz: kB(x*(θ),θ)k ≤ R, ∣∣B(x,θ) — B(x*(θ),θ)k ≤ β∣∣x - x?(θ)∣∣.
Under these conditions, when ∣∣X — x*(θ)k ≤ ε, we have
kJ(X,θ) — ∂x*(θ)∣∣ ≤ (βα-1 + γRα-2) ∣∣X — x?(θ)∣∣ .
This result is inspired by (Higham, 2002, Theorem 7.2), that is concerned with the stability of
solutions to inverse problems. Here We consider that A(∙, θ) is uniformly well-conditioned, rather
than only at χ*(θ). This does not affect the first order in ε of this bound, and makes it valid for all X.
It is also more tailored to applications to equation-specific cases.
Indeed, Theorem 1 can be applied to specific cases. In particular, for the gradient descent fixed point,
where T(x, θ) = X — ηVι f(χ, θ) and F(x, θ) = T(χ,θ) — x, this yields
A(x, θ) = ηV2f (x, θ) and B(x,Θ) = —η∂2V1 f (x, θ).
The guarantees on Jacobian precision under regularity conditions rely on f directly; see Corollary 1
in Appendix D. This reveals in particular that Jacobian estimation by implicit differentiation gains
a factor of t compared to automatic differentiation, after t iterations of gradient descent in the
strongly-convex setting (Ablin et al., 2020, Proposition 3.2). While our guarantees concern the
Jacobian of x?(Θ), we note that other studies (Grazzi et al., 2020; Ji et al., 2021; Bertrand et al., 2021)
give guarantees on hypergradients (i.e., the gradient of an outer objective).
We illustrate these results on ridge regression, where
X*(θ) = argmi5 ∣∣Φx — y∣2 + Pi θiX2. This problem
has the merit that the solution X?(θ) and its Jacobian
∂X? (θ) are available in closed form. By running gradient
descent for t iterations, we obtain an estimate X of x?(Θ)
and an estimate J(X, θ) of ∂x*(Θ); cf. Definition 1. By
doing so for different numbers of iterations t, we can
graph the relation between the error ∣∣x?(Θ) — X∣2 and
the error ∣∂x?(Θ) — J(X,θ)∣2, as shown in Figure 2,
empirically validating Theorem 1. The results in Figure 2
were obtained using the diabetes dataset from Efron et al.
(2004), with other datasets yielding a qualitatively similar
behavior. We derive similar guarantees in Corollary 2 in
Appendix D for proximal gradient descent.
4	Experiments
∣∣χ*(θ)-χ∣∣2
Figure 2: Jacobian estimate errors. Em-
pirical error of implicit differentiation fol-
lows closely the theoretical upper bound.
Unrolling achieves a much worse error
for comparable iterate error.
To conclude this work, we demonstrate the ease of solving bi-level optimization problems with our
framework. We also present an application to the sensitivity analysis of molecular dynamics.
4.1	Hyperparameter optimization of multiclass SVMs
In this example, we consider the hyperparameter optimization of multiclass SVMs (Crammer &
Singer, 2001) trained in the dual. Here, x*(Θ) is the optimal dual solution, a matrix of shape
m × k, where m is the number of training examples and k is the number of classes, and θ ∈ R+
is the regularization parameter. The challenge in differentiating x?(Θ) is that each row of x?(Θ) is
constrained to belong to the probability simplex 4k. More formally, let Xtr ∈ Rm×p be the training
feature matrix and Ytr ∈ {0, 1}m×k be the training labels (in row-wise one-hot encoding). Let
W(x, θ) := Xtr (Ytr — x)∕Θ ∈ Rp×k be the dual-primal mapping. Then, we consider the following
bi-level optimization problem
1
min - IlXvalW(x*(θ),θ)- KalkF
θ=exp(λ) 2
^^^^™{^^^^^"
outer problem
|
θ2
subject to	x?(θ) = argmin f(x, θ) := -∣W(x, Θ)∣f +〈x,Kr),
x∈C	2
'---------------{----------------}
inner problem
7
Under review as a conference paper at ICLR 2022
Figure 3: CPU runtime comparison of implicit differentiation and unrolling for hyperparameter
optimization of multiclass SVMs for multiple problem sizes. Error bars represent 90% confidence
intervals. (a) Mirror descent solver, with mirror descent fixed point for implicit differentiation.
(b) Proximal gradient solver, with proximal gradient fixed point for implicit differentiation. (c)
Block coordinate descent solver; for implicit differentiation we obtain x? (θ) by BCD but perform
differentiation with the mirror descent and proximal gradient fixed points. This showcases that the
solver and fixed point can be independently chosen.
where C = 4k X …×4k is the Cartesian product of m probability SimPlices. We apply the change
of variable θ = exp(λ) in order to guarantee that the hyper-parameter θ is positive. The matrix
W (x? (θ), θ) ∈ Rp×k contains the optimal primal solution, the feature weights for each class. The
outer loss is computed against validation data Xval and Yval .
While KKT conditions can be used to differentiate x? (θ), a more direct way is to use the projected
gradient fixed point (9). The projection onto C can be easily computed by row-wise projections on the
simplex. The projection’s Jacobian enjoys a closed form (Appendix B). Another way to differentiate
x*(θ) is using the mirror descent fixed point (11). Under the KL geometry, PrOjf (y, θ) corresponds
to a row-wise softmax. It is therefore easy to compute and differentiate. Figure 3 compares the
runtime performance of implicit differentiation vs. unrolling for the latter two fixed points.
4.2	Dataset distillation
Dataset distillation (Wang et al., 2018; Lorraine et al., 2020) aims to learn a small synthetic training
dataset such that a model trained on this learned data set achieves a small loss on the original training
set. Formally, let Xtr ∈ Rm×p and ytr ∈ [k]m denote the original training set. The distilled dataset
will contain one prototype example for each class and therefore θ ∈ Rk×p. The dataset distillation
problem can then naturally be cast as a bi-level problem, where in the inner problem we estimate a
logistic regression model x?(θ) ∈ Rp×k trained on the distilled images θ ∈ Rk×p, while in the outer
problem we want to minimize the loss achieved by χ*(θ) over the training set:
min
θ∈Rk×p
f (x*(θ), Xtr; ytr) subject to x*(θ) ∈ argmin f(x, θ; [k]) + ε∣∣xk2 ,
outer problem
x∈Rp×k
(12)
{^^^^^^≡
inner problem
}
}
where f (W, X; y) := '(y, XW), ' denotes the multiclass logistic regression loss, and ε = 10-3 is a
regularization parameter that we found had a very positive effect on convergence.
In this problem, and unlike in the general hyperparameter optimiza-
tion setup, both the inner and outer problems are high-dimensional,
making it an ideal test-bed for gradient-based bi-level optimization
methods. For this experiment, we use the MNIST dataset. The
number of parameters in the inner problem is p = 282 = 784.
while the number of parameters of the outer loss is k × p = 7840.
We solve this problem using gradient descent on both the inner and
outer problem, with the gradient of the outer loss computed using
implicit differentiation, as described in §2. This is fundamentally
different from the approach used in the original paper, where they
used differentiation of the unrolled iterates instead. For the same
solver, we found that the implicit differentiation approach was 4
Figure 4: Distilled dataset θ ∈
Rk×p obtained by solving (12).
8
Under review as a conference paper at ICLR 2022
Table 2: Mean AUC (and 95% confidence interval) for the cancer survival prediction problem.
Method I	L1 logreg	L2 logreg	DictL + L2 logreg	Task-driven DictL
AUC (%) I	71.6 ± 2.0	72.4 ± 2.8	68.3 ± 2.3	73.2 ± 2.1
times faster than the original one. The obtained distilled images θ
are visualized in Figure 4.
4.3	Task-driven dictionary learning
Task-driven dictionary learning was proposed to learn sparse codes
for input data in such a way that the codes solve an outer learning problem (Mairal et al., 2012;
Sprechmann et al., 2014; Zarka et al., 2019). Formally, given a data matrix Xtr ∈ Rm×p and a
dictionary of k atoms θ ∈ Rk×p, a sparse code is defined as a matrix x?(θ) ∈ Rm×k that minimizes
in X a reconstruction loss f (x, θ) := '(Xtr, χθ) regularized by a sparsity-inducing penalty g(χ).
Instead of optimizing the dictionary θ to minimize the reconstruction loss, Mairal et al. (2012)
proposed to optimize an outer problem that depends on the code. Given a set of labels Ytr ∈ {0, 1}m,
we consider a logistic regression problem which results in the bilevel optimization problem:
σ(x*(θ)w + b; ytr) subject to x*(θ) ∈ argmin f(x, θ) + g(x) .	(13)
min
θ∈Rk×p,w∈Rk,b∈R
}
^^^^^{^^^^^
outer problem
x∈Rm×k
、----------{-----
inner problem
}
When ` is the squared Frobenius distance between matrices, and g the elastic net penalty, Mairal
et al. (2012, Eq. 21) derive manually, using optimality conditions (notably the support of the codes
selected at the optimum), an explicit re-parameterization of x? (θ) as a linear system involving θ. This
closed-form allows for a direct computation of the Jacobian of x? w.r.t. θ. Similarly, (Sprechmann
et al., 2014) derive first order conditions in the case where ` is a β-divergence, while (Zarka et al.,
2019) propose to use unrolling of ISTA iterations. Our approach bypasses all of these manual
derivations, giving the user more leisure to focus directly on modeling (loss, regularizer) aspects.
We illustrate this on breast cancer survival prediction from gene expression data. We frame it as a
binary classification problem to discriminate patients who survive longer than 5 years (m1 = 200) vs
patients who die within 5 years of diagnosis (m0 = 99), from p = 1, 000 gene expression values. As
shown in Table 2, solving (13) (Task-driven DictL) reaches a classification performance competitive
with state-of-the-art L1 or L2 regularized logistic regression with 100 times fewer variables.
4.4	Sensitivity analysis of molecular dynamics
Many physical simulations require solving optimization problems,
such as energy minimization in molecular (Schoenholz & Cubuk,
2020) and continuum (Beatson et al., 2020) mechanics, structural
optimization (Hoyer et al., 2019) and data assimilation (Frerix
et al., 2021). In this experiment, we revisit an example from JAX-
MD (Schoenholz & Cubuk, 2020), the problem of finding energy
minimizing configurations to a system of k packed particles in a
2-dimensional box of size `
x? (θ) = argmin f (x, θ) :=	U (xi,j, θ),
x∈Rk×2	i,j
Figure 5: Particle positions
and position sensitivity vectors,
with respect to increasing the
diameter of the blue particles.
where χ?(θ) ∈ Rk×2 are the optimal coordinates of the k particles,
U (xi,j , θ) is the pairwise potential energy function, with half the
particles at diameter 1 and half at diameter θ = 0.6, which we
optimize with a domain-specific optimizer (Bitzek et al., 2006).
Here we consider sensitivity of particle position with respect to
diameter ∂x*(θ), rather than sensitivity of the total energy from the original experiment. Figure 5
shows results calculated via forward-mode implicit differentiation (JVP). Whereas differentiating the
unrolled optimizer happens to work for total energy, here it typically does not even converge (see
Appendix Figure 17), due the discontinuous optimization method.
9
Under review as a conference paper at ICLR 2022
References
Pierre Ablin, Gabriel Peyr6, and Thomas Moreau. SUPer-efficiency of automatic differentiation for
functions defined as a minimum. In Proc. of ICML, pp. 32-41, 2020.
Akshay Agrawal, Brandon Amos, Shane Barratt, StePhen Boyd, Steven Diamond, and Zico Kolter.
Differentiable convex optimization layers. arXiv preprint arXiv:1910.12430, 2019a.
Akshay Agrawal, Shane Barratt, Stephen Boyd, Enzo Busseti, and Walaa M Moursi. Differentiating
through a cone program. arXiv preprint arXiv:1904.09043, 2019b.
Alnur Ali, Eric Wong, and J Zico Kolter. A semismooth newton method for fast, generic convex
programming. In International Conference on Machine Learning, pp. 70-79. PMLR, 2017.
Brandon Amos. Differentiable optimization-based modeling for machine learning. PhD thesis, PhD
thesis. Carnegie Mellon University, 2019.
Brandon Amos and J Zico Kolter. Optnet: Differentiable optimization as a layer in neural networks.
In Proc. of ICML, pp. 136-145, 2017.
Joel AE Andersson, Joris Gillis, Greg Horn, James B Rawlings, and Moritz Diehl. Casadi: a
software framework for nonlinear optimization and optimal control. Mathematical Programming
Computation, 11(1):1-36, 2019.
Shaojie Bai, J Zico Kolter, and Vladlen Koltun. Deep equilibrium models. arXiv preprint
arXiv:1909.01377, 2019.
Alex Beatson, Jordan Ash, Geoffrey Roeder, Tianju Xue, and Ryan P Adams. Learning composable
energy surrogates for pde order reduction. In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan,
and H. Lin (eds.), Advances in Neural Information Processing Systems, volume 33, pp. 338-
348. Curran Associates, Inc., 2020. URL https://proceedings.neurips.cc/paper/
2020/file/0332d694daab22e0e0eaf7a5e88433f9-Paper.pdf.
Bradley M Bell and James V Burke. Algorithmic differentiation of implicit functions and optimal
values. In Advances in Automatic Differentiation, pp. 67-77. Springer, 2008.
Yoshua Bengio. Gradient-based optimization of hyperparameters. Neural computation, 12(8):
1889-1900, 2000.
Quentin Bertrand, Quentin Klopfenstein, Mathieu Blondel, Samuel Vaiter, Alexandre Gramfort, and
Joseph Salmon. Implicit differentiation of lasso-type models for hyperparameter optimization. In
Proc. of ICML, pp. 810-821, 2020.
Quentin Bertrand, Quentin Klopfenstein, Mathurin Massias, Mathieu Blondel, Samuel Vaiter, Alexan-
dre Gramfort, and Joseph Salmon. Implicit differentiation for fast hyperparameter selection in
non-smooth convex learning. arXiv preprint arXiv:2105.01637, 2021.
Michael J Best, Nilotpal Chakravarti, and Vasant A Ubhaya. Minimizing separable convex functions
subject to simple chain constraints. SIAM Journal on Optimization, 10(3):658-672, 2000.
Erik Bitzek, Pekka Koskinen, Franz Gahler, Michael Moseler, and Peter Gumbsch. Structural
relaxation made simple. Phys. Rev. Lett., 97:170201, Oct 2006. doi: 10.1103/PhysRevLett.97.
170201. URL https://link.aps.org/doi/10.1103/PhysRevLett.97.170201.
Mathieu Blondel. Structured prediction with projection oracles. In Proc. of NeurIPS, 2019.
Mathieu Blondel, Vivien Seguy, and Antoine Rolet. Smooth and sparse optimal transport. In Proc. of
AISTATS, pp. 880-889. PMLR, 2018.
Mathieu Blondel, Olivier Teboul, Quentin Berthet, and Josip Djolonga. Fast differentiable sorting
and ranking. In Proc. of ICML, pp. 950-959, 2020.
J Frederic Bonnans and Alexander Shapiro. Perturbation analysis ofoptimization problems. Springer
Science & Business Media, 2013.
10
Under review as a conference paper at ICLR 2022
James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal
Maclaurin, George Necula, Adam Paszke, Jake VanderPlas, Skye Wanderman-Milne, and
Qiao Zhang. JAX: composable transformations of Python+NumPy programs, 2018. URL
http://github.com/google/jax.
Peter Brucker. An O(n) algorithm for quadratic knapsack problems. Operations Research Letters, 3
(3):163-166,1984.
Olivier Chapelle, Vladimir Vapnik, Olivier Bousquet, and Sayan Mukherjee. Choosing multiple
parameters for support vector machines. Machine learning, 46(1):131-159, 2002.
Hamza Cherkaoui, Jeremias Sulam, and Thomas Moreau. Learning to solve tv regularised problems
with unrolled algorithms. Advances in Neural Information Processing Systems, 33, 2020.
Laurent Condat. Fast projection onto the simplex and the `1 ball. Mathematical Programming, 158
(1-2):575-585, 2016.
Koby Crammer and Yoram Singer. On the algorithmic implementation of multiclass kernel-based
vector machines. Journal of machine learning research, 2(Dec):265-292, 2001.
Marco Cuturi. Sinkhorn distances: lightspeed computation of optimal transport. In Advances in
Neural Information Processing Systems, volume 2, 2013.
Charles-Alban Deledalle, Samuel Vaiter, Jalal Fadili, and Gabriel Peyr6. Stein unbiased gradient
estimator of the risk (sugar) for multiple parameter selection. SIAM Journal on Imaging Sciences,
7(4):2448-2487, 2014.
Steven Diamond and Stephen Boyd. Cvxpy: A python-embedded modeling language for convex
optimization. The Journal of Machine Learning Research, 17(1):2909-2913, 2016.
Josip Djolonga and Andreas Krause. Differentiable learning of submodular models. Proc. of NeurIPS,
30:1013-1023, 2017.
Justin Domke. Generic methods for optimization-based modeling. In Artificial Intelligence and
Statistics, pp. 318-326. PMLR, 2012.
John C Duchi, Shai Shalev-Shwartz, Yoram Singer, and Tushar Chandra. Efficient projections onto
the `1 -ball for learning in high dimensions. In Proc. of ICML, 2008.
David Duvenaud, J. Zico Kolter, and Matthew Johnson. Deep implicit layers tutorial - neural ODEs,
deep equilibirum models, and beyond. Neural Information Processing Systems Tutorial, 2020.
Bradley Efron, Trevor Hastie, Iain Johnstone, and Robert Tibshirani. Least angle regression. The
Annals of statistics, 32(2):407-499, 2004.
Laurent El Ghaoui, Fangda Gu, Bertrand Travacca, Armin Askari, and Alicia Y Tsai. Implicit deep
learning. arXiv preprint arXiv:1908.06315, 2, 2019.
Rong-En Fan, Kai-Wei Chang, Cho-Jui Hsieh, Xiang-Rui Wang, and Chih-Jen Lin. Liblinear: A
library for large linear classification. JMLR, 9:1871-1874, 2008.
Luca Franceschi, Michele Donini, Paolo Frasconi, and Massimiliano Pontil. Forward and reverse
gradient-based hyperparameter optimization. In International Conference on Machine Learning,
pp. 1165-1173. PMLR, 2017.
Luca Franceschi, Paolo Frasconi, Saverio Salzo, Riccardo Grazzi, and Massimiliano Pontil. Bilevel
programming for hyperparameter optimization and meta-learning. In International Conference on
Machine Learning, pp. 1568-1577. PMLR, 2018.
Thomas Frerix, Dmitrii Kochkov, Jamie A. Smith, Daniel Cremers, Michael P. Brenner, and Stephan
Hoyer. Variational data assimilation with a learned inverse observation operator. 2021.
Roy Frostig, Matthew Johnson, Dougal Maclaurin, Adam Paszke, and Alexey Radul. Decomposing
reverse-mode automatic differentiation. In LAFI 2021 workshop at POPL, 2021. URL https:
//arxiv.org/abs/2105.09469.
11
Under review as a conference paper at ICLR 2022
Stephen Gould, Basura Fernando, Anoop Cherian, Peter Anderson, Rodrigo Santa Cruz, and Edison
Guo. On differentiating parameterized argmin and argmax problems with application to bi-level
optimization. arXiv preprint arXiv:1607.05447, 2016.
Stephen Gould, Richard Hartley, and Dylan Campbell. Deep declarative networks: A new hope.
arXiv preprint arXiv:1909.04866, 2019.
Riccardo Grazzi, Luca Franceschi, Massimiliano Pontil, and Saverio Salzo. On the iteration com-
plexity of hypergradient computation. In International Conference on Machine Learning, pp.
3748-3758. PMLR, 2020.
Andreas Griewank and Andrea Walther. Evaluating derivatives: principles and techniques of
algorithmic differentiation. SIAM, 2008.
SJ Grotzinger and C Witzgall. Projections onto order simplexes. Applied mathematics and Optimiza-
tion, 12(1):247-270, 1984.
Isabelle Guyon. Design of experiments of the nips 2003 variable selection benchmark. In NIPS 2003
workshop on feature extraction and feature selection, volume 253, 2003.
Magnus Rudolph Hestenes, Eduard Stiefel, et al. Methods of conjugate gradients for solving linear
systems, volume 49. NBS Washington, DC, 1952.
Nicholas J. Higham. Accuracy and Stability of Numerical Algorithms. Society for Industrial and
Applied Mathematics, second edition, 2002. doi: 10.1137/1.9780898718027. URL https:
//epubs.siam.org/doi/abs/10.1137/1.9780898718027.
Stephan Hoyer, Jascha Sohl-Dickstein, and Sam Greydanus. Neural reparameterization improves
structural optimization. 2019.
Kaiyi Ji, Junjie Yang, and Yingbin Liang. Bilevel optimization: Convergence analysis and enhanced
design. In International Conference on Machine Learning, pp. 4882-4892. PMLR, 2021.
Yoon Kim, Carl Denton, Luong Hoang, and Alexander M Rush. Structured attention networks. arXiv
preprint arXiv:1702.00887, 2017.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Steven G Krantz and Harold R Parks. The implicit function theorem: history, theory, and applications.
Springer Science & Business Media, 2012.
Cong Han Lim and Stephen J Wright. Efficient bregman projections onto the permutahedron and
related polytopes. In Proc. of AISTATS, pp. 1205-1213. PMLR, 2016.
Jonathan Lorraine, Paul Vicol, and David Duvenaud. Optimizing millions of hyperparameters by
implicit differentiation. In International Conference on Artificial Intelligence and Statistics, pp.
1540-1552. PMLR, 2020.
Julien Mairal, Francis Bach, and Jean Ponce. Task-driven dictionary learning. IEEE Transactions on
Pattern Analysis and Machine Intelligence, 34(4):791-804, 2012. doi: 10.1109/TPAMI.2011.156.
Andr6 FT Martins and Ram6n Fernandez Astudillo. From SoftmaX to SParsemax: A sparse model of
attention and multi-label classification. In Proc. of ICML, 2016.
Christian Michelot. A finite algorithm for finding the projection of a point onto the canonical simplex
of Rn. Journal of Optimization Theory and Applications, 50(1):195-200, 1986.
J.-J. Moreau. Proximite et dualite dans un espace hilbertien. Bulletin de la S.M.F, 93:273-299, 1965.
Vlad Niculae and Mathieu Blondel. A regularized framework for sparse and structured neural
attention. In Proc. of NeurIPS, 2017.
Vlad Niculae and Andre Martins. Lp-sparsemap: Differentiable relaxed optimization for sparse
structured prediction. In International Conference on Machine Learning, pp. 7348-7359, 2020.
12
Under review as a conference paper at ICLR 2022
Vlad Niculae, Andre Martins, Mathieu Blondel, and Claire Cardie. Sparsemap: Differentiable sparse
structured inference. In International Conference on Machine Learning, pp. 3799-3808. pMlR,
2018.
Brendan O’Donoghue, Eric Chu, Neal parikh, and Stephen Boyd. Conic optimization via operator
splitting and homogeneous self-dual embedding. Journal of Optimization Theory and Applications,
169(3):1042-1068, 2016.
Neal parikh and Stephen Boyd. proximal algorithms. Foundations and Trends in optimization, 1(3):
127-239, 2014.
F. pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, p. pretten-
hofer, R. Weiss, V. Dubourg, J. Vanderplas, A. passos, D. Cournapeau, M. Brucher, M. perrot, and
E. Duchesnay. Scikit-learn: Machine learning in python. Journal of Machine Learning Research,
12:2825-2830, 2011.
Fabian pedregosa. Hyperparameter optimization with approximate gradient. In International
conference on machine learning. pMLR, 2016.
Aravind Rajeswaran, Chelsea Finn, Sham Kakade, and Sergey Levine. Meta-learning with implicit
gradients. arXiv preprint arXiv:1909.04630, 2019.
Nimrod Rappoport and Ron Shamir. Multi-omic and multi-view clustering algorithms: review and
cancer benchmark. Nucleic Acids Res., 46:10546-10562, 2018.
Youcef Saad and Martin H Schultz. Gmres: A generalized minimal residual algorithm for solving
nonsymmetric linear systems. SIAM Journal on scientific and statistical computing, 7(3):856-869,
1986.
Samuel Schoenholz and Ekin Dogus Cubuk. Jax md: A framework for differentiable physics.
In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Advances
in Neural Information Processing Systems, volume 33, pp. 11428-11441. Curran Asso-
ciates, Inc., 2020. URL https://proceedings.neurips.cc/paper/2020/file/
83d3d4b6c9579515e1679aca8cbc8033- Paper.pdf.
Matthias W Seeger. Cross-validation optimization for large scale structured classification kernel
methods. Journal of Machine Learning Research, 9(6), 2008.
pablo Sprechmann, Alex M Bronstein, and Guillermo Sapiro. Supervised non-euclidean sparse nmf
via bilevel optimization with applications to speech enhancement. In 2014 4th Joint Workshop on
Hands-free Speech Communication and Microphone Arrays (HSCMA), pp. 11-15. IEEE, 2014.
Samuel Vaiter, Charles-Alban Deledalle, Gabriel Peyra Charles Dossal, and Jalal Fadili. Local behav-
ior of sparse analysis regularization: Applications to risk estimation. Applied and Computational
Harmonic Analysis, 35(3):433-451, 2013.
H A van der Vorst and H A van der Vorst. Bi-CGSTAB: A fast and smoothly converging variant of
Bi-CG for the solution of nonsymmetric linear systems. SIAM Journal on Scientific and Statistical
Computing, 13(2):631-644, 1992. URL http://dx.doi.org/10.1137/0913035.
Tongzhou Wang, Jun-Yan Zhu, Antonio Torralba, and Alexei A Efros. Dataset distillation. arXiv
preprint arXiv:1811.10959, 2018.
Robert Edwin Wengert. A simple automatic derivative evaluation program. Communications of the
ACM, 7(8):463-464, 1964.
Yuhuai Wu, Mengye Ren, Renjie Liao, and Roger B. Grosse. Understanding short-horizon bias
in stochastic meta-optimization. In 6th International Conference on Learning Representations,
ICLR 2018, Vancouver, BC, Canada, April 30 - May 3, 2018, Conference Track Proceedings.
OpenReview.net, 2018. URL https://openreview.net/forum?id=H1MczcgR-.
John Zarka, Louis Thiry, Tomds Angles, and StePhane Mallat. Deep network classification by
scattering and homotopy dictionary learning. arXiv preprint arXiv:1910.03561, 2019.
13
Under review as a conference paper at ICLR 2022
Appendix
A Code examples
A.1 Code examples for optimality conditions
Our library provides several reusable optimality condition mappings F or fixed points T . We
nevertheless demonstrate the ease of writing some of them from scratch.
Proximal gradient fixed point. The proximal gradient fixed point (7) with step size η = 1 is
T(x, θ) = Proxg(X - Vif (x, θf ),θg). It can be implemented as follows.
grad = jax.grad(f)
def T(x, theta):
theta_f, theta_g = theta
return prox(x - grad(x, theta_f), theta_g)
Figure 6:	Proximal gradient fixed point T(x, θ)
We recall that when the proximity operator is a projection, we recover the projected gradient fixed
point as a special case. Therefore, this fixed point can also be used for constrained optimization. We
provide numerous proximal and projection operators in the library.
KKT conditions. As a more advanced example, we now describe how to implement the KKT
conditions (6). The stationarity, primal feasibility and complementary slackness conditions read
V1f(z,θf)+ [∂1G(z, θG)]>λ + [∂1H(z, θH)]>ν = 0
H(z, θH) = 0
λ ◦ G(z,Θg) =0.
Using jax.vjp to compute vector-Jacobian products, this can be implemented as
grad = jax.grad(f)
def F(x, theta):
z, nu, lambd = x
theta_f, theta_H, theta_G = theta
_, H_vjp = jax.vjp(H, z, theta_H)
stationarity = (grad(z, theta_f) + H_vjp(nu)[0])
primal_feasability = H(z, theta_H)
_, G_vjp = jax.vjp(G, z, theta_G)
stationarity += G_vjp(lambd)[0]
comp_slackness = G(z, theta_G) * lambd
return stationarity, primal_feasability, comp_slackness
Figure 7:	KKT conditions F (x, θ)
Similar mappings F can be written if the optimization problem contains only equality constraints or
only inequality constraints.
14
Under review as a conference paper at ICLR 2022
Mirror descent fixed point. Letting η = 1 and denoting θ = (θf, θproj), the fixed point (11) is
X = ▽夕(x)
y = X - Vif (χ,θf)
T (x,θ) = Pr喷(y,θproj).
We can then implement it as follows.
grad = jax.grad(f)
def T(x, theta):
theta_f, theta_proj = params
x_hat = phi_mapping(x)
y = x_hat - grad(x, theta_f)
return bregman_projection(y, theta_proj)
Figure 8:	Mirror descent fixed point T(X, θ)
Although not considered in this example, the mapping V夕 could also depend on θ if necessary.
A.2 Code examples for experiments
We now sketch how to implement our experiments using our framework. In the following, jnp is
short for jax.numpy. In all experiments, we only show how to compute gradients with the outer
objective. We can then use these gradients with gradient-based solvers to solve the outer objective.
Multiclass SVM experiment.
X_tr, Y_tr, X_val, Y_val = load_data()
def W(x, theta): # dual-primal map
return jnp.dot(X_tr.T, Y_tr - x) / theta
def f(x, theta): # inner objective
return (0.5 * theta * jnp.sum(W(x, theta) ** 2) +
jnp.vdot(x, Y_tr))
grad = jax.grad(f)
proj = jax.vmap(projection_simplex) # row-wise projections
def T(x, theta):
return proj(x - grad(x, theta))
@custom_fixed_point(T)
def msvm_dual_solver(init_x, theta):
# [...]
return x_star # solution of the dual objective
def outer_loss(lambd):
theta = jnp.exp(lambd)
x_star = msvm_dual_solver(init_x, theta) # inner solution
Y_pred = jnp.dot(W(x_star, theta), X_val)
return 0.5 * jnp.sum((Y_pred - Y_val) ** 2)
print(jax.grad(outer_loss)(lambd))
Figure 9:	Code example for the multiclass SVM experiment.
15
Under review as a conference paper at ICLR 2022
Task-driven dictionary learning experiment.
X_tr, y_tr = load_data()
def f(x, theta): # dictionary loss
residual = X_tr - jnp.dot(x, theta)
return huber_loss(residual)
grad = jax.grad(f)
def T(x, theta): # proximal gradient fixed point
return prox_lasso(x - grad(x, theta))
@custom_fixed_point(T)
def sparse_coding(init_x, theta): # inner objective
# [...]
return x_star # lasso solution
def outer_loss(theta, w): # task-driven loss
x_star = sparse_coding(init_x, theta) # sparse codes
y_pred = jnp.dot(x_star, w)
return logloss(y_tr, y_pred)
print(jax.grad(outer_loss, argnums=(0,1)))
Figure 10:	Code example for the task-driven dictionary learning experiment.
Dataset distillation experiment.
X_tr, y_tr = load_data()
logloss = jax.vmap(loss.multiclass_logistic_loss)
def f(x, theta, l2reg=1e-3): # inner objective
scores = jnp.dot(theta, x)
distilled_labels = jnp.arange(10)
penalty = l2reg * jnp.sum(x * x)
return jnp.mean(logloss(distilled_labels, scores)) + penalty
F = jax.grad(f)
@custom_root(F)
def logreg_solver(init_x, theta):
# [...]
return x_star
def outer_loss(theta):
x_star = logreg_solver(init_x, theta) # inner solution
scores = jnp.dot(X_tr, x_star)
return jnp.mean(logloss(y_tr, scores))
print(jax.grad(outer_loss)(theta))
Figure 11:	Code example for the dataset distillation experiment.
16
Under review as a conference paper at ICLR 2022
Molecular dynamics experiment.
energy_fn = soft_sphere_energy_fn(diameter)
init_fn, apply_fn = jax_md.minimize.fire_descent(
energy_fn, shift_fn)
x0 = random.uniform(key, (N, 2))
R0 = L * x0 # transform to physical coordinates
R = lax.fori_loop(
0, num_optimization_steps,
body_fun=lambda t, state: apply_fn(state, t=t),
init_val=init_fn(R0)).position
x_star = R / L
def F(x, diameter): # normalized forces
energy_fn = soft_sphere_energy_fn(diameter)
normalized_energy_fn = lambda x: energy_fn(L * x)
return -jax.grad(normalized_energy_fn)(x)
dx = root_jvp(F, x_star, diameter, 1.0,
solve=linear_solve.solve_bicgstab)
print(dx)
Figure 12:	Code for the molecular dynamics experiment.
B	Jacob ian products
Our library provides numerous reusable building blocks. We describe in this section how to compute
their Jacobian products. As a general guideline, whenever a projection enjoys a closed form, we leave
the Jacobian product to the autodiff system.
B.1	Jacobian products of projections
We describe in this section how to compute the Jacobian products of the projections (in the Euclidean
and KL senses) onto various convex sets. When the convex set does not depend on any variable, we
simply denote it C instead of C(θ).
Non-negative orthant. When C is the non-negative orthant, C = Rd+, we obtain projC (y) =
max(y, 0), where the maximum is evaluated element-wise. This is also known as the ReLu function.
The projection in the KL sense reduces to the exponential function, Projg (y) = exp(y).
Box constraints. When C(θ) is the box constraints C(θ) = [θ1, θ2]d with θ ∈ R2, we obtain
projC(y,θ) = clip(y, θ1, θ2) := max(min(y, θ2), θ1).
This is trivially extended to support different boxes for each coordinate, in which case θ ∈ Rd×2 .
Probability simplex. When C is the standard probability simplex, C = 4d, there is no analytical
solution for projC(y). Nevertheless, the projection can be computed exactly in O(d) expected time
or O(dlogd) worst-case time (Brucker, 1984; Michelot, 1986; Duchi et al., 2008; Condat, 2016).
The Jacobian is given by diag(s) - ss>/ksk1, where s ∈ {0, 1}d is a vector indicating the support
ofprojC(y) (Martins & Astudillo, 2016). The projection in the KL sense, on the other hand, enjoys a
closed form: it reduces to the usual softmax projCg (y) = exp(y)/ Pjd=1 exp(yj ).
17
Under review as a conference paper at ICLR 2022
Box sections. Consider now the Euclidean projection z?(θ) = projc(y, θ) onto the set C(θ)=
{z ∈ Rd : αi ≤ zi ≤ βi, i ∈ [d]; w>z = c}, where θ = (α, β, w, c). This projection is a singly-
constrained bounded quadratic program. It is easy to check (see, e.g., (Niculae & Martins, 2020))
that an optimal solution satisfies for all i ∈ [d]
z;(θ) = [L(x*(θ), θ)]i := clip(wix?(θ) + yi, a βi)
where L: R X Rn → Rd is the dual-primal mapping and x?(θ) ∈ R is the optimal dual variable of
the linear constraint, which should be the root of
F(x*(θ),θ) = L(x*(θ), θ)>w — c.
The root can be found, e.g., by bisection. The gradient Vx?(θ) is given by Vx?(θ) = B>∕A and the
Jacobian ∂z？(θ) is obtained by application of the chain rule on L.
Norm balls. When C(θ) = {x ∈ Rd: ∣∣χk ≤ θ}, where k ∙ k is a norm and θ ∈ R+, projc(y,θ)
becomes the projection onto a norm ball. The projection onto the `1 -ball reduces to a projection
onto the simplex, see, e.g., (DUchi et al., 2008). The projections onto the '2 and '∞ balls enjoy
a closed-form, see, e.g., (Parikh & Boyd, 2014, §6.5). Since they rely on simple composition of
fUnctions, all three projections can therefore be aUtomatically differentiated.
Affine sets. When C(θ) = {x ∈ Rd : Ax = b}, where A ∈ Rp×d, b ∈ Rp and θ = (A, b), we get
projc (y, θ) = y — At(Ay — b) = y — A>(AA>)-1(Ay — b)
where At is the Moore-Penrose pseudoinverse of A. The second equality holds if p < d and A is
full rank. A practical implementation can pre-compute a factorization of the Gram matrix AA> .
Alternatively, we can also use the KKT conditions.
Hyperplanes and half spaces. When C(θ) = {x ∈ Rd : a>x = b}, where a ∈ Rd and b ∈ R and
θ = (a, b), we get
projc(y,θ) = y - a∣∣y- ba.
∣a∣2
When C(θ) = {x ∈ Rd : a>x ≤ b}, we simply replace a>y - b in the numerator by max(a>y - b, 0).
Transportation and Birkhoff polytopes. When C(θ) = {X ∈ Rp×d : X1d = θ1, X>1p =
θ2, X ≥ 0}, the so-called transportation polytope, where θ1 ∈ 4p and θ2 ∈ 4d are marginals, we
can compute approximately the projections, both in the Euclidean and KL senses, by switching to
the dual or semi-dual (Blondel et al., 2018). Since both are unconstrained optimization problems,
we can compute their Jacobian product by implicit differentiation using the gradient descent fixed
point. An advantage of the KL geometry here is that we can use Sinkhorn (Cuturi, 2013), which is a
GPU-friendly algorithm. The Birkhoff polytope, the set of doubly stochastic matrices, is obtained by
fixing θ1 = θ2 = 1d/d.
Order simplex. When C(θ) = {x ∈ Rd: θι ≥ xι ≥ x2 ≥ …≥ Xd ≥ θ2}, a so-called
order simplex (Grotzinger & Witzgall, 1984; Blondel, 2019), the projection operations, both in the
Euclidean and KL sense, reduce to isotonic optimization (Lim & Wright, 2016) and can be solved
exactly in O(d log d) time using the Pool Adjacent Violators algorithm (Best et al., 2000). The
Jacobian of the projections and efficient product with it are derived in (Djolonga & Krause, 2017;
Blondel et al., 2020).
Polyhedra. More generally, we can consider polyhedra, i.e., sets of the form C(θ) = {x ∈
Rd : Ax = b, Cx ≤ d}, where A ∈ Rp×d, b ∈ Rp, C ∈ Rm×d, and d ∈ Rm. There are several
ways to differentiate this projection. The first is to use the KKT conditions as detailed in §2.2. A
second way is consider the dual of the projection instead, which is the maximization of a quadratic
function subject to non-negative constraints (Parikh & Boyd, 2014, §6.2). That is, we can reduce
the projection on a polyhedron to a problem of the form (8) with non-negative constraints, which we
can in turn implicitly differentiate easily using the projected gradient fixed point, combined with the
projection on the non-negative orthant. Finally, we apply the dual-primal mapping , which enjoys a
closed form and is therefore amenable to autodiff, to obtain the primal projection.
18
Under review as a conference paper at ICLR 2022
B.2	Jacobian products of proximity operators
We provide several proximity operators, including for the lasso (soft thresholding), elastic net and
group lasso (block soft thresholding). All satisfy closed form expressions and can be differentiated
automatically via autodiff. For more advanced proximity operators, which do not enjoy a closed form,
recent works have derived their Jacobians. The Jacobians of fused lasso and OSCAR were derived in
(Niculae & Blondel, 2017). For general total variation, the Jacobians were derived in (Vaiter et al.,
2013; Cherkaoui et al., 2020).
C More examples of optimality criteria and fixed points
To demonstrate the generality of our approach, we describe in this section more optimality mapping
F or fixed point iteration T .
Newton fixed point. Let X be a root of G(∙, θ), i.e., G(χ, θ) = 0. The fixed point iteration of
Newton’s method for root-finding is
T(x,θ) =x - η[∂1G(x, θ)]-1G(x, θ).
By the chain and product rules, we have
∂1T (x, θ) = I - η(...)G(x, θ) - η[∂1G(x, θ)]-1∂1G(x, θ) = (1 - η)I.
Using (3), we get A = -∂1 F (x, θ) = ηI. Similarly,
B = ∂2T(x,θ) = ∂2F (x, θ) = -η[∂1G(x, θ)]-1∂2G(x, θ).
Newton’s method for optimization is obtained by choosing G(x, θ) = V1f (x,θ), which gives
T(x,θ) = x — η[V2f (x, θ)]-1 Vif (x,θ).	(14)
It is easy to check that we recover the same linear system as for the gradient descent fixed point
(5). A practical implementation can pre-compute an LU decomposition of ∂1G(x, θ), or a Cholesky
decomposition if ∂1G(x, θ) is positive semi-definite.
Proximal block coordinate descent fixed point. We now consider the case when x? (θ) is implicitly
defined as the solution
m
x*(θ):= argmin f (x,θ) + Mgi(Xi,θ),
where g1, . . . , gm are possibly non-smooth functions operating on subvectors (blocks) x1, . . . , xm of
X. In this case, we can use for i ∈ [m] the fixed point
Xi = [T(X, θ)]i = proxηigi(Xi - ηi[V1f(X, θ)]i, θ),	(15)
where η1 , . . . , ηm are block-wise step sizes. Clearly, when the step sizes are shared, i.e., η1 =
…=ηm = η, this fixed point is equivalent to the proximal gradient fixed point (7) with g(x, θ)=
Pin=1 gi(Xi, θ).
Quadratic programming. We now show how to use the KKT conditions discussed in §2.2 to
differentiate quadratic programs, recovering Optnet (Amos & Kolter, 2017) as a special case. To give
some intuition, let us start with a simple equality-constrained quadratic program (QP)
argmin f (z,θ) = ；z>Qz + c>z subject to H(z,θ) = Ez 一 d = 0,
where Q ∈ Rp×p, E ∈ Rq×p, d ∈ Rq. We gather the differentiable parameters as θ = (Q, E, c, d).
The stationarity and primal feasibility conditions give
V1f(z, θ) + [∂1H(z,θ)]>ν=Qz+c+E>ν=0
H(z, θ) = Ez 一 d = 0.
19
Under review as a conference paper at ICLR 2022
In matrix notation, this can be rewritten as
Q E>
E0
z -c
ν= d
(16)
We can write the solution of the linear system (16) as the root x = (z, ν) of a function F(x, θ). More
generally, the QP can also include inequality constraints
argmin f(z,θ) = gz>Qz + c>z subject to H(z,θ) = Ez — d = 0,G(z,θ) = Mz - h ≤ 0.
where M ∈ Rr×p and h ∈ Rr. We gather the differentiable parameters as θ = (Q, E, M, c, d, h).
The stationarity, primal feasibility and complementary slackness conditions give
▽if (z,θ) + [∂ιH (z,θ)]>ν + [∂ιG(z,θ)]> λ = Qz + C + E > V + M >λ = 0
H(z, θ) = Ez - d = 0
λ ◦ G(z, θ) = diag(λ)(M z - h) = 0
In matrix notation, this can be written as
- Q	E>	M>[「z]	「-c "
E	0	0	ν= d
diag(λ)M	0	0	λ	λ ◦ h
While x = (z, ν, λ) is no longer the solution of a linear system, it is the root of a function F (x, θ)
and therefore fits our framework. With our framework, no derivation is needed. We simply define f,
H and G directly in Python.
Conic programming. We now show that the differentiation of conic linear programs (Agrawal
et al., 2019b; Amos, 2019), at the heart of differentiating through cvxpy layers (Agrawal et al., 2019a),
easily fits our framework. Consider the problem
z*(λ), s*(λ) = argmin c>z subject to Ez + S = d,s ∈ K,	(17)
z∈Rp,s∈Rm
where λ = (c, E, d), E ∈ Rm×p, d ∈ Rm, c ∈ Rp and K ⊆ Rm is a cone; z and s are the primal
and slack variables, respectively. Every convex optimization problem can be reduced to the form (17).
Let us form the skew-symmetric matrix
0	E >	c
θ(λ) =	-E	0	d ∈ RN×N,
-c>	-d>	0
where N = p+m+1. Following (Agrawal et al., 2019b;a; Amos, 2019), we can use the homogeneous
self-dual embedding to reduce the process of solving (17) to finding a root of the residual map
F(x, θ) = θΠx + Π*x = ((θ - I)Π + I)x,	(18)
where Π = ProjRp×k* ×r+ and K ⊆ Rm is the dual cone. The splitting conic solver (O'DonoghUe
et al., 2016), which is based on ADMM, outputs a solution F(χ?(θ), θ) = 0 which is decomposed as
x*(θ) = (u*(θ), v*(θ), w*(θ)). We can then recover the optimal solution of (17) using
z*(λ) = u*(θ(λ)) and s*(λ) = PrOjk* (v*(θ(λ))) - v*(θ(λ)).
The key oracle whose JVP/VJP we need is therefore Π, which is studied in (Ali et al., 2017). The
projection onto a few cones is available in our library and can be used to express F .
Frank-Wolfe. We now consider
x? (θ) = argmin f(x, θ),	(19)
x∈C(θ)⊂Rd
where C(θ) is a convex polytope, i.e., it is the convex hull of vertices v1(θ), . . . , vm(θ). The Frank-
Wolfe algorithm requires a linear minimization oracle (LMO)
s 7→ argmin hs, xi
x∈C(θ)
20
Under review as a conference paper at ICLR 2022
and is a popular algorithm when this LMO is easier to compute than the projection onto C(θ).
However, since this LMO is piecewise constant, its Jacobian is null almost everywhere. Inspired by
SparseMAP (Niculae et al., 2018), which corresponds to the case when f is a quadratic, we rewrite
(19) as
p? (θ) = argmin g(p, θ) := f (V (θ)p, θ),
p∈4m
where V (θ) is a d × m matrix gathering the vertices v1 (θ), . . . , vm (θ). We then have x? (θ) =
V (θ)p? (θ). Since we have reduced (19) to minimization over the simplex, we can use the projected
gradient fixed point to obtain
T(p*(θ), θ)= proj4m(p*(θ) - Vιg(p*(θ), θ)).
We can therefore compute the derivatives of p?(θ) by implicit differentiation and the derivatives of
x*(θ) by product rule. Frank-Wolfe implementations typically maintain the convex weights of the
vertices, which We use to get an approximation of p?(θ). Moreover, it is well-known that after t
iterations, at most t vertices are visited. We can leverage this sparsity to solve a smaller linear system.
Moreover, in practice, we only need to compute VJPs of x? (θ).
D	Jacobian precision proofs
ProofofTheorem 1. To simplify notations, we note A? := A(x?, θ) and A := A(x, θ), and similarly
for B and J. We have by definition of the Jacobian estimate function A?J? = B? and AJ = B.
Therefore we have
J(x,θ) - ∂x*(θ) = ATB - A-1B?
=ATB - A-1B? + A-1B? - A-1 B?
=AT(B - B?) +(AT- A-1)B?.
For any invertible matrices M1, M2, it holds that M1-1 - M2-1 = M1-1(M2 - M1)M2-1, so
kM2-1 -M2-1kop ≤ kM1-1kopkM2 -M1kopkM2-1kop.
Therefore,
kA-1 - A-Ikop ≤g|A - A?kop ≤ 皆 kx - x*(θ)k .
α2	α2
As a consequence, the second term in J(X, θ) - ∂x? (θ) can be upper bounded and we obtain
kJ(x,θ) - ∂χ?(θ)k ≤ kA-1(B - B?)k + k(A-1 - A-1)B*k
≤kA-1kop kB - B?k + α kx -x*(θ)kkB*k,
which yields the desired result.	□
Corollary 1 (Jacobian precision for gradient descent fixed point). Let f be such that f (∙,θ) is
twice differentiable and α-strongly convex and V2f (∙, θ) is Y-Lipschitz (in the operator norm) and
∂2V1f (x, θ) is β-Lipschitz and bounded in norm by R. The estimated Jacobian evaluated at X is
then given by
J (X,θ) = -(V2f (x,θ))-1∂2V1f (X,θ).
For all θ ∈ Rn, and any X estimating x?(θ), we have the following bound for the approximation
error of the estimated Jacobian
kJ (χ,θ) - ∂χ*(θ)∣∣ ≤ (α+YR) kχ - χ*(θ)k.
ProofofCorollary 1. This follows from Theorem 1, applied to this specific A(x, θ) and B(x, θ). □
For proximal gradient descent, where T(x, θ) = proxηg(x - ηV1f(x, θ), θ), this yields
A(x, θ) =I-∂1T(x,θ) = I - ∂1proxηg(x - ηV1f(x, θ), θ)(I - ηV21f(x, θ))
B(x, θ) = ∂2 proxηg (x - ηV1f(x, θ), θ) - η∂1proxηg (x - ηV1f (x, θ), θ)∂2V1f (x, θ) .
21
Under review as a conference paper at ICLR 2022
We now focus in the case of proximal gradient descent on an objective f (x, θ) + g(x), where g is
smooth and does not depend on θ. This is the case in our experiments in §4.3. Recent work also
exploits local smoothness of solutions to derive similar bounds (Bertrand et al., 2021, Theorem 13)
Corollary 2 (Jacobian precision for proximal gradient descent fixed point). Let f be such that
f (∙,θ) is twice differentiable and α-strongly convex and V2 f (∙,θ) is Y-LipSChitz (in the operator
norm) and ∂2 Vf (x,θ) is β-Lipschitz and bounded in norm by R. Let g : Rd → R be a twice-
differentiable μ-strongly convex (with special case μ = 0 being only convex), for which thefunction
Γη (x, θ) = V2g(proxηg(x-ηV1f(x, θ)) is κη -Lipschitz in it first argument. The estimated Jacobian
evaluated at X is then given by
J(X,θ) = -(Vlf (X,θ) + Γη(X,θ))-1∂2V1f (X,θ).
For all θ ∈ Rn, and any X estimating x?(θ), we have the following bound for the approximation
error of the estimated Jacobian
kJ(X,θ) - ∂χ*(θ)k ≤ (β+κη + TJYR^) kX - X*(θ)k.
a + μ	(α + μ)2 )
Proof of Corollary 2. First, let us note that proxηg(y, θ) does not depend on θ, since g itself does not
depend on θ, and is therefore equal to classical proximity operator of ηg which, with a slight overload
of notations, we denote as proxηg(y) (with a single argument). In other words,
(proxηg (y,θ)	= Proxηg (y),
∂1proxηg (y, θ) = ∂proxηg(y),
(∂2pr0Xηg (y,θ) = 0 .
Regarding the first claim (expression of the estimated Jacobian evaluated at X), We first have that
proxηg (y) is the solution to (X0 - y) + ηVg(X0) = 0 in X0 - by first-order condition for a smooth
convex function. We therefore have that
proxηg(y) = (I + ηVg)-1(y)
∂proxηg(y) = (Id + ηV2g(proxηg(y)))-1,
the first I and inverse being functional identity and inverse, and the second Id and inverse being in
the matrix sense, by inverse rule for Jacobians ∂h(z) = [∂h-1(h(z))]-1 (applied to the prox).
As a consequence, We have, for Γη(X, θ) = V2g(proxηg (X - ηV1f (X, θ)) that
A(X, θ) = Id - (Id + ηΓη(X, θ))-1(Id - ηV21f (X, θ))
= (Id + ηΓη(X, θ))-1[Id + ηΓη(X, θ) - (Id - ηV12f (X, θ))]
= η(Id + ηΓη(X, θ))-1(V12f (X, θ) + Γη(X,θ))
B(X, θ) = -η(Id + ηΓη(X, θ))-1∂2V1f (X, θ) .
As a consequence, for all X ∈ Rd, We have that
J(X, θ) =-(V12f(X,θ)+Γη(X,θ))-1∂2V1f(X,θ).
In the folloWing, We modify slightly the notation of both A and B , Writing
A(x,θ) = V2f (x, θ)+Γη (x, θ)
~ . . .
B(x,θ) = -∂2V1f(x, θ).
With the current hypotheses, following along the proof of Theorem 1, we have that A is (α + μ)
well-conditioned, and (γ + κ)-Lipschitz in its first argument, and B is β-Lipschitz in its first
argument and bounded in norm by R. The same reasoning yields
kJ(X,θ) - ∂x*(θ)k ≤ (β+κη + -^YR-2) kx - X*(θ)k.
a + μ	(α + μ)2 )
□
22
Under review as a conference paper at ICLR 2022
Figure 13: GPU runtime comparison of implicit differentiation and unrolling for hyperparameter
optimization of multiclass SVMs for multiple problem sizes (same setting as Figure 3). Error bars
represent 90% confidence intervals. Absent data points were due to out-of-memory errors (16 GB
maximum).
(a)
Block coordinate descent (BCD)
Number of features
(b)	(c)
Figure 14: Value of the outer problem objective function (validation loss) for hyperparameter
optimization of multiclass SVMs for multiple problem sizes (same setting as Figure 3). As can
be seen, all methods performed similarly in terms of validation loss. This confirms that the faster
runtimes for implicit differentiation compared to unrolling shown in Figure 3 (CPU) and Figure 13
(GPU) are not at the cost of worse validation loss.
0,0∙
1 1
=(,flsLX=
IO-I	10»	IO1
∖∖X*(Θ)-X∖∖2
(a) 250 features
*°,
=≡.,ifl≡LX=
10^1	10»	IO1
l∣χ*(θ)-χ∣∣2
(b) 500 features
0,0∙
1 1
=s.,ifl≡LX=
UJ-I	10»	IO1
lkt(β) -χ∣∣2
(c) 1000 features
Figure 15: Jacobian error ∣∣∂x*(θ) - J(X, θ)∣∣2 (see also Definition 1) evaluated with a regularization
parameter of θ = 1, as a function of solution error ∣∣χ*(θ) - X∣∣2 when varying the number of features,
on the multiclass SVM task (see Appendix E.1 for a detailed description of the experimental setup).
The ground-truth solution x?(θ) is computed using the liblinear solver (Fan et al., 2008) available in
scikit-learn (Pedregosa et al., 2011) with a very low tolerance of 10-9. Unlike in Figure 2, which
was on ridge regression, the ground-truth Jacobian ∂x? (θ) cannot be computed in closed form, in
the more difficult setting of multiclass SVMs. We therefore use a finite difference to approximately
compute ∂x？(θ). Our results nevertheless confirm similar trends as in Figure 2.
23
Under review as a conference paper at ICLR 2022
E Experimental setup and additional results
Our experiments use JAX (Bradbury et al., 2018), which is Apache2-licensed and scikit-learn
(Pedregosa et al., 2011), which is BSD-licensed.
E.1 Hyperparameter optimization of multiclass SVMs
Experimental setup. Synthetic datasets were generated using scikit-learn’s
sklearn.datasets.make_classification (Pedregosa et al., 2011), following a
model adapted from (Guyon, 2003). All datasets consist of m = 700 training samples belonging to
k = 5 distinct classes. To simulate problems of different sizes, the number of features is varied as
p ∈ {100, 250, 500, 750, 1000, 2000, 3000, 4000, 5000, 7500, 10000}, with 10% of features being
informative and the rest random noise. In all cases, an additional mval = 200 validation samples
were generated from the same model to define the outer problem.
For the inner problem, we employed three different solvers: (i) mirror descent, (ii) (accelerated)
proximal gradient descent and (iii) block coordinate descent. Hyperparameters for all solvers were
individually tuned manually to ensure convergence across the range of problem sizes. For mirror
descent, a stepsize of 1.0 was used for the first 100 steps, following a inverse square root decay
afterwards UP to a total of 2500 steps. For proximal gradient descent, a stepsize of 5 ∙ 10-4 was used
for 2500 steps. The block coordinate descent solver was run for 500 iterations. All solvers used the
same initialization, namely, Xinit = 11m×k, which satisfies the dual constraints.
For the outer problem, gradient descent was used with a stepsize of 5 ∙ 10-3 for the first 100 steps,
following a inverse square root decay afterwards up to a total of 150 steps.
Conjugate gradient was used to solve the linear systems in implicit differentiation for at most 2500
iterations.
All results reported pertaining CPU runtimes were obtained using an internal compute cluster. GPU
results were obtained using a single NVIDIA P100 GPU with 16GB of memory per dataset. For each
dataset size, we report the average runtime of an individual iteration in the outer problem, alongside a
90% confidence interval estimated from the corresponding 150 runtime values.
Additional results Figure 13 compares the runtime of implicit differentiation and unrolling on
GPU. These results highlight a fundamental limitation of the unrolling approach in memory-limited
systems such as accelerators, as the inner solver suffered from out-of-memory errors for most problem
sizes (p ≥ 2000 for mirror descent, p ≥ 750 for proximal gradient and block coordinate descent).
While it might be possible to ameliorate this limitation by reducing the maximum number of iterations
in the inner solver, doing so might lead to additional challenges (Wu et al., 2018) and require careful
tuning.
Figure 14 depicts the validation loss (value of the outer problem objective function) at convergence. It
shows that all approaches were able to solve the outer problem, with solutions produced by different
approaches being qualitatively indistinguishable from each other across the range of problem sizes
considered.
Figure 15 shows the Jacobian error achieved as a function of the solution error, when varying the
number of features.
E.2 Task-driven dictionary learning
We downloaded from http://acgt.cs.tau.ac.il/multi_omic_benchmark/
download.html a set of breast cancer gene expression data together with survival information
generated by the TCGA Research Network (https://www.cancer.gov/tcga) and processed
as explained by (Rappoport & Shamir, 2018). The gene expression matrix contains the expression
value for p=20,531 genes in m=1,212 samples, from which we keep only the primary tumors
(m=1,093). From the survival information, we select the patients who survived at least five years
after diagnosis (m1 = 200), and the patients who died before five years (m0 = 99), resulting in a
cohort of m = 299 patients with gene expression and binary label. Note that non-selected patients
are those who are marked as alive but were not followed for 5 years.
24
Under review as a conference paper at ICLR 2022
To evaluate different binary classification methods on this cohort, we repeated 10 times a random split
of the full cohort into a training (60%), validation (20%) and test (20%) sets. For each split and each
method, 1) the method is trained with different parameters on the training set, 2) the parameter that
maximizes the classification AUC on the validation set is selected, 3) the method is then re-trained on
the union of the training and validation sets with the selected parameter, and 4) we measure the AUC
of that model on the test set. We then report, for each method, the mean test AUC over the 10 repeats,
together with a 95% confidence interval defined a mean ± 1.96 × standard error of the mean.
We used Scikit Learn’s implementation of logistic regression regularized by `1 (lasso)
and `2 (ridge) penalty from sklearn.linear_model.LogisticRegression, and
varied the C regularization parameter over a grid of 10 values: {10-5, 10-3, . . . , 104}.
For the unsupervised dictionary learning experiment method, we estimated a dic-
tionary from the gene expression data in the training and validation sets, us-
ing	sklearn.decomposition.DictionaryLearning(n_components=10,
alpha=2.0), which produces sparse codes in k = 10 dimensions with roughly 50%
nonzero coefficients by minimizing the squared Frobenius reconstruction distance with lasso
regularization on the code. We then use sklearn.linear_model.LogisticRegression
to train a logistic regression on the codes, varying the ridge regularization parameter C over a grid of
10 values {10-1, 100, . . . , 108}.
Finally, we implemented the task-driven dictionary learning model (13) with our toolbox, following
the pseudo-code in Figure 10. Like for the unsupervised dictionary learning experiment, we set the
dimension of the codes to k = 10, and a fixed elastic net regularization on the inner optimization
problem to ensure that the codes have roughly 50% sparsity. For the outer optimization problem, we
solve an `2 regularized ridge regression problem, varying again the ridge regularization parameter
C over a grid of 10 values {10-1, 100, . . . , 108}. Because the outer problem is non-convex, we
minimize it using the Adam optimizer (Kingma & Ba, 2014) with default parameters.
E.3 Dataset Distillation
Experimental setup. For the inner problem, we used gradient descent with backtracking line-
search, while for the outer problem we used gradient descent with momentum and a fixed step-size.
The momentum parameter was set to 0.9 while the step-size was set to 1.
Figure 4 was produced after 4000 iterations of the outer loop on CPU (Intel(R) Xeon(R) Platinum
P-8136 CPU @ 2.00GHz), which took 1h55. Unrolled differentiation took instead 8h:05 (4 times
more) to run the same number of iterations. As can be seen in Figure 16, the output is the same in
both approaches.
Dataset Distillation (MNIST). Generalization Accuracy: 0.8556
Figure 16: Distilled MNIST dataset θ ∈ Rk×p obtained by solving (12) through unrolled differen-
tiation. Although there is no qualitative difference, the implicit differentiation approach is 4 times
faster.
E.4 Molecular dynamics
Our experimental setup is adapted from the JAX-MD example notebook available at
https://github.com/google/jax-md/blob/master/notebooks/meta_
optimization.ipynb.
We emphasize that calculating the gradient of the total energy objective, f(x, θ) = Pij U (xi,j, θ),
with respect to the diameter θ of the smaller particles, Vif (x, θ), does not require implicit differenti-
ation or unrolling. This is because Vif (x, θ) = 0 at X = χ*(θ):
Vθf (x*(θ), θ) = ∂x*(θ)>Vif (x*(θ),θ) + V2f (x*(θ),θ) = V2f (x*(θ), θ).
25
Under review as a conference paper at ICLR 2022
This is known as Danskin’s theorem or envelope theorem. Thus instead, we consider sensitivities of
position ∂x? (θ) directly, which does require implicit differentiation or unrolling.
Our results comparing implicit and unrolled differentiation for calculating the sensitivity of position
are shown in Figure 17. We use BiCGSTAB (Vorst & van der Vorst, 1992) to perform the tangent linear
solve. Like in the original JAX-MD experiment, we use k = 128 particles in m = 2 dimensions.
Unrolled FIRE optimizer
Implicit differentiation
ULIoU AU ①一 praJO
3 2 10
Oooo
0	500	1000	1500	2000 0	500	1000	1500	2000
Number of optimization steps	Number of optimization steps
Figure 17: L1 norm of position sensitivities in the molecular dynamics simulations, for 40 dif-
ferent random initial conditions (different colored lines). Gradients through the unrolled FIRE
optimizer (Bitzek et al., 2006) for many initial conditions do not converge, in contrast to implicit
differentiation.
26