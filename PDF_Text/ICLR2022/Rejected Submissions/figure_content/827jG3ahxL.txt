Figure 1: In (a) and (b), we show proof tree visualizations of the theorem a1i and mp1i. Each nodecontains two pieces of information: N refers to the the name associated with the node, and PROPrefers to the proved proposition that is obtained by applying all theorem applications above that node.
Figure 2: Number of theorems Vs number of occurrences in entire dataset (a) and test set (b). Both (a)and (b) show noticeable occurrence imbalance with (b) being less due to our further subsampling of amaximum 10 occurrence. (c) Distribution of number of nodes in new theorems extracted. The modelmostly extracts short theorems but is also capable of extracting theorems that have hundreds of nodes.
Figure 3: A proof tree prediction where nodes with output probability greater than 0.5 have beencolored blue. This proof tree does not satisfy the constraint to be a valid theorem because only one ofthe parent nodes of the root are predicted to be in Vtarget .
Figure 4:	Visualization of theorem verification algorithm.
Figure 5:	An example prediction that fails to be extracted as a new theorem due to no valid substitutionplan in standardization. Specifically, the blue node wi cannot be substituted to a basic argumentallowed in Metamath while still keeping the proof tree valid.
Figure 6:	Visualization of a single refactoring operation. The theorem imim2i to be refactored isshown in (a), the new theorem used for refactoring is shown in (b) and imim2i after refactoring isshown in (c).
Figure 7:	Top 10 most frequently used theorems in refactoring.
Figure 8: Top 10 most frequently used theorems in theorem proving.
