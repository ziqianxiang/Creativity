Under review as a conference paper at ICLR 2018
Deep Function Machines: Generalized Neural
Networks for Topological Layer Expression
Anonymous authors
Paper under double-blind review
Ab stract
In this paper we propose a generalization of deep neural networks called deep func-
tion machines (DFMs). DFMs act on vector spaces of arbitrary (possibly infinite)
dimension and we show that a family of DFMs are invariant to the dimension of
input data; that is, the parameterization of the model does not directly hinge on
the quality of the input (eg. high resolution images). Using this generalization we
provide a new theory of universal approximation of bounded non-linear operators
between function spaces. We then suggest that DFMs provide an expressive frame-
work for designing new neural network layer types with topological considerations
in mind. Finally, we introduce a novel architecture, RippLeNet, for resolution
invariant computer vision, which empirically achieves state of the art invariance.
1	Introduction
In recent years, deep learning has radically transformed a majority of approaches to computer
vision, reinforcement learning, and generative models [Schmidhuber (2015)]. Theoretically, we
still lack a unified description of what computational mechanisms have made these deeper models
more successful than their wider counterparts. Substantial analysis by Shalev-Shwartz et al. (2011),
Raghu et al. (2016), Poole et al. (2016) and many others gives insight into how the properties of
neural architectures, like depth and weight sharing, determine the expressivity of those architectures.
However, less studied is the how the properties of data, such as sample statistics or geometric
structure, determine the architectures which are most expressive on that data.
Surprisingly, the latter perspective leads to simple questions without answers rooted in theory. For
example, what topological properties of images allow convolutional layers such expressivity and
generalizeability thereon? Intuitively, spatial locality and translation invariance are sufficient justifi-
cations in practice, but is there a more general theory which suggests the optimality of convolutions?
Furthermore, do there exist weight sharing schemes beyond convolutions and fully connected layers
that give rise to provably more expressive models in practice? In this paper, we will more concretely
study the data-architecture relationship and develop a theoretical framework for creating layers and
architectures with provable properties subject to topological and geometric constraints imposed on
the data.
The Problem with Resolution. To motivate a use for such a framework, we consider the problem
of learning on high resolution data. Computationally, machine learning deals with discrete data,
but frequently this data is sampled from a continuous process. For example, audio is inherently
a continuous function f : [0, tend] → R, but is sampled as a vector v ∈ R44,100×t . Even in
vision, images are generally piecewise smooth functions f : R2 → R3, but are sampled as tensors
v ∈ Rx×y×c . Performing tractible machine learning as the resolution of data of this type almost
always requires some lossy preprocessing like PCA or Discrete Fourier Analysis [Burch (2001)].
Convolutional neural networks avoid dealing therein by intutively assuming a spacial locality on
these vectors. However, one wonders what is lost through the use of various dimensionality reduction
and weight sharing schemes1 .
1Note we do not claim that deep learning on high resolution data is currently intractible or ineffective. The
problem of resolution is presented as an example in which topological constaints can be imposed on a type of
data to yield new architecutres with desired, provable properties.
1
Under review as a conference paper at ICLR 2018
Figure 1: Left: A discrete vector v ∈ Rl×w representation of an image. Right: The true continuous
function f : R2 → R from which it was sampled.
A key observation in discussing a large class of smooth functions is their simplicity. Although from
a set theoretic perspective, the graph of a function consists of infiniteley many points, relatively
complex algebras of functions can be described with symbolic simplicity. A great example are
polynomials: the space of all square (x2) mononomials occupies a one-dimensional vector space, and
one can generalize this phenomena beyond these basic families. Thus we will explore what results in
embracing the assumption that a signal is really a sample from a continuous process, and utilize the
analytic simplicity of certain smooth functions to derive new layer types.
Our Contribution. First, we extend neural networks to the infinite dimensional domain of continu-
ous functions and define deep function machines (DFMs), a general family of function approximators
which encapsolates this continuous relaxation and its discrete counterpart. Thereafer, we survey and
refocus past analysis of neural networks with infinitely (and potentially uncountably) many nodes2
with respect to the expresiveness the maps that they represent. We show that DFMs not only admit
most other infinite dimensional neural network generalizations in the literature but also provide the
necessary language to solve two long standing questions of universal approximation raised following
Stinchcombe (1999). With the framework firmly established, we then return to our motivating goal of
provable deep learning and show that DFMs naturally give rise to neural networks which are provably
invariant to the resolution of the input, and indeed that DFMs can be used more generally to construct
architectures (e.g. those with convolutions) with provable properties given topological assumptions.
Finally we experimentally verify such constructions by introducing a new type of layer, WaveLayers,
apart from convolutions.
2	Background
In order to propose deep function machines we must establish what it means for a neural network act
directly on continuous functions. Recall the standardMcCulloch & Pitts (1943) feed-forward neural
network.
Definition 2.1 (Discrete Neural Networks). We say N : Rn → Rm is a (discrete) feed-forward
neural network iff for the following recurrence relation is defined for adjacent layers ` → `0,
N: y'0 = g (WTy'); yo ：= X	Q∙I)
where w` is a weight tensor and g is a non-poIynomiaI activation function.
Suppose that we wish to map one space of functions to another with a neural network. Consider
the model of N as the number of neurons for every layer becomes uncountable. The index for each
neuron then becomes real-valued, along with the weight and input vectors. The process is roughly
depicted in Figure 2. The core idea behind the derivation is that as the number of nodes in the
network becomes uncountable we need apply a normalizing term to the contribution of each node
in the evaluation of the following layer so as to avoid saturation. Eventually this process resembles
Lebesgue integration.
More formally, let N be an L layer neural network as given in Definition 2.1. Without loss of
generality we will examine the first layer, ` = 1. Let us denote ξ : X ⊂ R → R as some
2See related work.
2
Under review as a conference paper at ICLR 2018
Figure 2: Left: Resolution refinement of an input signal by simple functions. Right: An illustration
of the extension of neural networks to infinite dimensions. Note that x ∈ RN is a sample of f(N), a
simple function with kf (N) - ξk → 0 as N → ∞. Furthermore, the process is not actually countable,
as depicted here.
arbitrary continuous input function for the neural network. Likewise consider a real-valued piecewise
integrable weight function, w` : R2 → R, for a layer ` which is composed of two indexing variables3
u,v ∈ e`, E'o ⊂ R. In this analysis We Win restrict the indices to lie in compact sets E', E'.
If f is a simple function then for some finite partition of E', say u0 < ∙ ∙ ∙ < Un, then f =
Pnm=1 χ[um-1,um]pn Where for all u ∈ [um-1, um], pn ≤ ξ(u). Visually this is a pieceWise constant
function underneath the graph of ξ . Suppose that some vector x is sampled from ξ, then We can make
X a simple function by taking an arbitray parition of E' so that: when u0 < u < u1, f (U) = x0, and
When u1 < u < u2, f(u) = x1, and so on. This simple function f is essentially pieceWise constant
on intervals of uniform length so that on each interval it attains the value of the nth component, xn .
Finally if wv is some simple function approximating the v-th roW of some Weight matrix W' in the
same fashion, then Wv ∙ f is also a simple function. Therefore particular neural layer associated to f
(and thereby x) is
L Wv(u)f(u) dμ(u))
yl = g(W'x) = g ( X : WmvXmμ(IUm-I, Um])
m=1
(2.2)
where μ is the Lebesgue measure on R.
NoW suppose that there is a refinement of X; that is, returning to our original problem, there is a
higher resolution sample of ξ say f0 (and thereby X0), so that it more closely approximates ξ. It then
follows that the cooresponding refined partition, u0 < …< Uk, (where k > n), occupies the same
E' but individually, μ([um-1 ,um ]) ≤ μ([um-1 ,ufm ]). Therefore we weight the contribution of each
X0n less than each Xn , in a measure theoretic sense.
Recalling the theory of simple functions without loss of generality assume ξ,ω(∙, ∙) ≥ 0. Then we
yield that if
Fv = {(wv, f) ： E' → R | f, wv simple, 0 ≤ f ≤ ξ, 0 ≤ Wv ≤ ω(∙, V)}
then it follows immediately that
sup
(f,wv )∈Fv
Wv (U)f (U)
dμ(U) = /
je`
ω'(u, v)ξ(u) dμ(U).
(2.3)
(2.4)
L
Therefore we give the following definition for infinite dimensional neural networks.
Definition 2.2 (Operator Neural Networks). We call O ： L1 (E') → L1 (E'0 ) an operator neural
network parameterized by ω' if for two adjacent layers ` → `0
O ： y'0(v) = g	y'(U)ω'(U,v)
e`
; y0(v) = ξ(v).
(2.5)
where E' , E'0 are locally compact Hausdorff mesure spaces and U ∈ X, v ∈ Y.
3It is no loss of generality to extend the results in this work to weight kernels indexed by arbitrary u, v ∈ Rn ,
but we ommit this treatment for ease of understanding.
3
Under review as a conference paper at ICLR 2018
3 Deep Function Machines
With operator neural networks defined, we endeavour to define a topologically inspired framework
for developing expressive layer types. A powerful language of abstraction for describing feed-
forward (and potentially recurrent) neural network architectures is that of computational skeletons as
introduced in Daniely et al. (2016). Recall the following definition.
Definition 3.1. A computational skeleton S is a directed asyclic graph whose non-input nodes are
labeled by activations.
Daniely et al. (2016) provides an excellent account of how these graph structures abstract the many
neural network architectures we see in practice. We will give these skeletons "flesh and skin"
so to speak, and in doing so pursure a suitable generalization of neural networks which allows
intermediate mappings between possibly infinite dimensional topological vector spaces. DFMs are
that generalization.
Definition 3.2 (Deep Function Machines). A deep function machine D is a computational skeleton
S indexed by I with the following properties:
•	Every vertex in S is a topological vector space X' where ' ∈ I.
•	Ifnodes ' ∈ A ⊂ I feed into '0 then the activation on '0 is denoted y' ∈ X' and is defined
as
y'0 = g (XT' [y'])	(3.1)
where T' : X' → X' is some affineform called the operation of node '.
To see the expressive power of this generalization, we propose several operations T' that not only
encapsulate ONNs and other abstractions on infinite dimensional neural networks, but also almost all
feed-forward architectures used in practice.
3.1	Generalized Neural Layers
Generalized neural layers are the basic units of the theory of deep function machines, and they can be
used to construct architectures of neural networks with provable properties, such as the resolution
invariance we seek. The most basic case is X' = Rn and X'0 = Rm, where we should expect a
standard neural network. As either X' or X'0 become infinite dimensional we hope to attain models
of functional MLPs from Rossi et al. (2002) or infinite layer neural networks from Globerson & Livni
(2016) with universal approximation properties.
Definition 3.3 (Generalized Layer Operations). We suggest several natural generalized layer families
T' for DFMs as follows.
•	T' is said to be o-operational if and only if X' and X'0 are spaces of integrable functions
over locally compact Hausdorff measure spaces, and
T'[y'](v) = o(y')(v) = y y'(u)ω'(u,v) dμ(u).
J e`
For example4, X', X'0 = C(R), yields operator neural networks.
(3.2)
•	T' is said to be n-discrete if and only if X' and X'0 are finite dimensional vector spaces,
and
T'[y'] = n(y') =W'Ty'.	(3.3)
For example, X' = Rn, X'0 = Rm , yields standard feed-forward neural networks.
•	T' is said to be f-functional if and only if X' is some space of integrable functions as
mentioned previously and X'0 is a finite dimensional vector space, and
T'[y'] = f(y') = ω ω'(u)y'(u) dμ(u)
je`
(3.4)
4Nothing precludes the definition from allowing multiple functions as input, the operation must just be
carried on each coordinate function.
4
Under review as a conference paper at ICLR 2018
N
n ⅛φ n ⅛φ n ⅛
∣C([-1,1])∣
o
O
Figure 3: Examples of three different deep function machines with activations ommited and T'
replaced with the actual type. Left: A standard feed forward binary classifier (without convolution),
Middle: An operator neural network. Right: A complicated DFM with residues.
For example 5 X' = C(R), X' = Rn, yieldsfunctional MLPs.
• t` is said to be d-defunctional ifand only if X' is a are finite dimensional vector space and
X' is some space Ofintegrablefunctions.
Tι[y'](v) = d(y')(V) = ω'(V)T y'	(3.5)
For example, X' = Rn, X' = C(R).
The naturality of the above layer operations come from their universality and generality.
3.2	Related Work and a Unified View of Infinite Dimensional Neural Networks
Operator neural networks are just one of many instantiations of DFMs. Before we show universality
results for deep function machines, it should be noted that there has been substantial effort in the
literature to explore various embodiments of infinite dimensional neural networks. To the best of the
authors’ knowledge, DFMs provide a single unified view of every such proposed framework to date.
In particular, Neal (1996) proposed the first analysis of neural networks with countably infinite nodes,
showing that as the number of nodes in discrete neural networks tends to infinity, they converge to a
Gaussian process prior over functions. Later, Williams (1998) provided a deeper analysis of such a
limit on neural networks. A great deal of effort was placed on analyzing covariance maps associated
to the Guassian processes resultant from infinite neural networks with both sigmoidal and Gaussian
activation functions. These results were based mostly in the framework of Bayesian learning, and led
to a great deal of analyses of the relationship between non-parametric kernel methods and infinite
networks, including Le Roux & Bengio (2007), Seeger (2004), Cho & Saul (2011), Hazan & Jaakkola
(2015), and Globerson & Livni (2016).
Out of this initial work, Hazan & Jaakkola (2015) define hidden layer infinite layer neural networks
with one or two layers which map a vector x ∈ Rn to a real value by considering infinitely many
feature maps φw(x) = g (hw, xi) where w is an index variable in Rn. Then for some weight function
U : Rn → R, the output of an infinite layer neural network is a real number J u(w) φw (x) dμ(w).
This approach can be kernelized and therefore has resulted further theory by Globerson & Livni (2016)
that aligns neural networks with Gaussian processes and kernel methods. Operatator neural networks
differ significantly in that we let each w be freely paramaterized by some function ω and require
that x be a continuous function on a locally compact Hausdorf space. Additionally no universal
approximation theory is provided for infinite layer networks directly, but is cited as following from
the work of Le Roux & Bengio (2007). As we will see, DFMs will not only encapsulate (and benefit
from) these results, but also provide a general universal approximation theory therefor.
5Note that y' (U) is a scalar function and ω is a vector valuued function of dimension dim(X'). Additionally
this definiton can easily be extended to function spaces on finite dimensional vectorspaces by using the Kronecker
product.
5
Under review as a conference paper at ICLR 2018
Table 1: Unification of Infinite Dimensional Neural Network Theory
Name	Form	DFM	Authors
InNfinite	b+p∞=ι Vjh(x； Uj)	N∞: RnE- →			→		Neal(1996); Williams (1998)
		C=IR		Rm	
Functional	p MLPs	∑2i=1 βig (J wiξ dμ)	F :					Stinchcombe
	L1(R)	→回→		回	(1999); Rossi et al. (2002) Le Roux & Bengio (2007)
					
OnnNnUOUS	Rωι(u)g(x ∙ ωo(u)) du C : ∣ Rn ∣ → J		t⅜b])	→	Rm	
Non-					Le Roux & Bengio (2007)
Conamutrus	R皿回回* d	C0: 叵 →		L1(R)	→[	Rm	
NNs Infinite	same as non-parametric	same as non-parametric Layer NNs	continuous NNs	continuous NNs					Globerson & Livni (2016); Hazan & Jaakkola (2015)
Another variant of infinite dimensional neural networks, which we hope to generalize, is the func-
tional multilayer perceptron (Functional MLP). This body of work is not referenced in any of the
aforementioned work on infinite layer neural networks, but it is clearly related. The fundamental idea
is that given some f ∈ V = C(X), where X is a locally compact Hausdorff space, there exists a
generalization of neural networks which approximates arbitrary continuous bounded functionals on
V (maps f → a ∈ R). These functional MLPs take the form PiP=i βig (ʃ ωɪ(x)f (x) dμ(x)). The
authors show the power of such an approximation using the functional analysis results of Stinchcombe
(1999) and additionally provide statistical consistency results defining well defined optimal parameter
estimation in the infinite dimensional case.
Stemming additionally from the initial work of Neal (1996), the final variant called continuous neural
networks has two manifestations: the first of which is more closely related to functional perceptrons
and the last of which is exactly the formulation of infintie layer NNs. Initially Le Roux & Bengio
(2007) proposes an infinite dimensional neural network of the form / ωι(u)g(x ∙ ω0 (U)) dμ(u) and
shows universal approximation in this regime. Overall this formulation mimics multiplication by
some weighting vector as in infinite layer NNs, except in the continuous neural formulation ω0 can be
parameterized by a set of weights. Thereafter, to prove connections between gaussian processes from
a different vantage, they propose non-parametric continuous neural networks, / ωι(u)g(x ∙ U) dμ(u),
which are exactly infinite-layer neural networks.
In the view of deep function machines, the foregoing variants of infinite and semi-infinite dimensional
neural networks are merely instantiations of different computational skeleton structures. A summary
of the unified view is given in Table 1.
3.3	Approximation Theory of Deep Function Machines
In addition to unification, DFMs provide a powerful language for proving universal approximation
theorems for neural networks of any depth and dimension6. The central theme of our approach is
that the approximation theories of any DFM can be factored through the standard approximation
theories of discrete neural networks. In the forthcoming section, this principle allows us to prove two
approximation theories which have been open questions since Stinchcombe (1999).
The classic results of Cybenko (1989), yields the theory for n-discrete layers. For f-functional
layers, the work of Stinchcombe (1999) proved in great generality that for certain topologies on
C(e`), two layer functional MLPs universally approximate any continuous functional on C(e`).
Following Stinchcombe (1999), Rossi et al. (2002) extended these results to the case wherein multiple
6By dimension, we mean both infinite and finite dimensional neural networks.
6
Under review as a conference paper at ICLR 2018
o-operational layers prepended f-functional layers. We will show in particular that o-operational and
similarly d-defunctional layers alone are dense in the much richer space of uniformly continuous
bounded operators on function space. We give three results of increasing power, but decreasing
transparency.
Theorem 3.4 (Point Approximation). Let [a, b] ⊂ R be a bounded interval andg : R → B ⊂ R be a
continuous, bijective activation function. Then if ξ : e` → R and f : E' → B are L1(μ) integrable
functions there exists a unique class of o-operational layers such that g ◦ o[ξ] = f.
Proof. We seek a class of weight kernels ωg so that that o[ξ] = f. Let ωg(u, v) =
(g-1)0 ◦ (h(Ξ(u), v)) h0(Ξ(u), v) where Ξ(u) is the indefinite integral of ξ. Define h so that
it satisfies the following two equivalent equations μ-a.e.
h(Ξ(b), v) - h(Ξ(a), v) = f(v)
dh(χ,v) ξ(u)∣	=0	(3.6)
∂x	x=Ξ(u),v=v,u∈{a,b}
The proof is completed in the appendix.	□
The statement of Theorem 3.4 is not itself very powerful; we merely claim that o-operational layers
can at least map any one function to any other one function. However, the proof yields insight
into what the weight kernels of o-operational layers look like when the single condition ξ 7→ f is
imposed. Therefrom, we conjecture but do not prove that a statstically optimal initialization for
training o-operational layers is given by satifying (3.6) when ξ = 1 Pm=I ξn, f = 1 Pm=I f„,
where the training set {(ξn , fn )} are drawn i.i.d from some distribution D.
Theorem 3.5	(Nonlinear Operator Approximation). Suppose that E1, E2 are bounded intervals in R.
For all κ, λ, if K : Lipλ (E1) → Lipκ(E3) is a uniformly continuous, nonlinear operator, then for
every > 0 there exists a deep function machine
D : L1(Eι)	L1 (E2)	L1(E3)	(3.7)
such that ∣∣D∣Lip入 一 Kll < e.
With two layer operator networks universal, it remains to consider d-deconvolutional layers.
Theorem 3.6	(Nonlinear Basis Approximation). Suppose I, E2 , E3 are compact intervals, and let
Cω (X) denote the set of analytic functions on X. If B : In → Cω(E3) is a continuous basis map to
analytic functions then for every e > 0 there exists a deep function machine
D :叵-ɪ÷ ∣L1(E2)∣ -ɪ÷ I L1 (E3)∣	(3.8)
such that kD|I n 一 Bk < e in the topology of uniform convergence.
To the best of our knowledge, the above are the first approximation theorems for nonlinear operators
and basis maps on function spaces for neural networks. The proofs in the appendix roughly involve a
factorization of arbitrary DFMs through approximation theories for n-discrete layers.
Essentially, the factorization works as follows. In both of the foregoing theorems we want to roughly
approximate some nonlinear map K with a DFM D . We therefore define an operator |K |, called an
affine projection, that takes functions, converts them into piecewise constant approximations, applies
K, and then again converts the result to piecewise constant approximations. Since there are a finite
number, say N and M, of pieces given in the input and the output of |K| respectively, we can define
an operator K : RN → RM, called a lattice map, which in some sense reproduces |K|. We then
show both Theorem 3.5 and Theorem 3.6 by approximating K with a discrete neural network, N ,
and chosing D to be such that its discreitzation is N . Surprisingly, this principle holds for any DFM
structure and a large class of different K not just those which use piecewise constant approximations!
7
Under review as a conference paper at ICLR 2018
4 Neural Topology from Topology
As we have now shown, deep function machines can express arbitrarily powerful configurations of
’perceptron layer’ mappings betwen different spaces. However, it is not yet theoretically clear how
different configurations of the ComPUtaional skeleton and the particular spaces X' do or do not lead
to a difference in expressiveness of DFMs. To answer questions of structure, we will return to the
motivating example of high-resolution data, but now in the language of deep function machines.
4.1	Resolution Invariant Neural Networks
If an an input (Xj) ∈ RN is sampled from an continuous function ξ ∈ C(e`), o-operational layers
are a natural way of extending neural networks to deal directly with ξ. As before, it is useful to think
of each o as a continuous relaxation of a class of n, and from this perspective we can gain insight into
the weight tensors of n-discrete layers as the resolution of x increases.
Theorem 4.1 (Invariance). If t` is an o-operational Iayerwith an integrable weight kernel ω(u, V) of
O(1) parameters, then there is a unique fully connected n-discrete layer, n` , with O(N) parameters
so that t`[ξ](j) = N'(x) for all ξ, X as above.
Theorem 4.1 is a statement of variance in parameterization;
when the input is a sample of a smooth signal, fully con-
nected n-discrete layers are naively overparameterized.
DFMs therefore yield a simple resolution invariance scheme
for neural networks. Instead of placing arbitrary restrictions
on w` like convolution or assuming that the gradient descent
will implicitly find a smooth weight matrix or filter We for n,
We take w` to be the discretization of a smooth ωg(u, v). An
immediate advantage is that the weight surfaces, ωg(u, v),
of o-operational layers can be parameterized by dense fam-
ilies f(u, v; w), whose parameters w do not depend on the
resolution of the input but on the complexity of the model
being learnt.
Resolution Invariance Schema
“`(U, v；W) = En=If (U, v； Wk)
l parameterization
O ： I C(E') I —o-> ∣C(E'0)
n-discrete inst.
[O]n : IRNl-----------n——> IRM I
Figure 4: DFM construction of resolu-
tion invariant n-discrete layer.
4.2	Topologically Inspired Layer Parameterizations
Furthermore, we can now explore new parameterizations by constructing weight tensors and thereby
neural network topologies which approximate the action of the operator neural networks which most
expressively fit the topological properties of the data. Generally new restrictions on the weights of
discrete neural networks might be achieved as follows:
1.	Given that the input data X is sampled from some f ∈ F ⊂ {g : E0 → R}, find a closed
algebra of weight kernels so that ω0 ∈ A0 is minimally parameterized and g ◦ o[F] is a
sufficiently "rich" class of functions.
2.	Repeat this process for each layer of a computational skeleton S and yield a DFM O.
3.	Instantiate a deep function machine [O]n called the n-discrete instatiation of O consisting
of only n-discrete layers by discretizing each o-operational layer through the resolution
invariance schema sample:
(4.1)
where en denotes the cardinality of the sample along the η-axis of e` = [0, ι]dim(Eg). ThiS
process is depicted in Figure 4.
This perspective yields interpretations of existing layer types and the creation of new ones. For
example, convolutional n-discrete layers provably approximate o-operational layers with weight
kernels that are solutions to the ultrahyperbolic partial differential equation.
8
Under review as a conference paper at ICLR 2018
Figure 5: The WaveLayer architecture of RippLeNet for MNIST. Bracketed numbers denote number
of wave coefficients. The images following each WaveLayer are the example activations of neurons
after training given by feeding 000 into RippLeNet.
Theorem 4.2 (Convolutional Neural Networks). Let N' be an n-discrete convolutional layer such
that n(x) = h ? x where ? is the convolution operator and h is a filter tensor. Then there is a
o-operational layer, θ` with ω' (u1,..., Un, v1,..., Vn) such that
XX ∂2 ω	2 XX ∂2 ω
≡ d2uk —c ≡ 西
(4.2)
and its n-discrete instatiation is [θ`]n = N'.
Using Theorem 4.2 we therefore propose the following generalization of convolutional layers with
weight kernels satisfying (4.2) whose n-discrete instantiation is resolution invariant.
Definition 4.3 (WaveLayers). We say that T' is a WaveLayer if it is the n-discrete instantiation (via
the resolution invariance schema) of an o-operational layer with weight kernel of the form
b
ω'(u, v) = s0 + ^X Si Cos(WT(u, v) — Pi); Si,pi ∈ R, wi ∈ R2dim(E').	(4.3)
i=1
WaveLayers7 are named as such, because the kernels ω' are super position standing waves moving
in directions encoded by wi , offset in phase by pi . Additionally any n-discrete convolutional layer
can be expressed by WaVeLayers, setting the direction θi of Wi to θi = π∕4. In this case, instead of
learning the values h at each j , we learn Si , wi , pi .
5 Experiments
With theoretical guarantees given for DFMs, we propose a series of experiments to test the learnability,
expressivity, and resolution invariance of WaveLayers.
RippLeNet. To find a baseline model, we performed a grid search on MNIST over various DFMs
and hyperparameters, arriving at RippLeNet, an architecture similar to the classic LeNet-5 of LeCun
et al. (1998) depicted in Figure 5. The model is the n-discrete instatiation of the following DFM
(5.1)
and consiststs of 5 successive wave layers with tanh activations and no pooling. We found that
using ReLu often resulted in a failure of learning to converge. Changes in the activation shapes
(eg. 24x24x2 → 10x10x2) are achieved merely by specifying the sample partition of E' at each
node of the DFM. The trainable parameters, in particular the magnitude of internal frequencies,
were initialized at offsets proportional to the number of waves comprising each o-operational
layer. Likewise, Orientation of each wave was initialized uniformly on the unit spherical shell.
7Note: WaveLayers are not not the same as Fourier networks or FC layers with cos activation functions. It
suffices to view wave layers as simply another way to reparameterize the weight matrix of n-discrete layers, and
therefore the VC dimension of WaveLayers is less than that of normal fully connected layers. See the appendix.
9
Under review as a conference paper at ICLR 2018
Model Expressive Parameter Reduction. In
Theorem 4.1, it was shown that DFMs in some
sense parameterize the complexity of the model
being learned, without constraints imposed by
the form of data. RippLeNet benefits in that
the sheer number of parameters (and therefore
the variance) can be reduced until the model ex-
presses the mapping to satisfactory error without
concern for resolution variants.
We emprically verify this methodology by fixing
the model architecture and increasing the num-
ber of waves per layer uniformly. This results in
an exponential marginal utility on lowest error
achieved after 80 epochs of MNIST with respect
to the number of parameters in the model, shown
in Figure 6. The slight outperformance of early
LeNet architectures, suggest that future work
in optimizing WaveLayers might be fruitful in
achieving state of the art parameter reduction.
Figure 6: A plot of test error versus number of
trainable parameters for RippLeNet in comparison
with early LeNet architectures.
」0」」山 4sφl %6。4 SUo42」① 4_ 6£uro」l PaZ--PllUON
Figure 7: A plot of training time (normalized for
each layer type with respect to the training time
for 28 × 28 baseline) as the resolution of MNIST
scales.
Resolution Invariance. True resolution invari-
ance has the desirable property of consistency.
Principly, consistency requires that regardless of
the the resolution complexity of data, the train-
ing time, paramerization, and testing accuracy
of a model do not vary.
We test consistency for RippLeNet by fixing all
aspects of initialization save for the input resolu-
tion of images. For each training run, we rescale
MNIST using both bicubic and nearest neigh-
bor scaling to square resolutions of sidelength
R = {16, . . . , 36, 38, 46, 64, . . . }. In conjuc-
tion we compare the resolution consistency of
fully connected (FC) and convolutional archi-
tectures. For FC models, the number of free
parameters on the first layer is increased out of
necessity. Likewise, the size of the input filters
for convolutional models is varied. As shown in
Figure 7, WaveLayers remain invariant to resolu-
tion changes in both multirun variance and nor-
malized convergence iterations, whereas both
FC and convolutional layers exhibit an increase
in both measurements with resolution.
6 Conclusion
In this paper we proposed deep function machines, a novel framework for topologically inspired
layer parameterization. We showed that given topological assumptions, DFMs provide theoretical
tools to yield provable properties in neural neural networks. We then used this framework to derive
WaveLayers, a new type of provably resolution invariant layer for processing data sampled from
continuous signals such as images and audio. The derivation of WaveLayers was additionally
accompanied by the proposal of several layer operations for DFMs between infinite and/or finite
dimensional vector spaces. We for the first time proved a theory of non-linear operator and functional
basis approximation for neural networks of infinite dimensions closing two long standing questions
since Stinchcombe (1999). We then utilized the expressive power of such DFMs to arrive at a novel
architecture for resolution invariant image processing, RippLeNet.
10
Under review as a conference paper at ICLR 2018
Future Work. Although we’ve layed the ground work for exploration into the theory of deep
function machines, there are still many open questions both theoretically and empirically. The
drastic outperformance in resolution variance of RippLeNet in comparision to traditional layer types
suggests that new layer types via DFMs with provable properties in mind should be further explored.
Furthermore a deeper analysis of existing global network topologies using DFMs may be useful given
their expressive power.
References
Carl Burch. A survey of machine learning. A survey for the Pennsylvania Governor’s School for the
Sciences, 2001.
Youngmin Cho and Lawrence K Saul. Analysis and extension of arc-cosine kernels for large margin
classification. arXiv preprint arXiv:1112.3712, 2011.
G. Cybenko. Approximation by superpositions of a sigmoidal function. Mathematics of Control,
Signals, and Systems, 2:303-3314,1989.
Amit Daniely, Roy Frostig, and Yoram Singer. Toward deeper understanding of neural networks: The
power of initialization and a dual view on expressivity. arXiv preprint arXiv:1602.05897, 2016.
Amir Globerson and Roi Livni. Learning infinite-layer networks: beyond the kernel trick. arXiv
preprint arXiv:1606.05316, 2016.
Tamir Hazan and Tommi Jaakkola. Steps toward deep kernel methods from infinite neural networks.
arXiv preprint arXiv:1508.05133, 2015.
Nicolas Le Roux and Yoshua Bengio. Continuous neural networks. 2007.
Yann LeCun, Leon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
Warren S McCulloch and Walter Pitts. A logical calculus of the ideas immanent in nervous activity.
The bulletin of mathematical biophysics, 5(4):115-133, 1943.
Radford M Neal. Bayesian learning for neural networks, volume 118. 1996.
Ben Poole, Subhaneil Lahiri, Maithreyi Raghu, Jascha Sohl-Dickstein, and Surya Ganguli. Ex-
ponential expressivity in deep neural networks through transient chaos. In Advances In Neural
Information Processing Systems, pp. 3360-3368, 2016.
Maithra Raghu, Ben Poole, Jon Kleinberg, Surya Ganguli, and Jascha Sohl-Dickstein. On the
expressive power of deep neural networks. arXiv preprint arXiv:1606.05336, 2016.
Fabrice Rossi, Brieuc Conan-Guez, and Frangois Fleuret. Theoretical properties of functional multi
layer perceptrons. 2002.
Jurgen Schmidhuber. Deep learning in neural networks: An overview. Neural Networks, 61:85-117,
2015.
Matthias Seeger. Gaussian processes for machine learning. International Journal of neural systems,
14(02):69-106, 2004.
Shai Shalev-Shwartz, Ohad Shamir, and Karthik Sridharan. Learning kernel-based halfspaces with
the 0-1 loss. SIAM Journal on Computing, 40(6):1623-1646, 2011.
Maxwell B Stinchcombe. Neural network approximation of continuous functionals and continuous
functions on compactifications. Neural Networks, 12(3):467-477, 1999.
Christopher KI Williams. Computation with infinite neural networks. Neural Computation, 10(5):
1203-1216, 1998.
11
Under review as a conference paper at ICLR 2018
7 Appendix A: Additional Toy Demonstration
To provide a direct comparison between convolutional, fully connected, and WaveLayer operations
on data with semicontinuity assumptions, we conducted several toy demonstrations. We construct a
dataset of functions (similar to a dataset of audio waveforms) whose input pairs are Gaussian bump
functions, Bμ(U) centered at different points in the interval μ ∈ [0,1]. The CooresPonding "labels”
or target outputs are squres of gaussian bump functions plus a linear form whose slopes are given
by the position of the center, that is Bμ(u)2 + μ(u - μ). The desired map We wish to learn is then
T : Bμ(u) → Bμ(u)2 + μ ∙ (U — μ). To construct the actual dataset D, for a random sample of
centers μ we sample the input output pairs over 100 evenly spaced sub-intervals. The resultant dataset
is a list of N pairs of input/output vectors D = {(xi, yi)}iN=1 with x, y ∈ R100.
We then train three different two layer DFMs with n-discrete convolutional, fully-connected, and
WaveLayers respectively. The following three figures show the outputs of all three layer types as
training progresses. In the first three quadrants, the output of each layer type on a particular example
datapoint is shown along with that example’s input/target functions, (xi, yi). The particular example
shown is chosen randomly at the beginning of training. In the bottom right, the log training error over
the whole dataset of each layer type is shown. A tick is the number of batches seen by the algorithm.
In initialization, the three layers exhibit predicted behavior despite artifacts towards the boundaries
of the intervals. The convolutional layer, acts as a mullifer smoothing the input signal as its own
kernel is Gaussian. The fully connected layer generates as predicted a normally distributed set of
different output activations and does not regard the spatial locality (and thereby continuity) of the
input. Finally the WaveLayer output exhibits behaviour predicted in Neal (1996), that is it limits
towards a smoothed random walk over the input signal.
As training continues, both the convolutional and WaveLayer outputs preserve the continuity of
the input signal, and approximate the smoothness of the output signal as induced by their own
relation to ultrahyperbolic differential equations. Since the FC layer is not restricted to any given
topology, although it approximates the desired output signal closely in the L2 norm, it fails to
achieve smoothness as this regularization is not explicity coded. It is important to note that in this
example the WaveLayer output immediately surpasses the accuracy of the convolutional output
because the convolutional output only has bias units accross entire channels, whereas the bias units
of WaveLayers are themselves functions P(=ι Skcos(wk ∙ V + Pk) + bk. Therefore WaveLayers
can impose hetrogenously accross their output signals, where as convolutional require much deeper
architectures to artifically generate such biases.
12
Under review as a conference paper at ICLR 2018
The results of this toy demonstration illustrate the intermediate flexibility of WaveLayers between
purely fully connected and convolutional architectures. Satisfying the same differential equation
(4.2), convolutional and WaveLayer architectures are regularized by spatial locality, but WaveLayers
can in fact go beyond convolution layers and employ translational hetrogeneity. Although the purpose
of this work is not to demonstrate the superiority of either convoluitional or WaveLayer architectures,
it does open a new avenue of exploration in neural architecture design using DFMs to design layer
types using topological constraints.
13
Under review as a conference paper at ICLR 2018
8 Appendix B: Theorems and Proofs
8.1	Point Approximation
Theorem 8.1. Let [a, b] ⊂ R be a bounded interval and g : R → B ⊂ R be a continuous, bijective
activation function. Then if ξ : e` → R and f : E' → B are L1(μ) integrable functions there exists
a unique class of o-operational layers such that g ◦ o[ξ] = f.
Proof. We will give an exact formula for the weight function ωg CooresPonding to o so that the
formula is true. Recall that
y'0(v)
g (y SI")"""，。)d〃(u)).
(8.1)
Then let ωg(u, V) = [(g-1)0 ◦ (h(Ξ(u), v))] h0(Ξ(u), V) where Ξ(u) is the indefinite integral of ξ
and h : R X e` → R is some jointly and seperately integrable function. By the bijectivity of g
onto its codomain, "` exists. Now further specify h so that, h(Ξ(u), V) I	= f (v). Then by the
lu∈E'
fundamental theorem of (Lebesgue) calculus and chain rule,
g(o[ξ](V))
g ZL
[(g-1)0 ◦ (h(Ξ(u),v))] h0(Ξ(u),v)ξ(u) dμ(u)
g (g-1 (h(E(U),v)))
u∈E'
f(V)
(8.2)
A generalization of this theorem to e` ⊂ Rn is given by Stokes theorem.
□
8.2	Density in Linear Operators
Theorem 8.2 (Approximation of Linear Operators). Suppose e`, e` are σ-compact, locally compact,
measurable, Hausdorff spaces. If K : C(e`) → C(E') is a bounded linear operator then there
exists an o-operational layer such that for all y' ∈ C (E'), o[y'] = K [y'].
Proof. Let Zt : C (Eg，)→ R be a linear form which evaluates its arguments at t ∈ E'; that is,
Zt(f) = f (t). Then because Zt is bounded on its domain, Zt ◦ K = K ?Zt : C (Eg) → R is a bounded
linear functional. Then from the Riesz Representation Theorem we have that there is a unique regular
Borel measure μt on Eg such that
(Ky') (t) = K*& (y')
/ y'(S) dμt(s),
(8.3)
kμtk = kK ?Zt k
We will show that κ : t 7→ K?Zt is continuous. Take an open neighborhood of K?Zt, say V ⊂
[C(Eg)]*, in the weak* topology. Recall that the weak* topology endows [C(Eg)]* with smallest
collection of open sets so that maps in i(C (Eg)) ⊂ [C (Eg)]** are continuous where i : C (Eg) →
[C(Eg)]** so that i(f) = f = φ → φ(f), φ ∈ [C(Eg)]*. Then without loss of generality
m
V = \ f-n1(Uan )
n=1
where fαn ∈ C(Eg) and Uαn are open in R. Now κ-1(V) = W is such that if t ∈ W then
K?Zt ∈ Tm f;n1(Uan). Therefore for all f。” then K*Zt(fon) = Zt(K%/)=K[fɑ/(t) ∈ Uon.
We would like to show that there is an open neighborhood of t, say D, so that D ⊂ W and κ(Z) ⊂ V.
First since all the maps K[fan] : Eg0 → R are continuous let D = T1m(K[fan])-1(Uan) ⊂ Eg0.
Then if r ∈ D, f。[K?Zr] = K[f。](r) ∈ Ua for all 1 ≤ n ≤ m. Therefore κ(r) ∈ V and so
κ(D) ⊂ V.
14
Under review as a conference paper at ICLR 2018
As the norm ∣∣ ∙ k* is continuous on [C(Eg)]*, and K is continuous on e`, the map t → ∣∣κ(t)k is
continuous. In particular, for any compact subset of Eg, say F, there is an r ∈ F so that ∣∣κ(r)∣ is
maximal on F; that is, for all t ∈ F, ∣∣μt∣∣ ≤ ∣∣μr∣∣∙ ThUs μt《μr.
Now We must construct a borel regular measure V such that for all t ∈ Eg, μt《 V. To do so, We
will decompose Eg into a union of infinitely many compacta on which there is a maximal measure.
Since Eg0 is a σ-compact locally compact Hausdorff space We can form a union Eg0 = S1∞ Un of
precompacts Un with the property that Un ⊂ U∏+ι. For each n define Vn so that Xun∖un-ιμt(n)
where μt(n is the maximal measure on each compact Cl(Un) as described in the above paragraph.
Finally let V = Pn∞=1 Vn . Clearly V is a measure since every Vn is mutually singular with Vm when
n = m. Additionally for all t ∈ Eg, μt《V.
Next by the Lebesgue-Radon-Nikodym theorem, for every t there is an L1 (V) function Kt so that
dμt(s) = Kt(S) dν(s). Thus it follows that
K yg (t)	yg(s)Kt(s) dV(s) E'e	(8.4) yg(s)K(t, s) dV(s) = o[yg](t).
By letting ωg = K we then have K =	二 o up to a v-null set and this completes the proof.	□
8.3	Density in Non-Linear operators
Theorem 8.3. Suppose that E1, E2 are bounded intervals in R. If K : Lipλ (E1) → Lipκ(E3) is a
uniformly continuous, nonlinear operator. Then for every > 0 there exists a deep function machine
D : L1(Eι) -ɪ÷ L1 (E2) -ɪ-> L1(E3)	(8.5)
(8.6)
(vi+1 — vi )
-^Prg pi) + Vi
such that ∣∣D∣Lip入 一 Kll < e.
We will first introduce some defintions which quantize uniformly continuous operators on function
space.
Definition 8.4. Let P = pi < •… < Pn be some partition of a compact interval E with N
components. We call ρP : Lip*(E) → RN and ρ*P : RM → Lip*(E) affine projection maps if
ρP(f) = (f(pi))iN=1
N-1
ρ*P (v) = v 7→	χPi (x)
i=0
where χPi is the indicator function on Pi = [pi,pi+1) when i < N and PN-1 = [pN-1,pN].
Definition 8.5. Let P, Q be partitions of E1, E3 of N, M components respectively. If K :
Lipλ(E1) → Lipκ(E3), its affine projection, |K|, and its lattice map, K, are defined so that the
following diagram commutes,
*
Lipλ (EI)一"T RN --------Lip Lipλ (EI)
Jk|	]k	K
LipK(E3)^r~*~ RM PQ^~ LipK(E3)
ρQ	ρQ
Lemma 8.6 (Strong Linear Approximation). IfK : Lipλ(E1) → LipK(E3) is a uniformly continuous,
nonlinear operator thenfor every e > 0 there exist partitions P, Q of E1,E3 so that ∣K — |K ∣∣ < e.
Proof. To show the lemma, we will chase the commutative diagram above by approximation.
For any δ > 0, we claim that there exists a P such that for any f ∈ Lipλ(E1), the affine projection
approximates f; that is, kf — PP ◦ PP ◦ f ∣∣L1(μ) < δ. To see this, take P to be a uniform partition of
15
Under review as a conference paper at ICLR 2018
Ei With ∆p := μ(Pi) < μ(Eδ1)λ .Then
N-1
If -ρp ◦ PP ◦ f | dμ ≤ £ /
i=1 Pi
N-1
≤ Xi=1 ZPi
N-1
≤X
i=1 Pi
f(t) -
(f(Pi；(Pf(Pi)) (t - Pi)+f(pi)] pμ(t)
If (t) - f (Pi) - λ(t - Pi) | dμ(t)
2λ∣t - pi∣ dμ(t) ≤ λ∆p2N < δ.
NoW by the absolute continuity of K, for every > 0 there is a δ and therefore a partition P of E1 so
that if kf - ρp ◦ ρp ◦ f∣∣Li(μ) < δ then ∣∣K[f] - K[ρp ◦ ρp ◦川山⑷ < e/2. Finally let Q bea
uniform partition of E3 so that for every φ ∈ LiPK(E3), ∣∣φ - PQ ◦ PQ ◦ φ∣Li(μ) < e/2. It follows
that for every f ∈ Lipλ(E1)
∣K[f] -|KI[f]∣Lι(μ) ≤∣K[f] - K ◦ ρp QPP[f]k + ∣K[f]-pQ。PQ ◦ K[川
ee
< 2 + 2= e.
Therefore the affine projection of K approximates K . This completes the proof.
□
With the lemma given we will approximate nonlinear operators through an approximation of the
affine approximation using n-discrete DFMs.
Proof of Theorem 3.5. Let e > 0 be given. By Lemma 8.6 there exist partitions, P, Q, so that
∣K-IKIk < e/2. The Cooresponding lattice map K : RN → RM is therefore continuous. Since Ei
is a compact interval, the image PP[Lipλ(E1)] is compact and homeomorphic to the unit hypercube
[0, 1]N. By the universal approximation theorem of Cybenko (1989), for every δ, there exists a deep
function machine
N : IRNl	[rj	IRM I,
so that kK - Ν∣∞ < δ. Then, the continuity of the affine projection maps implies that there exist δ
such that kPQ qN ◦ PP - ∣K∣∣ < e/2. Therefore the induced operator onNrepresents K; that is,
kPQ QN。PP - Kk < e.
LetN be parameterized by Wi ∈ RN×J and W2 ∈ RJ×M. Let S be any uniform partition of an
I = [0, 1] with J components. Then parameterize a deep function machine D with weight kernels
NJ
ωi(u,v)=	χSj×Pi(u, v)Wii,jδ(u -Pi),
i=i j=i
M-i	J
ω2(v, x) =	χQk(x)
k=i	j=i
W2	-W2
TQk)j,k(Lqk)+吟
δ(v - sj),
where δ is the dirac delta function. We claim that D = PQ qN。pp . Performing routine computations,
for any f ∈ LiPλ(Ei),
D[f] = T2 ◦ g ◦ (/ f (u)ωι(u, v) dμ(u)
T2 。 g 。	/ ΣΣXSj ×Pi (u, v) Wijf(u)δ(u - Pi) dμ(u)
Ei i=i j=i
T ◦ g。(XPP(f)tWjIXSj (v)):
T2 。 g 。 h(v )
16
Under review as a conference paper at ICLR 2018
Thus, h is identical to the jth neuron of the first n-discrete layer in N ◦ ρP when v = sj . Turning to
T2 in D, we get that
D[f] =
ω2(v, x)g(h(v)) dμ(v)
M-1	J
X χQk(x)X
k=1	j=1
W2 W2
j,k+(Q ) j,k (X -qk) + wj,k g(h(sj))
M-1
X XQk (X) ∙ g(PP(f )TWI)T
k=1
- wk+ι- Wki
一 μ(Qk)
(X - qk ) + Wk2
PQg(PP(f )T W I)T W 2) = PQQNQPP [f ].
Therefore ||。^入一 Kk < e and this completes the proof.
□
We will now prove a similar theorem for d-defunctional layers.
Theorem 8.7 (Nonlinear Basis Approximation). Suppose I, E2 , E3 are compact intervals, and let
Cω (X) denote the set of analytic functions on X. If B : In → Cω(E3) is a continuous basis map to
analytic functions then for every > 0 there exists a deep function machine
D ：叵-ɪ÷ ∣L1(E2)∣ -ɪ÷ I L1 (E3)∣	(8.7)
such that kD|I n - B k < in the topolopgy of uniform convergence.
Proof. Recall that the set of polynomials on E3, P, are a basis for the vector space Cω(E3). Therefore
the map B has a decomposition through nmaots κ, ∆ so that the following diagram commutes
'1(R)
/，/“ IK
Rn —B→ Cω (E3)
and κ : (ai)i∞=1 7→ P angn where gn is the mononomial of degree n. The existence of ∆ can be
verified through a composition of the direct product of basis projections in Cω(E3) and B.
For each m ∈ N the projection image in the mth coordinate, πm [∆[Rn]] = R and so again the
maos factor into a countable collection of maps (∆i : Rn → R)i∞=1 so that Qi∞=1 ∆i = ∆. We will
approximate B by approximations of κ Q ∆ via increasing products of ∆i .
Define the aforementioned increasing product map ∆(N) as
N∞
∆(N)=Y∆i× Yc0
i=1	N+1
where c0 is the constant map. Now with > 0 given, we wish to show that there exists an N so that
kκ Q ∆(N) - Bk < in the topology of uniform convergence.
To see this let PN ⊂ P denote the set of polynomials of degree at most n. Next we define a open
’mullification’ ofPN. In particular let
OPN()={f∈Cω() | |f-g| <,g∈PN}.
It is clear that OPN1 () ⊂ OPN2 () when N1 ≤ N2 and furthermore by the density of P in
Cω (E3) we have that {OPi ()}i∞=1 is an open cover of B [In] ⊂ Cω (E3). Since In is compact
B[In] is a compact subset of Cω(E3) and thus there is a finite index set I0 = {N1, . . . Nk} so that
St∈I0 OPt ⊃ B[In]. If N = maxI0 then OPN () ⊃ B[In]. Therefore for every X ∈ In we have
that kκ Q ∆(N) - Bk < since κ Q ∆(N) is a polynomial of degree at most N.
17
Under review as a conference paper at ICLR 2018
Now we will filter the maps ψN := π1...N ◦ ∆(N) where ψN : Rn → RN through the universal
approximation theory of standard discrete neural networks. Let N be a two n-discrete layer DFM so
that kN - ψN k < . For convienience let N := n2 ◦ gn1 Then we can instantiate N as the DFM in
(8.7) using the same method as in the proof of the nonlinear operator approximation theory above.
For the d-defunctional layer let Wj1k be the weight tensor of n1 in N so that n1(x)j1 = Pk Wj1kxk.
Then let the weight kernel for d be ωf(v) = ρ*(W.k). and then d[χ]∣v=j = nι(χj. WeWillommit
the design of weight kernels for the o-operational layer, but this is not difficult to establish. All
together we now have that via the approximation of N and equivalence of N and its instantiation in
the statement of the theorem,
kκ ◦ ρ ◦ o ◦ g ◦ d - κ ◦ ιN ◦ ψNk < .
Finally we need deal with the basis map κ. On the compact set ∆(N) [In] = ιN ◦ ψN [In], κ is a
bounded linear operator and its composition, κ ◦ ρ ◦ o is also a bounded linear operator. Therefore by
the bounded linear approximation theorem of o-operational layers, there is a ko0 - κ ◦ ρ ◦ ok < .
Appending such o0 to d as above we achieve the approximation bound of the theorem. This completes
the proof.	口
8.4	Resolution Invairance
Theorem 8.8. If t` is an o-operational layer with an integrable weight kernel ω(u, v) of O(1)
parameters, then there isa unique n-discrete layer with with O(N) parameters so that o[ξ](j) = n[x]j
for all indices j and for all ξ, x as above.
Proof. Given some o, we will give a direct computation of the corresponding weight matrix of n. It
follows that
θ[ξ](v) = / ξ(u) ω'(u,v) dμ(u)
N-1 n+1
=£/	((xn+ι - Xn)(U - n) + Xn) 3' (u,v) dμ(u)
=ɪ2 (xn+1 — Xn) /	(u — n)ω'(u, V) dμ(u) + Xn	ω'(u, V) dμ(u)
nn	n
(8.8)
Now, let Vn(V) = Rn,+1(u — n)ω'(u, v) dμ(u) and Qn(V) = Rnn+1 ω'(u, v) dμ(u); We can now
easily simplify (8.8) using the telescoping trick of summation.
N-1
o(ξ)[V] = XN VN-1(V) + X Xn (Qn (V) - Vn (V) + Vn-1(V)) + X1(Q1(V) - V1(V))	(8.9)
n=2
Given indices in j ∈ {1,…，M}, let W ∈ RN×M so that Wnj = (Qn(j) - Vn(j) + Vn-ι(j),
WN,j = VN-1(j), and W1,j = Q1(j) - V1(j). It follows that if W parameterizes some n, then
n[X]j = o[ξ](j) for every f sampled/approximated by X and ξ. Furthermore, dim(W) ∈ O(N), and
n is unique UP to L1 (μ) equivalence.	口
8.5	Convolutional Neural Networks and the Ultrahyperb olic Differential
Equation
Proof. A general solution to (4.3) is of the form ω(u, V) = F (u - cV) + G(u + cV) where F, G
are second-differentiable. Essentially the shape of ω stays constant in u, but the position of ω
varies in V. For every h there exists a continuous F so that F(j) = hj, G = 0. Let ω(u, V) =
F(u - cV) + G(u+ cV). Therefore applying Theorem 4.1, to o parameterized by ω, we yield a weight
matrix W so that
[o[ξ](j) =
E0
ξ(u)(F(u — cj) + 0) dμ(u) = (Wx)j
(h?X)j = n[X]j.
(8.10)
18
Under review as a conference paper at ICLR 2018
This completes the proof.
□
9	Appendix C: VC Dimension of Dis cretized Operator Neural
Networks.
In order to calculate the VC dimension of DFMs contianing only discretized o-operational layers,
denoted D, we have D ⊂ N, where N is the family of all DFMs with n-discrete skeletons whose
per-node dimensionality is exactly that of the discretization D. Thus the VC dimension ofF can be
bounded by that of N, however more fine tuned estimate is both possible and essential.
Suppose that in designing some deep architecture, one wishes to keep VC dimension low, whilst
increasing per-node activation dimensionality. In practice optimization in higher dimensions is easier
when a low dimensional parameterization is embedded therein. For example, hyperdimensional
computing, sparse coding, and convolutional neural networks naturally neccessitate high dimensional
hidden spaces but benefit from regularized capacity. Since the dimensionality of the discretization O
does not depend on the original dimensionality of the space, then the capacity of O depends directly
on the "complexity" of the family of weight surfaces there endowed. It would therefore be convenient
to answer the following question formally.
The VC Problem. Let w` ⊂ L1(R2, μ) be some family of weight surfaces. Then induce OW,
a family of discretized o-operational layers with OW := {[θw]n}w∈w where Hn denotes the
discretization. What is V CDim(OW)?
Although in this work we do not directly attack this problem, a solution leads to another dimension
of layer and architecture design beyond topological constraints. In practice, one would be able to
choose which set of W' to give a satisfactory generalizability condition on their learning problem.
10	Appendix D: Analytical Derivation of Continuous Error
Backpropagation for Seperable Weight Kernels
With these theoretical guarantees given for DFMs, the implementation of the feedforward and error
backpropagation algorithms in this context is an essential next step. We will consider operator neural
networks with polynomial kernels. As aforementioned, in the case where a DFM has nodes with
non-seperable kernels, we cannot give the guarntees we do in the following section. Therefore, a
standard auto-differentiation set-up will suffice for DFMs with for example wave layers.
Feedforward propagation is straight forward, and relies on memoizing operators by using the separa-
bility of weight polynomials. Essentially, integration need only occur once to yield coefficients on
power functions. See Algorithm 1.
10.0.1 Feed-Forward Propagation
We will say that a function f : R2 → R is numerically integrable if it can be seperated into
f(x, y) = g(x)h(y).
Theorem 10.1. If O is a operator neural network with L consecutive layers, then given any ` such
that 0 ≤ ' < L, y' is numerically integrable, and if ξ is any continuous and Riemann integrable
input function, then O [ξ] is numerically integrable.
19
Under review as a conference paper at ICLR 2018
Algorithm 1 Feedforward Propagation on F
Input: input function ξ
for l ∈ {0, . . . , L - 1} do
for t ∈ ZX do
Calculate I' = RE‘ y'(j')j' dj`.
end for
for S ∈ ZY do
CaICUIate CCs= PZX ka,sIa .
end for
Memoize y'(j) = g (PZY jbC')
end for
The output is given by O[ξ] = yL .
Proof. Consider the first layer. We can write the sigmoidal output of the (`)th layer as a function of
the previous layer; that is,
y' = g (/ w'(j',j')y'(jι) jι).
(10.1)
Clearly this composition can be expanded using the polynomial definition of the weight surface.
Hence
Z Z	ZY ZX	∖
y' = g UEey'(j')XXkX2l,X2'j' 2l j '2 dj' )
(ZY	ZX	∖
=g (£jx2'EkxMg JE y'(j')jx2l dj'),
(10.2)
and therefore y' is numerically integrable. For the purpose of constructing an algorithm, let Ix' be
the evaluation of the integral in the above definition for any given x2'
It is important to note that the previous proof requires that y' be Riemann integrable. Hence, with ξ
satisfying those conditions it follows that every y' is integrable inductively. That is, because y0 is
integrable it follows that by the numerical integrability of all l, O[ξ] = yL is numerically integrable.
This completes the proof.	□
Using the logic of the previous proof, it follows that the development of some inductive algorithm is
possible.
10.0.2 Continuous Error Backpropagation
As is common with many non-convex problems with discretized neural networks, a stochastic gradient
descent method will be developed using a continuous analogue to error backpropagation. We define
the loss function as follows.
Definition 10.2. For a operator neural network O and a dataset {(γn (j), δn(j))} we say that the
error for a given n is defined by
E
2 JL(O(Yn)- δn)2
djL
(10.3)
This error definition follows from N as the typical error function for N is just the square norm of the
difference of the desired and predicted output vectors. In this case we use the L2 norm on C(EL) in
the same fashion.
We first propose the following lemma as to aid in our derivation of a computationally suitable error
backpropagation algorithm.
Lemma 10.3. Given some layer, l > 0, in O, functions of the form Ψ' = g0 Σιy' are numerically
integrable.
20
Under review as a conference paper at ICLR 2018
Proof. If
Ψ'
y('-1)w('-1) dj`
(10.4)
then
∕Z 广1)	ZFI)	,
Ψ' = g0	X jj X ka`-1) /	yjja djl-2
∖ b	a	'e('-i)
hence Ψ can be numerically integrated and thereby evaluated.
(10.5)
□
The ability to simplify the derivative of the output of each layer greatly reduces the computational
time of the error backpropagation. It becomes a function defined on the interval of integration of the
next iterated integral.
Theorem 10.4. The gradient, VE (γ, δ) ,for the errorfunction (10.3) on some O can be evaluated
numerically.
Proof. Recall that E over O is composed of k',y for X ∈ ZX,y ∈ ZY, and 0 ≤ l ≤ L. If we
show that ∂kE- can be numerically evaluated for arbitrary, l, x, y, then every component of VE is
x,y
numerically evaluable and hence VE can be numerically evaluated. Given some arbitrary l in O, let
n = `. We will examine the particular partial derivative for the case that n = 1, and then for arbitrary
n, induct over each iterated integral.
Consider the following expansion for n = 1,
∂E
∂kX-n
∂⅛ 2 JEgS)- δ]
djL
/
je`
ZE
J E'
[O(γ) - δ] ΨL
JE('-1)
jLx-1jLy yL-1djL-1 djL
[O(γ) - δ] ΨLjLy
J E('-1)
jLx-1yL-1djL-1 djL
(10.6)
Since the second integral in (10.6) is exactly IxL-1 from (??), it follows that
∂E = IL-1 Je [O(Y)- δ]ψjLj
dkx,y	E e'
(10.7)
and clearly for the case of n = 1, the theorem holds.
Now we will show that this is all the case for larger n. It will become clear why we have chosen to
include n = 1 in the proof upon expansion of the pratial derivative in these higher order cases.
Let us expand the gradient for n ∈ {2, . . . , L}.
急=∕el [O(Y) - Wel
、
wl-1Ψl-1 [ ∙∙∙ [	wL-n+1)ψL-n+1)
-1	EL-n+1)
}
(10.8)
n-1 iterated integrals
yL-njLa-njLb -n+1 djL-n . . . djL
As aforementioned, proving the n = 1 case is required because for n = 1, (10.8) has a section of
n - 1 = 0 iterated integrals which cannot be possible for the proceeding logic.
We now use the order invariance properly of iterated integrals (that is, A B f(x, y) dxdy =
B A f(x, y) dydx) and reverse the order of integration of (10.8).
In order to reverse the order of integration we must ensure each iterated integral has an integrand
which contains variables which are guaranteed integration over some region. To examine this, we
propose the following recurrence relation for the gradient.
21
Under review as a conference paper at ICLR 2018
Let {Bs } be defined along L - n ≤ s ≤ L, as follows
BL
[O(γ) - δ] ΨLBL-1 djL,
EL
``
ZZX ZY
,Ψ'Σ号增在' dj',
L-n =	jLx -njLy -n+1 djL-n
(10.9)
such that ~∂kE~ = BL. If we wish to reverse the order of integration, We must find a reoccurrence
x,y
relation on a sequence, {4} such that JLELn = S^-nn = Bl. Consider the gradual reversal of
∂kx,y
(10.8).
Just as important as Clearly,
∂E = JE	yL-njL-n JE [O(γ) - δ]ψL JE	wl-1ψlt
[…[	jL-n+lWL-n+1)ΨL-n+1) djL-n+1... jLjL-n
EL-n+1)
(10.10)
is the first order reversal of (10.8). We now show the second order case with first weight function
expanded.
W = ZEL 期LfjL-n Ze	X X ka,bjL-n+lΨLfSjE JO(Y)- W
[…[	jL-n+2 W(L-n+^Ψ(L-n+2) djL-n+1 ... jL jL-n∙
EL-n+1)
Repeated iteration of the method seen in (10.10) and (10.11), where the inner most integral is moved
to the outside of the (L - s)th iterated integral, with s is the iteration, yields the following full reversal
of (10.8). For notational simplicity recall that l = L - n, then
z`	z` z'+2
∂∂E = / y'jL / X j” ψ' j XX k'j+2cΨ'+2
dkL,y JE'	JE' a	JE'+2 b C
z*2 z'+3	ZYT	(10.12)
I XX k'+d2 洋3e ψ'+3	… X kL- 1jL [O(Y) - δ]ψL
E'+3 d e	EL q
djL . . . djL-n .
Observing the reversal in (10.12), we yield the following recurrence relation for { s}. Bare in mind,
l = L - n, X and y still correspond with dkE—, and the following relation uses its definition on S for
∂ kx,y
cases not otherwise defined.
L,t
s,t
∂E
dkL,y
L-1
ZY
ktL,b-1jLb [O(γ) -δ]ΨLdjL.
ELb
ZY(s-1) ZX(s)
X Xkt(,sb-1)jsa+b	Ψ(s) s+1,a djs.
E(s) b	a
ZX'
I X j'a+yψ'¾+2,a dj`.
E' a
L jLy'¾ dj`.
(10.13)
`
l
22
Under review as a conference paper at ICLR 2018
Algorithm 2 Error Backpropagation
Input: input γ, desired δ, learning rate α, time t.
for ` ∈ {0, . . . , L} do
Calculate Ψ' = g0 (/石(名	y('-1)w('-1) j`)
end for
For every t, compute L,t from from (10.13).
Update the output coefficient matrix kxL,-y1 - IxL-1 EL [F(γ) - δ] ΨLjLy djL→kxL,-y1.
for l = L - 2 to 0 do
If it is null, compute and memoize l+2,t from (10.13).
Compute but do not store ` ∈ R.
Compute ∂kE- = Hl from from (10.13).
x,y
Update the weights on layer l: k',y (t) → k',y
end for
Note that L-n = BL by this logic.
With (10.13), we need only show that L-n is integrable. Hence we induct on L - n ≤ s ≤ L over
{ s } under the proposition that s is not only numerically integrable but also constant.
Consider the base case s = L. For every t, because every function in the integrand of L in (10.13)
is composed of jL, functions of the form L must be numerically integrable and clearly, L ∈ R.
Now suppose that s+1,t is numerically integrable and constant. Then, trivially, s,u is also numeri-
cally integrable by the contents of the integrand in (10.13) and s,u ∈ R. Hence, the proposition that
s + 1 implies s holds for ` < s < L.
Lastly we must show that both ` and l are numerically integrable. By induction l+2 must be
numerically integrable. Hence by the contents of its integrand ` must also be numerically integrable
and real. As a result, Hl = ∂kE- is real and numerically integrable.
x,y
Since we have shown that ∂rE- is numerically integrable, VE must therefore be numerically
x,y
evaluable as aforementioned. This completes the proof.	□
23