Table 1: Primitive drawing commands currently supported by our model.
Table 2: Grammar over graphics programs. We allow loops (for) with conditionals (if), verti-cal/horizontal reflections (reflect), variables (Var) and affine transformations (Z×Var+Z).
Table 3: Example drawings (left), their ground truth trace sets (middle left), and programs synthesizedfrom these trace sets (middle right). Compared to the trace sets the programs are more compressive(right: programs have fewer lines than traces) and automatically group together related drawingcommands. Note the nested loops and special case conditionals in the Ising model, combinationof symmetry and iteration in the bottom figure, affine transformations in the top figure, and thecomplicated program in the second figure to bottom.
Table 4: Parameterization of different ways of posing the program synthesis problem. The policylearns to choose parameters likely to quickly yield a minimal cost program. We slightly abusenotation by writing σ to mean an assignment to each of these parameters (so σ assumes one of 24different values) and to mean the set of programs selected by that parameterization (so σ ⊆ DSL)Parameter	Description	RangeLoops?	Is the program allowed to loop?	{True, False}Reflects?	Is the program allowed to have reflections?	{True, False}Incremental?	Solve the problem piece-by-piece or all at once?	{True, False}Maximum depth	Bound on the depth of the program syntax tree	{1, 2, 3}4 Applications of graphics program synthesisWhy synthesize a graphics program, if the trace set already suffices to recover the objects in animage? Within our domain of hand-drawn figures, graphics program synthesis has several uses:7Under review as a conference paper at ICLR 2018Awu由 nbQ』O0sketchoraclelearned policy tours)time (sec)
