Published as a conference paper at ICLR 2018
Meta-Learning and Universality:
Deep Representations and Gradient Descent can
Approximate any Learning Algorithm
Chelsea Finn & Sergey Levine
University of California, Berkeley
{cbfinn,svlevine}@eecs.berkeley.edu
Ab stract
Learning to learn is a powerful paradigm for enabling models to learn from data
more effectively and efficiently. A popular approach to meta-learning is to train
a recurrent model to read in a training dataset as input and output the parame-
ters of a learned model, or output predictions for new test inputs. Alternatively, a
more recent approach to meta-learning aims to acquire deep representations that
can be effectively fine-tuned, via standard gradient descent, to new tasks. In this
paper, we consider the meta-learning problem from the perspective of universal-
ity, formalizing the notion of learning algorithm approximation and comparing
the expressive power of the aforementioned recurrent models to the more recent
approaches that embed gradient descent into the meta-learner. In particular, we
seek to answer the following question: does deep representation combined with
standard gradient descent have sufficient capacity to approximate any learning al-
gorithm? We find that this is indeed true, and further find, in our experiments, that
gradient-based meta-learning consistently leads to learning strategies that gener-
alize more widely compared to those represented by recurrent models.
1	Introduction
Deep neural networks that optimize for effective representations have enjoyed tremendous success
over human-engineered representations. Meta-learning takes this one step further by optimizing
for a learning algorithm that can effectively acquire representations. A common approach to meta-
learning is to train a recurrent or memory-augmented model such as a recurrent neural network to
take a training dataset as input and then output the parameters of a learner model (Schmidhuber,
1987; Bengio et al., 1992; Li & Malik, 2017a; Andrychowicz et al., 2016). Alternatively, some
approaches pass the dataset and test input into the model, which then outputs a corresponding pre-
diction for the test example (Santoro et al., 2016; Duan et al., 2016; Wang et al., 2016; Mishra et al.,
2018). Such recurrent models are universal learning procedure approximators, in that they have the
capacity to approximately represent any mapping from dataset and test datapoint to label. However,
depending on the form of the model, it may lack statistical efficiency.
In contrast to the aforementioned approaches, more recent work has proposed methods that include
the structure of optimization problems into the meta-learner (Ravi & Larochelle, 2017; Finn et al.,
2017a; Husken & Goerick, 2000). In particular, model-agnostic meta-learning (MAML) optimizes
only for the initial parameters of the learner model, using standard gradient descent as the learner’s
update rule (Finn et al., 2017a). Then, at meta-test time, the learner is trained via gradient descent.
By incorporating prior knowledge about gradient-based learning, MAML improves on the statistical
efficiency of black-box meta-learners and has successfully been applied to a range of meta-learning
problems (Finn et al., 2017a;b; Li et al., 2017). But, does it do so at a cost? A natural question that
arises with purely gradient-based meta-learners such as MAML is whether it is indeed sufficient
to only learn an initialization, or whether representational power is in fact lost from not learning
the update rule. Intuitively, we might surmise that learning an update rule is more expressive than
simply learning an initialization for gradient descent. In this paper, we seek to answer the follow-
ing question: does simply learning the initial parameters of a deep neural network have the same
representational power as arbitrarily expressive meta-learners that directly ingest the training data
at meta-test time? Or, more concisely, does representation combined with standard gradient descent
have sufficient capacity to constitute any learning algorithm?
1
Published as a conference paper at ICLR 2018
We analyze this question from the standpoint of the universal function approximation theorem. We
compare the theoretical representational capacity of the two meta-learning approaches: a deep net-
work updated with one gradient step, and a meta-learner that directly ingests a training set and test
input and outputs predictions for that test input (e.g. using a recurrent neural network). In studying
the universality of MAML, we find that, for a sufficiently deep learner model, MAML has the same
theoretical representational power as recurrent meta-learners. We therefore conclude that, when
using deep, expressive function approximators, there is no theoretical disadvantage in terms of rep-
resentational power to using MAML over a black-box meta-learner represented, for example, by a
recurrent network.
Since MAML has the same representational power as any other universal meta-learner, the next
question we might ask is: what is the benefit of using MAML over any other approach? We study
this question by analyzing the effect of continuing optimization on MAML performance. Although
MAML optimizes a network’s parameters for maximal performance after a fixed small number
of gradient steps, we analyze the effect of taking substantially more gradient steps at meta-test
time. We find that initializations learned by MAML are extremely resilient to overfitting to tiny
datasets, in stark contrast to more conventional network initialization, even when taking many more
gradient steps than were used during meta-training. We also find that the MAML initialization is
substantially better suited for extrapolation beyond the distribution of tasks seen at meta-training
time, when compared to meta-learning methods based on networks that ingest the entire training set.
We analyze this setting empirically and provide some intuition to explain this effect.
2	Preliminaries
In this section, we review the universal function approximation theorem and its extensions that we
will use when considering the universal approximation of learning algorithms. We also overview the
model-agnostic meta-learning algorithm and an architectural extension that we will use in Section 4.
2.1	Universal Function Approximation
The universal function approximation theorem states that a neural network with one hidden layer
of finite width can approximate any continuous function on compact subsets of Rn up to arbitrary
precision (Hornik et al., 1989; Cybenko, 1989; Funahashi, 1989). The theorem holds for a range
of activation functions, including the sigmoid (Hornik et al., 1989) and ReLU (Sonoda & Murata,
2017) functions. A function approximator that satisfies the definition above is often referred to as
a universal function approximator (UFA). Similarly, we will define a universal learning procedure
approximator to be a UFA with input (D, x?) and output y?, where (D, x?) denotes the training
dataset and test input, while y? denotes the desired test output. Furthermore, Hornik et al. (1990)
showed that a neural network with a single hidden layer can simultaneously approximate any func-
tion and its derivatives, under mild assumptions on the activation function used and target function’s
domain. We will use this property in Section 4 as part of our meta-learning universality result.
2.2	Model-Agnostic Meta-Learning with a Bias Transformation
Model-Agnostic Meta-Learning (MAML) is a method that proposes to learn an initial set of param-
eters θ such that one or a few gradient steps on θ computed using a small amount of data for one
task leads to effective generalization on that task (Finn et al., 2017a). Tasks typically correspond to
supervised classification or regression problems, but can also correspond to reinforcement learning
problems. The MAML objective is computed over many tasks {Tj } as follows:
mθinXL(DT∙"T∙) = XL①T,，。-。口£(。方,θ)),
jj
where DTj corresponds to a training set for task Tj and the outer loss evaluates generalization on
test data in DT0 . The inner optimization to compute θT0 can use multiple gradient steps; though,
in this paper, we will focus on the single gradient step setting. After meta-training on a wide range
of tasks, the model can quickly and efficiently learn new, held-out test tasks by running gradient
descent starting from the meta-learned representation θ.
While MAML is compatible with any neural network architecture and any differentiable loss func-
tion, recent work has observed that some architectural choices can improve its performance. A
particularly effective modification, introduced by Finn et al. (2017b), is to concatenate a vector of
2
Published as a conference paper at ICLR 2018
parameters, θb, to the input. As with all other model parameters, θb is updated in the inner loop via
gradient descent, and the initial value of θb is meta-learned. This modification, referred to as a bias
transformation, increases the expressive power of the error gradient without changing the expressiv-
ity of the model itself. While Finn et al. (2017b) report empirical benefit from this modification, we
will use this architectural design as a symmetry-breaking mechanism in our universality proof.
3	Meta-Learning and Universality
We can broadly classify RNN-based meta-learning methods into two categories. In the first ap-
proach (Santoro et al., 2016; Duan et al., 2016; Wang et al., 2016; Mishra et al., 2018), there is a
meta-learner model g with parameters φ which takes as input the dataset DT for a particular task T
and a new test input x*, and outputs the estimated output y? for that input:
y? = g(Dτ, χ*; φ) = g((χ, y)ι,…，(χ, y)κ, χ*; φ)
The meta-learner g is typically a recurrent model that iterates over the dataset D and the new input
χ? . For a recurrent neural network model that satisfies the UFA theorem, this approach is maximally
expressive, as it can represent any function on the dataset DT and test input χ? .
In the second approach (Hochreiter et al., 2001; Bengio et al., 1992; Li & Malik, 2017b; Andrychow-
icz et al., 2016; Ravi & Larochelle, 2017; Ha et al., 2017), there is a meta-learner g that takes as
input the dataset for a particular task DT and the current weights θ ofa learner model f, and outputs
new parameters θT0 for the learner model. Then, the test input χ? is fed into the learner model to
produce the predicted output y?. The process can be written as follows:
y ? = f (χ*; θT) = f (χ*; g(Dτ; φ)) = f (χ*; g((χ, y)i:K; φ))
Note that, in the form written above, this approach can be as expressive as the previous approach,
since the meta-learner could simply copy the dataset into some of the predicted weights, reducing
to a model that takes as input the dataset and the test example.1 Several versions of this approach,
i.e. Ravi & Larochelle (2017); Li & Malik (2017b), have the recurrent meta-learner operate on
order-invariant features such as the gradient and objective value averaged over the datapoints in the
dataset, rather than operating on the individual datapoints themselves. This induces a potentially
helpful inductive bias that disallows coupling between datapoints, ignoring the ordering within the
dataset. As a result, the meta-learning process can only produce permutation-invariant functions of
the dataset.
In model-agnostic meta-learning (MAML), instead of using an RNN to update the weights of the
learner f, standard gradient descent is used. Specifically, the prediction y? for a test input χ? is:
y? = ∕maml(Dt , χ*; θ)
=f (χ*; θT) = f(χ*; θ - αVθL(Dτ,θ)) = f 卜;θ - αVθK Xq '(yk,fg； θ))),
where θ denotes the initial parameters of the model f and also corresponds to the parameters that are
meta-learned, and ` corresponds to a loss function with respect to the label and prediction. Since the
RNN approaches can approximate any update rule, they are clearly at least as expressive as gradient
descent. It is less obvious whether or not the MAML update imposes any constraints on the learning
procedures that can be acquired. To study this question, we define a universal learning procedure
approximator to be a learner which can approximate any function of the set of training datapoints
DT and the test point χ?. It is clear how fMAML can approximate any function on χ?, as per the UFA
theorem; however, it is not obvious if fMAML can represent any function of the set of input, output
pairs in DT, since the UFA theorem does not consider the gradient operator.
The first goal of this paper is to show that fMAML (DT, χ?; θ) is a universal function approximator of
(DT, χ?) in the one-shot setting, where the dataset DT consists of a single datapoint (χ, y). Then,
we will consider the case ofK -shot learning, showing that fMAML(DT, χ?; θ) is universal in the set
of functions that are invariant to the permutation of datapoints. In both cases, we will discuss meta
supervised learning problems with both discrete and continuous labels and the loss functions under
WhiCh UniverSality does or does not hold.
1For this to be possible, the model f must be a neural network with at least two hidden layers, since the
dataset can be copied into the first layer of weights and the predicted output must be a universal function
approximator of both the dataset and the test input.
3
Published as a conference paper at ICLR 2018
Wn--Wx	∕out(∙; ^out)
Figure 1: A deep fully-connected neural network with N+2 layers and ReLU nonlinearities. With this generic
fully connected network, we prove that, with a single step of gradient descent, the model can approximate any
function of the dataset and test input.
4	Universality of the One-Shot Gradient-Based Learner
We first introduce a proof of the universality of gradient-based meta-learning for the special case
with only one training point, corresponding to one-shot learning. We denote the training datapoint
as (x, y), and the test input as x?. A universal learning algorithm approximator corresponds to the
ability of a meta-learner to represent any function ftarget(x, y, x?) up to arbitrary precision.
We will proceed by construction, showing that there exists a neural network function f (∙; θ) such that
f (x*; θ0) approximates ftarget(x, y, x?) UP to arbitrary precision, where θ0 = θ - αVθ'(y, f (x))
and α is the non-zero learning rate. The proof holds for a standard multi-layer ReLU network,
provided that it has sufficient depth. As we discuss in Section 6, the loss function ` cannot be any
loss function, but the standard cross-entropy and mean-squared error objectives are both suitable.
In this proof, we will start by presenting the form of f and deriving its value after one gradient
step. Then, to show universality, we will construct a setting of the weight matrices that enables
independent control of the information flow coming forward from x and x? , and backward from y.
We will start by constructing f, which, as shown in Figure 1 is a generic deep network with N + 2
layers and ReLU nonlinearities. Note that, for a particular weight matrix Wi at layer i, a single
gradient step Wi - αVWi ` can only represent a rank-1 update to the matrix Wi. That is because
the gradient of Wi is the outer product of two vectors, VWi' = aibT-ι, where ai is the error
gradient with respect to the pre-synaptic activations at layer i, and bi-1 is the forward post-synaptic
activations at layer i - 1. The expressive power ofa single gradient update to a single weight matrix
is therefore quite limited. However, if we sequence N weight matrices as QiN=1 Wi , corresponding
to multiple linear layers, it is possible to acquire a rank-N update to the linear function represented
by W = QiN=1 Wi. Note that deep ReLU networks act like deep linear networks when the input and
pre-synaptic activations are non-negative. Motivated by this reasoning, we will construct f (∙; θ) as a
deep ReLU network where a number of the intermediate layers act as linear layers, which we ensure
by showing that the input and pre-synaptic activations of these layers are non-negative. This allows
us to simplify the analysis. The simplified form of the model is as follows:
f(∙; θ) = f。Ut((YY W) Φ(∙; θft,θb); θ°ut),
where φ(∙; θft, θb) represents an input feature extractor with parameters θft and a scalar bias transfor-
mation variable θb, QN=I Wi is a product of square linear weight matrices, fout(∙, θout) is a function
at the output, and the learned parameters are θ := {θft, θb, {Wi}, θout}. The input feature extractor
and output function can be represented with fully connected neural networks with one or more hid-
den layers, which we know are universal function approximators, while QiN=1 Wi corresponds to a
set of linear layers with non-negative input and activations.
Next, we derive the form of the post-update prediction f(x*; θ0). Let Z = (QN=I Wi) φ(x; θft,θb),
and the error gradient Vz' = e(x, y). Then, the gradient with respect to each weight matrix Wi is:
VWi'(y,f(χ,θ)) = (Y Wj) e(χ, y)φ(χ; θft, θb)τ ( Y WJ .
j=1	j=i+1
Therefore, the post-update value of QiN=1 Wi0 = QiN=1(Wi - αVWi `) is given by
N	N ∕i-1	∖ ∕i-1	\T	/ N \T / N ∖
∏ Wi-a X	∏ Wj	n Wj	e(x, y)φ(x;	θft,θb)T ∏	Wj ∏	Wj	-O(α2),
i=1	i=1	j=1	j=1	j=i+1	j=i+1
4
Published as a conference paper at ICLR 2018
where we will disregard the last term, assuming that α is comparatively small such that α2 and all
higher order terms vanish. In general, these terms do not necessarily need to vanish, and likely
would further improve the expressiveness of the gradient update, but we disregard them here for the
sake of the simplicity of the derivation. Ignoring these terms, we now note that the post-update value
of z? when x? is provided as input into f(∙; θ0) is given by
N
z? = Y Wiφ(x*; θft,θb)	(1)
i=1
N ∕i-1	∖ ∕i-1	∖ T	( N	∖T( N ∖
-αX	YWj	YWj	e(x,y)φ(x;θft,θb)T	Y Wj Y Wj	φ(x?;θft,θb),
i=1	j=1	j=1	j=i+1	j=i+1
and f(x? ； θ0) = fout(z?; θo ut).
Our goal is to show that that there exists a setting of Wi , fout, and φ for which the above function,
f(x?, θ0), can approximate any function of (x, y, x?). To show universality, we will aim to indepen-
dently control information flow from x, from y, and from x? by multiplexing forward information
from x and backward information from y. We will achieve this by decomposing Wi , φ, and the
error gradient into three parts, as follows:
r
Wi 0	0
Wi :=	0 Wi 0
0	0	Wi
^φ(∙; θft,θb)
φ(∙; θft,θb) :=	0
θb
0
Vz'(y,f(x; θ)) ：= e(y)	(2)
. e(y) ,
where the initial value of θb will be 0. The top components all have equal numbers of rows, as do the
middle components. As a result, we can see that z will likewise be made up of three components,
which We will denote as Z, z, and z. Lastly, We construct the top component of the error gradient to
be 0, whereas the middle and bottom components, e(y) and e(y), can be set to be any linear (but not
affine) function of y. We will discuss how to achieve this gradient in the latter part of this section
when we define fout and in Section 6.
In Appendix A.3, we show that we can choose a particular form of Wi, Wi, and Wi that will simplify
the products of Wj matrices in Equation 1, such that we get the following form for z?:
N
z? = -α X Aie(y)φ(x; θft, θb)τBTBiφ(x?; θft, θb),	(3)
i=1
where A1 = I, BN = I, Ai can be chosen to be any symmetric positive-definite matrix, and Bi can
be chosen to be any positive definite matrix. In Appendix D, we further show that these definitions
of the weight matrices satisfy the condition that the activations are non-negative, meaning that the
model f can be represented by a generic deep network with ReLU nonlinearities.
Finally, we need to define the function fout at the output. When the training input x is passed in, we
need fout to propagate information about the label y as defined in Equation 2. And, when the test
input x? is passed in, we need a different function defined only on z?. Thus, we will define fout as
a neural network that approximates the following multiplexer function and its derivatives (as shown
possible by Hornik et al. (1990)):
；θout) =	l(z	=	0)gpre	( Z	； θg) +l(z	=	0)hpost(z; θh),	(4)
fout	I
z
fout
zI
where gpre is a linear function with parameters θg such that Vz' = e(y) satisfies Equation 2 (see
Section 6) and hpost(∙; θh) is a neural network with one or more hidden layers. As shown in AP-
pendix A.4, the post-update value of fout is
；θoUt) = hpost(z?; θh).	(5)
Now, combining Equations 3 and 5, we can see that the post-update value is the following:
f(x?; θ0) = hpost (一α X Aie(y)φ(x; θft,θb)TBTBiφ(x? θft,θb)； θh)	(6)
5
Published as a conference paper at ICLR 2018
In summary, so far, we have chosen a particular form of weight matrices, feature extractor, and
output function to decouple forward and backward information flow and recover the post-update
function above. Now, our goal is to show that the above function f (x? ; θ0) is a universal learn-
ing algorithm approximator, as a function of (x, y, x?). For notational clarity, we will use
ki(x, x?) := φ(x; θft, θb)T BiT Biφ(x?; θft, θb0) to denote the inner product in the above equation,
noting that it can be viewed as a type of kernel with the RKHS defined by Biφ(x; θft, θb).2 The
connection to kernels is not in fact needed for the proof, but provides for convenient notation and an
interesting observation. We then define the following lemma:
Lemma 4.1 Let Us assume that e(y) can be Chosen to be any linear (but not affine) function of y.
Then, we can choose θft, θh, {Ai ; i > 1}, {Bi ; i < N } such that the function
f(x?; θ0) = hpost (-α X Aie(y)ki(x, x?); θ%)	⑺
can approximate any continuous function of (x, y, x?) on compact subsets of Rdim(y).3
Intuitively, Equation 7 can be viewed as a sum ofbasis vectors Aie(y) weighted by ki(x, x?), which
is passed into hpost to produce the output. There are likely a number of ways to prove Lemma 4.1.
In Appendix A.1, we provide a simple though inefficient proof, which we will briefly summarize
here. We can define kito be a indicator function, indicating when (x, x?) takes on a particular value
indexed by i. Then, we can define Aie(y) to be a vector containing the information of y and i.
Then, the result of the summation will be a vector containing information about the label y and the
value of (x, x?) which is indexed by i. Finally, hpost defines the output for each value of (x, y, x?).
The bias transformation variable θb plays a vital role in our construction, as it breaks the symmetry
within ki(x, x?). Without such asymmetry, it would not be possible for our constructed function to
represent any function of x and x? after one gradient step.
In conclusion, we have shown that there exists a neural network structure for which f(x?; θ0) is a uni-
versal approximator of ftarget(x, y, x?). We chose a particular form of f (∙; θ) that decouples forward
and backward information flow. With this choice, it is possible to impose any desired post-update
function, even in the face of adversarial training datasets and loss functions, e.g. when the gradient
points in the wrong direction. If we make the assumption that the inner loss function and training
dataset are not chosen adversarially and the error gradient points in the direction of improvement, it
is likely that a much simpler architecture will suffice that does not require multiplexing of forward
and backward information in separate channels. Informative loss functions and training data allow-
ing for simpler functions is indicative of the inductive bias built into gradient-based meta-learners,
which is not present in recurrent meta-learners.
Our result in this section implies that a sufficiently deep representation combined with just a single
gradient step can approximate any one-shot learning algorithm. In the next section, we will show
the universality of MAML for K -shot learning algorithms.
5 General Universality of the Gradient-Based Learner
Now, we consider the more general K-shot setting, aiming to show that MAML can approximate
any permutation invariant function of a dataset and test datapoint ({(x, y)i; i ∈ 1...K}, x?) for
K > 1. Note that K does not need to be small. To reduce redundancy, we will only overview the
differences from the 1-shot setting in this section. We include a full proof in Appendix B.
In the K-shot setting, the parameters of f(∙, θ) are updated according to the following rule:
1K
θ0 = θ - αK £V© '(yk ,f (Xk; θ))).
k=1
2Due to the symmetry of kernels, this requires interpreting θb as part of the input, rather than a kernel
hyperparameter, so that the left input is (x, θb) and the right one is (x?, θb0 ).
3The assumption with regard to compact subsets of the output space is inherited from the UFA theorem.
6
Published as a conference paper at ICLR 2018
Defining the form of f to be the same as in Section 4, the post-update function is the following:
1NK
/(x*; θ0) = hpost -ακ∑∑Ai^e(yk)ki(χk, x?); θh )
i=1 k=1
In Appendix C, we show one way in which this function can approximate any function of
({(x, y)k; k ∈ 1...K}, x?) that is invariant to the ordering of the training datapoints {(x, y)k; k ∈
1	I-V T 1	1	1	∙	. 1 .	1	. . ∙	CT	IC	1 4	1 I >	1 .1
1...K}. We do so by showing that we can select a setting of φ and of each Ai and Bi such that
z? is a vector containing a discretization of x? and frequency counts of the discretized datapoints4.
If z? is a vector that completely describes ({(x, y)i}, x?) without loss of information and because
hpost is a universal function approximator, f(x?; θ0) can approximate any continuous function of
({(x, y)i}, x?) on compact subsets of Rdim(y). It’s also worth noting that the form of the above
equation greatly resembles a kernel-based function approximator around the training points, and a
substantially more efficient universality proof can likely be obtained starting from this premise.
6 Loss Functions
In the previous sections, we showed that a deep representation combined with gradient descent can
approximate any learning algorithm. In this section, we will discuss the requirements that the loss
function must satisfy in order for the results in Sections 4 and 5 to hold. As one might expect, the
main requirement will be for the label to be recoverable from the gradient of the loss.
As seen in the definition of fout in Equation 4, the pre-update function f(x, θ) is given by gpre(z; θg),
where gpre is used for back-propagating information about the label(s) to the learner. As stated in
Equation 2, we require that the error gradient with respect to z to be:
0
ʌ , .. ,
Vz'(yf(χ; θ)) = e(y)
一 e(y) 一
z
where Z = Z
θb
~, _ _ .
φ(x; θft,θb)
0
0
and where e(y) and e(y) must be able to represent [at least] any linear function of the label y.
We define gpre as follows: gpre(z) := [ WWg Wg Wg ] z = WWgZ + WgZ + θbWg.
To make the top term of the gradient equal to 0, we can set Wg to be 0, which causes the pre-update
T
prediction y = f(x, θ) to be 0. Next, note that e(y) = Wg Vy'(y, y) and e(y) = WTVy'(y, y).
Thus, for e(y) to be any linear function of y, We require a loss function for which Vy'(y, 0) is
a linear function Ay, where A is invertible. Essentially, y needs to be recoverable from the loss
function’s gradient. In Appendix E and F, we prove the following two theorems, thus showing that
the standard `2 and cross-entropy losses allow for the universality of gradient-based meta-learning.
Theorem 6.1 The gradient of the Standard mean-squared error objective evaluated at y = 0 is a
linear, invertible function of y.
Theorem 6.2 The gradient of the softmax cross entropy loss with respect to the pre-softmax logits
is a linear, invertible function ofy, when evaluated at 0.
Now consider other popular loss functions whose gradients do not satisfy the label-linearity property.
The gradients of the `1 and hinge losses are piecewise constant, and thus do not allow for univer-
sality. The Huber loss is also piecewise constant in some areas its domain. These error functions
effectively lose information because simply looking at their gradient is insufficient to determine the
label. Recurrent meta-learners that take the gradient as input, rather than the label, e.g. Andrychow-
icz et al. (2016), will also suffer from this loss of information when using these error functions.
7	Experiments
Now that we have shown that meta-learners that use standard gradient descent with a sufficiently
deep representation can approximate any learning procedure, and are equally expressive as recurrent
learners, a natural next question is - is there empirical benefit to using one meta-learning approach
versus another, and in which cases? To answer this question, we next aim to empirically study
4With continuous labels y and mean-squared error `, we require the mild assumption that no two datapoints
may share the same input value x: the input datapoints must be unique.
7
Published as a conference paper at ICLR 2018
P ①」BnbS lueφE
Figure 2: The effect of additional gradient steps at test time when attempting to solve new tasks. The MAML
model, trained with 5 inner gradient steps, can further improve with more steps. All methods are provided with
the same data - 5 examples - where each gradient step is computed using the same 5 datapoints.
98969492
AUB-IrOUB IOllS II>eMLn
sinusoid amplitude
Figure 3: Learning performance on out-of-distribution tasks as a function of the task variability. Recurrent
meta-learners such as SNAIL and MetaNet acquire learning strategies that are less generalizable than those
learned with gradient-based meta-learning.
the inductive bias of gradient-based and recurrent meta-learners. Then, in Section 7.2, we will
investigate the role of model depth in gradient-based meta-learning, as the theory suggests that
deeper networks lead to increased expressive power for representing different learning procedures.
7.1 Empirical S tudy of Inductive Bias
First, we aim to empirically explore the differences between gradient-based and recurrent meta-
learners. In particular, we aim to answer the following questions: (1) can a learner trained with
MAML further improve from additional gradient steps when learning new tasks at test time, or
does it start to overfit? and (2) does the inductive bias of gradient descent enable better few-shot
learning performance on tasks outside of the training distribution, compared to learning algorithms
represented as recurrent networks?
To study both questions, we will consider two simple few-
shot learning domains. The first is 5-shot regression on a
family of sine curves with varying amplitude and phase. We
trained all models on a uniform distribution of tasks with am-
plitudes A ∈ [0.1, 5.0], and phases γ ∈ [0, π]. The sec-
ond domain is 1-shot character classification using the Om-
niglot dataset (Lake et al., 2011), following the training pro-
tocol introduced by Santoro et al. (2016). In our comparisons
to recurrent meta-learners, we will use two state-of-the-art
meta-learning models: SNAIL (Mishra et al., 2018) and meta-
networks (Munkhdalai & Yu, 2017). In some experiments,
we will also compare to a task-conditioned model, which is
trained to map from both the input and the task description
to the label. Like MAML, the task-conditioned model can
be fine-tuned on new data using gradient descent, but is not
trained for few-shot adaptation. We include more experimen-
tal details in Appendix G.
To answer the first question, we fine-tuned a model trained us-
ing MAML with many more gradient steps than used during
20-way, 1-shot Omniglot learning curves
80-
I
M 20-
⅛
MAML in it, train
MAML in it, test
rand in it, train
rand in it, test
20
∂0
number of gradient steps
Figure 4: Comparison of finetuning
from a MAML-initialized network and
a network initialized randomly, trained
from scratch. Both methods achieve
about the same training accuracy. But,
MAML also attains good test accu-
racy, while the network trained from
scratch overfits catastrophically to the
20 examples. Interestingly, the MAML-
initialized model does not begin to over-
fit, even though meta-training used 5
steps while the graph shows up to 100.
meta-training. The results on the sinusoid domain, shown in Figure 2, show that a MAML-learned
initialization trained for fast adaption in 5 steps can further improve beyond 5 gradient steps, espe-
cially on out-of-distribution tasks. In contrast, a task-conditioned model trained without MAML can
easily overfit to out-of-distribution tasks. With the Omniglot dataset, as seen in Figure 4, a MAML
model that was trained with 5 inner gradient steps can be fine-tuned for 100 gradient steps without
leading to any drop in test accuracy. As expected, a model initialized randomly and trained from
scratch quickly reaches perfect training accuracy, but overfits massively to the 20 examples.
8
Published as a conference paper at ICLR 2018
Next, we investigate the second question, aiming to compare MAML with state-of-the-art recurrent
meta-learners on tasks that are related to, but outside of the distribution of the training tasks. All
three methods achieved similar performance within the distribution of training tasks for 5-way 1-shot
Omniglot classification and 5-shot sinusoid regression. In the Omniglot setting, we compare each
method’s ability to distinguish digits that have been sheared or scaled by varying amounts. In the
sinusoid regression setting, we compare on sinusoids with extrapolated amplitudes within [5.0, 10.0]
and phases within [π, 2π]. The results in Figure 3 and Appendix G show a clear trend that MAML
recovers more generalizable learning strategies. Combined with the theoretical universality results,
these experiments indicate that deep gradient-based meta-learners are not only equivalent in repre-
sentational power to recurrent meta-learners, but should also be a considered as a strong contender in
settings that contain domain shift between meta-training and meta-testing tasks, where their strong
inductive bias for reasonable learning strategies provides substantially improved performance.
7.2 Effect of Depth
The proofs in Sections 4 and 5 suggest that gradient descent with deeper representations results
in more expressive learning procedures. In contrast, the universal function approximation theorem
only requires a single hidden layer to approximate any function. Now, we seek to empirically explore
this theoretical finding, aiming to answer the question: is there a scenario for which model-agnostic
meta-learning requires a deeper representation to achieve good performance, compared to the depth
of the representation needed to solve the underlying tasks being learned?
To answer this question, we
will study a simple regres-
sion problem, where the
meta-learning goal is to in-
fer a polynomial function
from 40 input/output data-
points. We use polynomi-
als of degree 3 where the co-
efficients and bias are sam-
pled uniformly at random
within [-1, 1] and the input
values range within [-3, 3].
Similar to the conditions in
the proof, we meta-train and
Figure 5: Comparison of depth while keeping the number of parameters con-
stant. Task-conditioned models do not need more than one hidden layer,
whereas meta-learning with MAML clearly benefits from additional depth.
Error bars show standard deviation over three training runs.
meta-test with one gradient step, use a mean-squared error objective, use ReLU nonlinearities, and
use a bias transformation variable of dimension 10. To compare the relationship between depth
and expressive power, we will compare models with a fixed number of parameters, approximately
40, 000, and vary the network depth from 1 to 5 hidden layers. As a point of comparison to the mod-
els trained for meta-learning using MAML, we trained standard feedforward models to regress from
the input and the 4-dimensional task description (the 3 coefficients of the polynomial and the scalar
bias) to the output. These task-conditioned models act as an oracle and are meant to empirically de-
termine the depth needed to represent these polynomials, independent of the meta-learning process.
Theoretically, we would expect the task-conditioned models to require only one hidden layer, as per
the universal function approximation theorem. In contrast, we would expect the MAML model to re-
quire more depth. The results, shown in Figure 5, demonstrate that the task-conditioned model does
indeed not benefit from having more than one hidden layer, whereas the MAML clearly achieves
better performance with more depth even though the model capacity, in terms of the number of pa-
rameters, is fixed. This empirical effect supports the theoretical finding that depth is important for
effective meta-learning using MAML.
8 Conclusion
In this paper, we show that there exists a form of deep neural network such that the initial weights
combined with gradient descent can approximate any learning algorithm. Our findings suggest that,
from the standpoint of expressivity, there is no theoretical disadvantage to embedding gradient de-
scent into the meta-learning process. In fact, in all of our experiments, we found that the learning
strategies acquired with MAML are more successful when faced with out-of-domain tasks com-
pared to recurrent learners. Furthermore, we show that the representations acquired with MAML
are highly resilient to overfitting. These results suggest that gradient-based meta-learning has a num-
9
Published as a conference paper at ICLR 2018
ber of practical benefits, and no theoretical downsides in terms of expressivity when compared to
alternative meta-learning models. Independent of the type of meta-learning algorithm, we formalize
what it means for a meta-learner to be able to approximate any learning algorithm in terms of its
ability to represent functions of the dataset and test inputs. This formalism provides a new perspec-
tive on the learning-to-learn problem, which we hope will lead to further discussion and research on
the goals and methodology surrounding meta-learning.
Acknowledgments
We thank Sharad Vikram for detailed feedback on the proof, as well as Justin Fu, Ashvin Nair,
and Kelvin Xu for feedback on an early draft of this paper. We also thank Erin Grant for helpful
conversations and Nikhil Mishra for providing code for SNAIL. This research was supported by the
National Science Foundation through IIS-1651843 and a Graduate Research Fellowship, as well as
NVIDIA.
References
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul, and Nando
de Freitas. Learning to learn by gradient descent by gradient descent. In Neural Information Processing
Systems (NIPS), 2016.
Samy Bengio, Yoshua Bengio, Jocelyn Cloutier, and Jan Gecsei. On the optimization of a synaptic learning
rule. In Optimality in Artificial and Biological Neural Networks, 1992.
George Cybenko. Approximation by superpositions of a sigmoidal function. Mathematics of Control, Signals,
andSystems(MCSS), 2(4):303-314,1989.
Yan Duan, John Schulman, Xi Chen, Peter L Bartlett, Ilya Sutskever, and Pieter Abbeel. Rl2: Fast reinforce-
ment learning via slow reinforcement learning. arXiv preprint arXiv:1611.02779, 2016.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep
networks. International Conference on Machine Learning (ICML), 2017a.
Chelsea Finn, Tianhe Yu, Tianhao Zhang, Pieter Abbeel, and Sergey Levine. One-shot visual imitation learning
via meta-learning. Conference on Robot Learning (CoRL), 2017b.
Ken-Ichi Funahashi. On the approximate realization of continuous mappings by neural networks. Neural
networks, 1989.
David Ha, Andrew Dai, and Quoc V Le. Hypernetworks. International Conference on Learning Representa-
tions (ICLR), 2017.
Sepp Hochreiter, A Steven Younger, and Peter R Conwell. Learning to learn using gradient descent. In
International Conference on Artificial Neural Networks. Springer, 2001.
Kurt Hornik, Maxwell Stinchcombe, and Halbert White. Multilayer feedforward networks are universal ap-
proximators. Neural networks, 1989.
Kurt Hornik, Maxwell Stinchcombe, and Halbert White. Universal approximation of an unknown mapping and
its derivatives using multilayer feedforward networks. Neural networks, 1990.
Michael Husken and Christian Goerick. Fast learning for problem classes using knowledge based network
initialization. In International Joint Conference on Neural Networks (IJCNN), 2000.
Brenden M Lake, Ruslan Salakhutdinov, Jason Gross, and Joshua B Tenenbaum. One shot learning of simple
visual concepts. In Conference of the Cognitive Science Society (CogSci), 2011.
Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M Hospedales. Learning to generalize: Meta-learning for
domain generalization. arXiv preprint arXiv:1710.03463, 2017.
Ke Li and Jitendra Malik. Learning to optimize. International Conference on Learning Representations (ICLR),
2017a.
Ke Li and Jitendra Malik. Learning to optimize neural nets. arXiv preprint arXiv:1703.00441, 2017b.
Nikhil Mishra, Mostafa Rohaninejad, Xi Chen, and Pieter Abbeel. A simple neural attentive meta-learner.
International Conference on Learning Representations (ICLR), 2018.
10
Published as a conference paper at ICLR 2018
Tsendsuren Munkhdalai and Hong Yu. Meta networks. International Conference on Machine Learning (ICML),
2017.
Sachin Ravi and Hugo Larochelle. Optimization as a model for few-shot learning. In International Conference
on Learning Representations (ICLR), 2017.
Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, and Timothy Lillicrap. Meta-learning
with memory-augmented neural networks. In International Conference on Machine Learning (ICML), 2016.
Jurgen Schmidhuber. Evolutionary principles in self-referential learning. On learning how to learn: The
meta-meta-... hook.) Diploma thesis, Institut f. Informatik, Tech. Univ. Munich, 1987.
Sho Sonoda and Noboru Murata. Neural network with unbounded activation functions is universal approxima-
tor. Applied and Computational Harmonic Analysis, 2017.
Jane X Wang, Zeb Kurth-Nelson, Dhruva Tirumala, Hubert Soyer, Joel Z Leibo, Remi Munos, Charles
Blundell, Dharshan Kumaran, and Matt Botvinick. Learning to reinforcement learn. arXiv preprint
arXiv:1611.05763, 2016.
11
Published as a conference paper at ICLR 2018
A Supplementary Proofs for 1-Shot Setting
A.1 Proof of Lemma 4.1
While there are likely a number of ways to prove Lemma 4.1 (copied below for convenience), here
we provide a simple, though inefficient, proof of Lemma 4.1.
Lemma 4.1 Let Us assume that e(y) can be chosen to be any linear (but not affine) function of y.
Then, we can choose θft, θh, {Ai ; i > 1}, {Bi ; i < N } such that the function
f(x?; θ0) = hpost (-α X Aie(y)ki(x, x?); θ%)	⑺
can approximate any continuous function of (x, y, x?) on compact subsets of Rdim(y).5
To prove this lemma, We will proceed by showing that We can choose e, θft, and each Ai and Bi such
that the summation contains a complete description of the values of x, x?, and y. Then, because
hpost is a universal function approximator, f(x?, θ0) will be able to approximate any function of x,
x?, and y.
Since A1 = I and BN = I, we will essentially ignore the first and last elements of the sum by
defining B1 := I and AN := I, where is a small positive constant to ensure positive definiteness.
Then, we can rewrite the summation, omitting the first and last terms:
f(x?; θ0) ≈ hpost ^-α X Aie(y)ki(x, x?)； θh)
Next, we will re-index using two indexing variables, j and l, where j will index over the discretiza-
tion of x and l over the discretization of x? .
(J-1L-1	∖
-αXX
Ajle(y)kji(x, x?); θh I
Next, we will define our chosen form of kjl in Equation 8. We show how to acquire this form in the
next section.
Lemma A.1 We can choose θft and each Bjl such that
k ( ?)	1 if discr(x) = ej and discr(x?) = el	()
kjl (x, x ) := 0 otherwise	(8)
where discr(∙) denotes a function that produces a one-hot discretization of its input and e denotes
the 0-indexed standard basis vector.
Now that we have defined the function kjl, we will next define the other terms in the sum. Our goal
is for the summation to contain complete information about (x, x?, y). To do so, we will chose e(y)
to be the linear function that outputs J * L stacked copies of y. Then, we will define Ajl to be a
matrix that selects the copy of y in the position corresponding to (j,l), i.e. in the position j + J * l.
This can be achieved using a diagonal Ajl matrix with diagonal values of 1 + at the positions
corresponding to the kth vector, and elsewhere, where k = (j + J * l) and is used to ensure that
Ajl is positive definite.
As a result, the post-update function is as follows:
-0 -
.
.
.
0
?0	?	?
f(x ； θ ) ≈ hpost (一αv(x, x?, y); θh), where v(x, x?, y) ≈ y ,
0
.
.
.
0
5The assumption with regard to compact subsets of the output space is inherited from the UFA theorem.
12
Published as a conference paper at ICLR 2018
where y is at the position j + J * l within the vector v(x, x*, y), where j satisfies discr(x) = ej
and where l satisfies discr(x?) = el. Note that the vector -αv(x, x?, y) is a complete description
of (x, x? , y) in that x, x? , and y can be decoded from it. Therefore, since hpost is a universal
function approximator and because its input contains all of the information of (x, x?, y), the function
f(x?; θ0) ≈ hpost (-αv(x, x?, y); θh) is a universal function approximator with respect to its inputs
(x, x?, y).
A.2 Proof of Lemma A.1
In this section, we show one way of proving Lemma A.1:
Lemma A.1 We can choose θft and each Bjl such that
?	1	if discr(x) = ej and discr(x?) = el
kjl (x, x ) := 0 otherwise
(8)
where discr(∙) denotes a function that produces a one-hot discretization of its input and e denotes
the 0-indexed standard basis vector.
τ-l 11 . 1	.	7	/	-⅛ ∖	∙ IC 1	7/	∕^k	Zi ∖rT1 TΛrΓ I >	7 /	⅛	Zi Zi I ∖	1	八	/-∖	n ∙	. 1
Recall that kjl (x, x?)	is defined	as φ(x; θft,	θb)TBjTlBjlφ(x?;	θft, θb0 ),	where	θb	= 0.	Since	the
gradient with respect to θb can be chosen to be any linear function of the label y (see Section 6), we
can assume without loss of generality that θb0 6= 0.
I-V T	.111	7	1 I >	Cll
We will choose φ and Bjl as follows:
([disc?]	if θb = 0
φ(∙; θft,θb) = {	0	Bji =	Ejj E + eI
((	otherwise	j
d L discr(∙)
where we use Eik to denote the matrix with a 1 at (i, k) and 0 elsewhere, and I is added to ensure
the positive definiteness of Bjl as required in the construction.
Using the above definitions, we can see that:
ej
0
0
T
if discr(x) =ej
T
otherwise
_ ~, , _ -，、
Bjiφ(x*, θft, θb) ≈
ej
0
0
if discr(x?) =el
otherwise
Thus, we have proved the lemma, showing that we can choose a φ and each Bjl such that:
kji(x, x?) ≈，ej	0 1	0
I 0
1 if discr(x) = ej and discr(x?) = el
otherwise
A.3 Form of linear weight matrices
The goal of this section is to show that We can choose a form of W, W, and W such that We can
simplify the form of z? in Equation 1 into the following:
N
z? = —α X Aie(y)φ(x; θft, θb)T BT Biφ(x*; θft, θb),	(9)
i=1
一	一 . 一 一 T 一.	一	二一	一. 一 一 一
where Ai =	I, Ai	= Mi-ιMi-ι for i	> 1, Bi =	Mi+ι	for i	< N	and BN	= I.
Recall that we decomposed Wi, φ, and the error gradient into three parts, as follows:
	Γ^ ~ Wi	0	0		^φ(∙; θft,θb)^	ʌ , ..	
Wi :=	0	Wi	0	φ(∙; θft,θb) :=		Vz'(y, f(x; θ)) :=	0 e(y)
	0	0	Wi		0 θb		一 e(y) 一
(10)
13
Published as a conference paper at ICLR 2018
where the initial value of θb will be 0. The top components, Wi and φ, have equal dimensions, as
do the middle components, Wi and 0. The bottom components are scalars. As a result, We can see
that Z will likewise be made up of three components, which we will denote as z, z, and z, where,
before the gradient update, Z = QN=I Wiφ(x; θft), z = 0, and z = 0. Lastly, we construct the
top component of the error gradient to be 0, whereas the middle and bottom components, e(y) and
e(y), can be set to be any linear (but not affine) function of y.
Using the above definitions and noting that θft = θft - αVθft' = θft, we can simplify the form of z?
in Equation 1, such that the middle component, z?, is the following:
N (i-1	、八T	ʌ T	( N ∖T ( N ʌ
z? = -α X	Y Wj	YWje(y)φ(x; θft,θb)T Y Wj	Y Wj	φ(X?; θft,θb)
i=1	j=1	j=1	j=i+1	j=i+1
We aim to independently control the backward information flow from the gradient e and the forward
information flow from φ. Thus, choosing all Wi and Wi to be square and full rank, we will set
Wi = MiM-+1	W i = M--IM i,
so that we have
N	i-1
Y Wj = Mi+1	Y Wj=M--ι,
j=i+1	j=1
for i ∈ {1 …N} where MN +ι = I and Mo = I. Then we can again simplify the form of z?:
N
z? = -α X A-e(y)φ(x; θft,θb)TBTB-Φ(x?; θft,θb),	(11)
i=1
where Ai = I, A- = M--ιMT-I for i > 1, Bi = M-+ι for i < N and BN = I.
A.4 Output function
In this section, we will derive the post-update version of the output function fout(∙; θout). Recall
that fout is defined as a neural network that approximates the following multiplexer function and its
derivatives (as shown possible by Hornik et al. (1990)):
z
z
Z
；θout) =I(Z = 0)gpre ɑ z
；θg	+l(z = 0)hpost(z; θh).
(12)
The parameters {θg , θh } are a part of θout, in addition to the parameters required to estimate the
indicator functions and their corresponding products. Since z = 0 and hpost(z) = 0 when the
gradient step is taken, we can see that the error gradients with respect to the parameters in the last
term in Equation 12 will be approximately zero. Furthermore, as seen in the definition of gpre in
Section 6, the value of gpre(z, θg) is also zero, resulting in a gradient of approximately zero for the
first indicator function.6
The post-update value of fout is therefore:
;θoutj ≈ l(z? = 0)gpre ( " z?
；θg + l(z? = 0)hpost(z?; θh) = hpost(z?; θh)
(13)
as long as z? = 0. In Appendix A.1, we can see that z? is indeed not equal to zero.
6To guarantee that g and h are zero when evaluated at x, we make the assumption that gpre and hpost are
neural networks with no biases and nonlinearity functions that output zero when evaluated at zero.
14
Published as a conference paper at ICLR 2018
B Full K-Shot Proof of Universality
In this appendix, we provide a full proof of the universality of gradient-based meta-learning in the
general case with K > 1 datapoints. This proof will share a lot of content from the proof in the
1-shot setting, but we include it for completeness.
We aim to show that a deep representation combined with one step of gradient descent can approx-
imate any permutation invariant function of a dataset and test datapoint ({(x, y)i; i ∈ 1...K}, x?)
for K > 1. Note that K does not need to be small.
We will proceed by construction, showing that there exists a neural network function
f (•; θ) such that f (∙; θ0) approximates ftarget({(x, y)k}, x?) UP to arbitrary precision, where
θ0 = θ - αK PK=I Vθ'(yk, f (Xk; θ))) and ɑ is the learning rate. As We discuss in Section 6,
the loss function ` cannot be any loss function, but the standard cross-entropy and mean-squared er-
ror objectives are both suitable. In this proof, we will start by presenting the form of f and deriving
its value after one gradient step. Then, to show universality, we will construct a setting of the weight
matrices that enables independent control of the information flow coming forward from the inputs
{xk} and x?, and backward from the labels {yk}.
We will start by constructing f. With the same motivation as in Section 4, we will construct f(∙; θ)
as the following:
f(∙; θ) = f。Ut((Y W) Φ(∙; θft,θb); θ。ut).
Φ(∙; θft, θb) represents an input feature extractor with parameters θft and a scalar bias transformation
variable θb, QN=I Wi is a product of square linear weight matrices, fout(∙, θout) is a readout function
at the output, and the learned parameters are θ := {θft, θb, {Wi}, θout}. The input feature extractor
and readout function can be represented with fully connected neural networks with one or more
hidden layers, which we know are universal function approximators, while QiN=1 Wi corresponds
to a set of linear layers. Note that deep ReLU networks act like deep linear networks when the
input and pre-synaptic activations are non-negative. We will later show that this is indeed the case
within these linear layers, meaning that the neural network function f is fully generic and can be
represented by deep ReLU networks, as visualized in Figure 1.
Next, we will derive the form of the post-update prediction f(x?; θ0). Let Zk = (QN=I Wi) φ(xk)
and we denote its gradient with respect to the loss as VZk' = e(xk, Zk). The gradient with respect
to any of the weight matrices Wi for a single datapoint (x, y) is given by
VWi'(y,f(χk,θ))= (YWj) e(χ,y)Φ(χ;θft,θb)τ ( ∏ Wj).
j=1	j=i+1
Therefore, the post-update value of QiN=1 Wi0 = QiN=1(Wi - αKK Pk VWi) is given by
N	K N ∕i-1	∖∕iT	∖ T	/ N \T/ N ∖
∏ Wi-K XXl ∏ Wjll	∏ Wj) e(xk, y )φ(xk;	θft,θb)τ( ∏ Wj)	I ∏ Wj)-O(α2),
i=1	k=1 i=1 j=1	j=1	j=i+1	j=i+1
where we move the summation over k to the left and where we will disregard the last term, assuming
that α is comparatively small such that α2 and all higher order terms vanish. In general, these
terms do not necessarily need to vanish, and likely would further improve the expressiveness of the
gradient update, but we disregard them here for the sake of the simplicity of the derivation. Ignoring
these terms, we now note that the post-update value of z? when x? is provided as input into f (∙; θ0)
is given by
N
Z? = ∏ Wiφ(x?; θft,θb)	(14)
i=1
K N ∕i-1	∖∕i-1	∖ T	/ N	∖T(	N ∖
-αxx ∏Wj	∏Wj	e(xk, yk)φ(xk;	θft, θb)T ∏	Wj	∏	Wj	φ(x?;	θf0t,	θb0),
k=1 i=1 j=1	j=1	j=i+1	j=i+1
15
Published as a conference paper at ICLR 2018
O ,	.	,
and f(x? ； θ) = fout(z*; θ ut).
Our goal is to show that that there exists a setting of Wi , fout, and φ for which the above func-
tion, f(x?, θ0), can approximate any function of ({(x, y)k}, x?). To show universality, we will aim
independently control information flow from {xk}, from {yk}, and from x? by multiplexing for-
ward information from {xk} and x? and backward information from {yk}. We will achieve this by
decomposing Wi , φ, and the error gradient into three parts, as follows:
	Γ^ ~ Wi	0	0
Wi :=	0	Wi	0
	0	0	Wi
-φ(∙; θft,θb)
φ(∙; θft,θb) :=	0
θb
0
VZk'(yk,f(χk; θ)) := e(yk)
一 e(yk) .
(15)
where the initial value of θb will be 0. The top components all have equal numbers of rows, as do the
middle components. As a result, we can see that zk will likewise be made up of three components,
which We will denote as Zk, Zk, and Zk. Lastly, We construct the top component of the error gradient
to be 0, whereas the middle and bottom components, e(yk) and e(yk), can be set to be any linear
(but not affine) function of yk . We discuss how to achieve this gradient in the latter part of this
section when we define fout and in Section 6.
In Appendix A.3, we show that we can choose a particular form of Wi, Wi, and Wi that will simplify
the products of Wj- matrices in Equation 14, such that we get the following form for Z?:
1KN
z? = -α1-. XX Aie(yk)φ(xk; θft, θb)τBTBiφ(x*; θft, θb),	(16)
K
k=1 i=1
where A1 = I, BN = I, Ai can be chosen to be any symmetric positive-definite matrix, and
Bi can be chosen to be any positive definite matrix. In Appendix D, we will further show that
these definitions of the weight matrices satisfy the condition that their activations are non-negative,
meaning that the model f can be represented by a generic deep network with ReLU nonlinearities.
Finally, we need to define the function fout at the output. When a training input xk is passed in, we
need fout to propagate information about its corresponding label yk as defined in Equation 15. And,
when the test input x? is passed in, we need a function defined on Z?. Thus, we will define fout as
a neural network that approximates the following multiplexer function and its derivatives (as shown
possible by Hornik et al. (1990)):
z
Z
Z
1(Z = 0)gpre Q Z
；θg +1(Z = 0)hpost(Z; θh),
(17)
where gprɛ is a linear function with parameters θg such that Vz' = e(y) satisfies Equation 15
(see Section 6) and hpost(∙; θh) is a neural network with one or more hidden layers. As shown in
Appendix A.4, the post-update value of fout is
fout Π Z?	； θoU) = hpost(Z?; θh).	(18)
Now, combining Equations 16 and 18, we can see that the post-update value is the following:
1KN
/(X?； θ0) = hpost -aK∑ΣAi^e(yk)φ(xk; θft, θb)TBTBiφ(x? θft, θb)； θh )	(19)
k=1 i=1
In summary, so far, we have chosen a particular form of weight matrices, feature extractor, and
output function to decouple forward and backward information flow and recover the post-update
function above. Now, our goal is to show that the above function f(x?; θ0) is a universal learning
algorithm approximator, as a function of ({(x, y)k}, x?). For notational clarity, we will use use
ki(xk, x?) := φ(xk; θft, θb)TBiTBiφ(x?; θft, θb0 ) to denote the inner product in the above equation,
noting that it can be viewed as a type of kernel with the RKHS defined by Biφ(x; θft, θb).7 The
7Due to the symmetry of kernels, this requires interpreting θb as part of the input, rather than a kernel
hyperparameter, so that the left input is (xk, θb) and the right one is (x?, θb0 ).
16
Published as a conference paper at ICLR 2018
connection to kernels is not in fact needed for the proof, but provides for convenient notation and an
interesting observation. We can now simplify the form of f (x?, θ0) as the following equation:
1NK
f^X θ0) = hpost -ακ∑∑Aieyk)ki(χk, x?); θh )	(20)
i=1 k=1
Intuitively, Equation 20 can be viewed as a sum of basis vectors Aie(yk) weighted by ki(xk, x?),
which is passed into hpost to produce the output. In Appendix C, we show that we can choose e,
θft, θh, each Ai, and each Bi such that Equation 20 can approximate any continuous function of
({(x, y)k}, x?) on compact subsets of Rdim(y). As in the one-shot setting, the bias transformation
variable θb plays a vital role in our construction, as it breaks the symmetry within ki (x, x?). Without
such asymmetry, it would not be possible for our constructed function to represent any function of
x and x? after one gradient step.
In conclusion, we have shown that there exists a neural network structure for which f(x?; θ0) is a
universal approximator of ftarget({(x, y)k},x?).
C S upplementary Proof for K-Shot Setting
In Section 5 and Appendix B, we showed that the post-update function f(x?; θ0) takes the following
form:
1NK
/(x?; θ0) = hpost -ακ∑∑Ai^e(yk)ki(χk, x?); θh )
i=1 k=1
In this section, we aim to show that the above form of f(x?; θ0) can approximate any function of
{(x, y)k; k ∈ 1...K} and x? that is invariant to the ordering of the training datapoints {(x, y)k; k ∈
1...K}. The proof will be very similar to the one-shot setting proof in Appendix A.1
Similar to Appendix A.1, we will ignore the first and last elements of the sum by defining B1 to be
I and AN to be I, where is a small positive constant to ensure positive definiteness. We will
then re-index the first summation over i = 2...N - 1 to instead use two indexing variables j and l
as follows:
(1 J-1L-1 K	ʌ
V XXXAjle(yk)kji(xk, x?); θh I
j=0 l=0 k=1
As in Appendix A.1, we will define the function kjl to be an indicator function over the values ofxk
and x?. In particular, we will reuse Lemma A.1, which was proved in Appendix A.2 and is copied
below:
Lemma A.1 We can choose θft and each Bjl such that
k ( ?)	1 if discr(x) = ej and discr(x?) = el	()
kjl (x, x ) := 0 otherwise	(8)
where discr(∙) denotes a function that produces a one-hot discretization of its input and e denotes
the 0-indexed standard basis vector.
Likewise, we will chose e(y k) to be the linear function that outputs J* L stacked copies of Nk. Then,
we will define Ajl to be a matrix that selects the copy of yk in the position corresponding to (j, l),
i.e. in the position j + J * l. This can be achieved using a diagonal Ajl matrix with diagonal values
of 1 + at the positions corresponding to the nth vector, and elsewhere, where n = (j + J* l) and
is used to ensure that Ajl is positive definite.
17
Published as a conference paper at ICLR 2018
As a result, the post-update function is as follows:
-0 -
.
.
.
ʌ	1	1 K	ʌ	0
f(x*; θ0) ≈ hpost (-ακfv(xk, x?, yk); θh), where v(x, x*, y) ≈ y ,
k=	k=1	)	0
.
.
.
0
where Zk is at the position j + J* l within the vector v(xk, x?, Zk), where j satisfies discr(xk) = ej
and where l satisfies discr(x?k) = el.
For discrete, one-shot labels Zk, the summation over v amounts to frequency counts of the triplets
(xk, x?, Zk). In the setting with continuous labels, we cannot attain frequency counts, as we do not
have access to a discretized version of the label. Thus, we must make the assumption that no two
datapoints share the same input value xk. With this assumption, the summation over v will contain
the output values Zk0 at the index corresponding to the value of (xk0, x?). For both discrete and con-
tinuous labels, this representation is redundant in x? , but nonetheless contains sufficient information
to decode the test input x? and set of datapoints {(x, Z)k} (but not the order of datapoints).
Since hpost is a universal function approximator and because its input contains all of the information
of ({(x, y)k}, x?), the function f(x?; θ0) ≈ hpost (一α-K PK=I V(Xk, x?, y); θh) is a universal
function approximator with respect to {(x, Z)k} and x?.
D	Deep ReLU Networks
In this appendix, we show that the network architecture with linear layers analyzed in the Sections 4
and 5 can be represented by a deep network with ReLU nonlinearities. We will do so by showing
that the input and activations within the linear layers are all non-negative.
First, consider the input φ(∙; θft, θb) and φ(∙; θft, θ(). The input φ(∙; θft, θb) is defined to consist of
〜
three terms. The top term, φ is defined in Appendices A.2 and C to be a discretization (which is
non-negative) both before and after the parameters are updated. The middle term is defined to be
a constant 0. The bottom term, θb, is defined to be 0 before the gradient update and is not used
afterward.
Next, consider the weight matrices, Wi . To determine that the activations are non-negative, it is
now sufficient to show that the products WN, WN-1WN, ..., QiN=1 Wi are positive semi-definite.
To do so, we need to show that the products QN= j Wi, QN=j 卬i, and QN=j Wi are PSD for j =
1, ..., N. In Appendix A.2, each Bi = Mi+1 is defined to be positive definite; and in Appendix A.3,
we define the products QN=j+ι Wi = Mj + 1. Thus, the conditions on the products of Wzi are
satisfied. In Appendices A.1 and C, each Ai are defined to be symmetric positive definite matrices.
In Appendix A.3, we define Wi = M-1γMi where Ai = M —M：_1. Thus, we can see that
each Mi is also symmetric positive definite, and therefore, each Wi is positive definite. Finally, the
purpose of the weights Wi is to provide nonzero gradients to the input θb, thus a positive value for
each Wi will suffice.
E Proof of Theorem 6.1
Here we provide a proof of Theorem 6.1:
Theorem 6.1 The gradient of the standard mean-squared error objective evaluated at y = 0 is a
linear, invertible function of Z.
For the standard mean-squared error objective, '(y,y) =	2∣∣y 一 yk2, the gradient is
V^'(y, 0) = -y, which satisfies the requirement, as A = -I is invertible.
18
Published as a conference paper at ICLR 2018
1009080706050403020
AUBJrmE4->0LISII>EMLn
MAML1 train
--MAML1 test
random, train
random, test
Figure 6: Left: Another comparison with out-of-distribution tasks, varying the phase of the sine curve. There
is a clear trend that gradient descent enables better generalization on out-of-distribution tasks compared to
the learning strategies acquired using recurrent meta-learners such as SNAIL. Right: Here is another example
that shows the resilience of a MAML-learned initialization to overfitting. In this case, the MAML model was
trained using one inner step of gradient descent on 5-way, 1-shot Omniglot classification. Both a MAML and
random initialized network achieve perfect training accuracy. As expected, the model trained from scratch
catastrophically overfits to the 5 training examples. However, the MAML-initialized model does not begin to
overfit, even after 100 gradient steps.
F	Proof of Theorem 6.2
Here we provide a proof of Theorem 6.2:
Theorem 6.2 The gradient of the softmax cross entropy loss with respect to the pre-softmax logits
is a linear, invertible function of y, when evaluated at 0.
For the standard softmax cross-entropy loss function with discrete, one-hot labels y, the gradient
is Vy'(y, 0) = C - y where C is a constant vector of value C and where We are denoting y as the
Pre-Softmax logits. Since y is a one-hot representation, we can rewrite the gradient as Vy'(y, 0)=
(C - I)y, where C is a constant matrix with value c. Since A = C - I is invertible, the cross
entropy loss also satisfies the above requirement. Thus, we have shown that both of the standard
supervised objectives of mean-squared error and cross-entropy allow for the universality of gradient-
based meta-learning.
G	Additional Experimental Details
In this section, we provide two additional comparisons on an out-of-distribution task and using
additional gradient steps, shown in Figure 6. We also include additional experimental details.
G.1 Inductive Bias Experiments
For Omniglot, all meta-learning methods were trained using code provided by the authors of the
respective papers, using the default model architectures and hyperparameters. The model embed-
ding architecture was the same across all methods, using 4 convolutional layers with 3 × 3 kernels,
64 filters, stride 2, batch normalization, and ReLU nonlinearities. The convolutional layers were
followed by a single linear layer. All methods used the Adam optimizer with default hyperparame-
ters. Other hyperparameter choices were specific to the algorithm and can be found in the respective
papers. For MAML in the sinusoid domain, we used a fully-connected network with two hidden
layers of size 100, ReLU nonlinearities, and a bias transformation variable of size 10 concatenated
to the input. This model was trained for 70,000 meta-iterations with 5 inner gradient steps of size
α = 0.001. For SNAIL in the sinusoid domain, the model consisted of 2 blocks of the following: 4
dilated convolutions with 2 × 1 kernels 16 channels, and dilation size of 1,2,4, and 8 respectively,
then an attention block with key/value dimensionality of 8. The final layer is a 1 × 1 convolution to
the output. Like MAML, this model was trained to convergence for 70,000 iterations using Adam
with default hyperparameters. We evaluated the MAML and SNAIL models for 1200 trials, report-
ing the mean and 95% confidence intervals. For computational reasons, we evaluated the MetaNet
model using 600 trials, also reporting the mean and 95% confidence intervals.
Following prior work (Santoro et al., 2016), we downsampled the Omniglot images to be 28 × 28.
When scaling or shearing the digits to produce out-of-domain data, we transformed the original
105 × 105 Omniglot images, and then downsampled to 28 × 28.
19
Published as a conference paper at ICLR 2018
G.2 Depth Experiments
In the depth comparison, all models were trained to convergence using 70,000 iterations. Each
model was defined to have a fixed number of hidden units based on the total number of parameters
(fixed at around 40,000) and the number of hidden layers. Thus, the models with 2, 3, 4, and 5
hidden layers had 200, 141, 115, and 100 units per layer respectively. For the model with 1 hidden
layer, we found that using more than 20, 000 hidden units, corresponding to 40, 000 parameters,
resulted in poor performance. Thus, the results reported in the paper used a model with 1 hidden
layer with 250 units which performed much better. We trained each model three times and report the
mean and standard deviation of the three runs. The performance of an individual run was computed
using the average over
20