Published as a conference paper at ICLR 2018
When is a Convolutional Filter Easy to
Learn?
Simon S. Du	Jason D. Lee
Carnegie Mellon University University of Southern California
ssdu@cs.cmu.edu	jasonlee@marshall.usc.edu
Yuandong Tian
Facebook AI Research
yuandong@fb.com
Ab stract
We analyze the convergence of (stochastic) gradient descent algorithm for learn-
ing a convolutional filter with Rectified Linear Unit (ReLU) activation function.
Our analysis does not rely on any specific form of the input distribution and our
proofs only use the definition of ReLU, in contrast with previous works that are
restricted to standard Gaussian input. We show that (stochastic) gradient descent
with random initialization can learn the convolutional filter in polynomial time
and the convergence rate depends on the smoothness of the input distribution and
the closeness of patches. To the best of our knowledge, this is the first recovery
guarantee of gradient-based algorithms for convolutional filter on non-Gaussian
input distributions. Our theory also justifies the two-stage learning rate strategy in
deep neural networks. While our focus is theoretical, we also present experiments
that justify our theoretical findings.
1 Introduction
Deep convolutional neural networks (CNN) have achieved the state-of-the-art performance in
many applications such as computer vision (Krizhevsky et al., 2012), natural language process-
ing (Dauphin et al., 2016) and reinforcement learning applied in classic games like Go (Silver et al.,
2016). Despite the highly non-convex nature of the objective function, simple first-order algorithms
like stochastic gradient descent and its variants often train such networks successfully. On the other
hand, the success of convolutional neural network remains elusive from an optimization perspective.
When the input distribution is not constrained, existing results are mostly negative, such as hard-
ness of learning a 3-node neural network (Blum & Rivest, 1989) or a non-overlap convolutional
filter (Brutzkus & Globerson, 2017). Recently, Shamir (2016) showed learning a simple one-layer
fully connected neural network is hard for some specific input distributions.
These negative results suggest that, in order to explain the empirical success of SGD for learning
neural networks, stronger assumptions on the input distribution are needed. Recently, a line of
research (Tian, 2017; Brutzkus & Globerson, 2017; Li & Yuan, 2017; Soltanolkotabi, 2017; Zhong
et al., 2017) assumed the input distribution be standard Gaussian N(0, I) and showed (stochastic)
gradient descent is able to recover neural networks with ReLU activation in polynomial time.
One major issue of these analysis is that they rely on specialized analytic properties of the Gaussian
distribution (c.f. Section 1.1) and thus cannot be generalized to the non-Gaussian case, in which
real-world distributions fall into. For general input distributions, new techniques are needed.
In this paper we consider a simple architecture: a convolution layer, followed by a ReLU activation
function, and then average pooling. Formally, we let x ∈ Rd be an input sample, e.g., an image,
we generate k patches from x, each with size p: Z ∈ Rp×k where the i-th column is the i-th patch
generated by some known function Zi = Zi(x). For a filter with size 2 and stride 1, Zi(x) is the i-th
and (i + 1)-th pixels. Since for convolutional filters, we only need to focus on the patches instead
of the input, in the following definitions and theorems, we will refer Z as input and let Z as the
distribution of Z: (σ(x) = max(x, 0) is the ReLU activation function)
1
Published as a conference paper at ICLR 2018
Input X
Figure 1: (a) Architecture of the network We are considering. Given input X, We extract its patches
{Zi} and send them to a shared weight vector w. The outputs are then sent to ReLU and then
summed to yield the final label (and its estimation). (b)-(c) Two conditions we proposed for con-
vergence. We want the data to be (b) highly correlated and (c) concentrated more on the direction
aligned with the ground truth vector w*.
1 上,，丁	∖
f(w, Z) = k£b (w>Zi) .	(1)
i=1
See Figure 1 (a) for a graphical illustration. Such architectures have been used as the first layer of
many works in computer vision (Lin et al., 2013; Milletari et al., 2016). We address the realizable
case, where training data are generated from (1) with some unknown teacher parameter w* under
input distribution Z. Consider the '2 loss ' (w, Z) = 1 (f (w, Z) - f (w*, Z))2. We learn by
(stochastic) gradient descent, i.e.,
wt+1 = wt - ηtg(wt )	(2)
where ηt is the step size which may change over time and g (wt ) is a random function where its
expectation equals to the population gradient E [g(w)] = EZ〜Z [V' (w, Z)]. The goal of our anal-
ysis is to understand the conditions where w → w*, if w is optimized under (stochastic) gradient
descent.
In this setup, our main contributions are as follows:
•	Learnability of Filters: We show if the input patches are highly correlated (Section 3),
i.e., θ (Zi , Zj ) ≤ ρ for some small ρ > 0, then gradient descent and stochastic gradient
descent with random initialization recovers the filter in polynomial time.1 Furthermore,
strong correlations imply faster convergence. To the best of our knowledge, this is the first
recovery guarantee of randomly initialized gradient-based algorithms for learning filters
(even for the simplest one-layer one-neuron network) on non-Gaussian input distribution,
answering an open problem in (Tian, 2017).
•	Distribution-Aware Convergence Rate. We formally establish the connection between
the smoothness of the input distribution and the convergence rate for filter weights recov-
ery where the smoothness in our paper is defined as the ratio between the largest and the
least eigenvalues of the second moment of the activation region (Section 2). We show that
a smoother input distribution leads to faster convergence, and Gaussian distribution is a
special case that leads to the tightest bound. This theoretical finding also justifies the two-
stage learning rate strategy proposed by (He et al., 2016; Szegedy et al., 2017) if the step
size is allowed to change over time.
1.1	Related Works
In recent years, theorists have tried to explain the success of deep learning from different perspec-
tives. From optimization point of view, optimizing neural network is a non-convex optimization
1 Note since in this paper we focus on continuous distribution over Z, our results do not conflict with previous
negative results(Blum & Rivest, 1989; Brutzkus & Globerson, 2017) whose constructions rely on discrete
distributions.
2
Published as a conference paper at ICLR 2018
problem. Pioneered by Ge et al. (2015), a class of non-convex optimization problems that sat-
isfy strict saddle property can be optimized by perturbed (stochastic) gradient descent in polyno-
mial time (Jin et al., 2017).2 This motivates the research of studying the landscape of neural net-
works (Soltanolkotabi et al., 2017; Kawaguchi, 2016; Choromanska et al., 2015; Hardt & Ma, 2016;
Haeffele & Vidal, 2015; Mei et al., 2016; Freeman & Bruna, 2016; Safran & Shamir, 2016; Zhou &
Feng, 2017; Nguyen & Hein, 2017) However, these results cannot be directly applied to analyzing
the convergence of gradient-based methods for ReLU activated neural networks.
From learning theory point of view, it is well known that training a neural network is hard in the
worst cases (Blum & RivesL 1989; Livm et al., 2014; s´ma, 2002; Shalev-ShWartz et al., 2017a;b)
and recently, Shamir (2016) showed either “niceness” of the target function or of the input dis-
tribution alone is sufficient for optimization algorithms used in practice to succeed. With some
additional assumptions, many works tried to design algorithms that provably learn a neural network
with polynomial time and sample complexity (Goel et al., 2016; Zhang et al., 2016; 2015; Sedghi &
Anandkumar, 2014; Janzamin et al., 2015; Gautier et al., 2016; Goel & Klivans, 2017). However,
these algorithms are tailored for certain architecture and cannot explain why (stochastic) gradient
based optimization algorithms work well in practice.
Focusing on gradient-based algorithms, a line of research analyzed the behavior of (stochastic) gradi-
ent descent for Gaussian input distribution. Tian (2017) showed population gradient descent is able
to find the true weight vector with random initialization for one-layer one-neuron model. Brutzkus
& Globerson (2017) showed population gradient descent recovers the true weights of a convolution
filter with non-overlapping input in polynomial time. Li & Yuan (2017) showed SGD can recover the
true weights of a one-layer ResNet model with ReLU activation under the assumption that the spec-
tral norm of the true weights is bounded by a small constant. All the methods use explicit formulas
for Gaussian input, which enable them to apply trigonometric inequalities to derive the convergence.
With the same Gaussian assumption, Soltanolkotabi (2017) shows that the true weights can be ex-
actly recovered by projected gradient descent with enough samples in linear time, if the number of
inputs is less than the dimension of the weights.
Other approaches combine tensor approaches with assumptions of input distribution. Zhong et al.
(2017) proved that with sufficiently good initialization, which can be implemented by tensor method,
gradient descent can find the true weights of a 3-layer fully connected neural network. However,
their approach works with known input distributions. Soltanolkotabi (2017) used Gaussian width
(c.f. Definition 2.2 of (Soltanolkotabi, 2017)) for concentrations and his approach cannot be directly
extended to learning a convolutional filter.
In this paper, we adopt a different approach that only relies on the definition of ReLU. We show as
long as the input distribution satisfies weak smoothness assumptions, we are able to find the true
weights by SGD in polynomial time. Using our conclusions, we can justify the effectiveness of
large amounts of data (which may eliminate saddle points), two-stage and adaptive learning rates
used by He et al. (2016); Szegedy et al. (2017), etc.
1.2	Organization
This paper is organized as follows. In Section 2, we analyze the simplest one-layer one-neuron
model where we state our key observation and establish the connection between smoothness and
convergence rate. In Section 3, we discuss the performance of (stochastic) gradient descent for
learning a convolutional filter. We provide empirical illustrations in Section 4 and conclude in
Section 5. We place most of our detailed proofs in the Appendix.
1.3	Notations
Let k∙k 2 denote the Euclidean norm of a finite-dimensional vector. For a matrix A, We use λmaχ (A)
to denote its largest singular value and λmin (A) its smallest singular value. Note if A is a positive
semidefinite matrix, λmax (A) and λmin (A) represent the largest and smallest eigenvalues of A,
respectively. Let O(∙) and Θ(∙) denote the standard Big-O and Big-Thetanotations that hide absolute
2Gradient descent is not guaranteed to converge to a local minima in polynomial time (Du et al., 2017; Lee
et al., 2016).
3
Published as a conference paper at ICLR 2018
Figure 2: (a) The four regions considered in our analysis. (b) Illustration of L (φ), Y(φ) and
L-w* (φ) defined in Definition 2.1 and Assumption 2.1.
constants. We assume the gradient function is uniformly bounded, i.e., There exists B > 0 such that
Ilg(W) k2 ≤ B. This condition is satisfied as long as patches, W and noise are all bounded.
2	Warm Up: Analyzing One-Layer ONE-NEURON Model
Before diving into the convolutional filter, we first analyze the special case for k = 1, which is
equivalent to the one-layer one-neuron architecture. The analysis in this simple case will give us
insights for the fully general case. For the ease of presentation, we define following two events and
corresponding second moments
S(w, w*) = {Z : w>Z ≥ 0, w>Z ≥ 0} , S(w, —w*) = {Z : w>Z ≥ 0, w>Z ≤ 0} ,	(3)
Aw,w* = E [ZZ>I{S(w, w*)}] , Aw,-w* = E [ZZ>I{S(w,-w*)}].
where I {∙} is the indicator function. Intuitively, S(w, w*) is the joint activation region of W and
w* and S(w, -w*) is the joint activation region of W and —w*. See Figure 2 (a) for the graphical
illustration. With some simple algebra we can derive the population gradient.
E [▽' (w, Z)] = Aw,w* (w — w*) + Aw,-w* w.
One key observation is We can write the inner product Rw' (w), W — w*i as the sum of two
non-negative terms (c.f. Lemma A.1). This observation directly leads to the following Theorem 2.1.
Theorem 2.1. Suppose for any w1, w2 with θ (w1, w2) < π, E ZZ>I {S(w, w*)}	0 and the
initialization w0 satisfies ` (w0) < ` (0) then gradient descent algorithm recovers w*.
The first assumption is about the non-degeneracy of input distribution. For θ (w1, w2 ) < π, one
case that the assumption fails is that the input distribution is supported on a low-dimensional space,
or degenerated. The second assumption on the initialization is to ensure that gradient descent does
not converge to w = 0, at which the gradient is undefined. This is a general convergence theorem
that holds for a wide class of input distribution and initialization points. In particular, it includes
Theorem 6 of (Tian, 2017) as a special case. If the input distribution is degenerate, i.e., there
are holes in the input space, the gradient descent may stuck around saddle points and we believe
more data are needed to facilitate the optimization procedure This is also consistent with empirical
evidence in which more data are helpful for optimization.
2.1	Convergence Rate of One-Layer One-Neuron Model
In the previous section we showed if the distribution is regular and the weights are initialized appro-
priately, gradient descent recovers the true weights when it converges. In practice we also want to
know how many iterations are needed. To characterize the convergence rate, we need some quanti-
tative assumptions. We note that different set of assumptions will lead to a different rate and ours is
only one possible choice. In this paper we use the following quantities.
4
Published as a conference paper at ICLR 2018
Definition 2.1 (The Largest/Smallest eigenvalue Values of the Second Moment on Intersection of
two Half Spaces). For φ ∈ [0, π], define
γ(φ) =	min	λmin (Aw,w* ) ,	L(φ) =	max	λmaχ (Aw,w* ),
w"w,w*=φ	w"w,w*=φ
These two conditions quantitatively characterize the angular smoothness of the input distribution.
For a given angle φ, if the difference between γ(φ) and L(φ) is large then there is one direction has
large probability mass and one direction has small probability mass, meaning the input distribution
is not smooth. On the other hand, if γ(φ) and L(φ) are close, then all directions have similar
probability mass, which means the input distribution is smooth. The smoothest input distributions
are rotationally invariant distributions (e.g. standard Gaussian) which have γ(φ) = L(φ). For
analogy, we can think of L(φ) as Lipschitz constant of the gradient and γ(φ) as the strong convexity
parameter in the optimization literature but here we also allow they change with the angle. Also
observe that when φ = π, γ(φ) = L(φ) = 0 because the intersection has measure 0 and both γ(φ)
and L(φ) are monotonically decreasing.
Our next assumption is on the growth of Aw,-w*. Note that when θ (w, w*) = 0, then Aw,-w* =
0 because the intersection between W and -w* has 0 measure. Also, Aw,-w* grows as the angle
between W and W becomes larger.
In the following, we assume the operator norm of Aw,-w* increases smoothly with respect to the
angle. The intuition is that as long as input distribution bounded probability density with respect
to the angle, the operator norm of Aw,-w* is bounded. We show in Theorem A.1 that β = 1 for
rotational invariant distribution and in Theorem A.2 that β = p for standard Gaussian distribution.
Assumption 2.1. We assume there exists β > 0 that for 0 ≤ φ ≤ π∕2, L-w* (φ)，
maxw,θ(w,w* )≤φ λmax (Aw,-w*)≤βφ.
Now we are ready to state the convergence rate.
Theorem 2.2. Suppose the initialization wo satisfies ∣∣wo — w/b < ∣∣w*∣∣2∙ Denote φt =
arcsin (kwtw,k2) then if step size is set as 0 ≤ η ≤ min°≤φ≤φt 2Lφ)+)4β)2, we have for
t = 1, 2, . . .
kwt+ι- w*k2 ≤ (1 - ηtγ(φt)) kwt- w*k2.
Note both γ(φ) and L(φ) increases as φ decreases so we can choose a constant step size
ηt = Θ ((L0φ+βρ^). This theorem implies that We can find the e-close solution of w* in
O ((L(O)++))log (1)) iterations. It also suggests a direct relation between the smoothness of the
distribution and the convergence rate. For smooth distribution where γ(φ) and L(φ) are close and β
is small then (L(O)+：)is relatively small and we need fewer iterations. On the other hand, if L(φ)
or β is much larger than γ(φ), we will need more iterations. We verify this intuition in Section 4.
If we are able to choose the step sizes adaptively ηt
θ ((L(φ⅞⅛2),Iike using meth-
ods proposed by Lin & Xiao (2014), we may improve the computational complexity to
O (maxφ≤φo "£(+：)log (ɪ)). Thisjustifies the use of two-stage learning rate strategy proposed
by He et al. (2016); Szegedy et al. (2017) where at the beginning we need to choose learning to be
small because »「*)2 is small and later we can choose a large learning rate because as the
2(L(φ0)+2β)2
angle between Wt and w/ becomes smaller, Q(TYφt)y 42 becomes bigger.
2(L(φt)+2β)
The theorem requires the initialization satisfying ∣wO - w* ∣2 < ∣w* ∣2, which can be achieved by
random initialization with constant success probability. See Section 3.2 for a detailed discussion.
3	Main Results for Learning a Convolutional Filter
In this section we generalize ideas from the previous section to analyze the convolutional filter. First,
for given w and w* we define four events that divide the input space of each patch Zi . Each event
5
Published as a conference paper at ICLR 2018
corresponds to a different activation region induced by W and w*, similar to (3).
S(w, w) = {Zi	:	w>Zi	≥	0, w>Zi ≥	0}	,	S(w, -wj = {Zi	: w>Zi	≥	0, w>Zi ≤	0},
S(-w, -W) = {Zi	:	w>Zi	≤	0, w>Zi ≤	0}	,	S(-w, w) = {Zi	: w>Zi	≤	0, w>Zi ≥	0}.
Please check Figure 2 (a) again for illustration. For the ease of presentation we also define the
average over all patches in each region
1k	1k
ZS(w,w*) = k XZiI {s(W, WJJ
,ZS(w,-w*) = kX ZiI{S(w,-w*)J ,
k i=1	k i=1
1k
ZS(-w,w*) = £ EZiI (S(-w, WJi}.
i=1
Next, we generalize the smoothness conditions analogue to Definition 2.1 and Assumption 2.1. Here
the smoothness is defined over the average of patches.
Assumption 3.1. For φ ∈ [0, π], define
γ(φ) = w:d(mW*) = 0 λmin (E [zS(w,w*)Z>(w,w*)D ,
L(φ)= w,θ(m,aX)=φ λmax (E hZS(W,w*)Z>(W,w*)i).
(4)
We assume for all 0 ≤ φ ≤ ∏∕2, maxw,θ(w,w*)=φ λmaχ (E IZS(W,-w*)Z>(w,-w*J) ≤ βΦ for
some β > 0.
The main difference between the simple one-layer one-neuron network and the convolution filter
is two patches may appear in different regions. For a given sample, there may exists patch Zi and
Zj such that Zi ∈ S(w, w) and Zj ∈ S(w, -w)∙ and their interaction plays an important role
in the convergence of (stochastic) gradient descent. Here we assume the second moment of this
interaction, i.e., cross-covariance, also grows smoothly with respect to the angle.
Assumption 3.2. We assume there exists Lcross > 0 such that
max	λmax E
w:θ(w,w* )≤φ	∖
w*) ZS(w,-w*)	+λmax E
+λmax E
,-w*)ZS(-w,w*)	≤ Lcross φ.
,w*)ZS(-w,w*)
First note if φ = 0, then ZS(w,-w*) and ZS(-w,w*) has measure 0 and this assumption models the
growth of cross-covariance. Next note this Lcross represents the closeness of patches. If Zi and Zj
are very similar, then the joint probability density of Zi ∈ S(w, w*b and Zj ∈ S(w, -w*)j∙ is
small which implies Lcross is small. In the extreme setting, Z1 = . . . = Zk, we have Lcross = 0
because in this case the events (Zi ∈ S(w, w)} ∩ {Zj∙ ∈ S(w, -w*j}, {Zi ∈ S(w, w)} ∩
(Zj ∈ S(-w, w*)j∙} and (Zi ∈ S(w, -w*}} ∩ {Zj∙ ∈ S(-w, w*)j∙} all have measure 0.
Now we are ready to present our result on learning a convolutional filter by gradient descent.
Theorem 3.1. If the initialization satisfies ∣∣wo — w/^ < ∣∣w*∣∣2 and denote
arcsin (，；3六"2) which satisfies γ(Φ0) > 6Lcross∙ Then if we choose
φt	=
ηt	≤
min0≤φ≤φt
Y(0)-6L
cross
2(L(φ)+10Lcross+4β)2 ,
we havefor t = 1, 2,... and φt，arcsin k kwt-w*k2
kw* k2
2	η(γ(φt) - 6Lc
ross)	2
kwt+1 - w*k2 ≤ C----------------2---------k kwt - w*k2
Our theorem suggests if the initialization satisfies γ(φ0) > 6Lcross, we obtain linear conver-
gence rate. In Section 3.1, we give a concrete example showing closeness of patches implies
large γ(φ) and small Lcross. Similar to Theorem 2.2, if the step size is chosen so that ηt =
6
Published as a conference paper at ICLR 2018
θ ((LS(W Jφ0)+1LL1z+4β)2)，in O ((Ls(w,φ00-6LLorθss+4β)2loge)) iterations，We can
find the e-close solution of w* and the proof is also similar to that of Theorem 3.1.
In practice,we never get a true population gradient but only stochastic gradient g(w) (c.f. Equa-
tion (2)). The following theorem shows SGD also recovers the underlying filter.
Theorem 3.2. Let φ* = argmaxφ γ (φ) ≥ 6Lcross. Denote r0 = kw0 - w* k2, φ0 =
arcsin (口,0口 ) and φι = φ*+φ. For e sufficiently small, if η = Θ (W (γ(φ1)-北；εSs) kw*k2),
then we have in T = O ( ?((人、H— ——log ( kw0-w*k ) ) iterations, with probability at
W2(γ(φ1)-6Lcross)2 kw* k22	Wδkw* k2
least 1 - δ we have kwT - w* k ≤ e kw* k2 .
Unlike the vanilla gradient descent case, here the convergence rate depends on φ1 instead of φ0 .
This is because of the randomness in SGD and we need a more robust initialization. We choose
φ1 to be the average of φ0 and φ* for the ease of presentation. As will be apparent in the proof
we only require φ0 not very close to φ*. The proof relies on constructing a martingale and use
Azuma-Hoeffding inequality and this idea has been previously used by Ge et al. (2015).
3.1	What distribution is easy for SGD to learn a convolutional filter ?
Different from One-Layer One-Neuron model, here we also requires the Lipschitz constant for close-
ness Lcross to be relatively small and γ(φ0) to be relatively large. A natural question is: What input
distributions satisfy this condition?
Here we give an example. We show if (1) patches are close to each other (2) the input distribution
has small probability mass around the decision boundary then the assumption in Theorem 3.1 is
satisfied. See Figure 1 (b)-(c) for the graphical illustrations.
Theorem 3.3.	Denote Zavg = 1 Pk=I Zi. Suppose all patches have unit norm3 * andfor allfor all
i, θ (Zi, Zavg) ≤ ρ. Further assume there exists L ≥ 0 such that for any φ ≤ ρ and for all Zi
P hθ(Zi, WJ ∈ h2 - φ, 2 + φii ≤ μφ, P hθ(Zi, WJ ∈ - h2 - φ, - 2 + φii ≤ μφ,
then we have
Y (Φ0) ≥ Yavg (Φo) - 4(1 - Cos P) and Lcross ≤ 3μ∙
where γavg (φ0) = σmin E ZZ>I w0>Z ≥ 0, w*>Z ≥ 0	, analogue to Definition 2.1.
Several comments are in sequel. We view ρ as a quantitative measure of the closeness between
different patches, i.e., ρ small means they are similar. This lower bound is monotonically decreasing
as a function of ρ and note when ρ = 0, σmin E ZS(w,w*)ZS>(w,w*) = Yavg(φ0) which recovers
Definition 2.1.
For the upper bond on Lcross, μ represents the upper bound of the probability density around the
decision boundary. For example if P [θ (Zi, w*) ∈ [∏2 - φ, ∏ + φ]] α φ2, then for φ in a small
neighborhood around π∕2, say radius G We have P [θ (Zi, w*) ∈ [∏2 - φ, ∏ + φ]] . eφ. This as-
sumption is usually satisfied in real world examples like images because the image patches are not
usually close to the decision boundary. For example, in computer vision, the local image patches of-
ten form clusters and is not evenly distributed over the appearance space. Therefore, if We use linear
classifier to separate their cluster centers from the rest of the clusters, near the decision boundary
the probability mass should be very loW.
3.2 The Power of Random Initialization
For one-layer one-neuron model, We need initialization kw0 - w* k2 < kw* k2 and for the convolu-
tion filter, We need a stronger initialization kw0 - w* k2 < kw* k2 cos (φ*). The folloWing theorem
3This is condition can be relaxed to the norm and the angle of each patch are independent and the norm of
each pair is independent of others.
7
Published as a conference paper at ICLR 2018
shows with uniformly random initialization we have constant probability to obtain a good initializa-
tion. Note with this theorem at hand, we can boost the success probability to arbitrary close to 1 by
random restarts. The proof is similar to (Tian, 2017).
Theorem 3.4.	Ifwe uniformly sample w° from a P-dimensional ball with radius a∣∣w*k so that
α ≤ {21p, then with probability at least 2 — p∕π∏p^a, we have ∣∣wo 一 w*∣∣2 ≤ √1 一 ɑ2 ∣∣w*k∙
To apply this general initialization theorem to our convolution filter case, We can choose a = cos φ*.
Therefore, with some simple algebra we have the following corollary.
Corollary 3.1. Suppose cos (φ*) < √∏p, then if w° is uniformly sampled from a ball with center
0 and radius ∣∣w*k Cos (φ*), we have with probability at least 1 — cos (φ*) ∙√z∏p > 41.
The assumption of this corollary is satisfied if the patches are close to each other as discussed in the
previous section.
4	Experiments
In this section We use simulations to verify our theoretical findings. We first test hoW the smoothness
affect the convergence rate in one-layer one-neuron model described in Section 2 To construct input
distribution With different L(φ), γ(φ) and β (c.f. Definition 2.1 and Assumption 2.1), We fix the
patch to have unit norm and use a mixture of truncated Gaussian distribution to model on the angle
around w* and around the —w* Specifically, the probability density of ∠Z, w* is sampled from
2N(0, σ)I[-π∕2,π∕2] + 11 N(—∏, σ)I[-π∕2,π∕2]. Note by definitions of L(φ) and γ(φ) if σ → 0 the
probability mass is centered around w*, so the distribution is very spiky and L(φ)∕γ(φ) and β will
be large. On the other hand, if σ → ∞, then input distribution is close to the rotation invariant
distribution and L(φ)∕γ(φ) and β will be small. Figure 3a verifies our prediction where we fix the
initialization and step size.
Next we test how the closeness of patches affect the convergence rate in the convolution setting. We
first generate a single patch Z using the above model with σ = 1, then generate each unit norm
Zi whose angle with Z, ∠Zi, Z is sampled from ∠Zi, Z 〜 N(0, σ2)I[-π,π). Figure 3b shows as
variance between patches becomes smaller, we obtain faster convergence rate, which coincides with
Theorem 3.1.
We also test whether SGD can learn a filter on real world data. Here we choose MNIST data and
generate labels using two filters. One is random filter where each entry is sampled from a standard
Gaussian distribution (Figure 4a) and the other is a Gabor filter (Figure 4b). Figure 3a and Figure 3c
show convergence rates of SGD with different initializations. Here, better initializations give faster
rates, which coincides our theory. Note that here we report the relative loss, logarithm of squared
error divided by the square of mean of data points instead of the difference between learned filter
and true filter because we found SGD often cannot converge to the exact filter but rather a filter with
near zero loss. We believe this is because the data are approximately lying in a low dimensional
manifold in which the learned filter and the true filter are equivalent. To justify this conjecture, we
try to interpolate the learned filter and the true filter linearly and the result filter has similar low loss
(c.f. Figure 5). Lastly, we visualize the true filters and the learned filters in Figure 4 and we can see
that the they have similar patterns.
5	Conclusions and Future Works
In this paper we provide the first recovery guarantee of (stochastic) gradient descent algorithm with
random initialization for learning a convolution filter when the input distribution is not Gaussian.
Our analyses only used the definition of ReLU and some mild structural assumptions on the input
distribution. Here we list some future directions.
One possibility is to extend our result to deeper and wider architectures. Even for two-layer fully-
connected network, the convergence of (stochastic) gradient descent with random initialization is
not known. Existing results either requires sufficiently good initialization (Zhong et al., 2017) or
8
Published as a conference paper at ICLR 2018
Figure 3: Convergence rates of SGD (a) with different smoothness where larger σ is smoother; (b)
with different closeness of patches where smaller σ2 is closer; (c) for a learning a random filter with
different initialization on MNIST data; (d) for a learning a Gabor filter with different initialization
on MNIST data.
(a) Random generated target filters.
γjrj I IPI lπlλ
JQ I IH
QQ I RI EZ
□ □ IIM
(b) Gabor filters.
Figure 4: Visualization of true and learned filters. For each pair, the left one is the underlying truth
and the right is the filter learned by SGD.
9
Published as a conference paper at ICLR 2018
relies on special architecture (Li & Yuan, 2017). However, we believe the insights from this paper
is helpful to understand the behaviors of gradient-based algorithms in these settings.
Another direction is to consider the agnostic setting, where the label is not equal to the output of a
neural network. This will lead to different dynamics of (stochastic) gradient descent and we may
need to analyze the robustness of the optimization procedures. This problem is also related to the
expressiveness of the neural network (Raghu et al., 2016) where if the underlying function is not
equal bot is close to a neural network. We believe our analysis can be extend to this setting.
References
Avrim Blum and Ronald L Rivest. Training a 3-node neural network is np-complete. In Advances
in neural information processing Systems, pp. 494-501, 1989.
Alon Brutzkus and Amir Globerson. Globally optimal gradient descent for a convnet with gaussian
inputs. arXiv preprint arXiv:1702.07966, 2017.
Anna Choromanska, Mikael Henaff, Michael Mathieu, Gerard Ben Arous, and Yann LeCun. The
loss surfaces of multilayer networks. In Artificial Intelligence and Statistics, pp. 192-204, 2015.
Yann N Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated
convolutional networks. arXiv preprint arXiv:1612.08083, 2016.
Simon S Du, Chi Jin, Jason D Lee, Michael I Jordan, Barnabas Poczos, and Aarti Singh. Gradient
descent can take exponential time to escape saddle points. arXiv preprint arXiv:1705.10412,
2017.
C Daniel Freeman and Joan Bruna. Topology and geometry of half-rectified network optimization.
arXiv preprint arXiv:1611.01540, 2016.
Antoine Gautier, Quynh N Nguyen, and Matthias Hein. Globally optimal training of generalized
polynomial neural networks with nonlinear spectral methods. In Advances in Neural Information
Processing Systems, pp. 1687-1695, 2016.
Rong Ge, Furong Huang, Chi Jin, and Yang Yuan. Escaping from saddle pointsonline stochastic
gradient for tensor decomposition. In Proceedings of The 28th Conference on Learning Theory,
pp. 797-842, 2015.
Surbhi Goel and Adam Klivans. Learning depth-three neural networks in polynomial time. arXiv
preprint arXiv:1709.06010, 2017.
Surbhi Goel, Varun Kanade, Adam Klivans, and Justin Thaler. Reliably learning the relu in polyno-
mial time. arXiv preprint arXiv:1611.10258, 2016.
Benjamin D Haeffele and Rene Vidal. Global optimality in tensor factorization, deep learning, and
beyond. arXiv preprint arXiv:1506.07540, 2015.
Moritz Hardt and Tengyu Ma. Identity matters in deep learning. arXiv preprint arXiv:1611.04231,
2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016.
Majid Janzamin, Hanie Sedghi, and Anima Anandkumar. Beating the perils of non-convexity: Guar-
anteed training of neural networks using tensor methods. arXiv preprint arXiv:1506.08473, 2015.
Chi Jin, Rong Ge, Praneeth Netrapalli, Sham M Kakade, and Michael I Jordan. How to escape
saddle points efficiently. arXiv preprint arXiv:1703.00887, 2017.
Kenji Kawaguchi. Deep learning without poor local minima. In Advances in Neural Information
Processing Systems, pp. 586-594, 2016.
10
Published as a conference paper at ICLR 2018
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
Iutional neural networks. In Advances in neural information processing Systems, pp. 1097-1105,
2012.
Jason D Lee, Max Simchowitz, Michael I Jordan, and Benjamin Recht. Gradient descent only
converges to minimizers. In Conference on Learning Theory, pp. 1246-1257, 2016.
Yuanzhi Li and Yang Yuan. Convergence analysis of two-layer neural networks with relu activation.
arXiv preprint arXiv:1705.09886, 2017.
Min Lin, Qiang Chen, and Shuicheng Yan. Network in network. arXiv preprint arXiv:1312.4400,
2013.
Qihang Lin and Lin Xiao. An adaptive accelerated proximal gradient method and its homotopy
continuation for sparse optimization. In International Conference on Machine Learning, pp. 73-
81, 2014.
Roi Livni, Shai Shalev-Shwartz, and Ohad Shamir. On the computational efficiency of training
neural networks. In Advances in Neural Information Processing Systems, pp. 855-863, 2014.
Song Mei, Yu Bai, and Andrea Montanari. The landscape of empirical risk for non-convex losses.
arXiv preprint arXiv:1607.06534, 2016.
Fausto Milletari, Nassir Navab, and Seyed-Ahmad Ahmadi. V-net: Fully convolutional neural net-
works for volumetric medical image segmentation. In 3D Vision (3DV), 2016 Fourth International
Conference on, pp. 565-571. IEEE, 2016.
Quynh Nguyen and Matthias Hein. The loss surface of deep and wide neural networks. arXiv
preprint arXiv:1704.08045, 2017.
Maithra Raghu, Ben Poole, Jon Kleinberg, Surya Ganguli, and Jascha Sohl-Dickstein. On the ex-
pressive power of deep neural networks. arXiv preprint arXiv:1606.05336, 2016.
Itay Safran and Ohad Shamir. On the quality of the initial basin in overspecified neural networks.
In International Conference on Machine Learning, pp. 774-782, 2016.
Hanie Sedghi and Anima Anandkumar. Provable methods for training neural networks with sparse
connectivity. arXiv preprint arXiv:1412.2693, 2014.
Shai Shalev-Shwartz, Ohad Shamir, and Shaked Shammah. Failures of gradient-based deep learning.
In International Conference on Machine Learning, pp. 3067-3075, 2017a.
Shai Shalev-Shwartz, Ohad Shamir, and Shaked Shammah. Weight sharing is crucial to succesful
optimization. arXiv preprint arXiv:1706.00687, 2017b.
Ohad Shamir. Distribution-specific hardness of learning neural networks. arXiv preprint
arXiv:1609.01037, 2016.
David Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche,
Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering
the game of go with deep neural networks and tree search. Nature, 529(7587):484-489, 2016.
Jin s´ma. Training a single sigmoidal neuron is hard. Neural Computation, 14(11):2709-2728,
2002.
Mahdi Soltanolkotabi. Learning relus via gradient descent. arXiv preprint arXiv:1705.04591, 2017.
Mahdi Soltanolkotabi, Adel Javanmard, and Jason D Lee. Theoretical insights into the optimiza-
tion landscape of over-parameterized shallow neural networks. arXiv preprint arXiv:1707.04926,
2017.
Christian Szegedy, Sergey Ioffe, Vincent Vanhoucke, and Alexander A Alemi. Inception-v4,
inception-resnet and the impact of residual connections on learning. In AAAI, pp. 4278-4284,
2017.
11
Published as a conference paper at ICLR 2018
Yuandong Tian. An analytical formula of population gradient for two-layered relu network and its
applications in convergence and critical point analysis. arXiv preprint arXiv:1703.00560, 2017.
Yuchen Zhang, Jason D Lee, Martin J Wainwright, and Michael I Jordan. Learning halfspaces and
neural networks with random initialization. arXiv preprint arXiv:1511.07948, 2015.
Yuchen Zhang, Jason D Lee, and Michael I Jordan. l1-regularized neural networks are improperly
learnable in polynomial time. In International Conference on Machine Learning, pp. 993-1θ01,
2016.
Kai Zhong, Zhao Song, Prateek Jain, Peter L Bartlett, and Inderjit S Dhillon. Recovery guarantees
for one-hidden-layer neural networks. arXiv preprint arXiv:1706.03175, 2017.
Pan Zhou and Jiashi Feng. The landscape of deep learning algorithms. arXiv preprint
arXiv:1705.07038, 2017.
12
Published as a conference paper at ICLR 2018
A Proofs and Additional Theorems
A.1 PROOFS OF THE THEOREM IN SECTION 2
Lemma A.1.
〈▽w' (w) , W - w*〉= (w - w*)> Aw,w* (w - w*) + (w - w*)> Aw,-w* w.	(5)
and both terms are non-negative.
Proof. Since Aw,w* 占 0 and Aw,-w* 占 0 (POSitive-Semidefinite), both the first term and one part
of the second term w> Aw,-w* W are non-negative. The other part of the second term is
-w>Aw,-w* W = -E [(w>Z) (w>Z)l {wτZ ≥ 0, w;Z ≤ 0}] ≥ 0.
□
ProofofTheorem 2.1. The assumption on the input distribution ensures when θ (w, w*) = π,
Aw,w* * 0 and when θ (w, w*) = 0, Aw,-w* * 0. Now when gradient descent converges
We have YW' (w) = 0. We have the following theorem. By assumption, since ' (w) < ' (0) and
gradient descent only decreases function value, we will not converge to w = 0. Note that at any
critical points, "w' (w), W - w*〉= 0, from Lemma A.1, We have:
(w - w*)τ Aw,w* (w - w*)	= 0	(6)
(w - w*)τ Aw,-w*W = 0.	(7)
Suppose We are converging to a critical point W = w*. There are two cases:
•	If θ (w, w*) = π, then we have(w - w*)τ Aw,w* (w - w*) > 0, which contradicts with
Eqn. 6.
•	If θ (w, w*) = π, without loss of generality, let W = -αw* for some α > 0.
By the assumption we know Aw,-w* * 0. Now the second equation becomes
(w - w*)τ Aw,-w* w = (1+ γ)w*Aw,-w* w* > 0, which contradicts with Eqn. 7.
Therefore we have W = w*.
□
Proof of Theorem 2.2. Our proof relies on the following simple but crucial observation: if
llw - w*k2 < Ilw*k2,then
θ (w, w* ) ≤
arcsιn
“W - w*k2 ʌ
I ι∣w*k2 广
We denote θ (wt, w*) = θt and by the observation we have θt ≤ φt. Recall the gradient descent
dynamics,
Wt+1 = Wt - NWt '(Wt)
=Wt — η (E [ZZτI {wjZ ≥ 0, WTZ ≥ 0}] (Wt — w*) — E [wτZ ≥ 0, WTZ ≤ 0] Wt).
Consider the squared distance to the optimal weight
I∣wt+1 - w*k2
= lwt - w* l22
—η (wt — w*)τ (E [ZZτI {wj,rZ ≥ 0, WTZ ≥ 0}] (Wt — w*) — E [wτZ ≥ 0, WTZ ≤ 0] Wt)
+ η2 ∣∣E [ZZτI {wi,rZ ≥ 0, WTZ ≥ 0}] (Wt — w*) — E [wτZ ≥ 0, WTZ ≤ 0] Wt∣∣2 .
By our analysis in the previous section, the second term is smaller than
-η (wt - w*)τ E [ZZτI {wjZ ≥ 0, WTZ ≥ 0}] (Wt - w*) ≤ -ηγ(θt) ∣∣Wt - w*∣2
13
Published as a conference paper at ICLR 2018
where we have used our assumption on the angle. For the third term, we expand it as
∣∣E [ZZ> I	{w> Z ≥ 0,	w> Z	≥ 0}] (Wt	—	w*) —	E [w>Z	≥ 0,	w> Z ≤ 0] wt∣∣j
= IlE [ZZ>I	{w>Z ≥ 0,	w>Z	≥ 0}] (wt	—	w*) ∣∣2
—2 (E [ZZ>I {w>Z ≥ 0, w>Z ≥ 0}] (Wt — w*))> E [w>Z ≥ 0, w>Z ≤ 0] Wt
+ ∣∣E [w>Z ≥ 0, w>Z ≤ 0] wt∣∣2
≤L2(θt) kwt	— w*k2 +	2L(θt)	Ilwt	—	w*k2	∙	2β	kwtʃ w*k +	(2/ kwt[	w*k2)	IlWtk2
kw* k2	kw* k2
≤L2(θt) kwt—w*k2 +	2L(Bt)	kwt—	w*k∙	2β~~iɪ-ɪ^	•2ι∣w*k2 + (2万^it~~：*"2)	•4ι∣w*k2
Iw* I2	Iw* I2
≤ (L2(Bt) + 8L(θt)β + 16β2) kw — w*k2.
Therefore, in summary,
kwt+1 — w*k22 ≤ 1 — ηγ(Bt) + η2 (L(Bt) + 4β)2 kwt — w*k22
≤(1 -号)kwt-w*k2
≤ (l - ηγ2φt) )kwt-w*k2
where the first inequality is by our assumption of the step size and second is because Bt ≤ φt and
Y(∙) is monotonically decreasing.	□
Theorem A.1 (Rotational Invariant Distribution). For any unit norm rotational invariant input dis-
tribution, we have β = 1.
Proof of Theorem A.1. Without loss of generality, we only need to focus on the plane spanned by w
and w* and suppose w* = (1, 0)>. Then
「	> 「/	--^2+φ ccos θ∖	.	1 φφ — Sin φcos φ
E [ZZ I {S(w,-wJ}]=J-π∕2	(Sin θ)(cos θ, sin θHθ=2( W -dφ W
It has two eigenvalues
— sin2 φ
φ + sin φcos φ
λι(φ) = φ÷fn≠ and λ2(φ) = Wni.
Therefore, maxw,θ(w,w*)≤φ λmaχ (Aw,-w*) = φ+2in φ ≤ φ for 0 ≤ φ ≤ ∏.
□
Theorem A.2. If Z 〜N (0, I) ,then β ≤ P
Proof. Note in previous theorem we can integrate angle and radius separately then multiply them
together. For Gaussian distribution, we have E
kZk22
≤ p. The result follows.
□
A.2 Proofs of Theorems in Section 3
Proof of Theorem 3.1. The proof is very similar to Theorem 2.2. Notation-wise, for two events
S1, S2 we use S1S2 as a shorthand for S1 ∩ S2 and S1 + S2 as a shorthand for S1 ∪ S2. Denote
Bt = B (wt, w*) . First note with some routine algebra, we can write the gradient as
Vwt' (Wt)
(d,d)
=E	X	ZiZj>I S(w, w*)iS(w, w*)j	(w — w*)
(i,j)=(1,1)
14
Published as a conference paper at ICLR 2018
+ E
+ E
-E
(d,d)
X	ZiZHS(w, w*)iS(w, -W
.(i,j)=(i,i)
(d,d)
X ZiZ>l{s(w,-w)S(w,-
*)j + S(w, -w*)iS (w, w*j}
w*)j}
W
W
.(i,j)=(i,i)	_
(d,d)
X	ZiZ>I{s(w, w*)iS(-w, w*)j + S(w, -w*)iS (w, w*)j + S(w, -w*)iS(-w, w*)j}
(i,j)=(i,i)
We first examine the inner product between the gradient and W - W
*.
w*
Bwt'(w), W - W*
(w - w*)> E
i
(d,d)
X	ZiZjI {s(w, w*)iS(w, w*)j}	(w -
W*)
+ (w - w*)> E
—(w — w*)> E
_(i,j)=(1/)	_
(d,d)
X	ZiZjI {s(w, WjiS(W, -w*)j + S(w, -w*)iS(w, w*)j + S(w, -w* bS(w, —w*j}
.(i,j)=(Ij)
(d,d)
X	ZiZjI {s(w, w*)iS(-w, w*)j + S(w, -w*)iS(w, w*)j + S(w, -w* )i S(-w, w*j}
w
w*
≥ (w — w*)> E
+ (w - w*)> E
.(i,j)=(Ij)
(d,d)
X	ZiZjI {s(w, w*)iS(w, w*)j}	(w -
_(i,j)=(1/)	_
(d,d)
W*)
—(w — w*)> E
X ZiZjI {s(w, WJiS(W, -w*)j}
.(i,j)=(Ij)
(d,d)
W
≥ γ(θt) ∣∣w - w*
X	ZiZjI {s(w, w*)iS(-w, w*)j + S(w, -w*bS(w, w*)j + S(w, -w* )i S(-w, w*j}
_(i,j)=(Ij)
∣2
-l∣w - w*∣2 l∣w∣2
E
(d,d)
X ZiZjI{s(w, W* )iS(w, —w*)j}
(i,j)=(i,i)
op
w*
-Ilw - w*k2 llw* k2
+
E
E
(d,d)
X	ZiZjI {s(w, w*)iS(-W, w*)j}
(ij)=(i,i)
(d,d)
X	ZiZjI {s(w,-W*)iS(w, W*)j}
(i,j)=(i,i)
+
E
op
op
(d,d)
X	ZiZjI{s(w, -w*)iS(-w,w*)j}
(i,j)=(i,i)
op
≥ γ(θt) ∣w - w*k2
-2 ∣∣w - w*∣∣2 llw*l∣2
E
-Ilw - w*k2 llw* k2
E
(d,d)
X	ZiZjI {s(w, w*)iS(w,-w*)j}
.(i,j)=(i,i)	_
(d,d)
X ZiZjI {s(w, w*)iS(-w, w*)j}
(i,j)=(i,i)
op
op
15
Published as a conference paper at ICLR 2018
+ E	(X, )	ZiZjI nS(w, -w* )iS(w, w*)j} Il +
(i,j)=(1,1)	op
≥ Y (θt) ∣∣Wt - w*k2 - 3LcrossΦt I∣w≠k2 ∣∣Wt - w*∣∣2
(d,d)
X	ZiZjI {s(w, -w*)iS(-w, w*)j}
(i,j)=(1,1)
E
≥ Y (θt) kwt - W* I∣2 - 6Lcross "W], w*k2 ∙ kw*k2 kwt - W* ∣∣2
llw* II2
≥ (Y (θt) - 6Lcross) ∣wt - w*∣22
where the first inequality we used the definitions of the regions; the second inequality we used the
definition of operator norm; the third inequality we used the fact ∣wt - w* ∣2 ≤ ∣w* ∣2 ; the fourth
inequality we used the definition of Lcross and the fifth inequality we used φ ≤ 2 sin φ for any
0 ≤ φ ≤ n/2. Next We can upper bound the norm of the gradient using similar argument
∣∣Vwt'(wt)∣2 ≤L(θt) ∣∣Wt - w*∣2 + 10Lcross ∣∣Wt - w*∣ +2β ∣Wt - w*∣2
=(L(θt) + 10L
cross+4β) ∣wt - w*∣2 .
Therefore, using the dynamics of gradient descent, putting the above tWo bounds together, We have
IlWt+1 - w*∣∣2 ≤ (1 - η (Y (θt) - 6LcroSs) + η2(L(θt) + 10Lcross + 4B )2) IlWt- w* ∣∣2
≤ (1- η(γ(θt) - 6LcroSS) )∣wt- w*∣2
≤ (I- η(γ(φt) - 6LcroSS)) ∣wt - w*∣2
where the last step we have used our choice of η and θt ≤ φt.	□
The proof of Theorem 3.2 consists of tWo parts. First We shoW if η is chosen properly and T is not
to big, then for all 1 ≤ t ≤ T, with high probability the iterates stat in a neighborhood of w*. Next,
conditioning on this, we derive the rate.
Lemma A.2. Denote r0 = ∣w0 - w* ∣2 < ∣w* ∣2 sin φ*. Given 0 < r1 < ∣w* ∣2 sin φ*, number
of iterations T ∈ Z++ and failure probability δ, denote φι = arcsin (晨： )then if the step size
satisfies
0 < 1 - ηY(φ1) + η2 (L(0) + 10Lcross + 4β)2 < 1
_______________________(r2-r0)2______________________. ≥ log (T)
T (1 + 2ηαT )(2〃B (L(0) + 10LcroSS + 4β) ri + η2B2)2 — V7
with α = Y (φ1) - η (L(0) + 10Lcross + 4β). Then with probability at least 1 - δ, for all t =
1, . . . , T, we have
∣wt - w* ∣ ≤ r1 .
Proof of Lemma A.2. Let g(wt) = E [Vwt ` (wt)] + ξt. We denote Ft = σ {ξ1, . . . , ξt}, the sigma-
algebra generated by ξ1 , . . . , ξt and define the event
Ct = {∀τ ≤ t, ∣wτ - w*∣ ≤ r1} .
Consider
E h∣wt+i - w*∣2ICtIFti
=E h∣wt -ηvw∕(wt) - w* - ηξt∣2ICtIFti
≤	1 - ηY(φ1) + η2 (L(0) + 10LcroSS + 4β)	∣wt - w* ∣2 + η2B2 ICt
where the inequality follows by our analysis of gradient descent together with definition of Ct and
E [ξt IFt ] = 0. Define
16
Published as a conference paper at ICLR 2018
By our analysis above, we have
E [Gt+1ICt |Ft] ≤ GtICt ≤ GtICt-1
where the last inequality is because Ct is a subset of Ct-1. Therefore, GtICt-1 is a super-martingale
and we may apply Azuma-Hoeffding inequality. Before that, we need to bound the difference be-
tween GtICt and its expectation. Note
IGtICt-I- E [GtICt-J 1Ft-Il=(I -ηα厂[kWt- w*∣∣2 - EhkWt- w*k2i IFt-J ICt-1
= (I- ηα厂[2ηhξt, wt - ηVwt'(w) - w* - η2E [kξtk2 凤口 ∣ Ij
≤ (1 - ηα)	t (2ηB	(L(O)	+ 10Lcross +	4B) IlWt- w*k2	+ η2B2) I-ct-ι
≤ (1 - ηα)	t (2ηB	(L(O)	+ 10Lcross +	4β) r1 + η2 B2)
,dt.
Therefore for all t ≤ T
t
ct2 ,Xdτ2
τ=1
t
=X (1 - ηα)-2t RnB (L(O) + IOLcross + 4β) ri + η2B2)2
τ=1
≤t (1 - nα)-2t (2nB (L(O) + 10LcroSS + 4β) ri + n2B2)2
≤T (1 + 2ηɑT)(2nB (L(O) + 1OLcroSS + 4β) ri + n2B2)
where the first inequality we used 1 - ηα < 1, the second we used t ≤ T and the third we used our
assumption on η. Let us bound at (t + 1)-th step, the iterate goes out of the region,
P [Ct ∩ {kwt+i - w*k2 > ri}] =P hCt ∩ nkwt+i - w*k22 > ri2oi
=P hCt ∩ nkwt+i - w*k22 > r02 + (ri2 - r02)oi
=P Ct ∩ ∣Gt+i (1 - nα)t + nB2 ≥ Go + nB2 + r2- *}]
≤P [Ct ∩ {Gt+i - Go ≥ r2 - r0 }]
V J (r2 -r0)]
≤exp 1--丁)
δ
≤-
≤ T
where the second inequality we used Azuma-Hoeffding inequality, the last one we used our assump-
tion of n. Therefore for all O ≤ t ≤ T, We have with probability at least 1 - δ, Ct happens. 口
Now we can derive the rate.
Lemma A.3. Denote ro = kwo - w*k2 < kw*k2 sinφ*. Given O < ri < kw*k2 sin φ*, number
of iterations T ∈ Z++ and failure probability δ, denote φι = arcsin (后〒)then if the step size
satisfies
O < 1 - nγ(φi) + n2 (L(O) + 1OLcross + 4β)2 < 1
____________________(r2 - r2)2__________________
T (1 + 2ηɑT)(2nB (L(O) + 1OLcroSS + 4β)ri + n2B2)2
nT γ (φi ) - n (L(O) + 1OLcross + 4β)
≥log (T
≥ log「
17
Published as a conference paper at ICLR 2018
E2 (γ(Φι) - η (L(0) + 10Lcross + 4β)2) I∣w*k2 ≥ ηB2
with α = γ (φ1) - η (L(0) + 10Lcross + 4β), then we have with probability 1 - 2δ,
IlWt- w*∣∣2 ≤ 2e kw*∣∣2.
Proof of Lemma A.3. We use the same notations in the proof of Lemma A.2. By the analysis of
Lemma A.2, we know
EhkWt+1 - W*k2Ict∣Ft] ≤ ((1 - ηα) IlWt- w*∣∣2 + η2B2) ICt.
Therefore we have
E IlWt - w*ιι2 ICt - ηθ-] ≤ (i - ηα)t (∣∣wo - w*∣∣2 - ¥).
Now we can bound the failure probability
P[∣∣wτ- w*ι∣2 ≥ 2eι∣w*k2] ≤P ]ι∣wτ- w*k2- ^~0~ ≥ e2 kw*k2
≤P ]{kwτ - w*k2 ICt- ηθ- ≥ e2 ∣∣wk2∣ ∪Cc
≤P ]{kwT - w*k2 ICt- ηθ- ≥ €2 ∣∣w∣∣2}] + δ
E hkwτ - w*k2 ICt - ηf-i
≤ —l--------------.--------+ δ
一	€2 kw*k2
(I - ηɑ)t (kw0 - w*k2 - nB)
-	E2∣∣w*k2
≤2δ.
The first inequality we used the last assumption. The second inequality we used the probability of
an event is upper bound by any superset of this event. The third one we used Lemma A.2 and the
union bound. The fourth one We used Markov,s inequality.	□
Now we can specify the T and η and derive the convergence rate of SGD for learning a convolution
filter.
Proof of Theorem 3.2. With the choice of η and T , it is straightforWard to check they satisfies con-
ditions in Lemma A.3.	□
Proof of Theorem 3.3. We first prove the loWer bound of γ (φ0).
E I (XZiI{S(w, w*)i}	ZiI{S(w, w*)i}]
k
k
>
=E kZ + £(ZiI {S(w, w)}- Z) kZ + £(ZiI {S(w, w)}- Z)
i=1
i=1
=k2E [ZZ>] + kE Iz (X (ZiI {S(w, w*)i} - Z))
+ kE	E(ZiI {S(w, w*)J - Z) Z>
18
Published as a conference paper at ICLR 2018
+ E ](XX (ZiI {S(w, w*)J- ZiI {S(w, w*)J)
<k2E [ZZ>] + kE ]z (X (ZiI{S(w, w*)i} - Z)
+ kE
(ZiI {S(w, w)}- Z) Z>
(ZiI {S(w, w*)i} - ZiI {S(w, w)}))
Note because Zis have unit norm and by law of cosines ∣∣Z (ZiI{S(w, w*}} - Z)Ilop ≤ 2(1 -
cos ρ). Therefore,
σmin (E ](χ ZiI {S(w, w*)i}
ZiI {S(w, wj})
≥ k2(γi(φ0) - 4(1 - cos ρ)).
Now we prove the upper bound of Lcross . Notice that
E hZiZj>InS(w, w*)iS(w, -w*)joi	≤E h∣Zi∣2 ∣Zj∣2 InS(w, w*)iS(w, -w*)joi
/
JS(W,—w* )
dP(Zi|Zj)	dP(θj).
,w*)i
If φ ≤ ψ, then by our assumption, we have
Z w—w* Z ww* dP(Zi|Zj) dP(θj) ≤Z w—w* dP(Zj) ≤Lφ.
On the other hand, if φ ≥ γ, let θj be the angle between w* and Zj, we have
/
S (w,—w* )
)dP(Zi∣Zj)) dP(θj) ≤ '2 +γ Z∣w	)dP(Zi∣Zj)) dP (θj)
≤Lγ
≤Lφ.
Therefore, σmax E ZS (w,w*)ZS>(w,—w*)	≤ Lφ. Using similar arguments we can show
σmax E ZS (w,w*)ZS (—w,w*)])≤ Lφ and σmaχ (E [Zs(w,-w*)Zs(-w,w*)]) ≤ Lφ.	□
Proof of Theorem 3.4. We use the same argument by Tian (2017). Let rinit be the initialization
radius. The failure probability is lower bounded
⅛ + kwk4) δVk-1 (rinit)
2 (Irinit)-
Vk (rinit)
Therefore, rinit = cos (φ*) ∣w* ∣2 maximizes this lower bound. Plugging this optimizer in and
using formula for the volume of the Euclidean ball, the failure probability is lower bounded by
1
2
- cos (φ* )
可p2+∖ ≥ 1 - c°s(φ*)∖户
Γ(p∕2 + 1∕2) - 2	'w*' V 2
where we used Gautschi’s inequality for the last step.
□
B Additional Experimental Results
Figure 5 show the loss of linear interpolation between the learned filter w and ground truth filter w*.
Our interpolation has the form winter = αw + (1 - α)w* where α ∈ [0, 1] is the interpolation ratio.
Note that for all interpolation ratios, the loss remains very low.
19
Published as a conference paper at ICLR 2018
-9
-10
1234
-1 -1 -1 -1
)ssoL evitaleR(go
-15
—Random Filter
-16----------1---------1--------1---------1--------1
0	20	40	60	80	100
Interpolation Ratio %
)ssoL evitaleR(go
Figure 5: Loss of linear interpolation between learned filter and the true filter.
20