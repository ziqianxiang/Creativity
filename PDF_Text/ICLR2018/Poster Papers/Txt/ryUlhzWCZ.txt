Published as a conference paper at ICLR 2018
Truncated Horizon Policy Search: Combining
Reinforcement Learning & Imitation Learning
Wen Sun
Robotics Institute
Carnegie Mellon University
Pittsburgh, PA, USA
wensun@cs.cmu.edu
J. Andrew Bagnell
Robotics Institute
Carnegie Mellon University
Pittsburgh, PA, USA
dbagnell@cs.cmu.edu
Byron Boots
School of Interactive Computing
Georgia Institute of Technology
Atlanta, GA, USA
bboots@cc.gatech.edu
Ab stract
In this paper, we propose to combine imitation and reinforcement learning via the
idea of reward shaping using an oracle. We study the effectiveness of the near-
optimal cost-to-go oracle on the planning horizon and demonstrate that the cost-
to-go oracle shortens the learner’s planning horizon as function of its accuracy: a
globally optimal oracle can shorten the planning horizon to one, leading to a one-
step greedy Markov Decision Process which is much easier to optimize, while an
oracle that is far away from the optimality requires planning over a longer horizon
to achieve near-optimal performance. Hence our new insight bridges the gap and
interpolates between imitation learning and reinforcement learning. Motivated
by the above mentioned insights, we propose Truncated HORizon Policy Search
(THOR), a method that focuses on searching for policies that maximize the total
reshaped reward over a finite planning horizon when the oracle is sub-optimal. We
experimentally demonstrate that a gradient-based implementation of THOR can
achieve superior performance compared to RL baselines and IL baselines even
when the oracle is sub-optimal.
1	Introduction
Reinforcement Learning (RL), equipped with modern deep learning techniques, has dramatically ad-
vanced the state-of-the-art in challenging sequential decision problems including high-dimensional
robotics control tasks as well as video and board games (Mnih et al., 2015; Silver et al., 2016). How-
ever, these approaches typically require a large amount of training data and computational resources
to succeed. In response to these challenges, researchers have explored strategies for making RL
more efficient by leveraging additional information to guide the learning process. Imitation learning
(IL) is one such approach. In IL, the learner can reference expert demonstrations (Abbeel & Ng,
2004), or can access a cost-to-go oracle (Ross & Bagnell, 2014), providing additional information
about the long-term effects of learner decisions. Through these strategies, imitation learning lowers
sample complexity by reducing random global exploration. For example, Sun et al. (2017) shows
that, with access to an optimal expert, imitation learning can exponentially lower sample complexity
compared to pure RL approaches. Experimentally, researchers also have demonstrated sample effi-
Ciency by leveraging expert demonstrations by adding demonstrations into a replay buffer (Vecer´k
et al., 2017; Nair et al., 2017), or mixing the policy gradient with a behavioral cloning-related gra-
dient (Rajeswaran et al., 2017).
Although imitating experts can speed up the learning process in RL tasks, the performance of the
learned policies are generally limited to the performance of the expert, which is often sub-optimal
in practice. Previous imitation learning approaches with strong theoretical guarantees such as Data
Aggregation (DAgger) (Ross et al., 2011) and Aggregation with Values (AggreVaTe) (Ross &
Bagnell, 2014) can only guarantee a policy which performs as well as the expert policy or a one-step
deviation improvement over the expert policy.1 Unfortunately, this implies that imitation learning
with a sub-optimal expert will often return a sub-optimal policy. Ideally, we want the best of both
1 AggreVaTe achieves one-step deviation improvement over the expert under the assumption that the pol-
icy class is rich enough.
1
Published as a conference paper at ICLR 2018
IL and RL: we want to use the expert to quickly learn a reasonable policy by imitation, while also
exploring how to improve upon the expert with RL. This would allow the learner to overcome the
sample inefficiencies inherent in a pure RL strategy while also allowing the learner to eventually sur-
pass a potentially sub-optimal expert. Combining RL and IL is, in fact, not new. Chang et al. (2015)
attempted to combine IL and RL by stochastically interleaving incremental RL and IL updates. By
doing so, the learned policy will either perform as well as the expert Policy-the property of IL (Ross
& Bagnell, 2014), or eventually reach a local optimal policy-the property of policy iteration-based
RL approaches. Although, when the expert policy is sub-optimal, the learned locally optimal policy
could potentially perform better than the expert policy, it is still difficult to precisely quantify how
much the learner can improve over the expert.
In this work, we propose a novel way of combining IL and RL through the idea of Reward Shaping
(Ng et al., 1999). Throughout our paper we use cost instead of reward, and we refer to the concept of
reward shaping with costs as cost shaping. We assume access to a cost-to-go oracle that provides an
estimate of expert cost-to-go during training. The key idea is that the cost-to-go oracle can serve as
a potential function for cost shaping. For example, consider a task modeled by a Markov Decision
Process (MDP). Cost shaping with the cost-to-go oracle produces a new MDP with an optimal
policy that is equivalent to the optimal policy of the original MDP (Ng et al., 1999). The idea of
cost shaping naturally suggests a strategy for IL: pick a favourite RL algorithm and run it on the new
MDP reshaped using expert’s cost-to-go oracle. In fact, Ng et al. (1999) demonstrated that running
SARSA (Sutton & Barto, 1998) on an MDP reshaped with a potential function that approximates
the optimal policy’s value-to-go, is an effective strategy.
We take this idea one step further and study the effectiveness of the cost shaping with the expert’s
cost-to-go oracle, with a focus on the setting where We only have an imperfect estimator Ve of the
cost-to-go of some expert policy ∏e, i.e., Ve = V *, where V * is the optimal policy,s cost-to-go
in the original MDP. We show that cost shaping with the cost-to-go oracle shortens the learner’s
planning horizon as a function of the accuracy of the oracle Ve compared to V*. Consider two
extremes. On one hand, when we reshape the cost of the original MDP with V * (i.e., Ve = V *), the
reshaped MDP has an effective planning horizon of one: a policy that minimizes the one-step cost
of the reshaped MDP is in fact the optimal policy (hence the optimal policy of the original MDP).
On the other hand, when the cost-to-go oracle provides no information regarding V*, we have no
choice but simply optimize the reshaped MDP (or just the original MDP) using RL over the entire
planning horizon.
With the above insight, we propose the high-level strategy for combining IL and RL, which we name
Truncated HORizon Policy Search with cost-to-go oracle (THOR). The idea is to first shape the cost
using the expert,s cost-to-go oracle Ve, and then truncate the planning horizon of the new MDP
and search for a policy that optimizes over the truncated planning horizon. For discrete MDPs, we
mathematically formulate this strategy and guarantee that we will find a policy that performs better
than the expert with a gap that can be exactly quantified (which is missing in the previous work of
Chang et al. (2015)). In practice, we propose a gradient-based algorithm that is motivated from this
insight. The practical algorithm allows us to leverage complex function approximators to represent
policies and can be applied to continuous state and action spaces. We verify our approach on several
MDPs with continuous state and action spaces and show that THOR can be much more sample effi-
cient than strong RL baselines (we compared to Trust Region Policy Optimization with Generalized
Advantage Estimation (TRPO-GAE) (Schulman et al., 2016)), and can learn a significantly better
policy than AggreVaTe (we compared to the policy gradient version of AggreVaTe from (Sun
et al., 2017)) with access only to an imperfect cost-to-go oracle.
1.1	Related Work and Our Contribution
Previous work has shown that truncating the planning horizon can result in a tradeoff between accu-
racy and computational complexity. Farahmand et al. (2016) proposed a model-based RL approach
that focuses on a search for policies that maximize a sum of k-step rewards with a termination value
that approximates the optimal value-to-go. Their algorithm focuses on the model-based setting and
the discrete state and action setting, as the algorithm needs to perform k-step value iteration to com-
pute the policy. Another use of the truncated planning horizon is to trade off bias and variance.
When the oracle is an approximation of the value function of the agent,s current policy, by using k-
2
Published as a conference paper at ICLR 2018
step rollouts bottomed up by the oracle’s return, truncating the planning horizon trades off bias and
variance of the estimated reward-to-go. The bias-variance tradeoff has been extensively studied in
Temporal Difference Learning literature (Sutton, 1988) and policy iteration literature as well (Gabil-
lon et al., 2011). Ng (2003) is perhaps the closest to our work. In Theorem 5 in the Appendix of
Ng’s dissertation, Ng considers the setting where the potential function for reward shaping is close
to the optimal value function and suggests that if one performs reward shaping with the potential
function, then one can decrease the discount factor of the original MDP without losing the optimal-
ity that much. Although in this work we consider truncating the planning steps directly, Theorem 5
in Ng’s dissertation and our work both essentially considers trading off between the hardness of the
reshaped MDP (the shorter the planning horizon, the easier the MDP to optimize) and optimality of
the learned policy. In addition to this tradeoff, our work suggests a path toward understanding previ-
ous imitation learning approaches through reward shaping, and tries to unify IL and RL by varying
the planning horizon from 1 to infinity, based on how close the expert oracle is to the optimal value
function. Another contribution of our work is a lower bound analysis that shows that performance
limitation of AggreVaTe with an imperfect oracle, which is missing in previous work (Ross &
Bagnell, 2014). The last contribution of our work is a model-free, actor-critic style algorithm that
can be used for continuous state and action spaces.
2	Preliminaries
We consider the problem of optimizing Markov Decision Process defined as M0 = (S, A, P, C, γ).
Here, S is a set of S states and A is a set of A actions; P is the transition dynamics at such that for
any s ∈ S, s0 ∈ S, a ∈ A, P(s0|s, a) is the probability of transitioning to state s0 from state s by
taking action a. For notation simplicity, in the rest of the paper, we will use short notation Psa to
represent the distribution P(∙∣s, a). The cost for a given pair of S and a is c(s, a), which is sampled
from the cost distribution C(s, a) with mean value c(s, a). A stationary stochastic policy π(a∣s)
computes the probability of generating action a given state s.
The value function VMπ and the state action cost-to-go QπM ,h(s, a) ofπ on M0 are defined as:
∞
VMMo(S) = E[XYtc(St,at)|so = s,a~π], QMO(s,a) = ElcGa) + γEs0~Psa[VMnIo(SO)]],
t=0
where the expectation is taken with respect to the randomness of M0 and the stochastic policy π .
With VMπ and QπM , we define the disadvantage2 function AπM (S, a) = QπM (S, a) - VMπ (S).
The objective is to search for the optimal policy π* such that π* = argmin∏ Vπ(s), ∀s ∈ S.
Throughout this work, We assume access to an cost-to-go oracle Ve(s) : S → R. Note that We
do not require Ve(s) to be equal to VM0. For example, Ve(s) could be obtained by learning from
trajectories demonstrated by the expert πe (e.g., Temporal Difference Learning (Sutton & Barto,
1998)), or Ve could be computed by near-optimal search algorithms via access to ground truth
information (DaUme In et al., 2009; Chang et al., 2015; Sun et al., 2016) or via access to a simulator
using Dynamic Programming (DP) techniques (Choudhury et al., 2017; Pan et al., 2017). In our
experiment, We focus on the setting where We learn a Ve(s) using TD methods from a set of expert
demonstrations.
2.1	Cost Shaping
Given the original MDP M0 and any potential functions Φ : S → R, we can reshape the cost c(s, a)
sampled from C(s, a) to be:
c0(s, a) = c(s, a) + γΦ(s0) - Φ(s), s0 〜Psa.	(1)
Denote the new MDP M as the MDP obtained by replacing c by c0 in M0: M = (S, A, P, c0, γ).
Ng et al. (1999) showed that the optimal policy ∏M on M and the optimal policy ∏Mo on the
original MDP are the same: ∏M(s) = ∏Mo (s), ∀s. In other words, if we can successfully find ∏M
on M, then we also find ∏Mo, the optimal policy on the original MDP Mo that we ultimately want
to optimize.
2We call Aπ as the disadvantage function as we are working in the cost setting.
3
Published as a conference paper at ICLR 2018
2.2	Imitation Learning
In IL, when given a cost-to-go oracle V e, we can use it as a potential function for cost shaping.
Specifically let Us define the disadvantage Ae(s, a) = c(s,a) + γEs,〜psa[Ve(s0)] - Ve(s). As
cost shaping does not change the optimal policy, we can rephrase the original policy search problem
Using the shaped cost:
∞
∏* = arg min E[£ Y tAe(st ,at )∣so = s, a 〜∏],	(2)
π	t=0
for all s ∈ S . ThoUgh Eq. 2 provides an alternative objective for policy search, it coUld be as hard as
the original problem as E[Pt γtAe(st, at)] is jUst eqUal to E[Pt γtc(st, at) - Ve(s0)], which can
be easily verified Using the definition of cost shaping and a telescoping sUm trick.
As directly optimizing Eq 2 is as difficUlt as policy search in the original MDP, previoUs IL al-
gorithms sUch as AggreVaTe essentially ignore temporal correlations between states and actions
along the planning horizon and directly perform a policy iteration over the expert policy at every
state, i.e., they are greedy with respect to Ae as π(s) = arg min° Ae(s, a), ∀s ∈ S. The policy iter-
ation theorem guarantees that such a greedy policy ∏ performs at least as well as the expert. Hence,
when the expert is optimal, the greedy policy ∏ is guaranteed to be optimal. However when Ve is
not the optimal value function, the greedy policy ∏ over Ae is a one-step deviation improvement
over the expert but is not guaranteed to be close to the optimal ∏*. We analyze in detail how poor
the policy resulting from such a greedy policy improvement method could be when Ve is far away
from the optimal value function in Sec. 3.
3 Effectivenes s of Cost-to-go oracle on Planning Horizon
In this section we study the dependency of effective planning horizon on the cost-to-go oracle. We
focus on the setting where we have access to an oracle Ve(s) which approximates the cost-to-go
of some expert policy πe (e.g., Ve could be designed by domain knowledge (Ng et al., 1999) or
learned from a set of expert demonstrations). We assume the oracle is close to VMo, but imperfect:
|Ve — VMo | = E for some E ∈ R+. We first show that with such an imperfect oracle, previous
IL algorithms AggreVaTe and AggreVaTe D (Ross & Bagnell, 2014; Sun et al., 2017) are only
guaranteed to learn apolicy that is γe∕(1-γ) away from the optimal. Let us define the expected total
cost for any policy ∏ as J(∏) = Es0〜V [VMo (so)], measured under some initial state distribution V
and the original MDP M0 .
EI-	EI	∙ .	λ Λr›,n	1	r	ι TVQ / ∖	■ . 1 ITAT^0∕ ∖ T ΛΛ	/ ∖ I
Theorem 3.1. There exists an MDP and an imperfect oracle Ve(s) With |Ve(s) — VMcι,h(s)∣
E, such that the performance of the induced policy from the cost-to-go oracle ∏*
arg mina
[c(s,a) + YEs0 〜Psa [V e(SO )]]
is at least Ω(ye∕(1 — Y)) away from the optimal policy
*
π :
J(∏*) - J(∏*) ≥ Ω(1—^E
(3)
EI	i' ∙ . ) .Λ	.	. 1	1	FC	1 ∙ *	1∙ * 1 ʌ	.人Q /	∖	/	∖
The proof with the constructed example can be found in Appendix A. Denote Qe(s, a) = c(s, a) +
γEsO[Ve(s0)], in high level, we construct an example where Qe is close to Q* in terms of ∣∣(Qe -
Q * k ∞, but the order of the actions induced by Qe is different from the order of the actions from Q *,
hence forcing the induced policy ∏* to make mistakes.
As AGGREVATE at best computes a policy that is one-step improvement over the oracle, i.e., ∏*
arg mina
[c(s,a) + Y Es'〜Psa
[Ve(s0)]], it eventually
has to suffer from the above lower bound.
This E gap in fact is not surprising as AGGREVATE is a one-step greedy algorithm in a sense that it
is only optimizing the one-step cost function c0 from the reshaped MDP M. To see this, note that
the cost of the reshaped MDP M is E[c0(s, a)] = [c(s, a) + γEs,〜Psa Ve(s0) - Ve(s)], and we have
π*(s) = arg min。E[c0(s, a)]. Hence AggreVaTe can be regarded as a special algorithm that aims
to optimizing the one-step cost of MDP M that is reshaped from the original MDP M0 using the
cost-to-go oracle.
4
Published as a conference paper at ICLR 2018
Though when the cost-to-go oracle is imperfect, AggreVaTe will suffer from the above lower
bound due to being greedy, when the cost-to-go oracle is perfect, i.e., Ve = V*, being greedy on
one-step cost makes perfect sense. To see this, use the property of the cost shaping (Ng et al., 1999),
We can verify that when Ve = V*:
VM(s) = 0,	∏M(s) = argminE[c0(s,a)],	∀s ∈ S.	(4)
a
Namely the optimal policy on the reshaped MDP M only optimizes the one-step cost, which indi-
cates that the optimal cost-to-go oracle shortens the planning horizon to one: finding the optimal
policy on M0 becomes equivalent to optimizing the immediate cost function on M at every state s.
When the cost-to-go oracle is away from the optimality, we lose the one-step greedy property
shown in Eq. 4. In the next section, we show that how we can break the lower bound Ω(e∕(l - Y))
only with access to an imperfect cost-to-go oracle Ve, by being less greedy and looking head for
more than one-step.
3.1 Outperforming the Expert
Given the reshaped MDP M with Ve as the potential function, as we mentioned in Sec. 2.2, directly
optimizing Eq. 2 is as difficult as the original policy search problem, we instead propose to minimize
the total cost ofa policy π over a finite k ≥ 1 steps at any state s ∈ S:
EhX γi-1c0(si,ai)∣sι = s; a 〜∏∣ ∙	(5)
i=1
Using the definition of cost shaping and telescoping sum trick,we can re-write Eq. 5 in the following
format, which we define as k-step disadvantage with respect to the cost-to-go oracle:
EhX YiTc(Si,ai) + YkVe(sk+ι) - Ve(sι)∣sι = s; a 〜π],∀s ∈ S.	(6)
i=1
We assume that our policy class Π is rich enough that there always exists a policy ∏* ∈ Π that
can simultaneously minimizes the k-step disadvantage at every state (e.g., policies in tabular rep-
resentation in discrete MDPs). Note that when k = 1, minimizing Eq. 6 becomes the problem of
finding a policy that minimizes the disadvantage AeM (s, a) with respect to the expert and reveals
AggreVaTe.
The following theorem shows that to outperform expert, we can optimize Eq. 6 with k > 1. Let us
denote the policy that minimizes Eq. 6 in every state as ∏*, and the value function of ∏* as Vπ.
Theorem 3.2. Assume π* minimizesEq.6for every state S ∈ S with k > 1 and |Ve(s) — V*(s)∣ =
Θ(), ∀s. We have :
J(π*) - J(π*) ≤ O
(7)
Compare the above theorem to the lower bound shown in Theorem 3.1, we can see that when k > 1,
we are able to learn a policy that performs better than the policy induced by the oracle (i.e.,∏*(s)=
argmina Qe(s, a)) by at least (ɪ-Y - ɪ-Yk )e. The proof can be found in Appendix B.
Theorem 3.2 and Theorem 3.1 together summarize that when the expert is imperfect, simply com-
puting a policy that minimizes the one-step disadvantage (i.e., (k = 1)) is not sufficient to guarantee
near-optimal performance; however, optimizing a k-step disadvantage with k > 1 leads to a policy
that guarantees to outperform the policy induced by the oracle (i.e., the best possible policy that can
be learnt using AggreVaTe and AggreVaTeD). Also our theorem provides a concrete perfor-
mance gap between the policy that optimizes Eq. 6 for k > 1 and the policy that induced by the
oracle, which is missing in previous work (e.g., (Chang et al., 2015)).
As we already showed, ifwe set k = 1, then optimizing Eq. 6 becomes optimizing the disadvantage
over the expert AeM , which is exactly what AGGREVATE aims for. When we set k = ∞, optimizing
Eq. 6 or Eq. 5 just becomes optimizing the total cost of the original MDP. Optimizing over a shorter
5
Published as a conference paper at ICLR 2018
Algorithm 1 Truncated Horizon Policy Search (THOR)
1:	Input: The original MDP M0 . Truncation Step k. Oracle V e .
2:	Initialize policy ∏θ0 with parameter θ° and truncated advantage estimator AM,k.
3:	for n = 0, ... do
4:	Reset system.
5:	Execute πθn to generate a set of trajectories {τi}iN=1.
6:	Reshape cost c0(st,at) = c(st,at) + V+1(st+1) - Ve(st), for every t ∈ [1,兀|] in every
trajectory τi, i ∈ [N].
7:	Compute gradient:
XX
Vθ(ln∏θ(at∣st))∣θ=θnAM,k(st, at)	(8)
τi	t
8:	Update disadvantage estimator to AMn,k using {方卜 with reshaped cost C.
9:	Update policy parameter to θn+1 .
10:	end for
finite horizon is easier than optimizing over the entire infinite long horizon due to advantages such
as smaller variance of the empirical estimation of the objective function, less temporal correlations
between states and costs along a shorter trajectory. Hence our main theorem essentially provides a
tradeoff between the optimality of the solution ∏* and the difficulty of the underlying optimization
problem.
4 Practical Algorithm
Given the original MDP Mo and the cost-to-go oracle Ve, the reshaped MDP's cost function c0 is
obtained from Eq. 1 using the cost-to-go oracle as a potential function. Instead of directly applying
RL algorithms on M0, we use the fact that the cost-to-go oracle shortens the effective planning
horizon of M, and propose THOR: Truncated HORizon Policy Search summarized in Alg. 1. The
general idea of THOR is that instead of searching for policies that optimize the total cost over the
entire infinitely long horizon, we focus on searching for polices that minimizes the total cost over a
truncated horizon, i.e., a k-step time window. Below we first show how we derive THOR from the
insight we obtained in Sec. 3.
Let us define a k-step truncated value function VMπ,k and similar state action value function QπM,k on
the reshaped MDP M as:
VMk(S) = EhXYtTcO(St,at)|si = s,a ~ πi,
t=1
k-1
QM(s,a) = E卜0(s,a) + X Yic0(si,ai)∣Si 〜PsaW ∏(si)],
i=1
(9)
At any time state s, VMπ,k only considers (reshaped) cost signals c0 from a k-step time window.
We are interested in searching for a policy that can optimizes the total cost over a finite k-step
horizon as shown in Eq. 5. For MDPs with large or continuous state spaces, we cannot afford to
enumerate all states s ∈ S to find a policy that minimizes the k-step disadvantage function as in
Eq. 5. Instead one can leverage the approximate policy iteration idea and minimize the weighted
cost over state space using a state distribution ν (Kakade & Langford, 2002; Bagnell et al., 2004):
min Eso 〜V
π∈Π	0
k
h X Yic0(
i=1
Si, ai)∣a 〜∏
(10)
E
.
For parameterized policy π (e.g., neural network policies), we can implement the minimization in
Eq. 10 using gradient-based update procedures (e.g., Stochastic Gradient Descent, Natural Gradient
(Kakade, 2002; Bagnell & Schneider, 2003)) in the policy’s parameter space. In the setting where
6
Published as a conference paper at ICLR 2018
the system cannot be reset to any state, a typical choice of exploration policy is the currently learned
policy (possibly mixed with a random process (Lillicrap et al., 2015) to futher encourage explo-
ration). Denote ∏n as the currently learned policy after iteration n and Prnn (∙) as the average state
distribution induced by executing πn (parameterized by θn) on the MDP. Replacing the exploration
distribution by Prnn (∙) in Eq. 10, and taking the derivative with respect to the policy parameter θ,
the policy gradient is:
k	k+i
Es 〜Prnn ETk 〜∏n [X Vθ ln n(ai|si； θ)(X YL-C(Sj ,aj ))]
i=1	j=i
k
≈ Es〜Prnn ETk〜∏n[X Vθ ln∏(a-∣s-; θ)QMk(s-,a-)]
i=1
where Tk 〜 πn denotes a partial k-step trajectory Tk = {sι,aι,…，Sk,a+ ∣sι = s} sampled
from executing πn on the MDP from state s. Replacing the expectation by empirical samples from
∏n, replacing Q∏Mk by a critic approximated by Generalized disadvantage Estimator (GAE) AMMj
(Schulman et al., 2016), we get back to the gradient used in Alg. 1:
k
Es 〜Prnn ETk 〜∏n D : V θ ln n(ai|si; θ)Q M (Si,ai)]
i=1
|T|
≈ k X (X Vθ ln(π(at∣St; θ))AMM(st")/H,	(11)
T	t=1
where |T | denotes the length of the trajectory T .
4.1	Interpretation using Truncated Back-Propagation Through Time
If using the classic policy gradient formulation on the reshaped MDP M we should have the fol-
lowing expression, which is just a re-formulation of the classic policy gradient (Williams, 1992):
|T|	t-1
ET X (Ct X(Vθ ln∏(at-i∣st--; θ))),	(12)
t=1	i=0
which is true since the cost c0i (we denote c0i(S, a) as c0i for notation simplicity) at time step i is
correlated with the actions at time step t = i all the way back to the beginning t = 1. In other
words, in the policy gradient format, the effectiveness of the cost ct is back-propagated through time
all the way back the first step. Our proposed gradient formulation in Alg. 1 shares a similar spirit
of Truncated Back-Propagation Through Time (Zipser, 1990), and can be regarded as a truncated
version of the classic policy gradient formulation: at any time step t, the cost c0 is back-propagated
through time at most k-steps:
|T|	k-1
ET X(Ct X(Vθ lnπ(at-i∣st--; θ))),	(13)
t=1	i=0
In Eq. 13, for any time step t, we ignore the correlation between C0t and the actions that are executed
k-step before t, hence elimiates long temporal correlations between costs and old actions. In fact,
AGGREVATE D (Sun et al., 2017), a policy gradient version of AGGREVATE, sets k = 1 and can be
regarded as No Back-Propagation Through Time.
7
Published as a conference paper at ICLR 2018
4.2	Connection to IL and RL
The above gradient formulation provides a natural half-way point between IL and RL. When k = 1
and Ve = VMMo (the optimal value function in the original MDP Mo):
|T |
|T |
ET [X Nθ(ln∏θ(at∣st))AM,1(st, at)] = ET [X Nθ(ln∏θ(at∣st))QM,1(st, at)]
t=1	t=1
|T |	|T|
=ET [XNθ(ln∏θ(at∣st))E[c0(st, at)]] = ET [XNθ(ln∏θ(at∣st))AM°(st, at)],	(14)
t=1	t=1
where, for notation simplicity, we here use ET to represent the expectation over trajectories sampled
*___
from executing policy πθ, and AπM is the advantage function on the original MDP M0. The fourth
expression in the above equation is exactly the gradient proposed by AggreVaTeD (Sun et al.,
2017). AggreVaTeD performs gradient descent with gradient in the format of the fourth expres-
Sion in Eq. 14 to discourage the log-likelihood of an action at that has low advantage over ∏* at a
given state st.
On the other hand, when we set k = ∞, i.e., no truncation on horizon, then we return back to the
classic policy gradient on the MDP M obtained from cost shaping with Ve. As optimizing M is
the same as optimizing the original MDP M0 (Ng et al., 1999), our formulation is equivalent to a
pure RL approach on M°. In the extreme case when the oracle Ve has nothing to do with the true
optimal oracle V*, as there is no useful information We can distill from the oracle and RL becomes
the only approach to solve M0 .
5 Experiments
We evaluated THOR on robotics simulators from OpenAI Gym (Brockman et al., 2016). Throughout
this section, we report reward instead of cost, since OpenAI Gym by default uses reward. The
baseline we compare against is TRPO-GAE (Schulman et al., 2016) and AggreVaTeD (Sun et al.,
2017).
To simulate oracles, we first train TRPO-GAE until convergence to obtain a policy as an expert πe .
We then collected a batch of trajectories by executing πe. Finally, we use TD learning Sutton (1988)
to train a value function VV that approximates Ve. In all our experiments, We ignored ∏e and only
used the pre-trained Ve for reward shaping. Hence our experimental setting simulates the situation
where we only have a batch of expert demonstrations available, and not the experts themselves. This
is a much harder setting than the interactive setting considered in previous work (Ross et al., 2011;
Sun et al., 2017; Chang et al., 2015). Note that πe is not guaranteed to be an optimal policy, and
Ve is only trained on the demonstrations from πe, therefore the oracle Ve is just a coarse estimator
of VMo. Our goal is to show that, compared to AggreVaTeD, THOR with k > 1 results in
significantly better performance; compared to TRPO-GAE, THOR with some k << H converges
faster and is more sample efficient. For fair comparison to RL approaches, we do not pre-train policy
or critic A using demonstration data, though initialization using demonstration data is suggested in
theory and has been used in practice to boost the performance (Ross et al., 2011; Bahdanau et al.,
2016).
For all methods we report statistics (mean and standard deviation) from 25 seeds that are i.i.d gen-
erated. For trust region optimization on the actor πθ and GAE on the critic, we simply use the
recommended parameters in the code-base from TRPO-GAE (Schulman et al., 2016). We did not
tune any parameters except the truncation length k.
5.1	Discrete Action Control
We consider two discrete action control tasks with sparse rewards: Mountain-Car, Acrobot and a
modified sparse reward version of CartPole. All simulations have sparse reward in the sense that no
reward signal is given until the policy succeeds (e.g., Acrobot swings up). In these settings, pure RL
approaches that rely on random exploration strategies, suffer from the reward sparsity. On the other
8
Published as a conference paper at ICLR 2018
(a) Mountain Car With H = 200
Acrobot-vl
(b) SR-CartPole with H = 200
-100
EnldH
-400
-500
O 25	50
-220 -
75 IOO 125	150	175	20t O
Batch Iteration
-100 -
Ensα
-180-
-160 -
-200-
Acrobot-vl
25	50	75	100	125	150	175	200
Batch Iteration
(c) Acrobot With H = 500	(d) Acrobot With H = 200
Figure 1: ReWard versus batch iterations of THOR With different k and TRPO-GAE (blue) for
Mountain car, Sparse ReWard (SR) CartPole, and Acrobot With different horizon. Average reWards
across 25 runs are shoWn in solid lines and averages + std are shoWn in dotted lines.
hand, THOR can leverage oracle information for more efficient exploration. Results are shoWn in
Fig. 1.
Note that in our setting where Ve is imperfect, THOR with k > 1 works much better than AG-
GREVATED (THOR With k = 1) in Acrobot. In Mountain Car, We observe that AGGREVATED
achieves good performance in terms of the mean, but THOR with k > 1 (especially k = 10) results
in much higher mean+std, which means that once THOR receives the reward signal, it can leverage
this signal to perform better than the oracles.
We also show that THOR with k > 1 (but much smaller than H) can perform better than TRPO-
GAE. In general, as k increases, we get better performance. We make the acrobot setting even
harder by setting H = 200 to even reduce the chance of a random policy to receive reward signals.
Compare Fig. 1 (c) to Fig. 1 (b), we can see that THOR with different settings of k always learns
faster than TRPO-GAE, and THOR with k = 50 and k = 100 significantly outperform TRPO-GAE
in both mean and mean+std. This indicates that THOR can leverage both reward signals (to perform
better than AggreVaTeD) and the oracles (to learn faster or even outperform TRPO).
5.2 Continuous Action Control
We tested our approach on simulators with continuous state and actions from MuJoCo simulators:
a modified sparse reward Inverted Pendulum, a modifed sparse reward Inverted Double Pendulum,
Hopper and Swimmer. Note that, compared to the sparse reward setting, Hopper and Swimmer
do not have reward sparsity and policy gradient methods have shown great results (Schulman et al.,
2015; 2016). Also, due to the much larger and more complex state space and control space compared
to the simulations we consider in the previous section, the value function estimator V e is much less
9
Published as a conference paper at ICLR 2018
1000-
InvertedPenduIum-
0
0	20
40	60
Batch Iteration
I nve rtedDoub IePe nd u lum-vl
20	40	60	80	100
Batch Iteration
(a) SR-Inverted Pendulum (H=1000)	(b) SR-Inverted Double Pendulum (H=1000)
Swlmmer-Vl
8 6 4
0	25	50	75	100	125	150	175	2 OC
Batch Iteration
Hopper-vl
0	25	50	75	100	125	150	175	200
Batch Iteration
(d) Hopper (H=1000)
(c) Swimmer (H=1000)

Figure 2: Reward versus batch iterations of THOR with different k and TRPO-GAE (blue) for
Sparse Reward (SR) Inverted Pendulum, Sparse Reward Inverted-Double Pendulum, Swimmer and
Hopper. Average rewards across 25 runs are shown in solid lines and averages + std are shown in
dotted lines.
accurate in terms of estimating VMMo since the trajectories demonstrated from experts may only cover
a very small part of the state and control space. Fig. 2 shows the results of our approach. For all
simulations, We require k to be around 20% 〜30% of the original planning horizon H to achieve
good performance. AGGREVATED (k = 1) learned very little due to the imperfect value function
estimator V e . We also tested k = H, Where We observe that reWard shaping With V e gives better
performance than TRPO-GAE. This empirical observation is consistent With the observation from
(Ng et al., 1999) ( Ng et al. (1999) used SARSA (Sutton, 1988), not policy gradient based methods).
This indicates that even when VVe is not close to V*, policy gradient methods can still employ the
oracle Ve just via reward shaping.
Finally, we also observed that our approach significantly reduces the variance of the performance
of the learned polices (e.g., Swimmer in Fig. 2(a)) in all experiments, including the sparse reward
setting. This is because truncation can significantly reduce the variance from the policy gradient
estimation when k is small compared to H.
6 Conclusion
We propose a novel way of combining IL and RL through the idea of cost shaping with an expert
oracle. Our theory indicates that cost shaping with the oracle shortens the learner’s planning horizon
as a function of the accuracy of the oracle compared to the optimal policy’s value function. Specifi-
cally, when the oracle is the optimal value function, we show that by setting k = 1 reveals previous
imitation learning algorithm AggreVaTeD. On the other hand, we show that when the oracle is
imperfect, using planning horizon k > 1 can learn a policy that outperforms a policy that would
been learned by AGGREVATE and AGGREVATED (i.e., k = 1). With this insight, we propose
10
Published as a conference paper at ICLR 2018
THOR (Truncated HORizon policy search), a gradient based policy search algorithm that explicitly
focusing on minimizing the total cost over a finite planning horizon. Our formulation provides a nat-
ural half-way point between IL and RL, and experimentally we demonstrate that with a reasonably
accurate oracle, our approach can outperform RL and IL baselines.
We believe our high-level idea of shaping the cost with the oracle and then focusing on optimizing
a shorter planning horizon is not limited to the practical algorithm we proposed in this work. In fact
our idea can be combined with other RL techniques such as Deep Deterministic Policy Gradient
(DDPG) (Lillicrap et al., 2015), which has an extra potential advantage of storing extra information
from the expert such as the offline demonstrations in its replay buffer (Vecer´k et al. (2017)). Though
in our experiments, We simply used some expert,s demonstrations to pre-train Ve using TD learning,
there are other possible ways to learn a more accurate Ve. For instance, if an expert is available
during training (Ross et al., 2011), one can online update Ve by querying expert,s feedback.
ACKNOWLEDGEMENT
Wen Sun is supported in part by Office of Naval Research contract N000141512365. The authors
also thank Arun Venkatraman and Geoff Gordon for value discussion.
References
Pieter Abbeel and Andrew Y Ng. Apprenticeship learning via inverse reinforcement learning. In
ICML, pp. 1. ACM, 2004.
J Andrew Bagnell and Jeff Schneider. Covariant policy search. In IJCAI, 2003.
J Andrew Bagnell, Sham M Kakade, Jeff G Schneider, and Andrew Y Ng. Policy search by dynamic
programming. In Advances in neural information processing systems, pp. 831-838, 2004.
Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu, Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron
Courville, and Yoshua Bengio. An actor-critic algorithm for sequence prediction. arXiv preprint
arXiv:1607.07086, 2016.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym, 2016.
Kai-wei Chang, Akshay Krishnamurthy, Alekh Agarwal, Hal Daume, and John Langford. Learning
to search better than your teacher. In ICML, 2015.
Sanjiban Choudhury, Ashish Kapoor, Gireeja Ranade, and Debadeepta Dey. Learning to gather
information via imitation. In Robotics and Automation (ICRA), 2017 IEEE International Confer-
ence on, pp. 908-915. IEEE, 2017.
Hal DaUme III, John Langford, and Daniel Marcu. Search-based structured prediction. Machine
learning, 2009.
Amir-massoud Farahmand, Daniel Nikolaev Nikovski, Yuji Igarashi, and Hiroki Konaka. Truncated
approximate dynamic programming with task-dependent terminal value. In AAAI, pp. 3123-3129,
2016.
Victor Gabillon, Alessandro Lazaric, Mohammad Ghavamzadeh, and Bruno Scherrer.
Classification-based policy iteration with a critic. 2011.
Sham Kakade. A natural policy gradient. NIPS, 2002.
Sham Kakade and John Langford. Approximately optimal approximate reinforcement learning. In
ICML, 2002.
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa,
David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv
preprint arXiv:1509.02971, 2015.
11
Published as a conference paper at ICLR 2018
Volodymyr Mnih et al. Human-level control through deep reinforcement learning. Nature, 2015.
Ashvin Nair, Bob McGrew, Marcin Andrychowicz, Wojciech Zaremba, and Pieter Abbeel.
Overcoming exploration in reinforcement learning with demonstrations. arXiv preprint
arXiv:1709.10089, 2017.
Andrew Y Ng. Shaping and policy search in reinforcement learning. PhD thesis, University of
California, Berkeley, 2003.
Andrew Y Ng, Daishi Harada, and Stuart Russell. Policy invariance under reward transformations:
Theory and application to reward shaping. In ICML, volume 99, pp. 278-287, 1999.
Yunpeng Pan, Ching-An Cheng, Kamil Saigol, Keuntaek Lee, Xinyan Yan, Evangelos Theodorou,
and Byron Boots. Agile off-road autonomous driving using end-to-end deep imitation learning.
arXiv preprint arXiv:1709.07174, 2017.
Aravind Rajeswaran, Vikash Kumar, Abhishek Gupta, John Schulman, Emanuel Todorov, and
Sergey Levine. Learning complex dexterous manipulation with deep reinforcement learning and
demonstrations. arXiv preprint arXiv:1709.10087, 2017.
Stephane Ross and J Andrew Bagnell. Reinforcement and imitation learning via interactive no-regret
learning. arXiv preprint arXiv:1406.5979, 2014.
Stephane Ross, Geoffrey J Gordon, and J.Andrew Bagnell. A reduction of imitation learning and
structured prediction to no-regret online learning. In AISTATS, 2011.
John Schulman, Sergey Levine, Pieter Abbeel, Michael I Jordan, and Philipp Moritz. Trust region
policy optimization. In ICML, pp. 1889-1897, 2015.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-
dimensional continuous control using generalized advantage estimation. ICLR, 2016.
David Silver et al. Mastering the game of go with deep neural networks and tree search. Nature,
2016.
Wen Sun, Arun Venkatraman, Byron Boots, andJ Andrew Bagnell. Learning to filter with predictive
state inference machines. In ICML, 2016.
Wen Sun, Arun Venkatraman, Geoffrey J Gordon, Byron Boots, and J Andrew Bagnell. Deeply
aggrevated: Differentiable imitation learning for sequential prediction. 2017.
Richard S Sutton and Andrew G Barto. Introduction to reinforcement learning, volume 135. MIT
Press Cambridge, 1998.
RichardS. Sutton. Learning to predict by the methods of temporal differences. Machine Learning,
3:9-44, 1988.
Matej Vecerlk, Todd Hester, Jonathan Scholz, FUmin Wang, Olivier Pietquin, Bilal Piot, Nico-
las Heess, Thomas Rothorl, Thomas Lampe, and Martin Riedmiller. Leveraging demonstra-
tions for deep reinforcement learning on robotics problems with sparse rewards. arXiv preprint
arXiv:1707.08817, 2017.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine learning, 1992.
David Zipser. Subgrouping reduces complexity and speeds up learning in recurrent networks. In
Advances in neural information processing systems, pp. 638-641, 1990.
12
Published as a conference paper at ICLR 2018
A Proof of Theorem 3.1
Figure 3: The special MDP we constructed for theorem 3.1
Proof. We prove the theorem by constructing a special MDP shown in Fig 3, where H = ∞. The
MDP has deterministic transition, 2H + 2 states, and each state has two actions a1 and a2 as shown
in Fig. 3. Every episode starts at state s0 . For state si (states on the top line), we have c(si) = 0 and
for state s0i (states at the bottom line) we have c(si) = 1.
It is clear that for any state si, we have Q* (si, a1) = 0, Q* (si, a2) = γ, Q* (s0i, a1) = 1 and
ʌ

Q*(s0i, a2) = 1 + γ, for i ≥ 1. Let us assume that we have an oracle V e such that V e(si) = 0.5 + δ
and V e(s0i) = 0.5 - δ, for some positive real number δ. Hence we can see that |V e(s) - V *(s)| =
0.5 + δ, for all s. Denote Qe(s, a) = c(s, a) + YEso-Psa[Ve(s0)], we know that Qe(Si, α1)=
^
ʌ
^
γ(0.5 + δ), Qe(si,a2) = γ(0.5 - δ), Qe(si,aι) = 1 + γ(0.5 + δ) and Qe(si,a?) = 1 + γ(0.5 - δ).
It is clear that the optimal policy π* has cost J(π*) = 0. Now let US compute the cost of the induced
ʌ
ʌ
policy from oracle Qe: π(s) = argmma Qe(s, a). As We can see π makes a mistake at every
γ
state as argmma Qe(s, a) = argmma Q*(s, a). Hence we have J(π) = ɪ--^. Recall that in our
constructed example, we have = 0.5 + δ. Now let δ → 0+ (by δ → 0+ we mean δ approaches to
zero from the right side), we have e → 0.5, hence J(π) = ɪ--^ → ɪ-γe (due to the fact 2e → 1).
Hence we have J(π) — J(π*) = Ω 1-Y^ 6
□
B Proof of Theorem 3.2
Below we prove Theorem 3.2.
Proof of Theorem 3.2. In this proof, for notation simplicity, we denote VMπ as Vπ for any π. Using
the definition of value function Vπ , for any state sɪ ∈ S we have:
iY
kX i=i
h
E
=
Vπ* (si) - V*(sι)
kk
=E[X Yi-ic(Si, ai) + YkVπ* (sk+i)∣∏*] - E[X Yi-1c(Si,电)+ YkV*(sk+i)∣∏*]
i=1	i=1
k
T C(Si ,ai)+ Y k Vπ * (sk+1 )∣∏ *] - e[ X Y -⑹,电)+ Yk V * (sk+i )∣∏ *]
i=1
Y i-ic(si ,ai)+ Yk V * (sk+i )∣∏ * i - EhX Y 一%3,电)+ Yk V*(sk+i )∣π [
i=1
(sk+1) - V* (sk+1 )i
Yi-i C(Si ,ai)+ Yk V * (sk+i )∣∏ * i - EhX Yi-i C(Si,电)+ Yk V * (sk+i )∣∏ [
士 7二工』
hhh
EEE
+k +
(15)
13
Published as a conference paper at ICLR 2018
Using the fact that kV*(s) - Ve(s)∣∣ ≤ e, We have that:
k	k
e[ X YiTC(Si,αi) + YkV*(sk+ι)∣∏*] ≤ e[ X Yi-1c(si,ai)+ YkVe(sk+ι)∣∏*] + γke,
i=1	i=1
e[XYiTC(Si,αi) + YkV*(sk+ι)∣π*i ≥ e[]TYi-1c(si,αi)+ γkVe(sk+ι)∣π*] TJ
i=1	i=1
Substitute the above two inequality into Eq. 15, we have:
Vπ*(s1) - V*(sι) ≤ YkE [Vπ*(sk+ι) - V*(sk+ι)] + 2Ykj
+ e[X Yi-1c(si,ai) + YkVe(sk+ι)∣∏[ - e[XYiTC(Si,αi) + YkVe(sk+ι)∣π[
i=1	i=1
≤ YkE [v余* (Sk+1) - V*(sk+ι)] +2ykJ
+ E[X yi-1c(si, αi) + γkVe(sk+ι)∣∏*] - E[X YiTC(Si, ai) + YkVe(sk+ι)∣∏*]
i=1	i=1
=γkE [v余* (Sk+1) - V*(sk+ι)] +2γk J	(16)
where the second inequality comes from the fact that π* is the minimizer from Eq. 6. Recursively
expand Vπ* (sk+ι) - V*(sk+ι) using the above procedure, we can get:
Vπ*(S1) - V*(S1) ≤ 2γkJ(1+ γk + γ2k + ...) ≤ -^γkkJ = O(T^kTj).	(17)
1 - Y1 - Y
Since the above inequality holds for any si ∈ S, for any initial distribution v over state space S, we
k
will have J(π*) - J(π*) ≤ O(占e).	□
14