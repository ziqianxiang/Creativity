Published as a conference paper at ICLR 2018
Backpropagation through the Void:
Optimizing control variates for
black-box gradient estimation
Will Grathwohl, Dami Choi, Yuhuai Wu, Geoffrey Roeder, David Duvenaud
University of Toronto and Vector Institute
{wgrathwohl, choidami, ywu, roeder, duvenaud}@cs.toronto.edu
Ab stract
Gradient-based optimization is the foundation of deep learning and reinforcement
learning, but is difficult to apply when the mechanism being optimized is unknown
or not differentiable. We introduce a general framework for learning low-variance,
unbiased gradient estimators, applicable to black-box functions of discrete or
continuous random variables. Our method uses gradients of a surrogate neural
network to construct a control variate, which is optimized jointly with the original
parameters. We demonstrate this framework for training discrete latent-variable
models. We also give an unbiased, action-conditional extension of the advantage
actor-critic reinforcement learning algorithm.
1	Introduction
Gradient-based optimization has been key to most recent advances in machine learning and rein-
forcement learning. The back-propagation algorithm (Rumelhart & Hinton, 1986), also known as
reverse-mode automatic differentiation (Speelpenning, 1980; Rall, 1981) computes exact gradients
of deterministic, differentiable objective functions. The reparameterization trick (Williams, 1992;
Kingma & Welling, 2014; Rezende et al., 2014) allows backpropagation to give unbiased, low-
variance estimates of gradients of expectations of continuous random variables. This has allowed
effective stochastic optimization of large probabilistic latent-variable models.
Unfortunately, there are many objective functions relevant to the machine learning community for
which backpropagation cannot be applied. In reinforcement learning, for example, the function being
optimized is unknown to the agent and is treated as a black box (Schulman et al., 2015a). Similarly,
when fitting probabilistic models with discrete latent variables, discrete sampling operations create
discontinuities giving the objective function zero gradient with respect to its parameters. Much recent
work has been devoted to constructing gradient estimators for these situations. In reinforcement
learning, advantage actor-critic methods (Sutton et al., 2000) give unbiased gradient estimates with
reduced variance obtained by jointly optimizing the policy parameters with an estimate of the value
function. In discrete latent-variable models, low-variance but biased gradient estimates can be given
by continuous relaxations of discrete variables (Maddison et al., 2016; Jang et al., 2016).
A recent advance by Tucker et al. (2017) used a continuous relaxation of discrete random variables to
build an unbiased and lower-variance gradient estimator, and showed how to tune the free parameters
of these relaxations to minimize the estimator’s variance during training. We generalize the method
of Tucker et al. (2017) to learn a free-form control variate parameterized by a neural network. This
gives a lower-variance, unbiased gradient estimator which can be applied to a wider variety of
problems. Most notably, our method is applicable even when no continuous relaxation is available, as
in reinforcement learning or black-box function optimization.
2	Background: Gradient estimators
How can we choose the parameters of a distribution to maximize an expectation? This problem
comes up in reinforcement learning, where we must choose the parameters θ of a policy distribu-
tion ∏(a∣s, θ) to maximize the expected reward ET〜∏ [R] over state-action trajectories T. It also
1
Published as a conference paper at ICLR 2018
Figure 1: Left: Training curves comparing different gradient estimators on a toy problem:
L(θ) = Ep(b∣θ)[(b - 0.499)2] Right: Log-variance of each estimator's gradient.
Q.5Q.5Q.5Q
5 7 0 2 5 7 0
- -IIII 2
- - - - -
SeleE q swcφpe,loM—o e。UeUe> 60—1
comes up in fitting latent-variable models, when we wish to maximize the marginal probability
p(χ∣θ) = Pzp(χ∣z)p(z∣θ) = Ep(z∣θ) [p(x∣z)]. In this paper, we'll consider the general problem of
optimizing
L(θ)= Ep(b∣θ)[ f(b)].
(1)
When the parameters θ are high-dimensional, gradient-based optimization is appealing because it
provides information about how to adjust each parameter individually. Stochastic optimization is
essential for scalablility, but is only guaranteed to converge to a fixed point of the objective when the
stochastic gradients g are unbiased, i.e. E [g]= ∂∂θL(θ) (Robbins & Monro, 1951).
How can we build unbiased, stochastic gradient estimators? There are several standard methods:
The score-function gradient estimator One of the most generally-applicable gradient estimators
is known as the score-function estimator, or REINFORCE (Williams, 1992):
∂
^REINFORCE [f ] = f (b)	logP(blθ),	b ~ P(Mo)
∂θ
(2)
This estimator is unbiased, but in general has high variance. Intuitively, this estimator is limited by
the fact that it doesn’t use any information about how f depends on b, only on the final outcome f (b).
The reparameterization trick When f is continuous and differentiable, and the latent variables b
can be written as a deterministic, differentiable function of a random draw from a fixed distribution,
the reparameterization trick (Williams, 1992; Kingma & Welling, 2014; Rezende et al., 2014) creates
a low-variance, unbiased gradient estimator by making the dependence of b on θ explicit through a
reparameterization function b = T(θ, ):
A	∂ b	∂f∂T
Oreparam[f] = d0f (b) = ∂T∂θ， E 〜P(C)	(3)
This gradient estimator is often used when training high-dimensional, continuous latent-variable
models, such as variational autoencoders. One intuition for why this gradient estimator is preferable
to REINFORCE is that it depends on ∂f∕∂b, which exposes the dependence of f on b.
Control variates Control variates are a general method for reducing the variance of a stochastic
estimator. A control variate is a function c(b) with a known mean Ep(b) [c(b)]. Given an estimator
g(b), subtracting the control variate from this estimator and adding its mean gives us a new estimator:
^new(b) = ^(b) - c(b) + Ep(b)[c(b)]	(4)
This new estimator has the same expectation as the old one, but has lower variance if c(b) is positively
correlated with ^(b).
2
Published as a conference paper at ICLR 2018
3	Constructing and optimizing a differentiable surrogate
In this section, We introduce a gradient estimator for the expectation of a function 枭Ep(b∣θ) [f (b)] that
can be applied even when f is unknown, or not differentiable, or when b is discrete. Our estimator
combines the score function estimator, the reparameterization trick, and control variates.
First, We consider the case Where b is continuous, but that f cannot be differentiated. Instead of differ-
entiating through f, We build a surrogate of f using a neural netWork cφ, and differentiate cφ instead.
Since the score-function estimator and reparameterization estimator have the same expectation, We
can simply subtract the score-function estimator for cφ and add back its reparameterization estimator.
This gives a gradient estimator Which We call LAX:
,LAX =。REINFORCE [f ] -。REINFORCE [Cφ] + Oreparam [cφ]
=[f (b) - cφ(b)] ^d logP(b∣θ) + 得cφ(b)	b = T(θ,e),e 〜p(e).	(5)
∂ θ	∂ θ
This estimator is unbiased for any choice of cφ . When cφ = f, then LAX becomes the reparame-
terization estimator for f. Thus LAX can have variance at least as loW as the reparameterization
estimator. An example of the relative bias and variance of each term in this estimator can be seen
beloW.
unbiased	unbiased	biased	biased
low variance	high variance	high variance	low variance
Figure 2: Histograms of samples from the gradient estimators that create LAX. Samples generated
from our one-layer VAE experiments (Section 6.2).
3.1	Gradient-based optimization of the control variate
Since gLAX is unbiased for any choice of the surrogate cφ, the only remaining problem is to choose a
cφ that gives low variance to ^lax. How can we find a φ which gives our estimator low variance? We
simply optimize cφ using stochastic gradient descent, at the same time as We optimize the parameters
θ of our model or policy.
To optimize cφ , we require the gradient of the variance of our estimator. To estimate these gradients,
we could simply differentiate through the empirical variance over each mini-batch. Or, following
Ruiz et al. (2016a) and Tucker et al. (2017), we can construct an unbiased, single-sample estimator
using the fact that our gradient estimator is unbiased. For any unbiased gradient estimator g with
parameters φ:
《Varianæ⑼=∂L%2] -	E[g]2 =	E[g2] = E [∂φg2] .	⑹
Thus, an unbiased single-sample estimate of the gradient of the variance of g is given by ∂g2∕∂φ.
This method of directly minimizing the variance of the gradient estimator stands in contrast to other
methods such as Q-Prop (Gu et al., 2016) and advantage actor-critic (Sutton et al., 2000), which
train the control variate to minimize the squared error (f (b) - cφ(b))2. Our algorithm, which jointly
optimizes the parameters θ and the surrogate cφ is given in Algorithm 1.
3.1.1	Optimal surrogate
What is the form of the variance-minimizing cφ ? Inspecting the square of (5), we can see that this
loss encourages cφ(b) to approximate f (b), but with a weighting based on 条 logp(b∣θ). Moreover,
3
Published as a conference paper at ICLR 2018
as cφ → f then ^lax → 扁cφ. Thus, this objective encourages a balance between the variance of
the reparameterization estimator and the variance of the REINFORCE estimator. Figure 3 shows the
learned surrogate on a toy problem.
Algorithm 1 LAX: Optimizing parameters and a gradient control variate simultaneously.
Require: f (∙), logp(b∣θ), reparameterized sampler b = T(θ, e), neural network cφ(∙),
step sizes α1, α2
while not converged do
e 〜p(e)	. Sample noise
b J T(e, θ)	. Compute input
gθ J [f (b) 一 cφ(b)] Vθ logp(b∣θ) + Vθcφ(b)	. Estimate gradient of objective
gφ J ∂^2/∂φ	. Estimate gradient of variance of gradient
θ J θ 一 ɑι^θ	. Update parameters
φ J φ 一 α2^φ	. Update control variate
end while
return θ
3.2	Discrete random variables and conditional reparameterization
We can adapt the LAX estimator to the case where b is a discrete random variable by introducing a
“relaxed” continuous variable z. We require a continuous, reparameterizable distribution p(z∣θ) and a
deterministic mapping H(z) such that H(z) = b 〜p(b∣θ) when Z 〜p(z∣θ). In our implementation,
we use the Gumbel-softmax trick, the details of which can be found in appendix B.
The discrete version of the LAX estimator is given by:
∂	∂∂
gDLAX =	f (b)	logp(b∣θ)	-	Cφ(Z)	logp(z∣Θ)	+	Cφ(Z),	b =	H(z),z 〜p(z∣Θ).⑺
∂θ	∂θ	∂θ
This estimator is simple to implement and general. However, if we were able to replace the
∂∂θ logp(z∣Θ) in the control variate with 另 logp(b∣θ) we should be able to achieve a more cor-
related control variate, and therefore a lower variance estimator. This is the motivation behind our
next estimator, which we call RELAX.
To construct a more powerful gradient estimator, we incorporate a further refinement due to Tucker
et al. (2017). Specifically, we evaluate our control variate both at a relaxed input Z 〜p(z∣Θ), and also
at a relaxed input conditioned on the discrete variable b, denoted Z 〜p(Z∣b, θ). Doing so gives us:
∂	∂∂
5RELAX = [f(b) — cφ(Z)]而 logp(blθ) + 而cΦ(Z) — 而。。(Z)
∂θ	∂θ	∂θ
b = H(z), z ~ p(z∣θ), Z ~ p(z∣b, θ)
(8)
This estimator is unbiased for any cφ. A proof and a detailed algorithm can be found in appendix A.
We note that the distribution p(z|b, θ) must also be reparameterizable. We demonstrate how to perform
this conditional reparameterization for Bernoulli and categorical random variables in appendix B.
3.3	Choosing the control variate architecture
The variance-reduction objective introduced above allows us to use any differentiable, parametric
function as our control variate cφ . How should we choose the architecture of cφ ? Ideally, we will
take advantage of any known structure in f .
In the discrete setting, if f is known and happens to be differentiable, we can use the concrete
relaxation (Jang et al., 2016; Maddison et al., 2016) and let cφ(Z) = f(σλ(Z)). In this special case,
our estimator is exactly the REBAR estimator. We are also free to add a learned component to the
concrete relaxation and let cφ(Z) = f(σλ(Z)) + rρ(Z) where rρ is a neural network with parameters ρ
making φ = {ρ, λ}. We took this approach in our experiments training discrete variational auto-
encoders. If f is unknown, we can simply let cφ be a generic function approximator such as a neural
network. We took this simpler approach in our reinforcement learning experiments.
4
Published as a conference paper at ICLR 2018
T
0a2C = X
t=1
∂ log ∏(at ∣st,θ)
∂θ
3.4 Reinforcement learning
We now describe how we apply the LAX estimator in the reinforcement learning (RL) setting. By
reinforcement learning, we refer to the problem of optimizing the parameters θ of a policy distribution
∏(a∣s, θ) to maximize the sum of rewards. In this setting, the random variable being integrated over
is τ, which denotes a series of T actions and states [(s1, a1), (s2, a2), ..., (sT, aT )]. The function
whose expectation is being optimized, R, maps τ to the sum of rewards R(τ) = PtT=1 rt (st, at).
Again, We want to estimate the gradient of an expectation of a black-box function:另Ep(T∣θ) [R(τ)].
The de facto standard approach is the advantage actor-critic estimator (A2C) (Sutton et al., 2000):
T
>,r - cφ(St) ,	at 〜∏(at∣st,θ)	(9)
t0=t
Wherecφ(st) is an estimate of the state-value function, cφ(s) ≈ V π(s) = Eτ [R|s1 = s]. This
estimator is unbiased when cφ does not depend on at. The main limitations of A2C are that cφ does
not depend on at, and that it’s not obvious how to optimizecφ. Using the LAX estimator addresses
both of these problems.
First, we assume π(at∣st, θ) is reparameterizable, meaning that we can write at = α(et, st, θ), where
t does not depend on θ. We again introduce a differentiable surrogate cφ(a, s). Crucially, this
surrogate is a function of the action as well as the state.
The extension of LAX to Markov decision processes is:
gRAX = XXX dlogπ∂θtlst,θ) "XxXrt0 - Cφ(at,st] + ∂∂θcφ(at,st),	(10)
t=1	t0=t
at = a(et,st, θ)	et 〜p(ej∙
This estimator is unbiased if the true dynamics of the system are Markovian w.r.t. the state st .
When T = 1, we recover the special case gR% = ^lax. Comparing gRALX to the standard advantage
actor-critic estimator in (9), the main difference is that our baselinecφ(at, st) is action-dependent
while still remaining unbiased.
To optimize the parameters φ of our control variatecφ(at, st), we can again use the single-sample
estimator of the gradient of our estimator’s variance given in (6). This approach avoids unstable
training dynamics, and doesn’t require storage and replay of previous rollouts.
Details of this derivation, as well as the discrete and conditionally reparameterized version of this
estimator can be found in appendix C.
4 Scope and Limitations
The work most related to ours is the recently-developed REBAR method (Tucker et al., 2017),
which greatly inspired our work. The REBAR estimator is a special case of the RELAX estimator,
when the surrogate is set to cφ(z) = η ∙ f (Softmaxλ(z)). The only free parameters of the REBAR
estimator are the scaling factor η, and the temperature λ, which gives limited scope to optimize the
surrogate. REBAR can only be applied when f is known and differentiable. Furthermore, it depends
on essentially undefined behavior of the function being optimized, since it evaluates the discrete loss
function at continuous inputs.
Because LAX and RELAX can construct a surrogate from scratch, they can be used for optimizing
black-box functions, as in reinforcement learning settings where the reward is an unknown function
of the environment. LAX and RELAX only require that we can query the function being optimized,
and can sample from and differentiate p(b∣θ).
Direct dependence on parameters Above, we assumed that the function f being optimized does
not depend directly on θ, which is usually the case in black-box optimization settings. However, a
dependence on θ can occur when training probabilistic models, or when we add a regularizer. In both
5
Published as a conference paper at ICLR 2018
these settings, if the dependence on θ is known and differentiable, we can use the fact that
∂	∂∂
∂θEp(b∣θ)[f (b, θ)] = Ep(b∣θ) ∂θf (b, θ) + f (b, θ) ∂θ logp(blθ)	(ID
and simply add 另f (b, θ) to any of the gradient estimators above to recover an unbiased estimator.
5 Related work
Miller et al. (2017) reduce the variance of reparameterization gradients in an orthogonal way to ours
by approximating the gradient-generating procedure with a simple model and using that model as
a control variate. NVIL (Mnih & Gregor, 2014) and VIMCO (Mnih & Rezende, 2016) provide
reduced variance gradient estimation in the special case of discrete latent variable models and discrete
latent variable models with Monte Carlo objectives. Salimans et al. (2017) estimate gradients using a
form of finite differences, evaluating hundreds of different parameter values in parallel to construct a
gradient estimate. In contrast, our method is a single-sample estimator.
Staines & Barber (2012) address the general problem of developing gradient estimators for deter-
ministic black-box functions or discrete optimization. They introduce a sampling distribution, and
optimize an objective similar to ours. Wierstra et al. (2014) also introduce a sampling distribution
to build a gradient estimator, and consider optimizing the sampling distribution. In the context of
general Monte Carlo integration, Oates et al. (2017) introduce a non-parametric control variate that
also leverages gradient information to reduce the variance of an estimator.
In parallel to our work, there has been a string of recent developments on action-dependent baselines
for policy-gradient methods in reinforcement learning. Such works include Gu et al. (2016) and
Gu et al. (2017) which train an action-dependent baseline which incorporates off-policy data. Liu
et al. (2017) independently develop a method similar to LAX applied to continuous control. Wu et al.
(2018) exploit per-dimension independence of the action distribution in continuous control tasks to
produce an action-dependent unbiased baseline.
6 Applications
REINFORCE
We demonstrate the effectiveness of our esti-
mator on a number of challenging optimization
problems. Following Tucker et al. (2017) We
begin with a simple toy example to illuminate
the potential of our method and then continue to
the more relevant problems of optimizing binary
VAE,s and reinforcement learning.
6.1 Toy experiment
As a simple example, we follow Tucker et al.
(2017) in minimizing Ep(b∣θ) [(b - t)2] as a
function of the parameter θ where p(b∣θ)=
BernOUlli(b∣θ). Tucker et al. (2017) set the
target t = .45. We focus on the more chal-
lenging case where t = .499. Figures 1a and
1b show the relative performance and gradient
log-variance of REINFORCE, REBAR, and RE-
LAX.
Figure 3 plots the learned surrogate cφ for a
fixed value of θ. We can see that cφ is near f for
all z, keeping the variance of the REINFORCE
part of the estimator small. Moreover the deriva-
0.251 η	------------------
0.250 -	- 3H(z(u)))
0.249 J ∣	∣	∣	~~l-------1-------1
0.20 ]——cφ(z(u))
0.15 J ∣-----"；--,_______________________I
I	I	I	I	I	I
0.0	0.2	0.4	0.6	0.8	1.0
U
Figure 3: The optimal relaxation for a toy loss
function, using different gradient estimators. Be-
cause REBAR uses the concrete relaxation of f,
which happens to be implemented as a quadratic
function, the optimal relaxation is constrained to
be a warped quadratic. In contrast, RELAX can
choose a free-form relaxation.
tive of cφ is positive for all z meaning that the reparameterization part of the estimator will produce
gradients pointing in the correct direction to optimize the expectation. Conversely, the concrete
6
Published as a conference paper at ICLR 2018
MNIST
Figure 4: Training curves for the VAE Experiments with the one-layer linear model. The horizontal
dashed line indicates the lowest validation error obtained by REBAR.
Omniglot
relaxation of REBAR is close to f only near 0 and 1 and its gradient points in the correct direction
only for values of z > log( 1-t). These factors together result in the RELAX estimator achieving the
best performance.
6.2 Discrete variational autoencoder
Next, we evaluate the RELAX estimator on the task of training a variational autoencoder (Kingma &
Welling, 2014; Rezende et al., 2014) with Bernoulli latent variables. We reproduced the variational
autoencoder experiments from Tucker et al. (2017), training models with one or two layers of 200
Bernoulli random variables with linear or nonlinear mappings between them, on both the MNIST and
Omniglot (Lake et al., 2015) datasets. Details of these models and our experimental procedure can be
found in Appendix E.1.
To take advantage of the available structure in the loss function, we choose the form of our control
variate to be cψ(z) = f (σλ(z)) + rρ(z) where ^p is a neural network with parameters P and
f(σλ(z)) is the discrete loss function, the evidence lower-bound (ELBO), evaluated at continuously
relaxed inputs as in REBAR. In all experiments, the learned control variate improved the training
performance, over the state-of-the-art baseline of REBAR. In both linear models, we achieved
improved validation performance as well increased convergence speed. We believe the decrease
in validation performance for the nonlinear models was due to overfitting caused by improved
optimization of an under-regularized model. We leave exploring this phenomenon to further work.
Dataset	Model	Concrete	NVIL	MuProp	REBAR	RELAX
	Nonlinear	-102.2	-101.5	-101.1	-81.01	-78.13
MNIST	linear one-layer	-111.3	-112.5	-111.7	-111.6	-111.20
	linear two-layer	-99.62	-99.6	-99.07	-98.22	-98.00
	Nonlinear	-110.4	-109.58	-108.72	-56.76	-56.12
Omniglot	linear one-layer	-117.23	-117.44	-117.09	-116.63	-116.57
	linear two-layer	-109.95	-109.98	-109.55	-108.71	-108.54
Table 1: Highest training ELBO for discrete variational autoencoders.
To obtain training curves we created our own implementation of REBAR, which gave identical or
slightly improved performance compared to the implementation of Tucker et al. (2017).
While we obtained a modest improvement in training and validation scores (tables 1 and 3), the
most notable improvement provided by RELAX is in its rate of convergence. Training curves for all
models can be seen in Figure 4 and in Appendix D. In Table 4 we compare the number of training
epochs that are required to match the best validation score of REBAR. In both linear models, RELAX
provides an increase in rate of convergence.
7
Published as a conference paper at ICLR 2018
Cart-pole	Lunar lander Inverted pendulum
-10
ecnairaV-go
-20
1000	2000
Episodes
Figure 5: Top row: Reward curves. Bottom row: Log-variance of policy gradients. In each curve, the
center line indicates the mean reward over 5 random seeds. The opaque bars in the top row indicate
the 25th and 75th percentiles. The opaque bars in the bottom row indicate 1 standard deviation. Since
the gradient estimator is defined at the end of each episode, we display log-variance per episode.
After every 10th training episode 100 episodes were run and the sample log-variance is reported
averaged over all policy parameters.
Model I Cart-pole Lunar lander Inverted pendulum
A2C	1152 ± 90	162374 ± 17241	6243 ± 164
LAX/RELAX 472 ± 114	68712 ± 20668	2067 ± 412
Table 2: Mean episodes to solve tasks. Definitions of solving each task can be found in Appendix E.
6.3 Reinforcement learning
We apply our gradient estimator to a few simple reinforcement learning environments with discrete
and continuous actions. We use the RELAX and LAX estimators for discrete and continuous actions,
respectively. We compare with the advantage actor-critic algorithm (A2C) (Sutton et al., 2000) as a
baseline.
As our control variate does not have the same interpretation as the value function of A2C, it was not
directly clear how to add reward bootstrapping and other variance reduction techniques common
in RL into our model. For instance, to do reward bootstrapping, we would need to use the state-
value function. In the discrete experiments, due to the simplicity of the tasks, we chose not to use
reward bootstrapping, and therefore omitted the use of state-value function. However, with the more
complicated continuous tasks, we chose to use the value function to enable bootstrapping. In this
case, the control variate takes the form: cφ(a, S) = V(S) + c(a, s), where V(S) is trained as it would
be in A2C. Full details of our experiments can be found in Appendix E.
In the discrete action setting, we test our approach on the Cart Pole and Lunar Lander environments
as provided by the OpenAI gym (Brockman et al., 2016). In the continuous action setting, we test
on the MuJoCo-simulated (Todorov et al., 2012) environment Inverted Pendulum also found in the
OpenAI gym. In all tested environments we observe improved performance and sample efficiency
using our method. The results of our experiments can be seen in Figure 5, and Table 2.
We found that our estimator produced policy gradients with drastically reduced variance (see Figure 5)
allowing for larger learning rates to be used while maintaining stable training. In both discrete
environments our estimator achieved greater than a 2-times speedup in convergence over the baseline.
8
Published as a conference paper at ICLR 2018
7 Conclusions and future work
In this work we synthesized and generalized several standard approaches for constructing gradi-
ent estimators. We proposed a generic gradient estimator that can be applied to expectations of
known or black-box functions of discrete or continuous random variables, and adds little computa-
tional overhead. We also derived a simple extension to reinforcement learning in both discrete and
continuous-action domains.
Future applications of this method could include training models with hard attention or memory
indexing (Zaremba & Sutskever, 2015). One could also apply our estimators to continuous latent-
variable models whose likelihood is non-differentiable, such as a 3D rendering engine. Extensions to
the reparameterization gradient estimator (Ruiz et al., 2016b; Naesseth et al., 2017) could also be
applied to increase the scope of distributions that can be modeled.
In the reinforcement learning setting, our method could be combined with other variance-reduction
techniques such as generalized advantage estimation (Kimura et al., 2000; Schulman et al., 2015b),
or other optimization methods, such as KFAC (Wu et al., 2017). One could also train our control
variate off-policy, as in Q-prop (Gu et al., 2016).
Acknowledgements
We thank Dougal Maclaurin, Tian Qi Chen, Elliot Creager, and Bowen Xu for helpful discussions.
We also thank Christopher Prohm for pointing out an error in one of our derivations. We would also
like to thank George Tucker for pointing out a bug in our initially released reinforcement learning
code.
References
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym, 2016.
Thomas Unterthiner Djork-Arne CleVert and SePP Hochreiter. Fast and accurate deep network
learning by exponential linear units (elus). International Conference on Learning Representations,
2016.
Shixiang Gu, Timothy LillicraP, Zoubin Ghahramani, Richard E Turner, and Sergey LeVine. Q-ProP:
SamPle-efficient Policy gradient with an off-Policy critic. arXiv preprint arXiv:1611.02247, 2016.
Shixiang Gu, Tim Lillicrap, Richard E Turner, Zoubin Ghahramani, Bernhard Scholkopf, and Sergey
LeVine. InterPolated Policy gradient: Merging on-Policy and off-Policy gradient estimation for deeP
reinforcement learning. In Advances in Neural Information Processing Systems, pp. 3849-3858,
2017.
Eric Jang, Shixiang Gu, and Ben Poole. Categorical reparameterization with gumbel-softmax. arXiv
preprint arXiv:1611.01144, 2016.
Hajime Kimura, Shigenobu Kobayashi, et al. An analysis of actor-critic algorithms using eligibility
traces: reinforcement learning with imperfect Value functions. Journal of Japanese Society for
Artificial Intelligence, 15(2):267-275, 2000.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International
Conference on Learning Representations, 2015.
Diederik P. Kingma and Max Welling. Auto-encoding Variational Bayes. International Conference
on Learning Representations, 2014.
Brenden M Lake, Ruslan SalakhutdinoV, and Joshua B Tenenbaum. Human-leVel concept learning
through probabilistic program induction. Science, 350(6266):1332-1338, 2015.
Hao Liu, Yihao Feng, Yi Mao, Dengyong Zhou, Jian Peng, and Qiang Liu. Sample-efficient policy
optimization with stein control Variate. arXiv preprint arXiv:1710.11198, 2017.
9
Published as a conference paper at ICLR 2018
Chris J Maddison, Andriy Mnih, and Yee Whye Teh. The concrete distribution: A continuous
relaxation of discrete random variables. arXiv preprint arXiv:1611.00712, 2016.
Andrew C Miller, Nicholas J Foti, Alexander D’Amour, and Ryan P Adams. Reducing reparameteri-
zation gradient variance. arXiv preprint arXiv:1705.07880, 2017.
Andriy Mnih and Karol Gregor. Neural variational inference and learning in belief networks. In
Proceedings ofthe 31stInternational Conference on Machine Learning (ICML-14) ,pp.1791-1799,
2014.
Andriy Mnih and Danilo Rezende. Variational inference for monte carlo objectives. In International
Conference on Machine Learning, pp. 2188-2196, 2016.
Christian Naesseth, Francisco Ruiz, Scott Linderman, and David Blei. Reparameterization gradients
through acceptance-rejection sampling algorithms. In Artificial Intelligence and Statistics, pp.
489-498, 2017.
Chris J Oates, Mark Girolami, and Nicolas Chopin. Control functionals for monte carlo integration.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79(3):695-718, 2017.
Louis B Rall. Automatic differentiation: Techniques and applications. 1981.
Danilo J Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic backpropagation and approximate
inference in deep generative models. In Proceedings of the 31st International Conference on
Machine Learning, pp. 1278-1286, 2014.
Herbert Robbins and Sutton Monro. A stochastic approximation method. The annals of mathematical
statistics, pp. 400-407, 1951.
Francisco J.R. Ruiz, Michalis K Titsias, and David M Blei. Overdispersed black-box variational
inference. In Uuncertainty in Artificial Intelligence, 2016a.
Francisco R Ruiz, Michalis Titsias RC AUEB, and David Blei. The generalized reparameterization
gradient. In Advances in Neural Information Processing Systems, pp. 460-468, 2016b.
David E Rumelhart and Geoffrey E Hinton. Learning representations by back-propagating errors.
Nature, 323:9, 1986.
Tim Salimans, Jonathan Ho, Xi Chen, and Ilya Sutskever. Evolution strategies as a scalable alternative
to reinforcement learning. arXiv preprint arXiv:1703.03864, 2017.
John Schulman, Nicolas Heess, Theophane Weber, and Pieter Abbeel. Gradient estimation using
stochastic computation graphs. In Advances in Neural Information Processing Systems, pp. 3528-
3536, 2015a.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional
continuous control using generalized advantage estimation. arXiv preprint arXiv:1506.02438,
2015b.
Bert Speelpenning. Compiling Fast Partial Derivatives of Functions Given by Algorithms. PhD
thesis, University of Illinois at Urbana-Champaign, 1980.
Joe Staines and David Barber. Variational optimization. arXiv preprint arXiv:1212.4507, 2012.
Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient meth-
ods for reinforcement learning with function approximation. In Advances in neural information
processing systems, pp. 1057-1063, 2000.
T. Tieleman and G. Hinton. Lecture 6.5—RmsProp: Divide the gradient by a running average of its
recent magnitude. COURSERA: Neural Networks for Machine Learning, 2012.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In Intelligent Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026-
5033. IEEE, 2012.
10
Published as a conference paper at ICLR 2018
George Tucker, Andriy Mnih, Chris J Maddison, and Jascha Sohl-Dickstein. Rebar: Low-variance,
unbiased gradient estimates for discrete latent variable models. arXiv preprint arXiv:1703.07370,
2017.
George Tucker, Surya Bhupatiraju, Shixiang Gu, Richard E Turner, Zoubin Ghahramani, and Sergey
Levine. The mirage of action-dependent baselines in reinforcement learning. 2018.
Daan Wierstra, Tom SchaUL Tobias Glasmachers, Yi Sun, Jan Peters, and Jurgen Schmidhuber.
Natural evolution strategies. Journal ofMachine Learning Research,15(1):949-980, 2014.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. Machine learning, 8(3-4):229-256, 1992.
Cathy Wu, Aravind Rajeswaran, Yan Duan, Vikash Kumar, Alexandre M Bayen, Sham Kakade,
Igor Mordatch, and Pieter Abbeel. Variance reduction for policy gradient with action-dependent
factorized baselines. International Conference on Learning Representations, 2018.
Yuhuai Wu, Elman Mansimov, Shun Liao, Roger Grosse, and Jimmy Ba. Scalable trust-region
method for deep reinforcement learning using kronecker-factored approximation. In Advances in
neural information processing systems, 2017.
Wojciech Zaremba and Ilya Sutskever. Reinforcement learning neural turing machines-revised. arXiv
preprint arXiv:1505.00521, 2015.
11
Published as a conference paper at ICLR 2018
Appendices
A The RELAX Algorithm
Proof. We show that 'relax is an unbiased estimator of 扁Ep(b∣θ) [f (b)]. The estimator is
∂
Ep(b∣θ) f S)- Ep(Rb,θ)[cφ(Z)]] ∂θ logp(blθ) -
∂
∂∂
∂θEp(Rb,θ)kφ(Z)] + ∂θEp(z∣θ)[cΦ(Z)].
∂θ
Expanding the expectation for clarity of exposition, we account for each term in the estimator
separately:
Ep(b∣θ)	f(b)而 Iog ρ(blθ) ∂θ	(12)
一 Ep(b∣θ) Ep(Rb,θ)[cφ(z)		∂ 法 log p(b∣θ)	(13) ∂θ
∂ 一 Ep(b∣θ) ∂θEp(Rb,θ)[cΦ(Z)]	(14)		
∂ + ∂θEp(z∣θ)[cΦ(Z)] ∙		(15)
Term (12) is an unbiased score-function estimator of 条Ep(b∣θ) [f (b)]. It remains to show that the
other three terms are zero in expectation. Following Tucker et al. (2017) (see the appendices of that
paper for a derivation), we rewrite term (14) as follows:
∂
-Ep(b∣θ)	∂θEp(Rb,θ) I。。(Z)I
∂
Ep(b∣θ) Ep(Rb,θ) [cφ(Z)] ∂θ logp(blθ)
∂
-Ep(z∣θ) cφ(Z) ∂θ logP(Z).
(16)
Note that the first term on the right-hand side of equation (16) is equal to term (13) with opposite
sign. The second term on the right-hand side of equation (16) is the score-function estimator of term
(15), opposite in sign. The sum of these terms is zero in expectation.
□
Algorithm 2 RELAX: Low-variance control variate optimization for black-box gradient estimation.
Require: f (∙), logρ(b∣θ), reparameterized samplers b = H(z), Z = S(e, θ) and Z = S(e, θ∣b),
neural network c。(∙), step sizes α1,α2
while not converged do
ei, e 〜p(e)	. Sample noise
Zi J S(ei, θ)	. Compute unconditional relaxed input
bi J H (Zi)	. Compute input
Zi J S(e, θ∣bi)	. Compute conditional relaxed input
gθ J [f (bi) 一 Cφ(Zi)] Vθ logp + VθCφ(Zi) - VθCφ(Zi)	. Estimate gradient
gφ J ∂gθ/∂φ	. Estimate gradient of variance of gradient
θ J θ 一 ɑι^θ	. Update parameters
φ J φ 一 ɑθgφ	. Update control variate
end while
return θ
B Conditional Re-sampling for Discrete Random Variables
When applying the RELAX estimator to a function of discrete random variables b 〜p(b∣θ), we
require that there exists a distribution p(z |θ) and a deterministic mapping H(z) such thatif Z 〜p(z |θ)
12
Published as a conference paper at ICLR 2018
then H(Z) = b 〜p(b∣θ). Treating both b and Z as random, this procedure defines a probabilistic
model p(b, z∣θ) = p(b∣z)p(z∣θ). The RELAX estimator requires reparameterized samples from
p(z∣θ) andp(z∣b, θ). We describe how to sample from these distributions in the common cases of
p(b∣θ) = Bernoulli(θ) andp(b∣θ) = CategOriCal(θ).
Bernoulli When p(b∣θ) is Bernoulli distribution We let H(Z) = I(Z > 0) and We sample from
p(z∣θ) with
θu
Z = log 口+logι-τ
U〜 uniform[0, 1].
We can sample from p(Z|b, θ) with
V v ∙ (1 — θ)	b = 0
[v ∙ θ + (1 — θ) b = 1
Z = log
+ log
v0
1 — v0
V 〜 uniform[0,1].
θ
1 — θ
Categorical When p(b∣θ) is a Categorical distribution where θi = p(b = i∣θ), we let H(Z)
argmax(Z)and we sample from p(z∣Θ) with
Z = logθ — log(— logu),	u 〜 uniform[0,1]k
where k is the number of possible outcomes.
To sample from p(Z∣b, θ), we note that the distribution of the largest Zb is independent of θ, and can
be sampled as Zb = — log(— log Vb) where Vb 〜uniform[0,1]. Then, the remaining v%=b can be
sampled as before but with their underlying noise truncated so Zit=b < Zb. As shown in the appendix
of Tucker et al. (2017), we can then sample from p(Z|b, θ) with:
— log(— log vi)	i = b
Zi =I —log (—logivi — logVb)	i = b
(17)
where Vi 〜uniform[0,1].
C Derivations of estimators used in Reinforcement learning
We give the derivation of the LAX estimator used for continuous RL tasks.
Theorem C.1. The LAX estimator,
TT
gRAX = X dlogπ∂θtMθ) Xrt0 - Cφ(at,st) + ∂∂θcφ(at,st),	(18)
t=1	t0=t
at = αt(et, st,θ),	6t 〜p(j),
is unbiased.
Proof. Note that by using the score-function estimator, for all t, we have
Ep(τ)
∂ logπ(αt∣st,θ)
∂θ
cφ(at, St)] = Ep(ai：t-i,si：t)[加 Eπ(at∣st,θ)hcφ(at, st)ii.
13
Published as a conference paper at ICLR 2018
Then, by adding and subtracting the same term, we have
∂θ Ep(T )[f(τ )]= Ep(T) f(τ) ∙ ∂θ log p(τ; θ)l - X Ep(T )hd log 支小阳 Cφ(at，s/十
t
X Ep(a1：t-1,sLt) h∂θ Eπ(at∣st,θ) hcφ(at, st)ii
t
IX ∂ log π(at∣st,θ)∕χ	M
Ep(T) 工---------∂θ-----I 2^rt0 - cΦ(at,st) )
+ X Ep(ai：t-I,si：t) [Ep(et)[而。。(如&，st, θ), St)]]
∣∖∞ d log π(at∣st,θ) (y∞	z Δ , d / /	6	、
Ep(T) ʌ,--------∂θ----- r	rt0 - cφ(at，st) I + ∂θcφ(at(et, St，θ), st)
□
In the discrete control setting, our policy parameterizes a soft-max distribution which we use to
sample actions. We define Zt 〜p(zt∣st), which is equal to σ(logπ - log(- log(u))) where U 〜
uniform[0,1], at = argmax(zt), σ is the soft-max function. We also define Zt 〜p(zt∣at, st) and
uses the same reparametrization trick for sampling Zt as explicated in Appendix B.
Theorem C.2. The RELAX estimator,
OrElax = X '"义 KndTs阳(XIrtJ - cΦ(zt, st) - ∂θcφ(zt, st) + ∂θcφ(zt, st),	(19)
Zt ~ p(zt∣at, st),	Zt ~ p(zt∣st),
is unbiased.
Proof. Note that by using the score-function estimator, for all t, we have
Ep(a1:t,s1:t)
h d log ",I) Ep(zt∣at,st)[cφ(zt,st)]]
Ep(ai：t-i,si：t) [∂θE∏(at∣st,θ) [Ep(zt∣at,st) [cφ(zt, st)]]]
Ep(a1:t-1,s1:t)
[∂θEp(ZtIst) [cφ(zt, st)]]
Then, by adding and subtracting the same term, we have
∂∂
∂θEp(T)[f (τ)] = Ep(T) f(τ) ∙ ∂θ logP(T θ)
-X Ep(…:t) h d log 蓝 t∣st,θ) Ep(zt∣at,st)[cφ(zt ,st)]i
t
+ X Ep(ai:t-i,si:t) h∂θEp(ZtIst) [cφ(zt, st)]i
3dlogπ(at∣st, θ) (3	雨 r l ×Λ"∣
Ep(T) ʌ, ∂θ	I	rt0 - Ep(Zt ∣at,st) [cφ(zt, st)] I
+ SXj Ep(ai：t-i,si：t) h∂θEp(Zt1st) [cφ(zt, st)]i
t
∞
Ep(T) X
t=1
∂ log π(at∣st,θ)
∂θ
X∞
rt0 - Ep(ZtIat,st)[cφ(zt,st)
∂∂
-∂θ Ep(Zt ∣at,st)[cφ(zt, st)] + ∂θEp(Zt1st) [Cφ(zt, st)]]
Sincep(Zt∣st) is reparametrizable, we obtain the estimator in Eq.(19).
□
14
Published as a conference paper at ICLR 2018
Figure 6: Training curves for the VAE Experiments with the two-layer linear model. The horizontal
dashed line indicates the lowest validation error obtained by REBAR.
D Further results on discrete variational autoencoders
Dataset	Model	REBAR	RELAX
	one-layer linear	-114.32	-113.62
MNIST	two-layer linear	-101.20	-100.85
	Nonlinear	-111.12	119.19
	one-layer linear	-122.44	-122.11
Omniglot	two-layer linear	-115.83	-115.42
	Nonlinear	-127.51	128.20
Table 3: Highest obtained validation ELBO.
Dataset	Model	REBAR	RELAX
	one-layer	857	531
MNIST	two-layer	900	620
	Nonlinear	331	-
	one-layer	2086	566
Omniglot	two-layer	1027	673
	Nonlinear	368	-
Table 4: Epochs needed to achieve REBAR’s best validation score. “-” indicates that the nonlinear
RELAX models achieved lower validation scores than REBAR.
E Experimental Details
E.1 Discrete VAE
We run all models for 2, 000, 000 iterations with a batch size of 24. For the REBAR models, we
tested learning rates in {.005, .001, .0005, .0001, .00005}.
RELAX adds more hyperparameters. These are the depth of the neural network component of our
control variate rρ , the weight decay placed on the network, and the scaling on the learning rate for
the control variate. We tested neural network models with l layers of 200 units using the ReLU
nonlinearity with l ∈ {2, 4}. We trained the control variate with weight decay in {.001, .0001}. We
trained the control variate with learning rate scaling in {1, 10}.
To limit the size of hyperparameter search for the RELAX models, we only test the best performing
learning rate for the REBAR baseline and the next largest learning rate in our search set. In many
cases, we found that RELAX allowed our model to converge at learning rates which made the REBAR
15
Published as a conference paper at ICLR 2018
Figure 7: Training curves for the VAE Experiments with the one-layer nonlinear model. The
horizontal dashed line indicates the lowest validation error obtained by REBAR.
estimators diverge. We believe further improvement could be achieved by tuning this parameter. It
should be noted that in our experiments, we found the RELAX method to be fairly insensitive to all
hyperparameters other than learning rate. In general, we found the larger (4 layer) control variate
architecture with weight decay of .001 and learning rate scaling of 1 to work best, but only slightly
outperformed other configurations.
All presented results are from the models which achieve the highest ELBO on the validation data.
E.1.1 One-layer linear model
In the one-layer linear models we optimize the evidence lower bound (ELBO):
log p(x) ≥ L(θ) = Eq(b|x)[log p(x|b) + log p(b) - log q(b|x)]
where q(bι∣x) = σ(x ∙ Wq + βq) andp(x∣bι) = σ(bι ∙ Wp + βp) with weight matrices Wq, Wp and
bias vectors βq, βp. The parameters of the prior p(b) are also learned.
E.1.2 Two layer linear model
In the two layer linear models we optimize the ELBO
L(θ) = Eq(b2|b1)q(b1|x)[log p(x|b1) + logp(b1 |b2) + logp(b2) - log q(b1|x) - log q(b2|b1)]
where q(bι∣x) = σ(x ∙ Wqlγ + βqj, q(b2∣b1) = σ(bι ∙ Wq2 + βq2), p(x∣bι) = σ(bι ∙ Wpγ + βpι ),and
p(b1∣b2) = σ(b ∙Wp2 +βp2) with weight matrices Wqll, Wql2, Wpi, Wp2 and biases βq> βq2, βρι, βp?.
As in the one-layer model, the prior p(b2 ) is also learned.
E.1.3 Nonlinear model
In the one-layer nonlinear model, the mappings between random variables consist of 2 deterministic
layers with 200 units using the hyperbolic-tangent nonlinearity followed by a linear layer with 200
units.
We run an identical hyperpameter search in all models.
E.2 Discrete RL
In both the baseline A2C and RELAX models, the policy and control variate (value function in the
baseline model) were two-layer neural networks with 10 units per layer. The ReLU non linearity was
used on all layers except for the output layer which was linear.
For these tasks we estimate the policy gradient with a single Monte Carlo sample. We run one
episode of the environment to completion, compute the discounted rewards, and run one iteration of
gradient descent. We believe using larger batches will improve performance but would less clearly
demonstrate the potential of our method.
16
Published as a conference paper at ICLR 2018
Both models were trained with the RMSProp (Tieleman & Hinton, 2012) optimizer and a reward
discount factor of .99 was used. Entropy regularization with a weight of .01 was used to encourage
exploration.
Both models have 2 hyperparameters to tune; the global learning rate and the scaling factor on
the learning rate for the control variate (or value function). We complete a grid search for both
parameters in {0.01, 0.003, 0.001} and present the model which “solves” the task in the fewest
number of episodes averaged over 5 random seeds. “Solving” the tasks was defined by the creators
of the OpenAI gym (Brockman et al., 2016). The Cart Pole task is considered solved if the agent
receives an average reward greater than 195 over 100 consecutive episodes. The Lunar Lander task
is considered solved if the agent receives an average reward greater than 200 over 100 consecutive
episodes.
The Cart Pole experiments were run for 250,000 frames. The Lunar Lander experiments were run for
5,000,000 frames.
The results presented for the CartPole and LunarLander environments were obtained using a slightly
biased sampler forp(z|b, θ).
E.3 Continuous RL
The three models- policy, value, and control variate, are two-layer neural networks with 64 hidden
units per layer. The value and control variate networks are identical, with the ELU (Djork-Arne CleVert
& Hochreiter, 2016) nonlinearity in each hidden layer. The policy network has tanh nonlinearity.
The policy network, which parameterizes the Gaussian policy comprises of a network (with the
architecture mentioned above) that outputs the mean, and a separate, trainable log standard deviation
value that is not input dependent. All three networks have a linear output layer. We selected the batch
size to be 2500, meaning for a fixed timestep (2500) we collect multiple rollouts of a task and update
the networks’ parameters with the batch of episodes. Per one policy update, we optimize both the
value and control variate network multiple times. The number of times we train the value network
is fixed to 25, while for the control variate, it was chosen to be a hyperparameter. All models were
trained using ADAM (Kingma & Ba, 2015), with β1 = 0.9, β2 = 0.999, and = 1e - 08.
The baseline A2C case has 2 hyperparameters to tune: the learning rate for the optimizer for the
policy and value network. A grid search was done over the set: {0.03, 0.003, 0.0003}. RELAX
has 4 hyperparameters to tune: 3 learning rates for the optimizer per network, and the number of
training iterations of the control variate per policy gradient update. Due to the large number of
hyperparameters, we restricted the size of the grid search set to {0.003, 0.0003} for the learning rates,
and {1, 5, 25} for the control variate training iteration number. We chose the hyperparameter setting
that yielded the shortest episode-to-completion time averaged over 5 random seeds. As with the
discrete case, we used the definition of completion provided by the OpenAI gym (Brockman et al.,
2016) for each task.
The Inverted Pendulum experiments were run for 1,000,000 frames.
Tucker et al. (2018) pointed out a bug in our initially released code for the continuous RL experiments.
This issue has been fixed in the publicly available code and the results presented in this paper were
generated with the corrected code.
E.3.1 Implementation Considerations
For continuous RL tasks, it is convention to employ a batch of a fixed number of timesteps (here,
2500) in which the number of episodes vary. We follow this convention for the sake of providing a fair
comparison to the baseline. However, this causes a complication when calculating the variance loss for
the control variate because we must compute the variance averaged over completed episodes, which is
difficult to obtain when the number of episodes is not fixed. For this reason, in our implementation we
compute the gradients for the control variate outside of the Tensorflow computation graph. However,
for practical reasons we recommend using a batch of fixed number of episodes when using our
method.
17