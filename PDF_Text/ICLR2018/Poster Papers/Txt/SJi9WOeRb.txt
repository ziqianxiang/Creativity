Published as a conference paper at ICLR 2018
Gradient Estimators for Implicit Models
Yingzhen Li & Richard E. Turner
University of Cambridge
Cambridge, CB2 1PZ, UK
{yl494,ret26}@cam.ac.uk
Ab stract
Implicit models, which allow for the generation of samples but not for point-wise
evaluation of probabilities, are omnipresent in real-world problems tackled by ma-
chine learning and a hot topic of current research. Some examples include data
simulators that are widely used in engineering and scientific research, generative
adversarial networks (GANs) for image synthesis, and hot-off-the-press approxi-
mate inference techniques relying on implicit distributions. The majority of exist-
ing approaches to learning implicit models rely on approximating the intractable
distribution or optimisation objective for gradient-based optimisation, which is
liable to produce inaccurate updates and thus poor models. This paper allevi-
ates the need for such approximations by proposing the Stein gradient estimator,
which directly estimates the score function of the implicitly defined distribution.
The efficacy of the proposed estimator is empirically demonstrated by examples
that include gradient-free MCMC, meta-learning for approximate inference and
entropy regularised GANs that provide improved sample diversity.
1	Introduction
Modelling is fundamental to the success of technological innovations for artificial intelligence. A
powerful model learns a useful representation of the observations for a specified prediction task,
and generalises to unknown instances that follow similar generative mechanics. A well established
area of machine learning research focuses on developing prescribed probabilistic models (Diggle
& Gratton, 1984), where learning is based on evaluating the probability of observations under the
model. Implicit probabilistic models, on the other hand, are defined by a stochastic procedure that
allows for direct generation of samples, but not for the evaluation of model probabilities. These
are omnipresent in scientific and engineering research involving data analysis, for instance ecology,
climate science and geography, where simulators are used to fit real-world observations to produce
forecasting results. Within the machine learning community there is a recent interest in a specific
type of implicit models, generative adversarial networks (GANs) (Goodfellow et al., 2014), which
has been shown to be one of the most successful approaches to image and text generation (Radford
et al., 2016; Yu et al., 2017; Arjovsky et al., 2017; Berthelot et al., 2017). Very recently, implicit dis-
tributions have also been considered as approximate posterior distributions for Bayesian inference,
e.g. see Liu & Feng (2016); Wang & Liu (2016); Li & Liu (2016); Karaletsos (2016); Mescheder
et al. (2017); Huszar (2017); Li et al. (2017); Tran et al. (2017). These examples demonstrate the SU-
perior flexibility of implicit models, which provide highly expressive means of modelling complex
data structures.
Whilst prescribed probabilistic models can be learned by standard (approximate) maximum like-
lihood or Bayesian inference, implicit probabilistic models require substantially more severe ap-
proximations due to the intractability of the model distribution. Many existing approaches first
approximate the model distribution or optimisation objective function and then use those approx-
imations to learn the associated parameters. However, for any finite number of data points there
exists an infinite number of functions, with arbitrarily diverse gradients, that can approximate per-
fectly the objective function at the training datapoints, and optimising such approximations can lead
to unstable training and poor results. Recent research on GANs, where the issue is highly preva-
lent, suggest that restricting the representational power of the discriminator is effective in stabilising
training (e.g. see Arjovsky et al., 2017; Kodali et al., 2017). However, such restrictions often intro-
1
Published as a conference paper at ICLR 2018
----- true loss	¼ true minimum
----approx. loss	* approx. loss minima
(a) approximate loss function
---tru true gradient ¼ true minimum
Figure 1: A comparison between the two approximation schemes. Since in practice the optimiser
only visits finite number of locations in the parameter space, it can lead to over-fitting if the neu-
ral network based functional approximator is not carefully regularised, and therefore the curvature
information of the approximated loss can be very different from that of the original loss (shown in
(a)). On the other hand, the gradient approximation scheme (b) can be more accurate since it only
involves estimating the sensitivity of the loss function to the parameters in a local region.
duce undesirable biases, responsible for problems such as mode collapse in the context of GANs,
and the underestimation of uncertainty in variational inference methods (Turner & Sahani, 2011).
In this paper we explore approximating the derivative of the log density, known as the score func-
tion, as an alternative method for training implicit models. An accurate approximation of the score
function then allows the application of many well-studied algorithms, such as maximum likelihood,
maximum entropy estimation, variational inference and gradient-based MCMC, to implicit models.
Concretely, our contributions include:
•	the Stein gradient estimator, a novel generalisation of the score matching gradient estimator
(Hyvarinen, 2005), that includes both parametric and non-parametric forms;
•	a comparison of the proposed estimator with the score matching and the KDE plug-in
estimators on performing gradient-free MCMC, meta-learning of approximate posterior
samplers for Bayesian neural networks, and entropy based regularisation of GANs.
2	Learning implicit probabilistic models
Given a dataset D containing i.i.d. samples we would like to learn a probabilistic model p(x) for the
underlying data distribution pD(x). In the case of implicit models, p(x) is defined by a generative
process. For example, to generate images, one might define a generative model p(x) that consists of
sampling randomly a latent variable Z 〜po(z) and then defining X = fθ(z). Here f is a function
parametrised by θ, usually a deep neural network or a simulator. We assume f to be differentiable
w.r.t. θ. An extension to this scenario is presented by conditional implicit models, where the addition
of a supervision signal y, such as an image label, allows us to define a conditional distribution p(x|y)
implicitly by the transformation x = fθ (z, y). A related methodology, wild variational inference
(Liu & Feng, 2016; Li & Liu, 2016) assumes a tractable joint density p(x, z), but uses implicit
proposal distributions to approximate an intractable exact posterior p(z|x). Here the approximate
posterior q(z|x) can likewise be represented by a deep neural network, but also by a truncated
Markov chain, such as that given by Langevin dynamics with learnable step-size.
Whilst providing extreme flexibility and expressive power, the intractability of density eval-
uation also brings serious optimisation issues for implicit models. This is because many
learning algorithms, e.g. maximum likelihood estimation (MLE), rely on minimising a dis-
tance/divergence/discrepancy measure D[p||pD], which often requires evaluating the model density
(c.f. Ranganath et al., 2016; Liu & Feng, 2016). Thus good approximations to the optimisation
procedure are the key to learning implicit models that can describe complex data structure. In the
context of GANs, the Jensen-Shannon divergence is approximated by a variational lower-bound
2
Published as a conference paper at ICLR 2018
represented by a discriminator (Barber & Agakov, 2003; Goodfellow et al., 2014). Related work
for wild variational inference (Li & Liu, 2016; Mescheder et al., 2017; Huszar, 2017; Tran et al.,
2017) uses a GAN-based technique to construct a density ratio estimator for q/p0 (Sugiyama et al.,
2009; 2012; Uehara et al., 2016; Mohamed & Lakshminarayanan, 2016) and then approximates the
KL-divergence term in the variational lower-bound:
Lvi(q) = Eq [logp(x∣z)] - KL[qφ(z∣x)∣∣Po(z)].	⑴
In addition, Li & Liu (2016) and Mescheder et al. (2017) exploit the additive structure of the KL-
divergence and suggest discriminating between q and an auxiliary distribution that is close to q,
making the density ratio estimation more accurate. Nevertheless all these algorithms involve a min-
imax optimisation, and the current practice of gradient-based optimisation is notoriously unstable.
The stabilisation of GAN training is itself a recent trend of related research (e.g. see Salimans et al.,
2016; Arjovsky et al., 2017). However, as the gradient-based optimisation only interacts with gradi-
ents, there is no need to use a discriminator if an accurate approximation to the intractable gradients
could be obtained. As an example, consider a variational inference task with the approximate pos-
terior defined as Z 〜qφ(z|x) ⇔ E 〜 ∏(e), Z = fφ(e, x). Notice that the variational lower-bound
can be rewritten as
Lvι(q) = Eq [logp(x, z)] + H[qφ(z∣x)],	(2)
the gradient of the variational parameters φ can be computed by a sum of the path gradient of
the first term (i.e. En [Vf logp(x, f (e, x))TVφf (e, x)]) and the gradient of the entropy term
VφH[q(z∣x)]. Expanding the latter, We have
VφH[qφ(z∣x)] = -VφE∏(e)[lθg qφ(fφ(E, x))]
= -Eπ()[Vφ log qφ(fφ(E, x))]	(3)
=-E∏(e)[Vφ log qφ(z∣x)∣z=fφ(e,χ) + Vf log qφ(fφ(e, x)∣x)Vφfφ(€, x)] ,
=—Eqφ(z∣χ)[Vφlogqφ(z∣x)] - E∏(e)[Vf logqφ(fφ(e, x)∣x)Vφfφ(e, x)],
in which the first term in the last line is zero (Roeder et al., 2017). As we typically assume the
tractability of Vφf, an accurate approximation to Vz log q(Z|x) would remove the requirement of
discriminators, speed-up the learning and obtain potentially a better model. Many gradient approx-
imation techniques exist (Stone, 1985; Fan & Gijbels, 1996; Zhou & Wolfe, 2000; De Brabanter
et al., 2013), and in particular, in the next section we will review kernel-based methods such as
kernel density estimation (Singh, 1977) and score matching (Hyvarinen, 2005) in more detail, and
motivate the main contribution of the paper.
3	Gradient approximation with the S tein gradient estimator
We propose the Stein gradient estimator as a novel generalisation of the score matching gradient es-
timator. Before presenting itwe first set-up the notation. Column vectors and matrices are boldfaced.
The random variable under consideration is x ∈ X with X = Rd×1 if not specifically mentioned. To
avoid misleading notation we use the distribution q(x) to derive the gradient approximations for gen-
eral cases. As Monte Carlo methods are heavily used for implicit models, in the rest of the paper we
mainly consider approximating the gradient g(xk) := Vxk log q(xk) for Xk 〜q(x),k = 1,…，K.
We use xij to denote thejth element of the ith sample xi. We also denote the matrix form of the col-
lected gradients as G := (Vxι log q(x1),…，VxK log q(xK))T ∈ RK×d, and its approximation
G := (g(x1),…，g(xK))T with g(xk) = Vxk log q(xk) for some q(x).
3.1	Stein gradient estimator: inverting Stein’s identity
We start from introducing Stein’s identity that was first developed for Gaussian random variables
(Stein, 1972; 1981) then extended to general cases (Gorham & Mackey, 2015; Liu et al., 2016). Let
h : Rd×1 → Rd0×1 be a differentiable multivariate test function which maps x to a column vector
h(x) = [h1(x), h2(x), ..., hd0 (x)]T. We further assume the boundary condition for h:
q(x)h(x)∣∂χ = 0, or lim q(x)h(x) = 0 if X = Rd.	(4)
x→∞
3
Published as a conference paper at ICLR 2018
This condition holds for almost any test function if q has sufficiently fast-decaying tails (e.g. Gaus-
sian tails). Now we introduce Stein’s identity (Stein, 1981; Gorham & Mackey, 2015; Liu et al.,
2016)
Eq [h(x)Vχ log q(x)T + Vxh(x)] = 0,	(5)
in which the gradient matrix term Vxh(x) = (Vxhι(x), ∙∙∙ , Vχh√∕(X))T ∈ Rd0×d. This identity
can be proved using integration by parts: for the ith row of the matrix h(x)Vx log q(x)T, we have
Eq[hi(x)Vxlogq(x)T]
hi(x)Vxq(x)Tdx
q(x)hi(x)∣∂χ — / q(x)Vxhi(x)Tdx
(6)
-Eq[Vxhi(x)T].
Observing that the gradient term Vx log q(x) of interest appears in Stein’s identity (5), we propose
the Stein gradient estimator by inverting Stein’s identity. As the expectation in (5) is intractable, we
further approximate the above with Monte Carlo (MC):
1K	1K
K £—h(xk )Vxklog q(xk)τ + err = K EVxk h(xk),	xk 〜q(xk),	(7)
k=1	k=1
with err ∈ Rd0 ×d the random error due to MC approximation, which has mean 0 and vanishes
as K → +∞. Now by temporarily denoting H = (h(x1),…，h(xκ)) ∈ Rd0×K, Vxh =
KK PK=I Vxkh(xk) ∈ Rd0×d, equation ⑺ can be rewritten as — KHG + err = Vxh. Thus we
consider a ridge regression method (i.e. adding an `2 regulariser) to estimate G:
GVem = argmin ||Vxh + -HGGIIF + -ɪIlGIIF,	⑻
G ∈RK×d	K	K
with II • IIf the Frobenius norm of a matrix and η ≥ 0. Simple calculation shows that
GVein = —(K + ηi )-1hV, Ki,	(9)
where K := HtH, Kij = K(xi, xj) := h(xi)Th(Xj),〈V, K)：= KHTVZh, hV, Kiij =
PkK=1 Vxk K(xi, xk). One can show that the RBF kernel satisfies Stein’s identity (Liu et al., 2016).
In this case h(x) = K(x, •), d0 = +∞ and by the reproducing kernel property (Berlinet & Thomas-
Agnan, 2011), h(x)Th(x0) = hK(x, •), K(x0, •)iH = K(x, x0).
3.2	Stein gradient estimator minimises the kernelised Stein discrepancy
In this section we derive the Stein gradient estimator again, but from a divergence/discrepancy min-
imisation perspective. Stein’s method also provides a tool for checking if two distributions q(x)
and q(x) are identical. If the test function set H is sufficiently rich, then one can define a Stein
discrepancy measure by
S(q,q) ：= sup Eq [Vx log q(x)τh(x) +(V, h)] ,	(10)
h∈H
see Gorham & Mackey (2015) for an example derivation. When H is defined as a unit ball in an
RKHS induced by a kernel K(x, •), Liu et al. (2016) and Chwialkowski et al. (2016) showed that
the supremum in (10) can be analytically obtained as (with Kxx0 shorthand for K(x, x0)):
S2(q,q) = Ex,xo〜q [(g(x) — g(x))TKxxo(g(x0) — g(x0))],	(11)
which is also named the kernelised Stein discrepancy (KSD). Chwialkowski et al. (2016) showed that
for C0-universal kernels satisfying the boundary condition, KSD is indeed a discrepancy measure:
S2(q,q) = 0 ⇔ q = q. Gorham & Mackey (2017) further characterised the power of KSD on
detecting non-convergence cases. Furthermore, if the kernel is twice differentiable, then using the
same technique as to derive (16) one can compute KSD by
S2(q, q) =Ex,x0 〜q [g(x)τKxxog(x0) + g(x)τVx0Kxxo + VxKxxOg(x0) + Tr(Vx,x0Kxxo)].
(12)
In practice KSD is estimated with samples {xk}3ι 〜q, and simple derivations show that the V-
statistic of KSD can be reformulated as SV(q, q) = K⅛Tr(GTKG + 2GGτ(V, K)) + C. Thus the
l2 error in (8) is equivalent to the V-statistic of KSD if h(x) = K(x, •), and we have the following:
4
Published as a conference paper at ICLR 2018
Theorem 1. G Vem is the solution of the following KSD V-Statistic minimisation problem
G Vtein = argmin SV (q,q) + K2 ||G ||F.	(13)
G∈RK×d	K
One can also minimise the U-statistic of KSD to obtain gradient approximations, and a full derivation
of which, including the optimal solution, can be found in the appendix. In experiments we use V-
statistic solutions and leave comparisons between these methods to future work.
3.3	Comparisons to existing kernel-based gradient estimators
There exist other gradient estimators that do not require explicit evaluations of Rx log q(x), e.g. the
denoising auto-encoder (DAE) (Vincent et al., 2008; Vincent, 2011; Alain & Bengio, 2014) which,
with infinitesimal noise, also provides an estimate of Rx log q(x) at convergence. However, ap-
plying such gradient estimators result in a double-loop optimisation procedure since the gradient
approximation is repeatedly required for fitting implicit distributions, which can be significantly
slower than the proposed approach. Therefore we focus on “quick and dirty” approximations and
only include comparisons to kernel-based gradient estimators in the following.
3.3.1	KDE gradient estimator: plug-in estimator with density estimation
A naive approach for gradient approximation would first estimate the intractable density q(x) ≈
q(x) (up to a constant), then approximate the exact gradient by Vx log q(x) ≈ Vx log q(x). Specif-
ically, Singh (1977) considered kernel density estimation (KDE) q(x) = K PK=I K(x, Xk) X C.,
then differentiated through the KDE estimate to obtain the gradient estimator:
KK
G KDE = X Vxj K(χi, Xk)/X K(χi, Xk).	(14)
k=1	k=1
Interestingly for translation invariant kernels K(X, X0) = K(X - X0) the KDE gradient estimator
(14) can be rewritten as GKDE = -diag (K1)-1(V, Ki. Inspecting and comparing it with the
Stein gradient estimator (9), one might notice that the Stein method uses the full kernel matrix
as the pre-conditioner, while the KDE method computes an averaged “kernel similarity” for the
denominator. We conjecture that this difference is key to the superior performance of the Stein
gradient estimator when compared to the KDE gradient estimator (see later experiments). The KDE
method only collects the similarity information between Xk and other samples Xjto form an estimate
of Vxk log q(Xk), whereas for the Stein gradient estimator, the kernel similarity between Xi and Xj
for all i, j 6= k are also incorporated. Thus it is reasonable to conjecture that the Stein method can
be more sample efficient, which also implies higher accuracy when the same number of samples are
collected.
3.3.2	Score matching gradient estimator: minimising MSE
The KDE gradient estimator performs indirect approximation of the gradient via density estimation,
which can be inaccurate. An alternative approach directly approximates the gradient Vx log q(X)
by minimising the expected '2 error w.r.t. the approximation g(x) = (gι(x),…,gd(x))T:
F(g) := Eq IjIg(X)- Vx logq(x)∣∣2] .	(15)
It has been shown in Hyvarinen (2005) that this objective can be reformulated as
d
F(g) = Eq [∣∣g(x)∣∣2 + 2(V,g(x)i] + C, (V,g(x)i = XNxjgj(x).	(16)
j=1
The key insight here is again the usage of integration by parts: after expanding the `2 loss objective,
the cross term can be rewritten as Eq [g(x)TVx log q(x)] = -Eq [(V, g(x)i], if assuming the
boundary condition (4) for g (see (6)). The optimum of (16) is referred as the score matching
gradient estimator. The `2 objective (15) is also called Fisher divergence (Johnson, 2004) which is
a special case of KSD (11) by selecting K(X, X0) = δx=x0. Thus the Stein gradient estimator can be
viewed as a generalisation of the score matching estimator.
5
Published as a conference paper at ICLR 2018
The comparison between the two estimators is more complicated. Certainly by the Cauchy-Schwarz
inequality the Fisher divergence is stronger than KSD in terms of detecting convergence (Liu et al.,
2016). However it is difficult to perform direct gradient estimation by minimising the Fisher diver-
gence, since (i) the Dirac kernel is non-differentiable so that it is impossible to rewrite the divergence
in a similar form to (12), and (ii) the transformation to (16) involves computing Vχ<^(x). So one
needs to propose a parametric approximation to G and then optimise the associated parameters ac-
cordingly, and indeed Sasaki et al. (2014) and Strathmann et al. (2015) derived a parametric solution
by first approximating the log density UP to a constant as log q(x) := PK=I akK(x, xk) + C, then
minimising (16) to obtain the coefficients ascore and constructing the gradient estimator as
K
GsCOre = X akcoreVχi κ(χi, χk).	(17)
k=1
Therefore the usage of parametric estimation can potentially remove the advantage of using a
stronger divergence. Conversely, the proposed Stein gradient estimator (9) is non-parametric in
that it directly optimises over functions evaluated at locations {xk}kK=1. This brings in two key ad-
vantages over the score matching gradient estimator: (i) it removes the approximation error due to
the use of restricted family of parametric approximations and thus can be potentially more accurate;
(ii) it has a much simpler and ubiquitous form that applies to any kernel satisfying the boundary
condition, whereas the score matching estimator requires tedious derivations for different kernels
repeatedly (see appendix).
In terms of computation speed, since in most of the cases the computation of the score matching
gradient estimator also involves kernel matrix inversions, both estimators are of the same order of
complexity, which is O(K3 + K2d) (kernel matrix computation plus inversion). Low-rank approx-
imations such as the NyStrOm method (SmOla & Schokopf, 2000; Williams & Seeger, 2001) can
enable speed-up, but this is not investigated in the paper. Again we note here that kernel-based gra-
dient estimators can still be faster than e.g. the DAE estimator since no double-loop optimisation is
required. Certainly it is possible to apply early-stopping for the inner-loop DAE fitting. However
the resulting gradient approximation might be very poor, which leads to unstable training and poorly
fitted implicit distributions.
3.4	Adding predictive power
Though providing potentially more accurate approximations, the non-parametric estimator (9) has
no predictive power as described so far. Crucially, many tasks in machine learning require predicting
gradient functions at samples drawn from distributions other than q, for example, in MLE q(x)
corresponds to the model distribution which is learned using samples from the data distribution
instead. To address this issue, we derive two predictive estimators, one generalised from the non-
parametric estimator and the other minimises KSD using parametric approximations.
Predictions using the non-parametric estimator. Let us consider an unseen datum y. Ify is sam-
pled from q, then one can also apply the non-parametric estimator (9) for gradient approximation,
given the observed data X = {x1,..., xκ }〜q. Concretely, if writing g(y) ≈ Vy log q(y) ∈ Rd×1
then the non-parametric Stein gradient estimator computed on X ∪ {y} is
g(y)T
G
-(K* + ηi )-1
VyK(y, y) + PkK=1 VxkK(y, xk)
[	hV, Ki + VyK(∙, y)	」
K*
Kyy
KXy
with VyK(∙, y) denoting a K X d matrix with rows VyK(Xk, y), and VyK(y, y) only differen-
tiates through the second argument. Then we demonstrate in the appendix that, by simple matrix
calculations and assuming a translation invariant kernel, we have (with column vector 1 ∈ RK ×1):
Vy log q(y)T ≈ -(Kyy + η — KyX(K + ηi)-1Kχy)-1
(KyXG Vein-(KyX(K + ηi)-1 + ιτ) Vy κ(∙, y))
(18)
In practice one would store the computed gradient G Vem,the kernel matrix inverse (K + ηI)-1 and
η as the “parameters” of the predictive estimator. For a new observation y 〜P in general, one can
“pretend” y is a sample from q and apply the above estimator as well. The approximation quality
depends on the similarity between q and p, and we conjecture here that this similarity measure, if
can be described, is closely related to the KSD.
6
Published as a conference paper at ICLR 2018
Fitting a parametric estimator using KSD. The non-parametric predictive estimator could be
computationally demanding. Setting aside the cost of fitting the “parameters”, in prediction the
time complexity for the non-parametric estimator is O(K2 + Kd). Also storing the “parameters”
needs O(Kd) memory for GVein. These costs make the non-parametric estimator undesirable for
high-dimensional data, since in order to obtain accurate predictions it often requires K scaling with
d as well. To address this, one can also minimise the KSD using parametric approximations, in a
similar way as to derive the score matching estimator in Section 3.3.2. More precisely, we define
a parametric approximation in a similar fashion as (17), and in the appendix we show that if the
RBF kernel is used for both the KSD and the parametric approximation, then the linear coefficients
a = (aι,…，aκ)t can be calculated analytically: aVem = (Λ + ηI)-1b, where
Λ =X	(KKK) +K(KX)K- ((KK) X)K - K((KK)	X),
b =(Kdiag(X)K + (KK) X-K(KX) - (K	X)K)1,
(19)
with X the “gram matrix” that has elements Xij = (Xi)Txj. Then for an unseen observation y 〜
P the gradient approximation returns Ny log q(y) ≈ (aVem)TVyK(∙, y). In this case one only
maintains the linear coefficients a Vem and computes a linear combination in prediction, which takes
O(K) memory and O(Kd) time and therefore is computationally cheaper than the non-parametric
prediction model (27).
4 Applications
We present some case studies that apply the gradient estimators to implicit models. Detailed set-
tings (architecture, learning rate, etc.) are presented in the appendix. Implementation is released at
https://github.com/YingzhenLi/SteinGrad.
4.1	Synthetic example: Hamiltonian flow with approximate gradients
We first consider a simple synthetic example to demonstrate the accuracy of the proposed gradient
estimator. More precisely we consider the kernel induced Hamiltonian flow (not an exact sampler)
(Strathmann et al., 2015) on a 2-dimensional banana-shaped object: x 〜 B(x; b = 0.03, v =
100) ⇔ xι 〜N(xi；0, v), x2 = E + b(x2 一 v), e 〜N(e; 0,1). The approximate Hamiltonian flow
is constructed using the same operator as in Hamiltonian Monte Carlo (HMC) (Neal et al., 2011),
except that the exact score function Nx log B(x) is replaced by the approximate gradients. We still
use the exact target density to compute the rejection step as we mainly focus on testing the accuracy
of the gradient estimators. We test both versions of the predictive Stein gradient estimator (see
section 3.4) since we require the particles of parallel chains to be independent with each other. We
fit the gradient estimators on K = 200 training datapoints from the target density. The bandwidth
of the RBF kernel is computed by the median heuristic and scaled up by a scalar between [1, 5].
All three methods are simulated for T = 2, 000 iterations, share the same initial locations that are
constructed by target distribution samples plus Gaussian noises of standard deviation 2.0, and the
results are averaged over 200 parallel chains.
We visualise the samples and some MCMC statistics in Figure 2. In general all the resulting Hamil-
tonian flows are HMC-like, which give us the confidence that the gradient estimators extrapolate
reasonably well at unseen locations. However all of these methods have trouble exploring the ex-
tremes, because at those locations there are very few or even no training data-points. Indeed we
found it necessary to use large (but not too large) bandwidths, in order to both allow exploration
of those extremes, and ensure that the corresponding test function is not too smooth. In terms of
quantitative metrics, the acceptance rates are reasonably high for all the gradient estimators, and the
KSD estimates (across chains) as a measure of sample quality are also close to that computed on
HMC samples. The returned estimates ofE[x1] are close to zero which is the ground true value. We
found that the non-parametric Stein gradient estimator is more sensitive to hyper-parameters of the
dynamics, e.g. the stepsize of each HMC step. We believe a careful selection of the kernel (e.g. those
with long tails) and a better search for the hyper-parameters (for both the kernel and the dynamics)
can further improve the sample quality and the chain mixing time, but this is not investigated here.
7
Published as a conference paper at ICLR 2018
Figure 2: Kernel induced Hamiltonian flow compared with HMC. Top: samples generated from the
dynamics, training data (in cyan), an the trajectory of a particle for T = 1 to 200 starting at the star
location (in yellow). Bottom: statistics computed during simulations. See main text for details.
4.2	Meta-learning of approximate posterior samplers for Bayesian NNs
One of the recent focuses on meta-learning has been on learning optimisers for training deep neural
networks, e.g. see (Andrychowicz et al., 2016). Could analogous goals be achieved for approximate
inference? In this section we attempt to learn an approximate posterior sampler for Bayesian neural
networks (Bayesian NNs, BNNs) that generalises to unseen datasets and architectures. A more
detailed introduction of Bayesian neural networks is included in the appendix, and in a nutshell,
we consider a binary classification task: p(y = 1|x, θ) = sigmoid(NNθ(x)), p0 (θ) = N(θ; 0, I).
After observing the training data D = {(xn, yn)}nN=1, we first obtain the approximate posterior
qφ(θ) ≈ p(θ∣D) 8 Po(θ) QnN=I p(yn∣Xn, θ), then approximate the predictive distribution for a
new observation as p(y* = 1∣x*, D) ≈ K Pk=Ip(y* = 1∣x*, θk), θk 〜qφ(θ). In this task we
define an implicit approximate posterior distribution qφ(θ) as the following stochastic normalising
flow (Rezende & Mohamed, 2015) θt+ι = f (θt, Vt, €t): given the current location θt and the
mini-batch data {(xm, ym)}mM=1, the update for the next step is
θt+ι = θt + Z∆φ(θt, Vt) + σφ(θt, Vt) Θ q, Wt 〜N(与 0,1),
Vt = Vθt
NM
M E logP(ym∣Xm, θt) + logPθ(θt)
m=1
(20)
The coordinates of the noise standard deviation σφ(θt, Vt) and the moving direction ∆φ(θt, Vt)
are parametrised by a coordinate-wise neural network. If properly trained, this neural network will
learn the best combination of the current location and gradient information, and produce approxi-
mate posterior samples efficiently on different probabilistic modelling tasks. Here we propose using
the variational inference objective (2) computed on the samples {θtk} to learn the variational param-
eters φ. Since in this case the gradient of the log joint distribution can be computed analytically,
we only approximate the gradient of the entropy term H[q] as in (3), with the exact score func-
tion replaced by the presented gradient estimators. We report the results using the non-parametric
Stein gradient estimator as we found it works better than the parametric version. The RBF kernel
is applied for gradient estimation, with the hyper-parameters determined by a grid search on the
bandwidth σ2 ∈ {0.25, 1.0, 4.0, 10.0, median trick} and η ∈ {0.1, 0.5, 1.0, 2.0}.
We briefly describe the test protocol. We take from the UCI repository (Lichman, 2013) six binary
classification datasets (australian, breast, crabs, ionosphere, pima, sonar), train an approximate sam-
pler on crabs with a small neural network that has one 20-unit hidden layer with ReLU activation,
and generalise to the remaining datasets with a bigger network that has 50 hidden units and uses
sigmoid activation. We use ionosphere as the validation set to tune ζ. The remaining 4 datasets
are further split into 40% training subset for simulating samples from the approximate sampler, and
60% test subsets for evaluating the sampler’s performance.
Figure 3 presents the (negative) test log-likelihood (LL), classification error, and an estimate of
the KSD U-statistic SU(p(θ∣D), q(θ)) (with data sub-sampling) over 5 splits of each test dataset.
Besides the gradient estimators we also compare with two baselines: an approximate posterior sam-
pler trained by maximum a posteriori (MAP), and stochastic gradient Langevin dynamics (SGLD)
8
Published as a conference paper at ICLR 2018
australian
0	l∞0	2000
0∙0-
8a EQ
gE2~asx
O IOOO 2000 O IOOO 2000 O IOOO 2000 O 5000 IOOOO
iteration	iteration	iteration	iteration
Figure 3: Generalisation performances for trained approximate posterior samplers.
(Welling & Teh, 2011) evaluated on the test datasets directly. In summary, SGLD returns best re-
sults in KSD metric. The Stein approach performs equally well or a little better than SGLD in
terms of test-LL and test error. The KDE method is slightly worse and is close to MAP, indicating
that the KDE estimator does not provide a very informative gradient for the entropy term. Surpris-
ingly the score matching estimator method produces considerably worse results (except for breast
dataset), even after carefully tuning the bandwidth and the regularisation parameter η. Future work
should investigate the usage of advanced recurrent neural networks such as an LSTM (Hochreiter &
Schmidhuber, 1997), which is expected to return better performance.
4.3	Towards addressing mode collapse in GANs using entropy regularisation
GANs are notoriously difficult to train in practice. Besides the instability of gradient-based minimax
optimisation which has been partially addressed by many recent proposals (Salimans et al., 2016;
Arjovsky et al., 2017; Berthelot et al., 2017), they also suffer from mode collapse. We propose
adding an entropy regulariser to the GAN generator loss. Concretely, assume the generative model
Pθ(x) is implicitly defined by X = fθ(z), Z 〜po (z), then the generator's loss is defined by
~	，一、	—	，一、	__r	z	....
Jgen(θ) = Jgen(θ) - αH[pe(x)],	(21)
where Jgen(θ) is the original loss function for the generator from any GAN algorithm and α is a
hyper-parameter. In practice (the gradient of) (21) is estimated using Monte Carlo.
We empirically investigate the entropy regularisation idea on the very recently proposed boundary
equilibrium GAN (BEGAN) (Berthelot et al., 2017) method using (continuous) MNIST, and we
refer to the appendix for the detailed mathematical set-up. In this case the non-parametric V-statistic
Stein gradient estimator is used. We use a convolutional generative network and a convolutional
auto-encoder and select the hyper-parameters of BEGAN γ ∈ {0.3, 0.5, 0.7}, α ∈ [0, 1] and λ =
0.001. The Epanechnikov kernel K(x, x0) := 1 pd=1(1 - (Xj - xj)2) is used as the pixel values lie
in a unit interval (see appendix for the expression of the score matching estimator), and to ensure the
boundary condition we clip the pixel values into range [10-8, 1 - 10-8]. The generated images are
visualised in Figure 4. BEGAN without the entropy regularisation fails to generate diverse samples
even when trained with learning rate decay. The other three images clearly demonstrate the benefit of
the entropy regularisation technique, with the Stein approach obtaining the highest diversity without
compromising visual quality.
We further consider four metrics to assess the trained models quantitatively. First 500 samples
are generated for each trained model, then we compute their nearest neighbours in the training set
using l1 distance, and obtain a probability vector p by averaging over these neighbour images’
label vectors. In Figure 5 we depict the entropy of p (top left), averaged l1 distances to the nearest
neighbour (top right), and the difference between the largest and smallest elements in p (bottom
right). The error bars are obtained by 5 independent runs. These results demonstrate that the Stein
9
Published as a conference paper at ICLR 2018

original
f q4 q/76 3 q3
夕夕，77,17夕 9
tr∙GX7 , ZI 9∕rr¼
2/ 7/3。/ 9，Irl
y22J∕ 7/ Qi u∖ ⅞
1 7λ。1 270 03
O4^ozrg-7A57
oa4。，6「，。，
J2o∕fj0004
Γ-÷J 7la4 O O C
G 7ΛO
zpðs 2。q 72 ∂
,E937 夕77Q2
00〃 3267332
4 H 3 7 夕
57qq^s 3D “g
6τ∙q75J3 Q/ y 7
, γc552q∙oj∙o
4N 73G5 夕 JAJ 97
Ny6 773701 1
34601 3 666 9
oðΓ743Z3 7zrl
Z22z9*g 夕 Og
√3∕f 376 S以 7
9 5 3 3 7 7 Q∙6 “夕
KDE
Score
Stein
0 5 0 5 0 5 0
3 2 2 110 0
SFgN-
Figure 4: Visualisation of generated images from trained BEGAN models.
60
00
1
0 8 6 4 2 0
Loooo6
u4d I 思Ed
60
c
O
00
1
Figure 5: Quantitative evaluation on entropy regularised BEGAN. The higher the better for the LHS
panels and the other way around for the RHS ones. See main text for details.
approach performs significantly better than the other two, in that it learns a better generative model
not only faster but also in a more stable way. Interestingly the KDE approach achieves the lowest
average l1 distance to nearest neighbours, possibly because it tends to memorise training examples.
We next train a fully connected network ∏(y∣x) on MNIST that achieves 98.16% text accuracy,
and compute on the generated images an empirical estimate of the inception score (Salimans et al.,
2016) Ep(x)[KL[n(y|x)||n(y)]] with π(y) = Ep(X)[π(y∣x)] (bottom left panel). High inception
score indicates that the generate images tend to be both realistic looking and diverse, and again the
Stein approach out-performs the others on this metric by a large margin.
Concerning computation speed, all the three methods are of the same order: 10.20s/epoch for KDE,
10.85s/epoch for Score, and 10.30s/epoch for Stein.1 This is because K < d (in the experiments
K = 100 and d = 784) so that the complexity terms are dominated by kernel computations
(O(K2d)) required by all the three methods. Also for a comparison, the original BEGAN method
without entropy regularisation runs for 9.05s/epoch. Therefore the main computation cost is dom-
inated by the optimisation of the discriminator/generator, and the proposed entropy regularisation
can be applied to many GAN frameworks with little computational burden.
5 Conclusions and future work
We have presented the Stein gradient estimator as a novel generalisation to the score matching gra-
dient estimator. With a focus on learning implicit models, we have empirically demonstrated the
efficacy of the proposed estimator by showing how it opens the door to a range of novel learning
tasks: approximating gradient-free MCMC, meta-learning for approximate inference, and unsu-
pervised learning for image generation. Future work will expand the understanding of gradient
estimators in both theoretical and practical aspects. Theoretical development will compare both
the V-statistic and U-statistic Stein gradient estimators and formalise consistency proofs. Practical
work will improve the sample efficiency of kernel estimators in high dimensions and develop fast
yet accurate approximations to matrix inversion. It is also interesting to investigate applications of
gradient approximation methods to training implicit generative models without the help of discrim-
inators. Finally it remains an open question that how to generalise the Stein gradient estimator to
non-kernel settings and discrete distributions.
1All the methods are timed on a machine with an NVIDIA GeForce GTX TITAN X GPU.
10
Published as a conference paper at ICLR 2018
Acknowledgement
We thank Marton Havasi, Jiri Hron, David Janz, Qiang Liu, Maria Lomeli, Cuong Viet Nguyen and
Mark Rowland for their comments and helps on the manuscript. We also acknowledge the anony-
mous reviewers for their review. Yingzhen Li thanks Schlumberger Foundation FFTF fellowship.
Richard E. Turner thanks Google and EPSRC grants EP/M0269571 and EP/L000776/1.
References
Guillaume Alain and Yoshua Bengio. What regularized auto-encoders learn from the data-generating
distribution. The Journal ofMachine Learning Research,15(1):3563-3593, 2014.
Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul,
and Nando de Freitas. Learning to learn by gradient descent by gradient descent. In Advances in
Neural Information Processing Systems, pp. 3981-3989, 2016.
Martin Arjovsky, Soumith Chintala, and Leon Bottou. Wasserstein gan. arXiv preprint
arXiv:1701.07875, 2017.
David Barber and Felix V Agakov. The im algorithm: A variational approach to information maxi-
mization. In NIPS, pp. 201-208, 2003.
Alain Berlinet and Christine Thomas-Agnan. Reproducing kernel Hilbert spaces in probability and
statistics. Springer Science & Business Media, 2011.
David Berthelot, Tom Schumm, and Luke Metz. Began: Boundary equilibrium generative adversar-
ial networks. arXiv preprint arXiv:1703.10717, 2017.
Kacper Chwialkowski, Heiko Strathmann, and Arthur Gretton. A kernel test of goodness of fit. In
Proceedings of The 33rd International Conference on Machine Learning, pp. 2606-2615, 2016.
Kris De Brabanter, Jos De Brabanter, Bart De Moor, and Irene Gijbels. Derivative estimation with
local polynomial fitting. The Journal of Machine Learning Research, 14(1):281-301, 2013.
Peter J Diggle and Richard J Gratton. Monte carlo methods of inference for implicit statistical
models. Journal of the Royal Statistical Society. Series B (Methodological), pp. 193-227, 1984.
Jianqing Fan and Irne Gijbels. Local polynomial modelling and its applications. Chapman & Hall,
1996.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NIPS, 2014.
Jackson Gorham and Lester Mackey. Measuring sample quality with stein’s method. In NIPS, 2015.
Jackson Gorham and Lester Mackey. Measuring sample quality with kernels. In ICML, 2017.
Geoffrey E Hinton. Training products of experts by minimizing contrastive divergence. Neural
computation, 14(8):1771-1800, 2002.
SePP Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 9(8):
1735-1780, 1997.
Ferenc Huszar. Variational inference using implicit distributions. arXiv preprint arXiv:1702.08235,
2017.
Aapo Hyvarinen. Estimation of non-normalized statistical models by score matching. Journal of
Machine Learning Research, 6(APr):695-709, 2005.
Aapo Hyvarinen. Consistency of pseudolikelihood estimation of fully visible boltzmann machines.
Neural Computation, 18(10):2283-2292, 2006.
Oliver Thomas Johnson. Information theory and the central limit theorem. World Scientific, 2004.
11
Published as a conference paper at ICLR 2018
Theofanis Karaletsos. Adversarial message passing for graphical models. arXiv preprint
arXiv:1612.05048, 2016.
Diederick P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International
Conference on Learning Representations (ICLR), 2015.
Naveen Kodali, Jacob Abernethy, James Hays, and Zsolt Kira. How to train your dragan. arXiv
preprint arXiv:1705.07215, 2017.
Yingzhen Li and Qiang Liu. Wild variational approximations. NIPS workshop on advances in
approximate Bayesian inference, 2016.
Yingzhen Li, Richard E Turner, and Qiang Liu. Approximate inference with amortised mcmc. arXiv
preprint arXiv:1702.08343, 2017.
M. Lichman. UCI machine learning repository, 2013. URL http://archive.ics.uci.edu/
ml.
Qiang Liu and Yihao Feng. Two methods for wild variational inference. arXiv preprint
arXiv:1612.00081, 2016.
Qiang Liu, Jason D Lee, and Michael I Jordan. A kernelized stein discrepancy for goodness-of-fit
tests and model evaluation. In ICML, 2016.
Siwei Lyu. Interpretation and generalization of score matching. In Proceedings of the Twenty-Fifth
Conference on Uncertainty in Artificial Intelligence,pp. 359-366. AUAI Press, 2009.
Benjamin Marlin, Kevin Swersky, Bo Chen, and Nando Freitas. Inductive principles for restricted
boltzmann machine learning. In Proceedings of the Thirteenth International Conference on Arti-
ficial Intelligence and Statistics, pp. 509-516, 2010.
Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. Adversarial variational bayes: Unifying
variational autoencoders and generative adversarial networks. arXiv preprint arXiv:1701.04722,
2017.
Shakir Mohamed and Balaji Lakshminarayanan. Learning in implicit generative models. arXiv
preprint arXiv:1610.03483, 2016.
Radford M Neal et al. Mcmc using hamiltonian dynamics. Handbook of Markov Chain Monte
Carlo, 2:113-162, 2011.
Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep
convolutional generative adversarial networks. In ICLR, 2016.
Rajesh Ranganath, Jaan Altosaar, Dustin Tran, and David M. Blei. Operator variational inference.
In NIPS, 2016.
Danilo Jimenez Rezende and Shakir Mohamed. Variational inference with normalizing flows. In
ICML, 2015.
Geoffrey Roeder, Yuhuai Wu, and David Duvenaud. Sticking the landing: An asymptotically zero-
variance gradient estimator for variational inference. arXiv preprint arXiv:1703.09194, 2017.
Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford, and Xi Chen.
Improved techniques for training gans. In NIPS, 2016.
Jaakko Sarela and Harri Valpola. Denoising source separation. Journal of machine learning re-
search, 6(Mar):233-272, 2005.
Hiroaki Sasaki, Aapo Hyvarinen, and Masashi Sugiyama. Clustering via mode seeking by direct
estimation of the gradient of a log-density. In Joint European Conference on Machine Learning
and Knowledge Discovery in Databases, pp. 19-34. Springer, 2014.
Radhey S Singh. Improvement on some known nonparametric uniformly consistent estimators of
derivatives of a density. The Annals of Statistics, pp. 394-399, 1977.
12
Published as a conference paper at ICLR 2018
Alex J Smola and Bernhard SchOkopf. Sparse greedy matrix approximation for machine learning.
In Proceedings of the Seventeenth International Conference on Machine Learning, pp. 911-918.
Morgan Kaufmann Publishers Inc., 2000.
Casper Kaae Sonderby, Jose Caballero, Lucas Theis, Wenzhe Shi, and Ferenc Huszar. Amortised
map inference for image super-resolution. In ICLR, 2017.
Charles Stein. A bound for the error in the normal approximation to the distribution of a sum of
dependent random variables. In Proceedings of the Sixth Berkeley Symposium on Mathematical
Statistics and Probability, Volume 2: Probability Theory, pp. 583-602, 1972.
Charles M Stein. Estimation of the mean of a multivariate normal distribution. The annals of
Statistics, pp. 1135-1151, 1981.
Charles J Stone. Additive regression and other nonparametric models. The annals of Statistics, pp.
689-705, 1985.
Heiko Strathmann, Dino Sejdinovic, Samuel Livingstone, Zoltan Szabo, and Arthur Gretton.
Gradient-free hamiltonian monte carlo with efficient kernel exponential families. In Advances
in Neural Information Processing Systems, pp. 955-963, 2015.
Masashi Sugiyama, Takafumi Kanamori, Taiji Suzuki, Shohei Hido, Jun Sese, Ichiro Takeuchi, and
Liwei Wang. A density-ratio framework for statistical data processing. Information and Media
Technologies, 4(4):962-987, 2009.
Masashi Sugiyama, Taiji Suzuki, and Takafumi Kanamori. Density-ratio matching under the breg-
man divergence: a unified framework of density-ratio estimation. Annals of the Institute of Sta-
tistical Mathematics, 64(5):1009-1044, 2012.
Dustin Tran, Rajesh Ranganath, and David M Blei. Deep and hierarchical implicit models. arXiv
preprint arXiv:1702.08896, 2017.
R. E. Turner and M. Sahani. Two problems with variational expectation maximisation for time-series
models. In D. Barber, T. Cemgil, and S. Chiappa (eds.), Bayesian Time series models, chapter 5,
pp. 109-130. Cambridge University Press, 2011.
Masatoshi Uehara, Issei Sato, Masahiro Suzuki, Kotaro Nakayama, and Yutaka Matsuo. Generative
adversarial nets from a density ratio estimation perspective. arXiv preprint arXiv:1610.02920,
2016.
Pascal Vincent. A connection between score matching and denoising autoencoders. Neural compu-
tation, 23(7):1661-1674, 2011.
Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol. Extracting and
composing robust features with denoising autoencoders. In Proceedings of the 25th international
conference on Machine learning, pp. 1096-1103. ACM, 2008.
Dilin Wang and Qiang Liu. Learning to draw samples: With application to amortized mle for
generative adversarial learning. arXiv preprint arXiv:1611.01722, 2016.
Max Welling and Yee W Teh. Bayesian learning via stochastic gradient langevin dynamics. In
Proceedings of the 28th International Conference on Machine Learning (ICML-11), pp. 681-688,
2011.
Christopher KI Williams and Matthias Seeger. Using the nystrom method to speed up kernel ma-
chines. In Advances in neural information processing systems, pp. 682-688, 2001.
Lantao Yu, Weinan Zhang, Jun Wang, and Yong Yu. Seqgan: sequence generative adversarial nets
with policy gradient. In Thirty-First AAAI Conference on Artificial Intelligence, 2017.
Shanggang Zhou and Douglas A Wolfe. On derivative estimation in spline regression. Statistica
Sinica, pp. 93-108, 2000.
13
Published as a conference paper at ICLR 2018
A Score matching estimator: remarks and derivations
In this section we provide more discussions and analytical solutions for the score matching esti-
mator. More specifically, we will derive the linear coefficient a = (a1, ..., aK) for the case of the
Epanechnikov kernel.
A. 1 Some remarks on score matching
Remark. It has been shown in Sarela & Valpola (2005); Alain & Bengio (2014) that de-noising auto-
encoders (DAEs) (Vincent et al., 2008), once trained, can be used to compute the score function
approximately. Briefly speaking, a DAE learns to reconstruct a datum x from a corrupted input
X = x+σe, e 〜N(0, I) by minimising the mean square error. Then the optimal DAE can be used to
approximate the score function as Nx logp(x) ≈ σ12(DAE*(x) 一x). Sonderby et al. (2017) applied
this idea to train an implicit model for image super-resolution, providing some promising results
in some metrics. However applying similar ideas to variational inference can be computationally
expensive, because the estimation of Nz log q(z|x) is a sub-routine for VI which is repeatedly
required. Therefore in the paper we deploy kernel machines that allow analytical solutions to the
score matching estimator in order to avoid double loop optimisation.
Remark. As a side note, score matching can also be used to learn the parameters of an unnor-
malised density. In this case the target distribution q would be the data distribution and q is often
a Boltzmann distribution with intractable partition function. As a parameter estimation technique,
score matching is also related to contrastive divergence (Hinton, 2002), pseudo likelihood estima-
tion (Hyvarinen, 2006), and DAEs (Vincent, 2011; Alain & Bengio, 2014). Generalisations of score
matching methods are also presented in e.g. Lyu (2009); Marlin et al. (2010).
A.2 The RBF kernel case
The derivations for the RBF kernel case is referred to (Strathmann et al., 2015), and for com-
pleteness we include the final solutions here. Assume the parametric approximation is defined as
log q(x) = Pk=I akK(x, xk) + C, where the RBF kernel uses bandwidth parameter σ. then the
optimal solution of the coefficients ascore = (∑ + ηI)-1v, with
d
v=X
i=1
σ2K1 一 K(xi	xi) + diag(xi)K1 一 2diag(xi)Kxi
d
Σ = X [diag(xi)K 一 Kdiag(xi)] [Kdiag(xi) 一 diag(xi)K] ,
i=1
xi = (xi1,xi2, ..., xiK )T ∈ RK ×1
A.3 The Epanechnikov kernel case
The Epanechnikov kernel is defined as K(x, x0) = d Pd=I(I —(Xi — χi)2), where the first and
second order gradients w.r.t. xi is
22
RxiK(x, X ) = d(Xi — Xi), RxiRxiK(x, X ) = - d	(22)
Thus the score matching objective with log q(x) = PK=I akK(x, xk) + C is reduced to
1K
F ⑷=K X
j=1
K
=-X
K M
K2	K2
|| X ak d (x - x )||2 - 2 X ak dd
k=1	k=1
KK
dp XX akak0(xk — Xj)τ(xk0 — Xj) — aT1
k=1 k0=1
(aTΣa — aT1),
14
Published as a conference paper at ICLR 2018
with the matrix elements
1「__________ 1 ɪ Z 一 一 一、
Nkk0 = d2 (Xk)Txk + KX (||xj||2 -(Xk + Xk 尸Xj)
j=1
Define the “gram matrix” Xij = (Xi)TXj, we write the matrix form of Σ as
∑ = ɪ X + K (Tr(X) - 2X11T).
Thus with an l2 regulariser, the fitted coefficients are
d2	1	-1
a score = — X + — (Tr(X) - 2X11t ) + ηI L
B S tein gradient es timator: derivations
B.1	Direct minimisation of KSD V-statistic and U-statistic
The V-statistic of KSD is the following: given samples xk 〜q,k = 1,..., K and recall Kjl =
K(Xj, Xl)
KK
SV(q,q) = K2 XX [g(xj)TKjlg(Xl)+ g(xj)TVxlKjl + VxjKTlg(xl)+ Tr(Vxj,χiKjl)].
j=1 l=1
(23)
The last term Vxj xl Kjl will be ignored as it does not depend on the approximation g. Using matrix
notations defined in the main text, readers can verify that the V-statistic can be computed as
1
SV (q,q) =&2 Tr(KG GT + 2hV, KiGT) + C.	(24)
K2
Using the cyclic invariance of matrix trace leads to the desired result in the main text. The U-statistic
of KSD removes terms indexed by j = l in (23), in which the matrix form is
SU(q,q) = τ,lτ,	T Tr((K - diag(K))GGT + 2(hV, Ki- Vdiag(K))Gt) + C. (25)
K(K - 1)
with the jth row of Vdiag(K) defined as Vxj K(Xj, Xj). For most translation invariant kernels this
extra term Vdiag(K) = 0, thus the optimal solution of G by minimising KSD U-statistic is
GUein = -(K - diag(K) + ηI)-1hV, K〉.	(26)
B.2	Deriving the non-parametric predictive estimator
Let us consider an unseen datum y. If y is sampled from the q distribution, then one can also
apply the non-parametric estimator (9) for gradient approximations, given the observed data X =
{x1,…，xk} ~ q. Concretely, if writing g(y) ≈ Vy log q(y) ∈ Rd×1 then the non-parametric
Stein gradient estimator (using V-statistic) is
g(y)τ
G
-(K* + ηI )-1
VyK(y, y) + PkK=1 VxkK(y, Xk)
[	hV, Ki + VyK(∙, y)	」
K*
Kyy
KXy
with VyK(∙, y) denoting a K X d matrix with rows VyK(xk, y), and VyK(y, y) only differentiates
through the second argument. Thus by simple matrix calculations, we have:
Vy log q(y)T ≈ - (Kyy + ŋ - KyX(K + ηI)-1Kχy) T
VyK(y, y) + X VxkK(y, xk) + KyXGVein- KyX(K + ηI)-1 VyK(∙, y))
k=1
(27)
15
Published as a conference paper at ICLR 2018
For translation invariant kernels, typically VyK(y, y) = 0, and more conveniently,
VxkK(y, Xk) = Vχk(Xk - y)V(χk-y)K(xk - y) = -VyK(Xk, y).
Thus equation (27) can be further simplified to (with column vector 1 ∈ RK×1)
Vy log q(y)T ≈ -(Kyy + η — KyX(K + ηI)-1Kχy)-1
(KyXGVein- (Kyx(K + ηi)-1 + IT) VyK(∙, y)).
The solution for the U-statistic case can be derived accordingly which we omit here.
(28)
B.3	Parametric Stein gradient estimator with the RBF kernel
We define a parametric approximation in a similar way as for the score matching estimator:
K
log q(x) := ^X a，kK(x, xk) + C, K(x, x0)
k=1
eχp -2σσ2||x - x0||2 .
(29)
Now we show the optimal solution of a = (a1, ..., aK)T by minimising (23). To simplify derivations
we assume the approximation and KSD use the same kernel. First note that the gradient of the RBF
kernel is
VxK(x, x0) = ±K(x, x0)(x0 — x).	(30)
σ2
Substituting (30) into (23):
SV (q,q) = C + 4 + 24,
1KKKK	1	0
* = K ΣΣΣΣ ak ak0 KkjKjl KikO ±(Xk- Xj )T(xk - xl),	(31)
k=1 k0=1 j=1 l=1	σ
4 = K XX XL XL akKkjKjlσ14(Xk - Xj)T(Xj-Xl).	(32)
k=1 j=1 l=1	σ
We first consider summing the j, l indices in *. Recall the “gram matrix” Xij = (Xi)TXj, the inner
product term in * can be expressed as Xkk0 + Xjl - Xkl - Xjk0. Thus the summation over j, l can
be re-written as
KK
Λ := X X KkjKjlKlk0 (Xkk0 + Xjl - Xkl - Xjk0)
j=1 l=1
=X	(KKK) +K(KX)K - ((KK)	X)K - K((KK)	X).
And thus * = σ4aTΛa. Similarly the summation over j, l in 4 can be simplified into
KK
-b:= X XKkjKjl(Xkj+Xjl -Xkl -Xjj)
j=1 l=1
= - (Kdiag(X)K + (KK)	X- K(KX) - (K	X)K)1,
which leads to 4 = - σ4 aTb. Thus minimising SV (q, q) plus an l2 regulariser returns the Stein
estimator aVem in the main text.
Similarly we can derive the solution for KSD U-statistic minimisation. The U statistic can also be
represented in quadratic form SU (q,q) = C + * + 24, With 4 = 4 and
KKK
k=1 k0=1 j=1
ak ak0 Kkj
16
Published as a conference paper at ICLR 2018
Summing over the j indices for the second term, we have
K
KkjKjjKjk0 (Xkk0 + Xjj - Xkj - Xjk0)
j=1
=X	(Kdiag(K)K) + Kdiag(K X)K - ((Kdiag(K))	X)K - K((diag(K)K)	X).
Working through the analogous derivations reveals that aUem = (Λ + ηI)-1b, with
Λ =X Θ (K(K — diag(K))K) + K((K Θ X) — diag(K Θ X))K
- ((K(K - diag(K)))	X)K - K(((K - diag(K))K)	X).
C More details on the experiments
We describe the detailed experimental set-up in this section. All experiments use Adam optimiser
(Kingma & Ba, 2015) with standard parameter settings.
C.1 Approximate posterior sampler experiments
We start by reviewing Bayesian neural networks with binary classification as a running example.
In this task, a normal deep neural network is constructed to predict y = fθ (x), and the neural
network is parameterised by a set of weights (and bias vectors which we omit here for simplicity)
θ= {Wl}lL=1. In the Bayesian framework these network weights are treated as random variables,
and a prior distribution, e.g. Gaussian, is also attached to them: p0(θ) = N(θ; 0, I). The likelihood
function of θ is then defined as
p(y = 1|x, θ) = sigmoid(NNθ(x)),
and p(y = 0|x, θ) = 1 - p(y = 1|x, θ) accordingly. One can show that the usage of Bernoulli
distribution here corresponds to applying cross entropy loss for training.
After framing the deep neural network as a probabilistic model, a Bayesian approach would find the
posterior of the network weights p(θ∣D) and use the uncertainty information encoded in it for future
predictions. By Bayes’ rule, the exact posterior is
N
p(θlD) <X P0(θ) Y p(yn|xn, θ),
n=1
and the predictive distribution for a new input x* is
p(y* = 1∣x*, D) = / p(y* = 1∣x*, θ)p(θ∣D)dθ.	(33)
Again the exact posterior is intractable, and approximate inference would fit an approximate poste-
rior distribution qφ(θ) parameterised by the variational parameters φ to the exact posterior, and then
use it to compute the (approximate) predictive distribution.
p(y* = 1|x*, D) ≈	p(y* = 1|x*, θ)qφ(θ)dθ.
Since in practice analytical integration for neural network weights is also intractable, the predictive
distribution is further approximated by Monte Carlo:
1K
p(y* = ι∣χ*, D) ≈ KK Ep(y* = ι∣χ*, θk), θk 〜qφ(θ).
Now it remains to fit the approximate posterior qφ(θ), and in the experiment the approximate pos-
terior is implicitly constructed by a stochastic flow. For the training task, we use a one hidden
layer neural network with 20 hidden units to compute the noise variance and the moving direction
of the next update. In a nutshell it takes the ith coordinate of the current position and the gra-
dient θt(i), Vt(i) as the inputs, and output the corresponding coordinate of the moving direction
17
Published as a conference paper at ICLR 2018
∆φ(θt, Vt)(i) and the noise variance σφ(θt, Vt)(i). Softplus non-linearity is used for the hidden
layer and to compute the noise variance we apply ReLU activation to ensure non-negativity. The
step-size ζ is selected as 1e-5 which is tuned on the KDE approach. For SGLD step-size 1e-5 also
returns overall good results.
The training process is the following. We simulate the approximate sampler for 10 transitions and
sum over the variational lower-bounds computed on the samples of every step. Concretely, the
maximisation objective is
T
L(φ) = XLVI(qt),
t=1
where T = 100 and qt(θ) is implicitly defined by the marginal distribution of θt that is dependent
on φ. In practice the variational lower-bound LVI(qt) is further approximated by Monte Carlo and
data sub-sampling:
NM
Lvι(qt) ≈ M ElOgp(ym∣χm, θt) + logpo(θt) - logqt(θt).
m=1
The MAP baseline considers an alternative objective function by removing the log qt(θt) term from
the above MC-VI objective.
Truncated back-propagation is applied for every 10 steps in order to avoid vanishing/exploding
gradients. The simulated samples at time T are stored to initialise the Markov chain for the next
iteration, and for every 50 iterations we restart the simulation by randomly sampling the locations
from the prior. Early stopping is applied using the validation dataset, and the learning rate is set to
0.001, the number of epochs is set to 500.
We perform hyper-parameter search for the kernel, i.e. a grid search on the bandwidth σ2 ∈
{0.25, 1.0, 4.0, 10.0, median trick} and η ∈ {0.1, 0.5, 1.0, 2.0}. We found the median heuristic is
sufficient for the KDE and Stein approaches. However, we failed to obtain desirable results using the
score matching estimator with median heuristics, and for other settings the score matching approach
underperforms when compared to KDE and Stein methods.
C.2 BEGAN experiments
In this section we describe the experimental details of the BEGAN experiment, but first we introduce
the mathematical idea and discuss how the entropy regulariser is applied.
Assume the generator is implicitly defined: X 〜pθ(x)什 X = fθ(z), Z 〜po(z). In BEGAN the
discriminator is defined as an auto-encoder DP(X) that reconstructs the input x. After selecting a
ratio parameter γ > 0, a control rate β0 initialised at 0, and a “learning rate” λ > 0 for the control
rate, the loss functions for the generator X = fθ(z), Z 〜po(z) and the discriminator are:
J (X) = IIDp (x) - x||,	l∣∙∣l = I∣∙∣∣2 or ∣∣∙∣∣1,
Jgen(θ; φ) = J (fθ (z)),	Z 〜Pθ(z)
Jdis3 θ) = J (X)- βtJgen(θ; φ),	X 〜D
βt+1 = βt + λ(γJ(X) - J(fθ(Z))).
(34)
The main idea behind BEGAN is that, as the reconstruction loss J(∙) is approximately Gaussian
distributed, with γ = 1 the discriminator loss Jdis is (approximately) proportional to the Wasser-
stein distance between loss distributions induced by the data distribution pD (X) and the generator
pθ(X). In practice it is beneficial to maintain the equilibrium γEpD [J (X)] = Epθ [J (X)] through
the optimisation procedure described in (34) that is motivated by proportional control theory. This
approach effectively stabilises training, however it suffers from catastrophic mode collapsing prob-
lem (see the left most panel in Figure 4). To address this issue, we simply subtract an entropy term
from the generator’s loss function, i.e.
Jgen(θ; ψ) = Jgen(θ; ψ) - αH[pθ],	(35)
where the rest of the optimisation objectives remains as in (34). This procedure would maintain
the equilibrium γEpD [J (X)] = Epθ [J (X)] - αH[p]. We approximate the gradient VθH[pθ] us-
ing the estimators presented in the main text. For the purpose of updating the control rate βt two
18
Published as a conference paper at ICLR 2018
strategies are considered to approximate the contribution of the entropy term. Given K samples
x1,…，Xk 〜pθ(x), The first proposal considers a plug-in estimate of the entropy term with a KDE
estimate of pθ (x), which is consistent with the KDE estimator but not necessary with the other
two (as they use kernels when representing logpθ(x) or Rx logpθ(x)). The second one uses a
proxy of the entropy loss -H[p] ≈ K? Pk=ι Rxk logpθ(xk)Txk with generated samples {xk} and
Rxk logpθ(xk) approximated by the gradient estimator in use.
In the experiment, we construct a deconvolutional net for the generator and a convolutional auto-
encoder for the discriminator. The convolutional encoder consists of 3 convolutional layers with
filter width 3, stride 2, and number of feature maps [32, 64, 64]. These convolutional layers are
followed by two fully connected layers with [512, 64] units. The decoder and the generative net have
a symmetric architecture but with stride convolutions replaced by deconvolutions. ReLU activation
function is used for all layers except the last layer of the generator, which uses sigmoid non-linearity.
The reconstruction loss in use is the squared '2 norm || ∙ ||2. The randomness po(z) is selected as
uniform distribution in [-1, 1] as suggested in the original paper (Berthelot et al., 2017). The mini-
batch size is set to K = 100. Learning rate is initialised at 0.0002 and decayed by 0.9 every 10
epochs, which is tuned on the KDE model. The selected γ and α values are: for KDE estimator
approach γ = 0.3, αγ = 0.05, for score matching estimator approach γ = 0.3, αγ = 0.1, and for
Stein approach γ = 0.5 and αγ = 0.3. The presented results use the KDE plug-in estimator for the
entropy estimates (used to tune β) for the KDE and score matching approaches. Initial experiments
found that for the Stein approach, using the KDE entropy estimator works slightly worse than the
proxy loss, thus we report results using the proxy loss. An advantage of using the proxy loss is
that it directly relates to the approximate gradient. Furthermore we empirically observe that the
performance of the Stein approach is much more robust to the selection of γ and α when compared
to the other two methods.
19