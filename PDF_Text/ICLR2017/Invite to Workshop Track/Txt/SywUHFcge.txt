Workshop track - ICLR 2017
A Theoretical Framework for Robustness of (Deep)
Clas sifiers Against Adversarial Examples
Beilun Wang, Ji Gao, Yanjun Qi
Department of Computer Science
University of Virginia
Charlottesville, VA 22901, USA
{bw4mw,jg6yd,yanjun}@virginia.edu
Ab stract
Most machine learning classifiers, including deep neural networks, are vulnerable
to adversarial examples. Such inputs are typically generated by adding small
but purposeful modifications that lead to incorrect outputs while imperceptible to
human eyes. The goal of this paper is not to introduce a single method, but to
make theoretical steps towards fully understanding adversarial examples. By using
concepts from topology, our theoretical analysis brings forth the key reasons why
an adversarial example can fool a classifier (f1) and adds its oracle (f2, like human
eyes) in such analysis. By investigating the topological relationship between two
(pseudo)metric spaces corresponding to predictor f1 and oracle f2 , we develop
necessary and sufficient conditions that can determine if f1 is always robust (strong-
robust) against adversarial examples according to f2 . Interestingly our theorems
indicate that just one unnecessary feature can make f1 not strong-robust, and the
right feature representation learning is the key to getting a classifier that is both
accurate and strong robust.
1 Introduction
Deep Neural Networks (DNNs) can efficiently learn highly accurate models and have been demon-
strated to perform exceptionally well (Krizhevsky et al., 2012; Hannun et al., 2014). However, recent
studies show that intelligent attackers can force many machine learning models, including DNNs, to
misclassify examples by adding small and hardly visible modifications on a regular test sample.
The maliciously generated inputs are called “adversarial examples” (Goodfellow et al., 2014; Szegedy
et al., 2013) and are commonly crafted by carefully searching small perturbations through an
optimization procedure. Several recent studies proposed algorithms for solving such optimization to
fool DNN classifiers. (Szegedy et al., 2013) firstly observe that convolution DNNs are vulnerable
to small artificial perturbations. They use box-constrained Limited-memory BFGS (L-BFGS) to
create adversarial examples and find that adversarial perturbations generated from one DNN network
can also force other networks to produce wrong outputs. Then, (Goodfellow et al., 2014) try to
clarify that the primary cause of such vulnerabilities may be the linear nature of DNNs. They then
propose the fast gradient sign method for generating adversarial examples quickly. Subsequent papers
(Fawzi et al., 2015; Papernot et al., 2015a; Nguyen et al., 2015) have explored other ways to explore
adversarial examples for DNN (details in Section 2.1). The goal of this paper is to analyze the
robustness of machine learning models in the face of adversarial examples.
In response to progress in generating adversarial examples, researchers attempt to design strategies for
making machine-learning systems robust to various noise, in the worst case as adversarial examples.
For instance, denoising NN architectures (Vincent et al., 2008; Gu & Rigazio, 2014; Jin et al., 2015)
can discover more robust features by using a noise-corrupted version of inputs as training samples.
A modified distillation strategy (Papernot et al., 2015b) is proposed to improve the robustness of
DNNs against adversarial examples, though it has been shown to be unsuccessful recently (Carlini &
Wagner, 2016a). The most generally successful strategy to date is adversarial training (Goodfellow
et al., 2014; Szegedy et al., 2013) which injects adversarial examples into training to improve the
generalization of DNN models. More recent techniques incorporate a smoothness penalty (Miyato
1
Workshop track - ICLR 2017
Table 1: A list of important notations used in the paper.
fl	A learned machine learning classifier fi = ci ◦ gi.
f2	The oracle for the same task (see Definition (2.1)) f2 = c2 ◦ g2.
gi	Part of fi including operations that progressively transform input into a new form of learned representations in X%.
Ci		Part of fi including simple decision functions (like linear) for classifying.
^X	InPUt SPaCe (e.g., {0,1,2,..., 255}32×32×3 for CIFAR-10 data (KrizhevSky & Hinton, 2009)).	
T	Output space (e.g., {1, 2,3,..., 10} for CIFAR-10 data (Krizhevsky & Hinton, 2009)).	
Xi	Feature space defined by the feature extraction module gi of predictor fi.
x2		Feature space defined by the feature extraction module g2 of oracle f2.
di(∙, ∙)	The metric function for measuring sample distances in feature space Xi with respect to predictor fi.
d2(∙, ∙)	The metric function for measuring sample distance in feature space X2 with respect to oracle f2.
	The Pseudometric function with respect to predictor fi, di(x,x0) = di(gi(x),gi(x0)).	
	The Pseudometric function with respect to oracle f2, d2(χ,χ0) = d2(g2(x),g2(x0)).	
a.e.	almost everywhere (Folland, 2013); (definedby Definition (9.2) in Section9.1)
3δ1,δ2,δ,η	small positive constants
et al., 2016; Zheng et al., 2016) or a layer-wise penalty (Carlini & Wagner, 2016b) as a regularization
term in the loss function to promote the smoothness of the DNN model distributions.
Recent studies (reviewed by (Papernot et al., 2016b)) are mostly empirical and provide little under-
standing of why an adversary can fool machine learning models with adversarial examples. Several
important questions have not been answered yet:
•	What makes a classifier always robust to adversarial examples?
•	Which parts of a classifier influence its robustness against adversarial examples more, compared
with the rest?
•	What is the relationship between a classifier’s generalization accuracy and its robustness against
adversarial examples?
•	Why (many) DNN classifiers are not robust against adversarial examples ? How to improve?
This paper tries to answer above questions and makes the following contributions:
•	Section 2 points out that previous definitions of adversarial examples for a classifier (f1 ) have
overlooked the importance of an oracle function (f2) of the same task.
•	Section 3 formally defines when a classifier f1 is always robust ("strong-robust") against adversarial
examples. It proves four theorems about sufficient and necessary conditions that make f1 always
robust against adversarial examples according to f2. Our theorems lead to a number of interesting
insights, like that the feature representation learning controls if a DNN is strong-robust or not.
•	Section 12 is dedicated to provide practical and theoretically grounded directions for understanding
and hardening DNN models against adversarial examples.
Table 1 provides a list of important notations we use in the paper.
2 Define Adversarial Examples
This section provides a general definition of adversarial examples , by including the notion of an
oracle. For a particular classification task, a learned classifier is represented as f1 : X → Y , where
X represents the input sample space and Y is the output space representing a categorical set.
2.1	Previous Formulations
Various definitions of “adversarial examples” exist in the recent literature, with most following
Eq. (2.1). See more detailed reviews in Section 8. The basic idea is to generate a misclassified sample
2
Workshop track - ICLR 2017
Machine-learning
classifier
Figure 1: Example of a machine-learning classifier (predictor) and a human annotator (oracle) for
classifying images of hand-written “0”. Both include two steps: feature extraction and classification.
The upper half is about the learned machine classifier f1 and the lower half is about the oracle f2 . f1
transforms samples from the original space X to an embedded metric space (X1, d1) using its feature
extraction step. Here, d1 is the similarity measure on the feature space X1 . Classification models
like DNN cover the feature extraction step in its model, though many other models like decision
tree need hard-crafted or domain-specific feature extraction. Then f1 can use a linear function to
decide the classification prediction yb ∈ Y . Similarly, human oracle f2 transforms data samples from
the original space X into an embedded metric space (X2 , d2) by its feature extraction. Here, d2 is
the corresponding similarity measure. Then the oracle get the classification result y ∈ Y using the
feature representation of samples (X2 , d2).
x0 by “slightly” perturbing a correctly classified sample x, with an adversarial perturbation ∆(x, x0).
Formally, when given x ∈ X
Find x0
s.t. f1 (x) 6= f1 (x0)	(2.1)
∆(x, x0) <
Here x, x0 ∈ X. ∆(x, x0) represents the difference between x and x0, which depends on the specific
data type that x and x0 belong to 1. Table 2 summarizes different choices of f1 and ∆(x, x0) used in
the recent literature, in which norm functions on the original space X are mostly used to calculate
∆(x, x0). Multiple algorithms have been implemented to solve Eq. (2.1) as a constrained optimization
(summarized by the last column of Table 2). More details are included for three such studies in
Section 8.2.
When searching for adversarial examples, one important property has not been fully captured by
Eq. (2.1). That is, an adversarial example has been modified very slightly from its seed and these
modifications can be so subtle that, for example in image classification, a human observer does not
even notice the modification at all. We define the role of “human observer” more formally as follows:
Definition 2.1. An “Oracle” represents a decision process generating ground truth labels for a task
of interest. Each oracle is task-specific, with finite knowledge and noise-free2.
1For example, in the case of strings, ∆(x, x0) represents the difference between two strings.
2We leave all detailed analysis of when an oracle contains noise as future work.
3
Workshop track - ICLR 2017
Figure 2: An example showing that f1 with one unnecessary feature (according to f2) is prone to
adversarial examples. The red circle denotes an adversarial example (e.g. generated by some attack
similar as JSMA (Papernot et al., 2015a) (details in Section 8.2)). Each adversarial example is very
close to its seed sample in the oracle feature space (according to d2), but it is comparatively far from
its seed sample in the feature space (according to d1 ) of the trained classifier and is at the different
side of the decision boundary of f1. Essentially “adversarial examples” can be easily found for all
seed samples in this Figure. We only draw cases for two seeds. Besides, for each seed sample, we
can generate a series of “adversarial examples” (by varying attacking power) after the attacking line
crosses the decision boundary of f1. We only show one case of such an adversarial example for each
seed sample.
Table 2: Summary of the previous studies defining adversarial examples.
Previous studies	f	∆(x, x )	Formulation of f (x) = f (x0)
(Goodfellow et al., 2014)=	Convolutional neural networks	'∞	argmax LossfI (x0), f (x)) x0
(SZegedy et al., 2013)	Convolutional neural networks	F	argmin Loss(fι(x0),l), subject to: l = fι(x0) 	X		
(Biggio et al.,2013)	Support vector machine (SVM)	F	argmin Loss(fι(x0), —1), subject to: fι(x) = 1 	X0		
(KantChelian et al., 2015)	Decision tree and Random forest	'2, '1, '∞	argmin Loss(fι(x0), —1), subject to: fι(x) = 1 X0
(PaPernot et al., 2016a)	Convolutional neural networks	'0	argmax LossfI(x0), fι (x)) 	X0		
(Grosse et al., 2016)	Convolutional neural networks	'0	argmax LossfI (x0), f (x)) X0
(Xu et al., 2016)	Random forest and SVM	'1, '∞	argmin Loss(fι(x0), —1), subject to: fι(x) = 1 X0	
The goal of machine learning is to train a learning-based predictor function f1 : X → Y to
approximate an oracle classifier f2 : X → Y for the same classification task. For example, in image
classification tasks, the oracle f2 is often a group of human annotators. Adding the notation of oracle,
we revise Eq. (2.1) into:
Find x0
s.t. f1 (x) 6= f1 (x0)
∆2(x, x0) <
f2(x) = f2(x0)
(2.2)
4
Workshop track - ICLR 2017
2.2	MEASURING SAMPLE DIFFERENCE IN WHICH SPACE? MODELING & DECOMPOSING f2
∆2 (x, x0) < reflects that adversarial examples add “small modifications” that are almost imper-
ceptible to oracle of the task. Clearly calculating ∆2(x, x0) needs to accord to oracle f2. For most
classification tasks, an oracle does not measure the sample difference in the original input space
X . We want to emphasize that sample difference is with regards to its classification purpose. For
instance, when labeling images for the hand-written digital recognition, human annotators do not
need to consider those background pixels to decide if an image is “0” or not.
Illustrated in Figure 1, we denote the feature space an oracle uses to consider difference among
samples for the purpose of classification decision as X2 . The sample difference uses a distance
function d2 in this space. An oracle function f2 : X → Y can be decomposed as f2 = c2 ◦ g2 where
g2 : X → X2 represents the operations for feature extraction from X to X2 and c2 : X2 → Y
denotes the simple operation of classification in X2 . Essentially g2 includes the operations that
(progressively) transform input representations into an informative form of representations X2 . c2
applies relatively simple functions (like linear) in X2 for the purpose of classification. d2 is the metric
function (details in Section 3) an oracle uses to measure the similarity among samples (by relying on
representations learned in the space X2). We illustrate the modeling and decomposition in Figure 1.
In Section 3 our theoretical analysis uses (X2, d2) to bring forth the fundamental causes of adversarial
examples and leads to a set of novel insights to understand such examples. To the best of the authors’
knowledge, the theoretical analysis made by this paper has not been uncovered by the literature.
Modeling Oracle f2: One may argue that it is hard to model f2 and (X2, d2) for real applications,
since if such oracles can be easily modeled machine-learning based f1 seems not necessary. In
Section 8.3, we provide examples of modeling oracles for real applications. For many security-
sensitive applications about machines, oracles f2 do exist 3. For artificial intelligence tasks like image
classification, humans are f2 . As illustrated by cognitive neuroscience papers (DiCarlo & Cox, 2007;
DiCarlo et al., 2012), human brains perform visual object recognition using the ventral visual stream,
and this stream is considered to be a progressive series of visual re-representations, from V1 to V2
to V4 to IT cortex (DiCarlo & Cox, 2007). Experimental results support that human visual system
makes classification decision at the final IT cortex layer. This process is captured exactly by our
decomposition f2 = c2 ◦ g2 .
2.3	Revised Formulation
Now we use the decomposition of f2 to rewrite ∆2 (x, x0) as d2 (g2 (x), g2 (x0)) in Eq. (2.2) and
obtain our proposed general definition of adversarial examples:
Definition 2.2. adversarial example: Suppose we have two functions f1 and f2. f1 : X → Y is the
classification function learned from a training set and f2 : X → Y is the classification function of the
oracle that generates ground-truth labels for the same task. Given a sample x ∈ X, an adversarial
example x0 ∈ X. (x, x0) satisfies Eq. (2.3).
Find x0
s.t. f1 (x) 6= f1 (x0)
d2(g2(x), g2(x0)) < δ2
f2(x) = f2(x0)
(2.3)
Most previous studies (Table 2) have made an important and implicit assumption about f2 (through
using ∆(x, x0) < ): f2 is almost everywhere (a.e.) continuous. We explains the a.e. continuity
assumption and its indication in Section 9. Basically, when f2 is assumed continuous a.e.,
P(f2(x) = f2(x0)|d2(g2(x),g2(x0)) < δ2) = 1
Therefore, when f2 is continuous a.e. Eq. (2.3) can be simplified into the following Eq. (2.4).
Find x0
s.t. f1 (x) 6= f1 (x0)	(2.4)
d2(g2(x), g2(x0)) < δ2
3Oracles f2 do exist in many security-sensitive applications about machines. But machine-learning classifiers
f1 are used popularly due to speed or efficiency
5
Workshop track - ICLR 2017
3 Define Strong-Robustness
With a more accurate definition of “adversarial examples”, now we aim to answer the first central
question: “What makes a classifier always robust against adversarial examples?”. Section 3.2
defines the concept “strong-robust” describing a classifier always robust against adversarial examples.
Section 3.3 and Section 3.4 present sufficient and necessary conditions for “strong-robustness”.
Section 4 then provides a set of theoretical insights to understand “strong-robustness”.
3.1	MODELING AND DECOMPOSING f1
As shown in Figure 1, we decompose f1 in a similar way as the decomposition of f2 . This is to
answer another key question: “which parts of a learned classifier influence its robustness against
adversarial examples more, compared with the rest?”. A machine-learning classifier f1 = c1 ◦ g1,
where g1 : X → X1 represents the feature extraction operations and c1 : X1 → Y performs a simple
operation (e.g., linear) of classification. Section 8.4 provides multiple examples of decomposing
state-of-the-art f1 4. d1 denotes the distance function f1 uses to measure difference among samples
in X1 .
Almost all popular machine learning classifiers satisfy the a.e. continuity assumption. It means:
P(f1(x) = f1 (x0)|d1 (g1 (x), g1 (x0)) < δ1) = 1
When f1 is not continuous a.e., it is not robust to any types of noise. See Section 9 for detailed
discussions.
For the rare cases that f1 is not continuous a.e., Section 11 discusses "boundary points" of f1 5.
Roughly speaking, when f1 is not continuous a.e., 6
P(f1(x) 6= f1 (x0)|d1 (g1 (x), g1 (x0)) < δ1) > 0
Therefore the following probability of “boundary points based adversarial examples” might not be 0
for such cases 7:
P(f1(x) 6=f1(x0)|f2(x) =f2(x0),
I
d1 (g1 (x), g1 (x0)) < δ1, d2(g2(x),g2(x0)) < δ2)
The value of this probability is critical for our analysis in Theorem (3.3) and in Theorem (3.5).
(3.1)
3.2	{δ2, η}-STRONG-ROBUST AGAINST ADVERSARIAL EXAMPLES
We then apply reverse-thinking on Definition (2.2) and derive the following definition of strong-
robustness for a machine learning classifier against adversarial examples:
Definition 3.1. {δ2 , η}-Strong-robustness of a machine-learning classifier: A machine-learning
classifier fι(∙) is {δ2,η}-strong-robust against adversarial examples if: ∀x,x0 ∈ X a.e., (x,x0)
satisfies Eq. (3.2).
∀x, x0 ∈ X
P(f1(x) = f1(x0)|f2(x) = f2(x0),	(3.2)
d2(g2 (x), g2 (x0)) < δ2) > 1 - η
When f2 is continuous a.e., Eq. (3.2) simplifies into Eq. (3.3):
∀x, x0 ∈ X, P(f1(x) = f1(x0)|
d2(g2 (x), g2 (x0)) < δ2) > 1 - η
(3.3)
Eq.(3.2) defines the “{62, n}-strong-robustness” as a claim with the high probability. To simplify
notations, in the rest of this paper, We use “strong-robust” representing ''{δ2,η}-strong-robust'”. Also
in the rest of this paper we propose and prove theorems and corollaries by using its more general
form by Eq. (3.2). For all cases, if f2 is continuous a.e., all proofs and equations can be simplified
by using only the term d2 (g2 (x), g2 (x0)) < δ2 (i.e. removing the term f2 (x) = f2 (x0)) according to
Eq. (3.3)).
The “strong-robustness” definition leads to four important theorems in next two subsections.
4Notice that g1 may also include implicit feature selection steps like `1 regularization.
5Boundary points are those points satisfying f1 (x) 6= f1 (x0) and d1 (g1 (x), g1(x0)) < δ1)
6When f1 is continuous a.e., P(f1 (x) 6= f1 (x0)|d1 (g1 (x), g1 (x0)) < δ1) = 0.
7“Boundary points based adversarial examples” only attack seed samples who are boundary points of f1 .
6
Workshop track - ICLR 2017
3.3	TOPOLOGICAL EQUIVALENCE OF TWO METRIC SPACES (X1, d1) AND (X2, d2) IS
Sufficient in Determining Strong-robustness
In the appendix, Section 10.1 briefly introduces the concept of metric space and the definition of
topological equivalence among two metric spaces. As shown in Figure 1, here f1 defines a metric
space (X1, d1) on X1 with the metric function d1. Similarly f2 defines a metric space (X2, d2) on
X2 with the metric function d2 .
If the topological equivalence ( Eq. (10.1)) exists between (X1, d1) and (X2, d2), it means that for
all pair of samples from X , we have the following relationship:
∀x, x0 ∈ X,
d1(g1(x),g1(x0)) < δ1 ⇔ d2(g2(x),g2(x0)) < δ2
(3.4)
When f1 is continuous a.e., this can get us the following important theorem, indicating that the
topological equivalence between (X1, d1) and (X2, d2) is a sufficient condition in determining
whether or not f1 is strong-robust against adversarial examples:
Theorem 3.2. When f1 is continuous a.e., if (X1, d1) and (X2, d2) are topologically equivalent,
then the learned classifier fι(∙) is strong-robust to adversarial examples.
Proof. See its proofs in Section 10.3.4
□
This theorem can actually guarantee that:
∀x, x0 ∈ X,
P(f1(x) = f1(x0)|f2(x) = f2(x0),	(3.5)
d2 (g2 (x), g2 (x0)) < δ2) = 1
Clearly Eq. (3.5) is a special (stronger) case of the “strong-robustness” defined by Eq. (3.2).
For more general cases including f1 might not be continuous a.e., we need to consider the probability
of the boundary point attacks (Eq. (3.1)). Therefore, we get a more general theorem as follows:
Theorem 3.3. If (X1, d1) and (X2, d2) are topologically equivalent and P(f1(x) 6= f1 (x0)|f2 (x) =
f2(x0),d1(g1(x),g1(x0)) < δι,d2(g2(x),g2(x0)) < δ2) < η, then the learned classifier fι(∙) is
strong-robust to adversarial examples.
Proof. See its proofs in Section 10.3.3.
□
3.4 FINER TOPOLOGY OF (X, d01) THAN (X, d02) IS S UFFICIENT AND NECESSARY IN
Determining Strong-robustness
Now we extend the discussion from two metric spaces into two pseudometric spaces. This extension
finds the sufficient and necessary condition that determines the strong-robustness of f1 . The related
two pseudometrics are d01 (for f1) and d02 (for f2), both directly being defined on X. Appendix Sec-
tion 10.2 includes detailed descriptions of pseudometric, pseudometric spaces, topology and a finer
topology relationship between two pseudometric spaces.
Essentially, the topology in pseudometric space (X, d01)) is a finer topology than the topology in
pseudometric space (X, d02 ) means:
∀x, x0 ∈ X, d02 (x, x0) < δ2 ⇒ d01 (x, x0) < δ1	(3.6)
Because d01(x, x0) = d1(g1(x), g1(x0)) and d02(x, x0) = d2(g2(x), g2(x0)), the above equation equals
to:
∀x, x0 ∈ X,
d2(g2(x),g2(x0)) < δ2 ⇒ d1(g1(x), g1(x0)) < δ1
(3.7)
Using Eq. (3.7) and the continuity a.e. assumption, we can derive the following Theorem about the
sufficient and necessary condition for f1 being strong-robust:
Theorem 3.4.	When f1 is continuous a.e., f1 is strong-robust against adversarial examples if and
only if the topology in (X, d01) is a finer topology than the topology in (X, d02).
Proof. See its proof in appendix Section 10.3.1.
□
7
Workshop track - ICLR 2017
Table 3: Summary of theoretical conclusions that we can derive. Here X1 = Rn1 and X2 = Rn2 .
The strong-robustness is determined by feature extraction function g1. The accuracy is determined by
both the classification function c1 and the feature extraction function g1 .
	Cases:	di &d2 are norms	Can be accurate?	Based on	Illustration
	Xi \ (Xi T X2) = 0, X2 ⊂ Xi		Not Strong-robust	may not be accurate	Theorem (3.4)	Figure 2
~(sΓ	ni > n2,X2 ( Xi	Not strong-robust	may be accurate	Corollary (4.1)	Figure 2
~W	ni = n2,Xi = X2	Strong-robust	may be accurate	Corollary (4.2)	Figure 4
"w~	ni <n2,Xi CΓ"	Strong-robust	may not be accurate	Theorem (3.4)	Figure 5
Actually the above theorem can guarantee that when f1 is continuous a.e.:
∀x, x0 ∈ X, P(f1(x) = f1 (x0)|d2 (g2 (x), g2 (x0)) < δ2) = 1	(3.8)
Eq. (3.8) clearly is a special (stronger) case of strong-robustness defined by Eq. (3.2).
When f1 is not continuous a.e., we need to consider the probability of the boundary points based
adversarial examples (Eq. (3.1)). For such a case, we get a sufficient condition 8 for the strong-
robustness:
Theorem 3.5.	When f1 is not continuous a.e., if the topology in (X, d01)) is a finer topol-
ogy than the topology in (X, d02) and P(f1(x) 6= f1(x0)|f2(x) = f2(x0), d1 (g1 (x), g1 (x0)) <
δ1, d2(g2(x), g2(x0)) < δ2) < η, then f1 is strong-robust against adversarial examples.
When f1 is not continuous a.e., its strong-robustness is significantly influenced by its boundary points
and therefore relates to the c1 function. Section 11.2 provides some discussion and we omit covering
such cases in the rest of this paper.
4	Towards Principled Understanding
The four theorems proposed above lead to a set of key insights about why and how an adversarial can
fool a machine-learning classifier using adversarial examples. One of the most valuable insights is:
feature learning step decides whether a predictor is strong-robust or not in an adversarial test setting.
All the discussions in the subsection assume f1 is continuous a.e..
4.1	Unnecessary Features Ruin Strong-robustness
Theorem (3.2) and Theorem (3.4) indicate that when f1 is continuous a.e., the two feature spaces
(X1 , d1) and (X2, d2) or the functions g1 and g2 determine the strong-robustness of f1. Based on
Theorem (3.4), we can derive a corollary as follows (proof in Section 10.3.1):
Corollary 4.1. When f1 is continuous a.e., if X1 = Rn1, X2 = Rn2, n1 > n2, X2 ( X1, d1, d2
are norm functions, then fι(∙) is not strong-robust against adversarial examples.
This corollary shows if unnecessary features (with regards to X2) are selected in the feature selection
step, then no matter how accurate the model is trained, it is not strong-robust to adversarial examples.
Figure 2 shows a situation that the oracle for the current task only needs to use one feature to classify
samples correctly. A machine learning classifier extracts two features with one used by the oracle
and the other is an extra unnecessary feature 9. In X1 , f1 (actually c1 ) successfully classifies all the
test inputs. However, it’s very easy to find adversary examples satisfying Eq. (2.4) by only adding a
small perturbation along the unnecessary feature dimension. In Figure 2, red circles show a few such
adversarial examples. The adversarial examples are very close to seed samples in the oracle space.
But they are predicted into a different class by f1.
For many security sensitive applications, previous studies using state-of-art learning-based classifiers
normally believe that adding more features is always helpful. Apparently, our corollary indicates that
8When f1 is not continuous a.e., it is difficult to find the necessary and sufficient condition for strong-
robustness of f1 . We leave this to future research.
9Two features of X1 actually positively correlate in Figure 2. However, the oracle does not need to use the
second feature for making classification decision
8
Workshop track - ICLR 2017
this thinking is wrong and can lead to their classifiers vulnerable to adversarial examples(Xu et al.,
2016).
As another example, multiple DNN studies about adversarial examples claim that adversarial examples
are transferable among different DNN models. This can be explained by Figure 2 (when X1 is a
much higher-dimensional space). Since different DNN models learn over-complete feature spaces
{X1 }, there is a high chance that these different X1 involve a similar set of unnecessary features
(e.g., the different learned features are correlated with others). Therefore the adversarial examples are
generated along similar gradient directions. That is why many such samples can evade multiple DNN
models.
4.2	Feature Space More Important than Norm
Using Theorem (3.3), we obtain another corollary as follows (proof in Section 10.3.1):
Corollary 4.2. When f1 is continuous a.e., if di and d2 are norms and Xi = X2 = Rn, then fι(∙)
is strong-robust to adversarial examples.
This corollary shows that if a learned classifier and its oracle share the same derived feature space
(Xi = X2), the learned classifier is strong-robust when two metrics are both norm functions (even if
not the same norm). We can call this corollary as “norm doesn’t matter”.
Many interesting phenomena can be answered by Corollary (4.2). For instance, for a norm regularized
classifier, this corollary answers an important question that whether a different norm function will
influence its robustness against adversarial examples. The corollary indicates that changing to a
different norm function may not improve the robustness of the model under adversarial perturbation.
Summarizing Theorem (3.2), Theorem (3.4), Corollary (4.2) and Corollary (4.1), the robustness of a
learned classifier is decided by two factors: (1) the difference between two derived feature spaces;
and (2) the difference between the metric functions. Two corollaries show that the difference between
the feature spaces is more important than the difference between the two metric functions.
4.3	Robustness and Generalization
In Table 3, we provide four situations in which the proposed theorems can be used to determine
whether a classifier fi is strong-robust against adversarial examples or not.
•	Case (I): If fi uses some unnecessary features, it will not be strong-robust to adversarial examples.
It may not be an accurate predictor if fi misses some necessary features used by f2 .
•	Case (II): If fi uses some unnecessary features, it will not be strong-robust to adversarial examples.
It may be an accurate predictor if fi uses all the features used by f2 .
•	Case (III): If fi and f2 use the same set of features and nothing else, fi is strong-robust and may
be accurate.
•	Case (IV): If fi misses some necessary features and does not extract unnecessary features, fi is
strong-robust (even tough its accuracy may not be good).
Table 3 provides a much better understanding of the relationship between robustness and accuracy.
Two interesting cases from Table 3 are worth to emphasize again: (1) If fi misses features used by
f2 and does not include unnecessary features (according to X2), fi is strong-robust (even though it
may not be accurate). (2) If fi extracts some extra unnecessary features, it will not be strong-robust
(though it may be a very accurate predictor).
We want to emphasize that “fi is strong-robust” does not mean it is a good classifier. For example, a
trivial example for strong-robust models is fi(x) ≡ 1, ∀x ∈ X. However, it is a useless model since
it doesn’t have any prediction power. In an adversarial setting, we should aim to get a classifier that is
both strong-robust and precise. A better feature learning function gi is exactly the solution that may
achieve both goals.
Table 3 indicates that ci and c2 do not influence the strong-robustness of fi when fi is continuous
a.e. 10. Figure 4 and Figure 5 further show two concrete example cases in which fi is strong-robust
according to f2 . However, in both figures, fi is not accurate according to f2 .
10When f1 is not continuous a.e., c1 matters for the strong-robustness. See Section 11 for details.
9
Workshop track - ICLR 2017
Table 4: Connecting to relevant DNN hardening solutions. The experimental results of comparing
different hardening solutions are shown in Figure 9, Figure 10, Table 10 and Table 11.
	x0	Loss Lf 1 (x, x0)	On Layer
Stability training (Zheng et al.,2016)	random perturbation	KL(∕1(x),∕1(x0T=	Classification layer
(MiyatO et al., 2016)	adversarial perturbation	KLfI(X) fι(x>TT~	Classification layer
Adversarial	train- ing(Goodfellow et al., 2014)	adversarial perturbation	L(fι(x), f2(x))	Loss function
Large Adversarial train- ing(Kurakin et al., 2016)	adversarial perturbation	L(f1(x0),f2(x))	Loss function
(Lee et al.,2015)	adversarial perturbation	k g1 (X)- g1(XO) l∣2	Layer before classification layer
Siamese Training	random perturbation	k g1 (X)- g1(XO) k2	Layer before classification layer
5	Towards Principled Solutions for DNNs
Our theoretical analysis uncovers fundamental properties to explain the adversarial examples. In this
section, we apply them to analyze DNN classifiers. More specifically, (1) we find that DNNs are not
strong-robust against adversarial examples; and (ii) we connect to possible hardening solutions and
introduce principled understanding of these solutions.
5.1	Are State-of-the-Art DNNs Strong-Robust?
For DNN, it is difficult to derive a precise analytic form of d1 (or d01 ). But we can observe some
properties of d1 through experimental results. Table 5,Table 6,Table 7 and Table 8 show properties of
d1 (and d01 ) resulting from performing testing experiments on four state-of-art DNN networks (details
in Section 12.1). All four tables indicate that the accuracy of DNN models in the adversarial setting
are quite bad. The performance on randomly perturbed inputs is much better than performance on
maliciously perturbed adversarial examples.
The phenomenon we observed can be explained by Figure 3. Comparing the second column and
the third column in four tables we can conclude that d1 (and d01 ) in a random direction is larger
than d1 (and d01) in the adversarial direction. This indicates that a round sphere in (X1, d1) (and
(X, d1)) corresponds to a very thin high-dimensional ellipsoid in (X, ∣∣∙∣∣) (illustrated by the left half
of Figure 3). Figure 3 (I) shows a sphere in (X, d01 ) and Figure 3 (III) shows a sphere in (X1 , d1 ).
They correspond to the very thin high-dimensional ellipsoid in (X, ∣∣∙∣∣) in Figure 3 (V). The norm
function ∣∣∙∣∣ is defined in space X and is application-dependent. All four tables uses ∣∣∙∣∣ = ∣∣∙∣∣∞.
Differently, for human oracles, a sphere in (X, d02) (shown in Figure 3 (II)) or in (X2, d2) (shown
in Figure 3 (IV)) corresponds to an ellipsoid in (X, ∣∣∙∣∣) not including very-thin directions (shown
in Figure 3 (VI)). When the attackers try to minimize the perturbation size using the approximated
distance function d2 = ∣∣∙∣∣, the thin direction of ellipsoid in Figure 3 (V) is exactly the adversarial
direction.
5.2	Towards Principled Solutions
Our theorems suggest a list of possible solutions that may improve the robustness of DNN classifiers
against adversarial samples. Options include such as:
By learning a better g1: Methods like DNNs directly learn the feature extraction function g1. Table 4
summarizes multiple hardening solutions (Zheng et al., 2016; Miyato et al., 2016; Lee et al., 2015)
in the DNN literature. They mostly aim to learn a better g1 by minimizing different loss functions
Lfι (x, χ0) so that when d2(g2(χ), g2(χ0)) < E (approximated by (X, || ∙ ||)), this loss Lf (x, χ0) is
small. Two major variations exist among related methods: the choice of Lf1 (x, x0) and the way
to generate pairs of (x, x0). For instance, to reach the strong-robustness we can force to learn a g1
that helps (X, d01) to be a finer topology than (X2, d02). Section 12.4 explores this option (“Siamese
training” in Table 4) through Siamese architecture. Experimentally Section 12.5 compares adversarial
training, stability training and Siamese training on two state-of-the-art DNN image-classification
10
Workshop track - ICLR 2017
(X4')
(X,d∕)
Not a FinerT
d2'(μ, b) Sm5ll∙---- /
(XL d])
(X2, d2)
NotTopoIogicaI
O
d1(^a,b) Large
∣v □ □
□
Equivalent，
Λ∏)
11 □π
9 0	∖
AUman oracle
>po∣ogy ⅞)	、
,入C `
Clbse	1
` O AUman oracle
Figure 3: This figure shows one situation that (X, d01) is not a finer topology than (X, d02) (therefore,
(X1, d1) and (X2, d2) are not topologically equivalent). According to Theorem (3.4), in this case, the
DNN is vulnerable to adversarial examples. The two sample points a and b are close with regards to
(w.r.t.) a norm || ∙ || in X. They are also close w.r.t. d2 in (X2 ,d2) space and close w.r.t. d2 in (X, d2)
space. But they are far from each other in the space of (X, d01) and in the space of (X1, d1). In other
words, while d2(a, b), d02(a, b) and ||a - b|| are small, d1(a, b) and d01(a, b) are large. Clearly, DNN
can be easily evaded by adding a small perturbation k a - b k on sample a or sample b. NOTE: it is
normally difficult to get the analytic form of (X2, d2) for most applications. Most previous studies
(reviewed in Section 2.2) assume (X2, d2) equals to (X, || ∙ ||), where || ∙ || is a norm function.
；Deep Neural Nets
；Deep Neural Nets
d2(af ð) sm≡ιt1 .------
tasks through performance against adversarial samples (details in Section 12.5). The hardening
effects of these strategies vary from task to task, however, they all improve the base DNN models’
performance in the adversarial setting.
By modifying unnecessary features: As shown by Table 3, unnecessary features ruin the strong-
robustness of learning-based classifiers. A simple way to remove the unrelated features is to identify
which feature is unnecessary. In (Gao et al., 2017) the authors compare the difference between
g1(x0) and g1(x) from DNN. They hypothesize that those learned DNN feature dimensions (in X1)
changing rapidly are utilized by an adversary, and thus can be removed to improve the robustness
of DNN model. Another efficient method is to substitute different values of features into several
equivalent classes. By this way, the adversarial perturbation in the unnecessary feature dimensions
can be squeezed by projecting into the same equivalent class. A recent study (Li & Vorobeychik,
2014) explored a similar strategy by using equivalent-feature-group to replace each word feature in a
group, in order to improve the robustness of spam-email classifiers against evasion attacks.
11
Workshop track - ICLR 2017
6	Conclusion
Adversarial examples are maliciously created inputs that lead a learning-based classifier to produce
incorrect output labels. An adversarial example is often generated by adding small perturbations
that appear unmodified to human observers. Recent studies that tried to analyze classifiers under
adversarial examples are mostly empirical and provide little understanding of why. To fill the gap, we
propose a theoretical framework for analyzing machine learning classifiers, especially deep neural
networks (DNN) against such examples. This paper is divided into three parts. The first section
provides a revised definition of adversarial examples by taking into account of the oracle of the task.
The second section defines strong-robustness and provides the principled understanding of what
makes a classifier strong-robust. The third section examines practical and theoretically grounded
directions for understanding and hardening DNN models against adversarial examples. Future steps
will include an empirical comparison to analyze recent literature using our theorems.
7	Related Works in a B roader Context
Investigating the behavior of machine learning systems in adversarial environments is an emerging
topic (Huang et al., 2011; Barreno et al., 2006; 2010; Globerson & Roweis, 2006; Biggio et al.,
2013; Kantchelian et al., 2015; Zhang et al., 2015). Recent studies can be roughly categorized
into three types: (1) Poisoning attacks in which specially crafted attack points are injected into the
training data. Multiple recent papers (Alfeld et al., 2016; Mei & Zhu, 2015b; Biggio et al., 2014;
2012; Mei & Zhu, 2015a) have considered the problem of an adversary being able to pollute the
training data with the goal of influencing learning systems including support vector machines (SVM),
autoregressive models and topic models. (2) Evasion attacks are attacks in which the adversary’s
goal is to create inputs that are misclassified by a deployed target classifier. Related studies (Szegedy
et al., 2013; Goodfellow et al., 2014; Xu et al., 2016; Kantchelian et al., 2015; Rndic & Laskov, 2014;
Biggio et al., 2013; Papernot et al., 2016b; Sinha et al., 2016) assume the adversary does not have
an opportunity to influence the training data, but instead finds “adversarial examples” to evade a
trained classifier like DNN, SVM or random forest. (3) Privacy-aware machine learning (Duchi et al.,
2014) is another important category relevant to data security in machine learning systems. Recent
studies have proposed various strategies (Xie et al., 2014; Bojarski et al., 2014; Stoddard et al., 2014;
Li & Zhou, 2015; Rajkumar & Agarwal, 2012; Dwork, 2011; Nock et al., 2015) to preserve the
privacy of data such as differential privacy. This paper focuses on evasion attacks that are mostly
used to attacking classifiers that try to distinguish malicious behaviors from benign behaviors. Here
We extend it to a broader meaning - adversarial manipulation of test samples. Evasion attacks may be
encountered during system deployment of machine learning methods in adversarial settings.
In the broader secure machine learning field, researchers also make attempts for hardening learning
systems. For instance: (1) (Barreno et al., 2010) and (Biggio et al., 2008) propose a method to
introduce some randomness in the selection of classification boundaries; (2) A feW recent studies
(Xiao et al., 2015; Zhang et al., 2015) consider the impact of using reduced feature sets on classifiers
under adversarial attacks. (Xiao et al., 2015) proposes an adversary-aWare feature selection model that
can improve a classifier’s robustness against adversarial attacks by incorporating specific assumptions
about the adversary’s data manipulation strategy. (3) Another line of Works, named as adversarial
training (GoodfelloW et al., 2014), designs a neW loss function for training neural netWorks, Which is a
linear interpolation of the loss function of the original sample and the loss function of the adversarial
example generated by the original sample. A scalable version of adversarial training (Kurakin et al.,
2016) Was recently proposed. By applying several tricks, the author can apply the adversarial training
to deeper netWork trained by the imagenet dataset. (4) Multiple studies model adversarial scenarios
With formal frameWorks representing the interaction betWeen the classifier and the adversary. Related
efforts include perfect information assumptions (Dalvi et al., 2004), assuming a polynomial number of
membership queries (LoWd & Meek, 2005), formalizing the attack process as a tWo-person sequential
Stackelberg game (Bruckner & Scheffer, 2011; Liu & Chawla, 2010), a min-max strategy (training
a classifier With best performance under the Worst perturbation) (Dekel et al., 2010; Globerson &
Roweis, 2006), exploring online and non-stationary learning (Dahlhaus, 1997; Cesa-Bianchi &
Lugosi, 2006), and formalizing as an adversarial reinforcement learning problem (Uther & Veloso,
1997). (5) A PAC model study about learning adversary behavior in a security games also investigated
the solution of computing the best defender strategy against the learned adversary behavior. It has a
12
Workshop track - ICLR 2017
similar conclusion as ours ( Section 3) that the extreme cases that the defender doesn’t work only has
zero probability (Sinha et al., 2016).
Figure 4: An example figure illustrating Table 3 Case (III) when f1 is strong-robust. We assume
c1 and c2 as linear classification functions. We show one case of X1 = X2 = R2 and f1, f2 are
continuous a.e.. In terms of classification, f1 (green boundary line) is not accurate according to f2
(red boundary line). All pairs of test samples (x, x0) can be categorized into the three cases shown in
this figure. Test-case (a): f1 and f2 assign the same classification label (yellow circle) on x and x0 . x
and x0 are predicted as the same class by both. Test-case (b): f1 assigns the class of “blue square” on
both x and x0 . f2 assigns the class of “yellow circle” on both x and x0 . Test-case (c): f2 assigns the
class of “yellow circle” on both x and x0 . However, f1 assigns the class of “blue square” on x and
assigns a different class of “yellow circle” on x0. This case has been explained in Section 11.
13
Workshop track - ICLR 2017
Figure 5: An example figure illustrating Table 3 Case (IV) when f1 is strong-robust. We assume c1
and c2 as linear classification functions. We show one case of 1 = n1 < n2 = 2, X1 ⊂ X2 and f1,
f2 are continuous a.e.. In terms of classification, f1 (green boundary line) is not accurate according to
f2 (red boundary line). All pairs of test samples (x, x0) can be categorized into the three cases shown
in this figure. Test-case (a): f1 and f2 assign the same classification label (yellow circle) on x and x0 .
x and x0 are predicted as the same class by both. Test-case (b): f1 assigns the class of “yellow circle”
on both x and x0 . f2 assigns the class of “blue square” on both x and x0 . Test-case (c): f2 assigns the
class of “yellow circle” on both x and x0 . However, f1 assigns the class of “blue square” on x and
assigns a different class of “yellow circle” on x0. This case can be explained in Section 11.
8	Formulation of Adversarial Examples
8.1	More about Previous Definitions of adversarial examples
For the purpose of "fooling" a classifier, naturally, the attacker wants to control the size of the
perturbation ∆(x, x0) to ensure the perturbed sample x0 still stays close enough to the original sample
14
Workshop track - ICLR 2017
x to satisfy the intended "fooling" purpose. For example, in the image classification case, Eq. (2.1)
can use the gradient information to find a ∆(x, x0) that makes human annotators still recognize x0 as
almost the same as x, though the classifier will predict x0 into a different class. In another example
with more obvious security implications about PDF malware (Xu et al., 2016), x0 in Eq. (2.1) is found
by genetic programming. A modified PDF file from a malicious PDF seed will still be recognized as
malicious by an oracle machine (i.e., a virtual machine decides if a PDF file is malicious or not by
actually running it), but are classified as benign by state-of-art machine learning classifiers (Xu et al.,
2016).
The following Eq. (8.1) has been popular as well. Eq. (8.1) is a special case of Eq. (2.1).
argmin ∆(x, x0)
x0∈X	(8.1)
Subject to: f1 (x) 6= f1 (x0)
Eq. (8.1) tries to find the x0 by minimizing ∆(x, x0) under some constraints. Eq. (2.1) is a more
general formulation than Eq. (8.1) and can summarize most relevant studies. For example, in (Xu
et al., 2016) "adversarial examples" are those generated PDFs that can fool PDFRate (a learning-based
classifier for detecting malicious PDFs) to classify them as benign. The distances of these variant
PDFs to the seed PDF are not necessarily minimal. For such cases, Eq. (2.1) still fits, while Eq. (8.1)
does not.
Besides, in the field of computer security, machine learning has been popular in classifying the
malicious (y = 1) behavior versus benign behavior (y = -1). For such a context, two different
definitions of adversarial examples exist in the literature:
For instance, (Biggio et al., 2013) uses a formula as follows:
argmin(f1(x0))
x0
s.t. ∆(x, x0) < dmax	(8.2)
f1(x) > 0
Differently, (Lowd & Meek, 2005) uses the following formula:
argmin(∆(x, x0))
x0
s.t. f1(x0) < 0	(8.3)
f1 (x) > 0
Here dmax is a small positive constant. These definitions of “adversarial examples” are special cases
of Eq. (8.1) and Eq. (2.1).
8.2	Background: Previous Algorithms Generating “adversarial examples”
To fool classifiers at test time, several approaches have been implemented to generate “adversarial
perturbations” by solving Eq. (2.2). According to Eq. (2.2), an adversarial example should be able
to change the classification result f1(x), which is a discrete value. To solve Eq. (2.2), we need to
transform the constraint f1(x) 6= f1(x0) into an optimizable formulation. Then we can easily use the
Lagrangian multiplier to solve Eq. (2.2). All the previous studies define a loss function Loss(∙, ∙) to
quantify the constraint f1(x) 6= f1(x0). This loss function can be the same with the training loss, or
it can be chosen differently, such as hinge loss or cross entropy loss.
We summarize four common attacking studies as follows:
Gradient ascent method (Biggio et al., 2013) Machine learning has been popular in classifying
malicious (y = 1) versus benign (y = -1) in computer security tasks. For such contexts, a simple
way to solve Eq. (2.2) is through gradient ascent. To minimize the size of the perturbation and
maximize the adversarial effect, the perturbation should follow the gradient direction (i.e., the
direction providing the largest increase of function value, here from y = -1 to 1). Therefore, the
perturbation r in each iteration is calculated as:
r = eNχLoss(fι(x + r), —1) Subject to: fι(x) = 1	(8.4)
By varying , this method can find a sample x0 with regard to d2(x, x0) such that f1(x) 6= f1(x0).
15
Workshop track - ICLR 2017
Box L-BFGS adversary (Szegedy et al., 2013) This study views the adversarial problem as a
constrained optimization problem, i.e., find a minimum perturbation in the restricted sample space.
The perturbation is obtained by using Box-constrained L-BFGS to solve the following equation:
argmin(c ×	d2(x,	x +	r)	+ Loss(f1(x +	r),	l)),	x + r ∈	[0, 1]p	(8.5)
r
Here p is the total number of features, c is a term added for the Lagrange multiplier. (for an image
classification task, it is 3 times the total number of pixels of an RGB image) l is a target label, which
is different from the original label. The constraint x + r ∈ [0, 1]p means that the adversarial example
is still in the range of sample space.
Fast gradient sign method (Goodfellow et al., 2014) The fast gradient sign method proposed
by (Goodfellow et al., 2014) views d2 as the '∞-norm. In this case, a natural choice is to make the
attack strength at every feature dimension the same. The perturbation is obtained by solving the
following equation:
argmin(c × d2(x, x + r) - Loss(f1(x + r), f1(x))), x + r ∈ [0, 1]p	(8.6)
r
Therefore the perturbation can be calculated directly by:
r = eSign(VzLoss(fι(z), fι(x)))	(8.7)
Here the loss function is the function used to train the neural network. A recent paper (Kurakin et al.,
2016) shows that adversarial examples generated by fast gradient sign method are misclassified even
after these images have been recaptured by cameras.
Jacobian-based saliency map approach (Papernot et al., 2015a) (Papernot et al., 2015a) pro-
posed the Jacobian-based saliency map approach (JSMA) to search for adversarial samples while
limiting the number of pixel to modify in the image. As a targeted attack, JSMA iteratively per-
turbs pixels in an input that have large adversarial saliency scores. The adversarial saliency map
is calculated from the Jacobian (gradient) matrix Vxf1(x) of the DNN model at the current input
x. The (i, j)th component in Jacobian matrix Vxf1(x) describes the derivative of output class j
with respect to feature pixel i. For each pixel i, its adversarial saliency score is calculated to reflect
how this pixel will increase the output score of class j versus changing the score of other possible
output classes. The process is repeated until misclassification in the target class is achieved or the
maximum number of perturbed pixels has been reached. Essentially, JSMA optimizes Equation 2.1
by measuring perturbation ∆(x, x0) through the 'o-norm.
8.3	MORE ABOUT MODELING ORACLE f2
Though difficult, we want to argue that it is possible to theoretically model "oracles" for some
state-of-the-art applications. For instance, as illustrated by the seminal cognitive neuroscience
paper "untangling invariant object recognition" (DiCarlo & Cox, 2007) and its follow-up study
(DiCarlo et al., 2012), the authors show that one can view the information processing of visual object
recognition by human brains as the process of finding operations that progressively transform retinal
representations into a new form of representation (X2 in this paper), followed by the application of
relatively simple decision functions (e.g., linear classifiers (Duda et al., 2012)). More specifically,
in human and other primates, such visual recognition takes place along the ventral visual stream,
and this stream is considered to be a progressive series of visual re-representations, from V1 to
V2 to V4 to IT cortex (DiCarlo & Cox, 2007). Multiple relevant studies (e.g., (DiCarlo & Cox,
2007; Johnson, 1980; Hung et al., 2005)) have argued that this viewpoint of representation learning
plus simple decision function is more productive than hypothesizing that brains directly learn very
complex decision functions (highly non-linear) that operate on the retinal image representation. This
is because the experimental evidence suggests that this view takes the problem apart in a way that is
consistent with the architecture and response properties of the ventral visual stream. Besides, simple
decision functions can be easily implemented in a single step of biologically plausible neuronal
processing (i.e., a thresholded sum over weighted synapses).
As another example, the authors of (Xu et al., 2016) used genetic programming to find “adversarial
examples” (by solving Eq. (2.2)) for a learning-based malicious-PDF classifier. This search needs an
oracle to determine if a variant x0 preserves the malicious behavior of a seed PDF x (i.e., f2 (x) =
f2(x0)). The authors of (Xu et al., 2016) therefore used the Cuckoo sandbox (a malware analysis
system through actual execution) to run a variant PDF sample in a virtual machine installed with a
PDF reader and reported the behavior of the sample including network APIs calls. By comparing the
16
Workshop track - ICLR 2017
behavioral signature of the original PDF malware and the manipulated variant, this oracle successfully
determines if the malicious behavior is preserved from x to x0. One may argue that "since Cuckoo
sandbox works well for PDF-malware identification, why a machine-learning based detection system
is even necessary?". This is because Cuckoo sandbox is computationally expensive and runs slow.
For many security-sensitive applications about machines, oracles f2 do exist, but machine-learning
classifiers f1 are used popularly due to speed or efficiency.
8.4	MORE ABOUT MODELING f1: DECOMPOSITION OF g1 AND c1
It is difficult to decompose an arbitrary f1 into g1 ◦ c1 . However, since in our context, f1 is a machine
learning classifier, we can enumerate many possible g1 functions to cover classic machine learning
classifiers.
•	Various feature selection methods are potential g1.
•	For DNN, g1 includes all the layers from input layer to the layer before the classification layer.
•	In SVM, X1 , d1 is decided by the chosen reproducing Hilbert kernel space.
•	Regularization is another popular implicit feature extraction method. For example, `1 regularization
can automatically do the feature extraction by pushing some parameters to be 0.
9	Assumption: Almost Everywhere (a.e.) Continuity
Most previous studies (Table 2) have made an important and implicit assumption about f1 and f2 : fi
is almost everywhere (a.e.) continuous. i ∈ {1, 2}.
Definition 9.1. Suppose fi is the classification function. fi is continuous a.e., i ∈ {1, 2}, if
∀x ∈ X a.e., ∃δi > 0, such that ∀x0 ∈ X, di(gi(x), gi(x0)) < δi, fi(x) = fi(x0).
Illustrated in Figure 1, di is the metric function (details in Section 3) fi uses to measure the similarity
among samples in the space Xi . For notation simplicity, we use the term “continuous a.e.” for
“continuous almost everywhere”11 in the rest of the paper. The above definition is a special case of
almost everywhere continuity defined in (Folland, 2013) (see Definition (9.2) in Section 9.1), since
we decompose fi in a certain way (see Figure 1). The a.e. continuity has a few indications, like:
∀x, x0 ∈ X, P(fi(x) 6= fi(x0)|di(gi(x),gi(x0)) < δi) = 0	(9.1)
See Section 9.1 for details of indications by a.e. continuity.
f2 is assumed continuous a.e. previously: Most previous studies find "adversarial examples" by
solving Eq. (2.1), instead of Eq. (2.2). This made an implicit assumption that if the adversarial
example x0 is similar to the seed sample x, they belong to the same class according to f2 . This
assumption essentially is: f2 is almost everywhere (a.e.) continuous.
f1 is continuous a.e.: Almost all popular machine learning classifiers satisfy the a.e. continuity
assumption. For instance, a deep neural network is certainly continuous a.e.. Similarly to the results
shown by (Szegedy et al., 2013), DNNs satisfy that |f1(x) - f1(x0)| ≤ W k x - x0 k2 where
W ≤ Q Wi and Wi ≥ ||(wi, bi)∣∣∞. Here i = {1, 2,..., L} representing i-th linear layer in NN.
Therefore, ∀ > 0, let δ = /W. Then |f1(x) - f1(x0)| < when d1(x, x0) =k x - x0 k2< δ. This
shows that a deep neural network is almost everywhere continuous when di (∙) = ∣∣∙∣∣ 2.
In Section 9.1, we show that if f1 is not continuous a.e., it is not robust to any types of noise.
Considering the generalization assumption of machine learning, machine learning classifiers should
satisfy the continuity a.e. assumption. Section 9.2 provides two examples of how popular machine
learning classifiers satisfy this assumption.
For the rare cases when f1 is not continuous a.e., see next Section 11 discussing "boundary points"
that matter for analyzing adversarial perturbations.
9.1	Indications from a.e.continuity assumption
The a.e. continuity has a few indications,
•	X is not a finite space; and ∀x, x0 ∈ X, P(fi(x) = fi(x0)|di(gi(x), gi(x0)) < δi) = 1
•	It does not mean the function f1 is continuous in every point in its feature space X;
11The measure (e.g., Lebesgue measure) of discontinuous set is 0.
17
Workshop track - ICLR 2017
•	If a probability distribution admits a density, then the probability of every one-point set {a} is zero;
the same holds for finite and countable sets and the same conclusion holds for zero measure sets 12,
for instance, straight lines or circle in Rn .
•	The a.e. continuity follows the same property as density function: the probability of picking
one-point set {x} from the whole feature space is zero; the same holds for zero measure sets. This
means: the probability of picking the discontinuous points (e.g., points on the decision boundary)
is zero, because they are null sets.
•	Most machine learning methods focus on X = Rp or space equivalent to Rp (e.g., [0, 1]p) (see
Appendix: Section 11.1). Most machine learning methods assume f1 is continuous a.e. (see
Appendix: Section 9.2).
Definition 9.2. Suppose (X, F, P) is a probability space(for general definition, (X, Σ, μ) is a
measure space), where X is the sample space, a σ-algebra F is a collection of all the events and P is
a probability measure defined in X and F. A property holds “almost everywhere” (a.e.) in X if and
only if the probability measure of the set for which the property holds equals 1.
Lemma 9.3. If the a.e. continuity assumption doesn’t hold, there exists a non-zero measure set D,
such that
∀x ∈ D, ∃x0
s.t. f1 (x) 6= f1 (x0)	(9.2)
d1 (x, x0 ) < δ1
Proof. Without it, for any test sample x, you can easily find a very similar sample x0 (i.e. for any
small δ1, d1(x, x0) < δ1) such that |f1(x) - f1(x0)| > . In classification problems, this means that
f1(x) 6= f1(x0)(i.e. there exist very similar pair of two samples x and x0 that have different labels for
most X ∈ Xi).	□
The Lemma (9.3) shows that f1 is not robust to a random noise if we don’t assume f1 is continuous.
9.2 Most machine-learning classifiers satisfy the a.e. continuity assumption
Almost all popular machine learning classifiers satisfy the a.e. continuity assumption. For example,
•	Logistic regression for text categorization with a bag of word representation.
A classifier on a multivariate feature representation in which each feature representing (modified)
counts of a word is naturally a.e. continuous. Since {x0∣dι(x, x0) < δι,x = x0} = 0 when δι is
small and x, x0 are mostly sparse vectors. Logistic regression with a bag of word representation is
a continuous a.e. predictor.
•	Support Vector Machine with continuous feature representation.
Suppose we define (X1, d1) by the d12(x, x0) = k(x, x) + k(x0, x0) - 2k(x, x0). Then support
vector machine is a linear classifier on (X1, d1). Thus, the SVM prediction function is continuous
a.e. with d1.
Most machine learning methods focus on the Rn space or the space equivalent to Rn (e.g., [0, 1]n).
For example, the sample space of image classification task intuitively is 255p, where p is the number
of features (e.g., 3 × 224 × 224). However, people mostly rescale the raw image data samples into
X = [0, 1]p. Therefore, the sample space X for f1 for this case is [0, 1]p.
10	Appendix: Using Metric Space and Pseudo Metric Spaces to
Understand Classifiers’ Robustness Against adversarial
EXAMPLES
10.1	Metric Spaces and Topological Equivalence of Two Metric Spaces
This subsection briefly introduces the concept of metric space and topological equivalence. A metric
on a set/space X is a function d : X × X → [0, ∞] satisfying four properties: (1) non-negativity, (2)
identity of indiscernibles, (3) symmetry and (4) triangle inequality. In machine learning, for example,
the most widely used metric is Euclidean distance. Kernel based methods, such as SVM, kernel
12Zero measure sets: also named as"Null set": https://en.wikipedia.org/wiki/Null_set
18
Workshop track - ICLR 2017
regression and Gaussian process, consider samples in a Reproducing kernel Hilbert space (RKHS).
The metric in a RKHS is naturally defined as: d2(x, y) = K(x, x) + K(y, y) - 2K(x, y), in which
K(∙, ∙) is a kernel function.
Now we present an important definition, namely that of “topological equivalence”, that can represent
a special relationship between two metric spaces.
Definition 10.1. Topological Equivalence (Kelley, 1975)
Afunction or mapping h(∙) from one topological space to another is continuous if the inverse image
of any open set is open. If this continuous function is one-to-one and onto, and the inverse of the
function is also continuous, then the function is called a homeomorphism and the domain of the
function, in our case (X1, d1), is said to be homeomorphic to the output range, e.g., here (X2, d2).
In other words, metric space (X1, d1) is topologically equivalent to the metric space (X2, d2).
We can state this definition as the following equation:
∃h : X1 → X2,∀x1,x01 ∈ X1,
h(x1) = x2, h(x01) = x02	(10.1)
d1 (x1 , x01 ) < δ1 ⇔ d2 (x2, x02) < δ2
Here h is continuous, one-to-one and onto. δ1 and δ2 are two small constants.
10.2	Pseudometric Spaces and Finer Topology among Pseudometric Spaces
We have briefly reviewed the concept of metric space in Section 10.1 and proposed the related Theo-
rem (3.2) in Section 3.3. This is partly because the concept of metric space has been widely used
in many machine learning models, such as metric learning (Xing et al., 2003). Theorem (3.2) and
related analysis indicate that feature spaces X1 and X2 (See Figure 1) are key determining factors for
deciding learning model’s strong-robustness.
However, it is difficult to get the analytic form of X2 in most applications (e.g., when an oracle f2 is
a human annotator). In fact, most previous studies (reviewed in Section 2.2) assume (X2, d2) equals
to (X, ∣∣∙∣∣), where ∣∣∙∣∣ is a norm function. Therefore, We want to extend our analysis and results
from the implicit feature space X2 to the original feature space X .
When we extend the analysis to the original space X , it is important to point out that the distance
function measuring sample similarity for a learned predictor f1 in the original space X may not be a
metric. The distance function in the original feature space X for oracle f2 may not be a metric as
well. This is because the distance between two different samples in the original space X may equal
to 0. Because two different samples may be projected into the same point in X1 or X2 . For example,
a change in one pixel of background in an image does not affect the prediction of f1 or f2 since the
g1 and g2 have already eliminated that (irrelevant) feature. This property contradicts the identity of
indiscernibles assumption for a metric function. Therefore we need a more general concept of the
distance function for performing theoretical analysis in the original space X . By using the concept of
Pseudometric Space13, we derive another important theorem about strong-robustness.
Pseudometric: If a distance function d0 : X × X → [0, ∞] has the following three properties: (1)
non-negativity, (2) symmetry and (3) triangle inequality, we call d is a pseudometric or generalized
metric. The space (X, d0 ) is a pseudometric space or generalized metric space. It is worth to point out
that the generalized metric space is a special case of topological space and metric space is a special
case of pseudometric space.
Why Pseudometric Space: As shown in Figure 1, we can decompose a common machine learning
classifier f1 = c1 ◦ g1, where g1 : X → X1 represents the feature extraction and c1 : X1 → Y
performs the operation of classification. Assume there exists a pseudometric d1 (∙, ∙) on X and a
metric d1(∙, ∙) defined on X114, so that ∀χ,χ0 ∈ X,
d01(x,x0) = d1(g1(x),g1(x0)).	(10.2)
Since d1 is a metric in X1, d01 fulfills the (1) non-negativity, (2) symmetry and (3) triangle inequality
properties. However, d01 may not satisfy the identity of indiscernible property (i.e., making it not a
13The crucial problem of the original sample space X is that it’s difficult to strictly define a metric on the
original feature space.
14d1(∙, ∙) on Xi satisfies four properties:(1) non-negativity, (2) identity of indiscernibles, (3) symmetry and
(4) triangle inequality.
19
Workshop track - ICLR 2017
metric). For example, suppose g1 only selects the first three features from X . Two samples x and x0
have the same value in the first three features but different values in the rest features. Clearly, x 6= x0,
but d0ι(x, x0) = d1(g1(x), gι(x0)) = 0. This shows that d1(∙, ∙) is a pseudometric but not a metric in
X . Similarly, a pseudometric d02 for the oracle can be defined as follow:
d02(x,x0) = d2(g2(x),g2(x0)).	(10.3)
To analyze the strong robustness problem in the original feature space X, we assume it to be a
generalized metric (pseudometric) space (X, d01) for f1 and a generalized metric (pseudometric)
space (X, d02) for f2. Now we can analyze f1 and f2 on the same feature space X but relate to two
different pseudometrics. This makes it possible to define a sufficient and necessary condition for
determining the strong robustness of f1 against adversarial perturbation.
Before introducing this condition, we need to briefly introduce the definition of topology and
finer/coarser topology here:
Definition 10.2. A topology τ is a collection of open sets in a space X.
A topology τ is generated by a collection of open balls {B(x, δ1)} where x ∈ X and B(x, δ1) =
{z|d(x, z) < δ1}. The collection contains {B(x, δ1)}, the infinite/finite number of the union of balls,
and the finite number of intersection of them.
Definition 10.3. Suppose τ1 and τ2 are two topologies in space X. If τ2 ⊆ τ1, the topology τ2 is
called a coarser (weaker or smaller) topology than the topology τ1, and τ1 is called a finer (stronger
or larger) topology than τ2.
10.3	Proofs for Theorems and Corollaries
In this section, we provide the proofs for Theorem (3.2), Corollary (4.2), Theorem (3.4), and Corol-
lary (4.1). We first prove Theorem (3.4) and Corollary (4.1). Since “topological equivalence” is a
stronger condition than “finer topology”, Theorem (3.2) and Corollary (4.2) are straightforward.
10.3.1	PROOF OF THEOREM (3.4) WHEN f2 IS CONTINUOUS A.E.
Proof. Let	S1 = {B1(x,	)} and	S2	= {B2(x,	)}, where B1(x, ) =	{y|d01(x, y) < }	and
B2(x, ) =	{y|d02(x, y) <	}. Then	S1	⊂ τ1 and S2	⊂ τ2. In fact, τ1 and τ2	are generated by S1	and
S2. S1 and S2 are bases of (X, τ1) and (X, τ2).
•	First, we want to prove that given δ2 > 0, ∃δ1 > 0 such that if d02(x, x0) ≤ δ2, then d01(x, x0) ≤ δ1.
Consider a pair of samples (x, x0) and d02(x, x0) ≤ δ2. x, x0 ∈ B2(x, δ2). Of course, B2(x, δ2) ∈
τ2. Suppose the (X, d01) is a finer topology than (X, d02). Then B2(x, δ2) ∈ τ1. You can
find B1(χ0, δ1∕2) ∈ τι such that B2(χ, δ2) ⊂ B1(x0, δι∕2), where B2(χ,δ2) is the closure of
B2 (x, δ2 ). Therefore d01 (x, x0) ≤ δ1 .
Based on a.e. continuity assumption of f1, since d01(x, x0) ≤ δ, f1(x) = f1(x0) a.e. . This means
that P(f1(x) = f1(x0)|d2(g2(x), g2(x0)) < δ2) = 1, which is our definition of strong-robustness.
•	Next, we want to show that if f1 is strong-robust, then τ1 is a finer topology than τ2 .
Suppose f1 is strong-robust, we need to prove that ∀δ2 > 0, ∃δ1 > 0 such that if d02(x, x0) ≤ δ2,
then d01 (x, x0) ≤ δ1 .
Assume τ1 is not a finer topology than τ2. This means there exists a B2(x, δ2) such that B2(x, δ2) ∈/
τ1. Therefore ∀δ1 > 0, there exists x0 ∈ B2 (x, δ2) such that d02(x, x0) < δ2 and d01(x, x0) > δ1.
Based on a.e. continuity assumption of f1, d01 (x, x0) > δ1 indicates that f1 (x) 6= f1 (x0). This
contradicts the strong-robust assumption. Thus, τ1 is a finer topology than τ2 .
□
Proof of Theorem (3.4) when f2 is not continuous a.e.
Proof. Let	S1 = {B1(x,	)} and	S2	= {B2(x,	)}, where B1(x, ) =	{y|d01(x, y) < }	and
B2(x, ) =	{y|d02(x, y) <	}. Then	S1	⊂ τ1 and S2	⊂ τ2. In fact, τ1 and τ2	are generated by S1	and
S2. S1 and S2 are bases of (X, τ1) and (X, τ2).
•	First, we want to prove that given δ2 > 0, ∃δ1 > 0 such that if d02(x, x0) ≤ δ2, then d01(x, x0) ≤ δ1.
Consider a pair of samples (x, x0) and d02(x, x0) ≤ δ2. x, x0 ∈ B2(x, δ2). Of course, B2(x, δ2) ∈
τ2.	Suppose the	(X, d01)	is a finer topology than	(X, d02).	Then	B2 (x,	δ2)	∈	τ1.	You can
20
Workshop track - ICLR 2017
find Bι(χo,δι∕2) ∈ τι such that B2(x,δ2) ⊂ Bι(x0,δι∕2), where B2(x,δ2) is the closure of
B2 (x, δ2 ). Therefore d01 (x, x0 ) ≤ δ1 .
Based on a.e. continuity assumption of f1, since d01(x, x0) ≤ δ1, f1(x) = f1(x0) a.e. . This means
that P(f1(x) = f1(x0)|f2(x) = f2(x), d2(g2(x), g2(x0)) < δ2) = 1, which is our definition of
strong-robustness.
•	Next, we want to show that if f1 is strong-robust, then τ1 is a finer topology than τ2 .
Suppose f1 is strong-robust, we need to prove that ∀δ2 > 0, ∃δ1 > 0 such that if d02(x, x0) ≤ δ2,
then d01 (x, x0 ) ≤ δ1 .
Assume τ1 is not a finer topology than τ2. This means there exists a B2(x, δ2) such that B2(x, δ2) ∈/
τ1. Therefore ∀δ1 > 0, there exists x0 ∈ B2(x, δ2) such that d02(x, x0) < δ2 and d01(x, x0) > δ1.
Based on a.e. continuity assumption of f1, d01(x, x0) > δ1 indicates that f1(x) 6= f1(x0). This
contradicts the strong-robust assumption. Thus, τ1 is a finer topology than τ2 .
□
10.3.2 Proof of Theorem (3.5)
Proof. In Section 10.3.1, we have already proved that if the (X, d01) is a finer topology than (X, d02),
then we can have that ∀ pair (x, x0) (x, x0 ∈ X) d02(x, x0) ≤ δ2, then d01(x, x0) ≤ δ1. Therefore,
P(f1(x) = f1(x0)|f2(x) = f2(x0),d02(x,x0) < δ2)
=1 - P(f1(x)	6= f1(x0)|f2(x)	=	f2(x0), d02(x,x0)	<	δ2)
=1 - P(f1(x)	6= f1(x0)|f2(x)	=	f2(x0), d1 (x, x0)	<	δ1,	(10.4)
d02 (x, x0) < δ2)
>1-η
□
10.3.3	Proof of Theorem (3.3)
Proof. Since (X1, d1) and (X2, d2) are topologically equivalent. P(f1(x) 6= f1(x0)|f2(x) =
f2(x0),d1(g1(x),g1(x0)) < δ1) = P(f1(x) 6= f1(x0)|f2(x) = f2(x0),d2(g2(x),g2(x0)) < δ2).
Therefore,
P(f1(x) = f1(x0)|f2(x) = f2(x0),d2(g2(x),g2(x0)) < δ2)
=1 - P(f1(x) 6= f1(x0)|f2(x) = f2(x0),
d2 (g2(x), g2(x0)) < δ2)
=1 - P(f1(x) 6= f1(x0)|f2(x) = f2(x0),
d1(g1(x), g1(x0)) < δ1, d2(g2(x),g2(x0)) < δ2)
>1 -η
(10.5)
□
10.3.4	Proof of Theorem (3.2)
Proof. Since f1 is continuous a.e., P(f1(x) = f1(x0)|f2(x) = f2(x0), d1 (g1 (x), g1(x0) <
δ1, d2(g2(x), g2(x0)) < δ2) = 0. Therefore, by Section 10.3.3, P(f1(x) = f1(x0)|f2(x) =
f2(x0),d2(g2(x),g2(x0)) < δ2) = l.	□
10.3.5	Proof of Corollary (4.2)
Proof. By (Kelley, 1975), We know that if di and d2 are norms in Rn, (Rn, di) and (Rn, d2) are
topological equivalent. Therefore, We have the conclusion.	□
10.3.6	Proof of Corollary (4.1)
Proof. Suppose ni > n2 and X2 ⊂ Xi. (X, d02) is a finer topology than (X, d0i). Therefore (X, d0i)
is not a finer topology than (X, d02), which indicates that fi is not strong-robust against adversarial
examples.	□
21
Workshop track - ICLR 2017
10.4 More about Principled Understanding from Proposed Theorems
10.4.1	MORE EXAMPLES ABOUT g1 MATTERS FOR STRONG-ROBUSTNESS AND c1 NOT
Figure 4 uses an example to illustrate Table 3 Case (III) when f1 is strong-robust. We show one case
of X1 = X2 = R2 and f1, f2 are continuous a.e.. In terms of classification, f1 (green boundary line)
is not accurate according to f2 (red boundary line).
Figure 5 uses an example figure to illustrate Table 3 Case (IV) when f1 is strong-robust. We show
one case of 1 = n1 < n2 = 2, X1 ⊂ X2 and f1, f2 are continuous a.e.. In terms of classification, f1
(green boundary line) is not accurate according to f2 (red boundary line).
All pairs of test samples (x, x0) can be categorized into the three cases shown in both figures.
•	Test-case (a) is when x and x0 are predicted as the same class by both. f1 gets correct predictions
according to f2 . There exist no adversarial examples.
•	Test-case (b) is when x and x0 are predicted as the same class by both. But f1 gets incorrect
predictions according to f2 . There exist no adversarial examples.
•	Test-case (c) shows when f1 (x) 6= f1 (x0), d2(x, x0) < δ2 and f2(x) = f2(x0). This case is
explained in Section 11. Essentially, this is about “Boundary based adversarial examples” and
can only attack points whose distance to the boundary of f1 is smaller than δ2 (f1 (x) 6= f1 (x0),
d2(x, x0) < δ2 and f2(x) = f2(x0)). When f1 is continuous a.e., the probability of this set is 0.
Clearly from the two figures, c1 does not determine the strong-robustness of f1.
10.4.2	More about Extra Unnecessary Features Ruin Strong-robustness
In real-world applications, such attacks can be, for example, adding words with a very tiny font size
in a spam E-mail, that is invisible to a human annotator. When a learning-based classifier tries to
utilize such extra words (unnecessary for human), it can lead to many easily generated adversarial
emails.
As another example, one previous study (Xu et al., 2016) shows that a genetic-programming based
adversarial example strategy can always evade two state-of-art learning-based PDF-malware classifiers
(with "100%" evasion rates). The reason behind such good evasion rates is the Condition (4.1). Both
state-of-art PDF-malware classifiers have used many superficial features (e.g., a feature representing
"is there a long comment section") that are not relevant to "the malicious property" of a PDF sample
at all !
10.4.3	WHEN f1 CONTINUOUS A.E., EITHER STRONG-ROBUST OR NOT ROBUST AT ALL A.E.
Table 3 indicates that training a strong-robust and accurate classifier in practice is extremely difficult.
For instance, Figure 2 shows only one extra irrelevant feature, which does not hurt accuracy, makes
the classifier not robust to adversarial perturbation at all (i.e., for samples a.e. in X, easy to find its
adversarial examples.).
When f1 is continuous a.e., P(f1(x) = f1(x0)|f2(x) = f2(x0), d2(g2(x), g2(x0)) < δ2) equals to
either 1 or 0. This means f1 is either strong-robust or not robust under AN at all a.e.. One case
with this probability as 0 is illustrated by Figure 2. Case (III) and Case (IV) from Table 3 have this
probability equaling to 1.
11 B OUNDARY POINTS OF f1 MATTER FOR ADVERSARIAL EXAMPLES WHEN
f1 IS NOT CONTINUOUS A.E.
When f1 is not continuous a.e., the analysis of adversarial examples needs to consider "boundary
points" of f1 with certain properties. This section tries to clarify the definition and related scope.
Definition 11.1. We define the set of boundary points of fi as the following set of sample pairs:
{(x,x0)|fi(x) 6= fi(x0),di(gi(x),gi(x0)) < δi,
x ∈ X,x0 ∈ X}
(11.1)
Our definition of the boundary points describes such points as pairs of samples that are across the
classification boundary. This format of definition makes the following analysis (notation-wise) easy
and concise.
22
Workshop track - ICLR 2017
Case (b)
Machine
classifier
Not consider in the
Strong-robustness
Not consider in the
strong-robustness
Boundary points of ʌ
Boundary points of ∕2
Boundary-based attack
Boundary points of ∕2
and f1
Figure 6: An example showing boundary points of f1 and boundary points of f2 . We assume f1
and f2 are continuous a.e.. We assume c1 and c2 as linear classification functions. The first two
columns showing boundary points of f2 that are not considered in this paper. The third column
describes “Boundary based adversarial attacks” that can only attack seed samples whose distance to
the boundary of f1 is smaller than . Essentially this attack is about those boundary points of f1 that
are treated as similar and belong to the same class by f2 .
Lemma 11.2. fi is not continuous a.e., if and only if
x ∈ X,x0 ∈ X,P(fi(x) 6= fi(x0)|di(gi(x),gi(x0)) < δi) > 0
(11.2)
This lemma shows that a case with probability of boundary points larger than 0 is exactly the situation
when fi being not continuous a.e..
11.1	MORE ABOUT BOUNDARY POINTS OF f1 AND B OUNDARY POINTS OF f2
In addition, we want to point out that all boundary pairs of f2 (satisfying f2 (x) 6= f2 (x0) and
d2 (g2 (x), g2 (x0)) < δ2) are not considered in our analysis of adversarial examples. Figure 6
illustrates three types of boundary points, using the first two columns showing boundary points of f2 .
The third column of Figure 6 describes “Boundary based adversarial examples” that can only attack
seed samples whose distance to the boundary of f1 is smaller than δ2. Essentially this attack is about
those boundary points of f1 that are treated as similar and belong to the same class by f2 . That is
P(f1(x) 6= f1(x0)|f2(x) = f2(x0),d2(g2(x),g2(x0)) < δ2,
d1(g1(x),g1(x0)) < δ1)
(11.3)
•	When f1 is continuous a.e., Eq. (3.1) equals to 0. (derived from Eq. (9.1) in Section 9)
•	When f1 is not continuous a.e., Eq. (3.1) might be larger than 0. (derived from Eq. (11.2))
The value of this probability is critical for our analysis in Theorem (3.3) and in Theorem (3.5). Again,
we want to emphasize that most machine learning methods assume f1 is continuous a.e. and therefore
“boundary based adversarial attacks” are not crucial.
23
Workshop track - ICLR 2017
P {adversarial samples)
Figure 7: When f1 is not continuous a.e., the strong-robustness of f1 is determined by both g1 and c1.
We assume c1 and c2 as linear classification functions. This figure shows when (1) sample space X is
finite, (2) f1 learns a wrong decision boundary and (3) the probability of test samples around f1’s
decision boundary is large, f1 is not strong-robust against adversarial examples. However, we want
to emphasize that the situation is very rare for a well-trained classifier f1 .
Machine
classifier
Assume ∖X∖ = IOlgl =
92/cι ≠ c2
11.2	WHEN f1 NOT CONTINUOUS A.E., STRONG-ROBUST IS SIGNIFICANTLY INFLUENCED BY
B OUNDARY POINTS OF f1
When f1 is not continuous a.e., for instance when X is a finite space, the probability of “adversarial
examples” can be calculated as:
P(f1(x) 6= f1(x0)|f2(x) = f2(x0),d2(g2(x),g2(x0)) < δ2)
= #{(x,x0)∣f2(x) = f2(x0)&d2(g2(x),g2(x0)) < δ2f (x) = f (x0)}	(11.4)
#{(x,x0)∣f2(x) = f (x0)&d2(g2(x),g2(x0)) < δ2}
This is exactly the proportion of those pairs of points for which f1 classifies them into different
classes and f2 treats them as similar and "same-class" samples. For this case, both g1 and c1 matter
for the strong-robustness of f1. See Appendix Section 11.2 for an example showing how c1 makes f1
not strong robust.
11.2.1	c1 MATTERS FOR STRONG-ROBUSTNESS WHENf1 IS NOT A.E. CONTINUOUS
Based on Eq. (11.4), when f1 is not continuous a.e., the strong-robustness off1 is determined by
both g1 and c1. Figure 7 shows an exemplar case in which X has only ten samples (i.e. ∣X∣ = 10).
We assume the learned f1 and the oracle f2 derive the same feature space, i.e., X1 = X2 . And
we also assume f1 performs the classification very badly because the decision boundary (by c1)
on X1 is largely different from the decision boundary on X2. The probability of "adversarial
examples" in this case can be calculated by using Eq. (11.4). We get P(f1(x) 6= f1(x0)∣f2(x) =
f2(x0),dι(gι(x),gι(x0)) < δι) = ∣⅛ =0.6.
Clearly in this case, c1 matters for the strong-robustness (when f1 is not a.e. continuous). This figure
indicates that when (1) sample space X is finite, (2) f1 learns a wrong decision boundary and (3) the
probability of test samples around f1’s decision boundary is large, f1 is not strong-robust against
adversarial examples. However, we want to point out that this situation is very rare for a well-trained
classifier f1.
24
Workshop track - ICLR 2017
Table 5: Accuracy of the deep residual network(He et al., 2015) obtained from two noise-perturbed
testing cases. The second column shows the result on randomly perturbed samples, and the third
column shows the result on adversarially perturbed samples.
Attack power (defined in Eq. (12.6))	Test accuracy on randomly perturbed sam- ples	Test accuracy on adversari- ally perturbed samples
"O	0.9411	0.9411
	0.9409	0.5833
	0.9369	0.3943
10	—	0.9288	—	0.3853	—
For cases when f1 is not continuous a.e., obtaining more samples is clearly a good way to learn a
better decision boundary that might improve the adversarial robustness of the classifier at the same
time.
12 More about DNNs’ Robustness Against Adversarial S amples
Researchers have proposed different strategies to generate adversarial examples attacking deep neural
networks (e.g., (Szegedy et al., 2013; Nguyen et al., 2015; He et al., 2015; Papernot et al., 2016a;
Moosavi-Dezfooli et al., 2015; Papernot et al., 2015b)). Previous studies mostly focus on an image
classification, therefore for these domains our symbols mean:
•	fι(∙): fι(∙) is aDNN classifier with multiple layers, including linear perceptron layers, activation
layers, convolutional layers and softmax decision layer.
•	(X1 , d1 ): X1 denotes the feature space discovered by the layer right before the last fully connected
layer. This feature space is automatically extracted from the original image space (e.g., RGB
representation) by the DNN. (X, d01) is defined by d1 using Eq. (10.2).
•	(X2, d2): X2 denotes the feature space that oracle (e.g., human annotators) used to decide ground-
truth labels of training images. For example, a human annotator needs to recognize a hand-written
digit “0”. X2 includes what patterns he/she needs for such a decision. (X, d02) is defined by d2
using Eq. (10.3)
12.1	More about Are State-of-the-Art Deep Neural Nets Strong-Robust ?
We can observe some properties of d1 through experimental results. Table 5,Table 6,Table 7 and
Table 8 show properties of d1 (and d01 ) resulting from performing testing experiments on four
state-of-art DNN networks.
In Table 9, the model we use is a 200-layer residual network (He et al., 2015) trained on Imagenet
dataset (Deng et al., 2009) by Facebook15. We generate two types of test samples from 50000 images
in the validation set of Imagenet: (1) 50000 randomly perturbed images. The random perturbations
on each image are generated by first fixing the perturbation value on every dimension to be the
same, and then randomly assigning the sign on every dimension as + or - (with probability 1/2). In
this way, the size of the perturbation can be described by ||x - χ01|∞ that we name as the level of
attacking power ( later defined in Eq. (12.6)). (2) 50000 adversarially perturbed images. We use the
fast-gradient sign method (introduced in Section 8.2) to generate such adversarial perturbations on
each seed image. The “attacking power” of such adversarial perturbations uses the same formula
as Eq. (12.6). The first column of Table 9 shows different attack powers (Eq. (12.6)) we use in the
experiment. The second column shows the accuracy of running the DNN model on the first group of
image samples and the third column shows the accuracy of running the DNN model on the second
group of image samples.
Table 6,Table 7 and Table 8 repeat similar experiments on three other DNN models: overfeat
network(Sermanet et al., 2013), the residual network(He et al., 2015) and the VGG model (Simonyan
& Zisserman, 2014). The conclusion is consistent across all four models.
15https://github.com/facebook/fb.resnet.torch
25
Workshop track - ICLR 2017
Table 6: Accuracy of the overfeat network(Sermanet et al., 2013) obtained from two noise-perturbed
testing cases. The second column shows the result on randomly perturbed samples, and the third
column shows the result on adversarially perturbed samples.
Attack power (defined in Eq. (12.6))	Test accuracy on randomly perturbed sam- ples	Test accuracy on adversari- ally perturbed samples
"O	0.7944	0.7944
	0.7923	0.5922
	0.7844	0.4270
10	—	0.7762	—	0.3485	—
Table 7: Accuracy of the residual network(He et al., 2015) obtained from two noise-perturbed testing
cases in CIFAR-10 dataset (Krizhevsky & Hinton, 2009). The second column shows the result
on randomly perturbed samples, and the third column shows the result on adversarially perturbed
samples.
Attack power (defined in Eq. (12.6))	Test accuracy on randomly perturbed sam- ples	Test accuracy on adversari- ally perturbed samples
"O	0.9431	0.9431
	0.9431	0.9294
	0.9429	0.6815
10	—	0.943	—	0.2961	—
12.2	Connecting Previous Studies Hardening DNNs
Multiple hardening solutions (Zheng et al., 2016; Miyato et al., 2016; Lee et al., 2015) exist in
the DNN literature. They mostly aim to learn a better g1 by minimizing different loss functions
Lf1 (x, x0) so that when d2(g2(x), g2(x0)) < , this loss Lf1 (x, x0) is small. This might improve the
the topological equivalence (or finer topology). Two major variations exist among related methods:
the choice of Lf1 (x, x0) and the way to generate pairs of (x, x0).
•	Choice of loss function Lf1 (x, x0): Siamese training (G) (Section 12.4) and (Lee et al., 2015) use
Lf1 (x, x0) = d1(g1(x), g1 (x0)). Siamese training (F) chooses Lf1 (x, x0) = dist(f1(x), f1(x0)),
where dist(∙, ∙) is a distance function measuring the difference between fι(χ) and fι(χ0). If fι is
continuous a.e., when d1(g1(x), g1(x0)) is small → we get dist(f1(x), f1(x0)) is small. However,
the reverse direction may not hold. Therefore, Lf1 (χ, χ0) = dist(f1(χ), f1(χ0)) may not work for
cases.
•	Generating pairs of (χ, χ0): Another variation is the way of generating pairs of (χ, χ0) so that
d2 (g2 (χ), g2 (χ0)) is small. There exist two common ways. One is generating χ0 by adding a
random (e.g. Gaussian) perturbation on χ. The other one is generating the adversarial perturbation
to get χ0 from χ.
Besides, (Zheng et al., 2016) uses Lf1 (χ, χ0) = KL(f1(χ), f1(χ0)) and uses it as a regularization
term adding onto the original training loss function. Its samples χ0 are generated from original
samples χ adding a small Gaussian noise. (Miyato et al., 2016) uses the similar loss function as
(Zheng et al., 2016). But (Miyato et al., 2016) uses adversarial perturbed χ0 from χ. (Lee
et al., 2015) uses Lf1 (χ, χ0) = d1(g1(χ), g1(χ0)) and χ0s are generated χs by adding a small
Gaussian noise. Recently proposed adversarial training (Goodfellow et al., 2014; Kurakin et al.,
2016) uses Lf1 (χ, χ0) = L(f1(χ0), f2(χ)) and uses adversarial perturbed χ0 from χ. These studies
are summarized and compared in Table 4.
26
Workshop track - ICLR 2017
Table 8: Accuracy of the wide residual network(Zagoruyko & Komodakis, 2016) obtained from
two noise-perturbed testing cases in CIFAR-10 dataset (Krizhevsky & Hinton, 2009). The second
column shows the result on randomly perturbed samples, and the third column shows the result on
adversarially perturbed samples.
Attack power (defined in Eq. (12.6))	Test accuracy on randomly perturbed sam- ples	Test accuracy on adversari- ally perturbed samples
"O	-0.953	-0.953
	-0.953	0.8527
飞	-0.953	0.4718
10	—	0.953	—	0.2529	—
Table 9: Accuracy of the VGG model (Simonyan & Zisserman, 2014) obtained from two noise-
perturbed testing cases in CIFAR-10 dataset (Krizhevsky & Hinton, 2009). The second column shows
the result on randomly perturbed samples, and the third column shows the result on adversarially
perturbed samples.
Attack power (defined in Eq. (12.6))	Test accuracy on randomly perturbed sam- ples	Test accuracy on adversari- ally perturbed samples
"O	0.9395	0.9395
	-0.938	0.7807
	-0.938	0.3767
10	—	0.9377	—	0.2092	—
12.3	A novel evaluation metric "Adversarial Robustness of Classifiers (ARC)"
TO QUANTIFY THE MODEL ROBUSTNESS AGAINST ADVERSARIAL EXAMPLES
Our theoretical analysis indicates that strong-robustness is a strong condition of machine learning
classifiers and requires thorough understanding of oracle. Since many state-of-the-art learning models,
including many DNNs, are not strong-robust, it is important to understand and quantify how far they
are away from strong-robustness.
This section proposes a new evaluation measure “Adversarial Robustness of Classifiers (ARC)” to
quantify how far a classifier is away from the strong-robustness. This quantitative measure considers
both the predictor f1 and the oracle f2. By design, a classifier (f1)’s ARC achieves the maximum (1
since ARC is rescaled to [0, 1]) if and only if f1 is strong-robust (see Theorem (12.3)).
12.3.1	DEFINE ARC AND ARCA
We name such situations as "weak-robustness" and propose a quantitative measure to describe how
robust a classification model is against adversarial examples. The proposed measure “Adversarial
Robustness of Classifiers (ARC)” considers both the predictor f1 and the oracle f2 (introduced in
Section 2.2). By design, a classifier (f1)’s ARC achieves the maximum (1 since ARC is rescaled to
[0, 1]) if and only if f1 is strong-robust against adversarial examples and is based on the expectation
of how difficult it is to generate adversarial examples.
Definition 12.1. Adversarial Robustness of Classifiers (ARC)
By adding the constraint d2(x, x0) < δ2 into Eq. (2.2) (our general definition of adversarial examples)
and taking the expactation of d2 between adversarial example and seed sample, we define a measure
27
Workshop track - ICLR 2017
quantifying the robustness of machine learning classifiers against adversarial examples.
ARC(f1,f2) =Ex∈X [d2 (x, x0)]
x0 = argmin d2(x, t)
t∈X	(12.1)
Subject to: f1 (x) 6= f1 (t)
d2(x, t) < δ2
Here for the case that x0 doesn’t exsit, we assume d2(x, x0) = δ2.
Two recent studies (Moosavi-Dezfooli et al., 2015; Papernot et al., 2015b) propose two similar
measures both assuming d2 as norm functions, but do not consider the importance of an oracle. More
importantly, (Papernot et al., 2015b) does not provide any computable way to calculate the measure.
In (Moosavi-Dezfooli et al., 2015), the measure is normalized by the size of the test samples, while
no evidence exists to show that the size of perturbation is related to the size of test samples.
The fact that previous measures neglect the oracle f2 leads to a severe problem: the generated
adversarial examples are not necessarily valid. This is because if the size of perturbation is too large,
oracle f2 may classify the perturbed sample into a different class (different from the class of the seed
sample).
This motivates us to design a computable criteria to estimate Definition (12.1). For instance, for
image classification tasks, we can choose d2 = || ∙ ∣∣∞ as an example. Then in Eq. (12.1), to estimate
of E[||x - χ0∣∣∞], we need to make some assumptions. Assume that there exists a threshold δ2, that
any perturbation larger than δ2 will change the classification of oracle f2. That is if ||x - χ0∣∣∞ ≥ δ2,
then f2(x) 6= f2(x0). More concretely, for image classification tasks, as the input space is discrete
(with every dimension ranging from 0 to 255), ARC can be estimated by the following Eq. (12.2):
δ2-1
ARC∞(f1,f2) =E[k x-x0 k∞] = X iP(k x-x0 k∞= i)
i=1
+δ2P(f1(x) =f1(t),∀ k x-t k∞< δ2).
x0 = argmin d2 (x, t)
t∈X
(12.2)
Subject to: f1(x) 6= f1(t)
f2(x) = f2(t)
Definition 12.2. Adversarial Robustness of Classifiers with Accuracy (ARCA)
As we have discussed in the Section 4, both accuracy and robustness are important properties in
determining whether a classification model is preferred or not. Therefore we combine accuracy and
ARC into the following unified measure ARCA:
ARCA(fι) = Accuracy(fι) X 4尺。(’1, ')	(12.3)
δ2
12.3.2	ARC and Strong-robustness
It is important to understand the relationship between strong-robustness and weak-robustness. We
provide an important theorem as follows that clearly shows the weak-robustness is quantitatively
related to the strong-robustness.
Theorem 12.3. fι is strong-robust against adversarial examples if and only if ARC (f1)∕δ2 = L
Proof of Theorem (12.3):
Proof. If ARC(f1)∕δ2 = 1, then based on Definition (12.1), we have that
P(d2(x, x0) = δ2) = 1.
This indicates that
P(f1(x) = f1(x0)|d2(x, x0) < δ2) = 1, which is the exact definition of strong-robustness ( Eq. (3.8)).
28
Workshop track - ICLR 2017
If f1 is strong-robust, then P(f1(x) = f1(x0)|d2(x, x0) < δ2) = 1.
Therefore ARC(f1) = E[d2(x, x0)]. Since P(f1(x) 6= f1(x0)|d2(x, x0) < δ2) = 0, we have that
ARC(f1) =
E[d2(x, x0)] =
δ2P(f1(x) =f1(x0)|d2(x,x0) <δ2)
δ2
(12.4)
ARC (f1)∕δ2 = 1.
12.4	Using “Siamese Architecture” to improve DNNs’ Adversarial Robustness
One intuitive formulation that we can use to improve a DNN’s adversarial robustness is by solving
the following:
∀x, x0 ∈ X, if d2 (g2 (x), g2 (x0)) < ,
argmin d1 (g1 (x; w), g1 (x0 ; w))
(12.5)
w
This essentially forces the DNN to have the finer topology between (X1, d1) and (X2, d2) by learning
a better g1 . We name the strategy minimizing the loss defined in Eq. (12.5) as "Siamese Training"
because this formulation uses the Siamese architecture (Bromley et al., 1993), a classical deep-
learning approach proposed for learning embedding. We feed a slightly perturbed input x0 together
with its original seed x to the Siamese network which contains two copies (sharing the same weights)
of a DNN model We want to improve. By penalizing the difference between middle-layer (gι(∙))
outputs of (x, x0), "Siamese Training" can push two spaces (X, d01) versus (X2, d02) to approach finer
topology relationship, and thus increase the robustness of the model. This can be concluded from
Figure 8. By assuming d2(g2(χ),g2(χ0)) equals (approximately) to ∣∣∆(χ,χ0)∣∣, previous studies
(summarized in Table 2) normally assume d2 is a norm function ∣∣∙∣∣. Because for a pair of inputs
(x,x0) that are close to each other (i.e., ||x - χ01| is small) in (X, || ∙ ||), Siamese training pushes
them to be close also in (X1, d1) . As a result, this means that a sphere in (X1, d1) maps to a
not-too-thin high-dimensional ellipsoid in (X, || ∙ ||). Therefore the adversarial robustness ofDNN
model after Siamese training may improve. In experiments, we choose Euclidean distance ∣∣ ∙ ∣∣2 for
dι(∙) (however, many other choices are possible).
12.5	Comparing DNN Hardening S trategies Experimentally
Datasets: Currently, we are using the following 2 image datasets to evaluate our model:
•	MNIST: MNIST, released in (LeCun et al., 1998) includes a task to classify handwritten digits. It
has a training set of 60,000 examples, and a test set of 10,000 examples. Each example is a 32x32
pixel black and white image of handwritten digit.
•	CIFAR-10: CIFAR-10 is an image classification dataset released by (Krizhevsky & Hinton, 2009).
The training set contains 50,000 32x32 color images in 10 classes, and the test set contains 10,000
32x32 color images. VGG model: We choose a VGG model (Simonyan & Zisserman, 2014) as a
base DNN model. The VGG model in our experiment has 16 weight layers (55 layers in total).
Baseline: Three different hardening strategies are compared through testing on adversarial examples
(details in Section 12.2): (1) original model; (2) stability training (Zheng et al., 2016) 16; (3) Siamese
training (alone); (4) adversarial training (Goodfellow et al., 2014; Kurakin et al., 2016) uses adversarial
perturbed x0 and original samples x to train a DNN model.
The first column of Table 10 and Table 11shows different levels of attack power (defined in Eq. (12.6)).
Test accuracy reported in Figure 9(a), Figure 10(a), Table 10 and Table 11 shows different hardening
approches can increase the effectiveness of the adversarial attacks. Details of our experimental set-up
and datasets are included in Section 12.2.
Evaluation Metrics:
16ATT: Stability training was shown to improve the model robustness against Gaussian noise in (Zheng
et al., 2016). Differently, our experiments focus on testing a learning model’s robustness against “adversarial
perturbation”. The sole purpose of including this baseline is to show where state-of-art hardening strategies are
in our experimental setting.
29
Workshop track - ICLR 2017
Loss
function
Il 5fι(x) -^i(ɪɔ Il2
di (% (%), 9ι (N))
to be small
(X,lHI)
is small
Assume
d2 Si (%), 9ι(%'))
‰d2) = (X, ∣∣∙∣∣)
,))
Figure 8: Sketch of Siamese training. Inputs are pairs of seed sample and their randomly perturbed
version, while we suppose the d2 distance between the pair is small. By forwarding a pair into the
Siamese network and penalizing the outputs of the pair, this training intuitively limit the d1 distance
between two similar samples to be small. Backpropagation is used to update the weights of the
network.
•	Test accuracy: We use top-1 test accuracy as the performance metric. It is defined as the number
of successfully classified samples divided by the number of all test samples. The base model
achieves accuracy when there’s no adversarial attack.
•	ARC (Eq. (12.2)) : We use ARC to measure the adversarial robustness of each model. η is chosen
to be 10.
•	ARCA: (Eq. (12.3)) : We use ARCA to measure the total performance of each model.
We generate adversarial examples using the fast gradient sign method, in which the power of the
adversary attack can be easily controlled. By controlling the power of fast-sign attacks, we can obtain
a complete view of how the accuracy changes according to different attack powers.
In the following analysis, the attack power is defined as:
P = ||x - χ0∣∣∞	(12.6)
For image classification tasks, we control the perturbed sample to be still in the valid input space, so
that every dimension of the perturbed samples is in the range of integers between 0 and 255.
References
Scott Alfeld, Xiaojin Zhu, and Paul Barford. Data poisoning attacks against autoregressive models.
AAAI, 2016.
Marco Barreno, Blaine Nelson, Russell Sears, Anthony D Joseph, and J Doug Tygar. Can machine
learning be secure? In Proceedings of the 2006 ACM Symposium on Information, computer
and communications security, pp. 16-25. ACM, ACM, 2006. URL http://dl.acm.org/
citation.cfm?id=1128824.
Marco Barreno, Blaine Nelson, Anthony D Joseph, and JD Tygar. The Security of Machine Learning.
Machine Learning, 81(2):121-148, 2010.
30
Workshop track - ICLR 2017
Table 10: Test accuracy for different training strategies on CIFAR-10 dataset.
Attack power (Eq. (12.6))	Original model	Stability Training	Siamese Training
^0	93.95%	93.81%	93.96%
	78.07%	78.01%	93.88%
霹	61.38%	60.34%	90.13%
	50.07%	49.21%	86.73%
^4	42.86%	41.51%	83.85%
	37.67%	36.33%	81.21%
^6	33.60%	32.08%	78.61%
~1	29.70%	28.09%	76.09%
^8	26.23%	25.11%	73.21%
^9	23.53%	22.43%	69.67%
10	20.92%	20.25%	65.98%
^aRC	4.9798	4.8717	8.9332
ARCA	一	0.4253	0.4155	0.7631
Table 11: Test accuracy for different training strategies on MNIST dataset.
Attack power	Original model	Adversarial Training	Stability Training	Siamese Training
^0	98.98%	98.96%	99.06%	99.03%
	98.75%	98.84%	98.94%	98.84%
	98.44%	98.63%	98.60%	98.47%
	98.10%	98.41%	98.29%	98.16%
^4	97.56%	98.12%	97.80%	97.78%
	97.09%	97.80%	97.47%	97.26%
^6	96.23%	97.38%	97.01%	96.56%
71	95.43%	96.96%	96.23%	95.81%
	94.22%	96.47%	95.37%	95.01%
^9	92.95%	96.06%	94.49%	93.89%
^Tθ	91.53%	95.57%	93.30%	92.76%
^arC	10.5928	10.732	10.6656	10.6357
ARCA 一	0.953159	0.96549	0.960486	0.957503
Battista Biggio, Giorgio Fumera, and Fabio Roli. Adversarial pattern classification using multi-
ple classifiers and randomisation. In Structural, Syntactic, and Statistical Pattern Recognition,
pp. 500-509. Springer, 2008. URL http://link.springer.com/chapter/10.10 07/
978-3-540-89689-0_54.
Battista Biggio, Blaine Nelson, and Pavel Laskov. Poisoning Attacks against Support Vector Machines.
In 29th International Conference on Machine Learning (ICML), 2012.
Battista Biggio, Igino Corona, Davide Maiorca, Blaine Nelson, Nedim Srndic, Pavel Laskov, Giorgio
Giacinto, and Fabio Roli. Evasion attacks against machine learning at test time. In Machine
Learning and Knowledge Discovery in Databases, pp. 387-402. Springer, 2013.
Battista Biggio, Samuel Rota Bulo, Ignazio Pillai, Michele Mura, EyaSu Zemene Mequanint, Marcello
Pelillo, and Fabio Roli. Poisoning complete-linkage hierarchical clustering. In Structural, Syntactic,
and Statistical Pattern Recognition, pp. 42-52. Springer Berlin Heidelberg, 2014.
Mariusz Bojarski, Anna Choromanska, Krzysztof Choromanski, and Yann LeCun. Differentially-and
non-differentially-private random decision trees. arXiv preprint arXiv:1410.6973, 2014.
Jane Bromley, James W Bentz, L6on Bottou, Isabelle Guyon, Yann LeCun, Cliff Moore, Eduard
Sackinger, and Roopak Shah. Signature verification using a “siamese” time delay neural network.
International Journal of Pattern Recognition and Artificial Intelligence, 7(04):669-688, 1993.
Michael Bruckner and Tobias Scheffer. Stackelberg Games for Adversarial Prediction Problems. In
17th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pp. 547-555. ACM,
2011.
31
Workshop track - ICLR 2017
ο 甲)ARC & ARCA value among different methods
■ARC 口 ARCA
0.8 ■	--
-0 Original
-O Stability Training
-•"Siamese Training
2	4	6~
Attack Power
Figure 9: Result of CIFAR-10: (a) Test accuracy under adversarial example attacks: three different
colors for three different training strategies. (Details in Section 12.2) We don’t include the result
of adversarial training because previous adversarial training can’t be used on networks with batch-
normalization. Some tricks of training such networks are released in a recent paper (Kurakin et al.,
2016) (b) ARC and ARCA for three different training strategies under adversarial example attacks.
■ARC 口 ARCA
2
Figure 10: (a) Test accuracy under adversarial example attacks on MNIST dataset: four different
colors for four different training strategies. (Details in Section 12.2) (b) ARC and ARCA for four
different training strategies under adversarial example attacks.
Nicholas Carlini and David Wagner. Defensive distillation is not robust to adversarial examples.
arXiv preprint arXiv:1607.04311, 2016a.
-	O Original
-	© Adversarial Training
-	© Stability Training
♦Siamese Training
32
Workshop track - ICLR 2017
Nicholas Carlini and David Wagner. Towards evaluating the robustness of neural networks. arXiv
preprint arXiv:1608.04644, 2016b.
Nicolo Cesa-Bianchi and Ggbor Lugosi. Prediction, learning, and games. Cambridge University
Press, 2006.
Rainer Dahlhaus. Fitting Time Series Models to Nonstationary Processes. The Annals of Statistics,
25(1):1-37,1997.
Nilesh Dalvi, Pedro Domingos, Sumit Sanghai, Deepak Verma, et al. Adversarial classification. In
Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and
data mining, pp. 99-108. ACM, 2004.
Ofer Dekel, Ohad Shamir, and Lin Xiao. Learning to Classify with Missing and Corrupted Features.
Machine Learning, 81(2):149-178, 2010.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A large-scale
hierarchical image database. In Computer Vision and Pattern Recognition, 2009. CVPR 2009.
IEEE Conference on, pp. 248-255. IEEE, 2009.
James J DiCarlo and David D Cox. Untangling invariant object recognition. Trends in cognitive
sciences, 11(8):333-341, 2007.
James J DiCarlo, Davide Zoccolan, and Nicole C Rust. How does the brain solve visual object
recognition? Neuron, 73(3):415-434, 2012.
John C Duchi, Michael I Jordan, and Martin J Wainwright. Privacy aware learning. Journal of the
ACM (JACM), 61(6):38, 2014.
Richard O Duda, Peter E Hart, and David G Stork. Pattern classification. John Wiley & Sons, 2012.
Cynthia Dwork. Differential Privacy. In Encyclopedia of Cryptography and Security, pp. 338-340.
Springer, 2011.
Alhussein Fawzi, Omar Fawzi, and Pascal Frossard. Fundamental limits on adversarial robustness.
In Proceedings of ICML, Workshop on Deep Learning, number EPFL-CONF-214923, 2015.
Gerald B Folland. Real analysis: modern techniques and their applications. John Wiley & Sons,
2013.
Ji Gao, Beilun Wang, and Yanjun Qi. Deepmask: Masking dnn models for robustness against
adversarial samples. arXiv preprint arXiv:1702.06763, 2017.
Amir Globerson and Sam Roweis. Nightmare at Test Time: Robust Learning by Feature Deletion. In
23rd International Conference on Machine Learning, pp. 353-360. ACM, 2006.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, December 2014. URL http://arxiv.org/abs/
1412.6572. arXiv: 1412.6572.
Kathrin Grosse, Nicolas Papernot, Praveen Manoharan, Michael Backes, and Patrick McDaniel.
Adversarial perturbations against deep neural networks for malware classification. arXiv preprint
arXiv:1606.04435, 2016.
Shixiang Gu and Luca Rigazio. Towards Deep Neural Network Architectures Robust to Adversarial
Examples. arXiv:1412.5068 [cs], December 2014. URL http://arxiv.org/abs/1412.
5068. arXiv: 1412.5068.
Awni Hannun, Carl Case, Jared Casper, Bryan Catanzaro, Greg Diamos, Erich Elsen, Ryan Prenger,
Sanjeev Satheesh, Shubho Sengupta, Adam Coates, and others. DeepSpeech: Scaling up end-to-
end speech recognition. arXiv preprint arXiv:1412.5567, 2014. URL http://arxiv.org/
abs/1412.5567.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image
recognition. arXiv preprint arXiv:1512.03385, 2015.
33
Workshop track - ICLR 2017
Ling Huang, Anthony D Joseph, Blaine Nelson, Benjamin IP Rubinstein, and JD Tygar. Adversarial
machine learning. In 4th ACM Workshop on Security and Artificial Intelligence, pp. 43-58. ACM,
ACM, 2011. URL http://dl.acm.org/citation.cfm?id=2046692.
Chou P Hung, Gabriel Kreiman, Tomaso Poggio, and James J DiCarlo. Fast readout of object identity
from macaque inferior temporal cortex. Science, 310(5749):863-866, 2005.
Jonghoon Jin, Aysegul Dundar, and Eugenio Culurciello. Robust convolutional neural networks
under adversarial noise. arXiv preprint arXiv:1511.06306, 2015.
KO Johnson. Sensory discrimination: decision process. Journal of Neurophysiology, 43(6):1771-
1792, 1980.
Alex Kantchelian, JD Tygar, and Anthony D Joseph. Evasion and hardening of tree ensemble
classifiers. arXiv preprint arXiv:1509.07892, 2015. URL http://arxiv.org/abs/1509.
07892.
John L Kelley. General topology. Springer Science & Business Media, 1975.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. ImageNet Classification with Deep
Convolutional Neural Networks. In Advances in Neural Information Processing Systems, pp.
1097-1105, 2012.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial machine learning at scale. arXiv
preprint arXiv:1611.01236, 2016.
Yann LeCun, Leon Bottou, YoshUa Bengio, and Patrick Haffner. Gradient-based learning applied
to document recognition. Proceedings of the IEEE, 86(11):2278-2324, November 1998. ISSN
0018-9219. doi: 10.1109/5.726791.
Taehoon Lee, Minsuk Choi, and Sungroh Yoon. Manifold regularized deep neural networks using
adversarial examples. arXiv preprint arXiv:1511.06381, 2015.
Bo Li and Yevgeniy Vorobeychik. Feature cross-substitution in adversarial classification. In Advances
in Neural Information Processing Systems, pp. 2087-2095, 2014.
Chencheng Li and Pan Zhou. Differentially private distributed online learning. arXiv preprint
arXiv:1505.06556, 2015.
Wei Liu and Sanjay Chawla. Mining adversarial patterns via regularized loss minimization. Machine
learning, 81(1):69-83, 2010.
Daniel Lowd and Christopher Meek. Adversarial learning. In Proceedings of the eleventh ACM
SIGKDD international conference on Knowledge discovery in data mining, pp. 641-647. ACM,
2005.
Shike Mei and Xiaojin Zhu. The security of latent dirichlet allocation. 2015a.
Shike Mei and Xiaojin Zhu. Some submodular data-poisoning attacks on machine learners. 2015b.
Takeru Miyato, Shin-ichi Maeda, and Koyama Masanori. Distributional smoothing with virtual
adversarial training. ICLR’ 16, 2016.
Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, and Pascal Frossard. Deepfool: a simple and
accurate method to fool deep neural networks. arXiv preprint arXiv:1511.04599, 2015.
Anh Nguyen, Jason Yosinski, and Jeff Clune. Deep neural networks are easily fooled: High confidence
predictions for unrecognizable images. In CVPR. IEEE, 2015.
Richard Nock, Giorgio Patrini, and Arik Friedman. Rademacher observations, private data, and
boosting. arXiv preprint arXiv:1502.02322, 2015.
34
Workshop track - ICLR 2017
Nicolas Papernot, Patrick McDaniel, Somesh Jha, Matt Fredrikson, Z Berkay Celik, and Ananthram
Swami. The limitations of deep learning in adversarial settings. arXiv preprint arXiv:1511.07528,
2015a.
Nicolas Papernot, Patrick McDaniel, Xi Wu, Somesh Jha, and Ananthram Swami. Distillation as a
defense to adversarial perturbations against deep neural networks. arXiv preprint arXiv:1511.04508,
November 2015b. URL http://arxiv.org/abs/1511.04508. arXiv: 1511.04508.
Nicolas Papernot, Patrick McDaniel, Ian Goodfellow, Somesh Jha, Z Berkay Celik, and Ananthram
Swami. Practical black-box attacks against deep learning systems using adversarial examples.
arXiv preprint arXiv:1602.02697, 2016a.
Nicolas Papernot, Patrick McDaniel, Arunesh Sinha, and Michael Wellman. Towards the science of
security and privacy in machine learning. arXiv preprint arXiv:1611.03814, 2016b.
Arun Rajkumar and Shivani Agarwal. A differentially private stochastic gradient descent algorithm
for multiparty classification. In International Conference on Artificial Intelligence and Statistics,
pp. 933-941, 2012.
N. Rndic and P. Laskov. Practical Evasion of a Learning-Based Classifier: A Case Study. In 2014
IEEE Symposium on Security and Privacy (SP), pp. 197-211, May 2014. doi: 10.1109/SP.2014.20.
Pierre Sermanet, David Eigen, Xiang Zhang, Michael Mathieu, Rob Fergus, and Yann LeCun.
Overfeat: Integrated recognition, localization and detection using convolutional networks. arXiv
preprint arXiv:1312.6229, 2013.
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image
recognition. arXiv preprint arXiv:1409.1556, 2014.
Arunesh Sinha, Debarun Kar, and Milind Tambe. Learning adversary behavior in security games:
A pac model perspective. In Proceedings of the 2016 International Conference on Autonomous
Agents & Multiagent Systems, pp. 214-222. International Foundation for Autonomous Agents and
Multiagent Systems, 2016.
Ben Stoddard, Yan Chen, and Ashwin Machanavajjhala. Differentially private algorithms for
empirical machine learning. arXiv preprint arXiv:1411.5428, 2014.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
URL http://arxiv.org/abs/1312.6199.
William Uther and Manuela Veloso. Adversarial reinforcement learning. Technical report, Technical
report, Carnegie Mellon University, 1997. Unpublished, 1997.
Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and Pierre-Antoine Manzagol. Extracting and
composing robust features with denoising autoencoders. In Proceedings of the 25th international
conference on Machine learning, pp. 1096-1103. ACM, 2008.
Huang Xiao, Battista Biggio, Gavin Brown, Giorgio Fumera, Claudia Eckert, and Fabio Roli. Is
feature selection secure against training data poisoning? In Proceedings of the 32nd International
Conference on Machine Learning (ICML-15), pp. 1689-1698, 2015.
Pengtao Xie, Misha Bilenko, Tom Finley, Ran Gilad-Bachrach, Kristin Lauter, and Michael Naehrig.
Crypto-nets: Neural networks over encrypted data. arXiv preprint arXiv:1412.6181, 2014.
Eric P. Xing, Michael I. Jordan, Stuart J Russell, and Andrew Y. Ng. Distance metric learning with
application to clustering with side-information. In S. Becker, S. Thrun, and K. Obermayer (eds.),
Advances in Neural Information Processing Systems 15, pp. 521-528. MIT Press, 2003.
Weilin Xu, Yanjun Qi, and David Evans. Automatically evading classifiers. In Proceedings of the
Network and Distributed Systems Symposium, 2016.
Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. arXiv preprint arXiv:1605.07146,
2016.
35
Workshop track - ICLR 2017
Fei Zhang, Patrick PK Chan, Battista Biggio, Daniel S. Yeung, and Fabio Roli. Adversarial Feature
Selection against Evasion Attacks. IEEE Transactions on Cybernetics, PP(1), 2015.
Stephan Zheng, Yang Song, Thomas Leung, and Ian Goodfellow. Improving the robustness of deep
neural networks via stability training. arXiv preprint arXiv:1604.04326, 2016.
36