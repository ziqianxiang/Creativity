Published as a conference paper at ICLR 2017
On Large-Batch Training for Deep Learning
Generalization Gap and Sharp Minima
Nitish Shirish Keskar*
Northwestern University
Evanston, IL 60208
keskar.nitish@u.northwestern.edu
Jorge Nocedal
Northwestern University
Evanston, IL 60208
j-nocedal@northwestern.edu
Ping Tak Peter Tang
Intel Corporation
Santa Clara, CA 95054
peter.tang@intel.com
Dheevatsa Mudigere
Intel Corporation
Bangalore, India
dheevatsa.mudigere@intel.com
Mikhail Smelyanskiy
Intel Corporation
Santa Clara, CA 95054
mikhail.smelyanskiy@intel.com
Ab stract
The stochastic gradient descent (SGD) method and its variants are algorithms of
choice for many Deep Learning tasks. These methods operate in a small-batch
regime wherein a fraction of the training data, say 32-512 data points, is sampled
to compute an approximation to the gradient. It has been observed in practice that
when using a larger batch there is a degradation in the quality of the model, as
measured by its ability to generalize. We investigate the cause for this generaliza-
tion drop in the large-batch regime and present numerical evidence that supports
the view that large-batch methods tend to converge to sharp minimizers of the
training and testing functions—and as is well known, sharp minima lead to poorer
generalization. In contrast, small-batch methods consistently converge to flat min-
imizers, and our experiments support a commonly held view that this is due to the
inherent noise in the gradient estimation. We discuss several strategies to attempt
to help large-batch methods eliminate this generalization gap.
1	Introduction
Deep Learning has emerged as one of the cornerstones of large-scale machine learning. Deep Learn-
ing models are used for achieving state-of-the-art results on a wide variety of tasks including com-
puter vision, natural language processing and reinforcement learning; see (Bengio et al., 2016) and
the references therein. The problem of training these networks is one of non-convex optimization.
Mathematically, this can be represented as:
min f (x) := -- fi(x),	(1)
x∈Rn JL M 乙 J 八''	」
i=1
where f is a loss function for data point i ∈ {1,2,…，M} which captures the deviation of the
model prediction from the data, and x is the vector of weights being optimized. The process of
optimizing this function is also called training of the network. Stochastic Gradient Descent (SGD)
(Bottou, 1998; Sutskever et al., 2013) and its variants are often used for training deep networks.
*Work was performed when author was an intern at Intel Corporation
1
Published as a conference paper at ICLR 2017
These methods minimize the objective function f by iteratively taking steps of the form:
xk+1 = xk - αk
|B1k| X Vfi(Xk)}
i∈Bk
(2)
where Bk ⊂ {1, 2,…,M} is the batch sampled from the data set and ak is the step size at iteration
k. These methods can be interpreted as gradient descent using noisy gradients, which and are often
referred to as mini-batch gradients with batch size |Bk|. SGD and its variants are employed in a
small-batch regime, where ∖Bk |《M and typically ∖Bk | ∈ {32, 64, ∙ ∙ ∙ , 512}. These ConfigUra-
tions have been successfully used in practice for a large number of applications; see e.g. (Simonyan
& Zisserman, 2014; Graves et al., 2013; Mnih et al., 2013). Many theoretical properties of these
methods are known. These inclUde gUarantees of: (a) convergence to minimizers of strongly-convex
fUnctions and to stationary points for non-convex fUnctions (BottoU et al., 2016), (b) saddle-point
avoidance (Ge et al., 2015; Lee et al., 2016), and (c) robUstness to inpUt data (Hardt et al., 2015).
Stochastic gradient methods have, however, a major drawback: owing to the seqUential natUre of the
iteration and small batch sizes, there is limited avenUe for parallelization. While some efforts have
been made to parallelize SGD for Deep Learning (Dean et al., 2012; Das et al., 2016; Zhang et al.,
2015), the speed-Ups and scalability obtained are often limited by the small batch sizes. One natU-
ral avenUe for improving parallelism is to increase the batch size ∖Bk∖. This increases the amoUnt
of compUtation per iteration, which can be effectively distribUted. However, practitioners have ob-
served that this leads to a loss in generalization performance; see e.g. (LeCUn et al., 2012). In other
words, the performance of the model on testing data sets is often worse when trained with large-
batch methods as compared to small-batch methods. In oUr experiments, we have foUnd the drop in
generalization (also called generalization gap) to be as high as 5% even for smaller networks.
In this paper, we present nUmerical resUlts that shed light into this drawback of large-batch methods.
We observe that the generalization gap is correlated with a marked sharpness of the minimizers
obtained by large-batch methods. This motivates efforts at remedying the generalization problem,
as a training algorithm that employs large batches withoUt sacrificing generalization performance
woUld have the ability to scale to a mUch larger nUmber of nodes than is possible today. This coUld
potentially redUce the training time by orders-of-magnitUde; we present an idealized performance
model in the Appendix C to sUpport this claim.
The paper is organized as follows. In the remainder of this section, we define the notation Used in
this paper, and in Section 2 we present oUr main findings and their sUpporting nUmerical evidence.
In Section 3 we explore the performance of small-batch methods, and in Section 4 we briefly discUss
the relationship between oUr resUlts and recent theoretical work. We conclUde with open qUestions
concerning the generalization gap, sharp minima, and possible modifications to make large-batch
training viable. In Appendix E, we present some attempts to overcome the problems of large-batch
training.
1.1	Notation
We Use the notation fi to denote the composition of loss fUnction and a prediction fUnction corre-
sponding to the ith data point. The vector of weights is denoted by x and is sUbscripted by k to
denote an iteration. We Use the term small-batch (SB) method to denote SGD, or one of its variants
like ADAM (Kingma & Ba, 2015) and ADAGRAD (DUchi et al., 2011), with the proviso that the
gradient approximation is based on a small mini-batch. In oUr setUp, the batch Bk is randomly sam-
pled and its size is kept fixed for every iteration. We Use the term large-batch (LB) method to denote
any training algorithm that Uses a large mini-batch. In oUr experiments, ADAM is Used to explore
the behavior of both a small or a large batch method.
2	Drawbacks of Large-Batch Methods
2.1	Our Main Observation
As mentioned in Section 1, practitioners have observed a generalization gap when Using large-batch
methods for training deep learning models. Interestingly, this is despite the fact that large-batch
methods UsUally yield a similar valUe of the training fUnction as small-batch methods. One may pUt
2
Published as a conference paper at ICLR 2017
forth the following as possible causes for this phenomenon: (i) LB methods over-fit the model; (ii)
LB methods are attracted to saddle points; (iii) LB methods lack the explorative properties of SB
methods and tend to zoom-in on the minimizer closest to the initial point; (iv) SB and LB methods
converge to qualitatively different minimizers with differing generalization properties. The data
presented in this paper supports the last two conjectures.
The main observation of this paper is as follows:
The lack of generalization ability is due to the fact that large-batch methods tend to converge
to sharp minimizers of the training function. These minimizers are characterized by a signif-
icant number of large positive eigenvalues in V2f (x), and tend to generalize less well. In
contrast, small-batch methods converge to flat minimizers characterized by having numerous
small eigenvalues of V2f(x). We have observed that the loss function landscape of deep neural
networks is such that large-batch methods are attracted to regions with sharp minimizers and
that, unlike small-batch methods, are unable to escape basins of attraction of these minimizers.
The concept of sharp and flat minimizers have been discussed in the statistics and machine learning
literature. (Hochreiter & Schmidhuber, 1997) (informally) define a flat minimizer X as one for which
the function varies slowly in a relatively large neighborhood of X. In contrast, a sharp minimizer X
is such that the function increases rapidly in a small neighborhood of X. A flat minimum can be de-
scribed with low precision, whereas a sharp minimum requires high precision. The large sensitivity
of the training function at a sharp minimizer negatively impacts the ability of the trained model to
generalize on new data; see Figure 1 for a hypothetical illustration. This can be explained through
the lens of the minimum description length (MDL) theory, which states that statistical models that
require fewer bits to describe (i.e., are of low complexity) generalize better (Rissanen, 1983). Since
flat minimizers can be specified with lower precision than to sharp minimizers, they tend to have bet-
ter generalization performance. Alternative explanations are proffered through the Bayesian view
of learning (MacKay, 1992), and through the lens of free Gibbs energy; see e.g. Chaudhari et al.
(2016).
Figure 1: A Conceptual Sketch of Flat and Sharp Minima. The Y-axis indicates value of the loss
function and the X-axis the variables (parameters)
2.2	Numerical Experiments
In this section, we present numerical results to support the observations made above. To this end,
we make use of the visualization technique employed by (Goodfellow et al., 2014b) and a proposed
heuristic metric of sharpness (Equation (4)). We consider 6 multi-class classification network con-
figurations for our experiments; they are described in Table 1. The details about the data sets and
network configurations are presented in Appendices A and B respectively. As is common for such
problems, we use the mean cross entropy loss as the objective function f.
The networks were chosen to exemplify popular configurations used in practice like AlexNet
(Krizhevsky et al., 2012) and VGGNet (Simonyan & Zisserman, 2014). Results on other networks
3
Published as a conference paper at ICLR 2017
Table 1: Network Configurations
Name	Network Type	Architecture	Data set
F1	Fully Connected	Section B.1	MNIST (LeCun et al., 1998a)
F2	Fully Connected	Section B.2	TIMIT (Garofolo et al., 1993)
C1	(Shallow) Convolutional	Section B.3	CIFAR-10 (Krizhevsky & Hinton, 2009)
C2	(Deep) Convolutional	Section B.4	CIFAR-10
C3	(Shallow) Convolutional	Section B.3	CIFAR-100 (Krizhevsky & Hinton, 2009)
C4	(Deep) Convolutional	Section B.4	CIFAR-100
and using other initialization strategies, activation functions, and data sets showed similar behavior.
Since the goal of our work is not to achieve state-of-the-art accuracy or time-to-solution on these
tasks but rather to characterize the nature of the minima for LB and SB methods, we only describe
the final testing accuracy in the main paper and ignore convergence trends.
For all experiments, we used 10% of the training data as batch size for the large-batch experiments
and 256 data points for small-batch experiments. We used the ADAM optimizer for both regimes.
Experiments with other optimizers for the large-batch experiments, including ADAGRAD (Duchi
et al., 2011), SGD (Sutskever et al., 2013) and adaQN (Keskar & Berahas, 2016), led to similar
results. All experiments were conducted 5 times from different (uniformly distributed random)
starting points and we report both mean and standard-deviation of measured quantities. The baseline
performance for our setup is presented Table 2. From this, we can observe that on all networks, both
approaches led to high training accuracy but there is a significant difference in the generalization
performance. The networks were trained, without any budget or limits, until the loss function ceased
to improve.
Table 2: Performance of small-batch (SB) and large-batch (LB) variants of ADAM on the 6 networks
listed in Table 1
Name	Training Accuracy		Testing Accuracy	
	SB	LB	SB	LB
F1	99.66% ± 0.05%	99.92% ± 0.01%	98.03% ± 0.07%	97.81% ± 0.07%
F2	99.99% ± 0.03%	98.35% ± 2.08%	64.02% ± 0.2%	59.45% ± 1.05%
C1	99.89% ± 0.02%	99.66% ± 0.2%	80.04% ± 0.12%	77.26% ± 0.42%
C2	99.99% ± 0.04%	99.99% ± 0.01%	89.24% ± 0.12%	87.26% ± 0.07%
C3	99.56% ± 0.44%	99.88% ± 0.30%	49.58% ± 0.39%	46.45% ± 0.43%
C4	99.10% ± 1.23%	99.57% ± 1.84%	63.08% ± 0.5%	57.81% ± 0.17%
We emphasize that the generalization gap is not due to over-fitting or over-training as commonly
observed in statistics. This phenomenon manifest themselves in the form of a testing accuracy curve
that, at a certain iterate peaks, and then decays due to the model learning idiosyncrasies of the
training data. This is not What We observe in our experiments; see Figure 2 for the training-testing
curve of the F2 and C1 networks, which are representative of the rest. As such, early-stopping
heuristics aimed at preventing models from over-fitting Would not help reduce the generalization
gap. The difference betWeen the training and testing accuracies for the netWorks is due to the
specific choice of the netWork (e.g. AlexNet, VGGNet etc.) and is not the focus of this study.
Rather, our goal is to study the source of the testing performance disparity of the tWo regimes, SB
and LB, on a given netWork model.
2.2	. 1 Parametric Plots
We first present parametric 1-D plots of the function as described in (GoodfelloW et al., 2014b).
Let x? and x? indicate the solutions obtained by running ADAM using small and large batch sizes
respectively. We plot the loss function, on both training and testing data sets, along a line-segment
containing the two points. Specifically, for α ∈ [-1,2], we plot the function f (αx? + (1 - α)x?)
and also superimpose the classification accuracy at the intermediate points; see Figure 31. For this
1The code to reproduce the parametric plot on exemplary networks can be found in our GitHub repository:
https://github.com/keskarnitish/large-batch-training.
4
Published as a conference paper at ICLR 2017
Figure 2: Training and testing accuracy for SB and LB methods as a function of epochs.
experiment, we randomly chose a pair of SB and LB minimizers from the 5 trials used to generate
the data in Table 2. The plots show that the LB minima are strikingly sharper than the SB minima
in this one-dimensional manifold. The plots in Figure 3 only explore a linear slice of the function,
but in Figure 7 in Appendix D, We plot f (sin(α2∏)x? + cos(α2∏)x?) to monitor the function along a
curved path between the two minimizers . There too, the relative sharpness of the minima is evident.
2.2.2 Sharpness of Minima
So far, We have used the term sharp minimizer loosely, but We noted that this concept has received
attention in the literature (Hochreiter & Schmidhuber, 1997). Sharpness of a minimizer can be
characterized by the magnitude of the eigenvalues of V2 f (x), but given the prohibitive cost of this
computation in deep learning applications, We employ a sensitivity measure that, although imperfect,
is computationally feasible, even for large netWorks. It is based on exploring a small neighborhood
ofa solution and computing the largest value that the function f can attain in that neighborhood. We
use that value to measure the sensitivity of the training function at the given local minimizer. NoW,
since the maximization process is not accurate, and to avoid being mislead by the case When a large
value of f is attained only in a tiny subspace of Rn , We perform the maximization both in the entire
space Rn as Well as in random manifolds. For that purpose, We introduce an n × p matrix A, Whose
columns are randomly generated. Here p determines the dimension of the manifold, Which in our
experiments is chosen as p = 100.
Specifically, let C denote abox around the solution over Which the maximization off is performed,
and let A ∈ Rn×p be the matrix defined above. In order to ensure invariance of sharpness to problem
dimension and sparsity, We define the constraint set C as:
G = {z ∈ Rp ： -e(∣(A+x)i∣ + 1) ≤ Zi ≤ e(∣(A+x)i∣ + 1) ∀i ∈ {1, 2,…，p}},	(3)
Where A+ denotes the pseudo-inverse of A. Thus controls the size of the box. We can noW define
our measure of sharpness (or sensitivity).
Metric 2.1. Givenx ∈ Rn, > 0 and A ∈ Rn×p, we define the (C, A)-sharpness of f at x as:
Φx,f(e,A) := (m- f?- f(X)X 100.	(4)
Unless specified otherWise, We use this metric for sharpness for the rest of the paper; ifA is not spec-
ified, it is assumed to be the identity matrix, In . (We note in passing that, in the convex optimization
literature, the term sharp minimum has a different definition (Ferris, 1988), but that concept is not
useful for our purposes.)
In Tables 3 and 4, We present the values of the sharpness metric (4) for the minimizers of the various
problems. Table 3 explores the full-space (i.e., A = In) Whereas Table 4 uses a randomly sampled
n X 100 dimensional matrix A. We report results with two values of e, (10-3,5 ∙ 10-4). In all
experiments, We solve the maximization problem in Equation (4) inexactly by applying 10 iterations
of L-BFGS-B (Byrd et al., 1995). This limit on the number of iterations was necessitated by the
5
Published as a conference paper at ICLR 2017
Ado-Uuw SSO.IU
>US3UU<
Ado-UUW sso」。
>uεsuu<
alpha
(c) C1
>US3UU<
Mooooooooo
198765432 Io
>US3UU<
Ado∙quw SS0.O
(e) C3
Figure 3: Parametric Plots - Linear (Left vertical axis corresponds to cross-entropy loss, f, and
right vertical axis corresponds to classification accuracy; solid line indicates training data set and
dashed line indicated testing data set); α = 0 corresponds to the SB minimizer and α = 1 to the LB
minimizer.
>US3UU<
Ado-UUW sso」。
(f) C4
A3enu3v

large cost of evaluating the true objective f. Both tables show a 1-2 order-of-magnitude difference
between the values of our metric for the SB and LB regimes. These results reinforce the view that
the solutions obtained by a large-batch method defines points of larger sensitivity of the training
function. In Appedix E, we describe approaches to attempt to remedy this generalization problem
of LB methods. These approaches include data augmentation, conservative training and adversarial
training. Our preliminary findings show that these approaches help reduce the generalization gap
but still lead to relatively sharp minimizers and as such, do not completely remedy the problem.
Note that Metric 2.1 is closely related to the spectrum of V2f (x). Assuming e to be small enough,
when A = In, the value (4) relates to the largest eigenvalue of V2f (x) and when A is randomly
sampled it approximates the Ritz value of V2f(x) projected onto the column-space of A.
6
Published as a conference paper at ICLR 2017
Table 3: Sharpness of Minima in Full Space; is defined in (3).
	€ = SB	10-3 LB	€ = SB	5∙10-4 LB
F1	1.23 ± 0.83	205.14 ± 69.52	0.61 ± 0.27	42.90 ± 17.14
F2	1.39 ± 0.02	310.64 ± 38.46	0.90 ± 0.05	93.15 ± 6.81
C1	28.58 ± 3.13	707.23 ± 43.04	7.08 ± 0.88	227.31 ± 23.23
C2	8.68 ± 1.32	925.32 ± 38.29	2.07 ± 0.86	175.31 ± 18.28
C3	29.85 ± 5.98	258.75 ± 8.96	8.56 ± 0.99	105.11 ± 13.22
C4	12.83 ± 3.84	421.84 ± 36.97	4.07 ± 0.87	109.35 ± 16.57
Table 4: Sharpness of Minima in Random Subspaces of Dimension 100
	€= SB	10-3 LB	€ = 5∙10-4	
			SB	LB
~w	0.11 ± 0.00	-9.22 ± 0.56-	0.05 ± 0.00	9.17 ± 0.14
F2	0.29 ± 0.02	23.63 ± 0.54	0.05 ± 0.00	6.28 ± 0.19
C1	2.18 ± 0.23	137.25 ± 21.60	0.71 ± 0.15	29.50 ± 7.48
C	0.95 ± 0.34	25.09 ± 2.61	0.31 ± 0.08	5.82 ± 0.52
C	17.02 ± 2.20	236.03 ± 31.26	4.03 ± 1.45	86.96 ± 27.39
C4	6.05 ± 1.13	72.99 ± 10.96	1.89 ± 0.33	19.85 ± 4.12
We conclude this section by noting that the sharp minimizers identified in our experiments do not
resemble a cone, i.e., the function does not increase rapidly along all (or even most) directions. By
sampling the loss function in a neighborhood of LB solutions, we observe that it rises steeply only
along a small dimensional subspace (e.g. 5% of the whole space); on most other directions, the
function is relatively flat.
3 Success of Small-Batch Methods
It is often reported that when increasing the batch size for a problem, there exists a threshold after
which there is a deterioration in the quality of the model. This behavior can be observed for the F2
and C1 networks in Figure 4. In both of these experiments, there is a batch size (≈ 15000 for F2 and
≈ 500 for C1) after which there is a large drop in testing accuracy. Notice also that the upward drift
in value of the sharpness is considerably reduced around this threshold. Similar thresholds exist for
the other networks in Table 1.
Let us now consider the behavior of SB methods, which use noisy gradients in the step computation.
From the results reported in the previous section, it appears that noise in the gradient pushes the
iterates out of the basin of attraction of sharp minimizers and encourages movement towards a flatter
minimizer where noise will not cause exit from that basin. When the batch size is greater than the
threshold mentioned above, the noise in the stochastic gradient is not sufficient to cause ejection
from the initial basin leading to convergence to sharper a minimizer.
To explore that in more detail, consider the following experiment. We train the network for 100
epochs using ADAM with a batch size of 256, and retain the iterate after each epoch in memory.
Using these 100 iterates as starting points we train the network using a LB method for 100 epochs
and receive a 100 piggybacked (or warm-started) large-batch solutions. We plot in Figure 5 the
testing accuracy and sharpness of these large-batch solutions, along with the testing accuracy of the
small-batch iterates. Note that when warm-started with only a few initial epochs, the LB method
does not yield a generalization improvement. The concomitant sharpness of the iterates also stays
high. On the other hand, after certain number of epochs of warm-starting, the accuracy improves
and sharpness of the large-batch iterates drop. This happens, apparently, when the SB method has
ended its exploration phase and discovered a flat minimizer; the LB method is then able to converge
towards it, leading to good testing accuracy.
It has been speculated that LB methods tend to be attracted to minimizers close to the starting point
x0 , whereas SB methods move away and locate minimizers that are farther away. Our numerical
7
Published as a conference paper at ICLR 2017
10000	20000	30000 40000	50000	60000
Batch Size
(a) F2
Figure 4: Testing Accuracy and Sharpness v/s Batch Size. The X-axis corresponds to the batch size
used for training the network for 100 epochs, left Y-axis corresponds to the testing accuracy at the
final iterate and right Y-axis corresponds to the sharpness of that iterate. We report sharpness for
two values of e: 10-3 and 5 ∙ 10-4.
75.5
0
76.0
O
79
5 O
a a
7 7
O 5
Zt
7 7
A3εnxq ctc≡3f
1000
2000	3000
Batch Size
(b) C1
Ss8ud」eus
lololololololo
QUQQQQO
8 7 6 5 4 3 2
100
> 70
⅛ 60
< 50
ξ 40
l≡ 30
爆某10-110j10-310j∙
ssueus
(a) F2
Figure 5: Warm-starting experiments. The upper figures report the testing accuracy of the SB
method (blue line) and the testing accuracy of the warm started (piggybacked) LB method (red line),
as a function of the number of epochs of the SB method. The lower figures plot the sharpness mea-
sure (4) for the solutions obtained by the piggybacked LB method v/s the number of warm-starting
epochs of the SB method.
5050503 2 1 O 1 2
8877660000^^
AU2nx< 6u 一81 Illlll
ssueus
IOO
20	40	60	80
Epoch of SB TYaInIng
(b) C1
8
Published as a conference paper at ICLR 2017
(a) F2
IO3
IO2
IO1
IO0
∙→ LB - IE-3
a * LB - 5E-4
♦ ♦ SB - IE-3
* * SB - 5E-4
Cross Entropy
(b) C1
Figure 6: Sharpness v/s Cross Entropy Loss for SB and LB methods.
experiments support this view: We observed that the ratio of kx? - xok2 and ||x? - x° k2 was in the
range of 3-10.
In order to further illustrate the qualitative difference between the solutions obtained by SB and LB
methods, we plot in Figure 6 our sharpness measure (4) against the loss function (cross entropy)
for one random trial of the F2 and C1 networks. For larger values of the loss function, i.e., near
the initial point, SB and LB method yield similar values of sharpness. As the loss function reduces,
the sharpness of the iterates corresponding to the LB method rapidly increases, whereas for the SB
method the sharpness stays relatively constant initially and then reduces, suggesting an exploration
phase followed by convergence to a flat minimizer.
4 Discussion and Conclusion
In this paper, we present numerical experiments that support the view that convergence to sharp
minimizers gives rise to the poor generalization of large-batch methods for deep learning. To this
end, we provide one-dimensional parametric plots and perturbation (sharpness) measures fora vari-
ety of deep learning architectures. In Appendix E, we describe our attempts to remedy the problem,
including data augmentation, conservative training and robust optimization. Our preliminary inves-
tigation suggests that these strategies do not correct the problem; they improve the generalization of
large-batch methods but still lead to relatively sharp minima. Another prospective remedy includes
the use of dynamic sampling where the batch size is increased gradually as the iteration progresses
(Byrd et al., 2012; Friedlander & Schmidt, 2012). The potential viability of this approach is sug-
gested by our warm-starting experiments (see Figure 5) wherein high testing accuracy is achieved
using a large-batch method that is warm-start with a small-batch method.
Recently, a number of researchers have described interesting theoretical properties of the loss sur-
face of deep neural networks; see e.g. (Choromanska et al., 2015; Soudry & Carmon, 2016; Lee
et al., 2016). Their work shows that, under certain regularity assumptions, the loss function of deep
learning models is fraught with many local minimizers and that many of these minimizers corre-
spond to a similar loss function value. Our results are in alignment these observations since, in our
experiments, both sharp and flat minimizers have very similar loss function values. We do not know,
however, if the theoretical models mentioned above provide information about the existence and
density of sharp minimizers of the loss surface.
Our results suggest some questions: (a) can one prove that large-batch (LB) methods typically con-
verge to sharp minimizers of deep learning training functions? (In this paper, we only provided some
numerical evidence.); (b) what is the relative density of the two kinds of minima?; (c) can one design
neural network architectures for various tasks that are suitable to the properties of LB methods?; (d)
can the networks be initialized in a way that enables LB methods to succeed?; (e) is it possible,
through algorithmic or regulatory means to steer LB methods away from sharp minimizers?
9
Published as a conference paper at ICLR 2017
References
Yoshua Bengio, Ian Goodfellow, and Aaron Courville. Deep learning. Book in preparation for MIT
Press, 2016. URL http://www.deeplearningbook.org.
Dimitris Bertsimas, Omid Nohadani, and Kwong Meng Teo. Robust optimization for unconstrained
simulation-based problems. Operations Research, 58(1):161-178,2010.
Leon Bottou. Online learning and stochastic approximations. On-line learning in neural networks,
17(9):142, 1998.
Leon Bottou, Frank E Curtis, and Jorge Nocedal. Optimization methods for large-scale machine
learning. arXiv preprint arXiv:1606.04838, 2016.
Richard H Byrd, Peihuang Lu, Jorge Nocedal, and Ciyou Zhu. A limited memory algorithm for
bound constrained optimization. SIAM Journal on Scientific Computing, 16(5):1190-1208, 1995.
Richard H Byrd, Gillian M Chin, Jorge Nocedal, and Yuchen Wu. Sample size selection in opti-
mization methods for machine learning. Mathematical programming, 134(1):127-155, 2012.
Pratik Chaudhari, Anna Choromanska, Stefano Soatto, and Yann LeCun. Entropy-sgd: Biasing
gradient descent into wide valleys. arXiv preprint arXiv:1611.01838, 2016.
Anna Choromanska, Mikael Henaff, Michael Mathieu, Gerard Ben Arous, and Yann LeCun. The
loss surfaces of multilayer networks. In AISTATS, 2015.
Dipankar Das, Sasikanth Avancha, Dheevatsa Mudigere, Karthikeyan Vaidynathan, Srinivas Srid-
haran, Dhiraj Kalamkar, Bharat Kaul, and Pradeep Dubey. Distributed deep learning using syn-
chronous stochastic gradient descent. arXiv preprint arXiv:1602.06709, 2016.
Jeffrey Dean, Greg Corrado, Rajat Monga, Kai Chen, Matthieu Devin, Mark Mao, Andrew Senior,
Paul Tucker, Ke Yang, Quoc V Le, et al. Large scale distributed deep networks. In Advances in
neural information processing systems, pp. 1223-1231, 2012.
J. Duchi, E. Hazan, and Y. Singer. Adaptive subgradient methods for online learning and stochastic
optimization. The Journal of Machine Learning Research, 12:2121-2159, 2011.
Michael Charles Ferris. Weak sharp minima and penalty functions in mathematical programming.
PhD thesis, University of Cambridge, 1988.
Michael P Friedlander and Mark Schmidt. Hybrid deterministic-stochastic methods for data fitting.
SIAM Journal on Scientific Computing, 34(3):A1380-A1405, 2012.
John S Garofolo, Lori F Lamel, William M Fisher, Jonathan G Fiscus, David S Pallett, Nancy L
Dahlgren, and Victor Zue. Timit acoustic-phonetic continuous speech corpus. Linguistic data
consortium, Philadelphia, 33, 1993.
Rong Ge, Furong Huang, Chi Jin, and Yang Yuan. Escaping from saddle pointsonline stochastic
gradient for tensor decomposition. In Proceedings of The 28th Conference on Learning Theory,
pp. 797-842, 2015.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014a.
Ian J Goodfellow, Oriol Vinyals, and Andrew M Saxe. Qualitatively characterizing neural network
optimization problems. arXiv preprint arXiv:1412.6544, 2014b.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recur-
rent neural networks. In 2013 IEEE international conference on acoustics, speech and signal
processing, pp. 6645-6649. IEEE, 2013.
M. Hardt, B. Recht, and Y. Singer. Train faster, generalize better: Stability of stochastic gradient
descent. arXiv preprint arXiv:1509.01240, 2015.
Sepp Hochreiter and Jurgen Schmidhuber. Flat minima. Neural Computation, 9(1):142, 1997.
10
Published as a conference paper at ICLR 2017
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015.
Nitish Shirish Keskar and Albert S. Berahas. adaQN: An Adaptive Quasi-Newton Algorithm for
Training RNNs, pp. 1-16. Springer International Publishing, Cham, 2016.
D. Kingma and J. Ba. Adam: A method for stochastic optimization. In International Conference on
Learning Representations (ICLR 2015), 2015.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
lutional neural networks. In Advances in neural information processing systems, pp. 1097-1105,
2012.
Yann LeCun, Leon Bottou, YoshUa Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998a.
Yann LeCun, Corinna Cortes, and Christopher JC Burges. The mnist database of handwritten digits,
1998b.
Yann A LeCun, Leon Bottou, Genevieve B Orr, and Klaus-Robert Muller. Efficient backprop. In
Neural networks: Tricks of the trade, pp. 9-48. Springer, 2012.
Jason D Lee, Max Simchowitz, Michael I Jordan, and Benjamin Recht. Gradient descent converges
to minimizers. University of California, Berkeley, 1050:16, 2016.
Mu Li, Tong Zhang, Yuqiang Chen, and Alexander J Smola. Efficient mini-batch training for
stochastic optimization. In Proceedings of the 20th ACM SIGKDD international conference on
Knowledge discovery and data mining, pp. 661-670. ACM, 2014.
David JC MacKay. A practical bayesian framework for backpropagation networks. Neural compu-
tation, 4(3):448-472, 1992.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wier-
stra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.
Hossein Mobahi. Training recurrent neural networks by diffusion. arXiv preprint arXiv:1601.04114,
2016.
Daniel Povey, Arnab Ghoshal, Gilles Boulianne, Lukas Burget, Ondrej Glembek, Nagendra Goel,
Mirko Hannemann, Petr Motlicek, Yanmin Qian, Petr Schwarz, et al. The kaldi speech recognition
toolkit. In IEEE 2011 workshop on automatic speech recognition and understanding, number
EPFL-CONF-192584. IEEE Signal Processing Society, 2011.
Jorma Rissanen. A universal prior for integers and estimation by minimum description length. The
Annals of statistics, pp. 416-431, 1983.
Uri Shaham, Yutaro Yamada, and Sahand Negahban. Understanding adversarial training: Increasing
local stability of neural nets through robust optimization. arXiv preprint arXiv:1511.05432, 2015.
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image
recognition. arXiv preprint arXiv:1409.1556, 2014.
Daniel Soudry and Yair Carmon. No bad local minima: Data independent training error guarantees
for multilayer neural networks. arXiv preprint arXiv:1605.08361, 2016.
Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: a simple way to prevent neural networks from overfitting. Journal of Machine Learning
Research, 15(1):1929-1958, 2014.
I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization and momentum
in deep learning. In Proceedings of the 30th International Conference on Machine Learning
(ICML 2013), pp. 1139-1147, 2013.
11
Published as a conference paper at ICLR 2017
Sixin Zhang, Anna E Choromanska, and Yann LeCun. Deep learning with elastic averaging sgd. In
Advances in Neural Information Processing Systems, pp. 685-693, 2015.
Stephan Zheng, Yang Song, Thomas Leung, and Ian Goodfellow. Improving the robustness of deep
neural networks via stability training. arXiv preprint arXiv:1604.04326, 2016.
A Details about Data Sets
We summarize the data sets used in our experiments in Table 5. TIMIT is a speech recognition
data set which is pre-processed using Kaldi (Povey et al., 2011) and trained using a fully-connected
network. The rest of the data sets are used without any pre-processing.
Table 5: Data Sets
Data Set	# Data Points		# Features	# Classes	Reference
	Train	Test			
MNIST	60000	10000	28 X 28	10	(LeCUn et al.,1998a;b)
TIMIT	721329	310621	360	1973	(GarofoloetaL,1993)
CIFAR-10	50000	10000	32 × 32	10	(KrizhevSky & Hinton, 2009)
CIFAR-100	50000	10000	32 × 32	100	(KrizhevSky & Hinton, 2009)
B	Architecture of Networks
B.1	NETWORK F1
For this network, we use a 784-dimensional input layer followed by 5 batch-normalized (Ioffe &
Szegedy, 2015) layers of 512 neurons each with ReLU activations. The output layer consists of 10
neurons with the softmax activation.
B.2	NETWORK F2
The network architecture for F2 is similar to F1 . We use a 360-dimensional input layer followed by
7 batch-normalized layers of 512 neurons with ReLU activation. The output layer consists of 1973
neurons with the softmax activation.
B.3	NETWORKS C1 AND C3
The C1 network is a modified version of the popular AlexNet configuration (Krizhevsky et al.,
2012). For simplicity, denote a stack of n convolution layers of a filters and a Kernel size of b × c
with stride length ofd as n × [a, b, c, d]. The C1 configuration uses 2 sets of [64, 5, 5, 2]-MaxPool(3)
followed by 2 dense layers of sizes (384, 192) and finally, an output layer of size 10. We use batch-
normalization for all layers and ReLU activations. We also use Dropout (Srivastava et al., 2014) of
0.5 retention probability for the two dense layers. The configuration C3 is identical to C1 except it
uses 100 softmax outputs instead of 10.
B.4	NETWORKS C2 AND C4
The C2 network is a modified version of the popular VGG configuration (Simonyan & Zisserman,
2014). The C3 network uses the configuration: 2 × [64, 3, 3, 1], 2 × [128, 3, 3, 1], 3 × [256, 3, 3, 1], 3 ×
[512, 3, 3, 1], 3 × [512, 3, 3, 1] which a MaxPool(2) after each stack. This stack is followed by a 512-
dimensional dense layer and finally, a 10-dimensional output layer. The activation and properties of
each layer is as in B.3. As is the case with C3 and C1, the configuration C4 is identical to C2 except
that it uses 100 softmax outputs instead of 10.
12
Published as a conference paper at ICLR 2017
C Performance Model
As mentioned in Section 1, a training algorithm that operates in the large-batch regime without
suffering from a generalization gap would have the ability to scale to much larger number of nodes
than is currently possible. Such and algorithm might also improve training time through faster
convergence. We present an idealized performance model that demonstrates our goal.
For LB method to be competitive with SB method, the LB method must (i) converge to minimizers
that generalize well, and (ii) do it in a reasonably number of iterations, which we analyze here. Let Is
and l` be number of iterations required by SB and LB methods to reach the point of comparable test
accuracy, respectively. Let Bs and b` be corresponding batch sizes and P be number of processors
being used for training. Assume that P < b`, and let fs(P) be the parallel efficiency of the SB
method. For simplicity, We assume that f'(P), the parallel efficiency of the LB method, is 1.0. In
other words, we assume that the LB method is perfectly scalable due to use of a large batch size.
For LB to be faster than SB, We must have
LB < 1 Bs
1' p	iPfs(P).
In other Words, the ratio of iterations of LB to the iterations of SB should be
τ <f⅛.
For example, if fs(P) = 0.2 and Bs/B' = 0.1, the LB method must converge in at most half as
many iterations as the SB method to see performance benefits. We refer the reader to (Das et al.,
2016) for a more detailed model and a commentary on the effect of batch-size on the performance.
D Curvilinear Parametric Plots
The parametric plots for the curvilinear path from x? to x?, i.e., f (sin(On )x? + cos(On )x?) can be
found in Figure 7.
E Attempts to Improve LB Methods
In this section, We discuss a feW strategies that aim to remedy the problem of poor generalization
for large-batch methods. As in Section 2, We use 10% as the percentage batch-size for large-batch
experiments and 256 for small-batch methods. For all experiments, We use ADAM as the optimizer
irrespective of batch-size.
E.1	Data Augmentation
Given that large-batch methods appear to be attracted to sharp minimizers, one can ask Whether it is
possible to modify the geometry of the loss function so that it is more benign to large-batch meth-
ods. The loss function depends both on the geometry of the objective function and to the size and
properties of the training set. One approach We consider is data augmentation; see e.g. (Krizhevsky
et al., 2012; Simonyan & Zisserman, 2014). The application of this technique is domain specific but
generally involves augmenting the data set through controlled modifications on the training data. For
instance, in the case of image recognition, the training set can be augmented through translations,
rotations, shearing and flipping of the training data. This technique leads to regularization of the
netWork and has been employed for improving testing accuracy on several data sets.
In our experiments, We train the 4 image-based (convolutional) netWorks using aggressive data aug-
mentation and present the results in Table 6. For the augmentation, We use horizontal reflections,
random rotations up to 10° and random translation of up to 0.2 times the size of the image. It is
evident from the table that, While the LB method achieves accuracy comparable to the SB method
(also With training data augmented), the sharpness of the minima still exists, suggesting sensitivity
to images contained in neither training or testing set. In this section, We exclude parametric plots and
sharpness values for the SB method oWing to space constraints and the similarity to those presented
in Section 2.2.
13
Published as a conference paper at ICLR 2017
18
16
14
2 0 8 a
1 1
Ado-Uuw sso」。
100
80
>US3UU<
O O
6 4
18
16
14
12108 6
AdOtuwu>so∙o
100
80
>US3UU<
Q 0
6 4
AdOJlUW SSoJu
4
2
0
-1.0
>US3UU<
…：i............................................................................■
F1
F2
>US3UU<
...........r...................r
0.5
alpha
(c) C1
AdaqUW SsoJU
0
-1.0	-0.5	0.0	0.5	1.0
alpha
18161412108 G
Ado∙quw SS0.O
O
O
(e) C3
(d) C2
(f) C4
Figure 7: Parametric Plots - Curvilinear (Left vertical axis corresponds to cross-entropy loss, f,
and right vertical axis corresponds to classification accuracy; solid line indicates training data set
and dashed line indicated testing data set); α = 0 corresponds to the SB minimizer while α = 1
corresponds to the LB minimizer
Table 6: Effect of Data Augmentation
Testing Accuracy
Baseline (SB) Augmented LB
Sharpness (LB method)
e = 10-3	e = 5 ∙ 10-4
C1
C2
C3
C4
83.63% ± 0.14%
89.82% ± 0.12%
54.55% ± 0.44%
63.05% ± 0.5%
82.50% ± 0.67%
90.26% ± 1.15%
53.03% ± 0.33%
65.88 ± 0.13%
231.77 ± 30.50
468.65 ± 47.86
103.68 ± 11.93
271.06 ± 29.69
45.89 ± 3.83
105.22 ± 19.57
37.67 ± 3.46
45.31 ± 5.93
14
Published as a conference paper at ICLR 2017
Table 7: Effect of Conservative Training
	Testing Accuracy		Sharpness (LB method)	
	Baseline (SB)	Conservative LB	E = 10-3	E = 5∙10-4
F1	98.03% ± 0.07%	98.12% ± 0.01%	232.25 ± 63.81	46.02 ± 12.58
F2	64.02% ± 0.2%	61.94% ± 1.10%	928.40 ± 51.63	190.77 ± 25.33
C1	80.04% ± 0.12%	78.41% ± 0.22%	520.34 ± 34.91	171.19 ± 15.13
C2	89.24% ± 0.05%	88.495% ± 0.63%	632.01 ± 208.01	108.88 ± 47.36
C3	49.58% ± 0.39%	45.98% ± 0.54%	337.92 ± 33.09	110.69 ± 3.88
C4	63.08% ± 0.10%	62.51 ± 0.67	354.94 ± 20.23	68.76 ± 16.29
E.2 Conservative Training
In (Li et al., 2014), the authors argue that the convergence rate of SGD for the large-batch setting
can be improved by obtaining iterates through the following proximal sub-problem.
xk+1
argmin |B1-| X fi(x) + λ kx - xkk2
x	i∈Bk
(5)
The motivation for this strategy is, in the context of large-batch methods, to better utilize a batch
before moving onto the next one. The minimization problem is solved inexactly using 3-5 itera-
tions of gradient descent, co-ordinate descent or L-BFGS. (Li et al., 2014) report that this not only
improves the convergence rate of SGD but also leads to improved empirical performance on con-
vex machine learning problems. The underlying idea of utilizing a batch is not specific to convex
problems and we can apply the same framework for deep learning, however, without theoretical
guarantees. Indeed, similar algorithms were proposed in (Zhang et al., 2015) and (Mobahi, 2016)
for Deep Learning. The former placed emphasis on parallelization of small-batch SGD and asyn-
chrony while the latter on a diffusion-continuation mechanism for training. The results using the
conservative training approach are presented in Figure 7. In all experiments, we solve the problem
(5) using 3 iterations of ADAM and set the regularization parameter λ to be 10-3. Again, there is
a statistically significant improvement in the testing accuracy of the large-batch method but it does
not solve the problem of sensitivity.
E.3 Robust Training
A natural way of avoiding sharp minima is through robust optimization techniques. These methods
attempt to optimize a worst-case cost as opposed to the nominal (or true) cost. Mathematically,
given an > 0, these techniques solve the problem
min φ(x) := max f(x + ∆x)
x	k∆xk≤
(6)
Geometrically, classical (nominal) optimization attempts to locate the lowest point ofa valley, while
robust optimization attempts to lower an -disc down the loss surface. We refer an interested reader
to (Bertsimas et al., 2010), and the references therein, for a review of non-convex robust optimiza-
tion. A direct application of this technique is, however, not feasible in our context since each itera-
tion is prohibitively expensive because it involves solving a large-scale second-order conic program
(SOCP).
15
Published as a conference paper at ICLR 2017
In the context of Deep Learning, there are two inter-dependent forms of robustness: robustness to
the data and robustness to the solution. The former exploits the fact that the function f is inherently
a statistical model, while the latter treats f as a black-box function. In (Shaham et al., 2015), the
authors prove the equivalence between robustness of the solution (with respect to the data) and
adversarial training (Goodfellow et al., 2014a).
Given the partial success of the data augmentation strategy, it is natural to question the efficacy
of adversarial training. As described in (Goodfellow et al., 2014a), adversarial training also aims
to artificially increase the training set but, unlike randomized data augmentation, uses the model’s
sensitivity to construct new examples. Despite its intuitive appeal, in our experiments, we found
that this strategy did not improve generalization. Similarly, we observed no generalization benefit
from the stability training proposed by (Zheng et al., 2016). In both cases, the testing accuracy,
sharpness values and the parametric plots were similar to the unmodified (baseline) case discussed
in Section 2. It remains to be seen whether adversarial training (or any other form of robust training)
can increase the viability of large-batch training.
16