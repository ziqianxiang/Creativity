Figure 1: Stack-based NPI: Four time steps from the execution of the stack-based NPI model. Eachcolor/hash pattern represents a unique set of unchanging data values which, over time, move UP anddown (and in and out of) the stack. Operations below the dotted line to calculate the new world stateare executed only at test time, since we do not have access to fworld at training time, and the trainingdata contains the correct sequence of world states.
Figure 2: RNN Cell: A zoomed in view of theinternals of an RNN cell from Figure 1.
Figure 3: NPL lattice: Each slice cor-responds to one timestep, and each nodein a timestep corresponds to a given calldepth, l, and elementary operation in-dex, i. A subset of the lattice transitionsare shown with blue arrows for PUSHtransitions, green for OP and orange forPOP.
Figure 4: NanoCraft: Anillustrative example program,where the agent (denoted as“*”) is required to build 3×4rectangular red wooden build-ing at a certain location ina 6×6 grid world. We cansee that some of the blocksare already in place in theinitial world-state. To buildthe building, the agent (pro-gram) first makes two calls toMOVE』ANY to move into placein the X and Y dimensions, andthen calls build_wall fourtimes to build the four walls ofthe building.
Figure 5: NanoCraft Sample Complexity: The x-axis varies the number of samples containingfull program abstractions, while the y-axis shows the accuracy. NPL-{64,128,256} shows the accu-racy of our model when trained with 64/128/256 training samples. NPI shows the accuracy of NPI,which can utilize only the samples containing full program abstractions. Finally, Seq-{64,128,256}shows the accuracy of a seq2seq baseline when trained on 64/128/256 samples. It’s performancedoes not change as we vary the number of samples with full program abstractions since it cannotutilize the additional supervision they provide.
Figure 6: Addition: An il-lustrative example program ofthe addition of 25 to 48. Wehave four pointers (denotedas “*”), one for each rowof the scratch pad. We re-peatedly call ADD1 until wehit the left most entry in thescratch pad. Each call toaddi We call act_write towrite the result, CARRY toWrite the carry digit (if nec-essary) and LSHIFT to shiftall four pointers to the left toWork on the next digit. Thedigit sequence on the fourthroW of scratch pad is the resultof the addition.
Figure 7: Addition Generalization Performance: The x-axis varies the number of input digitsfor the samples in the test set, while the y-axis shows the accuracy. All models are trained on additionprograms with inputs of 1 to 10 digits. NPL-16-1 shows the accuracy of our model when trainedwith 16 total samples (per number of digits), of which 1 sample (per number of digits) includes fullprogram abstractions. NPI-1 and NPI-16 show the accuracy of the NPI model when trained with 1total samples and 16 total samples respectively (per number of digits), all containing full programabstractions. S2S-Easy-16 and S2S-Easy-32 show the performance of the S2S-Easy baseline whentrained with 16 and 32 samples respectively (per number of digits).
