Published as a conference paper at ICLR 2017
Adversarial Feature Learning
Jeff Donahue
jdonahue@cs.berkeley.edu
Computer Science Division
University of California, Berkeley
Philipp Krahenbuhl
philkr@utexas.edu
Department of Computer Science
University of Texas, Austin
Trevor Darrell
trevor@eecs.berkeley.edu
Computer Science Division
University of California, Berkeley
Ab stract
The ability of the Generative Adversarial Networks (GANs) framework to learn
generative models mapping from simple latent distributions to arbitrarily complex
data distributions has been demonstrated empirically, with compelling results
showing that the latent space of such generators captures semantic variation in
the data distribution. Intuitively, models trained to predict these semantic latent
representations given data may serve as useful feature representations for auxiliary
problems where semantics are relevant. However, in their existing form, GANs
have no means of learning the inverse mapping - projecting data back into the
latent space. We propose Bidirectional Generative Adversarial Networks (BiGANs)
as a means of learning this inverse mapping, and demonstrate that the resulting
learned feature representation is useful for auxiliary supervised discrimination tasks,
competitive with contemporary approaches to unsupervised and self-supervised
feature learning.
1	Introduction
Deep convolutional networks (convnets) have become a staple of the modern computer vision pipeline.
After training these models on a massive database of image-label pairs like ImageNet (Russakovsky
et al., 2015), the network easily adapts to a variety of similar visual tasks, achieving impressive
results on image classification (Donahue et al., 2014; Zeiler & Fergus, 2014; Razavian et al., 2014)
or localization (Girshick et al., 2014; Long et al., 2015) tasks. In other perceptual domains such as
natural language processing or speech recognition, deep networks have proven highly effective as
well (Bahdanau et al., 2015; Sutskever et al., 2014; Vinyals et al., 2015; Graves et al., 2013). However,
all of these recent results rely on a supervisory signal from large-scale databases of hand-labeled data,
ignoring much of the useful information present in the structure of the data itself.
Meanwhile, Generative Adversarial Networks (GANs) (Goodfellow et al., 2014) have emerged as a
powerful framework for learning generative models of arbitrarily complex data distributions. The
GAN framework learns a generator mapping samples from an arbitrary latent distribution to data, as
well as an adversarial discriminator which tries to distinguish between real and generated samples
as accurately as possible. The generator’s goal is to “fool” the discriminator by producing samples
which are as close to real data as possible. When trained on databases of natural images, GANs
produce impressive results (Radford et al., 2016; Denton et al., 2015).
Interpolations in the latent space of the generator produce smooth and plausible semantic variations,
and certain directions in this space correspond to particular semantic attributes along which the data
distribution varies. For example, Radford et al. (2016) showed that a GAN trained on a database of
human faces learns to associate particular latent directions with gender and the presence of eyeglasses.
A natural question arises from this ostensible “semantic juice” flowing through the weights of
generators learned using the GAN framework: can GANs be used for unsupervised learning of rich
feature representations for arbitrary data distributions? An obvious issue with doing so is that the
1
Published as a conference paper at ICLR 2017
Figure 1: The structure of Bidirectional Generative Adversarial Networks (BiGAN).
generator maps latent samples to generated data, but the framework does not include an inverse
mapping from data to latent representation.
Hence, we propose a novel unsupervised feature learning framework, Bidirectional Generative
Adversarial Networks (BiGAN). The overall model is depicted in Figure 1. In short, in addition to
the generator G from the standard GAN framework (Goodfellow et al., 2014), BiGAN includes an
encoder E which maps data x to latent representations z. The BiGAN discriminator D discriminates
not only in data space (x versus G(z)), but jointly in data and latent space (tuples (x, E(x)) versus
(G(z), z)), where the latent component is either an encoder output E(x) or a generator input z.
It may not be obvious from this description that the BiGAN encoder E should learn to invert the
generator G. The two modules cannot directly “communicate” with one another: the encoder never
“sees” generator outputs (E(G(z)) is not computed), and vice versa. Yet, in Section 3, we will both
argue intuitively and formally prove that the encoder and generator must learn to invert one another
in order to fool the BiGAN discriminator.
Because the BiGAN encoder learns to predict features z given data x, and prior work on GANs has
demonstrated that these features capture semantic attributes of the data, we hypothesize that a trained
BiGAN encoder may serve as a useful feature representation for related semantic tasks, in the same
way that fully supervised visual models trained to predict semantic “labels” given images serve as
powerful feature representations for related visual tasks. In this context, a latent representation z may
be thought of as a “label” for x, but one which came for “free,” without the need for supervision.
An alternative approach to learning the inverse mapping from data to latent representation is to
directly model p(z|G(z)), predicting generator input z given generated data G(z). We’ll refer to
this alternative as a latent regressor, later arguing (Section 4.1) that the BiGAN encoder may be
preferable in a feature learning context, as well as comparing the approaches empirically.
BiGANs are a robust and highly generic approach to unsupervised feature learning, making no
assumptions about the structure or type of data to which they are applied, as our theoretical results will
demonstrate. Our empirical studies will show that despite their generality, BiGANs are competitive
with contemporary approaches to self-supervised and weakly supervised feature learning designed
specifically for a notoriously complex data distribution - natural images.
Dumoulin et al. (2016) independently proposed an identical model in their concurrent work, exploring
the case of a stochastic encoder E and the ability of such models to learn in a semi-supervised setting.
2	Preliminaries
Let PX(X) be the distribution of our data for X ∈ Ωχ (e.g. natural images). The goal of generative
modeling is capture this data distribution using a probabilistic model. Unfortunately, exact modeling
of this probability density function is computationally intractable (Hinton et al., 2006; Salakhutdinov
& Hinton, 2009) for all but the most trivial models. Generative Adversarial Networks (GANs) (Good-
2
Published as a conference paper at ICLR 2017
fellow et al., 2014) instead model the data distribution as a transformation of a fixed latent distribution
pz(z) for Z ∈ Ωz. This transformation, called a generator, is expressed as a deterministic feed
forward network G : Ωz → Ωχ with PG(x|z) = δ (X - G(Z)) andPG(X) = EZ〜PZ [pg(x∣z)]. The
goal is to train a generator such that pG (x) ≈ pX(x).
The GAN framework trains a generator, such that no discriminative model D : Ωχ → [0,1] can
distinguish samples of the data distribution from samples of the generative distribution. Both generator
and discriminator are learned using the adversarial (minimax) objective min max V (D, G), where
V(D, G):= Ex〜PX [log D(x)]+ Ex〜PG [log(1 - D(x))]	(1)
'----------{z---------}
Ez〜PZ [log(1-D(G(z)))]
Goodfellow et al. (2014) showed that for an ideal discriminator the objective C(G) :=
maxD V(D, G) is equivalent to the Jensen-Shannon divergence between the two distributions PG
and PX .
The adversarial objective 1 does not directly lend itself to an efficient optimization, as each step in
the generator G requires a full discriminator D to be learned. Furthermore, a perfect discriminator
no longer provides any gradient information to the generator, as the gradient of any global or local
maximum of V(D, G) is 0. To provide a strong gradient signal nonetheless, Goodfellow et al. (2014)
slightly alter the objective between generator and discriminator updates, while keeping the same fixed
point characteristics. They also propose to optimize (1) using an alternating optimization switching
between updates to the generator and discriminator. While this optimization is not guaranteed to
converge, empirically it works well if the discriminator and generator are well balanced.
Despite the empirical strength of GANs as generative models of arbitrary data distributions, it is not
clear how they can be applied as an unsupervised feature representation. One possibility for learning
such representations is to learn an inverse mapping regressing from generated data G(Z) back to
the latent input Z. However, unless the generator perfectly models the data distribution PX , a nearly
impossible objective for a complex data distribution such as that of high-resolution natural images,
this idea may prove insufficient.
3 B idirectional Generative Adversarial Networks
In Bidirectional Generative Adversarial Networks (BiGANs) we not only train a generator, but
additionally train an encoder E : Ωχ → Ωz. The encoder induces a distribution PE(z|x)=
δ(Z - E(X)) mapping data points X into the latent feature space of the generative model. The
discriminator is also modified to take input from the latent space, predicting PD(Y |X, Z), where
Y = 1 if X is real (sampled from the real data distribution PX), and Y = 0 if X is generated (the
output of G(Z), z 〜pz).
The BiGAN training objective is defined as a minimax objective
minmaxV(D,E,G)	(2)
G,E D
where
V(D,E,G) := Ex〜PX [Ez〜PE(∙∣x) [logD(x, z)] ] + EZ〜pz [Ex〜pg(∙∣z) [log (1 - D(x, z))]].
x----------{----------}	X------------{---------------}
log D(x,E(x))	log(1-D(G(z),z))
(3)
We optimize this minimax objective using the same alternating gradient based optimization as
Goodfellow et al. (2014). See Section 3.4 for details.
BiGANs share many of the theoretical properties of GANs (Goodfellow et al., 2014), while addition-
ally guaranteeing that at the global optimum, G and E are each other’s inverse. BiGANs are also
closely related to autoencoders with an `0 loss function. In the following sections we highlight some
of the appealing theoretical properties of BiGANs.
Definitions Let PGZ (X, z) := PG(X|z)PZ(z) and PEX (X, z) := PE(z|X)PX(X) be the joint distri-
butions modeled by the generator and encoder respectively. Ω := Ωχ X Ωz is the joint latent and
3
Published as a conference paper at ICLR 2017
data space. For a region R ⊆ Ω,
PEX(R) := RΩ PEX(X, Z)1[(x,z)∈R] d(X, Z) = RΩX PX(X) RΩZ PE (ZIX)1[(x,z)∈R] dz dχ
PGZ(R) := RΩ PGZ(x, z)1[(x,z)∈R] d(χ,z) = rωz PZ(Z) Jωx PG(XIZ)1[(x,z)∈R] dx dz
are probability measures over that region. We also define
PX(RX) ：= Jωx PX(X)1[x∈Rχ] dX	PZ(RZ) := Jωz PZ(Z)1[z∈Rz] dZ
as measures over regions RX ⊆ Ωx and RZ ⊆ Ωz. We refer to the set of features and data samples
in the support of PX and PZ as Ωχ := SuPP(PX) and Ωz := SuPP(PZ) respectively. DKL (P II Q)
and DJS (P II Q ) respectively denote the Kullback-Leibler (KL) and Jensen-Shannon divergences
between probability measures P and Q. By definition,
DKL ( P || Q ) := Ex 〜P [log fPQ (x)]
Djs (P II Q) := 2
where fpQ :=彩 is the Radon-Nikodym (RN) derivative of measure P with respect to measure Q,
with the defining property that P(R) = JR fpQ dQ. The RN derivative fpQ : Ω → R≥o is defined
for any measures P and Q on space Ω such that P is absolutely continuous with respect to Q: i.e.,
for any R ⊆ Ω, P(R) > 0 =⇒ Q(R) > 0.
3.1	Optimal discriminator, generator, & encoder
We start by characterizing the optimal discriminator for any generator and encoder, following Good-
fellow et al. (2014). This optimal discriminator then allows us to reformulate objective (3), and show
that it reduces to the Jensen-Shannon divergence between the joint distributions PEX and PGZ .
Proposition 1 For any E and G, the optimal discriminator DEG := arg max。V(D, E, G) is the
Radon-Nikodym derivative /eg := d(p：；+PGZ) : Ω → [0,1] of measure PEX with respect to
measure PEX + PGZ.
Proof. Given in Appendix A.1.
This optimal discriminator now allows us to characterize the optimal generator and encoder.
Proposition 2 The encoder and generator’s objective for an optimal discriminator C(E, G) :=
maxD V(D, E,G) = V(DEg, E, G) can be rewritten in terms ofthe Jensen-Shannon divergence
between measures PEX and PGZ as C(E, G) = 2 DJS (PEX II PGZ ) - log 4.
Proof. Given in Appendix A.2.
Theorem 1 The global minimum of C(E, G) is achieved if and only if PEX = PGZ. At that point,
C(E, G) = — log 4 and DEG = 2.
Proof. From Proposition 2, we have that C(E, G) = 2 DJS ( PEX II PGZ ) - log 4. The Jensen-
Shannon divergence DJS (P II Q ) ≥ 0 for any P and Q, and DJS (P II Q ) = 0 if and only if P = Q.
Therefore, the global minimum of C(E, G) occurs if and only if PEX = PGZ, and at this point the
value is C(E, G) = — log 4. Finally, PEX
dE g
dPEX
d(PEχ + pGz)
dPEX
2 dPEX
PGZ implies that the optimal discriminator is chance:
1. □
The optimal discriminator, encoder, and generator of BiGAN are similar to the optimal discriminator
and generator of the GAN framework (Goodfellow et al., 2014). However, an important difference is
that BiGAN optimizes a Jensen-Shannon divergence between a joint distribution over both data X
and latent features Z. This joint divergence allows us to further characterize properties of G and E,
as shown below.
3.2	Optimal generator & encoder are inverses
We first present an intuitive argument that, in order to “fool” a perfect discriminator, a deterministic
BiGAN encoder and generator must invert each other. (Later we will formally state and prove this
4
Published as a conference paper at ICLR 2017
property.) Consider a BiGAN discriminator input pair (x, z). Due to the sampling procedure, (x, z)
must satisfy at least one of the following two properties:
O	— ,	.	O	_ .,.
(a) X ∈ ΩΩχ ∧ E(X) = Z	(b) Z ∈ ΩZ ∧ G(Z) = X
If only one of these properties is satisfied, a perfect discriminator can infer the source of (x, z) with
certainty: if only (a) is satisfied, (x, Z) must be an encoder pair (x, E(x)) and DEg(x, Z) = 1; if
only (b) is satisfied, (x, Z) mustbe a generator pair (G(z), Z) and DEg(x, Z) = 0.
Therefore, in order to fool a perfect discriminator at (x, z) (so that 0 < DEg(x, z) < 1), E and
G must satisfy both (a) and (b). In this case, we can substitute the equality E(X) = Z required
by (a) into the equality G(Z) = X required by (b), and vice versa, giving the inversion properties
X = G(E(X)) and Z = E(G(Z)).
Formally, we show in Theorem 2 that the optimal generator and encoder invert one another almost
everywhere on the support Ωχ and Ωz of PX and Pz.
Theorem 2 If E and G are an optimal encoder and generator, then E = G-1 almost everywhere;
that is, G(E(X)) = X for PX-almost every X ∈ Ωχ, and E(G(Z)) = Z for PZ-almost every Z ∈ Ωz.
Proof. Given in Appendix A.4.
While Theorem 2 characterizes the encoder and decoder at their optimum, due to the non-convex
nature of the optimization, this optimum might never be reached. Experimentally, Section 4 shows
that on standard datasets, the two are approximate inverses; however, they are rarely exact inverses. It
is thus also interesting to show what objective BiGAN optimizes in terms of E and G. Next we show
that BiGANs are closely related to autoencoders with an `0 loss function.
3.3	Relationship to autoencoders
As argued in Section 1, a model trained to predict features Z given data X should learn useful semantic
representations. Here we show that the BiGAN objective forces the encoder E to do exactly this: in
order to fool the discriminator at a particular Z, the encoder must invert the generator at that Z, such
that E(G(Z)) = Z.
Theorem 3 The encoder and generator objective given an optimal discriminator C(E, G) :=
maxD V (D, E, G) can be rewritten as an `0 autoencoder loss function
C(E,G) = Ex~pχ [1[e(x)∈Ωz∧G(E(x))=x]log fEG (X，E(X))] +
EZ〜pz [1[g(z)∈Ωχ∧E(G(z))=z] Iog(I - fEG(G(Z),z))]
with log fEG ∈ (-∞, 0) and log (1 - fEG) ∈ (-∞, 0) PEX -almost and PGZ-almost everywhere.
Proof. Given in Appendix A.5.
Here the indicator function 1[G(E(x))=x] in the first term is equivalent to an autoencoder with `0 loss,
while the indicator 1[E(G(z))=z] in the second term shows that the BiGAN encoder must invert the
generator, the desired property for feature learning. The objective further encourages the functions
E(X) and G(Z) to produce valid outputs in the support of PZ and PX respectively. Unlike regular
autoencoders, the `0 loss function does not make any assumptions about the structure or distribution
of the data itself; in fact, all the structural properties of BiGAN are learned as part of the discriminator.
3.4	Learning
In practice, as in the GAN framework (Goodfellow et al., 2014), each BiGAN module D, G, and E
is a parametric function (with parameters θD, θG, and θE, respectively). As a whole, BiGAN can be
optimized using alternating stochastic gradient steps. In one iteration, the discriminator parameters
Θd are updated by taking one or more steps in the positive gradient direction Vθd V(D, E, G),
then the encoder parameters θE and generator parameters θG are together updated by taking a step
in the negative gradient direction -VθE,θGV(D, E, G). In both cases, the expectation terms of
5
Published as a conference paper at ICLR 2017
V(D, E, G) are estimated using mini-batches of n samples {x(i) 〜pχ}n=ι and {z(i) 〜 pZ}in=1
drawn independently for each update step.
Goodfellow et al. (2014) found that an objective in which the real and generated labels Y are swapped
provides stronger gradient signal to G. We similarly observed in BiGAN training that an “inverse”
objective provides stronger gradient signal to G and E. For efficiency, we also update all modules
D, G, and E simultaneously at each iteration, rather than alternating between D updates and G, E
updates. See Appendix B for details.
3.5	Generalized BiGAN
It is often useful to parametrize the output of the generator G and encoder E in a different, usually
smaller, space Ωχ and ΩZ rather than the original Ωχ and Ωz. For example, for visual feature
learning, the images input to the encoder should be of similar resolution to images used in the
evaluation. On the other hand, generating high resolution images remains difficult for current
generative models. In this situation, the encoder may take higher resolution input while the generator
output and discriminator input remain low resolution.
We generalize the BiGAN objective V(D, G, E) (3) with functions gχ : Ωχ → Ωχ and gz : Ωz -
ΩZ, and encoder E : Ωχ → Ωg, generator G : Ωz → Ωχ, and discriminator D : Ωχ X ΩZ → [0,1]:
Ex〜PX [Ez0〜PE(∙∣x) [logD(gx(x),z0)]] + EZ〜PZ [Eχ0〜pg(∙∣z) [log(1 — D(x0,gz(z)))]]
x---------------------{-------------}	X---------------{----------------}
log D(gX(x),E(x))	log(1-D(G(Z),gZ(Z)))
An identity gχ(x) = X and gz(z) = Z (and Ωχ = Ωχ, Ωg = Ωz) yields the original objective. For
visual feature learning with higher resolution encoder inputs, gX is an image resizing function that
downsamples a high resolution image X ∈ Ωχ to a lower resolution image x0 ∈ Ωχ, as output by the
generator. (gZ is identity.)
In this case, the encoder and generator respectively induce probability measures PEX0 and
Pgzo over regions R ⊆ Ω0 of the joint space Ω0 := Ωχ × Ωg, with Pex，(R):=
rωx RΩX RΩZ PEX(x, z0)1[(x0 ,z0)∈R]δ(gX (X) - χ0)dz0dχ0dχ = RΩX PX(x)1[(gχ(x),E(x))∈R] dx,
and PGz0 defined analogously. For optimal E and G, we can show PEX0 = PGz0 : a generalization
of Theorem 1. When E and G are deterministic and optimal, Theorem 2 - that E and G invert one
another - can also be generalized: ∃z∈ωz{E(x) = gz(z) ∧ G(z) = gχ(x)} for Pχ-almost every
x ∈ Ωχ, and ∃x∈Ωχ{E(x) = gz(z) ∧ G(z) = gχ(x)} for Pz-almost every Z ∈ Ωz.
4 Evaluation
We evaluate the feature learning capabilities of BiGANs by first training them unsupervised as
described in Section 3.4, then transferring the encoder’s learned feature representations for use in
auxiliary supervised learning tasks. To demonstrate that BiGANs are able to learn meaningful feature
representations both on arbitrary data vectors, where the model is agnostic to any underlying structure,
as well as very high-dimensional and complex distributions, we evaluate on both permutation-invariant
MNIST (LeCun et al., 1998) and on the high-resolution natural images of ImageNet (Russakovsky
et al., 2015).
In all experiments, each module D, G, and E is a parametric deep (multi-layer) network. The BiGAN
discriminator D(x, z) takes data x as its initial input, and at each linear layer thereafter, the latent
representation z is transformed using a learned linear transformation to the hidden layer dimension
and added to the non-linearity input.
4.1	Baseline methods
Besides the BiGAN framework presented above, we considered alternative approaches to learning
feature representations using different GAN variants.
Discriminator The discriminator D ina standard GAN takes data samples X 〜PX as input, making
its learned intermediate representations natural candidates as feature representations for related tasks.
6
Published as a conference paper at ICLR 2017
BiGAN D LR JLR AE ('2) AE ('1)
97.39	97.30 97.44 97.13	97.58	97.63
Table 1: One Nearest Neighbors (1NN) classification accuracy (%) on the permutation-invariant
MNIST (LeCun et al., 1998) test set in the feature space learned by BiGAN, Latent Regressor (LR),
Joint Latent Regressor (JLR), and an autoencoder (AE) using an '1 or '2 distance.
G(z)

Figure 2: Qualitative results for permutation-invariant MNIST BiGAN training, including generator
samples G(z), real data x, and corresponding reconstructions G(E(x)).
This alternative is appealing as it requires no additional machinery, and is the approach used for
unsupervised feature learning in Radford et al. (2016). On the other hand, it is not clear that the task of
distinguishing between real and generated data requires or benefits from intermediate representations
that are useful as semantic feature representations. In fact, if G successfully generates the true data
distribution pχ(x), D may ignore the input data entirely and predict P(Y = 1) = P (Y =1| X) = 2
unconditionally, not learning any meaningful intermediate representations.
Latent regressor We consider an alternative encoder training by minimizing a reconstruction loss
L(z, E(G(z))), after or jointly during a regular GAN training, called latent regressor or joint latent
regressor respectively. We use a sigmoid cross entropy loss L as it naturally maps to a uniformly
distributed output space. Intuitively, a drawback of this approach is that, unlike the encoder in a
BiGAN, the latent regressor encoder E is trained only on generated samples G(z), and never “sees”
real data X 〜pχ. While this may not be an issue in the theoretical optimum where PG(X) = PX(X)
exactly - i.e., G perfectly generates the data distribution PX - in practice, for highly complex data
distributions PX, such as the distribution of natural images, the generator will almost never achieve
this perfect result. The fact that the real data X are never input to this type of encoder limits its utility
as a feature representation for related tasks, as shown later in this section.
4.2	Permutation-invariant MNIST
We first present results on permutation-invariant MNIST (LeCun et al., 1998). In the permutation-
invariant setting, each 28 × 28 digit image must be treated as an unstructured 784D vector (Goodfellow
et al., 2013). In our case, this condition is met by designing each module as a multi-layer perceptron
(MLP), agnostic to the underlying spatial structure in the data (as opposed to a convnet, for example).
See Appendix C.1 for more architectural and training details. We set the latent distribution PZ =
[U(-1,1)]50 - a 50D continuous uniform distribution.
Table 1 compares the encoding learned by a BiGAN-trained encoder E with the baselines described
in Section 4.1, as well as autoencoders (Hinton & Salakhutdinov, 2006) trained directly to minimize
either '2 or '1 reconstruction error. The same architecture and optimization algorithm is used across
all methods. All methods, including BiGAN, perform at roughly the same level. This result is not
overly surprising given the relative simplicity of MNIST digits. For example, digits generated by
G in a GAN nearly perfectly match the data distribution (qualitatively), making the latent regressor
(LR) baseline method a reasonable choice, as argued in Section 4.1. Qualitative results are presented
in Figure 2.
4.3	ImageNet
Next, we present results from training BiGANs on ImageNet LSVRC (Russakovsky et al., 2015),
a large-scale database of natural images. GANs trained on ImageNet cannot perfectly reconstruct
7
Published as a conference paper at ICLR 2017
DE
Noroozi & Favaro (2016)
G
AlexNet-based D
Krizhevsky et al. (2012)
Figure 3: The convolutional filters learned by the three modules (D, G, and E) of a BiGAN (left,
top-middle) trained on the ImageNet (Russakovsky et al., 2015) database. We compare with the
filters learned by a discriminator D trained with the same architecture (bottom-middle), as well as
the filters reported by Noroozi & Favaro (2016), and by Krizhevsky et al. (2012) for fully supervised
ImageNet training (right).
x
G(E(x))
Figure 4: Qualitative results for ImageNet BiGAN training, including generator samples G(z), real
data x, and corresponding reconstructions G(E(x)).
the data, but often capture some interesting aspects. Here, each of D, G, and E is a convnet. In all
experiments, the encoder E architecture follows AlexNet (Krizhevsky et al., 2012) through the fifth
and last convolution layer (conv5). We also experiment with an AlexNet-based discriminator D as
a baseline feature learning approach. We set the latent distribution PZ = [U(-1,1)]200 - a 200D
continuous uniform distribution. Additionally, we experiment with higher resolution encoder input
images - 112 X 112 rather than the 64 X 64 used elsewhere - using the generalization described in
Section 3.5. See Appendix C.2 for more architectural and training details.
Qualitative results The convolutional filters learned by each of the three modules are shown in
Figure 3. We see that the filters learned by the encoder E have clear Gabor-like structure, similar to
those originally reported for the fully supervised AlexNet model (Krizhevsky et al., 2012). The filters
also have similar “grouping” structure where one half (the bottom half, in this case) is more color
sensitive, and the other half is more edge sensitive. (This separation of the filters occurs due to the
AlexNet architecture maintaining two separate filter paths for computational efficiency.)
In Figure 4 we present sample generations G(z), as well as real data samples x and their BiGAN re-
constructions G(E(x)). The reconstructions, while certainly imperfect, demonstrate empirically that
8
Published as a conference paper at ICLR 2017
	conv1	conv2	conv3	conv4	conv5
Random (Noroozi & Favaro, 2016)	48.5	41.0	34.8	27.1	12.0
Wang & Gupta (2015)	51.8	46.9	42.8	38.8	29.8
Doersch et al. (2015)	53.1	47.6	48.7	45.6	30.4
Noroozi & Favaro (2016)*	57.1	56.0	52.4	48.3	38.1
BiGAN (ours)	562	54.4	49.4	43.9	33.3
BiGAN, 112 × 112 E (ours)	55.3	53.2	49.3	44.4	34.8
Table 2: Classification accuracy (%) for the ImageNet LSVRC (Russakovsky et al., 2015) validation
set with various portions of the network frozen, or reinitialized and trained from scratch, following
the evaluation from Noroozi & Favaro (2016). In, e.g., the conv3 column, the first three layers
-conv1 through conv3 - are transferred and frozen, and the last layers - conv4, conv5, and fully
connected layers - are reinitialized and trained fully supervised for ImageNet classification. BiGAN is
competitive with these contemporary visual feature learning methods, despite its generality. (*Results
from Noroozi & Favaro (2016) are not directly comparable to those of the other methods as a different
base convnet architecture with larger intermediate feature maps is used.)
the BiGAN encoder E and generator G learn approximate inverse mappings, as shown theoretically
in Theorem 2. In Appendix C.2, we present nearest neighbors in the BiGAN learned feature space.
ImageNet classification Following Noroozi & Favaro (2016), we evaluate by freezing the first
N layers of our pretrained network and randomly reinitializing and training the remainder fully
supervised for ImageNet classification. Results are reported in Table 2.
VOC classification, detection, and segmentation We evaluate the transferability of BiGAN rep-
resentations to the PASCAL VOC (Everingham et al., 2014) computer vision benchmark tasks,
including classification, object detection, and semantic segmentation. The classification task involves
simple binary prediction of presence or absence in a given image for each of 20 object categories.
The object detection and semantic segmentation tasks go a step further by requiring the objects to
be localized, with semantic segmentation requiring this at the finest scale: pixelwise prediction of
object identity. For detection, the pretrained model is used as the initialization for Fast R-CNN (Gir-
shick, 2015) (FRCN) training; and for semantic segmentation, the model is used as the initialization
for Fully Convolutional Network (Long et al., 2015) (FCN) training, in each case replacing the
AlexNet (Krizhevsky et al., 2012) model trained fully supervised for ImageNet classification. We
report results on each of these tasks in Table 3, comparing BiGANs with contemporary approaches
to unsupervised (Krahenbuhl et al., 2016) and self-supervised (Doersch et al., 2015; Agrawal et al.,
2015; Wang & Gupta, 2015; Pathak et al., 2016) feature learning in the visual domain, as well as the
baselines discussed in Section 4.1.
4.4	Discussion
Despite making no assumptions about the underlying structure of the data, the BiGAN unsupervised
feature learning framework offers a representation competitive with existing self-supervised and even
weakly supervised feature learning approaches for visual feature learning, while still being a purely
generative model with the ability to sample data x and predict latent representation z. Furthermore,
BiGANs outperform the discriminator (D) and latent regressor (LR) baselines discussed in Section 4.1,
confirming our intuition that these approaches may not perform well in the regime of highly complex
data distributions such as that of natural images. The version in which the encoder takes a higher
resolution image than output by the generator (BiGAN 112 × 112 E) performs better still, and this
strategy is not possible under the LR and D baselines as each of those modules take generator outputs
as their input.
Although existing self-supervised approaches have shown impressive performance and thus far tended
to outshine purely unsupervised approaches in the complex domain of high-resolution images, purely
unsupervised approaches to feature learning or pre-training have several potential benefits.
9
Published as a conference paper at ICLR 2017
trained layers		Classification			FRCN Detection (% mAP) all	FCN Segmentation (% mIU) all
		fc8	(% mAP) fc6-8	all		
sup.	ImageNet (Krizhevsky et al., 2012)	77.0	78.8	78.3	56.8	48.0
	Agrawal et al. (2015)	31.2	31.0	54.2	43.9	-
self-sup.	Pathak et al. (2016)	30.5	34.6	56.5	44.5	30.0
	Wang & Gupta (2015)	28.4	55.6	63.1	47.4	-
	Doersch et al. (2015)	44.7	55.1	65.3	51.1	-
	k-means (Krahenbuhl et al., 2016)	32.0	39.2	56.6	45.6	32.6
	Discriminator (D)	30.7	40.5	56.4	-	-
	Latent Regressor (LR)	36.9	47.9	57.1	-	-
unsup.	Joint LR	37.1	47.9	56.5	-	-
	Autoencoder (`2 )	24.8	16.0	53.8	41.9	-
	BiGAN (ours)	37.5	48.7	58.9	46.2	34.9
	BiGAN, 112 × 112 E (ours)	40.7	52.3	60.1	46.9	35.2
Table 3: Classification and Fast R-CNN (Girshick, 2015) detection results for the PASCAL VOC
2007 (Everingham et al., 2014) test set, and FCN (Long et al., 2015) segmentation results on the
PASCAL VOC 2012 validation set, under the standard mean average precision (mAP) or mean
intersection over union (mIU) metrics for each task. Classification models are trained with various
portions of the AlexNet (Krizhevsky et al., 2012) model frozen. In the fc8 column, only the linear
classifier (a multinomial logistic regression) is learned - in the case of BiGAN, on top of randomly
initialized fully connected (FC) layers fc6 and fc7. In the fc6-8 column, all three FC layers are trained
fully supervised with all convolution layers frozen. Finally, in the all column, the entire network is
“fine-tuned”. BiGAN outperforms other unsupervised (unsup.) feature learning approaches, including
the GAN-based baselines described in Section 4.1, and despite its generality, is competitive with
contemporary self-supervised (self-sup.) feature learning approaches specific to the visual domain.
BiGAN and other unsupervised learning approaches are agnostic to the domain of the data. The
self-supervised approaches are specific to the visual domain, in some cases requiring weak super-
vision from video unavailable in images alone. For example, the methods are not applicable in the
permutation-invariant MNIST setting explored in Section 4.2, as the data are treated as flat vectors
rather than 2D images.
Furthermore, BiGAN and other unsupervised approaches needn’t suffer from domain shift between
the pre-training task and the transfer task, unlike self-supervised methods in which some aspect of the
data is normally removed or corrupted in order to create a non-trivial prediction task. In the context
prediction task (Doersch et al., 2015), the network sees only small image patches - the global image
structure is unobserved. In the context encoder or inpainting task (Pathak et al., 2016), each image
is corrupted by removing large areas to be filled in by the prediction network, creating inputs with
dramatically different appearance from the uncorrupted natural images seen in the transfer tasks.
Other approaches (Agrawal et al., 2015; Wang & Gupta, 2015) rely on auxiliary information un-
available in the static image domain, such as video, egomotion, or tracking. Unlike BiGAN, such
approaches cannot learn feature representations from unlabeled static images.
We finally note that the results presented here constitute only a preliminary exploration of the space
of model architectures possible under the BiGAN framework, and we expect results to improve sig-
nificantly with advancements in generative image models and discriminative convolutional networks
alike.
Acknowledgments
The authors thank Evan Shelhamer, Jonathan Long, and other Berkeley Vision labmates for helpful
discussions throughout this work. This work was supported by DARPA, AFRL, DoD MURI award
N000141110688, NSF awards IIS-1427425 and IIS-1212798, and the Berkeley Artificial Intelligence
Research laboratory. The GPUs used for this work were donated by NVIDIA.
10
Published as a conference paper at ICLR 2017
References
Pulkit Agrawal, Joao Carreira, and Jitendra Malik. Learning to see by moving. In ICCV, 2015.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. In ICLR, 2015.
Emily L. Denton, Soumith Chintala, Arthur Szlam, and Rob Fergus. Deep generative image models
using a Laplacian pyramid of adversarial networks. In NIPS, 2015.
Carl Doersch, Abhinav Gupta, and Alexei A. Efros. Unsupervised visual representation learning by
context prediction. In ICCV, 2015.
Jeff Donahue, Yangqing Jia, Oriol Vinyals, Judy Hoffman, Ning Zhang, Eric Tzeng, and Trevor
Darrell. DeCAF: A deep convolutional activation feature for generic visual recognition. In ICML,
2014.
Vincent Dumoulin, Ishmael Belghazi, Ben Poole, Alex Lamb, Martin Arjovsky, Olivier Mastropietro,
and Aaron Courville. Adversarially learned inference. arXiv:1606.00704, 2016.
Mark Everingham, S. M. Ali Eslami, Luc Van Gool, Christopher K. I. Williams, John Winn, and
Andrew Zisserman. The PASCAL Visual Object Classes challenge: A retrospective. IJCV, 2014.
Ross Girshick. Fast R-CNN. In ICCV, 2015.
Ross Girshick, Jeff Donahue, Trevor Darrell, and Jitendra Malik. Rich feature hierarchies for accurate
object detection and semantic segmentation. In CVPR, 2014.
Ian Goodfellow, David Warde-Farley, Mehdi Mirza, Aaron Courville, and Yoshua Bengio. Maxout
networks. In ICML, 2013.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NIPS, 2014.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey E. Hinton. Speech recognition with deep
recurrent neural networks. In ICASSP, 2013.
Geoffrey E. Hinton and Ruslan R. Salakhutdinov. Reducing the dimensionality of data with neural
networks. Science, 2006.
Geoffrey E. Hinton, Simon Osindero, and Yee-Whye Teh. A fast learning algorithm for deep belief
nets. Neural Computation, 2006.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. In ICML, 2015.
Yangqing Jia, Evan Shelhamer, Jeff Donahue, Sergey Karayev, Jonathan Long, Ross Girshick, Sergio
Guadarrama, and Trevor Darrell. Caffe: Convolutional architecture for fast feature embedding.
arXiv:1408.5093, 2014.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In ICLR, 2015.
PhiliPP Krahenbuhl, Carl Doersch, JeffDonahue, and Trevor Darrell. Data-dependent initializations
of convolutional neural networks. In ICLR, 2016.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. ImageNet classification with deeP convolu-
tional neural networks. In NIPS, 2012.
Yann LeCun, Leon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proc. IEEE, 1998.
Jonathan Long, Evan Shelhamer, and Trevor Darrell. Fully convolutional networks for semantic
segmentation. In CVPR, 2015.
Andrew L. Maas, Awni Y. Hannun, and Andrew Y. Ng. Rectifier nonlinearities improve neural
network acoustic models. In ICML, 2013.
11
Published as a conference paper at ICLR 2017
Mehdi Noroozi and Paolo Favaro. Unsupervised learning of visual representations by solving jigsaw
puzzles. In ECCV, 2016.
Deepak Pathak, PhiliPP Krahenbuhl, Jeff Donahue, Trevor Darrell, and Alexei A. Efros. Context
encoders: Feature learning by inpainting. In CVPR, 2016.
Alec Radford, Luke Metz, and Soumith Chintala. UnsuPervised rePresentation learning with deeP
convolutional generative adversarial networks. In ICLR, 2016.
Ali Razavian, Hossein AzizPour, JosePhine Sullivan, and Stefan Carlsson. CNN features off-the-shelf:
an astounding baseline for recognition. In CVPR Workshops, 2014.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang,
Andrej KarPathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Fei-Fei Li. ImageNet
large scale visual recognition challenge. IJCV, 2015.
Ruslan Salakhutdinov and Geoffrey E. Hinton. DeeP Boltzmann machines. In AISTATS, 2009.
Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. Sequence to sequence learning with neural networks.
In NIPS, 2014.
Theano DeveloPment Team. Theano: A Python framework for fast comPutation of mathematical
exPressions. arXiv:1605.02688, 2016.
Oriol Vinyals, Eukasz Kaiser, Terry Koo, Slav Petrov, Ilya Sutskever, and Geoffrey E. Hinton.
Grammar as a foreign language. In NIPS, 2015.
Xiaolong Wang and Abhinav GuPta. UnsuPervised learning of visual rePresentations using videos.
In ICCV, 2015.
Matthew D. Zeiler and Rob Fergus. Visualizing and understanding convolutional networks. In ECCV,
2014.
12
Published as a conference paper at ICLR 2017
Appendix A Additional proofs
A. 1 Proof of Proposition 1 (optimal discriminator)
Proposition 1 For any E and G, the optimal discriminator DEG := arg max。V(D, E, G) is the
dPEX
d(PEX + pGZ)
Radon-Nikodym derivative fEG
measure PEX + PGZ.
:Ω → [0,1] of measure PEX with respect to
Proof. For measures P and Q on space Ω, with P absolutely continuous with respect to Q, the RN
derivative fPQ := dQ exists, and we have
Ex〜P [g(x)] = Rω gdP = Rω gdQ dQ = Rω gfPQ dQ = Ex〜Q [fPQ(x)g(x)].	(4)
Let the probability measure PEG := PEX+PGZ denote the average of measures PEX and Pgz.
Both PEX and PGZ are each absolutely continuous with respect to PEG. Hence the RN derivatives
fEG :=
d(PdP+PGZ) = 1 d⅛ and fGE := d(PEP+PGz) = 1 dPGZ exist and sum to 1:
fEG + fGE = d(PEXE+PGz) + d(PEx+%Gz)
d(PEX+ PGZ)
d(PEX + PGz)
1.
(5)
We use (4) and (5) to rewrite the objective V (3) as a single expectation under measure PEG:
V(D,E,G) = E(x,z)〜PEX [log D(x,z)] + E(x,z)〜P°z [log(1 - D(x,z))]
=E(x,z)〜PEG [2f⅛t}(x, z) log D(x, z)] + E(x,z)〜PEG [2fGE}(x, z) log (1 - D(x, z))]
dPEX	dPGZ
dPEG	dPEG
=2E(x,z)〜PEG [fEG(x,z)logD(x,z) + fGE(x,z)log(1 - D(x,z))]
=2E(x,z)〜PEG [fEG(x, z)log D(x, z) + (1 - fEG(x, z))log(1 - D(x, z))].
Note that argmaxy {a log y +(1 — a) log(1 — y)} = a for any a ∈ [0,1]. Thus, DEG = fEG. □
A.2 Proof of Proposition 2 (encoder and generator objective)
Proposition 2 The encoder and generator’s objective for an optimal discriminator C(E, G) :=
maxD V(D, E,G) = V(DEG, E, G) can be rewritten in terms ofthe JenSen-ShannOn divergence
between measures PEX and PGZ as C(E, G) = 2 DJS (PEX || PGZ ) - log 4.
Proof. Using Proposition 1 along with (5) (1 - DEG = 1 - fEG = fGE) We rewrite the objective
C(E, G) = maxDV(D, E, G) = V(DEG, E, G)
=E(x,z)〜PEX [log DEG(X, z)] + E(x,z)〜PGZ [log (I - DEG(X, Z))]
=E(x,z)〜PEX [log fEG(x, z)] + E(x,z)〜PGZ [log fGE (x, z)]
=E(x,z)〜PEX [log(2fEG(x, z))] + E(x,z)〜PGZ [log (2fGE(x, z))] - log4
= DKL (PEX || PEG ) + DKL (PGZ || PEG ) - log 4
= DKL (PEXll PEX+PGZ ) +Dkl (PGZll PEX+PGZ ) - log4
= 2 DJS (PEX || PGZ ) - log 4. □
A.3 MEASURE DEFINITIONS FOR DETERMINISTIC E AND G
While Theorem 1 and Propositions 1 and 2 hold for any encoder pE(z|x) and generator pG(x|z),
stochastic or deterministic, Theorems 2 and 3 assume the encoder E and generator G are deterministic
functions; i.e., with conditionals pE (z|x) = δ(z - E(x)) and pG(x|z) = δ(x - G(z)) defined as δ
functions.
13
Published as a conference paper at ICLR 2017
For use in the proofs of those theorems, we simplify the definitions of measures PEX and PGZ given
in Section 3 for the case of deterministic functions E and G below:
PEX(R) = RΩX PX(X) rωz PE (ZIX)1[(x,z)∈R] dz dχ
=RΩX PX(x) (∕ωz δ(Z - E(X))1[(x,z)∈R] dz) dχ
=RΩχ PX(X)1[(χ,E(χ))∈R] dx
PGZ(R) = Rωz PZ(Z) Rωx PG(XIZ)1[(x,z)∈R] dx dz
=RΩz PZ(Z) (RΩχ δ(X - G(Z))1[(x,z)∈R] dX) dz
=Rωz PZ(Z)1[(G(z),z)∈R] dz
A.4 Proof of Theorem 2 (optimal generator and encoder are inverses)
Theorem 2 If E and G are an optimal encoder and generator, then E = G-1 almost everywhere;
that is, G(E(x)) = X for PX-almost every X ∈ Ωx, and E(G(z)) = Z for PZ-almost every Z ∈ Ωz.
Proof. Let RX := {x ∈ Ωχ : X = G(E(x))} be the region of Ωχ in which the inversion property
X = G(E(X)) does not hold. We will show that, for optimal E and G, RX0 has measure zero under
PX (i.e., PX(R0X) = 0) and therefore X = G(E(X)) holds PX-almost everywhere.
Let R0 := {(x, z) ∈ Ω : z = E(x) ∧ X ∈ RX} be the region of Ω such that (x, E(x)) ∈ R0 if and
only ifX ∈ R0X. We’ll use the definitions ofPEX and PGZ for deterministic E and G (Appendix A.3),
and the fact that PEX = PGZ for optimal E and G (Theorem 1).
PX(RX) = RΩχ PX(X)1[x∈RX] dx
=Rωx PX(X)1[(χ,E(χ))∈R0] dx
= PEX(R0)
= PGZ (R0)
=Rωz PZ(Z)1[(G(z),z)∈R0] dz
=∕ωz PZ(Z)1[z=E(G(z))∧ G(z)∈RX] dz
=∕ωz PZ(Z)	1[z=E(G(z)) ∧ G(Z) = G(E(G(Z)))],	dz
l^^^^^^^^^"^^^^^^^^^{ι^^^^^^^^^^^^^^^^^^—}
=0 for any z, as z=E(G(z)) =⇒ G(z)=G(E(G(z)))
= 0.
Hence region RX0 has measure zero (PX (RX0 ) = 0), and the inversion property X = G(E(X)) holds
PX-almost everywhere.
An analogous argument shows that RZ ：= {z ∈ Ωz : z = E(G(z))} has measure zero on PZ (i.e.,
PZ(RZ0 ) = 0) and therefore Z = E(G(Z)) holds PZ-almost everywhere.
A.5 Proof of Theorem 3 (relationship to autoencoders)
As shown in Proposition 2 (Section 3), the BiGAN objective is equivalent to the Jensen-Shannon
divergence between PEX and PGZ . We now go a step further and show that this Jensen-Shannon
divergence is closely related to a standard autoencoder loss. Omitting the 2 scale factor, a KL
divergence term of the Jensen-Shannon divergence is given as
DKL ( PEXuTZ ) =log2 + {log d(PEXP+PGZ) dPEX
= log 2 +
/
Jω
log f dPEX ,
(6)
where We abbreviate as f the Radon-Nikodym derivative feg := d(p：P+PgZ) ∈ [°，” defined in
Proposition 1 for most of this proof.
14
Published as a conference paper at ICLR 2017
We’ll make use of the definitions of PEX and PGZ for deterministic E and G found in Appendix A.3.
The integral term of the KL divergence expression given in (6) over a particular region R ⊆ Ω will
be denoted by
F(R) := l log/dPEXD、dPEX = l log f dPEX.
R	d (PEX + PGZ )	R
Next we will show that f > 0 holds PEX-almost everywhere, and hence F is always well defined
and finite. We then show that F is equivalent to an autoencoder-like reconstruction loss function.
Proposition 3 f > 0 PEX -almost everywhere.
Proof. Let Rf=0 := {(x, Z) ∈ Ω : f (x, z) = 0} be the region of Ω in which f = 0. Using the
definition of the Radon-Nikodym derivative f, the measure PEX(Rf =0) = Rf=0 f d(PEX +
PGZ) = Rf=0 0 d(PEX + PGZ) = 0 is zero. Hence f > 0 PEX-almost everywhere.
Proposition 3 ensures that log f is defined PEX-almost everywhere, and F(R) is well-defined. Next
we will show that F(R) mimics an autoencoder with `0 loss, meaning F is zero for any region in
which G(E(x)) 6= x, and non-zero otherwise.
Proposition 4 The KL divergence F outside the support of PGZ is zero: F(Ω \ SuPP(PGZ)) = 0∙
We'll first show that in region RS := Ω \ SuPP(Pgz), we have f = 1 Pex-almost everywhere.
Let Rf<1 := {(x, z) ∈ RS : f(x, z) < 1} be the region of RS in which f < 1. Let’s assume that
PEX(Rf<1) > 0 has non-zero measure. Then, using the definition of the Radon-Nikodym derivative,
PEX(Rf<1) = RRf<1 f d(PEX + PGZ) = RRf<1 f dPEX + RRf<1 f dPGZ ≤ εPEX(Rf<1)
|{z}	|{}
≤ε<1	0
< PEX(Rf<1),
where ε is a constant smaller than 1. But PEX(Rf<1) < PEX(Rf<1) is a contradiction; hence
PEX(Rf<1) = 0 and f = 1 PEX-almost everywhere in RS, implying log f = 0 PEX-almost
everywhere in RS. Hence F(RS) = 0.
By definition, F(Ω \ supp(PEχ))
R1 := SuPP(PEX) ∩ SuPP(PGZ).
0 is also zero. The only region where F might be non-zero is
Proposition 5 f < 1 PEX -almost everywhere in R1.
Let Rf=1 := (x, z) ∈ R1 : f(x, z) = 1 be the region in which f = 1. Let’s assume the set
Rf=I = 0 is not empty. By definition of the support1, PEX(Rf=1 > 0 and PGZ(Rf=1) > 0. The
Radon-Nikodym derivative on Rf=1 is then given by
PEX(Rf=1) = RRf=1 f d(PEX + PGZ) = RRf=1 1 d(PEX + PGZ) = PEX(Rf=1) + PGZ(Rf=1),
which implies PGZ(Rf=1) = 0 and contradicts the definition of support. Hence Rf=1 = 0 and
f < 1 PEX-almost everywhere on R1, implying log f < 0 PEX-almost everywhere.
Theorem 3 The encoder and generator objective given an optimal discriminator C(E, G) :=
maxD V (D, E , G) can be rewritten as an `0 autoencoder loss function
C(E,G) = Ex〜PX [1[e(x)∈Ωz∧G(E(x))=x] log fEG(X，E(X))] +
Ez~Pz [1[G(z)∈Ωχ∧E(G(z))=z] Iog(I - fEG(G(Z),z))]
with log fEG ∈ (-∞, 0) and log (1 - fEG) ∈ (-∞, 0) PEX -almost and PGZ-almost everywhere.
Proof. Proposition 4 (F(Ω \ supp(PGz)) = 0) and F(Ω \ SuPP(PEX)) = 0 imply that R1 :=
SuPP(PEX) ∩ SuPP(PGZ) is the only region of Ω where F may be non-zero; hence F(Ω) = F(R1).
1We use the definition U ∩ C = 0 =⇒ μ(U ∩ C) > 0 here.
15
Published as a conference paper at ICLR 2017
Note that
SUpp(PEX) = {(x,E(x)) : X ∈ Ωχ}
SUpp(PGZ) = {(G(z),Z) : Z ∈ Ωz}
=⇒ R1 := SUpp(PEX) ∩ SUpp(PGZ) = {(x, z): E(X) = Z ∧ X ∈ Ωχ ∧ G(Z) = X ∧ Z ∈ Ωz}
n	♦,/	7-11	• /'	_ ʌ	-J-∏ /	\	_ ʌ	1	X-* / TΠ /	∖ ∖	Z-I-V T	• .	.1
So a point (x, E(x)) is in R1 if X ∈ Ωχ, E(x) ∈ Ωz, and G(E(x)) = x. (We can omit the
x ∈ Ωχ condition from inside an expectation over PX, as PX-almost all X ∈ Ωχ have 0 probability.)
Therefore,
DKL (PEXU pex+PGZ ) - log2 = F(Ω) = F(R1)
= RR1 log f(x, Z) dPEχ
=Rω 1[(x,z)∈Ri] log f (x, z) dPEχ
=E(x,z)〜PEX [1[(x,z)∈R1] log f (X, z)]
=Ex〜PX [l[(x,E(x))∈Ri] log f (x,E(x))]
=EX~PX [1[E(x)∈Ωz∧G(E(x))=x] log f(x, E(X))].
Finally, with Propositions 3 and 5, we have f ∈ (0, 1) PEX-almost everywhere in R1, and therefore
log f ∈ (-∞, 0), taking a finite and strictly negative value PEX-almost everywhere.
An analogous argument (along with the fact that fEG + fGE = 1) lets us rewrite the other KL
divergence term
Dkl (PGZll Pex+PGZ ) — log2 = Ez 〜pz [1[g(z)∈Ω χ∧E(G(z))=z] log ∕ge (G(z), z)]
=EZ〜PZ [1[G(z)∈Ωχ∧E(G(z))=z]lθg (I — fEG(G(Z), z))]
The Jensen-Shannon divergence is the mean of these two KL divergences, giving C(E, G):
C(E, G) =2DJS(PEX||PGZ) —log4
=DKL (Pex ll PEχ+PGZ ) +Dkl (Pgz ∣∣ PEX+PGZ ) — log4
=EX~PX [1[E(x)∈Ωz∧G(E(x))=x] log fEG(X，E(X))] +
Ez~PZ [1[g(z)∈Ωχ∧E(G(z))=z]lθg(I — fEG(G(Z),z))] 口
Appendix B	Learning details
In this section we provide additional details on the BiGAN learning protocol summarized in Sec-
tion 3.4. Goodfellow et al. (2014) found for GAN training that an objective in which the real and
generated labels Y are swapped provides stronger gradient signal to G. We similarly observed in
BiGAN training that an “inverse” objective Λ (with the same fixed point characteristics as V ) provides
stronger gradient signal to G and E, where
A(D, G, E) = Ex~pχ [ Ez〜PE (∙∣x) [lθg(1 - D(X, z))] ] + Ez~pZ [ Ex〜PG(TZ) [log D(X, z)]].
×--------------V--------------}	X----------V-----------}
log(1-D(x,E(x)))	log D(G(z),z)
In practice, θG and θE are updated by moving in the positive gradient direction of this inverse
objective Vθe ,Θg Λ, rather than the negative gradient direction of the original objective.
We also observed that learning behaved similarly when all parameters θD, θG, θE were updated
simultaneously at each iteration rather than alternating between θD updates and θG, θE updates, so
we took the simultaneous updating (non-alternating) approach for computational efficiency. (For
standard GAN training, simultaneous updates of θD, θG performed similarly well, so our standard
GAN experiments also follow this protocol.)
16
Published as a conference paper at ICLR 2017
Appendix C	Model and training details
In the following sections we present additional details on the models and training protocols used in
the permutation-invariant MNIST and ImageNet evaluations presented in Section 4.
Optimization For unsupervised training of BiGANs and baseline methods, we use the Adam
optimizer (Kingma & Ba, 2015) to compute parameter updates, following the hyperparameters (initial
step size α = 2 × 10-4, momentum β1 = 0.5 and β2 = 0.999) used by Radford et al. (2016).
The step size α is decayed exponentially to α = 2 × 10-6 starting halfway through training. The
mini-batch size is 128. `2 weight decay of 2.5 × 10-5 is applied to all multiplicative weights in
linear layers (but not to the learned bias β or scale γ parameters applied after batch normalization).
Weights are initialized from a zero-mean normal distribution with a standard deviation of 0.02, with
one notable exception: BiGAN discriminator weights that directly multiply z inputs to be added to
spatial convolution outputs have initializations scaled by the convolution kernel size - e.g., fora 5 X 5
kernel, weights are initialized with a standard deviation of 0.5, 25 times the standard initialization.
Software & hardware We implement BiGANs and baseline feature learning methods using the
Theano (Theano Development Team, 2016) framework, based on the convolutional GAN implemen-
tation provided by Radford et al. (2016). ImageNet transfer learning experiments (Section 4.3) use
the Caffe (Jia et al., 2014) framework, per the Fast R-CNN (Girshick, 2015) and FCN (Long et al.,
2015) reference implementations. Most computation is performed on an NVIDIA Titan X or Tesla
K40 GPU.
C.1 Permutation-invariant MNIST
In all permutation-invariant MNIST experiments (Section 4.2), D, G, and E each consist of two
hidden layers with 1024 units. The first hidden layer is followed by a non-linearity; the second is
followed by (parameter-free) batch normalization (Ioffe & Szegedy, 2015) and a non-linearity. The
second hidden layer in each case is the input to a linear prediction layer of the appropriate size. In D
and E, a leaky ReLU (Maas et al., 2013) non-linearity with a “leak” of 0.2 is used; in G, a standard
ReLU non-linearity is used. All models are trained for 400 epochs.
C.2 ImageNet
In all ImageNet experiments (Section 4.3), the encoder E architecture follows AlexNet (Krizhevsky
et al., 2012) through the fifth and last convolution layer (conv5), with local response normalization
(LRN) layers removed and batch normalization (Ioffe & Szegedy, 2015) (including the learned scaling
and bias) with leaky ReLU non-linearity applied to the output of each convolution at unsupervised
training time. (For supervised evaluation, batch normalization is not used, and the pre-trained scale
and bias is merged into the preceding convolution’s weights and bias.)
In most experiments, both the discriminator D and generator G architecture are those used by Radford
et al. (2016), consisting of a series of four 5 × 5 convolutions (or “deconvolutions” - fractionally-
strided convolutions - for the generator G) applied with 2 pixel stride, each followed by batch
normalization and rectified non-linearity.
The sole exception is our discriminator baseline feature learning experiment, in which we let the
discriminator D be the AlexNet variant described above. Generally, using AlexNet (or similar convnet
architecture) as the discriminator D is detrimental to the visual fidelity of the resulting generated
images, likely due to the relatively large convolutional filter kernel size applied to the input image, as
well as the max-pooling layers, which explicitly discard information in the input. However, for fair
comparison of the discriminator’s feature learning abilities with those of BiGANs, we use the same
architecture as used in the BiGAN encoder.
Preprocessing To produce a data sample x, we first sample an image from the database, and resize
it proportionally such that its shorter edge has a length of 72 pixels. Then, a 64 × 64 crop is randomly
selected from the resized image. The crop is flipped horizontally with probability 2. Finally, the crop
is scaled to [-1, 1], giving the sample x.
17
Published as a conference paper at ICLR 2017
QUery	#1	#2	#3	#4
Figure 5: For the query images used in Krahenbuhl et al. (2016) (left), nearest neighbors (by minimum
cosine distance) from the ImageNet LSVRC (RUssakovsky et al., 2015) training set in the fc6 featUre
space of the ImageNet-trained BiGAN encoder E . (The fc6 weights are set randomly; this space is a
random projection of the learned conv5 feature space.)
Timing A single epoch (one training pass over the 1.2 million images) of BiGAN training takes
roughly 40 minutes on a Titan X GPU. Models are trained for 100 epochs, for a total training time of
under 3 days.
Nearest neighbors In Figure 5 we present nearest neighbors in the feature space of the BiGAN
encoder E learned in unsupervised ImageNet training.
18