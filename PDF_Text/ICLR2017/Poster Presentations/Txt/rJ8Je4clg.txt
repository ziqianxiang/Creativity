Published as a conference paper at ICLR 2017
Learning to Play in a Day: Faster Deep Rein-
forcement Learning by Optimality Tightening
Frank S. He
Department of Computer Science
University of Illinois at Urbana-Champaign
Zhejiang University
frankheshibi@gmail.com
Yang Liu
Department of Computer Science
University of Illinois at Urbana-Champaign
liu301@illinois.edu
Alexander G. Schwing	Jian Peng
Department of Electrical and Computer Engineering Department of Computer Science
University of Illinois at Urbana-Champaign	University of Illinois at Urbana-Champaign
aschwing@illinois.edu	jianpeng@illinois.edu
Ab stract
We propose a novel training algorithm for reinforcement learning which com-
bines the strength of deep Q-learning with a constrained optimization approach
to tighten optimality and encourage faster reward propagation. Our novel tech-
nique makes deep reinforcement learning more practical by drastically reducing
the training time. We evaluate the performance of our approach on the 49 games
of the challenging Arcade Learning Environment, and report significant improve-
ments in both training time and accuracy.
1	Introduction
The recent advances of supervised deep learning techniques (LeCun et al., 2015) in computer vision,
speech recognition and natural language processing have tremendously improved the performance
on challenging tasks, including image processing (Krizhevsky et al., 2012), speech-based transla-
tion (Sutskever et al., 2014) and language modeling (Hinton et al., 2012). The core idea of deep
learning is to use artificial neural networks to model complex hierarchical or compositional data
abstractions and representations from raw input data (Bengio et al., 2013). However, we are still
far from building intelligent solutions for many real-world challenges, such as autonomous driv-
ing, human-computer interaction and automated decision making, in which software agents need to
consider interactions with a dynamic environment and take actions towards goals. Reinforcement
learning (Bertsekas & Tsitsiklis, 1996; Powell, 2011; Sutton & Barto, 1998; Kaelbling et al., 1996)
studies these problems and algorithms which learn policies to make decisions so as to maximize a
reward signal from the environment. One of the promising algorithms is Q-learning (Watkins, 1989;
Watkins & Dayan, 1992). Deep reinforcement learning with neural function approximation (Tsit-
siklis & Roy, 1997; Riedmiller, 2005; Mnih et al., 2013; 2015), possibly a first attempt to combine
deep learning and reinforcement learning, has been proved to be effective on a few problems which
classical AI approaches were unable to solve. Notable examples of deep reinforcement learning
include human-level game playing (Mnih et al., 2015) and AlphaGo (Silver et al., 2016).
Despite these successes, its high demand of computational resources makes deep reinforcement
learning not yet applicable to many real-world problems. For example, even for an Atari game, the
deep Q-learning algorithm (also called deep Q-networks, abbreviated as DQN) needs to play up to
hundreds of millions of game frames to achieve a reasonable performance (van Hasselt et al., 2015).
AlphaGo trained its model using a database of game records of advanced players and, in addition,
about 30 million self-played game moves (Silver et al., 2016). The sheer amount of required com-
putational resources of current deep reinforcement learning algorithms is a major bottleneck for its
applicability to real-world tasks. Moreover, in many tasks, the reward signal is sparse and delayed,
thus making the convergence of learning even slower.
1
Published as a conference paper at ICLR 2017
Here we propose optimality tightening, a new technique to accelerate deep Q-learning by fast reward
propagation. While current deep Q-learning algorithms rely on a set of experience replays, they only
consider a single forward step for the Bellman optimality error minimization, which becomes highly
inefficient when the reward signal is sparse and delayed. To better exploit long-term high-reward
strategies from past experience, we design a new algorithm to capture rewards from both forward
and backward steps of the replays via a constrained optimization approach. This encourages faster
reward propagation which reduces the training time of deep Q-learning.
We evaluate our proposed approach using the Arcade learning environment (Bellemare et al., 2013)
and show that our new strategy outperforms competing techniques in both accuracy and training
time on 30 out of 49 games despite being trained with significantly fewer data frames.
2	Related Work
There have been a number of approaches improving the stability, convergence and runtime of deep
reinforcement learning since deep Q-learning, also known as deep Q-network (DQN), was first
proposed (Mnih et al., 2013; 2015). DQN combined techniques such as deep learning, reinforcement
learning and experience replays (Lin, 1992; Wawrzynski, 2009).
Nonetheless, the original DQN algorithm required millions of training steps to achieve human-
level performance on Atari games. To improve the stability, recently, double Q-learning was com-
bined with deep neural networks, with the goal to alleviate the overestimation issue observed in
Q-learning (Thrun & Schwartz, 1993; van Hasselt, 2010; van Hasselt et al., 2015). The key idea is
to use two Q-networks for the action selection and Q-function value calculation, respectively. The
greedy action of the target is first chosen using the current Q-network parameters, then the target
value is computed using a set of parameters from a previous iteration. Another notable advance is
“prioritized experience replay” (Schaul et al., 2016) or “prioritized sweeping” for deep Q-learning.
The idea is to increase the replay probability of experience tuples that have a high expected learning
progress measured by temporal difference errors.
In addition to the aforementioned variants of Q-learning, other network architectures have been
proposed. The dueling network architecture applies an extra network structure to learn the impor-
tance of states and uses advantage functions (Wang et al., 2015). A distributed version of the deep
actor-critic algorithm without experience replay was introduced very recently (Mnih et al., 2016).
It deploys multiple threads learning directly from current transitions. The approach is applicable to
both value-based and policy-based methods, off-policy as well as on-policy methods, and in discrete
as well as in continuous domains. The model-free episodic control approach evaluates state-action
pairs based on episodic memory using k-nearest neighbors with hashing functions (Blundell et al.,
2016). Bootstrapped deep Q-learning carries out temporally-extended (or deep) exploration, thus
leading to much faster learning (Osband et al., 2016).
Our fast reward propagation differs from all of the aforementioned approaches. The key idea of
our method is to propagate delayed and sparse rewards during Q-network training, and thus greatly
improve the efficiency and performance. We formulate this propagation step via a constrained pro-
gram. Note that our program is also different from earlier work on off-policy Q*(λ) algorithms
with eligibility traces and n-step Q learning (Munos et al., 2016; Watkins, 1989; Mnih et al., 2016),
which have been recently shown to perform poorly when used for training deep Q-networks on Atari
games.
3	Background
Reinforcement learning considers agents which are able to take a sequence of actions in an environ-
ment. By taking actions and experiencing at most one scalar reward per action, their task is to learn
a policy which allows them to act such that a high cumulative reward is obtained over time.
More precisely, consider an agent operating over time t ∈ {1, . . . , T}. At time t the agent is in an
environment state st and reacts upon it by choosing action at ∈ A. The agent will then observe a
new state st+1 and receive a numerical reward rt ∈ R. Throughout, we assume the set of possible
actions, i.e., the set A, to be discrete.
2
Published as a conference paper at ICLR 2017
A well established technique to address the aforementioned reinforcement learning task is Q-
learning (Watkins, 1989; Watkins & Dayan, 1992). Generally, Q-learning algorithms maintain an
action-value function, often also referred to as Q-function, Q(s, a). Given a state s, the action-value
function provides a ‘value’ for each action a ∈ A which estimates the expected future reward if
action a ∈ A is taken. The estimated future reward is computed based on the current state s or a
series of past states st if available.
The core idea of Q-learning is the use of the Bellman equation as a characterization of the optimal
future reward function Q* via a state-action-value function
Q*(st,a) = E[rt + YmaxQ*(st+ι, a0)].	(1)
a0
Hereby the expectation is taken w.r.t. the distribution of state st+1 and reward rt obtained after
taking action a, and γ is a discount factor. Intuitively, reward for taking action a plus best future
reward should equal the best total return from the current state.
The choice of Q-function is crucial for the success of Q-learning algorithms. While classical meth-
ods use linear Q-functions based on a set of hand-crafted features of the state, more recent ap-
proaches use nonlinear deep neural networks to automatically mine intermediate features from the
state (Riedmiller, 2005; Lange & Riedmiller, 2010; Mnih et al., 2013; 2015). This change has
been shown to be very effective for many applications of reinforcement learning. However, auto-
matic mining of intermediate representations comes at a price: larger quantities of data and more
computational resources are required. Even though it is sometimes straightforward to extract large
amounts of data, e.g., when training on video games, for successful optimization, it is crucial that the
algorithms operate on un-correlated samples from a dataset D for stability. A technique called “ex-
perience replay” (Lin, 1992; Wawrzynski, 2009) encourages this property and quickly emerged as a
standard step in the well-known deep Q-learning framework (Mnih et al., 2013; 2015). Experience
replays are stored as a dataset D = {(sj, aj, rj, sj+1)} which contains state-action-reward-future
state-tuples (sj, aj, rj, sj+1), including past observations from previous plays.
The characterization of optimality given in Eq. (1) combined with an “experience replay” dataset D
results in the following iterative algorithmic procedure (Mnih et al., 2013; 2015): start an episode
in the initial state s0; sample a mini-batch of tuples B = {(sj, aj, rj, sj+1)} ⊆ D; compute and
fix the targets yj = rj + γ maxa Qθ- (sj+1, a) for each tuple using a recent estimate Qθ- (the
maximization is only considered if sj is not a terminal state); update the Q-function by optimizing
the following program w.r.t. the parameters θ typically via stochastic gradient descent:
min	(Qθ(sj, aj) - yj)2 .	(2)
(sj,aj,rj,sj+1)∈B
After having updated the parameters of the Q-function we perform an action simulation either choos-
ing an action at random with a small probability , or by following the strategy arg maxa Qθ (st, a)
which is currently estimated. This strategy is also called the -greedy policy. We then obtain the
actual reward rt. Subsequently we augment the replay memory with the new tuple (st, at, rt, st+1)
and continue the simulation until this episode terminates or reaches an upper limit of steps, and
we restart a new episode. When optimizing w.r.t. the parameter θ, a recent Q-network is used to
compute the target yj = rj + γ maxa Qθ- (sj+1, a). This technique is referred to as ‘semi-gradient
descent,’ i.e., the dependence of the target on the parameter θ is ignored.
4	Fast Reward Propagation via Optimality Tightening
Investigating the cost function given in Eq. (2) more carefully, we observe that it operates on a
set of short one-step sequences, each characterized by the tuple (sj, aj, rj, sj+1). Intuitively, each
step encourages an update of the parameters θ, such that the action-value function for the chosen
action aj, i.e., Qθ(sj, aj), is closer to the obtained reward plus the best achievable future value, i.e.,
yj = rj + γ maxa Q(sj+1, a). As we expect from the Bellman optimality equation, it is instructive
to interpret this algorithm as propagating reward information from time j + 1 backwards to time j .
To understand the shortcomings of this procedure consider a situation where the agent only receives
a sparse and delayed reward once reaching a target in a maze. Further let |P | characterize the short-
est path from the agents initial position to the target. For a long time, no real reward is available
3
Published as a conference paper at ICLR 2017
and the aforementioned algorithm propagates randomly initialized future rewards. Once the target
is reached, real reward information is available. Due to the cost function and its property of prop-
agating reward time-step by time-step, it is immediately apparent that it takes at least an additional
O(|P|) iterations until the observed reward impacts the initial state.
In the following we propose a technique which increases the speed of propagation and achieves
improved convergence for deep Q-learning. We achieve this improvement by taking advantage of
longer state-action-reward-sequences which are readily available in the “experience replay memory.”
Not only do we propagate information from time instances in the future to our current state, but
also will we pass information from states several steps in the past. Even though we expect to see
substantial improvements on sequences where rewards are sparse or only available at terminal states,
we also demonstrate significant speedups for situations where rewards are obtained frequently. This
is intuitive as the Q-function represents an estimate for any reward encountered in the future. Faster
propagation of future and past rewards to a particular state is therefore desirable.
Subsequently we discuss our technique for fast reward propagation, a new deep Q-learning algo-
rithm that exploits longer state-transitions in experience replays by tightening the optimization via
constraints. For notational simplicity, we assume that the environmental dynamics is deterministic,
i.e., the new state and the reward are solely determined by the current state and action. It is possible
to show that mathematically our proposed approach also approximately works in stochastic environ-
ments. Please see details in the appendix. From the Bellman optimality equation we know that the
following series of equalities hold for the optimal Q-function Q":
Q* (sj,aj) = rj + Y max Q* (sj+ι, a) = rj + Ymax
aa
rj+1 + Y max
a0
[rj + 2 + Y max Q* (Sj+ 3 ,
矶
Evaluating such a sequence exactly is not possible in a reinforcement learning setting since the
enumeration of intermediate states sj+i requires exponential time complexity O(|A|i). Itis however
possible to take advantage of the episodes available in the replay memory D by noting that the
following sequence of inequalities holds for the optimal action-value function Q* (with the greedy
policy), irrespective of whether a policy π generating the sequence of actions aj, aj+1, etc., which
results in rewards rj, rj+1, etc. is optimal or not:
k
Q*(sj,aj) = rj + γmaxQ*(sj+1,a)] ≥ . . . ≥	γirj+i + γk+1 max Q*(sj+k+1, a) = Lj* k.
a	a,
i=0
Note the definition of the lower bounds Lj*,k for sample j and time horizon k in the aforementioned
series of inequalities.
We can also use this series of inequalities to define upper bounds. To see this note that
k
Q (sj -k-1 , aj-k-1) - Xγirj-k-1+i - γk+1Q* (sj, aj) ≥ 0,
i=0
which follows from the definition of the lower bound by dropping the maximization over the actions,
and a change of indices from j → j - k - 1. Reformulating the inequality yields an upper bound
Uj*,k for sample j and time horizon k by fixing state sj and action aj as follows:
k
Uj*,k=γ-k-1Q*(sj-k-1,aj-k-1)-Xγi-k-1rj-k-1+i ≥Q*(sj,aj).
i=0
In contrast to classical techniques which optimize the Bellman criterion given in Eq. (2), we propose
to optimize the Bellman equation subject to constraints Qθ (sj , aj) ≥ Ljmax = maxk∈{1,...,K} Lj,k,
which defines the largest lower bound, and Qθ (sj , aj) ≤ Ujmin = mink∈{1,...,K} Uj,k, which speci-
fies the smallest upper bound. Hereby, Lj,k and Uj,k are computed using the Q-function Qθ- with
a recent estimated parameter θ- rather than the unknown optimal Q-function Q*, and the integer K
specifies the number of future and past time steps which are considered. Also note that the target
used in the Bellman equation is obtained from yj = Lj,0 = rj + γ maxa Qθ- (sj+1, a). In this
way, we ignore the dependence of the bounds and the target on the parameter θ to stabilize the train-
ing. Taking all the aforementioned definitions into account, we propose the following program for
4
Published as a conference paper at ICLR 2017
Output : Parameters θ of a Q-function
Initialize: θ randomly, set θ- = θ
for episode J 1 to M do
initialize s1;
for t J 1 to T do
Choose action at according to -greedy strategy;
Observe reward rt and next state st+1 ;
Store the tuple (st, at, r%, ∙, st+ι) in replay memory D;
Sample a minibatch of tuples B = {(sj, aj, rj, Rj, sj+1}) from replay memory D;
Update θ with one gradient step of cost function given in Eq. (4);
Reset θ- = θ every C steps;
end
for t J T to 1 do
Compute Rt = r + γRt+ι;
Insert Rt into the corresponding tuple in replay memory D;
end
end
Algorithm 1: Our algorithm for fast reward propagation in reinforcement learning tasks.
reinforcement learning tasks:
min	(Qθ(sj,aj) -yj)2	s.t.
θ
(sj,aj,sj+1,rj)∈B
Qθ(sj,aj) ≥ Ljmax ∀(sj,aj) ∈ B
Qθ(sj,aj) ≤ Ujmin ∀(sj,aj) ∈ B
(3)
This program differs from the classical approach given in Eq. (2) via the constraints, which is cru-
cial. Intuitively, the constraints encourage faster reward propagation as we show next, and result in
tremendously better results as we will demonstrate empirically in Sec. 5.
Before doing so we describe our optimization procedure for the constrained program in Eq. (3) more
carefully. The cost function is generally non-convex in the parameters θ, and so are the constraints.
We therefore make use ofa quadratic penalty method to reformulate the program into
mθin	X	h(Qθ (sj, aj) - yj)2 + λ(Ljmax - Qθ(sj, aj))2+ + λ(Qθ (sj, aj) - Ujmin)2+i , (4)
(sj,aj,rj,sj+1)∈B
where λ is a penalty coefficient and (x)+ = max(0, x) is the rectifier function. Augmenting the cost
function with λ(Ljmax - Qθ(sj, aj))2+ and/or λ(Qθ (sj, aj) - Ujmin)2+ results in a penalty whenever
any optimality bounding constraint gets violated. The quadratic penalty function is chosen for sim-
plicity. The penalty coefficient λ can be set as a large positive value or adjusted in an annealing
scheme during training. In this work, we fix its value, due to time constraints. We optimize this cost
function with stochastic (sub-)gradient descent using an experience replay memory from which we
randomly draw samples, as well as their successors and predecessors. We emphasize that the deriva-
tives correcting the prediction of Q(sj, aj) not only depend on the Q-function from the immediately
successive time step Q(sj+1, a) stored in the experience replay memory, but also on more distant
time instances if constraints are violated. Our proposed formulation and the resulting optimization
technique hence encourage faster reward propagation, and the number of time steps depends on
the constant K and the quality of the current Q-function. We summarize the proposed method in
Algorithm 1.
The computational complexity of the proposed approach increases with the number of considered
time steps K, since additional forward passes are required to compute the bounds Ljmax and Ujmin .
However, we can increase the memory size on the GPU to compute both the bounds and targets in
a single forward pass if K is not too large. If at all a problem, we can further alleviate this increase
by randomly sampling a subset of the constraints rather than exhaustively using all of them. More
informed strategies regarding the choice of constraints are possible as well since we may expect
lower bounds in the more distant future to have a larger impact early in the training. In contrast once
the algorithm is almost converged we may expect lower bounds close to the considered time-step to
have bigger impact.
To efficiently compute the discounted reward over multiple time steps we add a new element to
the experience replay structure. Specifically, in addition to state, action, reward and next state for
5
Published as a conference paper at ICLR 2017
% t7e∙g 一
% 寸、9 i
% 寸 OZi
-
%ZO∙COL ■
%coe∙coL ■
%Z8COL ■
%ZZ∙6L ■
%60∙coe ■
% 寸∞ge ■
%99LCO∙
% 98∙9g
% Z9∙gg,
% ez∙91r
% L6.w
% 9g∙ Wi
% 6∞8σ?
% N9√c?
%S∙N
%coL∞τ7
% eL∙gτ7
% ∙oτ7
% 90Qrτ
% 8Nl>
% 909
%9∙co-
上。6cmc?
% 9cocv
% 807
%8L∙L-
% 寸 00
% Lo
%cogo
%9二
% 9e∙ L
% 9∙L
%COCO
S-IΦPE>U- OOBdS
.|①⅞00
InOxBaJCQ
XOEHV UOESa
① Pgd AUa
XUEoqoQ≤
O=CJ ΦEP
uω<
A£00H φo-
,IePE<
φ,lmuφ>
x∙≡9s<
-SBnbEgS
PUEuJlU0。.ISddOUQ
UeEoedωw
pωQ≤J8>o≤
① A山 φle>μQ-
Spo.I9s4
.lθq∈oAZE」。
OHWH
Θ6uφ> ①Q≤S-Blunz ①⊂0 w
OEroO S三一 ①EEN
6U0O-
U.IO
AeM①①」LL.
6u=moCQ
A£8 Q 6uzsuz
S⊂U81
① UOZ θnωco
6u×0co
七 θc□*o
.ləptzLUEθCQ
」9SeW njOuny
ω①H XUBG
UJElPlUWnI
」。MjOWENM
=ness<
」8 UUnH PEO0≤
UoXXEZ
UMoa PUE⅛
OO-IEOUS
9 一 qlsoLL
PUoqS ① UJE「
O-IFipu 山
=BqUΞoθp>
=mx
XUnClωqnoα
SIa
% LLZt
^φ⊂⊂⊃0 .IWS
Figure 1:	Improvements of our method trained on 10M frames compared to results of 200M frame
DQN training presented by Mnih et al. (2015), using the metric given in Eq. (5).
time-step j , we also store the real discounted return Rj which is the discounted cumulative return
achieved by the agent in its game episode. Rj is computed via Rj = PτT=j γτ-j rτ , where T is the
end of the episode and γ is the discount factor. Rj is then inserted in the replay memory after the
termination of the current episode or after reaching the limit of steps. All in all, the structure of our
experience replay memory consists of tuples of the form (sj, aj, rj, Rj, sj+1). In practice, we also
found that incorporating Rj in the lower bound calculation can further improve the stability of the
training.
We leave the questions regarding a good choice of penalty function and a good choice of the penalty
coefficients to future work. At the moment we use a quadratic penalty function and a constant
penalty coefficient λ identical for both bounds. More complex penalty functions and sophisticated
optimization approaches may yield even better results than the ones we report in the following.
5 Experiments
We evaluate the proposed algorithm on a set of 49 games from the Arcade Learning Environ-
ment (Bellemare et al., 2013) as suggested by Mnih et al. (2015). This environment is considered to
be one of the most challenging reinforcement learning task because of its high dimensional output.
Moreover, the intrinsic mechanism varies tremendously for each game, making it extremely de-
manding to find a single, general and robust algorithm and a corresponding single hyperparameter
setting which works well across all 49 games.
Following existing work (Mnih et al., 2015), our agent predicts an action based on only raw image
pixels and reward information received from the environment. A deep neural network is used as
the function approximator for the Q-function. The game image is resized to an 84 × 84 grayscale
image st . The first layer is a convolutional layer with 32 filters of size 8 × 8 and a stride of 4; the
second layer is a convolutional layer with 64 filters of size 4 × 4 and stride of 2; the third layer is
a convolutional layer with 64 filters of size 3 × 3 and a stride of 1; the next fully connected layer
transforms the input to 512 units which are then transformed by another fully connected layer to an
output size equal to the number of actions in each game. The rectified linear unit (ReLU) is used as
the activation function for each layer. We used the hyperparameters provided by Mnih et al. (2015)
for annealing -greedy exploration and also applied RMSProp for gradient descent. As in previous
work we combine four frames into a single step for processing. We chose the hyperparamenter
K = 4, for GPU memory efficiency when dealing with mini-batches. In addition, we also include
the discounted return Rj = Lj,∞ in the lower bound calculation to further stabilize the training. We
use the penalty coefficient λ = 4 which was obtained by coarsely tuning performance on the games
‘Alien,’ ‘Amidar,’ ‘Assault,’ and ‘Asterix.’ Gradients are also rescaled so that their magnitudes are
comparable with or without penalty. All experiments are performed on an NVIDIA GTX Titan-X
12GB graphics card.
6
Published as a conference paper at ICLR 2017
% 60√8
。_。coo∙gco
%cogc9-
%go∙g- 一
% Wq-
% gcoo一
% 890 -
% 990一
% LCON-
% zoco-
% N9τ j
%6L∙9 -
% eco∙g i
% ocoi
%9LCO■
% Zeco∙
%Coy6 ■
*⅛ZZ∙LL ■
%eo∙coL ■
% LrgL ■
% 二∙9L ■
%ze∙6L ■
%ooe ■
% eoe -
%石.翁■
% 寸∞ge ■
% 9ZCSI■
% LgOco∙
%gezco∙
% LCO8 ■
% 寸 e∙gco∙
%9zo寸■
%6et
%98CO寸■
InoMeaIG
XOEHV UolU①Q
UEUJOedsw
① A山 φω>μd
Θ6uφ> ①Q≤S-Blunz ①⊂0 w
6U0O-
ΦEroo SZ1 ① EBN
Spo.I9s4
① PgdAUa
」EPE<
U.IO
OU=MOG
uω<
ω8H XUEg
IS 8nbE ① S
x∙≡9s4
S-IΦPE>U- OOBdS
ə.ImUφ>
XUEoqoQ≤
pωQ≤-l①>Q≤
① UOZ θnωco
」① UUno -IECo
6u×0co
.lθq∈oAZE」。
ω~⊂⊂ΦH
-I8⅞oω
.ləptzLUEθCQ
」8 UUnH PEO0≤
」9SeW njOuny
o」npu山
A£00H φo-
PUEuJlU0。.ISddOUQ
IuElPIUElnl
OHWH
=BquΞoθp>
七 θc□*o
AeM①①」LL.
」。MjOwENM
9 一 qlsoLL
A£8 Q 6uzsuz
OO-IEOUS
UMoa PUE⅛
UoXXEZ
=ness<
O=CJ ΦEP
PUoqSəlug
=mx
XUnClωqnoα
SIa
Figure 2:	Improvements of our method trained on 10M frames compared to results of 10M frame
DQN training, using the metric given in Eq. (5).
5.1 Evaluation
In previous work (Mnih et al., 2015; van Hasselt et al., 2015; Schaul et al., 2016; Wang et al., 2015),
the Q-function is trained on each game using 200 million (200M) frames or 50M training steps. We
compare to those baseline results obtained after 200M frames using our proposed algorithm which
ran for only 10M frames or 2.5M steps, i.e., 20 times fewer data, due to time constraints. Instead of
training more than 10 days we manage to finish training in less than one day. Furthermore, for a fair
comparison, we replicate the DQN results and compare the performance of the proposed algorithm
after 10M frames to those obtained when training DQN on only 10M frames.
We strictly follow the evaluation procedure in (Mnih et al., 2015) which is often referred to as ‘30
no-op evaluation.’ During both training and testing, at the start of the episode, the agent always
performs a random number of at most 30 no-op actions. During evaluation, our agent plays each
game 30 times for up to 5 minutes, and the obtained score is averaged over these 30 runs. An -
greedy policy with = 0.05 is used. Specifically, for each run, the game episode starts with at most
30 no-op steps, and ends with ‘death’ or after a maximum of 5 minute game-play, which corresponds
to 18000 frames.
Our training consists of M = 40 epochs, each containing 250000 frames, thus 10M frames in
total. For each game, we evaluate our agent at the end of every epoch, and, following common
practice (van Hasselt et al., 2015; Mnih et al., 2015), we select the best agent’s evaluation as the
result of the game. So almost all hyperparameters are selected identical to Mnih et al. (2015) and
Nair et al. (2015).
To compare the performance of our algorithm to the DQN baseline, we follow the approach of Wang
et al. (2015) and measure the improvement in percent using
ScoreAgent - ScoreBaseline
max{ScoreHuman, ScoreBaseline} - ScoreRandom
(5)
We select this approach because the denominator choice of either human or baseline score prevents
insignificant changes or negative scores from being interpreted as large improvements.
Fig. 1 shows the improvement of our algorithm over the DQN baseline proposed by Mnih et al.
(2015) and trained for 200M frames, i.e., 50M steps. Even though our agent is only trained for 10M
frames, we observe that our technique outperforms the baseline significantly. In 30 out of 49 games,
our algorithm exceeds the baseline using only 5% of the baseline’s training frames, sometimes
drastically, e.g., in games such as ‘Atlantis,’ ‘Double Dunk,’ and ‘Krull.’ The remaining 19 games,
often require a long training time. Nonetheless, our algorithm still reaches a satisfactory level of
performance.
7
Published as a conference paper at ICLR 2017
	Training Time	Mean	Median
OUrS (10M)=	less than 1 day (1 GPU) =	345.70%	105.74%
DQN (200MΓ-	more than 10 days (1 GPU)	241.06%	93.52%
D-DQN (200Mr	more than 10 days (1 GPU)	330.3%	114.7%
Table 1: Mean and median human-normalized scores. DQN baseline and D-DQN results are from
Mnih et al. (2015); van Hasselt et al. (2015) and trained with 200M frames while our method is
trained with 10M frames. Note that our approach can be combined with the D-DQN method.
Figure 3: Game scores for our algorithm (blue), DQN (black), DQN+return (red) and DQN(λ)
(yellow) using 10M training frames. 30 no-op evaluation is used and moving average over 4 points
is applied.
In order to further illustrate the effectiveness of our method, we compare our results with our imple-
mentation of DQN trained on 10M frames. The results are illustrated in Fig. 2. We observe a better
performance on 46 out of 49 games, demonstrating in a fair way the potential of our technique.
As suggested by van Hasselt et al. (2015), we use the following score
ScoreNormalized =
ScOreAgent - ScOreRandom
|ScoreHuman - ScoreRandom |
(6)
tO summarize the perfOrmance Of Our algOrithm in a single number. We nOrmalize the scOres Of
Our algOrithm, the baseline repOrted by Mnih et al. (2015), and dOuble DQN (D-DQN) (van Hasselt
et al., 2015), and repOrt the training time, mean and median in Table 1. We Observe Our technique
with 10M frames tO achieve cOmparable scOres tO the D-DQN methOd trained On 200M frames (van
Hasselt et al., 2015), while it OutperfOrms the DQN methOd (Mnih et al., 2015) by a large margin. We
believe that Our methOd can be readily cOmbined with Other techniques develOped fOr DQN, such
as D-DQN (van Hasselt et al., 2015), priOritized experience replay (Schaul et al., 2016), dueling
netwOrks (Wang et al., 2015), and asynchrOnOus methOds (Mnih et al., 2016) tO further imprOve the
accuracy and training speed.
In Fig. 3 we illustrate the evOlutiOn Of the scOre fOr Our algOrithm and the DQN apprOach. In additiOn
We demonstrate two additional techniques: ‘DQN+return' and 'DQN(λ).' ‘DQN+return’ uses only
the discOunted future return as a bOund, but dOes nOt take advantage Of the additiOnal cOnstraints
we ProPoSe. 'DQN(λ)' combines TD-λ with the DQN algorithm. We illustrate the performance of
those four algorithms on the six games ‘Frostbite,’ ‘Atlantis,’ ‘Zaxxon,’ ‘H.E.R.O,’ ‘Q*Bert,’ and
‘ChoPPer Command.’ We observe our method to achieve higher scores than the three baselines on
the majority of the games. We refer the reader to the suPPlementary material for additional results.
6 Conclusion
In this PaPer we ProPosed a novel Program for deeP Q-learning which ProPagates Promising rewards
to achieve significantly faster convergence than the classical DQN. Our method significantly outPer-
forms comPeting aPProaches even when trained on a small fraction of the data on the Atari 2600
domain. In the future, we Plan to investigate the imPact of Penalty functions, advanced constrained
oPtimization techniques and exPlore Potential synergy with other techniques.
8
Published as a conference paper at ICLR 2017
References
M. G. Bellemare, Y. Naddaf, J. Veness, and M. Bowling. The arcade learning environment: An evaluation
platform for general agents. J. of Artificial Intelligence Research, 2013.
Y. Bengio, A. Courville, and P. Vincent. Representation Learning: A Review and New Perspectives. PAMI,
2013.
D. P. Bertsekas and J. N. Tsitsiklis. Neuro-Dynamic Programming. Athena Scientific, 1996.
C. Blundell, B. Uria, A. Pritzel, Y. Li, A. Ruderman, J. Z. Leibo, J. Rae, D. Wierstra, and D. Hassabis. Model-
Free Episodic Control. In http://arxiv.org/pdf/1606.04460v1.pdf, 2016.
G. E. Hinton, L. Deng, D. Yu, G. E. Dahl, A.-R. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. N.
Sainath, and B. Kingsbury. Deep neural networks for acoustic modeling in speech recognition: The shared
views of four research groups. IEEE Signal Processing Magazine, 2012.
L. P. Kaelbling, M. L. Littman, and A. W. Moore. Reinforcement learning: A survey. JMLR, 1996.
A. Krizhevsky, I. Sutskever, , and G. E. Hinton. Imagenet classification with deep convolutional neural net-
works. In Proc. NIPS, 2012.
S. Lange and M. Riedmiller. Deep auto-encoder neural networks in reinforcement learning. In Proc. Int. Jt.
Conf. Neural. Netw., 2010.
Y. LeCun, Y. Bengio, and G. E. Hinton. Deep learning. Nature, 2015.
L.-J. Lin. Self-improving reactive agents based on reinforcement learning, planning and teaching. Machine
Learning, 1992.
V.	Mnih, K. Kavukcuoglu, D. Silver, A. Graves, I. Antonoglou, D. Wierstra, and M. Riedmiller. Playing Atari
with Deep Reinforcement Learning. In NIPS Deep Learning Workshop, 2013.
V.	Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K.
Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran, D. Wierstra,
S. Legg, and D. Hassabis. Human-level control through deep reinforcement learning. Nature, 2015.
V.	Mnih, A. P. Badia, M. Mirza, A. Graves, T. P. Lillicrap, T. Harley, D. Silver, and K. Kavukcuoglu. Asyn-
chronous Methods for Deep Reinforcement Learning. In https://arxiv.org/abs/1602.01783, 2016.
R. Munos, T. Stepleton, A. Harutyunyan, and M. G. Bellemare. Safe and efficient off-policy reinforcement
learning. In Proc. NIPS, 2016.
A. Nair, P. Srinivasan, S. Blackwell, C. Alcicek, R. Fearon, V. Panneershelvam A. De Maria, M. Suleyman,
C. Beattie, S. Petersen, S. Legg, V. Mnih, K. Kavukcuoglu, and D. Silver. Massively Parallel Methods for
Deep Reinforcement Learning. In https://arxiv.org/abs/1507.04296, 2015.
I. Osband, C. Blundell, A. Pritzel, and B. Van Roy. Deep Exploration via Bootstrapped DQN. In
http://arxiv.org/abs/1602.04621, 2016.
W. P. Powell. Approximate Dynamic Programming. Wiley, 2011.
M. Riedmiller. Neural fitted Q iteration - first experiences with a data efficient neural reinforcement learning
method. In Proc. ECML, 2005.
T. Schaul, J. Quan, I. Antonoglou, and D. Silver. Prioritized Experience Replay. In Proc. ICLR, 2016.
D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. van den Driessche, J. Schrittwieser, I. Antonoglou,
V. Panneershelvam, M. Lanctot, S. Dieleman, D. Grewe, J. Nham, N. Kalchbrenner, I. Sutskever, T. Lillicrap,
M. Leach, K. Kavukcuoglu, T. Graepel, and D. Hassabis. Mastering the game of Go with deep neural
networks and tree search. Nature, 2016.
I. Sutskever, O. Vinyals, and Q. V. Le. Sequence to sequence learning with neural networks. In Proc. NIPS,
2014.
R.	S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. MIT Press, 1998.
S.	Thrun and A. Schwartz. Issues in using function approxima- tion for reinforcement learning. In Proc.
Connectionist Models Summer School, 1993.
J. N. Tsitsiklis and B. Van Roy. An analysis of temporal-difference learning with function approximation. 1997.
H. van Hasselt. Double Q-learning. In Proc. NIPS, 2010.
H. van Hasselt, A. Guez, and D. Silver. Deep Reinforcement Learning with Double Q-learning. In
https://arxiv.org/abs/1509.06461, 2015.
Z. Wang, T. Schaul, M. Hessel, H. van Hasselt, M. Lanctot, and N. de Freitas. Dueling Network Architectures
for Deep Reinforcement Learning. In https://arxiv.org/abs/1511.06581, 2015.
C. J. C. H. Watkins. Learning from delayed rewards. PhD thesis, University of Cambridge England, 1989.
C. J. C. H. Watkins and P. Dayan. Q-learning. Machine Learning, 1992.
P. Wawrzynski. Real-time reinforcement learning by sequential actor-critics and experience replay. Neural
Networks, 2009.
9
Published as a conference paper at ICLR 2017
s.t.
A Supplementary Material
Optimality tightening for stochastic environments
Similar to the inequalities we obtained for deterministic environments, we can also derive the fol-
lowing sequence of inequalities holds for the optimal action-value function Q* (with the greedy
policy), under the expectation of the environmental dynamics:
Q*(sj, aj)	= E[rj + γmaxQ*(sj+1, a)]
≥ ...
≥ E[X γirj+i + γk+1 max Q*(sj+k+1, a)]
i=0	a
So we have the following expectation constraint, on trajectories from state sj and action aj .
k
E[Q*(sj,aj) - (X γirj+i + γk+1 max Q*(sj+k+1, a))] ≥ 0
i=0	a
E[Q* (sj, aj) - Lj,k] ≥ 0
We can also use this series of inequalities to define upper bounds, on trajectories to state sj and
action aj .
k
E[Q* (sj, aj) - (γ -k-1 Q* (sj-k-1, aj-k-1) - X γi-k-1rj-k-1+i)] ≤ 0
i=0
E[Q*(sj,aj)-Uj,k] ≤0
With these expectation constraints, we can formulate a constrained optimization problem as follows:
min	(Qθ(sj,aj) -yj)2
θ
(sj,aj,sj +1,rj)∈B
mink E[Qθ (sj, aj) - Lj,k] ≥ 0 ∀ (sj, aj) ∈ B
maxkE[Qθ(sj,aj) - Uj,k] ≤ 0 ∀ (sj,aj) ∈ B .
Applying the quadratic penalty function method, we obtain the objective:
(Qθ(sj, aj) - yj)2 + λ(max E[Lj,k - Qθ(sj, aj)]2+ + max E[(Qθ (sj, aj) - Uj,k)]2+)
kk
(sj,aj,rj,sj+1)∈B
By applying the Jensen’s inequality, we are able to obtain an upper bound by first exchanging the
expectation with the max and then exchanging the expectation with the rectifier function, because
both the max function and the rectifier function are convex.
(Qθ(sj, aj) - yj)2 + E[λ(max Lj,k - Qθ(sj, aj)2+] + E[λ(Qθ (sj, aj) - maxUj,k)2+)]
kk
(sj,aj,rj,sj+1)∈B
It is easy to see that, since we have trajectory samples in the replay memory which were drawn
under the environmental dynamics, we can perform stochastic optimization using these trajectories.
In this way, a sample of this upper bound is identical to that in the deterministic setting in Eq. (4).
As a result, our proposed algorithm can be used to optimize an upper bound of the above constrained
optimization in stochastic environments.
Please note that here we provide a mathematical derivation of our approach for stochastic environ-
ments. We expect that it would work in practice, but due to time constraints and the lack of good
stochastic simulators, we cannot provide any empirical results here.
10
Published as a conference paper at ICLR 2017
B Additional Results
We present our quantitative results in Table S1 and Table S2. We also illustrate the normalized score
provided in Eq. (6) over the number of episodes in Fig. S1.
Game	Random	Human	DQN 200M	Ours 10M
Alien	227.80	6875	3069	1864
Amidar	5.8	1676	739.5	565.67
Assault	222.4	1496	3359	5142.37
Asterix	210	8503	6012	5408.33
Asteroids	719.1	13157	1629	1481.67
Atlantis	12850	29028	85641	316766.67
Bank Heist	14.2	734.4	429.7	596
Battle Zone	2360	37800	26300	30800
Beam Rider	363.9	5775	6846	8069
Bowling	23.1	154.8	42.4	49.3
Boxing	0.1	4.3	71.8	81.17
Breakout	1.7	31.8	401.2	229.79
Centipede	2091	11963	8309	4470.06
Chopper Command	811	9882	6687	6360
Crazy Climber	10781	35411	114103	114146
Demon Attack	152.1	3401	9711	5738.67
Double Dunk	-18.6	-15.5	-18.1	-10.07
Enduro	0	309.6	301.8	672.83
Fishing Derby	-91.7	5.5	-0.8	5.27
Freeway	0	29.6	30.3	31.3
Frostbite	65.2	4335	328.3	3974.11
Gopher	257.6	2321	8520	4660
Gravitar	173	2672	306.7	346.67
H.E.R.O	1027	25763	19950	19975
Ice Hockey	-11.2	0.9	-1.6	-3.43
Jamesbond	29	406.7	576.7	1088.33
Kangaroo	52	3035	6740	11716.67
Krull	1598	2395	3805	9461.1
Kung-Fu Master	258.5	22736	23270	27820
Montezuma’s Revenge	0	4376	0	23.33
Ms. Pacman	307.3	15693	2311	1805
Name This Game	2292	4076	7257	7314.67
Pong	-20.7	9.3	18.9	19.4
Private Eye	24.9	69571	1788	342.37
Q*Bert	163.9	13455	10596	12355
River Raid	1339	13513	8316	8028.33
Road Runner	11.5	7845	18257	29346.67
Robotank	2.2	11.9	51.6	34.5
Seaquest	68.4	20182	5286	4070
Space Invaders	148	1652	1976	995
Star Gunner	664	10250	57997	16653.95
Tennis	-23.8	-8.9	-2.5	-1
Time Pilot	3568	5925	5947	5423.33
Tutankham	11.4	167.6	186.7	232
Up and Down	533.4	9082	8456	14406
Venture	0	1188	380	286.67
Video Pinball	16257	17298	42684	74873.2
Wizard of Wor	563.5	4757	3393	4716.67
Zaxxon	32.5	9173	4977	10598
Table S1:	Raw Scores across 49 games, using 30 no-op start evaluation (5 minutes emulator time,
18000 frames, = 0.05). Results of DQN is taken from Mnih et al. (2015)
11
Published as a conference paper at ICLR 2017
Game	DQN 200M	Ours 10M
Alien	42.74%	24.62%
Amidar	43.93%	33.52%
Assault	246.27%	386.31%
Asterix	69.96%	62.68%
Asteroids	7.32%	6.13%
Atlantis	449.94%	1878.60%
Bank Heist	57.69%	80.78%
Battle Zone	67.55%	80.25%
Beam Rider	119.79%	142.39%
Bowling	14.65%	19.89%
Boxing	1707.14%	1930.24%
Breakout	1327.24%	757.77%
Centipede	62.99%	24.10%
Chopper Command	64.78%	61.17%
Crazy Climber	419.50%	419.67%
Demon Attack	294.22%	171.95%
Double Dunk	16.13%	275.16%
Enduro	97.48%	217.32%
Fishing Derby	93.52%	99.76%
Freeway	102.36%	105.74%
Frostbite	6.16%	91.55%
Gopher	400.43%	213.36%
Gravitar	5.35%	6.95%
H.E.R.O	76.50%	76.60%
Ice Hockey	79.34%	64.22%
Jamesbond	145.00%	280.47%
Kangaroo	224.20%	391.04%
Krull	276.91%	986.59%
Kung-Fu Master	102.38%	122.62%
Montezuma’s Revenge	0%	0.53%
Ms. Pacman	13.02%	9.73%
Name This Game	278.31%	281.54%
Pong	132%	133.67%
Private Eye	2.54%	0.46%
Q*Bert	78.49%	91.73%
River Raid	57.31%	54.95%
Road Runner	232.92%	374.48%
Robotank	509.28%	332.99%
Seaquest	25.94%	19.90%
Space Invaders	121.54%	56.31%
Star Gunner	598.10%	166.81%
Tennis	142.95%	153.02%
Time Pilot	100.93%	78.72%
Tutankham	112.23%	141.23%
Up and Down	92.68%	162.38%
Venture	31.99%	24.13%
Video Pinball	2538.62%	5630.76%
Wizard of Wor	67.47%	99.04%
Zaxxon	54.09%	115.59%
Table S2:	Normalized results across 49 games, using the evaluation score given in Eq. (6)
12
Published as a conference paper at ICLR 2017
LI
O
5
2
(səeisu ①。」① d U-①」0W5 P3z=eullo N
Ooo
0 5 0
2 11
O O
5
O	2	4	6	8	10
Training frames (Ie6)
Figure S1: Convergence of mean and median of normalized percentages on 49 games.
13