Published as a conference paper at ICLR 2017
An Information-Theoretic Framework for
Fast and Robust Unsupervised Learning via
Neural Population Infomax
Wentao Huang & Kechen Zhang
Department of Biomedical Engineering
Johns Hopkins University School of Medicine
Baltimore, MD 21205, USA
{whuang21,kzhang4}@jhmi.edu
Ab stract
A framework is presented for unsupervised learning of representations based on
infomax principle for large-scale neural populations. We use an asymptotic ap-
proximation to the Shannon’s mutual information for a large neural population to
demonstrate that a good initial approximation to the global information-theoretic
optimum can be obtained by a hierarchical infomax method. Starting from the
initial solution, an efficient algorithm based on gradient descent of the final ob-
jective function is proposed to learn representations from the input datasets, and
the method works for complete, overcomplete, and undercomplete bases. As con-
firmed by numerical experiments, our method is robust and highly efficient for
extracting salient features from input datasets. Compared with the main existing
methods, our algorithm has a distinct advantage in both the training speed and the
robustness of unsupervised representation learning. Furthermore, the proposed
method is easily extended to the supervised or unsupervised model for training
deep structure networks.
1	Introduction
How to discover the unknown structures in data is a key task for machine learning. Learning good
representations from observed data is important because a clearer description may help reveal the
underlying structures. Representation learning has drawn considerable attention in recent years
(Bengio et al., 2013). One category of algorithms for unsupervised learning of representations is
based on probabilistic models (Lewicki & Sejnowski, 2000; Hinton & Salakhutdinov, 2006; Lee
et al., 2008), such as maximum likelihood (ML) estimation, maximum a posteriori (MAP) probabil-
ity estimation, and related methods. Another category of algorithms is based on reconstruction error
or generative criterion (Olshausen & Field, 1996; Aharon et al., 2006; Vincent et al., 2010; Mairal
et al., 2010; Goodfellow et al., 2014), and the objective functions usually involve squared errors with
additional constraints. Sometimes the reconstruction error or generative criterion may also have a
probabilistic interpretation (Olshausen & Field, 1997; Vincent et al., 2010).
Shannon’s information theory is a powerful tool for description of stochastic systems and could
be utilized to provide a characterization for good representations (Vincent et al., 2010). However,
computational difficulties associated with Shannon’s mutual information (MI) (Shannon, 1948) have
hindered its wider applications. The Monte Carlo (MC) sampling (Yarrow et al., 2012) is a conver-
gent method for estimating MI with arbitrary accuracy, but its computational inefficiency makes it
unsuitable for difficult optimization problems especially in the cases of high-dimensional input stim-
uli and large population networks. Bell and Sejnowski (Bell & Sejnowski, 1995; 1997) have directly
applied the infomax approach (Linsker, 1988) to independent component analysis (ICA) of data with
independent non-Gaussian components assuming additive noise, but their method requires that the
number of outputs be equal to the number of inputs. The extensions of ICA to overcomplete or
undercomplete bases incur increased algorithm complexity and difficulty in learning of parameters
(Lewicki & Sejnowski, 2000; Kreutz-Delgado et al., 2003; Karklin & Simoncelli, 2011).
1
Published as a conference paper at ICLR 2017
Since Shannon MI is closely related to ML and MAP (Huang & Zhang, 2017), the algorithms of
representation learning based on probabilistic models should be amenable to information-theoretic
treatment. Representation learning based on reconstruction error could be accommodated also by
information theory, because the inverse of Fisher information (FI) is the Cramer-Rao lower bound
on the mean square decoding error of any unbiased decoder (Rao, 1945). Hence minimizing the
reconstruction error potentially maximizes a lower bound on the MI (Vincent et al., 2010).
Related problems arise also in neuroscience. It has long been suggested that the real nervous sys-
tems might approach an information-theoretic optimum for neural coding and computation (Barlow,
1961; Atick, 1992; Borst & Theunissen, 1999). However, in the cerebral cortex, the number of neu-
rons is huge, with about 105 neurons under a square millimeter of cortical surface (Carlo & Stevens,
2013). It has often been computationally intractable to precisely characterize information coding
and processing in large neural populations.
To address all these issues, we present a framework for unsupervised learning of representations
in a large-scale nonlinear feedforward model based on infomax principle with realistic biological
constraints such as neuron models with Poisson spikes. First we adopt an objective function based
on an asymptotic formula in the large population limit for the MI between the stimuli and the neural
population responses (Huang & Zhang, 2017). Since the objective function is usually nonconvex,
choosing a good initial value is very important for its optimization. Starting from an initial value, we
use a hierarchical infomax approach to quickly find a tentative global optimal solution for each layer
by analytic methods. Finally, a fast convergence learning rule is used for optimizing the final objec-
tive function based on the tentative optimal solution. Our algorithm is robust and can learn complete,
overcomplete or undercomplete basis vectors quickly from different datasets. Experimental results
showed that the convergence rate of our method was significantly faster than other existing methods,
often by an order of magnitude. More importantly, the number of output units processed by our
method can be very large, much larger than the number of inputs. As far as we know, no existing
model can easily deal with this situation.
2	Methods
2.1	Approximation of Mutual Information for Neural Populations
Suppose the input X is a K-dimensional vector, X = (xι,…，XK)T, the outputs of N neurons are
denoted by a vector, r = (ri, •…,t，n)t, where We assume N is large, generally N 》K. We
denote random variables by upper case letters, e.g., random variables X and R, in contrast to their
vector values X and r. The MI between X and R is defined by I(X; R)
P(XIr))	, where
P(X) ∕r,χ,
h)r χ denotes the expectation with respect to the probability density function (PDF) p(r, x).
Our goal is to maxmize MI I(X; R) by finding the optimal PDF p(r|X) under some constraint
conditions, assuming that p(r|X) is characterized by a noise model and activation functions f(X; θn)
with parameters θn for the n-th neuron (n = 1, ∙ ∙ ∙ , N). In other words, we optimize p(r∣x) by
solving for the optimal parameters θn . Unfortunately, it is intractable in most cases to solve for the
optimal parameters that maximizes I(X; R). However, if p(X) and p(r|X) are twice continuously
differentiable for almost every X ∈ RK, then for large N we can use an asymptotic formula to
approximate the true value of I(X; R) with high accuracy (Huang & Zhang, 2017):
I(X； R) ' IG = 2(ln(det (密)),+ H(X),	(1)
where det (∙) denotes the matrix determinant and H(X) = 一(lnp(x)iχ is the stimulus entropy,
G(X)=J(X)+P(X),	(2)
J(X) =	一/ d ln P (HX) ∖	(3) ∖	dXdxT	∕r∣x ,
P(X)	=a2 ln P(X)	⑷ ∂x∂XT .
Assuming independent noises in neuronal responses, we have p(r|X) = QnN=1 p(rn|X; θn),
and the Fisher information matrix becomes J(X) ≈ N PkK=11 αkS(X; θk), where S(X; θk) =
2
Published as a conference paper at ICLR 2017
D d ln Pdrx'θk)d ln PxTx"k) E	and ak > 0 (k = 1, ∙ ∙ ∙ ,Kι) is the population density of Param-
x	r|x
eter θk, with PkK=11 αk = 1, and 1 ≤ K1 ≤ N (see Appendix A.1 for details). Since the cerebral
cortex usually forms functional column structures and each column is composed of neurons with the
same properties (Hubel & Wiesel, 1962), the positive integer K1 can be regarded as the number of
distinct classes in the neural population.
Therefore, given the activation function f(x; θk), our goal becomes to find the optimal popula-
tion distribution density αk of parameter vector θk so that the MI between the stimulus x and the
response r is maximized. By Eq. (1), our optimization problem can be stated as follows:
minimize QG[{ak}] = 1 Qn(det(G(X)))〉x ,	(5)
K1
subject to ɪ2 αk = 1, αk > 0, ∀k = 1,…，Ki.	(6)
k=1
Since QG [{αk}] is a convex function of {αk} (Huang & Zhang, 2017), we can readily find the
optimal solution for small K by efficient numerical methods. For large K, however, finding an
optimal solution by numerical methods becomes intractable. In the following we will propose an
alternative approach to this problem. Instead of directly solving for the density distribution {αk}, we
optimize the parameters {αk} and {θk} simultaneously under a hierarchical infomax framework.
2.2 Hierarchical Infomax
For clarity, we consider neuron model with Poisson spikes although our method is easily applicable
to other noise models. The activation function f (X; θn) is generally a nonlinear function, such as
sigmoid and rectified linear unit (ReLU) (Nair & Hinton, 2010). We assume that the nonlinear
function for the n-th neuron has the following form: f(X; θn) = f(yn; θn), where
yn = wnT X.	(7)
T TT
with wn being a K-dimensional weights vector, f(yn; θn) is a nonlinear function, θn = (wTn , θn )T
and θn are the parameter vectors (n = 1,…，N).
In general, it is very difficult to find the optimal parameters, θn, n = 1,…，N, for the following
reasons. First, the number of output neurons N is very large, usually N K. Second, the activation
function f(X; θn) is a nonlinear function, which usually leads to a nonconvex optimization problem.
For nonconvex optimization problems, the selection of initial values often has a great influence on
the final optimization results. Our approach meets these challenges by making better use of the large
number of neurons and by finding good initial values by a hierarchical infomax method.
We divide the nonlinear transformation into two stages, mapping first from X to yn, (n = 1, •…，N),
and then from yn to f(yn; θn), where yn can be regarded as the membrane potential of the n-th
neuron, and f(yn; θn) as its firing rate. As with the real neurons, we assume that the membrane
potential is corrupted by noise:
Yn = Yn + Zn,	⑻
where Zn 〜N(0,σ2) is a normal distribution with mean 0 and variance σ2. Then the mean
membrane potential of the k-th class subpopulation with Nk = Nαk neurons is given by
1 Nk
Yk =寸 X Ykn = Yk + Zk, k =1,…，Ki,	⑼
Nk n=1
Zk 〜N(0, N-1σ2).	(10)
Define vectors y = (K,…，yN)t, y = (yi,… 方勺)1 and y = (yi,…，yκjτ, where y =
WT x (k = 1, ∙ ∙ ∙ , Ki). Notice that yn (n = 1, ∙∙∙ ,N) is also divided into Ki classes, the same
as for rn. If We assume f (x; θk) = f (yk； θk), i.e. assuming an additive GaUSSian noise for yn
(see Eq. 9), then the random variables X, Y, Y, Y and R form a Markov chain, denoted by
X → Y → Y → Y → R (see Figure 1), and We have the following proposition (see Appendix
A.2).
3
Published as a conference paper at ICLR 2017
X	WtX	y Y + Z γ	1 /Nk	γ	f( Y)	R
x1
xk
xK
Figure 1: A neural network interpretaton for random variables X, Y, Y,Y, R.
τr⅛-.	-rττ∙ .ι .ι	1	∙ 1 ι ^vλ ʌ r λ^z^ Yz^ τn ι n æ i i ∙ ^vλ ʌ r λ^z^
Proposition 1. With the random variables X, Y, Y, Y, R and Markov chain X → Y → Y →
Y → R,the following equations hold,
.	.	.	.	.7	.	.一 、
I(X; R)	=	I(Y;	R)	≤	I(Y;	R)	≤	I(Y; R),	(11)
.	.	.	一、	.	7 、
I(X; R)	≤	I(X;	Y)	=	I(X;	Y)	≤	I(X; Y),	(12)
and for large Nk (k = 1,…,Ki),
I(Y; R) ` I(Y; R) ` I(Y; R) = I(X;	R),	(13)
.	.	.	一、	.	7 、
I(X; Y) ` I(X; Y) = I(X; Y)∙	(14)
A major advantage of incorporating membrane noise is that it facilitates finding the optimal solution
by using the infomax principle. Moreover, the optimal solution obtained this way is more robust;
that is, it discourages overfitting and has a strong ability to resist distortion. With vanishing noise
σ2 → 0, we have Yk → Yk, f(yk θk) ` f (yk; θk) = f(x; θk), so that Eqs. (13) and (14) hold as
in the case of large Nk.
To optimize MI I(Y; R), the probability distribution of random variable Y, p(y), needs to be de-
termined, i.e. maximizing I(Y; R) about p(y) under some constraints should yield an optimal
distribution: p* (y) = arg maxp(y)I(Y; R). Let C = maxp(y)I (Y; R) be the channel capacity of
neural population coding, and we always have I(X; R) ≤ C (Huang & Zhang, 2017). To find a
suitable linear transformation from X to Y that is compatible with this distribution p* (y), a reason-
able choice is to maximize I(X; Y) (≤ I(X; Y)), where Y is a noise-corrupted version ofY. This
implies minimum information loss in the first transformation step. However, there may exist many
transformations from X to Y that maximize I(X; Y) (see Appendix A.3.1). Ideally, if we can find
a transformation that maximizes both I(X; Y) and I(Y; R) simultaneously, then I(X; R) reaches
its maximum value: I(X; R) = maxp(y) I (Y; R) = C.
From the discussion above we see that maximizing I(X; R) can be divided into two steps,
namely, maximizing I(X; Y) and maximizing I(Y; R). The optimal solutions of max I(X; Y)
and max I(Y; R) will provide a good initial approximation that tend to be very close to the optimal
solution ofmaxI(X; R).
Similarly, we can extend this method to multilayer neural population networks. For example, a two-
layer network with outputs R⑴ and R(2) form a Markov chain, X → R⑴ → R(I) → R(I) →
4
Published as a conference paper at ICLR 2017
R(2), where random variable R(I) is similar to Y, random variable R(I) is similar to Y, and R(I)
is similar to Y in the above. Then We can show that the optimal solution of max I(X; R(2)) can
be approximated by the solutions of max I(X; R(I)) and max I(R(1); R(2)), with I(R(1); R(2)) `
I(R⑴;R⑵).
More generally, consider a highly nonlinear feedforward neural network that maps the input x to
output z, with Z = F(x；。)= Al ◦…。hi (x), where hi (l = 1,…，L) is a linear or nonlinear
function (Montufar et al., 2014). We aim to find the optimal parameter θ by maximizing I (X; Z). It
is usually difficult to solve the optimization problem when there are many local extrema for F(x;。).
However, if each function hl is easy to optimize, then we can use the hierarchical infomax method
described above to get a good initial approximation to its global optimization solution, and go from
there to find the final optimal solution. This information-theoretic consideration from the neural
population coding point of view may help explain why deep structure networks with unsupervised
pre-training have a powerful ability for learning representations.
2.3 The Objective Function
The optimization processes for maximizing I (X; Y) and maximizing I (Y; R) are discussed in detail
in Appendix A.3. First, by maximizing I(X; Y) (see Appendix A.3.1 for details), we can get the
optimal weight parameter Wk (k = 1, ∙∙∙ , Ki, see Eq. 7) and its population density ɑk (see Eq. 6)
which satisfy
W = [Wi,…，WKi] = aUo∑-1∕2C,
αι =…=ακι = K-1,
(15)
(16)
where a = JKIK-1, C = [ci,…，cκj ∈ RK0×K1, CCT = Ik。，Ik。is a Ko X Ko identity
matrix with integer K0 ∈ [1, K], the diagonal matrix Σ0 ∈ RK0×K0 and matrix U0 ∈ RK×K0 are
given in (A.44) and (A.45), with Ko given by Eq. (A.52). Matrices Σo and Uo can be obtained
by Σ and U with UoT Uo = IK0 and UoΣoUoT ≈ UΣUT ≈ xxT x (see Eq. A.23). The
optimal weight parameter Wk (15) means that the input variable x must first undergo a whitening-
like transformation ^ = Σ-1/2UTx, and then goes through the transformation y = aCTx, with
matrix C to be optimized below. Note that weight matrix W satisfies rank(W) = min(Ko, Ki),
which is a low rank matrix, and its low dimensionality helps reduce overfitting during training (see
Appendix A.3.1).
By maximizing I (Y; R) (see Appendix A.3.2), we further solve the the optimal parameters θk for
the nonlinear functions f (yk； θk), k = 1,…，Ki. Finally, the objective function for our OPtimiZa-
tion problem (Eqs. 5 and 6) turns into (see Appendix A.3.3 for details):
minimize
subject to CCT = IK0,
(17)
(18)
where Φ = diag (φ(yι)2, ∙ ∙ ∙ ,φ(yKι)2), φ(yk) = a-i ∣∂gk(yQ/dy® | (k = 1,…，Ki), gk(yk)
2 Jf‰; θk), yk
a-iyk = CTx, and X = Σ-i∕2UTx. We apply the gradient descent method to
optimize the objective function, with the gradient of Q[C] given by:
dQ[C]
dC
CΦCT) i CΦ + xωT)
(19)
—
where ω = (ωi,…，ωKι )T, ωk = φ(yk)φ0(yk)cT (cΦc,)	Ck, k = 1,…，Ki.
When Ko = Ki (or Ko > Ki), the objective function Q[C] can be reduced to a simpler form,
and its gradient is also easy to compute (see Appendix A.4.1). However, when Ko < Ki, it is
computationally expensive to update C by applying the gradient of Q[C] directly, since it requires
matrix inversion for every x. We use another objective function Q[C] (see Eq. A.118) which is an
approximation to Q[C], but its gradient is easier to compute (see Appendix A.4.2). The function
5
Published as a conference paper at ICLR 2017
K l^X-1^l ∙ . <	∙	. ∙	i' ∙O l^X-1^l ♦ 1 11 ,11	.1	. ∙	1	1 . ∙	i' .Λ	.
Q[C] is the approximation of Q[C], ideally they have the same optimal solution for the parameter
C.
Usually, for optimizing the objective in Eq. 17, the orthogonality constraint (Eq. 18) is unnecessary.
However, this orthogonality constraint can accelerate the convergence rate if we employ it for the
initial iteration to update C (see Appendix A.5).
3 Experimental Results
We have applied our methods to the natural images from Olshausen’s image dataset (Olshausen &
Field, 1996) and the images of handwritten digits from MNIST dataset (LeCun et al., 1998) using
Matlab 2016a on a computer with 12 Intel CPU cores (2.4 GHz). The gray level of each raw image
was normalized to the range of 0 to 1. M image patches with size w × w = K for training were
randomly sampled from the images. We used the Poisson neuron model with a modified sigmoidal
11
tuning function f(y； θ) = 4(1+exp(-βy-b))2 , with g(y) = N f(y； θ) = 1+exp(-βy-b), Where
~
θ
(β, b)T . We obtained the initial values (see Appendix A.3.2): b0
0 andβo ≈ 1.81 JKIK-1.
For our experiments, we set β = 0.5βo for iteration epoch t = 1, .…，t° and β = βo for t
t0 + 1, ∙ ∙∙ , tmax, where t0 = 50.
Firstly, we tested the case ofK = K0 = K1 = 144 and randomly sampled M = 105 image patches
with size 12× 12 from the Olshausen’s natural images, assuming that N = 106 neurons were divided
into K1 = 144 classes and = 1 (see Eq. A.52 in Appendix). The input patches were preprocessed
by the ZCA whitening filters (see Eq. A.68). To test our algorithms, we chose the batch size to be
equal to the number of training samples M, although we could also choose a smaller batch size. We
updated the matrix C from a random start, and set parameters tmax = 300, v1 = 0.4, and τ = 0.8
for all experiments.
In this case, the optimal solution C looked similar to the optimal solution of IICA (Bell & Sejnowski,
1997). We also compared with the fast ICA algorithm (FICA) (Hyvarinen, 1999), which is faster
than IICA. We also tested the restricted Boltzmann machine (RBM) (Hinton et al., 2006) for a
unsupervised learning of representations, and found that it could not easily learn Gabor-like filters
from Olshausen’s image dataset as trained by contrastive divergence. However, an improved method
by adding a sparsity constraint on the output units, e.g., sparse RBM (SRBM) (Lee et al., 2008) or
sparse autoencoder (Hinton, 2010), could attain Gabor-like filters from this dataset. Similar results
with Gabor-like filters were also reproduced by the denoising autoencoders (Vincent et al., 2010),
which method requires a careful choice of parameters, such as noise level, learning rate, and batch
size.
In order to compare our methods, i.e. Algorithm 1 (Alg.1, see Appendix A.4.1) and Algorithm
2 (Alg.2, see Appendix A.4.2), with other methods, i.e. IICA, FICA and SRBM, we implemented
these algorithms using the same initial weights and the same training data set (i.e. 105 image patches
preprocessed by the ZCA whitening filters). To get a good result by IICA, we must carefully select
the parameters; we set the batch size as 50, the initial learning rate as 0.01, and final learning rate
as 0.0001, with an exponential decay with the epoch of iterations. IICA tends to have a faster
convergence rate for a bigger batch size but it may become harder to escape local minima. For
FICA, we chose the nonlinearity function f(u) = log cosh(u) as contrast function, and for SRBM,
we set the sparseness control constant p as 0.01 and 0.03. The number of epoches for iterations was
set to 300 for all algorithms. Figure 2 shows the filters learned by our methods and other methods.
Each filter in Figure 2(a) corresponds to a column vector of matrix C (see Eq. A.69), where each
vector for display is normalized by Ck — Ck/ max(∣Cι,k |,…，∣<⅛,k∣), k = 1,…，Ki. The results
in Figures 2(a), 2(b) and 2(c) look very similar to one another, and slightly different from the results
in Figure 2(d) and 2(e). There are no Gabor-like filters in Figure 2(f), which corresponds to SRBM
with p = 0.03.
Figure 3 shows how the coefficient entropy (CFE) (see Eq. A.122) and the conditional entropy
(CDE) (see Eq. A.125) varied with training time. We calculated CFE and CDE by sampling once
every 10 epoches from a total of 300 epoches. These results show that our algorithms had a fast
convergence rate towards stable solutions while having CFE and CDE values similar to the algorithm
of IICA, which converged much more slowly. Here the values of CFE and CDE should be as small
6
Published as a conference paper at ICLR 2017
(a)	(b)	(c)
(d)	(e)	(f)
Figure 2: Comparison of filters obtained from 105 natural image patches of size 12×12 by our
methods (Alg.1 and Alg.2) and other methods. The number of output filters was K1 = 144. (a):
Alg.1. (b): Alg.2. (c): IICA. (d): FICA. (e): SRBM (p = 0.01). (f): SRBM (p = 0.03).
time (seconds)
time (seconds)
(a)	(b)	(c)
Figure 3: Comparison of quantization effects and convergence rate by coefficient entropy (see
A.122) and conditional entropy (see A.125) corresponding to training results (filters) shown in Fig-
ure 2. The coefficient entropy (panel a) and conditional entropy (panel b and c) are shown as a
function of training time on a logarithmic scale. All experiments run on the same machine using
Matlab. Here we sampled once every 10 epoches out of a total of 300 epoches. We set epoch number
t0 = 50 for Alg.1 and Alg.2 and the start time to 1 second.
as possible for a good representation learned from the same data set. Here we set epoch number
t0 = 50 in our algorithms (see Alg.1 and Alg.2), and the start time was set to 1 second. This
explains the step seen in Figure 3 (b) for Alg.1 and Alg.2 since the parameter β was updated when
epoch number t = t0 . FICA had a convergence rate close to our algorithms but had a big CFE,
which is reflected by the quality of the filter results in Figure 2. The convergence rate and CFE for
SRBM were close to IICA, but SRBM had a much bigger CDE than IICA, which implies that the
information had a greater loss when passing through the system optimized by SRBM than by IICA
or our methods.
7
Published as a conference paper at ICLR 2017
From Figure 3(c) we see that the CDE (or MI I(X; R), see Eq. A.124 and A.125) decreases (or
increases) with the increase of the value of the sparseness control constant p. Note that a smaller
p means sparser outputs. Hence, in this sense, increasing sparsity may result in sacrificing some
information. On the other hand, a weak sparsity constraint may lead to failure of learning Gabor-
like filters (see Figure 2(f)), and increasing sparsity has an advantage in reducing the impact of
noise in many practical cases. Similar situation also occurs in sparse coding (Olshausen & Field,
1997), which provides a class of algorithms for learning overcomplete dictionary representations of
the input signals. However, its training is time consuming due to its expensive computational cost,
although many new training algorithms have emerged (e.g. Aharon et al., 2006; Elad & Aharon,
2006; Lee et al., 2006; Mairal et al., 2010). See Appendix A.5 for additional experimental results.
4 Conclusions
In this paper, we have presented a framework for unsupervised learning of representations via in-
formation maximization for neural populations. Information theory is a powerful tool for machine
learning and it also provides a benchmark of optimization principle for neural information pro-
cessing in nervous systems. Our framework is based on an asymptotic approximation to MI for a
large-scale neural population. To optimize the infomax objective, we first use hierarchical infomax
to obtain a good approximation to the global optimal solution. Analytical solutions of the hierarchi-
cal infomax are further improved by a fast convergence algorithm based on gradient descent. This
method allows us to optimize highly nonlinear neural networks via hierarchical optimization using
infomax principle.
From the viewpoint of information theory, the unsupervised pre-training for deep learning (Hinton &
Salakhutdinov, 2006; Bengio et al., 2007) may be reinterpreted as a process of hierarchical infomax,
which might help explain why unsupervised pre-training helps deep learning (Erhan et al., 2010). In
our framework, a pre-whitening step can emerge naturally by the hierarchical infomax, which might
also explain why a pre-whitening step is useful for training in many learning algorithms (Coates
et al., 2011; Bengio, 2012).
Our model naturally incorporates a considerable degree of biological realism. It allows the opti-
mization of a large-scale neural population with noisy spiking neurons while taking into account of
multiple biological constraints, such as membrane noise, limited energy, and bounded connection
weights. We employ a technique to attain a low-rank weight matrix for optimization, so as to reduce
the influence of noise and discourage overfitting during training. In our model, many parameters
are optimized, including the population density of parameters, filter weight vectors, and parameters
for nonlinear tuning functions. Optimizing all these model parameters could not be easily done by
many other methods.
Our experimental results suggest that our method for unsupervised learning of representations has
obvious advantages in its training speed and robustness over the main existing methods. Our model
has a nonlinear feedforward structure and is convenient for fast learning and inference. This simple
and flexible framework for unsupervised learning of presentations should be readily extended to
training deep structure networks. In future work, it would interesting to use our method to train deep
structure networks with either unsupervised or supervised learning.
Acknowledgments
We thank Prof. Honglak Lee for sharing Matlab code for algorithm comparison, Prof. Shan Tan for
discussions and comments and Kai Liu for helping draw Figure 1. Supported by grant NIH-NIDCD
R01 DC013698.
References
Aharon, M., Elad, M., & Bruckstein, A. (2006). K-SVD: An algorithm for designing overcomplete
dictionaries for sparse representation. Signal Processing, IEEE Transactions on, 54(11), 43l1-
4322.
8
Published as a conference paper at ICLR 2017
Amari, S. (1999). Natural gradient learning for over- and under-complete bases in ica. Neural
ComPut ,11(8),1875-1883.
Atick, J. J. (1992). Could information theory provide an ecological theory of sensory processing?
Network: ComP. Neural., 3(2), 213-251.
Barlow, H. B. (1961). Possible principles underlying the transformation of sensory messages. Sen-
sory Communication, (pp. 217-234).
Bell, A. J. & Sejnowski, T. J. (1995). An information-maximization approach to blind separation
and blind deconvolution. Neural ComPut., 7(6), 1129-1159.
Bell, A. J. & Sejnowski, T. J. (1997). The ”independent components” of natural scenes are edge
filters. Vision Res., 37(23), 3327-3338.
Bengio, Y. (2012). Deep learning of representations for unsupervised and transfer learning. Unsu-
Pervised and Transfer Learning Challenges in Machine Learning, 7, 19.
Bengio, Y., Courville, A., & Vincent, P. (2013). Representation learning: A review and new per-
spectives. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 35(8), 1798-1828.
Bengio, Y., Lamblin, P., Popovici, D., Larochelle, H., et al. (2007). Greedy layer-wise training of
deep networks. Advances in neural information Processing systems, 19, 153.
Borst, A. & Theunissen, F. E. (1999). Information theory and neural coding. Nature neuroscience,
2(11), 947-957.
Carlo, C. N. & Stevens, C. F. (2013). Structural uniformity of neocortex, revisited. Proceedings of
the National Academy of Sciences, 110(4), 1488-1493.
Coates, A., Ng, A. Y., & Lee, H. (2011). An analysis of single-layer networks in unsupervised
feature learning. In International conference on artificial intelligence and statistics (pp. 215-
223).
Cortes, C. & Vapnik, V. (1995). Support-vector networks. Machine learning, 20(3), 273-297.
Cover, T. M. & Thomas, J. A. (2006). Elements of Information, 2nd Edition. New York: Wiley-
Interscience.
Edelman, A., Arias, T. A., & Smith, S. T. (1998). The geometry of algorithms with orthogonality
constraints. SIAM J. Matrix Anal. APPl., 20(2), 303-353.
Elad, M. & Aharon, M. (2006). Image denoising via sparse and redundant representations over
learned dictionaries. Image Processing, IEEE Transactions on, 15(12), 3736-3745.
Erhan, D., Bengio, Y., Courville, A., Manzagol, P.-A., Vincent, P., & Bengio, S. (2010). Why does
unsupervised pre-training help deep learning? The Journal of Machine Learning Research, 11,
625-660.
Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., Courville, A., &
Bengio, Y. (2014). Generative adversarial nets. In Advances in Neural Information Processing
Systems (pp. 2672-2680).
Hinton, G. (2010). A practical guide to training restricted boltzmann machines. Momentum, 9(1),
926.
Hinton, G., Osindero, S., & Teh, Y.-W. (2006). A fast learning algorithm for deep belief nets. Neural
comPutation, 18(7), 1527-1554.
Hinton, G. E. & Salakhutdinov, R. R. (2006). Reducing the dimensionality of data with neural
networks. Science, 313(5786), 504-507.
Huang, W. & Zhang, K. (2017). Information-theoretic bounds and approximations in neural popu-
lation coding. Neural ComPut, submitted, URL httPs://arxiv.org/abs/1611.01414.
9
Published as a conference paper at ICLR 2017
Hubel, D. H. & Wiesel, T. N. (1962). Receptive fields, binocular interaction and functional archi-
tecture in the cat's visual cortex. The Journal of physiology, 160(1), 106-154.
Hyvarinen, A. (1999). Fast and robust fixed-point algorithms for independent component analysis.
Neural Networks, IEEE Transactions on, 10(3), 626-634.
Karklin, Y. & Simoncelli, E. P. (2011). Efficient coding of natural images with a population of noisy
linear-nonlinear neurons. In Advances in neural information processing systems, volume 24 (pp.
999-1007).
Konstantinides, K. & Yao, K. (1988). Statistical analysis of effective singular values in matrix rank
determination. Acoustics, Speech and Signal Processing, IEEE Transactions on, 36(5), 757-763.
Kreutz-Delgado, K., Murray, J. F., Rao, B. D., Engan, K., Lee, T. S., & Sejnowski, T. J. (2003).
Dictionary learning algorithms for sparse representation. Neural computation, 15(2), 349-396.
LeCun, Y., Bottou, L., Bengio, Y., & Haffner, P. (1998). Gradient-based learning applied to docu-
ment recognition. Proceedings of the IEEE, 86(11), 2278-2324.
Lee, H., Battle, A., Raina, R., & Ng, A. Y. (2006). Efficient sparse coding algorithms. In Advances
in neural information processing systems (pp. 801-808).
Lee, H., Ekanadham, C., & Ng, A. Y. (2008). Sparse deep belief net model for visual area v2. In
Advances in neural information processing systems (pp. 873-880).
Lewicki, M. S. & Olshausen, B. A. (1999). Probabilistic framework for the adaptation and compar-
ison of image codes. JOSA A, 16(7), 1587-1601.
Lewicki, M. S. & Sejnowski, T. J. (2000). Learning overcomplete representations. Neural compu-
tation, 12(2), 337-365.
Linsker, R. (1988). Self-Organization in a perceptual network. Computer, 21(3), 105-117.
Mairal, J., Bach, F., Ponce, J., & Sapiro, G. (2009). Online dictionary learning for sparse coding.
In Proceedings of the 26th annual international conference on machine learning (pp. 689-696).:
ACM.
Mairal, J., Bach, F., Ponce, J., & Sapiro, G. (2010). Online learning for matrix factorization and
sparse coding. The Journal of Machine Learning Research, 11, 19-60.
Montufar, G. F., Pascanu, R., Cho, K., & Bengio, Y. (2014). On the number of linear regions of deep
neural networks. In Advances in Neural Information Processing Systems (pp. 2924-2932).
Nair, V. & Hinton, G. E. (2010). Rectified linear units improve restricted boltzmann machines. In
Proceedings of the 27th International Conference on Machine Learning (ICML-10) (pp. 807-
814).
Olshausen, B. A. & Field, D. J. (1996). Emergence of simple-cell receptive field properties by
learning a sparse code for natural images. Nature, 381(6583), 607-609.
Olshausen, B. A. & Field, D. J. (1997). Sparse coding with an overcomplete basis set: A strategy
employed by v1? Vision Res., 37(23), 3311-3325.
Rao, C. R. (1945). Information and accuracy attainable in the estimation of statistical parameters.
Bulletin of the Calcutta Mathematical Society, 37(3), 81-91.
Shannon, C. (1948). A mathematical theory of communications. Bell System Technical Journal, 27,
379-423 and 623-656.
Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014). Dropout:
A simple way to prevent neural networks from overfitting. The Journal of Machine Learning
Research, 15(1), 1929-1958.
10
Published as a conference paper at ICLR 2017
Vincent, P., Larochelle, H., Lajoie, I., Bengio, Y., & Manzagol, P.-A. (2010). Stacked denoising
autoencoders: Learning useful representations in a deep network with a local denoising criterion.
The Journal ofMachine Learning Research,11, 3371-3408.
Yarrow, S., Challis, E., & Series, P. (2012). Fisher and shannon information in finite neural popula-
tions. Neural computation, 24(7), 1740-1780.
Appendix
A.1 Formulas for Approximation of Mutual Information
It follows from I(X; R) =
and Eq. (1) that the conditional entropy should read:
H(X|R) = -hlnP(x∣r)ir,χ '— 2	(det (密)))∙	(A」)
The Fisher information matrix J(x) (see Eq. 3), which is symmetric and positive semidefinite, can
be written also as
J(x)
∂ ln p(r|x) ∂ ln p(r|x)
dx	dxT ∕r∣x
(A.2)
If we suppose p(r|x) is conditional independent, namely, p(r|x) = QnN=1 p(rn|x; θn), then we
have (see Huang & Zhang, 2017)
J(x)
p(θ)S(x; θ)dθ,
S(x; θ)
∂ lnp(r|x; θ) ∂ ln p(r|x; θ)
∂x	∂xT
where p(θ) is the population density function of parameter θ,
1N
p(θ) = NN ∑δ(θ - θn),
n=1
(A.3)
(A.4)
(A.5)
and δ(∙) denotes the Dirac delta function. It can be proved that the approximation function of MI
IG[p(θ)] (Eq. 1) is concave about p(θ) (Huang & Zhang, 2017). In Eq. (A.3), we can approximate
the continuous integral by a discrete summation for numerical computation,
K1
J(x) ≈N X αkS(x; θk),	(A.6)
k=1
where PK=I αk = 1, αk > 0, k =1,…，Kι, 1 ≤ Ki ≤ N.
For Poisson neuron model, by Eq. (A.4) we have (see Huang & Zhang, 2017)
p(r|x; θ)
S(x; θ)
f(x;θ) exp(-f (x； θ)),
r!
1	∂f(x; θ) ∂f(x; θ)
f (x； θ)	∂X	∂xT
(A.7)
N
Θ
∂g(x; θ) ∂g(x; θ)
∂x	∂ xT
(A.8)
where f(x； θ) ≥ 0 is the activation function (mean response) of neuron and
g(x; θ) = 2√f (x； θ).
(A.9)
11
Published as a conference paper at ICLR 2017
Similarly, for Gaussian noise model, we have
p(rlx;θ) = σ√πexp (- (r- fσx θ"2 !，	(A.10)
S(x; θ) = ⅛ S fτθ),	(A.11)
where σ > 0 denotes the standard deviation of noise.
Sometimes We do not know the specific form of P(X) and only know M samples, xι, •…，XM,
which are independent and identically distributed (i.i.d.) samples drawn from the distribution p(x).
Then we can use the empirical average to approximate the integral in Eq. (1):
1M
IG ≈ - ]Tln(det(G(xm))) + H (X).	(A.12)
m=1
A.2 Proof of Proposition 1
Proof. It follows from the data-processing inequality (Cover & Thomas, 2006) that
	.	.	.	.	.J	.	.—	. I (X; R) ≤ I (Y; R) ≤ I (Y; R) ≤ I (Y; R), .	.	.	—.	.	J .	.	. I(X; R) ≤ I(X; Y) ≤ I(X; Y) ≤ I(X; Y).	(A.13) (A.14)
Since		
	P(yk∣χ) = P(ykι, ∙ ∙ ∙, ykNk ∣χ) = N(WTχ, N-1σ2), k = 1,…，Kι,	(A.15)
we have		
	P(y∣χ) = P(y∣χ),	(A.16)
	P(y) = P(y),	(A.17)
			J I (X; Y)= I (X; Y).	(A.18)
Hence, by (A.14) and (A.18), expression (12) holds.
On the other hand, when Nk is large, from Eq. (10) we know that the distribution of Zk, namely,
N(0, N-1σ2), approaches a Dirac delta function δ(zQ. Then by (7) and (9) we have P (r|y) `
p(r|y) = p (r|X) and
I(X; R) = I(Y;R) - ln
I (Y; R) = I (Y; R) -〈 ln
I (Y; R) = I (Y; R) - (ln
I(X; Y) = I(X; Y)-〈ln
P (r|y)
P (r|x)
P (r∣y)'
p (r|y),
P (r∣y)'
p (r|y),
P (χ∣y)
p (χ∣y)
= I (Y ; R) ,
r,x
` I (Y; R),
r,y,y
,J .
` I (Y; R),
r,y,y
` I (X ； Y).
x,y,yy
(A.19)
(A.20)
(A.21)
(A.22)
It follows from (A.13) and (A.19) that (11) holds. Combining (11), (12) and (A.20)-(A.22), we
immediately get (13) and (14). This completes the proof of Proposition 1.
A.3 HIERARCHICAL OPTIMIZATION FOR MAXIMIZING I(X; R)
In the following, we will discuss the optimization procedure for maximizing I(X; R) in two stages:
♦	♦	♦ τ / PT- -χjr∖ 1	♦	♦	♦ 丁 r r C∖
maximizing I(X; Y) and maximizing I(Y; R).
12
Published as a conference paper at ICLR 2017
A.3.1 The 1st Stage
T . 1 r∙	1	∙	♦♦	. <	>11	7- / -ττ-	1	.	.1	. ∙	1	.
In the first stage, our goal is to maximize the MI I(X; Y ) and get the optimal parameters wk
(k = 1,…,Ki). Assume that the stimulus X has zero mean (if not, let X J X - hx)χ) and
covariance matrix Σx. It follows from eigendecomposition that
∑x =〈xxT〉x ≈ M1-1XXT = u∑ut,	(a.23)
where X = [x1,…，xM], U = [u1,…，UK] ∈ Rk×k is an unitary orthogonal matrix and Σ =
diag (σ2,…，σK is a positive diagonal matrix with σ1 ≥ ∙∙∙ ≥ σκ > 0. Define
X = £-1/2 UT x,	(A.24)
W k = ∑1∕2UT Wk,	(A.25)
yk = W T x,	(A.26)
where k = 1, ∙∙∙ ,Ki. The covariance matrix of X is given by
Σχ
xxxxT xχ
≈ IK,
(A.27)
1 τ ♦ T7 τ›r ∙ ι . ∙ .	. ∙ τ-,	∙>∕a<<∖	i	τ / 、T -ilr∖ τ / ^tr $八 ι
and IK is a K × K identity matrix. From (1) and (A.11) we have I(X; Y ) = I(X; Y ) and
I(X Y)' IG=lln(det(2l
,~ .
+ H(X),
(A.28)
K1
Gx ≈ Nσ-2 XαkWxkWxkT + IK.
k=1
The following approximations are useful (see Huang & Zhang, 2017):
p(xX) ≈N (0, IK),
(A.29)
(A.30)
P(xx)
∂2 ln p (xx)
∂XdXT	≈ IK.
(A.31)
—
By the central limit theorem, the distribution of random variable X is closer to a normal distribu-
tion than the distribution of the original random variable X . On the other hand, the PCA models
assume multivariate gaussian data whereas the ICA models assume multivariate non-gaussian data.
Hence by a PCA-like whitening transformation (A.24) we can use the approximation (A.31) with
the Laplace’s method of asymptotic expansion, which only requires that the peak be close to its
mean while random variable X needs not be exactly Gaussian.
Without any constraints on the Gaussian channel of neural populations, especially the peak firing
rates, the capacity of this channel may grow indefinitely: I(X; Y) → ∞. The most common
constraint on the neural populations is an energy or power constraint which can also be regarded as
a signal-to-noise ratio (SNR) constraint. The SNR for the output yn of the n-th neuron is given by
SNRn = σ12 D(WTx)2E ≈ σ12WTWn, n = 1,…，N.	(A.32)
We require that
1 N	1 K1
^77〉：SNRn ≈ f〉: αk WkWk ≤ ρ,	(A.33)
N	σ2
n=1	k=1
where ρ is a positive constant. Then by Eq. (A.28), (A.29) and (A.33), we have the following
optimization problem:
minimize QG[W] = -2ln (det (Nσ-2WWT + IK)),	(A.34)
subject to h = Tr (WWT) — E ≤ 0,	(A.35)
13
Published as a conference paper at ICLR 2017
where Tr (∙) denotes matrix trace and
W = WA1/ = £1/2UTWA1/2 = W1,…，WK1], A = diag(ai,…，aκι), W = [wi,…，WKi ], TT T	Γ ~	~	1 W = [w 1,…，WKi ], E = ρσ2.	(A.36) (A.37) (A.38) (A.39) (A.40)
Here E is a constant that does not affect the final optimal solution so we set E = 1. Then we obtain
an optimal solution as follows:
W	=aUo∑-"VT,	(A.41)
A	K1-1IKi,	(A.42)
a	=d EKiK- = q KiK-,	(A.43)
Σo	=diag (σ2,…，σK0),	(A.44)
Uo	U(:, 1:Ko) ∈ RK×K0,	(A.45)
Vo	V(:, 1:Ko) ∈ RKi×K0,	(A.46)
where V = [vι, ∙∙∙ , vκj is an Ki X Ki unitary orthogonal matrix, parameter Ko represents the
size of the reduced dimension (1 ≤ K0 ≤ K), and its value will be determined below. Now the
optimal parameters Wn (n = 1,…，N) are clustered into Ki classes (see Eq. A.6) and obey an
uniform discrete distribution (see also Eq. A.60 in Appendix A.3.2).
When K = K0 = Ki, the optimal solution of W in Eq. (A.41) is a whitening-like filter. When
V = IK, the optimal matrix W is the principal component analysis (PCA) whitening filters. In the
symmetrical case with V = U, the optimal matrix W becomes a zero component analysis (ZCA)
whitening filter. If K < Ki , this case leads to an overcomplete solution, whereas when K0 ≤ Ki <
K, the undercomplete solution arises. Since K0 ≤ Ki and K0 ≤ K, Q0G achieves its minimum
when K0 = K . However, in practice other factors may prevent it from reaching this minimum. For
example, consider the average of squared weights,
K1	E K0
ς = Eak kwkk2 = Tr (WAWT) = K^∑σ-2,	(A.47)
k=i	0 k=i
where ∣∣∙k denotes the Frobenius norm. The value of ς is extremely large when any σk becomes
vanishingly small. For real neurons these weights of connection are not allowed to be too large.
Hence we impose a limitation on the weights: ς ≤ Ei, where Ei is a positive constant. This yields
another constraint on the objective function,
E K0
h = ~ΓΓ 5"2 σk - EI ≤ 0.	(A.48)
K0 k=i k
From (A.35) and (A.48) We get the optimal Ko = arg max2κθ (EK-1 PK=I σ-2). By this con-
straint, small values of σk2 will often result in K0 < K and a low-rank matrix W (Eq. A.41).
On the other hand, the low-rank matrix W can filter out the noise of stimulus x. Consider the
transformation Y = WTX with X = [xi, •…，XM] and Y = [yi, •…，yM] for M samples. It
follows from the singular value decomposition (SVD) of X that
T
X = USV ,	(A.49)
where U is given in (A.23), V is a M × M unitary orthogonal matrix, S is a K × M diagonal matrix
with non-negative real numbers on the diagonal, Sk,k = √M - 1 σk (k = 1,…，K, K ≤ M), and
SST = (M - 1)Σ. Let
X = √M-1 Uo£0/2VT ≈ X,	(A.50)
14
Published as a conference paper at ICLR 2017
where V0 = V (:, 1:Ko) ∈ RM×K0, ∑o and Uo are given in (A.44) and (A.45), respectively. Then
Y = WTX = aV0Σ-"UTUSVT = WTX = a√M - 1V0VT,	(A.51)
where X can be regarded as a denoised version of X. The determination of the effective rank
Ko ≤ K of the matrix X by using singular values is based on various criteria (Konstantinides &
Yao, 1988). Here we choose K0 as follows:
K0 = arg min
K00
PK= ι σ ≥ ∖
pK=i 琢一)
(A.52)
where is a positive constant (0 < ≤ 1).
Another advantage of a low-rank matrix W is that it can significantly reduce overfitting for learning
neural population parameters. In practice, the constraint (A.47) is equivalent to a weight-decay reg-
ularization term used in many other optimization problems (Cortes & Vapnik, 1995; Hinton, 2010),
which can reduce overfitting to the training data. To prevent the neural networks from overfitting,
Srivastava et al. (2014) presented a technique to randomly drop units from the neural network dur-
ing training, which may in fact be regarded as an attempt to reduce the rank of the weight matrix
because the dropout can result in a sparser weights (lower rank matrix). This means that the update
is only concerned with keeping the more important components, which is similar to first performing
a denoising process by the SVD low rank approximation.
In this stage, we have obtained the optimal parameter W (see A.41). The optimal value of matrix
V0 can also be determined, as shown in Appendix A.3.3.
A.3.2 The 2nd Stage
For this stage, our goal is to maximize the MI I(Y ; R) and get the optimal parameters θk,
k = 1,…,Ki. Here the input is y = (yι,…，yKJT and the output r = (ri, •…，『n)t is
also clustered into K1 classes. The responses of Nk neurons in the k-th subpopulation obey a Pois-
son distribution with mean f(eTy; θk), where ek is a unit vector with 1 in the k-th element and
yk = ekT y. By (A.24) and (A.26), we have
hyk iyk = 0,
σyk =〈y2〉yk = kwk∣∣2 .
Then for large N, by (1)-(4) and (A.30) We can use the following approximation,
1
I (Y; R) ` IF = 2
+ H(Y),
where
J(y) = diag(Nai |gi (yi)|2 , ∙∙∙ ,NaKι ∖gfκ 1 (yKJ∣2),
gk(yk) = ‘gk("k), k = 1,…,Ki,
∂yk
gk(yk) = 2ʌ/f(yk; θk), k = 1,…，Ki.
(A.53)
(A.54)
(A.55)
(A.56)
(A.57)
(A.58)
It is easy to get that
=1 X (ln(
≤ 2 X *m (
Nak |gk(yk)|2
2πe
y+H(Y)
|gkJyk)∣2) ) - K1 in
+ H(Y),
(A.59)
15
Published as a conference paper at ICLR 2017
where the equality holds if and only if
αk =vh, k = 1,…，K1,
K1
(A.60)
which is consistent with Eq. (A.42).
On the other hand, it follows from the Jensen’s inequality that
(A.61)
det J(y))i∕2	=	QKlι |gk(y)|
Rdet J(y)) 1/2 dy	RQK=I |gk(yk)| dy
(A.62)
From (A.61) and (A.62), maximizing IF yields
p (yk)
|gk (y X
R |gk (yk )| dyk
k = 1,…，K1.
(A.63)
We assume that (A.63) holds, at least approximately. Hence we can let the peak of gk0 (yk) be at
y = hykiyk = 0 and (y2)yk = σ2k = kwkk2. Then combining (A.57), (A.61) and (A.63) We find
the optimal parameters θk for the nonlinear functions f(yk; θk), k = 1,…，K1.
A.3.3 The Final Objective Function
In the preceding sections we have obtained the initial optimal solutions by maximizing I(X ； Y)
and I(Y ; R). In this section, We Will discuss hoW to find the final optimal V0 and other parameters
by maximizing I(X; R) from the initial optimal solutions.
First, we have	y	二 W T x =	二 ay,	(A.64)
where a is given in (A.43) and
y =	二 (y1,…	∙ ,yκι )T = CT x =	二 C T 文，	(A.65)
X =	=Σ-1/2	U0T X,		(A.66)
C	= V0T ∈	RK0×K1,		(A.67)
X =	U0Σ0-	1/2UT X = UoX,		(A.68)
C 二	= U0C	= [C1,…，Cki ].		(A.69)
It follows that
I(X; R) = I(X; R) ` IG
T
G(X)= N WΦW + IK,
WW = Σ1∕2UT WA1/2 = a
(A.70)
(A.71)
(A.72)
16
Published as a conference paper at ICLR 2017
where IKK is a K × K0 diagonal matrix with value 1 on the diagonal and			
Φ = Φ2,			(A.73)
Φ = diag(φ(yι), ∙∙∙ ,Φ(yκι)),			(A.74)
φ(yk) = a-1	∂gk (yk) ∂yk	,	(A.75)
gk (yk) =2 Vf(yk； θk)		,	(A.76)
yk = a yk = Ck x, k		=1,…，K1.	(A.77)
Then we have		CΦCt + Iκo).	
det(G(^)) =det (NK-I			(A.78)
For large N and K0 /N → 0, we have			
det(G(X)) ≈ det(J(X)) = det (NK-1CΦCT),			(A.79)
KK IG ≈ IF = -Q	2 ln (2πe)	2 ln (ε) + H(X),	(A.80)
Q = - IDln (det (cφcT ))E^,	(A.81)
K0	
ε = ^N.	(A.82)
Hence we can state the optimization problem as:	
minimize Q [C] = - D Dln (det (cΦc,))),	(A.83)
subject to CCT = IK0.	(A.84)
The gradient from (A.83) is given by:	
d!CC] = -<(cφcτ)	Cφ + xωT ∖ ^	(A.85)
where C = [ci,…,cκj, ω = (ωι,…,ωκJT, and
ωk = φ(yk)φ0(yk)cT (CΦCT)	Ck, k =1,…，Ki.	(A.86)
In the following we will discuss how to get the optimal solution of C for two specific cases.
A.4 Algorithms for Optimization Objective Function
A.4. 1 ALGORITHM 1: K0 = Ki
Now CCT = CTC	IK1 , then by Eq. (A.83) we have Qi[C] = - (Xln(φ(yk))) ,	(A.87) ∖k=1	IX dT = TXωT〉x,	(A-) dC ωk =	, k = 1, ∙∙∙ , K1.	(A∙89) φ(yk)
Under the orthogonality constraints (Eq. A.84), we can use the following update rule for learning C
(Edelman et al., 1998; Amari, 1999):
	ct+i = ct + μt dC,	(A.90) 苧=-d¾T + Ct (%)T Ct,	(A.91)
17
Published as a conference paper at ICLR 2017
where the learning rate parameter μt changes with the iteration count t, t = 1, •…，tmaχ. Here We
can use the empirical average to approximate the integral in (A.88) (see Eq. A.12). We can also
apply stochastic gradient descent (SGD) method for online updating of Ct+1 in (A.90).
The orthogonality constraint (Eq. A.84) can accelerate the convergence rate. In practice, the orthog-
onal constraint (A.84) for objective function (A.83) is not strictly necessary in this case. We can
completely discard this constraint condition and consider
minimize Q2 [C]
—
ln(φ (yk))
-∣ln (det (CTC)),
(A.92)
x x
where we assume rank (C) = K1 = K0. If we let
dC = -CCT dQ [C]
dt	dC
(A.93)
then
Tr
dCT )
dt )
-Tr
(CT dQ2 [C] dQ2 [C]「、
IC	dC	dCT C)
≤ 0.
(A.94)
Therefore we can use an update rule similar to Eq. A.90 for learning C. In fact, the method can also
be extended to the case K0 > K1 by using the same objective function (A.92).
The learning rate parameter μt (see A.90) is updated adaptively, as follows. First, calculate
μt =	, t = 1, ∙∙∙ , tmax,
κt
「XX1 kVCtG,k)k
Kt = Ki 匕 kCt(：,k)k ,
(A.95)
(A.96)
and Ct+1 by (A.90) and (A.91), then calculate the value Q1 Ct+1. IfQ1 Ct+1 < Q1[Ct], then
let vt+i J vt, continue for the next iteration; otherwise, let Vt J τvt, μt J vt∕κt and recalculate
Ct+1 and Q1 Ct+1. Here 0 < v1 < 1 and 0 < τ < 1 are set as constants. After getting Ct+1
for each update, we employ a Gram-Schmidt orthonormalization process for matrix Ct+i, where
the orthonormalization process can accelerate the convergence. However, we can discard the Gram-
Schmidt orthonormalization process after iterative t0 (> 1) epochs for more accurate optimization
solution C. In this case, the objective function is given by the Eq. (A.92). We can also further
optimize parameter b by gradient descent.
When K0 = K1 , the objective function Q2 [C] in Eq. (A.92) without constraint is the same as the
objective function of infomax ICA (IICA) (Bell & Sejnowski, 1995; 1997), and as a consequence
we should get the same optimal solution C. Hence, in this sense, the IICA may be regarded as a
special case of our method. Our method has a wider range of applications and can handle more
generic situations. Our model is derived by neural populations with a huge number of neurons and it
is not restricted to additive noise model. Moreover, our method has a faster convergence rate during
training than IICA (see Section 3).
A.4.2 ALGORITHM 2: K0 ≤ K1
In this case, it is computationally expensive to update C by using the gradient of Q (see Eq. A.85),
since it needs to compute the inverse matrix for every x. Here we provide an alternative method for
learning the optimal C. First, we consider the following inequalities.
18
Published as a conference paper at ICLR 2017
Proposition 2. The following inequations hold,
2 Dln (det UCT))Ex ≤ 2	ln (det (C dφ e^ cT ))，	(A.97)
〈ln (det (CΦCT)))X ≤ ln (det (C〈小)爻 CT))		(A.98)
1 ≤ — _ 2	ln (det (C hΦiX CT))	(A.99)
1 ≤ — _ 2	ln (det (C DφE^ CT))，	(A.100)
ln (det (CΦCT)) ≤ 1	ln (det (CΦCT)),	(A.101)
where C ∈ RK0×K1, Ko ≤ Ki, and CCT =IK0.		
Proof. Functions ln (det (C <Φ>4 CT)) and ln (det (C (Φ)χ CT)) are concave functions about
P (x) (See the proof OfProPosition 5.2. in Huang & Zhang, 2017), which fact establishes inequalities
(A.97) and (A.98).
Next we will prove the inequality (A.101). By SVD, we have
cφ = UDDV T,
(A.102)
where U is a Ko X Ko unitary orthogonal matrix, V = [vι, 72,…,vκγ ] is an Ki X Ki unitary
orthogonal matrix, and D is an Ko X Ki rectangular diagonal matrix with Ko positive real numbers
on the diagonal. By the matrix Hadamard's inequality and CaUChy-Schwarz inequality We have
det (CΦCTCΦCT) det (cΦcT) 1
T	TT
=det ( DV CTCVD (DD
(A.103)
where Vi = [Vi, V2,…，Vκ0] ∈ RK1 ×K0. The last equality holds because of CCT = Ik。and
VT V1 = IKo. This establishes inequality (A.101) and the equality holds if and only if Ko = Ki
♦♦
or CVi = IKo.
Similarly, we get inequality (A.99):
ln (det (C <Φ>χ CT)) ≤ 1 ln (det (C hφ)^ CT)) .	(A.104)
By Jensen’s inequality, we have
hφ (yk)iX ≤ φΦ (yk)2)爻，∀k =	1,…，K1.	(A.105)
Then it follows from (A.105) that inequality (A.100) holds:		
2ln (det (C hΦiX CT)) ≤ 1 ln (det	(c dφ Ex CT)).	(A.106)
19
Published as a conference paper at ICLR 2017

This completes the proof of Proposition 2.
By Proposition 2, if K0 = K1 then we get	
2 Dln (det (φ ))Ex ≤ 2ln (det (Dφ E^)),	(A.107)
hln(det(Φ))ix ≤ ln(det(hΦi^))	(A.108)
= 1ln (det (hφi^))	(A.109)
≤ 2ln (det (Dφ Ex)),	(A.110)
ln (det (Φ)) = ɪ ln (det (Φ)).	(A.111)
On the other hand, it follows from (A.81) and Proposition 2 that	
〈ln (det (CΦCt)))爻 ≤ —Q ≤ ∣ln (det (c <ΦE爻 CT)),	(A.112)
〈ln (det (CΦCt))% ≤-Q ≤ 2ln (det (c <ΦE爻 CT)).	(A.113)
T T	.1 . ʌ ∙ 1	. ʌʌ Z	AC	'./'ll	i'	.Λ Z-X	1	CI
Hence We can see that Q is close to Q (See A.81). Moreover, it follows from the CaUchy-SchWarz
inequality that
D(φ)k,kEx = hφ (yk)iyk ≤ IZ φ (yk)2 dyk /P (yk)2 dyk)
where k = 1, •…，Kι, the equality holds if and only if the following holds:
「 φ	φ (yk)	1 ι	£
p (yk) = ~r~π~ττ~, k = 1,…，Kι,
J φ (yk) dyk
which is the similar to Eq. (A.63).
(A.114)
(A.115)
Since I(X; R) = I(Y ; R) (see Proposition 1), by maximizing I(X; R) we hope the equality in
inequality (A.61) and equality (A.63) hold, at least approximatively. On the other hand, let
Copt = arg min Q[C] = arg max (Dln (det(CΦCT ))〉J ,
C opt = arg min Q[C] = arg max (ln (det (C <Φ>x CT))),
(A.116)
(A.117)
Copt and C opt make (A.63) and (A.115) to hold true, which implies that they are the same optimal
solution: Copt = C opt.
EI	i'	.Λ ∕' 11	1 ∙ . ∙ i'	ZAI^X_1^I	Λ . ∙ . . i' ∙O∣^X-1^I	1	∙ . . 1
Therefore, we can use the following objective function Q[C] as a substitute for Q[C] and write the
optimization problem as:
minimize Q[C] = — ɪ ln (det(C <Φ>x CT)) ,	(A.118)
subject to CCT = IK0.	(A.119)
The update rule (A.90) may also apply here and a modified algorithm similar to Algorithm 1 may
be used for parameter learning.
A.5 Supplementary Experiments
A.5. 1 Quantitative Methods for Comparison
To quantify the efficiency of learning representations by the above algorithms, we calculate the co-
efficient entropy (CFE) for estimating coding cost as follows (Lewicki & Olshausen, 1999; Lewicki
& Sejnowski, 2000):
yk = ZWTx, k = 1,…，Kι,	(A.120)
ζ
K
PKlι kwkk
(A.121)
20
Published as a conference paper at ICLR 2017
where X is defined by Eq. (A.68), and Wk is the corresponding optimal filter. To estimate the
probability density of coefficients qk (yk) (k = 1, ∙ ∙ ∙ , K1) from the M training samples, We apply
the kernel density estimation for qk (yk) and use a normal kernel with an adaptive optimal window
width. Then we define the CFE h as
1 K1
h = KfHk(Yk),	(A.122)
1 k=1
Hk(Yk) = -∆Pnqk(n∆) log2 qk(n∆),	(A.123)
where qk (yk) is quantized as discrete qk (n∆) and ∆ is the step size.
Methods such as IICA and SRBM as well as our methods have feedforward structures in which
information is transferred directly through a nonlinear function, e.g., the sigmoid function. We
can use the amount of transmitted information to measure the results learned by these methods.
Consider a neural population with N neurons, which is a stochastic system with nonlinear transfer
functions. We chose a sigmoidal transfer function and Gaussian noise with standard deviation set to
1 as the system noise. In this case, from (1), (A.8) and (A.11), we see that the approximate MI IG is
equivalent to the case of the Poisson neuron model. It follows from (A.70)-(A.82) that
I(X; R) = I(X; R) = H(X) - H (XIR) ` IG = H(X) - hi,
H (X|R)` hi = -1 Λn (det	1CΦCT +
(A.124)
(A.125)
where we set N = 106. A good representation should make the MI I(X; R) as big as possible.
Equivalently, for the same inputs, a good representation should make the conditional entropy (CDE)
H (X|R)(or h1) as small as possible.
(a)	(b)	(c)
(d)	(e)	(f)
Figure 4:	Comparison of basis vectors obtained by our method and other methods. Panel (a)-(e)
correspond to panel (a)-(e) in Figure 2, where the basis vectors are given by (A.130). The basis
vectors in panel (f) are learned by MBDL and given by (A.127).
21
Published as a conference paper at ICLR 2017
A.5.2 Comparison of Basis Vectors
We compared our algorithm with an up-to-date sparse coding algorithm, the mini-batch dictionary
learning (MBDL) as given in (Mairal et al., 2009; 2010) and integrated in Python library, i.e. scikit-
learn. The input data was the same as the above, i.e. 105 nature image patches preprocessed by the
ZCA whitening filters.
We denotes the optimal dictionary learned by MBDL as BB ∈ RK×K1 for which each column
represents a basis vector. Now we have
X ≈ U£1/2UTBy = By,	(A.126)
B = U£1/2UT B,	(A.127)
where y = (yι,…，yκι )T is the coefficient vector.
Similarly, we can obtain a dictionary from the filter matrix C. Suppose rank (C) = K0 ≤ K1, then
it follows from (A.64) that
X = (aCCT)	Cy.	(A.128)
By (A.66) and (A.128), we get
x ≈ By = aBCTΣ-1/2UTx,	(A.129)
B = a-1Uo∑0/2 (CCT)-1 C =[bι,…，bκ∕ ,	(A.130)
where y = WTX = aCTΣ-1/2UTx, the vectors bi, ∙∙∙ , bκι can be regarded as the basis vectors
T
and the strict equality holds when Ko = Ki = K. Recall that X = [xi, •…，XM] = USV
(see Eq. A.49) and Y = [yi,…，yM] = WTX = a√M-1CTVT, then we get X = BY =
√M - 1 Uo∑Y2VT ≈ X. Hence, Eq. (A.129) holds.
The basis vectors shown in Figure 4(a)-4(e) correspond to filters in Figure 2(a)-2(e). And Fig-
ure 4(f) illustrates the optimal dictionary B learned by MBDL, where we set the regularization pa-
rameter as λ = 1.2/√K, the batch size as 50 and the total number of iterations to perform as 20000,
which took about 3 hours for training. From Figure 4 we see that these basis vectors obtained by the
above algorithms have local Gabor-like shapes except for those by SRBM. If rank(B) = K = Ki,
then the matrix B-t can be regarded as a filter matrix like matrix C (see Eq. A.69). However,
from the column vector of matrix B-t we cannot find any local Gabor-like filter that resembles the
filters shown in Figure 2. Our algorithm has less computational cost and a much faster convergence
rate than the sparse coding algorithm. Moreover, the sparse coding method involves a dynamic
generative model that requires relaxation and is therefore unsuitable for fast inference, whereas the
feedforward framework of our model is easy for inference because it only requires evaluating the
nonlinear tuning functions.
A.5.3 Learning Overcomplete Bases
We have trained our model on the Olshausen’s nature image patches with a highly overcomplete
setup by optimizing the objective (A.118) by Alg.2 and got Gabor-like filters. The results of 400
typical filters chosen from 1024 output filters are displayed in Figure 5(a) and corresponding base
(see Eq. A.130) are shown in Figure 5(b). Here the parameters are Ki = 1024, tmax = 100,
vi = 0.4, τ = 0.8, and = 0.98 (see A.52), from which we got rank (B) = K0 = 82. Compared
to the ICA-like results in Figure 2(a)-2(c), the average size of Gabor-like filters in Figure 5(a) is
bigger, indicating that the small noise-like local structures in the images have been filtered out.
We have also trained our model on 60,000 images of handwritten digits from MNIST dataset (LeCun
et al., 1998) and the resultant 400 typical optimal filters and bases are shown in Figure 5(c) and
Figure 5(d), respectively. All parameters were the same as Figure 5(a) and Figure 5(b): Ki = 1024,
tmax = 100, vi = 0.4, τ = 0.8 and = 0.98, from which we got rank (B) = K0 = 183. From
these figures we can see that the salient features of the input images are reflected in these filters and
bases. We could also get the similar overcomplete filters and bases by SRBM and MBDL. However,
the results depended sensitively on the choice of parameters and the training took a long time.
22
Published as a conference paper at ICLR 2017
(b)
(a)
/ #■ ≡ħ∏∏hh
〃 7dlp 1 WEIDg, ∙‹D
⅛ / 7 / ʌv V n-l ∕πn /
J /
(c)	(d)
Figure 5:	Filters and bases obtained from Olshausen’s image dataset and MNIST dataset by Al-
gorithm 2. (a) and (b): 400 typical filters and the corresponding bases obtained from Olshausen’s
image dataset, where K0 = 82 and K1 = 1024. (c) and (d): 400 typical filters and the corresponding
bases obtained from the MNIST dataset, where K0 = 183 and K1 = 1024.
Figure 6	shows that CFE as a function of training time for Alg.2, where Figure 6(a) corresponds to
Figure 5(a)-5(b) for learning nature image patches and Figure 6(b) corresponds to Figure 5(c)-5(d)
for learning MNIST dataset. We set parameters tmax = 100 and τ = 0.8 for all experiments and
varied parameter v1 for each experiment, with v1 = 0.2, 0.4, 0.6 or 0.8. These results indicate a fast
convergence rate for training on different datasets. Generally, the convergence is insensitive to the
change of parameter v1 .
We have also performed additional tests on other image datasets and got similar results, confirming
the speed and robustness of our learning method. Compared with other methods, e.g., IICA, FICA,
MBDL, SRBM or sparse autoencoders etc., our method appeared to be more efficient and robust for
unsupervised learning of representations. We also found that complete and overovercomplete filters
and bases learned by our methods had local Gabor-like shapes while the results by SRBM or MBDL
did not have this property.
23
Published as a conference paper at ICLR 2017
Figure 6: CFE as a function of training time for Alg.2, with v1 = 0.2, 0.4, 0.6 or 0.8. In all
experiments parameters were set to tmax = 100, t0 = 50 and τ = 0.8. (a): corresponding to
Figure 5(a) or Figure 5(b). (b): corresponding to Figure 5(c) or Figure 5(d).
A.5.4 Image Denoising
Similar to the sparse coding method applied to image denoising (Elad & Aharon, 2006), our method
(see Eq. A.130) can also be applied to image denoising, as shown by an example in Figure 7. The
filters or bases were learned by using 7×7 image patches sampled from the left half of the image, and
subsequently used to reconstruct the right half of the image which was distorted by Gaussian noise.
A common practice for evaluating the results of image denoising is by looking at the difference
between the reconstruction and the original image. If the reconstruction is perfect the difference
should look like Gaussian noise. In Figure 7(c) and 7(d) a dictionary (100 bases) was learned by
MBDL and orthogonal matching pursuit was used to estimate the sparse solution. 1 For our method
(shown in Figure 7(b)), we first get the optimal filters parameter W, a low rank matrix (K0 < K),
then from the distorted image patches Xm (m = 1, ∙∙∙ , M) We get filter outputs Ym = WTXm
and the reconstruction Xm = Bym (parameters: e = 0.975 and Ko = Ki = 14). As can be seen
from Figure 7, our method Worked better than dictionary learning, although We only used 14 bases
compared With 100 bases used by dictionary learning. Our method is also more efficient. We can
get better optimal bases B by a generative model using our infomax approach (details not shoWn).
1Python source code is available at http://scikit-learn.org/stable/_downloads/plot_image_denoising.py
24
Published as a conference paper at ICLR 2017
Distorted image
Algorithm 1
Image	Difference (norm: 23,48)	Image	Difference (norm: 14,24)
(a)	(b)
Orthogonal Matching Pursuit
Orthogonal Matching Pursuit
1 atom
2 atoms
Image
Difference (norm: 15.79)
Image
Difference (norm: 14.47)
(c)	(d)
Figure 7: Image denoising. (a): the right half of the original image is distorted by Gaussian noise
and the norm of the difference between the distorted image and the original image is 23.48. (b):
image denoising by our method (Algorithm 1), with 14 bases used. (c) and (d): image denoising
using dictionary learning, with 100 bases used.
25