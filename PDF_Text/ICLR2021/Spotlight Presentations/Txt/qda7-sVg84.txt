Published as a conference paper at ICLR 2021
Contrastive Behavioral Similarity
Embeddings for Generalization in
Reinforcement Learning
Rishabh Agarwal* Marlos C. MaChado^ Pablo Samuel Castro Marc G. Bellemare
Google Research, Brain Team
{rishabhagarwal, marlosm, psc, bellemare}@google.com
Ab stract
Reinforcement learning methods trained on few environments rarely learn policies
that generalize to unseen environments. To improve generalization, we incorporate
the inherent sequential structure in reinforcement learning into the representation
learning process. This approach is orthogonal to recent approaches, which rarely
exploit this structure explicitly. Specifically, we introduce a theoretically motivated
policy similarity metric (PSM) for measuring behavioral similarity between states.
PSM assigns high similarity to states for which the optimal policies in those states
as well as in future states are similar. We also present a contrastive representation
learning procedure to embed any state similarity metric, which we instantiate
with PSM to obtain policy similarity embeddings (PSEs* 1). We demonstrate that
PSEs improve generalization on diverse benchmarks, including LQR with spurious
correlations, a jumping task from pixels, and Distracting DM Control Suite.
1	Introduction
Current reinforcement learning (RL) approaches of-
ten learn policies that do not generalize to environ-
ments different than those the agent was trained on,
even when these environments are semantically equiv-
alent (Tachet des Combes et al., 2018; Song et al.,
2019; Cobbe et al., 2019). For example, consider a
jumping task where an agent, learning from pixels,
needs to jump over an obstacle (Figure 1). Deep RL
agents trained on a few of these tasks with different
obstacle positions struggle to solve test tasks where
obstacles are at previously unseen locations.
Train ENv Train ENv Test ENv
Figure 1: Jumping task: The agent (white block),
learning from pixels, needs to jump over an obsta-
cle (grey square). The challenge is to generalize to
unseen obstacle positions and floor heights in test
tasks using a small number of training tasks. We
show the agent’s trajectories using faded blocks.
Recent solutions to circumvent poor generalization in RL are adapted from supervised learning,
and, as such, largely ignore the sequential aspect of RL. Most of these solutions revolve around
enhancing the learning process, including data augmentation (e.g., Kostrikov et al., 2020; Lee et al.,
2020a), regularization (Cobbe et al., 2019; Farebrother et al., 2018), noise injection (Igl et al., 2019),
and diverse training conditions (Tobin et al., 2017); they rarely exploit properties of the sequential
decision making problem such as similarity in actions across temporal observations.
Instead, we tackle generalization by incorporating properties of the RL problem into the representation
learning process. Our approach exploits the fact that an agent, when operating in environments with
similar underlying mechanics, exhibits at least short sequences of behaviors that are similar across
these environments. Concretely, the agent is optimized to learn an embedding in which states are
close when the agent’s optimal policies in these states and future states are similar. This notion of
proximity is general and it is applicable to observations from different environments.
Specifically, inspired by bisimulation metrics (Castro, 2020; Ferns et al., 2004), we propose a
novel policy similarity metric (PSM). PSM (Section 3) defines a notion of similarity between states
originated from different environments by the proximity of the long-term optimal behavior from these
states. PSM is reward-agnostic, making it more robust for generalization compared to approaches that
* Also at Mila, Universit6 de Montreal. RoW at DeePMind.
1Pronounce ‘pisces’.
1
Published as a conference paper at ICLR 2021
rely on reward information. We prove that PSM yields an upper bound on suboptimality of policies
transferred from one environment to another (Theorem 1), which is not attainable with bisimulation.
We employ PSM for representation learning and introduce policy similarity embeddings (PSEs) for
deep RL. To do so, we present a general contrastive procedure (Section 4) to learn an embedding
based on any state similarity metric. PSEs are the instantiation of this procedure with PSM. PSEs
are appealing for generalization as they encode task-relevant invariances by putting behaviorally
equivalent states together. This is unlike prior approaches, which rely on capturing such invariances
without being explicitly trained to do so, for example, through value function similarities across
states (e.g., Castro & Precup, 2010), or being robust to fixed transformations of the observation
space (e.g., Kostrikov et al., 2020; Laskin et al., 2020a).
PSEs lead to better generalization while being orthogonal to how most of the field has been tackling
generalization. We illustrate the efficacy and broad applicability of our approach on three existing
benchmarks specifically designed to test generalization: (i) jumping task from pixels (Tachet des
Combes et al., 2018) (Section 5), (ii) LQR with spurious correlations (Song et al., 2019) (Section 6.1),
and (iii) Distracting DM Control Suite (Stone et al., 2021; Zhang et al., 2018b) (Section 6.2). Our
approach improves generalization compared to a wide variety of approaches including standard
regularization (Farebrother et al., 2018; Cobbe et al., 2019), bisimulation (Castro & Precup, 2010;
Castro, 2020; Zhang et al., 2021), out-of-distribution generalization (Arjovsky et al., 2019) and
state-of-the-art data augmentation (Kostrikov et al., 2020; Lee et al., 2020a).
2	Preliminaries
We describe an environment as a Markov decision process (MDP) (Puterman, 1994) M =
(X, A, R, P, γ), with a state space X, an action space A, a reward function R, transition dynamics
P, and a discount factor Y ∈ [0,1). A policy ∏(∙ | x) maps states X ∈ X to distributions over actions.
Whenever convenient, we abuse notation and write π(x) to describe the probability distribution
∏(∙ | x), treating ∏(χ) as a vector. In RL, the goal is to find an optimal policy ∏* that maximizes the
cumulative expected return Eat〜∏(. ∣ χt) [Pt YtR(xt, at)] starting from an initial state x0.
We are interested in learning a policy that generalizes across related environments. We formalize this
by considering a collection ρ of MDPs, sharing an action space A but with disjoint state spaces. We
use X and Y to denote the state spaces of specific environments, and write RX, PX for the reward
and transition functions of the MDP whose state space is X, and ∏X for its optimal policy, which We
assume unique without loss of generality. For a given policy π, we further specialize these into RπX
and PXπ , the reward and state-to-state transition dynamics arising from following π in that MDP.
We write S for the union of the state spaces of the MDPs in ρ. Concretely, different MDPs correspond
to specific scenarios in a problem class (Figure 1), and S is the space of all possible configurations.
Used without subscripts, R, P, and π refer to the reward and transition function of this “union MDP”,
and a policy defined over S ; this notation simplifies the exposition. We measure distances between
states across environments using pseudometrics2 on S ; the set of all such pseudometrics is M, and
Mp is the set of metrics on probability distributions over S .
In our setting, the learner has access to a collection of training MDPs {Mi}iN=1, drawn from ρ. After
interacting with these environments, the learner must produce a policy π over the entire state space S,
which is then evaluated on unseen MDPs from ρ. Similar in spirit to the setting of transfer learning
(Taylor & Stone, 2009), here we evaluate the policy’s zero-shot performance on ρ.
Our policy similarity metric (Section 3) builds on the concept of π-bisimulation (Castro, 2020).
Under the π-bisimulation metric, the distance between two states, x and y, is defined in terms of
the difference between the expected rewards obtained when following policy π. The π-bisimulation
metric dπ satisfies a recursive equation based on the 1-Wasserstein metric W1 : M → Mp, where
W1 (d)(A, B) is the minimal cost of transporting probability mass from A to B (two probability
distributions on S) under the base metric d (Villani, 2008). The recursion is
d∏(x,y) = ∣Rπ(X)- Rn(y)∣+ γWι(d∏)(Pπ(∙∣ x),Pπ(∙∣ y)) ,	x,y ∈S.	(1)
To achieve good generalization properties, we learn an embedding function zθ : S → Rk that
reflects the information encoded in the policy similarity metric; this yields a policy similarity
2Pseudometrics are generalization of metrics where the distance between two distinct states can be zero.
2
Published as a conference paper at ICLR 2021
embedding (Section 4). We use contrastive methods (Hadsell et al., 2006; Oord et al., 2018) whose
track record for representation learning is well-established. We adapt SimCLR (Chen et al., 2020),
a popular contrastive method for learning embeddings of image inputs. Given two inputs x and y,
T
their embedding similarity is s"(x, y) = sim(z"(x), z§(y)), where Sim(U,v)= 百口3 denotes the
cosine similarity function. SimCLR aims to maximize similarity between augmented versions of an
image (e.g., crops, colour changes) while minimizing its similarity to other images. The loss used by
SimCLR for two versions x, y ofan image, and a set X0 containing other images is:
`(	X0)= _1 __________________exp(λsθ(x,y))_______________
""'y;	) = - og exp(λsθ(x, y)) + Pχ,∈χ,\. exp(λsθ(x0, y))
(2)
where λ is an inverse temperature hyperparameter. τhe overall simCLR loss is then the expected
value of 'θ(x, y; S), When x, y, and X0 are drawn from some augmented training distribution.
3 Policy Similarity Metric
A useful tool in learning a policy that generalizes is to understand which states result in similar
behavior, and which do not. τo be maximally effective, this similarity should go beyond the
immediately chosen action and consider long-term behavior. In this regards, the π-bisimulation
metrics are interesting as they are based on the full sequence of future rewards received from different
states. However, considering rewards can be both too restrictive (when the policies are the same, but
the obtained rewards are not; see Figure D.1) or too permissive (when the policies are different, but
the obtained rewards are not; see Figure 3a). In fact, π-bisimulation metrics actually lead to poor
generalization in our experiments (sections 5.1 and 5.2).
τo address this issue, we instead consider the similarity between policies themselves. We replace
the absolute reward difference by a probability pseudometric between policies, denoted Dist. Addi-
tionally, since we would like to perform well in unseen environments, we are interested in similarity
in optimal behavior. We thus use π* as the grounding policy. This yields the policy similarity
metric (PsM), for which states are close when the optimal policies in these states and future states
are similar. For a given DIST, the PSM d* : S ×S → R satisfies the recursive equation
d*(x, y) = Disτ(π*(x), π* (y)) + YWι(d^)[Pπ* (∙ | x), Pπ* (∙ | y)).
^{^™
(A)
}|
^{^―
(B)
(3)
|
}
The DIST term captures the difference in local optimal behavior (A) while W1 captures long-term
optimal behavior difference (B); the exact weights assigned to the two are given by the discount
factor. Furthermore, when Dist is bounded, d is guaranteed to be finite. While there are technically
multiple PSMs (one for each Dist), we omit this distinction whenever clear from context. A proof of
the uniqueness of d* is given in Proposition B.1.
Our main use of PSM will be to compare states across environments. In this context, we identify the
terms in Equation 3 with specific environments for clarity and write (despite its technical inaccuracy)
d*(x, y) = DIST(∏X(x), ∏Y(y)) + γWι (d*)(PX* (∙ | x), PY* (∙ | y)).
PSM is applicable to both discrete and continuous action spaces. In our experiments, Dist is the
total variation distance (TV ) when A is discrete, and we use the `1 distance between the mean
actions of the two policies when A is continuous. PSM can be computed iteratively using dynamic
programming (Ferns et al., 2011) (more details in Section D.1). Furthermore, when π* is unavailable
on training environments, we replace it by an approximation ∏* to obtain an approximate PSM, which
is close to the exact PSM depending on the suboptimality of ∏* (Proposition D.3).
Despite resembling π-bisimulation metrics in form, the PSM possesses different characteristics which
are better suited to the problem of generalizing a learned policy. To illustrate this point, consider the
following simple nearest-neighbour scheme: Given a state y ∈ Y , denote its closest match in X by
Xy := argminχ∈χ d*(x, y). Suppose that we use this scheme to transfer ∏X to MY, in the sense
that we behave according to the policy ∏(y) = ∏X(Xy). We can then bound the difference between ∏
and πY* , something that is not possible if d* is replaced by a π-bisimulation metric.
Theorem 1. [Bound on policy transfer] For any y ∈ Y, let Yy 〜Pπ (∙ | YtT) define the SeqUenCe
of random states encountered starting in Y0 = y andfollowing policy π. We have:
3
Published as a conference paper at ICLR 2021
EYyt	ΣYtTV (πK),∏*K))
t≥0
≤ 1-γd* (Xy,y) .
The proof is in the Appendix (Section B). Theorem 1 is non-vacuous whenever d*(Xy ,y) < 1/(1+ γ).
In particular, d* (Xy, y) = 0 implies that the transferred policy is optimal. Although this scheme is not
practical (computing d* requires knowledge of ∏γ), it shows that meaningful policy generalization
can be obtained if we can find a mapping that generalizes across S . Put another way, PSM gives us a
principled way of lifting generalization across inputs (a supervised learning problem) to generalization
across environments. We now describe how to employ PSM for learning representations that put
together states in which the agent’s long-term optimal behavior is similar.
4	Learning Contrastive Metric Embeddings
To generalize a learned policy to new envi-
ronments, we build on the success of con-
trastive representations (Section 2). Given
a state similarity metric d, we develop a
general procedure (Algorithm 1) to learn
contrastive metric embeddings (CMEs) for
d. We utilize the metric d for defining the
set of positive and negative pairs, as well
as assigning importance weights to these
pairs in the contrastive loss (Equation 4).
Algorithm 1 Contrastive Metric Embeddings (CMEs)
1: Given: State embedding z§(∙), Metric d(∙, ∙) Train-
ing environments {Mi}iN=1. Hyperparameters:
Temperature 1∕λ, Scale β, Total training steps K
for each step k = 1, . . . , K do
Sample a pair of training MDPs MX , MY
Update θ to minimize LCME where
LCME = EMX ,Mγ 〜P [Lθ (MX, MY)]
5: end for
2
3
4
We first apply a transformation to convert d to a similarity measure Γ, bounded in [0, 1] for “soft”
similarities. In this work, we transform d using the Gaussian kernel with a positive scale parameter β,
that is, Γ(x, y) = exp(-d(x, y)∕β). β controls the sensitivity of the similarity measure to d.
Second, we select the positive and negative pairs given a set of states X0 ⊆ X and Y from MDPs
MX, MY respectively. For each anchor state y ∈ Y, we use its nearest neighbor in X0 based on
the similarity measure Γ to define the positive pairs {(Xy, y)}, where Xy = argmax Γ(x, y). The
x∈X0
remaining states in X0, paired with y, are used as negative pairs. This choice of pairs is motivated
by Theorem 1, which shows that if we transfer the optimal policy in MX to the nearest neighbors
defined using PSM, its performance in MY has suboptimality bounded by PSM.
Next, we define a soft version of the SimCLR contrastive loss (Equation 2) for learning the function
zθ, which maps states (usually high-dimensional) to embeddings. Given a positive state pair (Xy, y),
the set X0, and the similarity measure Γ, the loss (pseudocode provided in Section J.2) is given by
`o(X y; X0) = - log________________________r(xy,y)exp(λsθ(Xy,y))__________________________ ⑷
θ ( y,y )=	gΓ(Xy ,y)exp(λsθ (Xy ,y)) + Jχ ,、伊“}(1 - Γ(X0,y))exp(λsθ(X0, y)) ( )
where we use the same notation as in Equation 2. Following SimCLR, we use a non-linear projection
of the representation as zθ (Figure A.1). The agent’s policy is an affine function of the representation.
The total contrastive loss for MX and MY utilizes the optimal trajectories TX = {Xt}N=ι and
TY = {yt}N=ι, where Xt+ι 〜PX* (∙ | Xt) and yt+ι 〜PY (∙ | yt). We set X0 = TX and define
Lθ(MX, MY) = Ey 〜TY ['θ(Xy,y； TX)]	where Xy = argmaxΓ(X,y).
x∈τX*
We refer to CMEs learned with policy similarity metric as policy similarity embeddings (PSEs). PSEs
can trivially be combined with data augmentation by using augmented states when computing state
embeddings. We simultaneously learn PSEs with the RL agent by adding LCME (Algorithm 1) as an
auxiliary objective during training. Next, we illustrate the benefits from this auxiliary objective.
5	Jumping Task from Pixels: A Case Study
Task Description. The jumping task (Tachet des Combes et al., 2018) (Figure 1) captures, using
well-defined factors of variations, whether agents can learn the correct invariances required for
generalization, directly from image inputs. The task consists of an agent trying to jump over an
obstacle. The agent has access to two actions: right and jump. The agent needs to time the jump
4
Published as a conference paper at ICLR 2021
Table 1: Percentage (%) of test tasks solved by different methods without and with data augmentation. The
“wide”, “narrow”, and random grids are described in Figure 2. We report average performance across 100 runs
with different random initializations, with standard deviation between parentheses.
Data Augmentation	Method	Grid Configuration (%)		
		“Wide”	“Narrow”	Random
X	Dropout and `2 reg.	17.8 (2.2)	10.2 (4.6)	9.3 (5.4)
	Bisimulation Transfer4	17.9 (0.0)	17.9 (0.0)	30.9 (4.2)
	PSEs	33.6 (10.0)	9.3 (5.3)	37.7 (10.4)
✓	RandConv	50.7 (24.2)	33.7 (11.8)	71.3 (15.6)
	RandConv + Bisimulation	41.4 (17.6)	17.4 (6.7)	33.4 (15.6)
	RandConv + PSEs	87.0 (10.1)	52.4 (5.8)	83.4 (10.1)
Obstacle Position
Floor
Height
(a) “Wide” grid	(b) “Narrow” grid	(c) Random grid
Figure 2: Jumping Task: Visualization of average performance of PSEs with data augmentation across different
configurations. We plot the median performance across 100 runs. Each tile in the grid represents a different task
(obstacle position/floor height combination). For each grid configuration, the height varies along the y-axis (11
heights) while the obstacle position varies along the x-axis (26 locations). The red letter > indicates the training
tasks. Random grid depicts only one instance, each run consisted of a different test/train split. Beige tiles are
tasks PSEs solved while black tiles are tasks PSEs did not solve when used with data augmentation. These
results were chosen across all the 100 runs to demonstrate what the average reported performance looks like.
precisely, at a specific distance from the obstacle, otherwise it will eventually hit the obstacle.
Different tasks consist in shifting the floor height and/or the obstacle position. To generalize, the
agent needs to be invariant to the floor height while jump based on the obstacle position. The obstacle
can be in 26 different locations while the floor has 11 different heights, totaling 286 tasks.
Problem Setup. We split the problem into 18 seen (training) and 268 unseen (test) tasks to stress test
generalization using a few changes in the underlying factors of variations seen during training. The
small number of positive examples3 results in a highly unbalanced classification problem with low
amounts of data, making it challenging without additional inductive biases. Thus, we evaluate gener-
alization in regimes with and without data augmentation. The different grids configurations (Figure 2)
capture different types of generalization: the “wide” grid tests generalization via “interpolation”,
the “narrow” grid tests out-of-distribution generalization via “extrapolation”, and the random grid
instances evaluate generalization similar to supervised learning where train and test samples are
drawn i.i.d. from the same distribution.
We used RandConv (Lee et al., 2020a), a state-of-the-art data augmentation for generalization. For
hyperparameter selection, we evaluate all agents on a validation set containing 54 unseen tasks in the
“wide” grid (Figure 2a) and pick the parameters with the best validation performance. We use these
fixed parameters for all grid configurations to show the robustness of PSEs to hyperparameter tuning.
We first compute the optimal trajectories in the training tasks. Using these trajectories, we compute
PSM using dynamic programming (Section D.1). We train the agent by imitation learning, combined
with an auxiliary loss for PSEs (Section 4). More details are in Section G.
5.1	Evaluating Generalization on Jumping Task
We show the efficacy of PSEs compared to common generalization approaches such as regulariza-
tion (e.g., Cobbe et al., 2019; Farebrother et al., 2018), and data augmentation (e.g., Lee et al., 2020a;
Laskin et al., 2020a), which are quite effective on pixel-based RL tasks. We also contrast PSEs with
bisimulation transfer (Castro & Precup, 2010), a tabular state-based transfer approach based on bisim-
ulation metrics which does not do any learning and bisimulation preserving representations (Zhang
et al., 2021), showing the advantages of PSM over a prevalent state similarity metric.
3We have 18 different trajectories with several examples for the action right, but only one instance of jump
action per trajectory, leading to just 18 total instances of the action jump.
5
Published as a conference paper at ICLR 2021
(a) Optimal Trajectories
(b) PSEs
dings
Figure 3: Embedding visualization. (a) Optimal trajectories on original jumping task (visualized as coloured
blocks) with different obstacle positions. We visualize the hidden representations using UMAP, where the color
of points indicate the tasks of the corresponding observations. Points with the same number label correspond to
same distance of the agent from the obstacle, the underlying optimal invariant feature across tasks.
We first investigated how well PSEs generalize over existing methods without incorporating additional
domain knowledge during training. Table 1 summarizes, in the setting without data augmentation,
the performance of these methods in different train/test splits (c.f. Figure 2 for a detailed description).
PSEs, with only 18 examples, already leads to better performance than standard regularization.
PSEs also outperform bisimulation transfer in the “wide” and random grids. Although bisimulation
transfer is impractical4 when evaluating zero-shot generalization, we still performed this comparison,
unfair to PSEs, to highlight their efficacy. PSEs perform better because, in contrast to bisimulation,
PSM is reward agnostic (c.f. Proposition D.1) - the expected return of the jump action is quite
different depending on the obstacle position (c.f. Figure G.2 for a visual juxtaposition of PSM
and bisimulation). Overall, these results are promising because they place PSEs as an effective
generalization method that does not rely on data augmentation.
Nevertheless, PSEs are complementary to data augmentation, which consistently improves gener-
alization in deep RL. We compared RandConv combined with PSEs to simply using RandConv.
Domain-specific augmentation also succeeds in the jumping task. Thus, it is not surprising that
RandConv is so effective compared to techniques without augmentation. Table 1 (2nd row) shows
that PSEs substantially improve the performance of RandConv across all grid configurations. More-
over, Table 1 (2nd row) illustrates that when combined with RandConv, bisimulation preserving
representations (Zhang et al., 2021) diminish generalization by 30 - 50% relative to PSEs.
Notably, Table 1 (1st row) indicates that learning-based methods are ineffective on the “narrow” grid
without data augmentation. That said, PSEs do work quite well when combined with RandConv.
However, even with data augmentation, generalization in “narrow” grid happens only around the
vicinity of training tasks, exhibiting the challenge this grid poses for learning-based methods. We
believe this is due to the poor extrapolation ability of neural networks (e.g., Haley & Soloway, 1992;
Xu et al., 2020), which is more perceptible without prior inductive bias from data augmentation.
5.2	Understanding gains from PSEs: Ablations and Visualizations
PSEs are contrastive metric embed-
dings (CMEs) learned with PSM.
We investigate the gains from
CMEs (Section 4) and PSM (Sec-
tion 3) by ablating them. CMEs
can be learned with any state
similarity metric - We use π*-
bisimulation (Castro, 2020) as an al-
ternative. Similarly, PSM can be
used with any metric embedding -
we use '2-embeddings (Section E)
as an alternative, which Zhang et al.
Table 2: Ablating PSEs. Percentage (%) of test tasks solved when
we ablate the similarity metric and learning procedure for metric
embeddings in the data augmentation setting on wide grid. PSEs,
which combine CMEs with PSM, considerably outperform other
embeddings. We report the average performance across 100 runs with
standard deviation between parentheses. All ablations except PSEs
deteriorate performance compared to just using data augmentation
(RandConv), as reported in Table 1.
Metric / Embedding	'2-embeddings	CMEs
π*-bisimulation	41.4(17.6)	23.1 (7.6)
PSM	17.5 (8.4)	87.0 (10.1)
4Bisimulation transfer assumes oracle access to dynamics and rewards on unseen environments as well as
tabular state space to compute the exact bisimulation metric (Section C).
6
Published as a conference paper at ICLR 2021
(2021)	employed with π*-bisimulation for learning representations in a single task RL setting. For a
fair comparison, we tune hyperparameters for 128 trials for each ablation entry in Table 2.
Table 2 show that PSES (= PSM + CMES) generalize significantly better than ∏*-bisimulation
with CMES or '2-embeddings, both of which significantly degrade performance (-60% and -45%,
respectively). This is expected, as ∏*-bisimulation imposes the incorrect invariances for thejumping
task (c.f. Figures G.2a and G.2d). Additionally, looking at the rows of Table 2, CMEs are superior
than '2-embeddings for PSM while inferior for π*-bisimulation. This result is in line with the
hypothesis that CMEs better enforce the invariances encoded by a similarity metric compared to
'2 -embeddings (c.f. Figures 3b and 3c).
Visualizing learned representations. We visualize the metric embeddings in the ablation above
by projecting them to two dimensions with UMAP (McInnes et al., 2018), a popular visualization
technique for high dimensional data which better preserves the data’s global structure compared to
other methods such as t-SNE (Coenen & Pearce, 2019).
Figure 3 shows that PSEs partition the states into two sets: (1) states where a single suboptimal
action leads to failure (all states before jump) and (2) states where actions do not affect the final
outcome (states after jump). Additionally, PSEs align the labeled states in the first set, which have a
PSM distance of zero. These aligned states have the same distance from the obstacle, the invariant
feature that generalizes across tasks. On the other hand, '2-embeddings (Zhang et al., 2021) with
PSM do not align states with zero PSM except the state with thejump action - poor generalization,
as observed empirically, is likely due to states with the same optimal behavior ending up with distant
embeddings. CMEs with ∏*-bisimulation align states with ∏*-bisimulation distance of zero - such
states are equidistant from the start state and have different optimal behavior for any pair of tasks
with different obstacle positions (Figure G.2c).
5.3	Jumping Task with Colors: Where Task-dependent Invariance Matters
PSEs capture invariances that are usually orthogonal to
task-agnostic invariances from data augmentation. This
difference is important because, for certain tasks, data
augmentation can erroneously alias states with different
optimal behavior. Domain knowledge is often required
to select appropriate augmentations, otherwise augmen-
tations can hurt generalization. In contrast, PSEs do
not require any domain knowledge but instead exploit
the inherent structure of the RL tasks.
To demonstrate the difference between PSEs and data
augmentation, we simply include colored obstacles in
the jumping task (see Figure G.5). In this modified
task, the optimal behavior of the agent depends on
the obstacle color: the agent needs to jump over the
red obstacle but strike the green obstacle to get a high
return. The red obstacle task has the same difficulty as
the original jumping task while the green obstacle task is easier. We jointly train the agent with 18
training tasks each, for both obstacle colors, and evaluate generalization on unseen red tasks.
Figure 4 shows the large performance gap between PSEs and data augmentation with RandConv. All
methods solve the green obstacle tasks (Table G.1). As opposed to the original jumping task (c.f. Ta-
ble 1), data augmentation inhibits generalization since RandConv forces the agent to ignore color,
conflating the red and green tasks (Figure G.6). PSEs still outperform regularization and data aug-
mentation. Furthermore, data augmentation performs better when combined with PSEs. Thus, PSEs
are effective even when data augmentation hurts performance.
5.4	Effect of Policy Suboptimality on PSEs
To understand the sensitivity of learning effective PSEs to the quality of the policies, we compute
PSEs using -suboptimal policies on the jumping task, which take the optimal action with probability
1 - and the subopotimal action with probability . We evaluate the generalization performance of
PSEs for increasingly suboptimal policies, ranging from the optimal policy ( = 0) to the uniform
random policy ( = 0.5). To isolate the effect of suboptimality on PSEs, the agent still imitates the
optimal actions during training for all .
% Test tasks solved
Figure 4: Percentage (%) of red obstacle test
tasks solved when trained, jointly with red and
green obstacles, on the “wide” grid. We report
the mean across 100 runs. Error bars show 99%
confidence interval for the mean.
7
Published as a conference paper at ICLR 2021
Figure 5 shows that PSEs show near-optimal generalization with
≤ 0.4 while degrade generalization with an uniform random pol-
icy. This result is well-aligned with Proposition D.3, which shows
that for policies with decreasing suboptimality, PSM approxima-
tion becomes more accurate, resulting in improved PSEs. Overall,
this study confirms that the utility of PSEs for generalization is
robust to suboptimality. One reason for this robustness is that
PSEs are likely to align states with similar long-term greedy op-
timal actions, resulting in good performance even with suboptimal
policies that preserve these greedy actions.
6 Additional Empirical Evaluation
W IOO
JgP 7K
S Φ 75
% o 50
Φ S
匕25
0.00.10.2 0.30.40.5
Suboptimality (e)
Figure 5: % of test tasks solved
using PSEs computed using -
suboptimal policies on the “wide”
grid. We report the mean across 100
runs. Error bars show one standard
In this section, we exhibit that PSM ignores spurious information deviation.
for generalization using a LQR task (Song et al., 2019) with non-image inputs. Then, we demonstrate
the scalability of PSEs without explicit access to optimal policies in an RL setting, with continuous
actions, using Distracting DM Control Suite (Stone et al., 2021; Zhang et al., 2018b).
6.1	LQR with Spurious Correlations
We show how representations learned using PSM,
when faced with semantically equivalent environ-
ments, can learn the main factors of variation and
ignore spurious correlations that hinder generaliza-
tion. We use LQR with distractors (Song et al., 2019;
Sonar et al., 2020) to assess generalization in a feature-
based RL setting with linear function approximation.
The distractors are input features that are spuriously
correlated with optimal actions and can be used for
predicting these actions during training, but hurt gen-
eralization. The agent learns a linear policy using 2
environments with fixed distractors. This policy is
Figure 6: LQR generalization: Absolute test er-
ror in LQR cost relative to the oracle (which has
access to true state), of various methods trained
with nd distractors on 2 training environments.
Lower error is better. PSM achieves near-optimal
performance. We report mean across 100 differ-
ent seeds. Error bars (non-existent for most meth-
ods) show 99% confidence interval for mean.
evaluated on environments with unseen distractors.
We aggregate state pairs in training environments
with near-zero PSM. We contrast this approach with
(i) IPO (Sonar et al., 2020), a policy optimization
method based on IRM (Arjovsky et al., 2019) for out-
of-distribution generalization, (ii) overparametrization,
which leads to better generalization via implicit regularization (Song et al., 2019), and (iii) weight
sparsity using 'ι-regularization since the policy weights which generalize in this task are sparse.
All methods optimally solve the training environments; however, the baselines perform abysmally
in terms of generalization compared to state aggregation with PSM (Figure 6), indicating their
reliance on distractors. PSM obtains near-optimal generalization which we corroborate through this
conjecture (Section H.1): Assuming zero state aggregation error with PSM, the policy learned using
gradient descent is independent of the distractors. Refer to Section H for a detailed discussion.
6.2	Distracting DM Control Suite
Finally, we demonstrate scalability of PSEs on the Distract-
ing DM Control Suite (DCS) (Stone et al., 2021), which tests
whether agents can ignore high-dimensional visual distractors
irrelevant to the RL task. Since we do not have access to opti-
mal training policies, we use learned policies as proxy for ∏*
for computing PSM as well as collecting data for optimizing
PSEs. Even with this approximation, PSEs outperform state-
of-the-art data augmentation. DCS extends DM Control (Tassa
et al., 2020) with visual distractions. We use the dynamic back-
ground distractions (Stone et al., 2021; Zhang et al., 2018b) Figure 7: Distracting Control Suite:
where a video is played in the background from a specific Snapshots of training environments.
frame. The video and the frame are randomly sampled every new episode. We use 2 videos during
training (Figure 7) and evaluate generalization on 30 unseen videos (Figure I.1).
8
Published as a conference paper at ICLR 2021
Table 3: Generalization performance with unseen distractions in the Distracting Suite at 500K steps. We
report the average scores across 5 seeds ± standard error. All methods are added to SAC (Haarnoja et al., 2018).
Pretrained initialization uses DrQ trained for 500K steps. Figures I.2 and I.3 show generalization curves.
Initialization	Method	BiC-catch	C-swingup	C-run	F-spin	R-easy	W-walk
Random	DrQ	747±28	582±42	220±12	646±54	931±14	549±83
	DrQ + PSEs	821±17	749±19	308±12	779±49	955±10	789±28
Pretrained	DrQ	748±30	689±22	219±10	764±48	943±10	709±29
	DrQ + PSEs	805±25	753±13	282±8	803±19	962±11	829±21
All agents are built on top of SAC (Haarnoja et al., 2018) combined with DrQ (Kostrikov et al., 2020),
an augmentation method with state-of-the-art performance on DM control. Notably, DrQ outperforms
CURL (Laskin et al., 2020b), a strong contrastive method for RL. Without data augmentation on DM
control, SAC performs poorly, even during training (Kostrikov et al., 2020). We augment DrQ with
an auxiliary loss for learning PSEs and compare it with DrQ (Table 3). Orthogonal to DrQ, PSEs
align representations of different states across environments based on PSM (c.f. Figure A.1). All
agents are trained for 500K environment steps with random crop augmentation. For computing PSM,
we use policies learned by DrQ pretrained on training environments for 500K steps.
First, we investigate how much better PSEs generalize relative to DrQ, assuming the agent is provided
with PSM beforehand. The agent’s policy is randomly initialized so that additional gains over DrQ
can be attributed to the auxiliary information from PSM. The substantial gains in Table 3 indicate
that PSEs are more effective than DrQ for encoding invariance to distractors.
Since PSEs utilize PSM approximated using pretrained policies, we also compare to a DrQ agent
where we initialize it using these pretrained policies. This comparison provides the same auxiliary
information to DrQ as available to PSEs, thus, the generalization difference stems from how they
utilize this information. Table 3 demonstrates that PSEs outperform DrQ with pretrained initialization,
indicating that the additional pretraining steps are more judiciously utilized for computing PSM as
opposed to just longer training with DrQ. More details, including learning curves, are in Section I.
7	Related Work
PSM (Section 3) is inspired by bisimulation metrics (Section C). However, different than traditional
bisimulation (e.g., Larsen & Skou, 1991; Givan et al., 2003; Ferns et al., 2011), PSM is more tractable
as it defined with respect to a single policy similar to the recently proposed ∏*-bisimulation (Cas-
tro, 2020; Zhang et al., 2021). However, in contrast to PSM, bisimulation metrics rely on reward
information and may not provide a meaningful notion of behavioral similarity in certain environ-
ments (Section 5). For example, states similar under PSM would have similar optimal policies, yet
can have arbitrarily large ∏* -bisimulation distance between them (Proposition D.1).
PSEs (Section 4) use contrastive learning to encode behavior similarity (Section 3) across MDPs.
Previously, contrastive learning has been applied for imposing state self-consistency (Laskin et al.,
2020b), capturing predictive information (Oord et al., 2018; Mazoure et al., 2020; Lee et al., 2020b)
or encoding transition dynamics (van der Pol et al., 2020; Stooke et al., 2020; Schwarzer et al.,
2020) within an MDP. These methods can be integrated with PSEs to encode additional invariances.
Interestingly, in a similar spirit to PSEs, Pacchiano et al. (2020); Moskovitz et al. (2021) explore
comparing behavioral similarity between policies to guide policy optimization within an MDP.
PSEs are complementary to data augmentation methods (Kostrikov et al., 2020; Lee et al., 2020a;
Raileanu et al., 2020; Ye et al., 2020), which have recently been shown to significantly improve
agents’ generalization capabilities. In fact, we combine PSEs to state-of-the-art augmentation methods
including random convolutions (Lee et al., 2020a; Laskin et al., 2020a) in the jumping task and
DrQ (Kostrikov et al., 2020) on Distracting Control Suite, leading to performance improvement.
8	Conclusion
This paper advances generalization in RL by two contributions: (1) the policy similarity metric (PSM)
which provides a new notion of state similarity based on behavior proximity, and (2) contrastive
metric embeddings, which harness the benefits of contrastive learning for representations based on a
similarity metric. PSEs combine these two ideas to improve generalization. Overall, this paper shows
the benefits of exploiting the inherent structure in RL for learning effective representations.
9
Published as a conference paper at ICLR 2021
References
Rishabh Agarwal, Chen Liang, Dale Schuurmans, and Mohammad Norouzi. Learning to generalize from sparse
and underspecified rewards. In ICML, 2019.
Martin Arjovsky, LCon Bottou, Ishaan Gulrajani, and David Lopez-Paz. Invariant risk minimization. CoRR,
abs/1907.02893, 2019.
Sanjeev Arora, Nadav Cohen, Wei Hu, and Yuping Luo. Implicit regularization in deep matrix factorization. In
Advances in Neural Information Processing Systems, pp. 7413-7424, 2019.
Yogesh Balaji, Swami Sankaranarayanan, and Rama Chellappa. Metareg: Towards domain generalization using
meta-regularization. In Advances in Neural Information Processing Systems, pp. 998-1008, 2018.
Pablo Samuel Castro. Scalable methods for computing state similarity in deterministic Markov decision
processes. In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI), 2020.
Pablo Samuel Castro and Doina Precup. Using bisimulation for policy transfer in MDPs. In Proceedings of the
AAAI Conference on Artificial Intelligence (AAAI), 2010.
Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey E. Hinton. A simple framework for contrastive
learning of visual representations. CoRR, abs/2002.05709, 2020.
Karl Cobbe, Oleg Klimov, Christopher Hesse, Taehoon Kim, and John Schulman. Quantifying generalization in
reinforcement learning. In Proceedings of the International Conference on Machine Learning (ICML), 2019.
Andy Coenen and Adam Pearce. Understanding umap, 2019. URL https://pair-code.github.io/
understanding-umap/.
Jesse Farebrother, Marlos C. Machado, and Michael Bowling. Generalization and regularization in DQN. In
NeurIPS Deep Reinforcement Learning Workshop, 2018.
Norm Ferns, Prakash Panangaden, and Doina Precup. Metrics for finite Markov decision processes. In
Proceedings of the Conference in Uncertainty in Artificial Intelligence (UAI), 2004.
Norm Ferns, Pablo Samuel Castro, Doina Precup, and Prakash Panangaden. Methods for computing state
similarity in Markov decision processes. In Proceedings of the 22nd Conference on Uncertainty in Artificial
Intelligence, UAI ’06. AUAI Press, 2006.
Norm Ferns, Prakash Panangaden, and Doina Precup. Bisimulation metrics for continuous markov decision
processes. SIAM Journal on Computing, 40(6):1662-1714, 2011.
Norman Ferns and Doina Precup. Bisimulation metrics are optimal value functions. In The 30th Conference on
Uncertainty in Artificial Intelligence, pp. 10, 2014.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-agnostic meta-learning for fast adaptation of deep
networks. In Proceedings of the International Conference on Machine Learning (ICML), 2017.
Robert Givan, Thomas Dean, and Matthew Greig. Equivalence notions and model minimization in markov
decision processes. Artificial Intelligence, 147(1-2):163-223, 2003.
Daniel Golovin, Benjamin Solnik, Subhodeep Moitra, Greg Kochanski, John Karro, and D Sculley. Google vizier:
A service for black-box optimization. In Proceedings of the 23rd ACM SIGKDD international conference on
knowledge discovery and data mining, pp. 1487-1495, 2017.
Suriya Gunasekar, Blake E Woodworth, Srinadh Bhojanapalli, Behnam Neyshabur, and Nati Srebro. Implicit
regularization in matrix factorization. In Advances in Neural Information Processing Systems, pp. 6151-6159,
2017.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maximum
entropy deep reinforcement learning with a stochastic actor. arXiv preprint arXiv:1801.01290, 2018.
Raia Hadsell, Sumit Chopra, and Yann LeCun. Dimensionality reduction by learning an invariant mapping. In
2006 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’06), volume 2,
pp. 1735-1742. IEEE, 2006.
Pamela J Haley and DONALD Soloway. Extrapolation limitations of multilayer feedforward neural networks. In
[Proceedings 1992] IJCNN International Joint Conference on Neural Networks, volume 4, pp. 25-30. IEEE,
1992.
10
Published as a conference paper at ICLR 2021
Maximilian Igl, Kamil Ciosek, Yingzhen Li, Sebastian Tschiatschek, Cheng Zhang, Sam Devlin, and Katja
Hofmann. Generalization in reinforcement learning with selective noise injection and information bottleneck.
In Advances in Neural Information Processing Systems, pp. 13978-13990, 2019.
Wengong Jin, Regina Barzilay, and Tommi Jaakkola. Domain extrapolation via regret minimization. arXiv
preprint arXiv:2006.03908, 2020.
Arthur Juliani, Ahmed Khalifa, Vincent-Pierre Berges, Jonathan Harper, Ervin Teng, Hunter Henry, Adam
Crespi, Julian Togelius, and Danny Lange. Obstacle Tower: A generalization challenge in vision, control,
and planning. In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), 2019.
Niels Justesen, Ruben Rodriguez Torrado, Philip Bontrager, Ahmed Khalifa, Julian Togelius, and Sebastian
Risi. Illuminating generalization in deep reinforcement learning through procedural level generation. arXiv
preprint arXiv:1806.10729, 2018.
Taylor W. Killian, George Dimitri Konidaris, and Finale Doshi-Velez. Robust and efficient transfer learning
with hidden parameter Markov decision processes. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), pp. 4949-4950, 2017.
Ilya Kostrikov, Denis Yarats, and Rob Fergus. Image augmentation is all you need: Regularizing deep
reinforcement learning from pixels. CoRR, abs/2004.13649, 2020.
Kim G Larsen and Arne Skou. Bisimulation through probabilistic testing. Information and computation, 94(1):
1-28, 1991.
Michael Laskin, Kimin Lee, Adam Stooke, Lerrel Pinto, Pieter Abbeel, and Aravind Srinivas. Reinforcement
learning with augmented data. CoRR, abs/2004.14990, 2020a.
Michael Laskin, Aravind Srinivas, and Pieter Abbeel. Curl: Contrastive unsupervised representations for
reinforcement learning. Proceedings of the 37th International Conference on Machine Learning, Vienna,
Austria, PMLR 119, 2020b. arXiv:2003.06417.
Kimin Lee, Kibok Lee, Jinwoo Shin, and Honglak Lee. Network randomization: A simple technique for general-
ization in deep reinforcement learning. In The International Conference on Learning Representations (ICLR),
2020a.
Kuang-Huei Lee, Ian Fischer, Anthony Liu, Yijie Guo, Honglak Lee, John Canny, and Sergio Guadarrama.
Predictive information accelerates learning in rl. arXiv preprint arXiv:2007.12401, 2020b.
Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M. Hospedales. Learning to generalize: Meta-learning for
domain generalization. In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI), 2018.
Bogdan Mazoure, Remi Tachet des Combes, Thang Long DOAN, Philip Bachman, and R Devon Hjelm. Deep
reinforcement and infomax learning. Advances in Neural Information Processing Systems, 33, 2020.
L. McInnes, J. Healy, and J. Melville. UMAP: Uniform Manifold Approximation and Projection for Dimension
Reduction. ArXiv e-prints, February 2018.
Ted Moskovitz, Michael Arbel, Ferenc Huszar, and Arthur Gretton. Efficient wasserstein natural gradients for
reinforcement learning. In International Conference on Learning Representations, 2021.
Junhyuk Oh, Satinder P. Singh, Honglak Lee, and Pushmeet Kohli. Zero-shot task generalization with multi-task
deep reinforcement learning. In Proceedings of the International Conference on Machine Learning (ICML),
2017.
Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive coding.
arXiv preprint arXiv:1807.03748, 2018.
Aldo Pacchiano, Jack Parker-Holder, Yunhao Tang, Krzysztof Choromanski, Anna Choromanska, and Michael
Jordan. Learning to score behaviors for guided policy optimization. In International Conference on Machine
Learning, 2020.
Charles Packer, Katelyn Gao, Jernej Kos, Philipp Krahenbuhl, Vladlen Koltun, and Dawn Song. Assessing
generalization in deep reinforcement learning. arXiv preprint arXiv:1810.12282, 2018.
Christian F. Perez, Felipe Petroski Such, and Theofanis Karaletsos. Generalized hidden parameter mdps
transferable model-based rl in a handful of trials. In Proceedings of the AAAI Conference on Artificial
Intelligence (AAAI), 2020.
11
Published as a conference paper at ICLR 2021
Jordi Pont-Tuset, Federico Perazzi, Sergi Caelles, Pablo Arbeldez, Alex Sorkine-Hornung, and Luc Van GooL
The 2017 davis challenge on video object segmentation. arXiv preprint arXiv:1704.00675, 2017.
Martin L Puterman. Markov Decision Processes: Discrete Stochastic Dynamic Programming. John Wiley &
Sons, Inc., 1994.
Roberta Raileanu, Max Goldstein, Denis Yarats, Ilya Kostrikov, and Rob Fergus. Automatic data augmentation
for generalization in deep reinforcement learning. arXiv preprint arXiv:2006.12862, 2020.
Aravind Rajeswaran, Kendall Lowrey, Emanuel Todorov, and Sham M. Kakade. Towards generalization and
simplicity in continuous control. In Advances in Neural Information Processing Systems (NeurIPS), 2017.
Benjamin Recht. A tour of reinforcement learning: The view from continuous control. Annual Review of Control,
Robotics, and Autonomous Systems, 2019.
Max Schwarzer, Ankesh Anand, Rishab Goel, R Devon Hjelm, Aaron Courville, and Philip Bachman. Data-
efficient reinforcement learning with momentum predictive representations. arXiv preprint arXiv:2007.05929,
2020.
Anoopkumar Sonar, Vincent Pacelli, and Anirudha Majumdar. Invariant policy optimization: Towards stronger
generalization in reinforcement learning. arXiv preprint arXiv:2006.01096, 2020.
Xingyou Song, Yiding Jiang, Yilun Du, and Behnam Neyshabur. Observational overfitting in reinforcement
learning. In The International Conference on Learning Representations (ICLR), 2019.
Austin Stone, Oscar Ramirez, Kurt Konolige, and Rico Jonschkowski. The distracting control suite 一 a
challenging benchmark for reinforcement learning from pixels. arXiv preprint arXiv:2101.02722, 2021.
Adam Stooke, Kimin Lee, Pieter Abbeel, and Michael Laskin. Decoupling representation learning from
reinforcement learning. arXiv preprint arXiv:2009.08319, 2020.
Remi Tachet des Combes, Philip Bachman, and Harm van Seijen. Learning invariances for policy generalization.
In Workshop track at the International Conference on Learning Representations (ICLR), 2018.
Yujin Tang, Duong Nguyen, and David Ha. Neuroevolution of self-interpretable agents. arXiv preprint
arXiv:2003.08165, 2020.
Yuval Tassa, Saran Tunyasuvunakool, Alistair Muldal, Yotam Doron, Siqi Liu, Steven Bohez, Josh Merel, Tom
Erez, Timothy Lillicrap, and Nicolas Heess. dm_control: Software and tasks for continuous control. arXiv
preprint arXiv:2006.12983, 2020.
Matthew E. Taylor and Peter Stone. Transfer learning for reinforcement learning domains: A survey. Journal of
Machine Learning Research,10:1633-1685, 2009.
Josh Tobin, Rachel Fong, Alex Ray, Jonas Schneider, Wojciech Zaremba, and Pieter Abbeel. Domain randomiza-
tion for transferring deep neural networks from simulation to the real world. In 2017 IEEE/RSJ International
Conference on Intelligent Robots and Systems (IROS), pp. 23-30. IEEE, 2017.
Elise van der Pol, Thomas Kipf, Frans A Oliehoek, and Max Welling. Plannable approximations to mdp
homomorphisms: Equivariance under actions. In Proceedings of the 19th International Conference on
Autonomous Agents and MultiAgent Systems, pp. 1431-1439, 2020.
CCdricVillani. Optimal transport: old and new. Springer, 2008.
Sam Witty, Jun Ki Lee, Emma Tosch, Akanksha Atrey, Michael Littman, and David Jensen. Measuring and
characterizing generalization in deep reinforcement learning. In NeurIPS Critiquing and Correcting Trends in
Machine Learning Workshop, 2018.
Keyulu Xu, Jingling Li, Mozhi Zhang, Simon S Du, Ken-ichi Kawarabayashi, and Stefanie Jegelka. How neural
networks extrapolate: From feedforward to graph neural networks. arXiv preprint arXiv:2009.11848, 2020.
Chang Ye, Ahmed Khalifa, Philip Bontrager, and Julian Togelius. Rotation, translation, and cropping for
zero-shot generalization. CoRR, abs/2001.09908, 2020.
Amy Zhang, Nicolas Ballas, and Joelle Pineau. A Dissection of Overfitting and Generalization in Continuous
Reinforcement Learning. CoRR, abs/1806.07937, 2018a.
Amy Zhang, Yuxin Wu, and Joelle Pineau. Natural environment benchmarks for reinforcement learning. arXiv
preprint arXiv:1811.06032, 2018b.
12
Published as a conference paper at ICLR 2021
Amy Zhang, Clare Lyle, Shagun Sodhani, Angelos Filos, Marta Kwiatkowska, Joelle Pineau, Yarin Gal, and
Doina Precup. Invariant causal prediction for block mdps. In Proceedings of the International Conference on
Machine Learning (ICML), 2020.
Amy Zhang, Rowan McAllister, Roberto Calandra, Yarin Gal, and Sergey Levine. Learning invariant repre-
sentations for reinforcement learning without reconstruction. The International Conference on Learning
Representations (ICLR), 2021.
Chiyuan Zhang, Oriol Vinyals, R6mi Munos, and Samy Bengio. A study on overfitting in deep reinforcement
learning. CoRR, abs/1804.06893, 2018c.
13
Published as a conference paper at ICLR 2021
Appendix
A Learning Contrastive Metric Embeddings
Augmentation Representation Projection
Input
Contrastive
Learning
Policy
Reinforcement
Learning
Figure A.1: Architecture for learning CMEs. Given an input pair (x, y), we first apply the (optional) data
augmentation operator Ψ to produce the input augmentations Ψx := Ψ(x), Ψy := Ψ(y). When not using
data augmentation, Ψ is equal to the identity operator, that is, ∀x Ψ(x) = x. The agent’s policy network then
outputs the representations for these augmentations by applying the encoder fθ, that is, fx = fθ (Ψx), fy =
fθ (Ψy). These representations are projected using a non-linear projector hθ to obtain the embedding zθ, that is,
zθ (x) = hθ (fx), zθ (y) = hθ (fy). These metric embeddings are trained using the contrastive loss defined in
Equation (4). The policy πθ is an affine function of the representation, that is, πθ (∙∣y) = WT fy + b, where
W, b are learned weights and biases. The entire network is trained end-to-end jointly using the reinforcement
learning (or imitation learning) loss in conjunction with the auxiliary contrastive loss.
B Proofs
We begin by defining some notation which will be used throughout these results:
•	Wedenote Et≥o [γt TV (∏(片),π* K))] = EYJPt≥° Yt TV (∏K ),∏* K))]
•	For any y ∈ Y, let Yt 〜PK(∙∣Yyt-1), where Yy = y.
•	TV n(Yk )= Eo≤t<n Yt TV (∏(Yk+t ),∏*(γk+t)).
We now proceed with some technical lemmas necessary for the main result.
Lemma 1. Given any two pseudometrics5 d, d0 ∈ M and probability distributions PX , PY where
X , Y ⊂ S, we have:
W1(d)(PX,PY) ≤ kd-d0k+W1(d0)(PX,PY)
Proof. Note that the dual of the linear program for computing W1(d)(PX , PY) is given by
min	Γ(x, y) d(x, y)
x∈X, y∈Y
subject to X Γ(x, y) = PY(y) ∀y,	X Γ(x, y) = PX (x) ∀x,	Γ(x, y) ≥ 0∀x,y
xy
5Pseudometrics are generalization of metrics where the distance between two distinct states can be zero.
14
Published as a conference paper at ICLR 2021
Using the dual formulation subject to the constraints above, W1 (d) can be written as
WYd)(PX,Pγ) ≤ kd - d0k = W 1(d - d' + d0)(Pχ,Pγ) ≤ Ild - d0k
=min E	Γ(x,y) (d(x,y) - d0(x,y) + d0(x,y))
χ∈X, y∈Y
≤ min X	Γ(x,y)(∣∣d - d0∣ + d0(x,y))
χ∈X, y∈Y
=∣∣d — d[∣ + min ɪ2	Γ(x, y) d0(x,y)
γ χ∈X ,y∈Y
=IId - d0∣∣+ W 1(d0 )(Pχ ,Pγ)
□
Lemma 2. Given any yo ∈ Y, we have:
X (Pπ(y1∣y0) - Pπ*(y1∣y0)) TVn(琮)≤ 1--Tv(∏(y0),π*(y0))
yι∈Y	Y
Proof.
X (Pπ(y1∣y0) - Pπ* (y1∣y0)) TVn(琮)≤ X (pπ(y1∣y0) - Pπ* (y1∣y0)) TVn(琮)
yι∈Y	yι∈Y
≤ X XP(y1∣y0,α)(∏(α∣y0)-π*(α∣y0)) TVn(琮)
yι∈Y a∈A
≤ X X P(y1∣y0,α) ∣π(α∣yo) - π*(α∣y0)∣
1 — Y
yι∈Y α∈A
=ι—— X ∣π(a∣y0) - π*(a∣y0)∣ X P(y"y0, a)
Y a∈A	yι∈Y
=ι-- X ∣π(a∣y0) - π*(a∣y0)∣
Y a∈A
2	............
=------tv(WyO),π (yO))
1	- Y
□
Lemma 3. Given any y° ∈ Y, if TV n(γ0) ≤ ɪ-γ d*(xy1 ,y1), we have:
X Pπ*(y1∣y0)TVn(琮)≤ 产W1(d*) (pπ*(∙∣xyo),Pπ*(∙∣y0))
yι∈Y	Y
Proof. Note that We have the following equality, where 0 is a vector of zeros:
X Pπ* (y1∣y0)TVn(Y0)= X Pπ* (y1∣y0)TVn(γ0) - X Pπ* (x∣xyo)0
yι∈Y	yι∈Y	χ∈X
which is the same form as the primal LP for W1(d*)(Pπ* (∙∣y0), Pπ* (∙∣xyo)). By assumption, we
have that
TVn(γ0) ≤ 1+Yd*(xy1,y1)
This implies that j-γTVn(Y^0) is a feasible solution to W1(d*)(Pπ* (∙∣y0), Pπ* (∙∣xyo)):
X Pπ*(y1∣y0)l+2TVn(琮)≤ W1(d*) (pπ*(∙∣xyo),Pπ*(∙∣y0))
yι∈Y	+ Y
and the result follows.	□
15
Published as a conference paper at ICLR 2021
Proposition B.1. The operator F given by:
, , ,	,	,	, ,	, ..	,	—* , .	— * , .
F(d)(x,y) = DIST(n (x),π (y)) + YWIm)(PX (Ix),PY (Iy))
is a contraction mapping and has a unique fixed point for a bounded dist.
Proof. We first prove that F is contraction mapping. Then, a simple application of the Banach Fixed
Point Theorem asserts that F has a unique fixed point. Note that for all pseudometrics d, d0 ∈ M,
and for all states x ∈ X, y ∈ Y,
F(d)(x, y) - F (d0)(x, y)
=γ (Wι(d)(PπX(∙∣x),Pγ*(∙∣y)) -Wι(d0)(PπX(∙∣x),Pγ*(∙∣y)))
Lemma 1	*	*	*	*
≤ Y (kd-d0k + W1(d0)(PπX(∙∣x),pγ (∙∣y)) -W1(d0)(Pπχ(∙∣x),pγ (∙∣y)))
= γ kd - d0k
Thus, kF (d) - F(d0)k ≤ Ykd - d0k, so that F is a contracting mapping for Y < 1 and has an unique
fixed point d*.
Theorem 1. [Bound on policy transfer] For any y ∈ Y, let Yy 〜Pπ (∙ | YtT) define the Sequence
of random states encountered starting in Yy) = y andfollowing policy π. We have:
EYyt XYtTV (Π(γt),∏*(γt)) ≤ 1+⅞d*(xy,y).
t≥)	Y
Proof. We will prove this by induction. Assuming that the bound holds for TVn , we prove the bound
holds for TVn+1. Thebase case for n = 1 follows from TV(∏(y), ∏*(y)) = TV(∏*(xy),∏*(y)) ≤
d* (xy, y). Note that TVn ≤ 1；-Y since the TV distance per time-step can be at most 1.
Let Pn (y0∣y) denote the probability of ending in state y0 ∈ Y after t steps when following policy ∏
and starting from state y. We then have:
TVn+1(Yyk) = X Pk(yk∣y)TV(∏(yk),∏t(yk)) + YTVn(Yyk+1)
yk ∈Y
=X Pk(yfc∣y) TV(∏(yk),∏*(yk))+ Y X Pn(yk+ι∣yk)τv"(蹴十)
yk∈Y	yk+1∈Y
=X Pk (yk|y) TV (∏(yk ),∏*(yk))+ Y X F (yk+ι∖yk) - Pπ* (yk+ι∣yk)) tv n(Y0c+J
yk∈Y	yk+1∈Y
+γ X Pπ*(yk+ι∖yk)τvn(Y0k+,)
yk+1 ∈Y
Lemma 2	2Y	*
≤	∑ Pk(yk∖y) TV(∏(yk),∏*(yk)) + r--Tv(∏(yk),∏'(yk)) + Y E Pπ (yk+ι∖yk)TVn(⅛ι)
yk∈Y	Y	yk+1 ∈Y
Lemma 3
≤ E Pk(yk∖y) [TV(∏(yk),∏*(yk))
yk ∈Y
+γ ( 1-YTV(Π(yk),∏*(yk)) + 1-YWι(dt)(Pk* “XyJP"* (∙∖yk)))
=X Pk(yk∖y) [ 1+^ (TV(∏*(Xyk),∏*(yk)) + γWι(d*)(Pk* (∙∖Xyk),Pk* (∙∖yk)))]
yk∈Y	Y
≤ X pk∏(yk\y)1+γd*(Xyk,yk)
1- Y
yk∈Y
16
Published as a conference paper at ICLR 2021
Thus, by induction, it follows that for all n:
TVn(Y0) ≤ 1+γd*(Xy,y),
which completes the proof.	□
C Bisimulation metrics
Notation. We use the notation as defined in Section 2.
Bisimulation metrics (Givan et al., 2003; Ferns et al.,2011) define a pseudometric d〜：S ×S → R
where d〜(x, y) is defined in terms of distance between immediate rewards and next state distributions.
Define FZ : M → M by
Fz(d)(x, y) = max |R(x, a) - R(y, a)| + γWι(d)(Pa(∙ | x), Pa(∙ | y))	(C.1)
a∈A
then, FZe has a unique fixed point dZ which is a bisimulation metric. FZe uses the 1-Wasserstein
metric W1 : M → Mp. The 1-Wasserstein distance W1(d) under the pseudometric dcan be computed
using the dual linear program:
max	P (x)ux	-	P (y)vy	subject to ∀x	∈ X , y ∈ Y	ux	-	vy	≤ d(x, y)
u,v x∈X	y∈Y
Since we are only interested in computing the coupling between the states in X and Y, the above
formulation assumes that PX (y) = 0 for all y ∈ Y and PY (x) = 0 for all x ∈ X. The computation
of dZ is expensive and requires a tabular representation of the states, rendering it impractical for large
state spaces. On-policy bisimulation (Castro, 2020) (e.g., ∏*-bisimulation) is tied to specific behavior
policies and is much easier to approximate than bisimulation.
D	Policy Similarity Metric
D.1 Computing PSM
In general, PSM for a given DIST across MDPs MX and MY is given by
d*(χ, y) = dist(∏X(x), ∏Y(y)) + γWι (d*)(PX* (∙ | x), Pγ* (∙ | y)).	(D.1)
Since our main focus is showing the utility of PSM for generalization, we simply use environments
where PsM can be computed using dynamic programming. Using a similar observation to Castro
(2020), we assert that the recursion for d* takes the following form in deterministic environments:
d*(x,y) = Dist(∏X (x),∏Y (y)) + γd*(x0,y0).	(D.2)
where x0 = PXπ* (x), y0 = PYπ* (y) are the next states from taking actions πX* (x), πX* (y) from states
x, y respectively. Furthermore, we assume that DIsT between terminal states from MX and MY is
zero. Note that the form of Equation D.2 closely resembles the update rule in Q-learning, and as such,
can be efficiently computed with samples using approximate dynamic programming. Given access to
optimal trajectories τX* = {xt}tN=1 and τY* = {yt}tN=1, where xt+1 = PXπ* (xt) and yt+1 = PYπ* (yt),
Equation D.2 can be solved using exact dynamic programming; we provide pseudocode in section J.1.
There are other ways to approximate the Wasserstein distance in bisimulation metrics (e.g., Ferns
et al., 2006; 2011; Castro, 2020; Zhang et al., 2021). That said, approximating bisimulation (or PsM)
for stochastic environments remains an exciting research direction (Castro, 2020). Investigating other
distance metrics for long-term behavior difference in PsM is also interesting for future work.
D.2 PsM Connections to Data Augmentation and Bisimulation
Connection to bisimulation. Although bisimulation metrics have appealing properties such as
bounding value function differences (e.g., (Ferns & Precup, 2014)), they rely on reward information
and may not provide a meaningful notion of behavioral similarity in certain environments. Propo-
sition D.1 implies that states similar under PsM would have similar optimal policies yet can have
arbitrarily large bisimulation distance between them.
17
Published as a conference paper at ICLR 2021
Figure D.1: Cyan edges represent actions with a positive reward, which are also the optimal actions. Zero
rewards everywhere else. x0 , y0 are the start states while x2 , y2 are the terminal states.
Proposition D.1. There exists environments MX and MY such that ∀(X, y) ∈ L where L =
{(x,y) ∣X ∈ X, y ∈ Y, d*(x,y) = 0}, dL(x,y) = IRmax-RminI - e for any given e > 0.
For example, consider the two semantically equivalent environments in Figure D.1 with πX (XO)=
∏Y(yo) = ao and ∏X(xι) = ∏γ(yι) = aι but different rewards r,,ry respectively. Whenever
r% > (1 + 1∕γ) rχ, bisimulation metrics incorrectly imply that x° is more behaviorally similar to yι
than y0 .
For the MDPs shown in Figure D.1, to determine which y state is behaviorally equivalent to x0, we
look at the distances computed by bisimulation metric d〜and ∏*-bisimulation metric d[:
d〜(x0,y0) = dL(xo,yo) = (1 + γ)∣ry - r『|
d〜(xo,yι) = max((1 + Y) rχ,r%), d-(x0,yι) = |ry - rχ∣ + Yrx
Thus, ry > (1 + 1∕γ) rx implies that d〜(x0,y1) < d〜(x0,y0) as well as d[(x0, yι) < d[(xo, yo).
Connection to data augmentation. Data augmentation often assumes access to optimality invariant
transformations, e.g., random crops or flips in image-based benchmarks (Laskin et al., 2020a;
Kostrikov et al., 2020). However, for certain RL tasks, such augmentations can erroneously alias
states with different optimal behavior and hurt generalization. For example, if the image observation
is flipped in a goal reaching task with left and right actions, the optimal actions would also be flipped
to take left actions instead of right and vice versa. Proposition D.2 states that PSMs can precisely
quantify the invariance of such augmentations.
Proposition D.2. For an MDP MX and its transformed version Mψ(X) for the data augmentation
ψ, d*(x, ψ(x)) indicates the optimality invariance of ψ for any X ∈ X.
D.3 PSM with Approximately-Optimal Policies
Generalized Policy Similarity Metric for arbitrary policies. For a given DIST, we define a
generalized PSM d : (S × Π) × (S × Π) → R where Π is the set of all policies over S. d satisfies
the recursive equation:
d((x,∏ι), (y,∏2)) = DIST(∏1(x),∏2(y)) + γWι(d)(Pπ1(∙ | x),Pπ2 (∙ | y)).	(D.3)
Since DIST is assumed to be a pseudometric and W1 is a probability metric, it implies that d
is a pseudometric as (1) d is non-negative, that is, d (X, π1), (y, π2) ≥ 0, (2) d is symmetric,
that is, d (X, π1), (y, π2) = d (X, π1), (y, π2) , and d satisfies the triangle inequality, that is,
d (X,π1), (y,π2) < d (X,π1), (z,π3) + d (z,π3), (y, π2) .
Using this notion of generalized PSM, we show that the approximation error in PSM from
using a suboptimal policy is bounded by the policy’s suboptimality. Thus, for policies with decreasing
suboptimality, the PSM approximation becomes more accurate, resulting in improved PSEs.
Proposition D.3. [Approximation error in PSM] Let d : S × S → R be the approximate PSM
computed using a suboptimal policy π defined over S, that is, d(x,y) = DIST(∏(x),∏(y)) +
γWι(d)(Pπ(∙ | x), Pπ(∙ | y)) . We have:
*
|d (χ,y) - d(χ,y)∣ <
Long-term suboptimality
difference from x
+	d ((y,π), (y,π*))
X-------{--------}
Long-term suboptimality
difference from y
18
Published as a conference paper at ICLR 2021
Proof. The PSM d* and approximate PSM d are instantiations of the generalized PSM (Equation D.3)
with both input policies as ∏* and ∏ respectively.
d*(χ,y) = d (W), (y,∏*)) < d((χ,∏*), (χ,∏)) + d((χ,∏), (y,∏*))
< d((χ,∏*), (χ,∏)) + d((y,∏), (y,∏*)) + d((χ,∏), (y,∏))
d*(χ,y) - d(χ,y) < d((χ,∏*), (χ,∏)) + d((y,∏), (y,∏')) 丁 d(χ,y) = d((χ,∏), (y,∏))
Similarly, (d(x,y) - d*(x,y) < d((x,π*), (x,∏)) + d((y,∏), (y,π*))
□
E L2 Metric Embeddings
Another common choice (Zhang et al., 2021) for learning metric embeddings is to use the squared
loss (i.e., l2-loss) for matching the euclidean distance between the representations of a pair of states
to the metric distance between those states. Concretely, for a given d* and representation fθ, the
loss L(θ) = Esi,sj [(kfθ(Si) - fθ(Sj)∣∣2 - d*(si, Sj))2] is minimized. However, it might be too
restrictive to match the exact metric distances, which we demonstrate empirically by comparing l2
metric embeddings with CMEs (Section 5.2).
F Extended Related Work
Generalization across different tasks used to be described as transfer learning. In the past, most
transfer learning approaches relied on fixed representations and tackled different problem formulations
(e.g., assuming shared state space). Taylor & Stone (2009) present a comprehensive survey of
the techniques at the time, before representation learning became so prevalent in RL. Recently,
the problem of performing well in a different, but related task, started to be seen as a problem
of generalization; with the community highlighting that deep RL agents tend to overfit to the
environments they are trained on (Cobbe et al., 2019; Witty et al., 2018; Farebrother et al., 2018;
Juliani et al., 2019; Kostrikov et al., 2020; Song et al., 2019; Justesen et al., 2018; Packer et al., 2018).
Prior generalization approaches are typically adapted from supervised learning, including data aug-
mentation, regularization (Cobbe et al., 2019; Farebrother et al., 2018), stochasticity (Zhang et al.,
2018c), noise injection (Igl et al., 2019; Zhang et al., 2018a), more diverse training conditions (Ra-
jeswaran et al., 2017; Witty et al., 2018) and self-attention architectures (Tang et al., 2020). In contrast,
PSEs exploits behavior similarity (Section 3), a property related to the sequential aspect of RL. Fur-
thermore, for certain RL tasks, it can be unclear what an optimality invariant data augmentation would
look like (Section 5.3). PSM can quantify the invariance of such augmentations (Proposition D.2).
Meta-learning is also related to generalization. Meta-learning methods try to find a parametrization
that requires a small number of gradient steps to achieve good performance on a new task (Finn et al.,
2017). In this context, various meta-learning approaches capable of zero-shot generalization have
been proposed (Li et al., 2018; Agarwal et al., 2019; Balaji et al., 2018). These approaches typically
consist in minimizing the loss in the environments the agent is while adding an auxiliary loss for
ensuring improvement in the other (validation) environments available to the agent. Nevertheless,
Tachet des Combes et al. (2018) has shown that meta-learning approaches fail in the jumping task
which we also observed empirically. Others have also reported similar findings (e.g., Farebrother
et al., 2018).
There are several other approaches for tackling zero-shot generalization in RL, but they often rely on
domain-specific information. Some examples include knowledge about equivalences between entities
in the environment (Oh et al., 2017) and about what is under the agent’s control (Ye et al., 2020).
Causality-based methods are a different way of tackling generalization, but current solutions do not
scale to high-dimensional observation spaces (e.g., Killian et al., 2017; Perez et al., 2020; Zhang
et al., 2020).
19
Published as a conference paper at ICLR 2021
G Jumping Task with Pixels
Obstacle PosiTion=20, Floor Height = 15
Obstacle PosiTion=30, Floor Height = 10
Figure G.1: Optimal trajectories on the jumping tasks for two different environments. Note that the optimal
trajectory is a sequence of right actions, followed by a single jump at a certain distance from the obstacle,
followed by right actions.
Detailed Task Description. The jumping task consists of an agent trying to jump over an obstacle
on a floor. The environment is deterministic with the agent observing a reward of +1 at each time
step. If the agent successfully reaches the rightmost side of the screen, it receives a bonus reward of
+100; if the agent touches the obstacle, the episode terminates. The observation space is the pixel
representation of the environment, as depicted in Figure 1. The agent has access to two actions: right
and jump. The jump action moves the agent vertically and horizontally to the right.
Architecture. The neural network used for Jumping Task experiment is adapted from the Nature
DQN architecture. Specifically, the network consists of 3 convolutional layers of sizes 32, 64, 64
with filter sizes 8 × 8, 4 × 4 and 3 × 3 and strides 4, 2, and 1, respectively. The output of the convnet
is fed into a single fully connected layer of size 256 followed by ’ReLU’ non-linearity. Finally, this
FC layer output is fed into a linear layer which computes the policy which outputs the probability of
the jump and right actions.
Contrastive Embedding. For all our experiments, we use a single ReLU layer with k = 64 units for
the non-linear projection to obtain the embedding zθ (Figure A.1). We compute the embedding using
the penultimate layer in the jumping task network. Hyperparameters are reported in Table G.2.
Total Loss. For jumpy world, the total loss is given by LIL + αLCME where LIL is the imitation
learning loss, LCME is the auxiliary loss for learning PSEs with the coefficient α.
pφ>oS^s(ollsə.L %
pφ>oS^s(ollsə.L %
pφ>os sjls(ollsə.L %
PSEs
Dropout + 12 reg.
% % %
Ooo
2 1
Training Iterations
PSEs
Dropout + 12 reg.
Training Iterations
O
O
2c
Oo
15
Oo
10
O
50
Training Iterations
Figure G.3: Test performance curves in the setting without data augmentation on the “wide”, “narrow”, and
random grids described in Figure 2. We plot the median performance across 100 runs. Shaded regions show 25
and 75 percentiles.
20
Published as a conference paper at ICLR 2021
BisiMULATioN
y50
"40
"30
y20
"10
"0
X0 X10 X20 X30 X40 X50
PSM
175
150
125
100
-75
-50
-25
(a)	Bisimulation metric
π* - BisimULAtioN
y50
440
y30
y20
y10
y0
x0 x10 x20 x30 x40 x50
(b)	Policy Similarity metric
1.75
1.50
1.25
-1.00
-0.75
-0.50
-0.25
l-l0.00
"50
940
930
920
y10
4000
3000
-2000
-1000
TRUE Similarity
1.0
y0
X0 X10 X20 X30 X40 X50
y50
"40
"30
"20
y10
-0.4
-0.2
y。
X0 x10 x20 x30 x40 x50
0.8
0.6
l-l0.0
(C) π* -Bisimulation metric
(d) True State Similarity
~~L 0
~~L 0
Figure G.2: PSM vs. Bisimulation. Visualizing PSM and bisimulation metrics with discount factor γ = 0.99.
xi and yi correspond to the states visited by optimal policies in the two environments with obstacle at positions
25 and 45, respectively. For each grid, the (i, j)th location shows the distance assigned by the metric to the
states xi and yj. Lower distances (lighter shades) imply higher similarity between two states. The bottom right
figure shows which states are equivalent to each other. The ranges are different for each metric as bisimulation
metrics utilize reward differences while PSM uses the total variation (TV ) distance between policies. Note that
the large bisimulation distances are due to the fact that the reward at the terminal state is set to 100.
P ①>0s SXSE-l->s ① J- %
100%
80%
60%
40%
20%
0%
Training Iterations
P ①>0s s*s134S ① J, %
100%
80%
60%
40%
20%
0%
0	500	1000 1500
RandConv + PSEs
RandConv
200
P ①>0s s*s134S ① J- %
Training Iterations
Training Iterations
Figure G.4: Test performance curves in the setting with data augmentation on the “wide”, “narrow”, and
random grids described in Figure 2. We plot the median performance across 100 runs. Shaded regions show 25
and 75 percentiles.
21
Published as a conference paper at ICLR 2021
G.	1 Jumping Task from Colors
o IOag ∙o so
I'
1«
2«
30
4«
S6
«	1«	2«	3«	4« S«
Figure G.5: Jumping task with colored ob-
stacles. The agent needs to jump over the red
obstacle but strike the green obstacle.
Table G.1: Percentage (%) of test tasks solved when trained
on the “wide” grid with both red and green obstacles. The
numbers we report are averaged across 100 runs. Standard
error is reported between parentheses.
Method	Red (%)	Green (%)
RandConv	6.2 (0.4)	99.6 (0.2)
Dropout and l2 reg.	19.5 (0.2)	100.0 (0.0)
RandConv + PSEs	29.8 (1.3)	99.6 (0.2)
PSEs	37.9 (1.9)	100.0 (0.0)
Input Augmentation Augmentation Augmentation Augmentation Augmentation
Input Augmentation Augmentation Augmentation Augmentation Augmentation
Figure G.6: Randconv enforces color invariance. The first column shows the original observation where
the top row corresponds to the observation from task with green obstacle jumping task while the bottom row
corresponds to the red obstacle jumping task. Columns 2-6 in each row show 5 augmentations by applying
RandConv. The augmentations show that RandConv tries to encode invariance with respect to the obstacle color.
G.2 Hyperparameters
For hyperparameter selection, we evaluate all agents on a validation set containing 54 unseen tasks
in the “wide” grid and pick the parameters with the best validation performance. The validation
set (Figure G.7) was selected by using the environments nearby to the training environments whose
floor height differ by 1 or whose obstacle position differ by 1.
Table G.2: Common hyperparameters across
all methods for all jumping task experiments.
Hyperparameter	Value
Learning rate decay	0.999
Training epochs	2000
Optimizer	Adam
Batch size (Imitation)	256
Num training tasks	18
Γ-scale Parameter (β)	0.01
Embedding size (k)	64
Batch Size (LCME)	57
∣τχ |	57
Figure G.7: Unseen 56 validation tasks, labeled with V, used
for hyperparameter selection.
22
Published as a conference paper at ICLR 2021
Table G.3: Optimal hyperparameters for reporting results in Table 1. These hyperparameters are selected using
the “wide” grid by maximizing final performance on a validation set containing 56 unseen tasks. All grid
configurations in Table 1 use these hyperparameters.
Hyperparameter	Dropout and '2-reg.	PSEs	RandConv RandConv + PSEs
Learning Rate	4×10-3	3.2×10-3	7×10-3	2.6×10-3
'2-reg. coefficient	4.3×10-4	1×10-5	—	—
Dropout coefficient	3×10-1	—	—	—
Contrastive Temperature (1 /λ)	—	1.0	-	5×10T
Auxiliary loss coefficient (α)	—	1×101	-	5.0
Table G.4: Optimal hyperparameters for reporting results in Figure 5.3. These hyperparameters are selected
using the “wide” grid by maximizing final performance on a validation set containing 56 unseen tasks.
Hyperparameter	Dropout and '2-reg.	PSEs	RandConv RandConv + PSEs
Learning Rate	4×10-3	6×10-3	5×10-3	2.6×10-3
'2-reg. coefficient	4.3×10-4	7×10-5	--
Dropout coefficient	3×10-1	-	--
Contrastive Temperature (1∕λ)	-	5×10-1	-	5×10-1
Auxiliary loss coefficient (α)	-	5.0	-	5.0
Table G.5: Optimal hyperparameters for reporting ablation results in Table 2. These hyperparameters are selected
using the “wide” grid by maximizing final performance on a validation set containing 56 unseen tasks.
Hyperparameter	PSM		π* -bisimulation	
	CMEs	'2 -embeddings	CMEs	'2 -embeddings
Learning Rate	4×10	-3	5×10-4	4.7×10-4	1×10-4
Contrastive Temperature (1∕λ)	1.0	-	5×10-1	-	
Auxiliary loss coefficient (α)	5.0	1×10-1	1×10-1	1×10-6
Please note that Table G.3 and Table G.4 correspond to two different tasks: one uses the standard
jumping task with white obstacles, while the other uses colored obstacles where the optimal policies
depend on color. For fair comparison, we tune hyperparameters for all the methods using Bayesian
optimization (Golovin et al., 2017). We use the best parameters among these tuned hyperparameters
and the ones found in Table G.3, leading to different parameters for both PSEs as well as RandConv.
Evaluating PSEs with the jumping task hyperparameters from Table G.3 instead of the ones in
Table G.4 leads to a small drop (-4%) on the jumping task with colors (Section 5.3). Nevertheless,
PSEs still outperform other methods in Section 5.3.
H LQR: Additional Details
Optimal control with linear dynamics and quadratic cost, commonly known as LQR, has been
increasingly used as a simplified surrogate for deep RL problems (Recht, 2019). Following Song et al.
(2019); Sonar et al. (2020), we analyze the following LQR problem for assessing generalization:
minimize
subject to
ES0〜D [2 P∞=0 STQst + aTRat],
0.1 Wc
st+1 = Ast + Bat, ot =	st, at = Kot,
(H.1)
where D is the initial state distribution, st ∈ Rns is the (hidden) true state at time t, at ∈ Rna is
the control action, and K is the linear policy matrix. The agent receives the input observation ot,
which is a linear transformation of the state st. Wc and Wd are semi-orthogonal matrices to prevent
information loss for predicting optimal actions. An environment corresponds to a particular choice
23
Published as a conference paper at ICLR 2021
Table H.1: LQR generalization performance: Absolute error in LQR cost, w.r.t. the oracle solver (which has
access to true state), of various methods trained with nd distractors on N = 2 environments. The reported mean
and standard deviations are across 100 different seeds. Lower error is better.
Method	Number of Distractors (nd)		
	500	1000	10000
Overparametrization (Song et al., 2019)	25.8 (1.5)	24.9 (1.1)	24.9 (0.4)
IPO (Sonar et al., 2020) (IRM + Policy opt.)	32.6 (5.0)	27.3 (2.8)	24.8 (0.4)
Weight Sparsity ('ι-reg.)	28.2 (0.0)	28.2 (0.0)	28.2 (0.0)
PSM (State aggregation)	0.03 (0.0)	0.03 (0.0)	0.02 (0.0)
of Wd ; all other system parameters (A, B, Q, R, Wc) are fixed matrices which are shared across
environments and unknown to the agent. The agent learns the policy matrix K using N training
environments based on Equation H.1. At test time, the learned policy is evaluated on environments
with unseen Wd .
The generalization challenge in this setup is to ignore the distractors: Wcst ∈ Rns represents the
state features invariant across environments while Wdst ∈ Rnd is a high-dimensional distractor of
size ns , nd, respectively, such that ns << nd. Furthermore, the policy matrix which generalizes
across all environments is K?
10 WcP?T
0
T
, where P? corresponds to the optimal LQR solution
with access to state st . However, for a single environment with distractor Wd, multiple solutions
10α WcP?T
(1 - α) WdP?T
exist, for instance, K?0
T
∀α ∈ [0, 1]. Note that the distractors are an order
of magnitude larger than the invariant features in ot and dependence on them is likely to cause the
agent to act erratically on inputs with unseen distractors, resulting in poor generalization.
We use overparametrized policies with two linear layers, i.e., K = K1K2, where K1(o) is the learned
representation for observation o. We learn K using gradient descent using the combined cost on
2 training environments with varying number of distractors. We aggregate observation pairs with
near-zero PSM by matching their representations using a squared loss. We use the open-source code
released by Sonar et al. (2020) for our experiments.
Table H.2: An overview of hyper-parameters for LQR.
Parameter	Setting
A B nx na Q R	Orthogonal matrix, scaled 0.8 I20×20 20 20 I20×20 I20×20
Ki ∀i Wd	Orthogonal Initialization, scaled 0.001 Random semi-orthogonal matrix
The reliance on distractors for IPO also highlights a limitation of IRM: if a model can achieve
a solution with zero training error, then any such solution is acceptable by IRM regardless of its
generalization ability - a common scenario with overparametrized deep neural nets (Jin et al., 2020).
H.	1 Near-optimality of PSM Aggregation
Conjecture 1. Assuming zero state aggregation error with policy similarity metric (PSM), the policy
matrix K learned using gradient descent is independent of the distractors.
Proof. For LQR domains x, y, an observation pair (otx, oty) has zero PSM iff the underlying state st
is same for both the observations in the pair. This is true, as (a) both domains has the same transition
24
Published as a conference paper at ICLR 2021
dynamics, as specified by Equation H.1, and (b) the optimal policy is deterministic and is completely
determined by the current state st at any time t.
Assume otx	=	0.W1 Wc	st	and oty	=	0.W1 Wc	st	for distractor semi-orthogonal matrices WdX	and
WdY, respectively. Furthermore, the representation is given by K1 (otx) and K1 (oty) respectively.
Assume that K1 = [Ks Kd] where Ks ∈ Rh×ns and Kd ∈ Rh×nd and K1 ∈ Rh×(ns+nd).
Zero state-aggregation error with squared loss implies that for pair (otx , oty) corresponding to st,
K1(otx-oty) =K1 W x	-0	W y	st	=0	=⇒	Kd(Wdx	-Wdy)st=0	(H.2)
As Equation H.2 holds for all states visited by the optimal policy in an infinite horizon LQR, it
follows that Kd(Wdx - Wdy ) = 0.
Furthermore, it is well-known that gradient descent tends to find low-rank solutions due to implicit
regularization (Arora et al., 2019; Gunasekar et al., 2017), e.g.,with small enough step sizes and
initialization close enough to the origin, gradient descent on matrix factorization converges to the
minimum nuclear norm solution for 2 layer linear networks (Gunasekar et al., 2017). Based on this,
We conjecture that Kd = 0 which We found to be true in practice.	□
I	Distracting Control S uite
We use the same setup as Kostrikov et al. (2020); Stone et al. (2021) for implementation details and
training protocol. For completeness, We describe the details beloW.
Dynamic Background Distractions. In Distracting Control Suite (Stone et al., 2021), random
backgrounds are projected from scenes of the DAVIS 2017 dataset (Pont-Tuset et al., 2017) onto
the skybox of the scene. To make these backgrounds visible for all tasks and vieWs, the floor grid
is semi-transparent With transparency coefficient 0.3. We take the first 2 videos in the DAVIS 2017
training set and randomly sample a scene and a frame from those at the start of every episode. In
the dynamic setting, the video plays forWards or backWards until the last or first frame is reached at
Which point the video is played backWards. This Way, the background motion is alWays smooth and
Without “cuts”.
Soft Actor-Critic. Soft Actor-Critic (SAC) (Haarnoja et al., 2018) learns a state-action value function
Qθ, a stochastic policy πθ and a temperature α to find an optimal policy for an MDP (S, A,p, r, γ) by
optimizing a γ-discounted maximum-entropy objective. θ is used generically to denote the parameters
updated through training in each part of the model. The actor policy ∏ (a∕st) is a parametric tanh-
Gaussian that given St samples at = tanh(μθ(St) + σθ(St)e), where e 〜N(0,1) and μe and σθ are
parametric mean and standard deviation.
The policy evaluation step learns the critic Qθ(St, at) network by optimizing a single-step of the soft
Bellman residual
JQ(D) = E(st,at ,st)〜D [(Qθ (St, at) - yt)2]
at~π∙lSt)
yt = r(st,at) + Y[Qθ0(st,at) - αlogπθ(at|st)],
where D is a replay buffer of transitions, θ0 is an exponential moving average of the weights. SAC
uses clipped double-Q learning, which we omit for simplicity but employ in practice.
The policy improvement step then fits the actor policy ∏θ(at∣st) network by optimizing the objective
Jn(D)= Est〜D[Dkl(∏θ(∙∣st)∣∣ exp{1 Qθ(st, ∙)})]∙
α
Finally, the temperature α is learned with the loss
Ja(D)= E St〜D [-a log πθ(at|st) - αHH],
at 〜∏θ(∙∣st)
where H ∈ R is the target entropy hyper-parameter that the policy tries to match, which in practice is
usually set to HH = -|A|.
25
Published as a conference paper at ICLR 2021
Figure I.1: DCS Test Environments: Snapshots of test environments used for evaluating generalization on
Distracting Control Suite. Random backgrounds are projected from scenes of the first 30 videos of DAVIS 2017
validation dataset.
26
Published as a conference paper at ICLR 2021
I.1	Actor and Critic Networks
Following Kostrikov et al. (2020), we use clipped double Q-learning for the critic, where each
Q-function is parametrized as a 3-layer MLP with ReLU activations after each layer except of the
last. The actor is also a 3-layer MLP with ReLUs that outputs mean and covariance for the diagonal
Gaussian that represents the policy. The hidden dimension is set to 1024 for both the critic and actor.
I.2	Encoder Network
We employ the encoder architecture from Kostrikov et al. (2020). This encoder consists of four
convolution layers with 3 × 3 kernels and 32 channels. The ReLU activation is applied after each
convolutional layer. We use stride to 1 everywhere, except of the first convolutional layer, which
has stride 2. The output of the convnet is feed into a single fully-connected layer normalized
by LayerNorm. Finally, we apply tanh nonlinearity to the 50 dimensional output of the fully-
connected layer. We initialize the weight matrix of fully-connected and convolutional layers with the
orthogonal initialization and set the bias to be zero. The actor and critic networks both have separate
encoders, although we share the weights of the conv layers between them. Furthermore, only the
critic optimizer is allowed to update these weights (i.e.,we stop the gradients from the actor before
they propagate to the shared convolutional layers).
I.3	Contrastive Metric Embedding Loss
For all our experiments, we use a single ReLU layer with k = 256 units for the non-linear projection
to obtain the embedding zθ (Figure A.1). We compute the embedding using the penultimate layer in
the actor network. For picking the hyperparameters, we used 3 temperatures [0.1, 0.01, 1.0] and 3
auxiliary LCME loss coefficients [1, 3, 10] using “Ball In Cup Catch” as the validation environment.
All other hyperparameters are the same as prior work (see Table I.2).
We approximate optimal policies with the policies obtained after training a DrQ agent for 500K
environment steps. Since a given action sequence from this approximate policy has the same perfor-
mance across different training environments, we compute the PSM across training environments, via
dynamic programming (see Section J.1 for pseudo-code), using such action sequences.
Total Loss. The total loss is given by LRL + αLCME where LRL is the reinforcement learning loss
which combines Jπ(D), Jπ(D), and Jα(D)), while LCME is the auxiliary loss for learning PSEs
with the coefficient α.
I.4	Training and Evaluation Setup
For evaluation, we use the first 30 videos from the DAVIS 2017 validation dataset (see Figure I.1).
Each checkpoint is evaluated by computing the average episode return over 100 episodes from the
unseen environments. All experiments are performed with five random seeds per task used to compute
means and standard deviations/errors of their evaluations. We use K = 2, M = 2 as prescribed by
Kostrikov et al. (2020) for DrQ. Following Kostrikov et al. (2020) and Stone et al. (2021), we use a
different action repeat hyper-parameter for each task, which we summarize in Table I.3. We construct
an observational input as a 3-stack of consecutive frames (Kostrikov et al., 2020), where each frame
is an RGB rendering of size 84 × 84 from the 0th camera. We then divide each pixel by 255 to scale
it down to [0, 1] range. For data augmentation, we maintain temporal consistency by using the same
crop augmentation across consecutive frames.
Table I.1: Optimal hyperparameters for PSE auxiliary loss for reporting results in Table 3.
Hyperparameter	Setting
Contrastive temperature (1∕λ)	0.1
Auxiliary loss coefficient (α)	1.0
Γ-scale parameter (β)	0.1
Batch Size (LCME)	128
∣τχ I	1000 // Action Repeat
27
Published as a conference paper at ICLR 2021
Table I.2: Hyper-parameters taken from Kostrikov et al. (2020) in the Distracting Control Suite experiments.
Parameter	Setting
Replay buffer capacity	100, 000
Seed steps	1, 000
Batch size (DrQ)	512
Discount γ	0.99
Optimizer	Adam
Learning rate	10-3
Critic target update frequency	2
Critic Q-function soft-update rate τ	0.01
Actor update frequency	2
Actor log stddev bounds	[-10, 2]
Init temperature	0.1
Table I.3: The action repeat hyper-parameter used for each task in the Distracting Control Suite benchmark.
Task name	Action repeat
Cartpole Swingup	8
Reacher Easy	4
Cheetah Run	4
Finger Spin	2
Ball In Cup Catch	4
Walker Walk	2
I.5	Generalization Curves
----DrQ + PSEs -------- DrQ
0.0	0.1	0.2	0.3	0.4	0.5
0.0	0.1	0.2	0.3	0.4	0.5
o.o o.ι
0.2	0.3	0.4	0.5
Environment Steps (×106)
UJrU①B ①Pos_d山
0.0	0.1	0.2	0.3	0.4	0.5
Environment Steps (× 106)
Environment Steps (×106)
0.0	0.1	0.2	0.3	0.4	0.5
Environment Steps (×106)
0.0	0.1	0.2	0.3	0.4	0.5
Environment Steps (×106)
Figure I.2:	Random Initialization. Generalization performance on unseen environments over the course of
training. The agent is initialized randomly. DrQ augmented with PSEs outperforms DrQ. We plot the average
episode return across 5 seeds and the shaded region shows the standard deviation. Each checkpoint is evaluated
using 100 episodes with unseen backgrounds.
28
Published as a conference paper at ICLR 2021
Environment Steps (×106)
Environment Steps (×106)
Environment Steps (×106)
Environment Steps (×106)
Environment Steps (×106)
Environment Steps (×106)
Figure I.3:	Pretrained Initialization. Generalization performance on unseen environments over the course of
training. The agent is initialized using a pretrained DrQ agent. DrQ augmented with PSEs outperforms DrQ on
most of the environments. We plot the average return across 5 seeds and the shaded region shows the standard
deviation. Each checkpoint is evaluated using 100 episodes with unseen backgrounds.
J Pseudo code
J.1 Dynamic Programming for Computing PSM
1	def metric fixed_point(cost matrix, gamma=0.99, eps=1e-7):
2	"""Dp for calculating PSM in environments with deterministic dynamics.
3
4	Args:
5	cost_matrix: DIST matrix where entries at index (i, j) is DIST(X_i,
y_j)
6	gamma: Metric discount factor.
7	eps: Threshold for stopping the fixed point iteration.
8	"""
9	d = np.zeros_like(CoSt_matrix)
io	def OperatOr (d_cur):
d_new = 1 * cost_matrix
12	discounted_d_Cur = gamma * d_cur
d_new[:-1, :-1] += discounted_d_cur[1:, 1:]
d_new[:-1, -1] += discounted_d_cur[1:, -1]
d_new[-1, :-1] += discounted_d_cur[-1, 1:]
16	return d_new
17
18	while True:
d_new = operator(d)
if np.sum(np.abs(d - d_new)) < eps:
21	break
22	else:
d = d_new[:]
24 return d
J.2 Contrastive Loss
1	def COntraStive_loss(similarity_matrix,
2	metric_values,
3	temperature,
29
Published as a conference paper at ICLR 2021
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
beta=1.0):
"""Contrative Loss with embedding similarity ."""
metric_shape = tf.shape(metriJvalues)
#	# z_\theta(X) : embedding」= nn_model. representation (X)
#	# z_\theta(Y) : embedding_2 = nn_model. representation(Y)
#	# Similarity_matrix = cosine_Similarity(embedding」， embedding_2
#	# metric_values = PSM(X, Y)
Similarity_matrix /= temperature
neg_logits1 = Similarity_matrix
col_indices = tf.cast(tf.argmin(metriJvalues, axis=1), dtype=tf.int32)
pos_indices1 = tf.stack(
(tf.range(metriJShape[0], dtype=tf.int32), col_indices), axis=1)
pos_logits1 = tf.gather_nd(similarity_matrix, pos_indices1)
metric_values /= beta
Similarity_measure = tf.exp(-metriJvalueS)
pos_weights1 = -tf.gather_nd(metriJvalues, pos_indices1)
pos_logits1 += pos_weights1
negative_WeightS = tf.math.log((1.0 - Similarity_measure) + 1e-8)
neg_logits1 += tf.tensor_Scatter_nd_update(
negative_Weights, pos_indices1, pos_weights1)
neg_logits1 = tf.math.reduce_logsumexp(neg_logits1, axis=1)
return tf.reduce_mean(neg_logits1 - pos_logits1) # Equation 4
a
30