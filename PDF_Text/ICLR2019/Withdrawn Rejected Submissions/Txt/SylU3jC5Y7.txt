Under review as a conference paper at ICLR 2019
Adaptive Network Sparsification via Depen-
dent Variational Beta-Bernoulli Dropout
Anonymous authors
Paper under double-blind review
Ab stract
While variational dropout approaches have been shown to be effective for network
sparsification, they are still suboptimal in the sense that they set the dropout rate for
each neuron without consideration of the input data. With such input-independent
dropout, each neuron is evolved to be generic across inputs, which makes it difficult
to sparsify networks without accuracy loss. To overcome this limitation, we propose
adaptive variational dropout whose probabilities are drawn from sparsity-inducing
beta-Bernoulli prior. It allows each neuron to be evolved either to be generic or
specific for certain inputs, or dropped altogether. Such input-adaptive sparsity-
inducing dropout allows the resulting network to tolerate larger degree of sparsity
without losing its expressive power by removing redundancies among features.
We validate our dependent variational beta-Bernoulli dropout on multiple public
datasets, on which it obtains significantly more compact networks than baseline
methods, with consistent accuracy improvements over the base networks.
1	Introduction
One of the main obstacles in applying deep learning to large-scale problems and low-power com-
puting systems is the large number of network parameters, as it can lead to excessive memory and
computational overheads. To tackle this problem, researchers have explored network sparsification
methods to remove unnecessary connections in a network, which is implementable either by weight
pruning (Han et al., 2016) or sparsity-inducing regularizations Wen et al. (2016).
Recently, variational Bayesian approaches have shown to be useful for network sparsification,
outperforming non-Bayesian counterparts. They take a completely different approach from the
conventional methods that either uses thresholding or sparsity-inducing norms on parameters, and
uses well-known dropout regularization instead. Specifically, these approaches use variational
dropout Kingma et al. (2015) which adds in multiplicative stochastic noise to each neuron, as a means
of obtaining sparse neural networks. Removal of unnecessary neurons could be done by either setting
the dropout rate individually for each neuron with unbounded dropout rate Molchanov et al. (2017)
or by pruning based on the signal-to-noise ratio Neklyudov et al. (2017).
While these variational dropout approaches do yield compact networks, they are suboptimal in that
the dropout rate for each neuron is learned completely independently of the given input data and
labels. With input-independent dropout regularization, each neuron has no choice but to encode
generic information for all possible inputs, since it does not know what input and tasks it will be given
at evaluation time, as each neuron will be retained with fixed rate regardless of the input. Obtaining
high degree of sparsity in such as setting will be difficult as dropping any of the neurons will result in
information loss. For maximal utilization of the network capacity and thus to obtain a more compact
model, however, each neuron should be either irreplaceably generic and used by all tasks, or highly
specialized for a task such that there exists minimal redundancy among the learned representations.
This goal can be achieved by adaptively setting the dropout probability for each input, such that some
of the neurons are retained with high probability only for certain types of inputs and tasks.
To this end, we propose a novel input-dependent variational dropout regularization for data and
task-dependent network sparsification. We first propose beta-Bernoulli dropout that learns to set
dropout rate for each individual neuron, by generating the dropout mask from beta-Bernoulli prior,
and show how to train it using variational inference. This dropout regularization is a proper way of
obtaining a Bayesian neural network and also sparsifies the network, since beta-Bernoulli distribution
1
Under review as a conference paper at ICLR 2019
is a sparsity-inducing prior. Then, we propose dependent beta-Bernoulli dropout, which is an
input-dependent version of our variational dropout regularization.
Such adaptive regularization has been utilized for general network regularization by a non-Bayesian
and non-sparsity-inducing model Ba & Frey (2013); yet, the increased memory and computational
overheads that come from learning additional weights for dropout mask generation made it less
appealing for generic network regularization. In our case of network sparsification, however, the over-
heads at training time is more than rewarded by the reduced memory and computational requirements
at evaluation time, thanks to the high degree of sparsification obtained in the final output model.
We validate our dependent beta-Bernoulli variational dropout regularizer on multiple public datasets
for network sparsification performance and prediction error, on which it obtains more compact
network with substantially reduced prediction errors, when compared with both the base network and
existing network sparsification methods. Further analysis of the learned dropout probability for each
unit reveals that our input-adaptive variational dropout approach generates a clearly distinguishable
dropout mask for each task, thus enables each task to utilize different sets of neurons for their
specialization.
Our contribution in this paper is threefold:
•	We propose beta-Bernoulli dropout, a novel dropout regularizer which learns to generate
Bernoulli dropout mask for each neuron with sparsity-inducing prior, that obtains high
degree of sparsity without accuracy loss.
•	We further propose dependent beta-Bernoulli dropout, which yields significantly more
compact network than input-independent beta-Bernoulli dropout, and further perform run-
time pruning for even less computational cost.
•	Our beta-Bernoulli dropout regularizations provide novel ways to implement a sparse
Bayesian Neural Network, and we provide a variational inference framework for learning it.
2	Related Work
Deep neural networks are known to be prone to overfitting, due to its large number of parameters.
Dropout Srivastava et al. (2014) is an effective regularization that helps prevent overfitting by reducing
coadaptations of the units in the networks. During dropout training, the hidden units in the networks
are randomly dropped with fixed probability p, which is equivalent to multiplying the Bernoulli
noises Z 〜Ber(1 - P) to the units. It was later found that multiplying Gaussian noises with the same
mean and variance, Z 〜N(1, I-Ep), works just as well or even better Srivastava et al. (2014).
Dropout regularizations generally treat the dropout rate p as a hyperparameter to be tuned, but there
have been several studies that aim to automatically determine proper dropout rate. Kingma et al.
(2015) propose to determine the variance of the Gaussian dropout by stochastic gradient variational
Bayes. Generalized dropout Srinivas & Babu (2016) places a beta prior on the dropout rate and
learn the posterior of the dropout rate through variational Bayes. They showed that by adjusting
the hyperparameters of the beta prior, we can obtain several regularization algorithms with different
characteristics. Our beta-Bernoulli dropout is similar to one of its special cases, but while they obtain
the dropout estimates via point-estimates and compute the gradients of the binary random variables
with biased heuristics, we approximate the posterior distribution of the dropout rate with variational
distributions and compute asymptotically unbiased gradients for the binary random variables.
Ba et al. Ba & Frey (2013) proposed adaptive dropout (StandOut), where the dropout rates for each
individual neurons are determined as function of inputs. This idea is similar in spirit to our dependent
beta-Bernoulli dropout, but they use heuristics to model this function, while we use proper variational
Bayesian approach to obtain the dropout rates. One drawback of their model is the increased memory
and computational cost from additional parameters introduced for dropout mask generation, which is
not negligible when the network is large. Our model also requires additional parameters, but with our
model the increased cost at training time is rewarded at evaluation time, as it yields a significantly
sparse network than the baseline model as an effect of the sparsity-inducing prior.
Recently, there has been growing interest in structure learning or sparsification of deep neural
networks. Han et al. Han et al. (2016) proposed a strategy to iteratively prune weak network weights
for efficient computations, and Wen et al. Wen et al. (2016) proposed a group sparsity learning
2
Under review as a conference paper at ICLR 2019
algorithm to drop neurons, filters or even residual blocks in deep neural networks. In Bayesian
learning, various sparsity inducing priors have been demonstrated to efficiently prune network
weights with little drop in accuracies Molchanov et al. (2017); Louizos et al. (2017); Neklyudov
et al. (2017); Louizos et al. (2018). In the nonparametric Bayesian perspective, Feng et al. Feng &
Darrell (2015) proposed IBP based algorithm that learns proper number of channels in convolutional
neural networks using the asymptotic small-variance limit approximation of the IBP. While our
dropout regularizer is motivated by IBP as with this work, our work is differentiated from it by the
input-adaptive adjustments of dropout rates that allow each neuron to specialize into features specific
for some subsets of tasks.
3	Backgrounds
3.1	Bayesian Neural Networks and Stochastic Gradient Variational Bayes
Suppose that we are given a neural network f(x; W) parametrized by W, a training set D =
{(xn, yn)}nN=1, and a likelihoodp(y|f(x; W)) chosen according to the problem of interest (e.g., the
categorical distribution for a classification task). In Bayesian neural networks, the parameter W is
treated as a random variable drawn from a pre-specified prior distribution p(W), and the goal of
learning is to compute the posterior distribution p(W|D):
N
p(W∣D) (X P(W) Y p(yn∣f(Xn； W)).	(1)
n=1
When a novel input x* is given, the prediction y* is obtained as a distribution, by mixing W from
p(W|D) as follows:
p(y* |x*, D) =	p(y* |f(x*； W))p(W|D)dW.	(2)
Unfortunately, p(W|D) is in general computationally intractable due to computing p(D), and thus
we resort to approximate inference schemes. Specifically, we use variational Bayes (VB), where we
posit a variational distribution q(W； φ) of known parametric form and minimize the KL-divergence
between it and the true posterior p(W∣D), DκL[q(W; φ)kp(W∣D)]. It turns out that minimizing
DKL [q(W； φ) ∣∣p(W∣D)] is^equivalent to maximizing the evidence lower-bound (ELBO),
L(φ) =XEq[logp(yn|f(xn；W))] - DKL[q(W； φ)kp(W)],	(3)
n=1
where the first term measures the expected log-likelihood of the dataset w.r.t. q(W； φ), and the
second term regularizes q(W； φ) so that it does not deviate too much from the prior. The pa-
rameter φ is learned by gradient descent, but these involves two challenges. First, the expected
likelihood is intractable in many cases, and so is its gradient. To resolve this, we assume that
q(W； φ) is reparametrizable, so that we can obtain i.i.d. samples from q(W； φ) by computing
differentiable transformation of i.i.d. noise (Kingma & Welling, 2014; Rezende et al., 2014) as
ε(S)〜 r(ε), W(S) = T(ε(s); φ). Then we can obtain a low-variance unbiased estimator of the
gradient, namely
1
VφEq[logp(yn∣f(Xn； W))] ≈ S	φlogp(yn∣f(xn,T(ε⑶;φ))).	(4)
S=1
The second challenge is that the number of training instances N may be too large, which makes
it impossible to compute the summation of all expected log-likelihood terms. Regarding on this
challenge, we employ the stochastic gradient descent technique where we approximate with the
summation over a uniformly sampled mini-batch B,
NN
£ VφEq [log p(yn |f (Xn； W))] ≈ 面 E VφEq [log p(yn∣f (Xn； W))].	⑸
n=1	n∈B
Combining the reparametrization and the mini-batch sampling, we obtain an unbiased estimator
of VφL(φ) to update φ. This procedure, often referred to as stochastic gradient variational Bayes
(SGVB) Kingma & Welling (2014), is guaranteed to converge to local optima under proper learning-
rate scheduling.
3
Under review as a conference paper at ICLR 2019
3.2	Latent feature models and Indian Buffet Processes
In latent feature model, data are assumed to be generated as combinations of latent features:
dn=f(Wzn)=fkXK=1zn,kwk,	(6)
where zn,k = 1 means that dn possesses the k-th feature wk, and f is an arbitrary function.
The Indian Buffet Process (IBP) Griffiths & Ghahramani (2005) is a generative process of binary
matrices with infinite number of columns. Given N data points, IBP generates a binary matrix
Z ∈ {0, 1}N×K whose n-th row encodes the feature indicator zn>. The IBP is suitable to use as a
prior process in latent feature models, since it generates possibly infinite number of columns and
adaptively adjust the number of features on given dataset. Hence, with an IBP prior we need not
specify the number of features in advance.
One interesting observation is that while it is a marginal of the beta-Bernoulli processes (Thibaux &
Jordan, 2007), the IBP may also be understood as a limit of the finite-dimensional beta-Bernoulli
process. More specifically, the IBP with parameter α > 0 can be obtained as
∏k 〜beta(α∕K, 1),	z%k 〜Ber(∏k), K →∞.	(7)
This beta-Bernoulli process naturally induces sparsity in the latent feature allocation matrix Z. As
K → ∞, the expected number of nonzero entries in Z converges to Nα (Griffiths & Ghahramani,
2005) , where α is a hyperparameter to control the overall sparsity level of Z.
In this paper, we relate the latent feature models (6) to neural networks with dropout mask. Specif-
ically, the binary random variables zn,k correspond to the dropout indicator, and the features w
correspond to the inputs or intermediate units in neural networks. From this connection, we can
think of a hierarchical Bayesian model where we place the IBP, or finite-dimensional beta-Bernoulli
priors for the binary dropout indicators. We expect that due to the property of the IBP favoring sparse
model, the resulting neural network would also be sparse.
3.3	Dependent Indian Buffet Processes
One important assumption in the IBP is that features are exchangeable - the distribution is invariant
to the permutation of feature assignments. This assumption makes the posterior inference convenient,
but restricts flexibility when we want to model the dependency of feature assignments to the input
covariates x, such as times or spatial locations. To this end, Williamson et al. Williamson et al. (2010)
proposed dependent Indian Buffet processes (dIBP), which triggered a line of follow-up work (Zhou
et al., 2011; Ren et al., 2011). These models can be summarized as following generative process:
π 〜p(π) z∣π, X 〜 Ber(g(π, x)),	(8)
where g(∙, ∙) is an arbitrary function that maps π and X to a probability. In our latent feature
interpretation for neural network layers above, the input covariates X corresponds to the input or
activations in the previous layer. In other words, we build a data-dependent dropout model where the
dropout rates depend on the inputs. In the main contribution section, we will further explain how we
will construct this data-dependent dropout layers in detail.
4 Main contribution
4.1	Variational B eta-B ernoulli dropout
Inspired by the latent-feature model interpretation of layers in neural networks, we propose a Bayesian
neural network layer overlaid with binary random masks sampled from the finite-dimensional beta-
Bernoulli prior. Specifically, let W be a parameter of a neural network layer, and let zn ∈ {0, 1}K
be a binary mask vector to be applied for the n-th observation Xn . The dimension of W needs not be
equal to K. Instead, we may enforce arbitrary group sparsity by sharing the binary masks among
multiple elements of W. For instance, let W ∈ RK ×L×M be a parameter tensor in a convolutional
neural network with K channels. To enforce a channel-wise sparsity, we introduce zn ∈ {0, 1}K of
4
Under review as a conference paper at ICLR 2019
K dimension, and the resulting masked parameter Wn for the n-th observation is given as
{zn,k Wk,',m | (k,', m) = (1,1,1),..., (K, L, M)},	(9)
where Wk,',m is the (k,', m)-th element of W. From now on, with a slight abuse of notation, We
denote this binary mask multiplication as
___
Wn = Zn 0 W,	(10)
with appropriate sharing of binary mask random variables. The generative process of our Bayesian
neural network is then described as
KK
W 〜N(0,λI), π 〜ɪɪ beta(∏k; α∕K, 1), Zn∣π 〜ɪɪ Ber(z%k； ∏k), Wn = Zn 0 W.
k=1	k=1
(11)
Note the difference between our model and the model in Gal & Ghahramani (2016). In Gal &
Ghahramani (2016), only Gaussian prior is placed on the parameter W, and the dropout is applied in
the variational distribution q(W) to approximate p(W|D). Our model, on the other hand, includes
the binary mask Zn in the prior, and the posterior for the binary masks should also be approximated.
The goal of the posterior inference is to compute the posterior distribution p(W, Z, π∣D), where
Z = {Z1, . . . , ZN}. We approximate this posterior with the variational distribution of the form
K	NK
q(W, Z, ∏X) = δw(W) Y q(∏k) Y Y q(zn,k ∣∏k),	(12)
k=1	n=1 k=1
where we omitted the indices of layers for simplicity. For W, we conduct computationally efficient
point-estimate to get the single value Wc , with the weight-decay regularization arising from the
zero-mean Gaussian prior. For π, following Nalisnick & Smyth (2017), we use the Kumaraswamy
distribution (Kumaraswamy, 1980) for q(πk):
q(πk; ak, bk) = akbkπkak-1 (1 - πkak )bk-1,	(13)
since it closely resembles the beta distribution and easily reparametrizable as
1	1
∏k(u; a，k,bk) = (1 — Ubk )ak , U 〜unif([0,1]).	(14)
We further assume that q(zn,k ∣∏k) = p(zn,k ∣∏k) = Ber(∏k). Zk is sampled by reparametrization
with continuous relaxation (Maddison et al., 2017; Jang et al., 2017; Gal et al., 2017),
(15)
where T is a temperature of continuous relaxation, U 〜unif([0,1]), and Sgm(X) = ɪ+三.The
KL-divergence between the prior and the variational distribution is then obtained in closed form as
follows (Nalisnick & Smyth, 2017):
DKL[qZn) kp(Z,以=X (aka-α (-γ - ψSk) - bk) +iog akbk - bkb-ɪ),	(16)
where Y is Euler-Mascheroni constant and Ψ(∙) is the digamma function. Note that the infinite series
in the KL-divergence vanishes because of the choice p(πk) = beta(πk; α∕K, 1).
We can apply the SGVB framework described in Section 3.1 to optimize the variational parameters
{ak, bk}K=ι. After the training, the prediction for a novel input x* is given as
p(y*∣x*, D, W) = Ep(z*,∏,w∣D)[p(y*∣f(x*；z* 0 W))] ≈ Eq(z*,∏)[p(y*∣f(x*;z* 0 W))], (17)
and we found that the following naive approximation works well in practice,
p(y∕x*, D, W) ≈ p(y* |f (x*; Eq[z∕ Z W)),	(18)
where
Eq[z*,k ] = Eq(∏k )[∏k], Eq(∏k) [∏k ]=怨Ebk) ∙	(19)
k	k	Γ(1 + ak- + bk )
5
Under review as a conference paper at ICLR 2019
Figure 1: An example to show the intuition behind Eq (21). Each block represents a histogram of
output distribution. A set of activations (1st block) are standardized (2nd block), and rescaled and
shifted (3rd block), and transformed into probabilities (4th block).
4.2 Variational Dependent Beta-Bernoulli Dropout
Now we describe our Bayesian neural network model with input dependent beta-Bernoulli dropout
prior constructed as follows:
KK
W 〜N(0,λI), π 〜Y beta(∏k; α∕K, 1), Zn∣π, Xn 〜Y Ber(zn,k;夕k(x%k)),	(20)
k=1	k=1
Here, xn is the input to the dropout layer. For convolutional layers, we apply the global average
pooling to tensors to get vectorized inputs. In principle, we may introduce another fully connected
layer as (夕 1(χn,1),...,夕 K (χn,κ)) = Sgm(VXn + c), With additional parameters V ∈ Rk×k and
c ∈ RK, but this is undesirable for the network sparsification. Rather than adding parameters for fully
connected layer, We propose simple yet effective Way to generate input-dependent probability, With
minimal parameters involved. Specifically, We construct each πk (xn,k) independently as folloWs:
Wk (xn,k) = ∏k min (l - e, max (e,γk W- "k + β) ),	(21)
where μk and σk are the estimates of k-th components of mean and standard deviation of inputs,
and γk and βk are scaling and shifting parameters to be learned, and e > 0 is some small tolerance
to prevent overflow. The parameterization in (21) is motivated by the batch normalization (Ioffe
& Szegedy, 2015). The intuition behind this construction is as follows. The inputs after the
standardization would approximately be distributed as N (0, 1), and thus would be centered around
zero. If we pass them through max(e, min(1 - e)), most of insignificant dimensions would have
probability close to zero. However, some inputs may be important regardless of the significance of
current activation. In that case, we expect the corresponding shifting parameter βk to be large. Thus
by β = (β1 , . . . , βK ) we control the overall sparsity, but we want them to be small unless required
to get sparse outcomes. We enforce this by placing a prior distribution on β 〜N(0, ρI).
The goal of variational inference is hence to learn the posterior distribution p(W, Z, π, β∣D), and
we approximate this with variational distribution of the form
K	NK
q(W, Z, ∏, β∣X) = δw(W) Y q(∏k)q(βk) YY
q(zn,k∣∏k, Xn),	(22)
k=1	n=1 k=1
where q(∏k) are the same as in beta-Bernoulli dropout, q(βk) = N(βk; ηk, Kk), and q(zn,k∖∏k)=
p(zn,k∖∏k, Xn) 1 The KL-divergence is computed as
DKL[q(Z, π∖X)kp(Z, π)] + DKL[q(β)kp(β)],	(23)
where the first term was described for beta-Bernoulli dropout and the second term can be computed
analytically.
The prediction for the novel input x* is similarity done as in the beta-Bernoulli dropout, with the
naive approximation for the expectation:
p(y*∣x*, D, W) ≈ p(y*∣f (x*; Eq[z*]③ W)),	(24)
1 In principle, we may introduce an inference network q(z∣π, x, y) and minimizes the KL-divergence
between q(z∣π, x, y) and p(z∣π, x), but this results in discrepancy between training and testing for sampling z,
and also make optimization cumbersome. Hence, we chose to simply set them equal. Please refer to Sohn et al.
(2015) for discussion about this.
6
Under review as a conference paper at ICLR 2019
Table 1: Results for LeNet-500-300 and LeNet5-Caffe on MNIST. Error and Memory are in %.
LeNet 500-300					LeNet5-Caffe			
	Error	Neurons	Speedup	Memory	Error	Neurons/Filters	Speedup	Memory
Original	1.56	784-500-300	1.0	100.0	0.7	20-50-800-500	1.0	100.0
SSL	2.30± 0.09	404-32-22	39.13	2.55	0.97 ± 0.06	6-8-107-10	12.74	10.97
SVD	1.50 ± 0.04	532-64-35	14.73	6.78	0.72 ± 0.01	10-16-238-29	5.18	13.97
SBP	1.59 ± 0.05	255-100-43	17.91	5.57	0.74 ± 0.02	10-18-128-38	4.81	13.75
BB	1.34 ± 0.04	294-110-71	13.26	7.52	0.57 ± 0.01	13-25-156-54	2.94	16.2
DBB	1.38 ± 0.07	106-56-46	33.51	0.98	0.63 ± 0.02	13-24-53-27	2.95	14.79
VIB	1.48 ± 0.07	139-101-28	31.39	3.17	0.71 ± 0.02	12-18-82-34	4.02	14.35
GD	1.54 ± 0.04	488-142-136	6.04	16.54	0.66 ± 0.03	14-29-368-174	2.36	28.15
where
Eq[z*,k] = Eq[∏k] min(1 - 3 max(3 Yk xn'； "k + ηk
(25)
Two stage pruning scheme Since πk ≥ πk(xn,k) for all xn,k, we expect the resulting network to
be sparser than the network pruned only with the beta-Bernoulli dropout (only with πk). To achieve
this, we propose a two-stage pruning scheme, where we first prune the network with beta-Bernoulli
dropout, and prune the network again with πk(xn,k) while holding the variables π fixed. By fixing π
the resulting network is guaranteed to be sparser than the network before the second pruning.
5 Experiments
We now compare our beta-Bernoulli dropout (BB) and input-dependent beta-Bernoulli dropout (DBB)
to other structure learning/pruning algorithms on several neural networks using benchmark datasets.
Experiment Settings We followed a common setting to compare pruning algorithms by using
LeNet 500-300, LeNet 5-Caffe 2 3, and VGG-like (Zagoruyko, 2015) networks on MNIST LeCun
et al. (1998), CIFAR-10, and CIFAR-100 datasets (Krizhevsky & Hinton, 2009). We included
recent Bayesian pruning methods for a fair comparison: sparse variational dropout (SVD Molchanov
et al. (2017)), structured sparsity learning (SSL Wen et al. (2016)) and structured Bayesian pruning
(SBP Neklyudov et al. (2017)), variational information bottleneck (VIB Dai et al. (2018)), and
generalized dropout (GD Srinivas & Babu (2016)). We faithfully tuned all hyperparameters of
baselines on a validation set to find a reasonable solution that is well balanced between accuracy and
sparsification, while fixing batch size (100) and the number of maximum epochs (200) to match our
experiment setting.
Implementation Details We pretrained all networks using the standard training procedure before
fine-tuning for network sparsification Molchanov et al. (2017); Neklyudov et al. (2017). While
pruning, we set the learning rate for the weights W to be 0.1 times smaller than those for the
variational parameters as in Neklyudov et al. (2017). We used Adam (Kingma & Ba, 2015) for all
methods. For DBB, as mentioned in Section 4.2, we first prune networks with BB, and then prune
again with DBB whiling holding the variational parameters for q(π) fixed.
We report all hyperparameters of BB and DBB for reproducing our results. Weset α∕K = 10-4 for
all layers of BB and DBB. In principle, we may fix K to be large number and tune α. However, in
the network sparsification tasks, K is given as the neurons/filters to be pruned. Hence, we chose to
set the ratio a/K to be small number altogether. In the testing phase, We pruned the neurons/filters
whose expected dropout mask probability Eq[πk] are smaller than a filxed threshold 10-33. For the
input-dependent dropout, since the number of pruned neurons/filters differ according to the inputs,
we report them as the running average over the test data. We fixed the temperature parameter of
concrete distribution T = 10-1 and the prior variance of β, P = √5 for all experiments.
2https://github.com/BVLC/caffe/blob/master/examples/mnist
3We tried different values such as 10-2 or 10-4, but the difference was insignificant.
7
Under review as a conference paper at ICLR 2019
Table 2: Classification accuracy and sparsification performance of various pruning methods on CIFAR-10 and
CIFAR-100 datasets. Error and Memory are in %.
CIFAR-10				
		Error	Filters/Neurons	Speedup Memory	
Original	7.43	64-64-128-128-256-256-256-512-512-512-512-512-512-512-512	1.00	100.0
SSL	8.27 ± 0.11	64-62-128-115-241-113-32-63-53-12-89-52-250-250-442	1.67	14.78
SVD	7.85 ± 0.08	64-64-128-128-254-209-54-107-102-14-162-121-356-386-490	1.41	21.18
SBP	7.27 ± 0.06	64-64-128-128-254-209-55-107-100-14-155-125-98-92-353	1.41	18.546
BB	6.66 ± 0.11	64-64-128-126-251-174-41-89-81-13-118-108-23-23-68	1.49	16.09
DBB	7.03 ± 0.16	63 -61-126-122-236-131-36-64-65-11-93-93-17-18-48	1.54	14.08
VIB	7.17 ± 0.16	57-63-119-118-206-135-38-59-54-13-86-90-9-9-45	1.78	12.93
GD	7.26 ± 0.15	64-64-128-128-254-207-53-105-103-15-161-125-376-340-366	1.41	20.97
	CIFAR-100					
	Error	Filters	Speedup Memory	
Original	-31.46%-	64-64-128-128-256-256-256-512-512-512-512-512-512-512-512	1.0	100.0
SSL	32.75±0.16	62-64-128-128-255-254-135-187-98-22-212-156-512-512-512	1.28	28.24
SVD	31.26 ±0.06	64-64-128-128-255-255-135-238-173-26-343-268-512-512-512	1.25	36.77
SBP	30.56 ± 0.03	64-64-128-128-255-255-135-238-173-26-345-270-450-429-512	1.25	35.74
BB	29.27 ± 0.27	64-64-128-128-255-255-134-213-152-25-268-256-47-47-194	1.26	26.15
DBB	28.85 ± 0.06	63-63-126-126-245-234-129-167-124-22-223-227-35-36-104-105	1.29	22.64
VIB	29.87 ± 0.19	62-64-128-127-252-239-129-204-115-23-210-196-26-26-154	1.31	22.74
GD	30.54 ± 0.23	64-64-128-128-253-245-115-214-164-26-320-254-415-364-434	1.29	32.42
Figure 2: Parts of g(x) in 3rd, 8th, 15th layer of VGG network for CIFAR-100, w.r.t. different inputs.
5.1	Experiments on MNIST dataset
We used LeNet 500-300 and LeNet 5-Caffe networks on MNIST for comparison. Following the
conventions, we applied dropout to the inputs to the fully connected layers and right after the
convolution for the convolutional layers. We report the results with basic settings in Table 1. Please
refer to the appendix where we presented various results to highlight the tradeoff between sparsity
and accuracy (Table 3). For both neworks, BB and DBB achieved significantly higher accuracy than
ther methods. On LeNet-500-300, DBB pruned large amount of neurons in the input layer, because
the inputs to this network are simply vectorized pixel values, so it can prune the inputs according
to the digit classes (Fig. 3). Also, we found that the dropout masks generated by DBB tend to be
generic at lower network layers to extract common features, but become class-specific at higher
layers to specialize features for class discriminativity. See the appendix for the additional results on
LeNet-5-Caffe showing this tendency (Fig. 3).
5.2	Experiments on CIFAR- 1 0 and CIFAR- 1 00 datasets
We compared the pruning algorithms on VGG-like network adapted for CIFAR-10 and CIFAR-100
datasets. Table 2 summarizes the performance of each algorithm on particular setting, where BB
and DBB achieved impressive sparsity with significantly improved accuracy. Further analysis of
the filters retained by DBB in Fig. 2 shows that DBB either retains most filters (layer 3) or perform
generic pruning (layer 8) at lower layers, while performing diversified pruning at higher layers (layer
15). Further, at layer 15, instances from the same class retained similar filters, while instances from
different classes retained different filters. Please refer to the appendix, where we presented tradeoff
between accuracy and sparsity with various settings (Table 4).
6 Conclusion
We have proposed novel beta-Bernoulli dropout for network regularization and sparsification, where
we learn dropout probabilities for each neuron either in an input-independent or input-dependent
8
Under review as a conference paper at ICLR 2019
manner. Our beta-Bernoulli dropout learns the distribution of sparse Bernoulli dropout mask for each
neuron in a variational inference framework, in contrast to existing work that learned the distribution of
Gaussian multiplicative noise or weights, and obtains significantly more compact network compared
to those competing approaches. Further, our dependent beta-Bernoulli dropout that input-adaptively
decides which neuron to drop further improves on the input-independent beta-Bernoulli dropout, both
in terms of size of the final network obtained and run-time computations.
References
J. Ba and B. Frey. Adaptive dropout for training deep neural networks. In Advances in Neural
Information Processing Systems 26, 2013.
Bin Dai, Chen Zhou, and David Wipf. Compressing neural networks using the variational information
bottleneck. arXiv:1802.10399, 2018.
J. Feng and T. Darrell. Learning the structure of deep convolutional networks. IEEE International
Conference on Computer Vision, 2015.
Y. Gal and Z. Ghahramani. Dropout as a Bayesian approximation: representing model uncertainty in
deep learning. In Proceedings of the 33rd International Conference on Machine Learning, 2016.
Y. Gal, J. Hron, and A. Kendall. Concrete dropout. Advances in Neural Information Processing
Systems, 2017.
T. L. Griffiths and Z. Ghahramani. Infinite latent feature models and the Indian buffet process. In
NIPS, 2005.
S. Han, H. Mao, and W. J. Dally. Deep compression: compressing deep neural networks with pruning,
trained quantization and Huffman coding. In Proceedings of the International Conference on
Learning Representations, 2016.
S. Ioffe and C. Szegedy. Batch normalization: accelerating deep network training by reducing internal
covariate shift. In Proceedings of the 32nd International Conference on Machine Learning, 2015.
E. Jang, S. Gu, and B. Poole. Categorical reparametrization with Gumbel-softmax. In Proceedings of
the International Conference on Learning Representations, 2017.
D. P. Kingma and J. L. Ba. Adam: A method for stochastic optimization. In Proceedings of the
International Conference on Learning Representations, 2015.
D. P. Kingma and M. Welling. Auto-encoding variational Bayes. In Proceedings of the International
Conference on Learning Representations, 2014.
D. P. Kingma, T. Salimans, and M. Welling. Variational dropout and the local reparametrization trick.
In Advances in Neural Information Processing Systems 28, 2015.
Alex Krizhevsky and Geoffrey E. Hinton. Learning multiple layers of features from tiny images.
Technical report, Computer Science Department, University of Toronto, 2009.
Ponnambalam Kumaraswamy. A generalized probability density function for double-bounded random
processes. Journal of Hydrology, 1980.
Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document
recognition. Proceedings ofthe IEEE, 86(11):2278-2324,1998.
C. Louizos, K. Ullrich, and M. Welling. Bayesian compression for deep learning. Advances in Neural
Information Processing Systems, 2017.
C.	Louizos, M. Welling, and D. P. Kingma. Learning sparse neural networks through L0 regularization.
International Conference on Learning Representations, 2018.
C.	J. Maddison, A. Mnih, and Y. W. Teh. The concrete distribution: a continuous relaxation of discrete
random variables. In Proceedings of the International Conference on Learning Representations,
2017.
9
Under review as a conference paper at ICLR 2019
D.	Molchanov, A. Ashukha, and D. Vetrov. Variational dropout sparsifies deep neural networks. In
Proceedings of the 34th International Conference on Machine Learning, 2017.
E.	Nalisnick and P. Smyth. Stick-breaking variational autoencoders. In Proceedings of the Interna-
tional Conference on Learning Representations, 2017.
K.	Neklyudov, D. Molchanov, A. Ashukha, and D. Vetrov. Structured Bayesian pruning via log-
normal multiplicative noise. Advances in Neural Information Processing Systems, 2017.
L.	Ren, Y. Wang, D. B. Dunson, and L. Carin. The kernel beta process. In Advances in Neural
Information Processing Systems 24, 2011.
D. J. Rezende, S. Mohamed, and D. Wierstra. Stochastic backpropagation and approximate inference
in deep generative models. In Proceedings of the 31st International Conference on Machine
Learning, 2014.
K. Sohn, H. Lee, and X. Yan. Learning structured ouput representation using deep conditional
generative models. Advances in Neural Information Processing Systems 28, 2015.
S. Srinivas and R. V. Babu. Generalized dropout. arXiv preprint arXiv:1611.06791, 2016.
N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov. Dropout: a simple
way to prevent neural networks from overfitting. Journal of Machine Learning Research, 15(1):
1929-1958, 2014.
R.	Thibaux and M. I. Jordan. Hierarchical beta processess and the Indian buffet processes. In
Proceedings of the 11th International Conference on Artificial Intelligence and Statistics, 2007.
W. Wen, C. Wu, Y. Wang, Y. Chen, and H. Li. Learning structured sparsity in deep neural networks.
In Advances in Neural Information Processing Systems 29, 2016.
S.	Williamson, P. Orbanz, and Z. Ghahramani. Dependent indian buffet processes. In Proceedings of
the 13th International Conference on Artificial Intelligence and Statistics, 2010.
S. Zagoruyko. 92.45 on CIFAR-10 in Torch. 2015.
M. Zhou, H. Yang, G. Sapiro, and D. B. Dunson. Dependent hierarchical beta process for image
interpolation and denoising. In Proceedings of the 14th International Conference on Artificial
Intelligence and Statistics, 2011.
10
Under review as a conference paper at ICLR 2019
Appendices
A Some qualitative results for DBB on MNIST experiments
(Fig. 3, left) shows the class average values of 夕(x) for the class 0, 3, 7, and 9. Unlike the other
pruning algorithms where the general background is pruned, DBB specifically pruned the area where
the digits present. (Fig. 3, right) shows the correlation coefficients between the class average values
of 夕(x) learnt from DBB. As we stated in the paper, it clearly show the tendency to share filters in
lower layers, and be specific in higher layers. This tendency can also be observed in the experiments
with VGG on CIFAR10 and CIFAR100.
1.0
0.8
0.6
0.4
0.2
0.0
class
0
1
2
3
4
5
6
7
8
9
dense500
class	class
Figure 3: Correlation coefficients of class averages of 夕(x) for the four layers in LeNet5-Caffe.
B Additional results on LeNet-500-300 and LeNet5 - Caffe
Table 3 shows the results of pruning algorithms with five sparsity levels. We controlled the sparsity
by tuning the initial learning rate for sparsity related variables (for instance, the learning rate
for the paramters of qg; a%,bk) for BB). For SSL, we tested five sparsity rate parameter {2 ∙
10-3,10-3, 5 ∙ 10-4,10-4,5 ∙ 10-5}, and for all the other methods we tested with initial learning
rate {5 ∙ 10-2,2 ∙ 10-2,10-2, 5 ∙ 10-3,10-3}. The results presented in the main text are the ones
with sparsity rate 5 ∙ 10-4 for SSL and initial learning rate 10-2 for all other methods. We ran all the
algorithms five times and reported mean and standard deviations.
C Additional results on VGG-like
Table 4 shows the results of pruning algorithms with four sparsity levels. We controlled the sparsity
by tuning the initial learning rate for sparsity related variables. For SSL, we tested with sparsity
rate parameter {10-3, 5 ∙ 10-4,10-4,5 ∙ 10-5}, and for all the other methods we tested with initial
learning rate {2 ∙ 10-2,10-2, 5 ∙ 10-3,10-3}. The results presented in the main text are the ones
with sparsity rate 5 ∙ 10-4 for SSL and initial learning rate 10-2 for all other methods. We ran all
three algorithms five times and reported mean and standard deviations.
11
Under review as a conference paper at ICLR 2019
Table 3: Comparision of pruning methods on LeNet-500-300 and LeNet5-Caffe with MNIST. Error
and Memory are in %.
LeNet 500-300	∣	LeNet5-Caffe
	Error	Speedup	Memory	Error	Speedup	Memory
	3.52 ± 0.12	75.69	1.32	1.44 ± 0.08	23.17	10.09
	2.63 ± 0.12	54.83	1.82	1.03 ± 0.05	20.26	10.20
SSL	2.30 ± 0.09	39.13	2.55	0.97 ± 0.06	12.74	10.97
	2.06 ± 0.13	27.68	3.61	0.84 ± 0.05	8.06	11.83
	1.93 ± 0.09	22.99	4.34	0.83 ± 0.07	6.77	12.30
	2.75 ± 0.14	21.44	4.66	1.47 ± 0.11	3.62	16.38
	1.51 ± 0.04	18.39	5.43	0.74 ± 0.04	4.92	14.05
SVD	1.50 ± 0.04	14.73	6.78	0.72 ± 0.01	5.17	14.04
	1.51 ± 0.03	11.99	8.33	0.71 ± 0.01	4.78	14.75
	1.45 ± 0.02	8.40	11.89	0.68 ± 0.02	2.92	17.95
	1.77 ± 0.04	24.81	4.01	1.06 ± 0.27	26.10	10.54
	1.70 ± 0.05	21.60	4.61	0.79 ± 0.05	4.81	13.51
SBP	1.59 ± 0.05	17.91	5.57	0.74 ± 0.02	4.81	13.75
	1.52 ± 0.03	14.76	6.75	0.76 ± 0.03	4.06	14.64
	1.51 ± 0.01	11.46	8.70	0.73 ± 0.02	2.89	16.94
	1.60 ± 0.09	30.35	3.28	0.65 ± 0.03	3.45	14.75
	1.38 ± 0.04	17.24	5.78	0.63 ± 0.03	3.38	14.94
BB	1.34 ± 0.04	13.26	7.52	0.57 ± 0.01	2.94	16.2
	1.34 ± 0.02	10.78	9.25	0.58 ± 0.04	2.72	17.43
	1.26 ± 0.03	5.08	19.68	0.63 ± 0.01	2.43	36.23
	2.01 ± 0.07	64.88	0.50	0.77 ± 0.03	4.11	12.75
	1.50 ± 0.09	43.24	0.69	0.64 ± 0.02	3.61	13.52
DBB	1.38 ± 0.07	33.51	0.98	0.63 ± 0.02	2.95	14.79
	1.32 ± 0.03	23.47	2.08	0.60 ± 0.04	2.8	15.21
	1.26 ± 0.02	5.97	14.28	0.58 ± 0.01	2.45	26.68
	2.06 ± 0.07	54.50	1.82	0.82 ± 0.07	4.52	13.74
	1.75 ± 0.08	35.80	2.78	0.77 ± 0.05	4.17	14.00
VIB	1.48 ± 0.07	31.39	3.17	0.76 ± 0.02	4.02	14.17
	1.51 ± 0.09	28.57	3.48	0.71 ± 0.04	3.87	14.35
	1.48 ± 0.03	20.33	4.90	0.65 ± 0.04	3.23	15.31
	1.66 ± 0.07	10.68	9.34	0.73 ± 0.03	2.71	18.46
	1.53 ± 0.05	8.02	12.44	0.71 ± 0.06	2.60	22.63
GD	1.54 ± 0.04	6.04	16.54	0.66 ± 0.03	2.36	28.15
	1.50 ± 0.02	4.37	22.84	0.67 ± 0.01	2.15	35.91
	1.31 ± 0.05	3.18	31.42	0.60 ± 0.02	1.92	65.78
12
Under review as a conference paper at ICLR 2019
Table 4: Comparision of pruning methods on VGG-like with CIFAR10 and CIFAR100. Error and
Memory are in %.
	VGG-CIFAR10		I	VGG-CIFAR100			
	Error	Speedup	Memory	Error	Speedup	Memory
	9.56 ± 0.09	2.09	12.01	36.27 ± 0.22	1.43	23.21
	8.27 ± 0.11	1.67	14.78	32.75 ± 0.16	1.28	28.24
SSL	7.32 ± 0.07	1.42	19.04	30.64 ± 0.06	1.25	34.44
	7.12 ± 0.16	1.41	20.30	30.45 ± 0.19	1.25	36.14
	9.71 ± 0.18	1.41	18.48	34.26 ± 0.19	1.25	35.76
C∖7TΛ	7.85 ± 0.08	1.41	21.18	31.26 ± 0.06	1.25	36.77
SVD	7.78 ± 0.01	1.40	21.71	31.31 ± 0.08	1.25	36.89
	7.38 ± 0.05	1.40	22.47	31.22 ± 0.06	1.25	36.80
	14.68 ± 0.10	1.43	17.72	45.03 ± 1.59	1.27	31.01
eŋp SBP	7.27 ± 0.06	1.41	18.55	30.56 ± 0.03	1.25	35.74
	7.40 ± 0.02	1.40	21.03	30.82 ± 0.02	1.25	36.84
	7.40 ± 0.02	1.40	22.54	31.03 ± 0.09	1.25	36.90
	7.43 ± 0.11	1.89	12.45	40.13 ± 1.84	2.40	11.26
ŋŋ	6.66 ± 0.11	1.49	16.09	29.27 ± 0.27	1.26	26.15
BB	6.61 ± 0.14	1.42	17.79	28.89 ± 0.07	1.25	29.15
	6.51 ± 0.06	1.40	22.51	29.68 ± 0.08	1.25	36.90
	8.89 ± 0.12	2.36	8.62	40.45± 1.74	2.63	9.39
DBB	7.03 ± 0.16	1.54	14.08	28.85± 0.06	1.29	22.64
	6.59 ± 0.07	1.44	6.64	28.48± 0.18	1.27	26.93
	6.39 ± 0.04	1.42	22.02	28.74± 0.10	1.26	36.41
	7.87 ± 0.13	2.32	10.42	31.64 ± 0.33	1.65	17.84
∖7T^D	7.17 ± 0.06	1.78	12.93	29.87 ± 0.19	1.31	22.74
VIB	6.93 ± 0.13	1.45	16.51	29.90 ± 0.34	1.25	27.26
	7.11 ± 0.08	1.41	17.77	30.20 ± 0.18	1.25	31.69
	8.06 ± 0.12	1.58	17.84	36.35 ± 0.50	1.56	23.93
GD	7.26 ± 0.15	1.41	20.97	30.54 ± 0.23	1.29	34.42
	6.98 ± 0.12	1.41	21.55	29.94 ± 0.10	1.25	36.34
	6.59 ± 0.09	1.40	22.54	29.29 ± 0.01	1.25	36.90
13