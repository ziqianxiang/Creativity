Figure 1: The binary function similarity learningproblem. Checking whether two graphs are simi-lar requires reasoning about both the structure aswell as the semantics of the graphs. Here the lefttwo control flow graphs correspond to the samefunction compiled with different compilers (andtherefore similar), while the graph on the rightcorresponds to a different function.
Figure 2: Illustration of the graph embedding (left) and matching models (right).
Figure 3: Visualization of cross-graph attention for GMNs after 5 propagation layers. In each pairof graphs the left figure shows the attention from left graph to the right, the right figure shows theopposite.
Figure 4: Performance (Ã—100) of different models on the binary function similarity search task.
Figure 5:	Example control flow graphs for the same binary function, compiled with different compilers(clang for the leftmost one, gcc for the others) and optimization levels. Note that each node in thegraphs also contains a set of assembly instructions which we also take into account when computingsimilarity using learned features.
Figure 6:	Control flow graph size distribution in the training set. In this plot the graphs are sorted bysize on the x axis, each point in the figure corresponds to the size of one graph.
Figure 7: The change of cross-graph attention over propagation layers. Here the two graphs aretwo isomorphic chains and there are some in-graph symmetries. Note that in the end the nodes arematched to two corresponding nodes with equal weight, except the one at the center of the chainwhich can only match to a single other node.
Figure 8: The change of cross-graph attention over propagation layers. Here the two graphs areisomorphic, with graph edit distance 0. Note that in the end a lot of the matchings concentrated onthe correct match.
Figure 9: The change of cross-graph attention over propagation layers. The edit distance betweenthese two graphs is 1.
