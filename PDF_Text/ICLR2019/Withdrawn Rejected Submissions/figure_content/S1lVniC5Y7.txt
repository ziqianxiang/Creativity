Figure 1: (a)Tree based representation of the recurrent node. Tree outputs h(t) and c(t) are fedas inputs in the next time step. (b) In standard recurrent network, the tree node is repeated severaltimes to create each layer in a multi-layered network. Different node colors depict various elementactivations. (c) The heterogeneous layer consists of different types of recurrent nodes.
Figure 2: (a) Homologous crossover in GP - the two trees on the top look different but in-fact theyare almost mirror images of each other. These two trees will therefore belong in the same species.
Figure 3: Learning curve comparison of LSTM node, NAS node and GP nodes. Y-axis is thevalidation perplexity (lower is better) and X-axis is the epoch number. Notice that LSTM nodelearns quicker than the other two initially but eventually settles at a larger perplexity value. Thisgraph demonstrates that the strategy to determine network fitness using partial training (say based onepoch 10 validation perplexity) is faulty. A fitness predictor model like Meta-LSTM can overcomethis problem.
Figure 4: (a) Meta LSTM model: this is a sequence to sequence (seq2seq) model that takes thevalidation perplexity of the first 10 epochs as sequential input and predicts the validation perplexityat epoch 40. The green rectangles denote the encoder and the orange rectangles denote the decoder.
Figure 5: (a) Comparing Evolved recurrent node with NASCell and LSTM. The green input ele-ments denote the native memory cell outputs from the previous time step (c, d). The red coloredinputs are formed after combining the node output from the previous time step h(t - 1) and the newinput from the current time step x(t). In all three solutions, the memory cell paths include relativelyfew non-linearities. The evolved node utilizes the extra memory cell in different parts of the node.
Figure 6: Evolved Node for Music. The node evolved to solve the music task is very different fromthe node for the natural language task. For example, this node only uses a single memory cell (greeninput d in the figure) unlike the language node that used both c and d. This results indicates that’architecture does matter’ and that custom evolved solution perform better than hand-designed ones.
