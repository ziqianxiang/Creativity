Published as a conference paper at ICLR 2019
Variance Networks: When Expectation Does
Not Meet Your Expectations
Kirill Neklyudov*
Samsung-HSE Laboratory, National Research
University Higher School of Economics
Samsung AI Center Moscow
k.necludov@gmail.com
Arsenii Ashukha*
Samsung AI Center Moscow
ars.ashuha@gmail.com
Dmitry Molchanov*
Samsung-HSE Laboratory, National Research
University Higher School of Economics
Samsung AI Center Moscow
dmolch111@gmail.com
Dmitry Vetrov
Samsung-HSE Laboratory, National Research
University Higher School of Economics
Samsung AI Center Moscow
vetrovd@yandex.ru
Ab stract
Ordinary stochastic neural networks mostly rely on the expected values of their
weights to make predictions, whereas the induced noise is mostly used to capture
the uncertainty, prevent overfitting and slightly boost the performance through
test-time averaging. In this paper, we introduce variance layers, a different kind
of stochastic layers. Each weight of a variance layer follows a zero-mean dis-
tribution and is only parameterized by its variance. It means that each object is
represented by a zero-mean distribution in the space of the activations. We show
that such layers can learn surprisingly well, can serve as an efficient exploration
tool in reinforcement learning tasks and provide a decent defense against adversar-
ial attacks. We also show that a number of conventional Bayesian neural networks
naturally converge to such zero-mean posteriors. We observe that in these cases
such zero-mean parameterization leads to a much better training objective than
more flexible conventional parameterizations where the mean is being learned.
1	Introduction
Modern deep neural networks are usually trained in a stochastic setting. They use different stochastic
layers (Srivastava et al. (2014); Wan et al. (2013)) and stochastic optimization techniques (Welling
& Teh (2011); Kingma & Ba (2014)). Stochastic methods are used to reduce overfitting (Srivastava
et al. (2014); Wang & Manning (2013); Wan et al. (2013)), estimate uncertainty (Gal & Ghahramani
(2016); Malinin & Gales (2018)) and to obtain more efficient exploration for reinforcement learning
(Fortunato et al. (2017); Plappert et al. (2017)) algorithms.
Bayesian deep learning provides a principled approach to training stochastic models (Kingma &
Welling (2013); Rezende et al. (2014)). Several existing stochastic training procedures have been
reinterpreted as special cases of particular Bayesian models, including, but not limited to different
versions of dropout (Gal & Ghahramani (2016)), drop-connect (Kingma et al. (2015)), and even
the stochastic gradient descent itself (Smith & Le (2018)). One way to create a stochastic neural
network from an existing deterministic architecture is to replace deterministic weights wij with
random weights Wij 〜 q(Wj | φij) (Hinton & Van Camp (1993); BlUndell et al. (2015)). During
training, a distribution over the weights is learned instead of a single point estimate. Ideally one
would want to average the predictions over different samples of such distribution, which is known
as test-time averaging, model averaging or ensembling. However, test-time averaging is impractical,
so during inference the learned distribution is often discarded, and only the expected values of the
weights are used instead. This heuristic is known as mean propagation or the weight scaling rule
* Equal contribution
1
Published as a conference paper at ICLR 2019
(Srivastava et al. (2014); Goodfellow et al. (2016)), and is widely and successfully used in practice
(Srivastava et al. (2014); Kingma et al. (2015); Molchanov et al. (2017)).
In our work we study the an extreme case of stochastic neural network where all the weights in
one or more layers have zero means and trainable variances, e.g. Wij 〜N(0, σj). Although no
information get stored in the expected values of the weights, these models can learn surprisingly
well and achieve competitive performance. Our key results can be summarized as follows:
1.	We introduce variance layers, a new kind of stochastic layers that store information only in
the variances of its weights, keeping the means fixed at zero, and mapping the objects into
zero-mean distributions over activations. The variance layer is a simple example when the
weight scaling rule (Srivastava et al. (2014)) fails.
2.	We draw the connection between neural networks with variance layers (variance networks)
and conventional Bayesian deep learning models. We show that several popular Bayesian
models (Kingma et al. (2015); Molchanov et al. (2017)) converge to variance networks, and
demonstrate a surprising effect - a less flexible posterior approximation may lead to much
better values of the variational inference objective (ELBO).
3.	Finally, we demonstrate that variance networks perform surprisingly well on a number of
deep learning problems. They achieve competitive classification accuracy, are more robust
to adversarial attacks and provide good exploration in reinforcement learning problems.
2	Stochastic Neural Networks
A deep neural network is a function that outputs the predictive distribution p(t | x, W) of targets t
given an object x and weights W. Recently, stochastic deep neural networks — models that exploit
some kind of random noise — have become widely popular (Srivastava et al. (2014); Kingma et al.
(2015)). We consider a special case of stochastic deep neural networks where the parameters W are
drawn from a parametric distribution q(W | φ). During training the parameters φ are adjusted to the
training data (X, T) by minimizing the sum of the expected negative log-likelihood and an optional
regularization term R(φ). In practice this objective equation 1 is minimized using one-sample mini-
batch gradient estimation.
-Eq(W | φ) logp(T∣ X, W) + R(φ) → min	(1)
φ
This training procedure arises in many conventional techniques of training stochastic deep neu-
ral networks, such as binary dropout (Srivastava et al. (2014)), variational dropout (Kingma et al.
(2015)) and drop-connect (Wan et al. (2013)). The exact predictive distribution Eq(W | φ)p(t | x, W)
for such models is usually intractable. However, it can be approximated using K independent sam-
ples of the weights equation 2. This technique is known as test-time averaging. Its complexity
increases linearly in K.
1K
p(t I X) = Eq(W । φ)p(t I χ,w) ` κ ∑p(t I x，ck), Wk 〜q(w I Φ)	(2)
In order to obtain a more computationally efficient estimation, it is common practice to replace the
weights with their expected values equation 3. This approximation is known as the weight scaling
rule (Srivastava et al. (2014)).
Eq(W | φ)p(t I x, W) ≈p(t I x,EqW).	(3)
As underlined by Goodfellow et al. (2016), while being mathematically incorrect, this rule still
performs very well on practice. The success of weight scaling rule implies that a lot of learned
information is concentrated in the expected value of the weights.
In this paper we consider symmetric weight distributions q(W I φ) = q(-W I φ). Such distributions
cannot store any information about the training data in their means as EW = 0. In the case of
conventional layers with symmetric weight distribution, the predictive distribution p(t I x, EW = 0)
does not depend on the object x. Thus, the weight scaling rule results in a random guess quality
predictions. We would refer to such layers as the variance layers, and will call neural networks that
at least one variance layer the variance networks.
2
Published as a conference paper at ICLR 2019
(a) Neurons encode the same information
Figure 1: The visualization of objects activation samples from a variance layer with two variance
neurons. The network was learned on a toy four-class classification problem. The two plots corre-
spond to two different random initializations. We demonstrate that a variance layer can learn two
fundamentally different kinds of representations (a) two neurons repeat each other, the informa-
tion about each class is encoded in variance of each neuron (b) two neurons encode an orthogonal
information, both neurons are needed to identify the class of the object.
(b) Neurons encode different information
3	Variance Layer
In this section, we consider a single fully-connected layer1 with I input neurons and O output
neurons, before a non-linearity. We denote an input vector by ak ∈ RI and an output vector by
bk ∈ RO, a weight matrix by W ∈ RI×O. The output of the layer is computed as bk> = ak>W. A
standard normal distributed random variable is denoted by e 〜N(0,1).
Most stochastic layers mostly rely on the expected values of the weights to make predicitons. We
introduce a Gaussian variance layer that by design cannot store any information in mean values of
the weights, as opposed to conventional stochastic layers. In a Gaussian variance layer the weights
follow a zero-mean Gaussian distribution Wij = σij∙ ∙ Cij 〜N(WijI 0, σj), so the information can
be stored only in the variances of the weights.
3.1	Distribution of activations
To get the intuition of how the variance layer can output any sensible values let’s take a look at the
activations of this layer. A Gaussian distribution over the weights implies a Gaussian distribution
over the activations (Wang & Manning (2013); Kingma et al. (2015)). This fact is used in the local
reparameterization trick (Kingma et al. (2015)), and we also rely on it in our experiments.
bkj = Eakiμj + j t£aM2j
i=1	i=1
Conventional layer
Variance layer
(4)
In Gaussian variance layer an expectation of bmj is exactly zero, so the first term in eq. equation 4
disappears. During training, the layer can only adjust the variances PiI a2kiσi2j of the output. It
means that each object is encoded by a zero-centered fully-factorized multidimensional Gaussian
rather than by a single point / a non-zero-mean Gaussian. The job of the following layers is then
to classify such zero-mean Gaussians with different variances. It turns out that such encodings are
surprisingly robust and can be easily discriminated by the following layers.
3
Published as a conference paper at ICLR 2019
3.2	Toy problem
We illustrate the intuition on atoy classification problem. Object of four classes were generated from
Gaussian distributions with μ ∈ {(3,3), (3,10), (10,3), (10,10)} and identity covariance matrices. A
classification network consisted of six fully-connected layers with ReLU non-linearities, where the
fifth layer is a bottleneck variance layer with two output neurons. In Figure 1 we plot the activations
of the variance layer that were sampled similar to equation equation 4. The exact expressions are
presented in Appendix E. Different colors correspond to different classes.
We found that a variance bottleneck layer can learn two fundamentally different kinds of representa-
tions that leads to equal near perfect performance on this task. In the first case the same information
is stored in two available neurons (Figure 1a). We see this effect as a kind of in-network ensembling:
averaging over two samples from the same distribution results in a more robust prediction. Note that
in this case the information about four classes is robustly represented by essentially only one neuron.
In the second case the information stored in these two neurons is different. Each neuron can be either
activated (i.e. have a large variance) or deactivated (i.e. have a low variance). Activation of the first
neuron corresponds to either class 1 or class 2, and activation of the second neuron corresponds to
either class 1 or class 3. This is also enough to robustly encode all four classes. Other combinations
of these two cases are possible, but in principle, we see how the variances of the activations can
be used to encode the same information as the means. As shown in Section 6, although this repre-
sentation is rather noisy, it robustly yields a relatively high accuracy even using only one sample,
and test-time averaging allows to raise it to competitive levels. We observe the same behaviour with
real tasks. See Appendix D for the visualization of the embeddings, learned by a variance LeNet-5
architecture on the MNIST dataset.
One could argue that the non-linearity breaks the symmetry of the distribution. This could mean
that the expected activations become non-zero and could be used for prediction. However, this
is a fallacy: we argue that the correct intuition is that the model learns to distinguish activations of
different variance. To prove this point, we train variance networks with antisymmetric non-linearities
like (e.g. a hyperbolic tangent) without biases. That would make the mean activation of a variance
layer exactly zero even after a non-linearity. See Appendix C for more details.
3.3	Other zero-mean symmetric distributions
Other types of variance layers may exploit different kinds of multiplicative or additive symmetric
zero-mean noise distributions . These types of noise include, but not limited to:
•	Gaussian variance layer: q(wj) = σj ∙ eij, where Eij 〜N(0,1)
•	Bernoulli variance layer: q(wj) = θj ∙ (2cj — 1), where Eij 〜 Bernoulli1 1)
•	Uniform variance layer: q(wj) = θj ∙ Eij, where Eij 〜 UnifOrm( — 1,1),
In all these models the learned information is stored only in the variances of the weights. Applied
to these type of models, the weight scaling rule (eq. equation 3) will result in the random guess
performance, as the mean of the weights is equal to zero. Note that we cannot perform an exact local
reparameterization trick for Bernoulli or Uniform noise. We can however use moment-matching
techniques similar to fast dropout (Wang & Manning (2013)). Under fast dropout approximation all
three cases would be equivalent to a Gaussian variance layer.
We were able to train a LeNet-5 architecture (Caffe (2014)) on the MNIST dataset with the first
dense layer being a Gaussian variance layer up to 99.3 accuracy, and up to up to 98.7 accuracy
with a Bernoulli or a uniform variance layer. Such gap in the performance is due to the lack of the
local reparameterization trick for Bernoulli or uniform random weights. The complete results for
the Gaussian variance layer are presented in Section 6.
1	In this section we consider fully-connected layers for simplicity. The same applies to convolutional lay-
ers and other linear transformations. In the experiments we consider both fully-connected and convolutional
variance layers.
4
Published as a conference paper at ICLR 2019
-10.0
Figure 2: The KL divergence between the Gaus-
sian dropout posterior and different priors. The
KL-divergence between the Gaussian dropout
posterior and the Student’s t-prior is no longer
a function of just α; however, for small enough
ν it is indistinguishable from the KL-divergence
with the log-uniform prior.
40	60
# Epoch
80	1∞
Figure 3: CIFAR-10 test set accuracy for a
VGG-like neural network with layer-wise pa-
rameterization with weights replaced by their
expected values (deterministic), sampled from
the variational distribution (sample), the test-
time averaging (ensemble) and zero-mean ap-
proximation accuracy. Note how the informa-
tion is transfered from the means to the vari-
ances between epochs 40 and 60.
4	Relation to Bayesian Deep Learning
In this section we review several Gaussian dropout posterior models with different prior distributions
over the weights. We show that the Gaussian dropout layers may converge to variance layers in
practice.
4.1	Stochastic Variational Inference
Doubly stochastic variational inference (DSVI) (Titsias & Lazaro-Gredilla (2014)) with the (local)
reparameterization trick (Kingma & Welling (2013); Kingma et al. (2015)) can be considered as
a special case of training with noise, described by eq. equation 1. Given a likelihood function
p(t | x, W) and a prior distribution p(W), we would like to approximate the posterior distribution
p(W | Xtrain , Ttrain) ≈ q(W | φ) over the weights W . This is performed by maximization of the
variational lower bound (ELBO) w.r.t. the parameters φ of the posterior approximation q(W | φ)
L(φ) = Eq(W | φ) logp(T | X,W) - KL(q(W | φ) k P(W)) → max.	(5)
φ
The variational lower bound consists of two parts. One is the expected log likelihood term
Eq(W | φ) log p(T | X, W) that reflects the predictive performance on the training set. The other is
the KL divergence term KL(q(W | φ) k p(W)) that acts as a regularizer and allows us to capture the
prior knowledge p(W).
4.2	Models
We consider the Gaussian dropout approximate posterior that is a fully-factorized Gaussian Wij 〜
N(WijI μj,αμ2j) (Kingma et al. (2015)) with the Gaussian “dropout rate” ɑ shared among all
weights of one layer. We explore the following prior distributions:
Symmetric log-uniform distribution P(Wij) a -pw1^ is the prior used in variational dropout
(Kingma et al. (2015); Molchanov et al. (2017)). The KL-term for the Gaussian dropout posterior
5
Published as a conference paper at ICLR 2019
turns out to be a function of α and can be expressed as follows:
KL(N(μij, αμ2j) ∣∣ LogU(Wij))=	⑹
=const — 2 log αμ2 + 1 Eε〜N(0,1)logμ2(1 + √0ε)2 =	(7)
=const — 1log α + Eε〜N(0,1)log 11 + √αε∣	(8)
This KL-term can be estimated using one MC sample, or accurately approximated. In our experi-
ments, we use the approximation, proposed in Sparse Variational Dropout (Molchanov et al. (2017)).
Student’s t-distribution with ν degrees of freedom is a proper analog of the log-uniform prior, as
the log-uniform prior is a special case of the Student’s t-distribution with zero degrees of freedom.
As ν goes to zero, the KL-term for the Student’s t-prior equation 10 approaches the KL-term for the
log-uniform prior equation 7.
KL(Mμj, αμ2j) I St(WijI V))=	⑼
=const — 2 log αμ2 + ν+-1 Eε〜N(o,i)log (V + μ2(1 + √αε)2)	(10)
As the use of the improper log-uniform prior in neural networks is questionable (Hron et al. (2017)),
we argue that the Student’s t-distribution with diminishing values of V results in the same proper-
ties of the model, but leads to a proper posterior. We use one sample to estimate the expectation
equation 10 in our experiments, and use V = 10-16.
Automatic Relevance Determination priorp(Wij) = N (Wij | 0, λi2j) (Neal (1996); MacKay et al.
(1994)) has been previously applied to linear models with DSVI(Titsias & Lazaro-Gredilla (2014)),
and can be applied to Bayesian neural networks without changes. Following (Titsias & LaZaro-
Gredilla (2014)), we can show that in the case of the Gaussian dropout posterior, the optimal prior
variance λj would be equal to (α + 1)μj, and the KL-term KL(q(W ∣ φ) ∣∣ P(W)) would then be
calculated as follows:
KL(N(μij,αμ2j) ∣∣ N(0, (α + 1)μj)) = log(1 + α-1) .	(11)
Note that in the case of the log-uniform and the ARD priors, the KL-divergence between a zero-
centered Gaussian and the prior is constant. For the ARD prior it is trivial, as the prior distribution
p(W) is equal to the approximate posterior q(W) and the KL is zero. For the log-uniform distribution
the proof is presented in Appendix F. Note that a zero-centered posterior is optimal in terms of these
KL divergences. In the next section we will show that Gaussian dropout layers with these priors can
indeed converge to variance layers.
4.3	Convergence to variance layers
As illustrated in Figure 2, in all three cases the KL term decreases in α and pushes α to infinity. We
would expect the data term to limit the learned values of α, as otherwise the model would seem to be
overregularized. Surprisingly, we find that in practice for some layers a's may grow to essentially
infinite values (e.g. a > 107). When this happens, the approximate posterior N(μj, αμj) becomes
indistinguishable from its zero-mean approximation N(0, αμj), as its standard deviation √α∣μj∣
becomes much larger than its mean μj. We prove that as α goes to infinity, the Maximum Mean
Discrepancy (Gretton et al. (2012)) between the approximate posterior and its zero-mean approxi-
mation goes to zero.
Theorem 1. Assume that αt -→ +∞ as t -→ +∞. Then the Gaussian dropout posterior
qt(w) = QD=I N(Wi I μt,i, αtμ2,i) becomes indistinguishable from its zero-centered approximation
q0(w) = QD=I N (Wi I 0, α±μ2,i) in terms of Maximum Mean Discrepancy:
MMD(qt0 (W) ∣ qt (W)) ≤
lim MMD(qt0 (W) ∣ qt (W)) = 0
t→+∞
(12)
(13)
The proof of this fact is provided in Appendix A. It is an important result, as MMD provides an
upper bound equation 38 on the change in the predictions of the ensemble. It means that we can
6
Published as a conference paper at ICLR 2019
Table 1: Variational lower bound (ELBO), its decomposition into the data term and the KL term, and test
set accuracy for different parameterizations. The test-time averaging accuracy is roughly the same for all
procedures, but a clear phase transition is only achieved in layer-wise and neuron-wise parameterizations. The
same result is reproduced on a VGG-like architecture on CIFAR-10; the achieved ELBO values are -116.2,
-233.4 and -1453.7 for the layer-wise, neuron-wise and weight-wise parameterizations respectively.
Metric		Parameterization				
		zero-mean	layer	neuron	weight	additive
Evidence Lower Bound	L(φ)	-4.0	-17.4	-31.4	-602.6	-227.9
Data term	Eq log p(T |X,W)	-4.0	-15.8	-17.0	-33.8	-31.2
Regularizer term	KL(q k p)	0.0	1.7	14.4	568.8	196.7
Mean propagation acc. (%)	y = arg maxt p(t | x, EqW)	11.3	11.3	11.3	96.6	99.2
Test-time averaging acc. (%)	y = arg maxt Eqp(t | x, W)	99.4	99.2	99.2	99.4	99.2
replace the learned posterior N (μj, αμj) with its zero-centered approximation N (0, αμj) without
affecting the predictions of the model. In this sense we see that some layers in these models may
converge to variance layers. Note that although α may grow to essentially infinite values, the mean
and the variance of the corresponding Gaussian distribution remain finite. In practice, as α tends to
infinity, the means μj tend to zero, and the variances σj = ɑμ2 converge to finite values.
During the beginning of training, the Gaussian dropout rates α are low, and the weights can be
replaced with their expectations with no accuracy degradation. After the end of training, the dropout
rates are essentially infinite, and all information is stored in the variances of the weights. In these
two regimes the network behave very differently. Ifwe track the train or test accuracy during training
we can clearly see a kind of “phase transition” between these two regimes. See Figure 3 for details.
We observe the same results for all mentioned prior distributions. The corresponding details are
presented in Appendix B.
5 Avoiding local optima
In this section we show how different parameterizations of the Gaussian dropout posterior influ-
ence the value of the variational lower bound and the properties of obtained solution. We consider
the same objective that is used in sparse variational dropout model (Molchanov et al. (2017)), and
consider the following parameterizations for the approximate posterior q(wij):
zero-mean layer-wise neuron-wise weight-wise additive
q(Wij) N(0,σ2j) N(μij, αμ2j) N(μij, %μj) N(μij, αjμj) N(μij,σj
(14)
Note that the additive and weight-wise parameterizations are equivalent and that the layer- and the
neuron-wise parameterizations are their less flexible special cases. We would expect that a more
flexible approximation would result in a better value of variational lower bound. Surprisingly, in
practice we observe exactly the opposite: the simpler the approximation is, the better ELBO we
obtain.
The optimal value of the KL term is achieved when all a's are set to infinity, or, equivalently, the
mean is set to zero, and the variance is nonzero. In the weight-wise and additive parameterization a's
for some weights get stuck in low values, whereas simpler parameterizations have all a's converged
to effectively infinite values. The KL term for such flexible parameterizations is orders of magnitude
worse, resulting in a much lower ELBO. See Table 1 for further details. It means that a more flexible
parameterization makes the optimization problem much more difficult. It potentially introduces
a large amount of poor local optima, e.g. sparse solutions, studied in sparse variational dropout
(Molchanov et al. (2017)). Although such solutions have lower ELBO, they can still be very useful
in practice.
6 Experiments
We perform experimental evaluation of variance networks on classification and reinforcement learn-
ing problems. Although all learned information is stored only in the variances, the models perform
surprisingly well on a number of benchmark problems. Also, we found that variance networks
7
Published as a conference paper at ICLR 2019
Ooooooooo
05050505
07520752
0.985	0.990	0.995
Accuracy, %
9
0
11.0	11.5	12.0	12.5	13.
Threshold for the variances
Figure 5: Here we show that a variance layer can
be pruned up to 98% with almost no accuracy
degradation. We use magnitude-based pruning
for σ ’s (replace all σij∙ that are below the thresh-
old with zeros), and report test-time-averaging
accuracy.
Accuracy of the model after
Sparsity after pruning
Figure 4: Histograms of test accuracy of LeNet-
5 networks on MNIST dataset. The blue his-
togram shows an accuracy of individual weight
samples. The red histogram demonstrates that
test time averaging over 200 samples signifi-
cantly improves accuracy.
are more resistant to adversarial attacks than conventional ensembling techniques. All stochas-
tic models were optimized with only one noise/weight sample per step. Experiments were imple-
mented using PyTorch (Paszke et al. (2017)). The code is available at https://github.com/
da-molchanov/variance-networks.
6.1	Classification
We consider three image classification tasks,
the MNIST (LeCun et al. (1998)), CIFAR-10
and CIFAR-100 (Krizhevsky & Hinton (2009))
datasets. We use the LeNet-5-Caffe architec-
ture (Caffe (2014)) as a base model for the ex-
periments on the MNIST dataset, and a VGG-
like architecture (Zagoruyko (2015)) on CIFAR-
10/100. As can be seen in Table 2, variance
networks provide the same level of test accu-
racy as conventional binary dropout. In the vari-
ance LeNet-5 all 4 layers are variational dropout
layers with layer-wise parameterization equa-
tion 14. Only the first fully-connected layer con-
verged to a variance layer. In the variance VGG
the first fully-connected layer and the last three
convolutional layers are variational dropout lay-
Table 2: Test set classification accuracy for differ-
ent methods and datasets. “Variance” stands for vari-
ational dropout model in the layer-wise parameteriza-
tion equation 14. “1 samp.” corresponds to the accu-
racy of one sample of the weights, “Det.” corresponds
to mean propagation, and “20 samp.” corresponds to
the MC estimate of the predictive distribution using 20
samples of the weights.
Architecture	Dataset	Network	Accuracy (%)		
			1 samp.	Det.	20 samp.
LeNet5	MNIST	Dropout Variance	99.1 98.2	99.4 11.3	99.4 99.3
VGG-like	CIFAR10	Dropout Variance	91.0 91.3	93.1 10.0	93.4 93.4
VGG-like	CIFAR100	Dropout Variance	77.5 76.9	79.8 5.0	81.7 82.2
ers with layer-wise parameterization equation 14. All these layers converged to variance layers. For
the first dense layer in LeNet-5 the value of log α reached 6.9, and for the VGG-like architecture
logα > 15 for convolutional layers and logα > 12 for the dense layer. As shown in Figure 4, all
samples from the variance network posterior robustly yields a relatively high classification accuracy.
In Appendix D we show that the intuition provided for the toy problem still holds for a convolutional
network on the MNIST dataset.
Similar to conventional pruning techniques (Han et al. (2015); Wen et al. (2016)), we can prune
variance layer in LeNet5 by the value of weights variances. Weights with low variances have small
contributions into the variance of activation and can be ignored. In Figure 5 we show sparsity and
accuracy of obtained model for different threshold values. Accuracy of the model is evaluated by
test time averaging over 20 random samples. Up to 98% of the layer parameters can be zeroed out
with no accuracy degradation.
8
Published as a conference paper at ICLR 2019
6.2	Reinforcement Learning
Recent progress in reinforcement learning shows that pa-
rameter noise may provide efficient exploration for a
number of reinforcement learning algorithms (Fortunato
et al. (2017); Plappert et al. (2017)). These papers uti-
lize different types of Gaussian noise on the parameters of
the model. However, increasing the level of noise while
keeping expressive ability may lead to better exploration.
In this section, we provide a proof-of-concept result for
exploration with variance network parameter noise on
two simple gym (Brockman et al. (2016)) environments
with discrete action space: the CartPole-v0 (Barto
et al. (1983)) and the Acrobot-v1 (Sutton (1996)).
The approach we used is a policy gradient proposed by
(Williams (1992); Sutton et al. (2000)).
In all experiments the policy was approximated with
a three layer fully-connected neural network containing
256 neurons on each hidden layer. Parameter noise and
variance network policies had the second hidden layer to
be parameter noise (Fortunato et al. (2017); Plappert et al.
(2017)) and variance (Section 3) layer respectively. For
both methods we made a gradient update for each episode
with individual samples of noise per episode. Stochas-
tic gradient learning is performed using Adam (Kingma
& Ba (2014)). Results were averaged over nine runs
with different random seeds. Figure 6 shows the train-
ing curves. Using the variance layer parameter noise the algorithm progresses slowly but tends to
reach a better final result.
6.3	Adversarial Examples
Deep neural networks suffer from adversarial at-
tacks (Goodfellow et al. (2014)) — the predictions are
not robust to even slight deviations of the input images.
In this experiment we study the robustness of variance
networks to targeted adversarial attacks.
The experiment was performed on CIFAR-
10 (Krizhevsky & Hinton (2009)) dataset on a VGG-like
architecture (Zagoruyko (2015)). We build target
adversarial attacks using the iterative fast sign algo-
rithm (Goodfellow et al. (2014)) with a fixed step length
ε = 0.5, and report the successful attack rate (Figure 7).
We compare our approach to the following baselines:
a dropout network with test time averaging (Srivastava
et al. (2014)), and deep ensembles (Lakshminarayanan
et al. (2017)) and a deterministic network. We average
over 10 samples in ensemble inference techniques. Deep
CartPole
200	4∞	6∞	800	1000
# Episode
Acrobot
-500
0	200	400	600	800	1∞0
# Episode
Figure 6: Evaluation mean scores for
CartPole-v0 and Acrobot-v1 environments
obtained by policy gradient after each
episode of training for deterministic, param-
eter noise (Fortunato et al. (2017); Plappert
et al. (2017)) and variance network policies
(Section 3).
Deterministic	Variance	Variance Ensemble
Dropout	Deep Ensemble
Figure 7: Results on iterative fast sign ad-
versarial attacks for VGG-like architecture
on CIFAR-10 dataset. For each iteration
we report the successful attack rate. Deep
ensemble of variance networks has a lower
successful attacks rate.
ensembles were constructed from five separate networks. All methods were trained without
adversarial training (Goodfellow et al. (2014)). Our experiments show that variance network has
better resistance to adversarial attacks. We also present the results with deep ensembles of variance
networks (denoted variance ensembles) and show that these two techniques can be efficiently
combined to improve the robustness of the network even further.
7 Discussion
In this paper we introduce variance networks, surprisingly stable stochastic neural networks that
learn only the variances of the weights, while keeping the means fixed at zero in one or several layers.
9
Published as a conference paper at ICLR 2019
We show that such networks can still be trained well and match the performance of conventional
models. Variance networks are more stable against adversarial attacks than conventional ensembling
techniques, and can lead to better exploration in reinforcement learning tasks.
The success of variance networks raises several counter-intuitive implications about the training of
deep neural networks:
•	DNNs not only can withstand an extreme amount of noise during training, but can actually
store information using only the variances of this noise. The fact that all samples from
such zero-centered posterior yield approximately the same accuracy also provides addi-
tional evidence that the landscape of the loss function is much more complicated than was
considered earlier (Garipov et al. (2018)).
•	A popular trick, replacing some random variables in the network with their expected values,
can lead to an arbitrarily large degradation of accuracy — up to a random guess quality
prediction.
•	Previous works used the signal-to-noise ratio of the weights or the layer output to prune
excessive units (Blundell et al. (2015); Molchanov et al. (2017); Neklyudov et al. (2017)).
However, we show that in a similar model weights or even a whole layer with an exactly
zero SNR (due to the zero mean output) can be crucial for prediction and can’t be pruned
by SNR only.
•	We show that a more flexible parameterization of the approximate posterior does not nec-
essarily yield a better value of the variational lower bound, and consequently does not
necessarily approximate the posterior distribution better.
We believe that variance networks may provide new insights on how neural networks learn from
data as well as give new tools for building better deep models.
Acknowledgments
We would like to thank Max Welling and Ekaterina Lobacheva for valuable discussions and feedback
on the earliest version of this paper. Kirill Neklyudov and Dmitry Molchanov were supported by
Samsung Research, Samsung Electronics.
References
Andrew G Barto, Richard S Sutton, and Charles W Anderson. Neuronlike adaptive elements that can
solve difficult learning control problems. IEEE transactions on systems, man, and cybernetics,
1983.
Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in
neural networks. arXiv preprint arXiv:1505.05424, 2015.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym. arXiv preprint arXiv:1606.01540, 2016.
Caffe. Training lenet on mnist with caffe, 2014. URL http://caffe.berkeleyvision.
org/gathered/examples/mnist.html.
Meire Fortunato, Mohammad Gheshlaghi Azar, Bilal Piot, Jacob Menick, Ian Osband, Alex Graves,
Vlad Mnih, Remi Munos, Demis Hassabis, Olivier Pietquin, et al. Noisy networks for exploration.
arXiv preprint arXiv:1706.10295, 2017.
Yarin Gal and Zoubin Ghahramani. Dropout as a bayesian approximation: Representing model
uncertainty in deep learning. In international conference on machine learning, pp. 1050-1059,
2016.
Timur Garipov, Pavel Izmailov, Dmitrii Podoprikhin, Dmitry P Vetrov, and Andrew Gordon Wilson.
Loss surfaces, mode connectivity, and fast ensembling of dnns. arXiv preprint arXiv:1802.10026,
2018.
10
Published as a conference paper at ICLR 2019
Ian Goodfellow, Yoshua Bengio, and Aaron Courville. Deep Learning. MIT Press, 2016. http:
//www.deeplearningbook.org.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014.
Arthur Gretton, Karsten M Borgwardt, Malte J Rasch, Bernhard Scholkopf, and Alexander Smola.
A kernel two-sample test. Journal ofMachine Learning Research,13(Mar):723-773, 2012.
Song Han, Jeff Pool, John Tran, and William Dally. Learning both weights and connections for
efficient neural network. In Advances in neural information processing systems, pp. 1135-1143,
2015.
Geoffrey E Hinton and Drew Van Camp. Keeping the neural networks simple by minimizing the
description length of the weights. In Proceedings of the sixth annual conference on Computational
learning theory, pp. 5-13. ACM, 1993.
Jiri Hron, Alexander G de G Matthews, and Zoubin Ghahramani. Variational gaussian dropout is
not bayesian. arXiv preprint arXiv:1711.02989, 2017.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint
arXiv:1312.6114, 2013.
Diederik P Kingma, Tim Salimans, and Max Welling. Variational dropout and the local reparame-
terization trick. In Advances in Neural Information Processing Systems, pp. 2575-2583, 2015.
Alex Krizhevsky and Geoffrey Hinton. Learning multiple layers of features from tiny images. 2009.
Balaji Lakshminarayanan, Alexander Pritzel, and Charles Blundell. Simple and scalable predictive
uncertainty estimation using deep ensembles. In Advances in Neural Information Processing
Systems, pp. 6405-6416, 2017.
Yann LeCun, Leon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to
document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
David JC MacKay et al. Bayesian nonlinear modeling for the prediction competition. ASHRAE
transactions, 100(2):1053-1062, 1994.
Andrey Malinin and Mark Gales. Predictive uncertainty estimation via prior networks. arXiv
preprint arXiv:1802.10501, 2018.
Dmitry Molchanov, Arsenii Ashukha, and Dmitry Vetrov. Variational dropout sparsifies deep neural
networks. arXiv preprint arXiv:1701.05369, 2017.
Radford M Neal. Bayesian learning for neural networks, volume 118. Springer Science & Business
Media, 1996.
Kirill Neklyudov, Dmitry Molchanov, Arsenii Ashukha, and Dmitry P Vetrov. Structured bayesian
pruning via log-normal multiplicative noise. In Advances in Neural Information Processing Sys-
tems, pp. 6778-6787, 2017.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
pytorch. 2017.
Matthias Plappert, Rein Houthooft, Prafulla Dhariwal, Szymon Sidor, Richard Y Chen, Xi Chen,
Tamim Asfour, Pieter Abbeel, and Marcin Andrychowicz. Parameter space noise for exploration.
arXiv preprint arXiv:1706.01905, 2017.
Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic backpropagation and
approximate inference in deep generative models. arXiv preprint arXiv:1401.4082, 2014.
11
Published as a conference paper at ICLR 2019
Samuel L. Smith and Quoc V. Le. A bayesian perspective on generalization and stochastic gradient
descent. In International Conference on Learning Representations, 2018. URL https://
openreview.net/forum?id=BJij4yg0Z.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: A simple way to prevent neural networks from overfitting. The Journal of Machine
LearningResearch,15(1):1929-1958, 2014.
Richard S Sutton. Generalization in reinforcement learning: Successful examples using sparse
coarse coding. In Advances in neural information processing systems, pp. 1038-1044, 1996.
Richard S Sutton, David A McAllester, Satinder P Singh, and Yishay Mansour. Policy gradient
methods for reinforcement learning with function approximation. In Advances in neural informa-
tion processing systems, pp. 1057-1063, 2000.
Michalis Titsias and MigUeI Lazaro-Gredilla. Doubly stochastic variational bayes for non-conjugate
inference. Proceedings of The 31st International Conference on Machine Learning, 32:1971-
1979, 2014.
Li Wan, Matthew Zeiler, Sixin Zhang, Yann Le Cun, and Rob Fergus. Regularization of neural
networks using dropconnect. In International Conference on Machine Learning, pp. 1058-1066,
2013.
Sida Wang and Christopher Manning. Fast dropout training. In international conference on machine
learning, pp. 118-126, 2013.
Max Welling and Yee W Teh. Bayesian learning via stochastic gradient langevin dynamics. In
Proceedings of the 28th International Conference on Machine Learning (ICML-11), pp. 681-688,
2011.
Wei Wen, Chunpeng Wu, Yandan Wang, Yiran Chen, and Hai Li. Learning structured sparsity in
deep neural networks. In Advances in Neural Information Processing Systems, pp. 2074-2082,
2016.
Ronald J Williams. Simple statistical gradient-following algorithms for connectionist reinforcement
learning. In Reinforcement Learning, pp. 5-32. Springer, 1992.
Sergey Zagoruyko. 92.45 on cifar-10 in torch, 2015. URL http://torch.ch/blog/2015/
07/30/cifar.html.
12
Published as a conference paper at ICLR 2019
A Proof of Theorem 1
Theorem 1. Assume that lim αt = +∞. Then the Gaussian dropout posterior qt (w)
t→+∞
QD=1 N(Wi | μt,i, αtμ2,i) becomes indistinguishable from its zero-centered approximation q0(w)
QD=1 N (wi 10, at μ2,J in terms of Maximum Mean Discrepancy:
MMD(qt0(w) k qt(w)) ≤
lim MMD(qt0 (w) k qt (w)) = 0
t→+∞	t
(15)
(16)
Proof. By the definition of the Maximum Mean Discrepancy, we have
MMD(qt0 (w) k qt(w)) = sup Eqt0 (w) f (w) - Eqt(w)f (w),	(17)
f∈C
kfk∞≤1
where the supremum is taken over the set of continuous functions, bounded by 1. Let’s reparame-
terize and join the expectations:
sup Eq0(w)f (w) — Eqt(W)f(w) = SuP Eε〜N(0,Id) [f (√0tμt Θ ε) — f(μt + √Otμt Θ ε)]
f∈C	t	f∈C
kfk∞≤1	kfk∞≤1
(18)
Since linear transformations of the argument do not change neither the norm of the function, nor its
continuity, We can hide the component-wise multiplication of ε by √αtμt inside the function f (ε).
This would not change the supremum.
SuP Eε〜N(0,Id) [f (√0tμt Θ ε) — f(μ + √0tμt Θ ε)]
f∈C
kfk∞≤1
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
f (ε) — f
(19)
(20)
There exists a rotation matrix R such that R(√α,..., √1= )> = (√D, 0,..., 0)>. As ε comes
from an isotropic Gaussian ε 〜N(0,Id), its rotation Rε would follow the same distribution Rε 〜
N(0, ID ). Once again, we can incorporate this rotation into the function f without affecting the
supremum.
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
f(R>Rε) — f
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
f(Rε) — f R
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
SuP E ε=Rε
f ∈C	ε 〜N (0,Id )
kfk∞≤1
SuP Eε 〜N (0,Id )
f∈C
kfk∞≤1
f(ε)- f
f(Rε) — f
f (ε) — f
f (ε) — f
+ε
+ε
+ε
>
>
, 0, . . . , 0	+ Rε
+ ε1, ε2, . . . , εD
,0,...,o I + ε
(21)
(22)
(23)
(24)
(25)
(26)
13
Published as a conference paper at ICLR 2019
Let’s consider the integration over ε1 separately (φ(ε1) denotes the density of the standard Gaussian
distribution):
sup Eε 〜N (0,Id )
f∈C
kfk∞≤1
f(ε)-f
f(ε)-f
Z+∞
∞
kfk∞≤1
+ ε1,ε2, . . . ,εD	φ(ε1)dε1
(27)
(28)
Next, we view f(ε1, . . . ) as a function of ε1 and denote its antiderivative as F1(ε) = f(ε)dε1.
Note that as f is bounded by 1, hence F 1 is Lipschitz in ε1 with a Lipschitz constant L = 1. It
would allow us to bound its deviation
Let’s use integration by parts:
Z+∞
∞
kfk∞≤1
sup Eε∖1 〜N(0,Id-i)	(FI(E)- F 1
kffk∈∞≤1
f(ε)-f
+ ε1,ε2,..., £d) I ≤ √Dt
+ ε1, ε2, . . . ,εD	φ(ε1)
+ ε1, ε2, . . .,εD	φ(ε1)dε1
(29)
+∞
(30)
ε1 =-∞
Z+∞
∞
F1(ε) - F1
+ ε1, ε2, . . . ,εD	dφ(ε1)
(31)
The first term is equal to zero, as (F 1(ε) - F1 (√D + ε1,ε2,... ,ed^ ) is bounded and φ(-∞)
φ(+∞) = 0. Using dφ(ε1) = -φ(ε1)ε1dε1, we obtain
MMD(qt0 (w) k qt(w))
(32)
Z+∞
∞
kfk∞≤1
F1(ε) - F1
+ ε1, ε2, . . . , εD	φ(ε1)ε1dε1
(33)
Finally, we can use the Lipschitz property of F1(ε) to bound this value:
MMD(qt0(w) k qt(w)) ≤
(34)
+∞
≤	SUp Eε∖ι 〜N (0,Id-i)
f∈C
kfk∞≤1
Z+∞
F1(ε)
∞
-F1
+ ε1,ε2,... ,εD I φ(ει)∣ει∣dει ≤
(35)
∞
	
Z+∞ √D
—^φ(ε1)lε1ldε1
∞	αt
kfk∞≤1
(36)
Thus, we obtain the following bound on the MMD:
MMD(qt0(w) k qt(w)) ≤
(37)
This bound goes to zero as αt goes to infinity.
As the output of a softmax network lies in the interval [0, 1], we obtain the following bound on the
deviation of the prediction of the ensemble after applying the zero-mean approximation:
□
∀t, ∀x
(38)
14
Published as a conference paper at ICLR 2019
B Phase transition plots for different priors
S £.76.5.432.1
Ooooooooo
.⅛-m⅛vv<
# Epoch
(a) Log Uniform
S £.76.5.43 2
Oooooooo
.⅛-m⅛vv<
----Mean propagation
----Sample
----Ensemble
Zfero-mean sample
100	200	3∞	400	500
# Epoch
(b) Student
W0.5M03
.⅛-m⅛vv<
# Epoch
(c) ARD
Figure 8: These are the learning curves for VGG-like architectures, trained on CIFAR-10 with layer-
wise parameterization and with different prior distributions. These plots show that all three priors
are equivalent in practice: all three models converge to variance networks. The convergence for
the Student’s prior is slower, because in this case the KL-term is estimated using one-sample MC
estimate. This makes the stochastic gradient w.r.t. log α very noisy when α is large.
C Anti-symmetric non-linearities
We have considered the following setting. We used a LeNet-5 network on the MNIST dataset with
only tanh non-linearities and with no biases.
Table 3: One-sample (stochastic) and test-time-averaging (ensemble) accuracy of LeNet-5 tanh net-
works. “det” stands for conventional deterministic layers and “var” stands for variance layers (layers
with zero-mean parameterization).
conv1	conv2	dense1	dense2	Stochastic	Ensemble
det	det	det	det	99.4	99.4
det	var	det	det	98.8	99.4
det	det	var	det	98.8	99.2
det	var	var	det	93.2	97.5
Note that it works well even if the second-to-last layer is a variance layer. It means that the zero-
mean variance-only encodings are robustly discriminated using a linear model.
D MNIST variance activations
Figure 9: Average distributions of activations of a variance layer for objects from different classes
for four random neurons. Each line corresponds to an average distribution, and the filled areas
correspond to the standard deviations of these p.d.f.s. Each neuron essentially has several “energy
levels”, one for each class / a group of classes. On one “energy level” the samples have roughly
the same average magnitude, and samples with different magnitudes can easily be told apart with
successive layers of the neural network.
Neuron #43
U
U
U
U
U
U
U
"W -«	-« -W S B	∙<BB
15
Published as a conference paper at ICLR 2019
E Local Reparameterization Trick for Variance Networks
Here we provide the expressions for the forward pass through a fully-connected and a convolutional
variance layer with different parameterizations.
Fully-connected layer, q(wj) = N(μj, αjμj):
bj
Din
fμ%j a + εj
i=1
Din
Eaij μ2j α2
i=1
(39)
Fully-connected layers, q(wij) = N(0, σi2j):
uDin
bj = εj t ai2σi2j	(40)
i=1
For fully-connected layers ε 〜 N(0,1) and all variables mentioned above are scalars.
ConvolUtionallayer, q(wijhw ) = N(μijhw, aijhwμijhw ):
bj = Ai ? μi+ εj Θ ʌ∕A2 ? (ai Θ μ2)	(41)
Convolutional layers, q(wijhw ) = N(0, σi2jhw ):
bj = εj © JA2 *σ1	(42)
In the last two equations denotes the component-wise multiplication, ? denotes the convolution
operation, and the square and square root operations are component-wise. εj∙hw 〜N(0,1). All
variables bj,μi,Ai,σi are 3D tensors. For all layers ε is sampled independently for each object
in a mini-batch. The optimization is performed w.r.t. μ, log ɑ or w.r.t. log σ, depending on the
parameterization.
F KL Divergence for Zero-Centered Parameterization
We show below that the KL divergence DKL (N(0, σ2) k LogU) is constant w.r.t. σ.
DKL(N(0,σ2) k LogU) H
12	1
(X- 2 log 2πeσ - Ew〜N(。团 log ∣χ∣ =
=-2 log 2∏eσ2 + Eε〜N(o,i)log ∣σε∣ =
=-2 log 2∏e + Eε〜N(0,i) log ∣ε∣
(43)
(44)
(45)
(46)
16