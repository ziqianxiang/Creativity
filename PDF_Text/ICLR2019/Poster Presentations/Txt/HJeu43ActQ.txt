Published as a conference paper at ICLR 2019
NOODL: Provable Online Dictionary Learning
and Sparse Coding
Sirisha Rambhatla*, Xingguo Li* and Jarvis Hauptt
*Dept. of Electrical and Computer Engineering, University of Minnesota - Twin Cities, USA
^Dept. of Computer Science, Princeton University, Princeton, NJ, USA
Email: rambh002@umn.edu, xingguol@cs.princeton.edu, and jdhaupt@umn.edu
Ab stract
We consider the dictionary learning problem, where the aim is to model the given
data as a linear combination of a few columns of a matrix known as a dictionary,
where the sparse weights forming the linear combination are known as coeffi-
cients. Since the dictionary and coefficients, parameterizing the linear model are
unknown, the corresponding optimization is inherently non-convex. This was a
major challenge until recently, when provable algorithms for dictionary learning
were proposed. Yet, these provide guarantees only on the recovery of the dic-
tionary, without explicit recovery guarantees on the coefficients. Moreover, any
estimation error in the dictionary adversely impacts the ability to successfully lo-
calize and estimate the coefficients. This potentially limits the utility of existing
provable dictionary learning methods in applications where coefficient recovery
is of interest. To this end, we develop NOODL: a simple Neurally plausible alter-
nating Optimization-based Online Dictionary Learning algorithm, which recovers
both the dictionary and coefficients exactly at a geometric rate, when initialized
appropriately. Our algorithm, NOODL, is also scalable and amenable for large
scale distributed implementations in neural architectures, by which we mean that
it only involves simple linear and non-linear operations. Finally, we corroborate
these theoretical results via experimental evaluation of the proposed algorithm
with the current state-of-the-art techniques.
1	Introduction
Sparse models avoid overfitting by favoring simple yet highly expressive representations. Since
signals of interest may not be inherently sparse, expressing them as a sparse linear combination
of a few columns of a dictionary is used to exploit the sparsity properties. Of specific interest are
overcomplete dictionaries, since they provide a flexible way of capturing the richness of a dataset,
while yielding sparse representations that are robust to noise; see Mallat and Zhang (1993); Chen
et al. (1998); Donoho et al. (2006). In practice however, these dictionaries may not be known,
warranting a need to learn such representations - known as dictionary learning (DL) or sparse
coding (Olshausen and Field, 1997). Formally, this entails learning an a priori unknown dictionary
A ∈ Rn×m and sparse coefficients Xj) ∈ Rm from data samples y(j)∈ Rn generated as
y(j) = A*xj), kxj)ko ≤ k for all j = 1, 2,...	(1)
This particular model can also be viewed as an extension of the low-rank model (Pearson, 1901).
Here, instead of sharing a low-dimensional structure, each data vector can now reside in a separate
low-dimensional subspace. Therefore, together the data matrix admits a union-of-subspace model.
As a result of this additional flexibility, DL finds applications in a wide range of signal processing
and machine learning tasks, such as denoising (Elad and Aharon, 2006), image inpainting (Mairal
et al., 2009), clustering and classification (Ramirez et al., 2010; Rambhatla and Haupt, 2013; Ramb-
hatla et al., 2016; 2017; 2019b;a), and analysis of deep learning primitives (Ranzato et al., 2008;
Gregor and LeCun, 2010); see also Elad (2010), and references therein.
Notwithstanding the non-convexity of the associated optimization problems (since both factors are
unknown), alternating minimization-based dictionary learning techniques have enjoyed significant
success in practice. Popular heuristics include regularized least squares-based (Olshausen and Field,
1997; Lee et al., 2007; Mairal et al., 2009; Lewicki and Sejnowski, 2000; Kreutz-Delgado et al.,
2003), and greedy approaches such as the method of optimal directions (MOD) (Engan et al., 1999)
and k-SVD (Aharon et al., 2006). However, dictionary learning, and matrix factorization models in
general, are difficult to analyze in theory; see also Li et al. (2016a).
1
Published as a conference paper at ICLR 2019
To this end, motivated from a string of recent theoretical works (Gribonval and Schnass, 2010; Jenat-
ton et al., 2012; Geng and Wright, 2014), provable algorithms for DL have been proposed recently
to explain the success of aforementioned alternating minimization-based algorithms (Agarwal et al.,
2014; Arora et al., 2014; 2015). However, these works exclusively focus on guarantees for dictionary
recovery. On the other hand, for applications of DL in tasks such as classification and clustering -
which rely on coefficient recovery - it is crucial to have guarantees on coefficients recovery as well.
Contrary to conventional prescription, a sparse approximation step after recovery of the dictionary
does not help; since any error in the dictionary - which leads to an error-in-variables (EIV) (Fuller,
2009) model for the dictionary - degrades our ability to even recover the support of the coefficients
(Wainwright, 2009). Further, when this error is non-negligible, the existing results guarantee recov-
ery of the sparse coefficients only in '2-norm sense (Donoho et al., 2006). As a result, there is a
need for scalable dictionary learning techniques with guaranteed recovery of both factors.
1.1	Summary of Our Contributions
In this work, we present a simple online DL algorithm motivated from the following regularized
least squares-based problem, where S(∙) is a nonlinear function that promotes sparsity.
p
p
A,{xm(ji)n}jp=1jP=1ky(j) -Ax(j)k22+jP=1S(x(j)).
(P1)
Although our algorithm does not optimize this objective, it leverages the fact that the problem (P1)
is convex w.r.t A, given the sparse coefficients {x(j)}. Following this, we recover the dictionary by
choosing an appropriate gradient descent-based strategy (Arora et al., 2015; Engan et al., 1999). To
recover the coefficients, we develop an iterative hard thresholding (IHT)-based update step (Haupt
and Nowak, 2006; Blumensath and Davies, 2009), and show that - given an appropriate initial esti-
mate of the dictionary and a mini-batch ofp data samples at each iteration t of the online algorithm -
alternating between this IHT-based update for coefficients, and a gradient descent-based step for the
dictionary leads to geometric convergence to the true factors, i.e., x(j→x j) and A(t)→A* as t→∞.
In addition to achieving exact recovery of both factors, our algorithm - Neurally plausible alternat-
ing Optimization-based Online Dictionary Learning (NOODL) - has linear convergence properties.
Furthermore, it is scalable, and involves simple operations, making it an attractive choice for practi-
cal DL applications. Our major contributions are summarized as follows:
•	Provable coefficient recovery: To the best of our knowledge, this is the first result on exact re-
covery of the sparse coefficients {x j)}, including their support recovery, for the DL problem. The
proposed IHT-based strategy to update coefficient under the EIV model, is of independent interest
for recovery of the sparse coefficients via IHT, which is challenging even when the dictionary is
known; see also Yuan et al. (2016) and Li et al. (2016b).
•	Unbiased estimation of factors and linear convergence: The recovery guarantees on the co-
efficients also helps us to get rid of the bias incurred by the prior-art in dictionary estimation.
Furthermore, our technique geometrically converges to the true factors.
•	Online nature and neural implementation: The online nature of algorithm, makes it suitable for
machine learning applications with streaming data. In addition, the separability of the coefficient
update allows for distributed implementations in neural architectures (only involves simple linear
and non-linear operations) to solve large-scale problems. To showcase this, we also present a
prototype neural implementation of NOODL.
In addition, we also verify these theoretical properties of NOODL through experimental evaluations
on synthetic data, and compare its performance with state-of-the-art provable DL techniques.
1.2	Related Works
With the success of the alternating minimization-based techniques in practice, a push to study the
DL problem began when Gribonval and Schnass (2010) showed that for m = n, the solution pair
(A*, X*) lies at a local minima of the following non-convex optimization program, where X =
[x(1), x(2), . . . , x(p)] and Y = [y(1), y(2), . . . , y(p)], with high probability over the randomness of
the coefficients,
min kXk1 s.t. Y = AX, kAik = 1,∀i ∈ [m].
A,X
(2)
2
Published as a conference paper at ICLR 2019
Table 1: Comparison of provable algorithms for dictionary learning.
Method	Conditions			Recovery Guarantees	
	Initial Gap of Dictionary	Maximum Sparsity	Sample Complexity	Dictionary	Coefficients
NOODL (this work)	O* (iog(n))	O* (μ√h)	Ω (mk2)	No bias	No bias
Arora15(‘‘biased’')t			Ω (mk)	O(p∕n) J	N/A
Arora15(‘‘unbiased'')ɪ			poly(m)	NegligibIe bias §	N/A
Baraketal. (2015)^	N/A	O(m(1-δ)) for δ > 0	no ⑷ ∕poly(k∕m)	e	N/A
Agarwal et al.(2014)*	O*(1∕poly(m)T	O (√n∕μ)一	Ω(m2)	No bias	N/A
Spielman et al. (2012) (for n ≤ m)	N/A	O(√n)	Ω (n2)一	No bias	N/A
Dictionary recovery reported in terms of column-wise error. ↑ See Section 5 for description. * This procedure is not online. § The bias
is not explicitly quantified. The authors claim it will be negligible.『Here, d = Ω(∙∣ log(m/n)) for column-wise error of e.
Following this, Geng and Wright (2014) and Jenatton et al. (2012) extended these results to the
overcomplete case (n < m), and the noisy case, respectively. Concurrently, Jung et al. (2014; 2016)
studied the nature of the DL problem for S(∙) = ∣∣ ∙ ∣∣ι (in (P1)), and derived a lower-bound on the
minimax risk of the DL problem. However, these works do not provide any algorithms for DL.
Motivated from these theoretical advances, Spielman et al. (2012) proposed an algorithm for the
under-complete case n ≥ m that works up-to a sparsity of k = O(√n). Later, Agarwal et al. (2014)
and Arora et al. (2014) proposed clustering-based provable algorithms for the overcomplete setting,
motivated from MOD (Engan et al., 1999) and k-SVD (Aharon et al., 2006), respectively. Here, in
addition to requiring stringent conditions on dictionary initialization, Agarwal et al. (2014) alternates
between solving a quadratic program for coefficients and an MOD-like (Engan et al., 1999) update
for the dictionary, which is too expensive in practice. Recently, aDL algorithm that works for almost
linear sparsity was proposed by Barak et al. (2015); however, as shown in Table 1, this algorithm
may result in exponential running time. Finally, Arora et al. (2015) proposed a provable online DL
algorithm, which provided improvements on initialization, sparsity, and sample complexity, and is
closely related to our work. A follow-up work by Chatterji and Bartlett (2017) extends this to random
initializations while recovering the dictionary exactly, however the effect described therein kicks-in
only in very high dimensions. We summarize the relevant provable DL techniques in Table 1.
The algorithms discussed above implicitly assume that the coefficients can be recovered, after dic-
tionary recovery, via some sparse approximation technique. However, as alluded to earlier, the
guarantees for coefficient recovery - when the dictionary is known approximately - may be limited
to some `2 norm bounds (Donoho et al., 2006). This means that, the resulting coefficient estimates
may not even be sparse. Therefore, for practical applications, there is a need for efficient online
algorithms with guarantees, which serves as the primary motivation for our work.
2	Algorithm
We now detail the specifics of our algorithm - NOODL, outlined in Algorithm 1. NOODL recov-
ers both the dictionary and the coefficients exactly given an appropriate initial estimate A(0) of the
dictionary. Specifically, it requires A(O) to be (e0, 2)-close to A* for e0 = O*(1/ log(n)), where
(, κ)-closeness is defined as follows. This implies that, the initial dictionary estimate needs to be
column-wise, and in spectral norm sense, close to A*, which can be achieved via certain initializa-
tion algorithms, such as those presented in Arora et al. (2015).
Definition 1 ((e, κ)-closeness). A dictionary A is (e, κ)-close to A* if ∣A - A* ∣ ≤ κ∣A* ∣, and
if there is a permutation π : [m] → [m] and a collection of signs σ : [m] → {±1} such that
∣σ(i)Aπ(i) -Ai*∣ ≤e, ∀i∈ [m].
Notation. Given an integer n, we denote [n] = {1, 2, . . . , n}. The bold upper-case and lower-case letters
are used to denote matrices M and vectors v, respectively. Mi, M(i,:), Mij, and vi (and v(i)) denote the i-th
column, i-th row, (i,j) element of a matrix, and i-th element of a vector, respectively. The superscript (∙)(n)
denotes the n-th iterate, while the subscript (∙)(n) is reserved for the n-th data sample. Given a matrix M,
we use kMk and kMkF as the spectral norm and Frobenius norm. Given a vector v, we use kvk, kvk0, and
kvk1 to denote the `2 norm, `0 (number of non-zero entries), and `1 norm, respectively. We also use standard
notations O(∙), Ω(∙) (O(∙), Ω(∙)) to indicate the asymptotic behavior (ignoring logarithmic factors). Further,
we use g(n) = O* (f (n)) to indicate that g(n) ≤ Lf (n) for a small enough constant L, which is independent
of n. We use c(∙) for constants parameterized by the quantities in (∙). TT(Z) := Z ∙ l∣z∣≥τ denotes the hard-
thresholding operator, where “1” is the indicator function. We use supp(∙) for the supporf (the set of non-zero
elements) and sign(∙) for the element-wise sign.
3
Published as a conference paper at ICLR 2019
Algorithm 1: NOODL: Neurally plausible alternating Optimization-based Online Dictionary Learning.
Input: Fresh data samples y(j) ∈ Rn forj ∈ [p] at each iteration t generated as per (1), where
|x*| ≥ C for i ∈ SuPP(X*). Parameters ηA, ηXr) and T(r) chosen as per A.5 and A.6. No. of
iterations T = Ω(log(1∕eτ)) and R = Ω(log(1∕δR)), for target tolerances eτ and 5r.
Output: The dictionary A(t) and coefficient estimates Xb((tj)) for j ∈ [p] at each iterate t.
Initialize: Estimate A(O) ,which is (eq, 2)-near to A for e0 = O*(1/log(n))
for t = 0 to T - 1 do
Predict: (Estimate Coefficients)
for j = 1 to p do
Initialize: X((j0)) = TC/2(A(t)>y(j))	(3)
for r = 0 to R - 1 do
I Undate:	χ(r+1)	=	Tf I(X(T)-Tzr)	A(t)> (A⑴X(T)-	%,、))	(4)
Update:	X(j)	=	Tτ (r) (X(j) - ηx	A (A X(j) -	y(j)))	(4)
end
end
Xb((tj)) := X((jR)) for j ∈ [p]
Learn: (Update Dictionary)
Form empirical gradient estimate: b(t) = ɪ Pp=I(A⑴X(j) - y(j))sign(X(j))>	(5)
Take a gradient descent step: A(t+1) = A(t) - ηA gb(t)	(6)
Normalize: Ai(t+1) = Ai(t+1)/kAi(t+1) k ∀ i ∈ [m]
end
Due to the streaming nature of the incoming data, NOODL takes a mini-batch of p data samples at
the t-th iteration of the algorithm, as shown in Algorithm 1. It then proceeds by alternating between
two update stages: coefficient estimation (“Predict”) and dictionary update (“Learn”) as follows.
Predict Stage: For a general data sample y = A*x*, the algorithm begins by forming an initial
coefficient estimate X(O) based on a hard thresholding (HT) step as shown in (3), where T (z) := Z ∙
l∣z∣≥τ for a vector z. Given this initial estimate X(O),the algorithm iterates over R = Ω(log(1∕δR))
IHT-based steps (4) to achieve a target tolerance of δR, such that (1 - ηx)R ≤ δR. Here, ηx(r) is the
learning rate, and τ(r) is the threshold at the r-th iterate of the IHT. In practice, these can be fixed
to some constants for all iterations; see A.6 for details. Finally at the end of this stage, we have
estimate b(t) := X(R) of x*.
Learn Stage: Using this estimate of the coefficients, we update the dictionary at t-th iteration A(t)
by an approximate gradient descent step (6), using the empirical gradient estimate (5) and the learn-
ing rate nA = θ(m/k); see also A.5. Finally, we normalize the columns of the dictionary and con-
tinue to the next batch. The running time of each step t ofNOODL is therefore O(mnp log(1∕δκ)).
For a target tolerance of eT and δT, such that kAi(T) - Ai* k ≤ eT, ∀i ∈ [m] and |Xbi(T) - Xi* | ≤ δT
we choose T = max(Ω(log(1∕eτ)), Ω(log(√k∕δτ))).
NOODL uses an initial HT step and an approximate gradient descent-based strategy as in Arora
et al. (2015). Following which, our IHT-based coefficient update step yields an estimate of the
coefficients at each iteration of the online algorithm. Coupled with the guaranteed progress made on
the dictionary, this also removes the bias in dictionary estimation. Further, the simultaneous recovery
of both factors also avoids an often expensive post-processing step for recovery of the coefficients.
3	Main Result
We start by introducing a few important definitions. First, as discussed in the previous section we
require that the initial estimate A(O) of the dictionary is (eO, 2)-close to A*. In fact, we require this
closeness property to hold at each subsequent iteration t, which is a key ingredient in our analysis.
This initialization achieves two goals. First, the kσ(i)Aπ(i) - Ai* k ≤ eO condition ensures that
the signed-support of the coefficients are recovered correctly (with high probability) by the hard
thresholding-based coefficient initialization step, where signed-support is defined as follows.
4
Published as a conference paper at ICLR 2019
Definition 2. The signed-support ofa vector X is defined as Sign(X) ∙ SuPP(X).
Next, the ∣∣A-A*k ≤ 2 k A* k condition keeps the dictionary estimates close to A* and is used in our
analysis to ensure that the gradient direction (5) makes progress. Further, in our analysis, we ensure
t (defined as ∣Ai(t) - Ai*∣ ≤ t) contracts at every iteration, and assume 0, t = O*(1/ log(n)).
Also, We assume that the dictionary A is fixed (deterministic) and μ-incoherent, defined as follows.
Definition 3. A matrix A ∈ Rn×m with unit-norm columns is μ-incoherent if for all i = j the
inner-product between the columns ofthe matrixfollow |hAi, Aj)| ≤ μ∕√n.
The incoherence parameter measures the degree of closeness of the dictionary elements. Smaller
values (i.e., close to 0) of μ are preferred, since they indicate that the dictionary elements do not
resemble each other. This helps us to effectively tell dictionary elements apart (Donoho and Huo,
2001; CandeS and Romberg, 2007). We assume that μ = O(log(n)) (Donoho and Huo, 2001). Next,
we assume that the coefficients are drawn from a distribution class D defined as follows.
Definition 4 (Distribution class D). The coefficient vector X* belongs to an unknown distribution
D, where the support S = SuPP(X*) is at most ofsize k, Pr[i ∈ S] = θ(k/m) and Pr [i,j ∈ S]=
Θ(k2∕m2). Moreover, the distribution is normalized such that E[x*∣i ∈ S] = 0 and E[x*2∣i ∈
S] = 1, and when i ∈ S, |Xi* | ≥ Cfor some constant C ≤ 1. In addition, the non-zero entries are
sub-Gaussian and pairwise independent conditioned on the support.
The randomness of the coefficient is necessary for our finite sample analysis of the convergence.
Here, there are two sources of randomness. The first is the randomness of the support, where the
non-zero elements are assumed to pair-wise independent. The second is the value an element in
the support takes, which is assumed to be zero mean with variance one, and bounded in magnitude.
Similar conditions are also required for support recovery of sparse coefficients, even when the dic-
tionary is known (Wainwright, 2009; Yuan et al., 2016). Note that, although we only consider the
case |Xi* | ≥ C for ease of discussion, analogous results may hold more generally for Xi*s drawn
from a distribution with sufficiently (exponentially) small probability of taking values in [-C, C].
Recall that, given the coefficients, we recover the dictionary by making progress on the least squares
objective (P1) (ignoring the term penalizing S(∙)). Note that, our algorithm is based on finding
an appropriate direction to ensure descent based on the geometry of the objective. To this end, we
adopt a gradient descent-based strategy for dictionary update. However, since the coefficients are not
exactly known, this results in an approximate gradient descent-based approach, where the empirical
gradient estimate is formed as (5). In our analysis, we establish the conditions under which both
the empirical gradient vector (corresponding to each dictionary element) and the gradient matrix
concentrate around their means. To ensure progress at each iterate t, we show that the expected
gradient vector is (Ω(k∕m), Ω(m∕k), 0)-correlated with the descent direction, defined as follows.
Definition 5. A vector g(t) is (ρ-, ρ+, ζt)-correlated with a vector z* if
hg(t),z(t) -z*i ≥ ρ-∣z(t) -z*∣2 +ρ+∣g(t)∣2 -ζt.
This can be viewed as a local descent condition which leads to the true dictionary columns; see also
CandeS et al. (2015), Chen and Wainwright (2015) and Arora et al. (2015). In convex optimiza-
tion literature, this condition is implied by the 2ρ--strong convexity, and 1∕2ρ+ -smoothness of the
objective. We show that for NOODL, ζt = 0, which facilitates linear convergence to A* without
incurring any bias. Overall our specific model assumptions for the analysis can be formalized as:
A.1 A* is μ-incoherent (Def. 3), where μ = O(log(n)), ∣ A*∣ = O(PmTn) and m = O(n);
A.2 The coefficients are drawn from the distribution class D, as per Def. 4;
A.3 The sparsity k satisfies k = O*(√n∕μ log(n));
A.4 A(0) is (0, 2)-close to A* as per Def. 1, and 0 = O*(1T log(n));
A.5 The step-size for dictionary update satisfies ηA = Θ(mTk);
A.6 The step-size and threshold for coefficient estimation satisfies ηx(r) < c1 (t, μ, n, k) =
Ω(k∕√n) < 1 and T(r) = c2(et, μ, k, n) = Ω(k2∕n) for small constants ci and c2.
We are now ready to state our main result. A summary of the notation followed by a details of the
analysis is provided in Appendix A and Appendix B, respectively.
5
Published as a conference paper at ICLR 2019
Theorem 1 (Main Result). Suppose that assumptions A.1-A.6 hold, and Algorithm 1 is provided
with P = Ω(mk2) new samples generated according to model (1) at each iteration t. Then, With
probability at least (1 一 δ(，) for some small constant δatg, given R = Ω(log(n)), the coefficient
estimate xbi(t) at t-th iteration has the correct signed-support and satisfies
(Xit)- x"2 = O(k(1 - ω)"2kA(0) - A*k), for all i ∈ SUpp(X*).
Furthermore, for some 0 < ω < 1/2, the estimate A(t) at (t)-th iteration satisfies
kA(t) - A* k2 ≤ (1 - ω)t∣∣A(O)- A*k2, for all t = 1, 2,..…
Our main result establishes that When the model satisfies A.1 〜A.3, the errors corresponding to the
dictionary and coefficients geometrically decrease to the true model parameters, given appropriate
dictionary initialization and learning parameters (step sizes and threshold); see A.4〜A.6. In other
Words, to attain a target tolerance of T and δT, Where kAi(T) - Ai* k ≤ T, |xbi(T) - xi* | ≤ δT,
we require T = max(Ω(log(1∕eτ)), Ω(log(√k∕δτ))) outer iterations and R = Ω(log(1∕δκ)) IHT
steps per outer iteration. Here, δR ≥ (1 - ηx)R is the target decay tolerance for the IHT steps.
An appropriate number of IHT steps, R, remove the dependence of final coefficient error (per outer
iteration) on the initial x(0) . In Arora et al. (2015), this dependence in fact results in an irreducible
error, which is the source of bias in dictionary estimation. As a result, since (for NOODL) the error
in the coefficients only depends on the error in the dictionary, it can be made arbitrarily small, at a
geometric rate, by the choice of eT, δT, and δR. Also, note that, NOODL can tolerate i.i.d. noise, as
long as the noise variance is controlled to enable the concentration results to hold; we consider the
noiseless case here for ease of discussion, which is already highly involved.
Intuitively, Theorem 1 highlights the symbiotic relationship between the two factors. It shows that,
to make progress on one, it is imperative to make progress on the other. The primary condition
that allows us to make progress on both factors is the signed-support recovery (Def. 2). However,
the introduction of IHT step adds complexity in the analysis of both the dictionary and coefficients.
To analyze the coefficients, in addition to deriving conditions on the parameters to preserve the
correct signed-support, we analyze the recursive IHT update step, and decompose the noise term
into a component that depends on the error in the dictionary, and the other that depends on the initial
coefficient estimate. For the dictionary update, we analyze the interactions between elements of the
coefficient vector (introduces by the IHT-based update step) and show that the gradient vector for
the dictionary update is (Ω(k∕m), Ω(m∕k), 0)-correlated with the descent direction. In the end, this
leads to exact recovery of the coefficients and removal of bias in the dictionary estimation. Note that
our analysis pipeline is standard for the convergence analysis for iterative algorithms. However, the
introduction of the IHT-based strategy for coefficient update makes the analysis highly involved as
compared to existing results, e.g., the simple HT-based coefficient estimate in Arora et al. (2015).
NOODL has an overall running time of O(mnp log(1∕δκ) max(log(1∕eτ), log(√k∕δτ)) to achieve
2
target tolerances eτ and δτ, with a total sample complexity of P∙T = Ω(mk2). Thus to remove bias,
the IHT-based coefficient update introduces a factor of log(l∕δκ) in the computational complexity
as compared to Arora et al. (2015) (has a total sample complexity of P ∙ T = Ω(mk)), and also does
not have the exponential running time and sample complexity as Barak et al. (2015); see Table 1.
4	Neural implementation of NOODL
The neural plausibility of our algorithm implies that it can be implemented as a neural network.
This is because, NOODL employs simple linear and non-linear operations (such as inner-product
and hard-thresholding) and the coefficient updates are separable across data samples, as shown in
(4) of Algorithm 1. To this end, we present a neural implementation of our algorithm in Fig. 1,
which showcases the applicability of NOODL in large-scale distributed learning tasks, motivated
from the implementations described in (Olshausen and Field, 1997) and (Arora et al., 2015).
The neural architecture shown in Fig. 1(a) has three layers - input layer, weighted residual evaluation
layer, and the output layer. The input to the network is a data and step-size pair (y(j), ηx) to each
input node. Given an input, the second layer evaluates the weighted residuals as shown in Fig. 1.
Finally, the output layer neurons evaluate the IHT iterates x((jr)+1) (4). We illustrate the operation of
this architecture using the timing diagram in Fig. 1(b). The main stages of operation are as follows.
6
Published as a conference paper at ICLR 2019
(a) Neural implementation of NOODL
' =0
' =2
' =4
' =1
Figure 1: A neural implementation of
NOODL. Panel (a) shows the neural architec-
ture, which consists of three layers: an in-
put layer, a weighted residual evaluation layer
(evaluates ηx (y(j)— A(t)x(r))), and an out-
put layer. Panel (b) shows the operation of the
neural architecture in panel (a). The update of
x((jr)+1) is given by (4).
Output: X — 0
Residual: 0
InPUt: (y(j), 1)
0	x(0) = TT (A(t)>y(j))
y(j)	y(j)
.	(y(j),nX)
) ηχM) - A㈤X(O)) ηχM) - A㈤Xj))
' =2R +1
X(R)
nx(y(j)- A㈤X(RT))
(y(j),I)
Hebbian
Learning:
Residual
sharing and
dictionary
update.
' =5
(b) The timing sequence of the neural implementation.
Initial Hard Thresholding Phase: The coefficients initialized to zero, and an input (y(j) , 1) is
provided to the input layer at a time instant ` = 0, which communicates these to the second layer.
Therefore, the residual at the output of the weighted residual evaluation layer evaluates to y(j) at
` = 1. Next, at ` = 2, this residual is communicated to the output layer, which results in evaluation
of the initialization x((j0)) as per (3). This iterate is communicated to the second layer for the next
residual evaluation. Also, at this time, the input layer is injected with (y(j) , ηx) to set the step size
parameter ηx for the IHT phase, as shown in Fig. 1(b).
Iterative Hard Thresholding (IHT) Phase: Beginning ` = 3, the timing sequence enters the
IHT phase. Here, the output layer neurons communicate the iterates x((jr)+1) to the second layer for
evaluation of subsequent iterates as shown in Fig. 1(b). The process then continues till the time
instance ' = 2R + 1, for R = Ω(log(1∕δκ)) to generate the final coefficient estimate
x
(R)
(j)
are
for the current batch of data. At this time, the input layer is again injected with (y(j) , 1) to prep
the network for residual sharing and gradient evaluation for dictionary update.
Dictionary Update Phase: The procedure now enters the dictionary update phase, denoted as “Heb-
bian Learning” in the timing sequence. In this phase, each output layer neuron communicates the
final coefficient estimate xb((tj)) = x((jR)) to the second layer, which evaluates the residual for one last
time (with ηx = 1), and shares it across all second layer neurons (“Hebbian learning”). This allows
each second layer neuron to evaluate the empirical gradient estimate (5), which is used to update
the current dictionary estimate (stored as weights) via an approximate gradient descent step. This
completes one outer iteration of Algorithm 1, and the process continues for T iterations to achieve
target tolerances T and δT, with each step receiving a new mini-batch of data.
5	Experiments
We now analyze the convergence properties and sample complexity of NOODL via experimental
evaluations 2. The experimental data generation set-up, additional results, including analysis of
computational time, are shown in Appendix E.
5.1	Convergence Analysis
We compare the performance of our algorithm NOODL with the current state-of-the-art alternating
optimization-based online algorithms presented in Arora et al. (2015), and the popular algorithm pre-
sented in Mairal et al. (2009) (denoted as Mairal ‘09). First of these, Arora15(‘‘biased’’),
is a simple neurally plausible method which incurs a bias and has a sample complexity of Ω(mk).
The other, referred to as Arora15(‘‘unbiased’’), incurs no bias as per Arora et al. (2015),
but the sample complexity results were not established.
Discussion: Fig. 2 panels (a-i), (b-i), (c-i), and (d-i) show the performance of the aforementioned
methods for k = 10, 20, 50, and 100, respectively. Here, for all experiments we set ηx = 0.2 and
τ = 0.1. We terminate NOODL when the error in dictionary is less than 10-10. Also, for coefficient
update, we terminate when change in the iterates is below 10-12. For k = 10, 20 and k = 50,
2The associated code is made available at https://github.com/srambhatla/NOODL.
7
Published as a conference paper at ICLR 2019
seuqinhceT ssorcA
yrevoceR yranoitciD
10, nA = 30 k = 20, nA = 30	k = 50, nA = 15 k = 100, nA
4 6 8 0
uuu-
IIIo
,lotujSn-Ueq0」LLe≥ss≈
50	100	150
Iterations
(a-i)
20	40	60	80	100
10-2
10-4
10-6
10-8
10-10
10-2
10-4
10-6
10-8
10-10
20	40	60
Iterations
(c-i)
100
10-2
10-4
10-6
10-8
-10
15
80	10	20	30
Iterations
(d-i)
10-2
10-4
10-6
10-8
10-10
40
IL ΓL ΓL
a---qeqo,lb-Sseoons
Phase Transition
JQOOZ
fo ecnamrofreP
γ2"lγ'^γ,°
,loSn-Ueq0」e≥
50	100	150
Iterations
(α-ii)
Iterations
(b-i)
20	40	60	80	1 00
Iterations
(b-ii)
20	40	60	80
Iterations
(c-ii)
10	20	30	40
Iterations
(d-ii)
IL ΓL ΓL
a---qeqo,lb-Sseoons
0.5	1	1.5	2
p=m
(e-i) Dictionary
m = n
m = 2n
m = 4n
0.5	1	1.5	2
p=m
(e-ii) Coefficients

Figure 2: Comparative analysis of convergence properties. Panels (a-i), (b-i), (c-i), and (d-i) show the conver-
gence of NOODL, Arora15(‘‘biased’’), Arora15(‘‘unbiased’’) and Mairal ‘09, for differ-
ent sparsity levels for n = 1000, m = 1500 and p = 5000. Since NOODL also recovers the coefficients, we
show the corresponding recovery of the dictionary, coefficients, and overall fit in panels (a-ii), (b-ii), (c-ii), and
(d-ii), respectively. Further, panels (e-i) and (e-ii) show the phase transition in samples p (per iteration) with
the size of the dictionary m averaged across 10 Monte Carlo simulations for the two factors. Here, n = 100,
k =	3,	ηx	= 0.2,	τ = 0.1,	0 =	2/ log(n),	ηA	is chosen as per A.5.	A trial is considered successful if the
7
relative Frobenius error incurred by A and X is below 5 × 10-7 after 50 iterations.
we note that Arora15(‘‘biased’’) and Arora15(‘‘unbiased’’) incur significant bias,
while NOODL converges to A* linearly. NOODL also converges for significantly higher choices
of sparsity k, i.e., for k = 100 as shown in panel (d), beyond k = O(√n), indicating a potential for
improving this bound. Further, we observe that Mairal ‘09 exhibits significantly slow convergence
as compared to NOODL. Also, in panels (a-ii), (b-ii), (c-ii) and (d-ii) we show the corresponding
performance of NOODL in terms of the error in the overall fit (kY - AXkF/kYkF), and the error in
the coefficients and the dictionary, in terms of relative Frobenius error metric discussed above. We
observe that the error in dictionary and coefficients drops linearly as indicated by our main result.
5.2	Phase transitions
Fig. 2 panels (e-i) and (e-ii), shows the phase transition in number of samples with respect to the
size of the dictionary m. We observe a sharp phase transition at m = 1 for the dictionary, and at
m = 0.75 for the coefficients. This phenomenon is similar to that observed by Agarwal et al. (2014)
(however, theoretically they required p = O(m2)). Here, we confirm number of samples required
by NOODL are linearly dependent on the dictionary elements m.
6	Future Work
We consider the online DL setting in this work. We note that, empirically NOODL works for the
batch setting also. However, analysis for this case will require more sophisticated concentration
results, which can address the resulting dependence between iterations of the algorithm. In addition,
our experiments indicate that NOODL works beyond the sparsity ranges prescribed by our theoreti-
cal results. Arguably, the bounds on sparsity can potentially be improved by moving away from the
incoherence-based analysis. We also note that in our experiments, NOODL converges even when
initialized outside the prescribed initialization region, albeit it achieves the linear rate once it sat-
isfies the closeness condition A.4. These potential directions may significantly impact the analysis
and development of provable algorithms for other factorization problems as well. We leave these
research directions, and a precise analysis under the noisy setting, for future explorations.
7	Conclusions
We present NOODL, to the best of our knowledge, the first neurally plausible provable online algo-
rithm for exact recovery of both factors of the dictionary learning (DL) model. NOODL alternates
between: (a) an iterative hard thresholding (IHT)-based step for coefficient recovery, and (b) a gradi-
ent descent-based update for the dictionary, resulting in a simple and scalable algorithm, suitable for
large-scale distributed implementations. We show that once initialized appropriately, the sequence
of estimates produced by NOODL converge linearly to the true dictionary and coefficients without
incurring any bias in the estimation. Complementary to our theoretical and numerical results, we
also design an implementation of NOODL in a neural architecture for use in practical applications.
In essence, the analysis of this inherently non-convex problem impacts other matrix and tensor fac-
torization tasks arising in signal processing, collaborative filtering, and machine learning.
8
Published as a conference paper at ICLR 2019
Acknowledgment
The authors would like to graciously acknowledge support from DARPA Young Faculty Award,
Grant No. N66001-14-1-4047.
References
Agarwal, A., Anandkumar, A., Jain, P., Netrapalli, P. and Tandon, R. (2014). Learning
sparsely used overcomplete dictionaries. In Conference on Learning Theory (COLT).
Aharon, M., Elad, M. and Bruckstein, A. (2006). k-svd: An algorithm for designing over-
complete dictionaries for sparse representation. IEEE Transactions on Signal Processing, 54
4311-4322.
Arora, S., Ge, R., Ma, T. and Moitra, A. (2015). Simple, efficient, and neural algorithms for
sparse coding. In Conference on Learning Theory (COLT).
Arora, S., Ge, R. and Moitra, A. (2014). New algorithms for learning incoherent and over-
complete dictionaries. In Conference on Learning Theory (COLT).
Barak, B., Kelner, J. A. and Steurer, D. (2015). Dictionary learning and tensor decompo-
sition via the sum-of-squares method. In Proceedings of the 47th annual ACM symposium on
Theory of Computing. ACM.
Beck, A. and Teboulle, M. (2009). A fast iterative shrinkage-thresholding algorithm for linear
inverse problems. SIAM Journal on Imaging Sciences, 2 183-202.
Blumensath, T. and Davies, M. E. (2009). Iterative hard thresholding for compressed sensing.
Applied and Computational Harmonic Analysis, 27 265-274.
CANDES, E. and Romberg, J. (2007). Sparsity and incoherence in compressive sampling. Inverse
Problems, 23 969.
CANDES, E. J., Li, X. and SOLTANOLKOTABI, m. (2015). Phase retrieval via wirtinger flow:
Theory and algorithms. IEEE Transactions on Information Theory, 61 1985-2007.
Chatterji, N. and Bartlett, P. L. (2017). Alternating minimization for dictionary learning with
random initialization. In Advances in Neural Information Processing Systems.
Chen, S. S., Donoho, D. L. and Saunders, M. A. (1998). Atomic decomposition by basis
pursuit. SIAM Journal on Scientific Computing, 20 33-61.
Chen, Y. and Wainwright, M. J. (2015). Fast low-rank estimation by projected gradient descent:
General statistical and algorithmic guarantees. CoRR, abs/1509.03025.
Donoho, D., Elad, M. and Temlyakov, V. N. (2006). Stable recovery of sparse overcomplete
representations in the presence of noise. IEEE Transactions on Information Theory, 52 6-18.
Donoho, D. L. and Huo, X. (2001). Uncertainty principles and ideal atomic decomposition.
IEEE Transactions on Information Theory, 47 2845-2862.
ELAD, M . (2010). Sparse and Redundant Representations: From Theory to Applications in Signal
and Image Processing. 1st ed. Springer Publishing Company, Incorporated.
Elad, M. and Aharon, M. (2006). Image denoising via sparse and redundant representations
over learned dictionaries. IEEE Transactions on Image Processing, 15 3736-3745.
Engan, K., Aase, S. O. and Husoy, J. H. (1999). Method of optimal directions for frame design.
In IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP), vol. 5.
IEEE.
FULLER, W. A . (2009). Measurement error models, vol. 305. John Wiley & Sons.
Geng, Q. and Wright, J. (2014). On the local correctness of 'ι-minimization for dictionary
learning. In 2014 IEEE International Symposium on Information Theory (ISIT). IEEE.
Gershgorin, S. A. (1931). Uber die abgrenzung der eigenwerte einer matrix 749-754.
9
Published as a conference paper at ICLR 2019
GREGOR, K. and LECUN, Y. (2010). Learning fast approximations of sparse coding. In Proceed-
ings of the 27th International Conference on Machine Learning (ICML). Omnipress.
Gribonval, R. and Schnass, K. (2010). Dictionary identification and sparse matrix-factorization
via 'ι -minimization. IEEE Transactions on Information Theory, 56 3523-3539.
Hanson, D. and Wright, F. T. (1971). A bound on tail probabilities for quadratic forms in
independent random variables. The Annals of Mathematical Statistics, 42 1079-1083.
HAUPT, J. and NOWAK, R. (2006). Signal reconstruction from noisy random projections. IEEE
Transactions on Information Theory, 52 4036-4048.
Jenatton, R., Grib onval, R. and Bach, F. (2012). Local stability and robustness of sparse
dictionary learning in the presence of noise. Research report.
https://hal.inria.fr/hal-00737152
Jung, A., Eldar, Y. and GOrtz, N. (2014). Performance limits of dictionary learning for sparse
coding. In Proceedings of the European Signal Processing Conference (EUSIPCO),. IEEE.
JUNG, A., ELDAR, Y. C. and GRTZ, N. (2016). On the minimax risk of dictionary learning. IEEE
Transactions on Information Theory, 62 1501-1515.
Kreutz-Delgad o, K., Murray, J. F., Rao, B. D., Engan, K., Lee, T. and Sejn owski,
T. J . (2003). Dictionary learning algorithms for sparse representation. Neural Computation, 15
349-396.
Lee, H., Battle, A., Raina, R. and Ng, A . Y. (2007). Efficient sparse coding algorithms. In
Advances in Neural Information Processing Systems (NIPS.
LEWICKI, M. S. and SEJN OWSKI, T. J. (2000). Learning overcomplete representations. Neural
Computation, 12 337-365.
LI, X., WANG, Z., LU, J., ARORA, R., HAUPT, J., LIU, H. and ZHAO, T. (2016a). Sym-
metry, saddle points, and global geometry of nonconvex matrix factorization. arXiv preprint
arXiv:1612.09296.
Li, X., Zhao, T., Arora, R., Liu, H. and Haupt, J. (2016b). Stochastic variance reduced
optimization for nonconvex sparse learning. In International Conference on Machine Learning.
Mairal, J., Bach, F., P once, J. and Sapiro, G. (2009). Online dictionary learning for sparse
coding. In Proceedings of the International Conference on Machine Learning (ICML). ACM.
MALLAT, S. G. and ZHANG, Z. (1993). Matching pursuits with time-frequency dictionaries. IEEE
Transactions on Signal Processing, 41 3397-3415.
Olshausen, B . A. and Field, D. J. (1997). Sparse coding with an overcomplete basis set: A
strategy employed by v1? Vision Research, 37 3311-3325.
PEARS ON, K. (1901). On lines and planes of closest fit to systems of points in space. The London,
Edinburgh, and Dublin Philosophical Magazine and Journal of Science, 2 559-572.
https://doi.org/10.1080/14786440109462720
Rambhatla, S. and Haupt, J. (2013). Semi-blind source separation via sparse representations
and online dictionary learning. In 2013 Asilomar Conference on Signals, Systems and Computers,.
IEEE.
Rambhatla, S., Li, X. and Haupt, J. (2016). A dictionary based generalization of robust PCA.
In IEEE Global Conference on Signal and Information Processing (GlobalSIP). IEEE.
Rambhatla, S., Li, X. and Haupt, J. (2017). Target-based hyperspectral demixing via general-
ized robust PCA. In 51st Asilomar Conference on Signals, Systems, and Computers. IEEE.
https://doi.org/10.1109/ACSSC.2017.8335372
Rambhatla, S., Li, X., Ren, J. and Haupt, J. (2019a). A dictionary-based generalization of
robust PCA part I: Study of theoretical properties. abs/1902.08304.
https://arxiv.org/abs/1902.08304
10
Published as a conference paper at ICLR 2019
Rambhatla, S., Li, X., Ren, J. and Haupt, J. (2019b). A dictionary-based generalization of
robust PCA part II: Applications to hyperspectral demixing. abs/1902.10238.
https://arxiv.org/abs/1902.10238
Ramirez, I., Sprechmann, P. and Sapiro, G. (2010). Classification and clustering via dictio-
nary learning with structured incoherence and shared features. In IEEE Conference on Computer
Vision and Pattern Recognition (CVPR). IEEE.
Ranzato, M., Boureau, Y. and LeCun, Y. (2008). Sparse feature learning for deep belief
networks. In Advances in Neural Information Processing Systems (NIPS).1185-1192.
Rudelson, M. and Vershynin, R. (2013). Hanson-wright inequality and sub-gaussian concen-
tration. Electronic Communications in Probability, 18.
Spielman, D. A., Wang, H. and Wright, J. (2012). Exact recovery of sparsely-used dictionar-
ies. In Conference on Learning Theory (COLT).
TIBSHIRANI, R. (1996). Regression shrinkage and selection via the lasso. Journal of the Royal
Statistical Society. Series B (Methodological) 267-288.
TROPP, J. (2015). An introduction to matrix concentration inequalities. Foundations and Trends in
Machine Learning, 8 1-230.
Wainwright, M. J. (2009). Sharp thresholds for high-dimensional and noisy sparsity recovery
using 'ι-constrained quadratic programming (lasso). IEEE Transactions on Information Theory,
55 2183-2202.
YUAN, X., LI, P. and ZHANG, T. (2016). Exact recovery of hard thresholding pursuit. In Advances
in Neural Information Processing Systems (NIPS).
11
Published as a conference paper at ICLR 2019
A Summary of Notation
We summarizes the definitions of some frequently used symbols in our analysis in Table 2. In
addition, we use D(v) as a diagonal matrix with elements of a vector v on the diagonal. Given a
matrix M, we use M-i to denote a resulting matrix without i-th column. Also note that, since we
show that k A(t) - Ak ≤ et contracts in every step, therefore We fix et, e0 = O*(1/ log(n)) in our
analysis.
Table 2: Frequently used symbols
Dictionary Related
Symbol	Definition	
A(t) Ai	i-th column of the dictionary estimate at the t-th iterate.	
et	∣A(t)- A"I ≤ et = o*(康)	Upper-bound on column-wise error at the t-th iterate.
μ	√ = √ + 2et	Incoherence between the columns of A ⑴；See Claim 1.
λ(jt)	λjt) =〈A?- Aj A*i∣≤ 等	Inner-product between the error and the dictionary element.
Λ(St)(i,j)	AS)(i,j) = (λt), forj=i,i ∈ S S	0,	otherwise.	A diagonal matrix of size ∣S ∣ × ∣S ∣ with λ(jt) on the diagonal for j ∈ S.
Coefficient Related
Symbol	Definition	
(r) xi	i-th element the coefficient estimate at the r-th IHT iterate.	
C	∣x*∣ ≥ C for i ∈ SuPP(X*) and C ≤ 1	Lower-bound on x*s.
S	S := supp(x*) where ∣S∣ ≤ k	Support of x*
δR	δR = Q - ηχ+ ηχ√)R ≥ (1 - ηχ)R 一	Decay parameter for coefficients.
δT	∣X(T) — x*∣ ≤ δτ∀i ∈ supp(x*)	Target coefficient element error tol- erance.
^i^	C(' := ∣x* - Xy)I for i ∈ SuPP(X*)	Error in non-zero elements of the coefficient vector.
Probabilities
Symbol	Definition	Symbol	Definition
Qj	Qi = Pr[i ∈ S] = Θ(m`)	qi,j	Qjj=pr[i, j ∈S ]=θ( m)
Pi	pi = E[xi*Sign(xi*)∣xi* 6=0]	δT	δT(t) = 2m exp(-C2/O* (et2))
~^β~	δβ(t) = 2k exp(-1/O(et))	~~~wtr	δ(tW = exp(—1/O&))	-
	δg? = exp(—Ω(k))	~^gr~	δgt = (n + m) exp(-Ω(mplog(n))
Other terms
Symbol	Definition
ξj(r+1)	ξr+1) := P IhAjt- Aj Aji +〈Aj, Aj)X - P j Ajt)iXir) i=j	i=j
βj(t)	βjt := P HAj Aj - APy +〈Aj - Ajt), APy + N? - Aj Aji)Xj 	j=j
tβ	tβ = O(√ket) is an upper-bound on βjt) with probability at least (1 — δβt))
ξej(r+1)	er+1) ：= βj(t + P ∣hAjt), Ait)i∣∣xj -Xy)I i=j	
∆(jt)	∆jt := E[ASt)少SR)Sign(Xj)]
	，~	R	, 、	，~ 的 ) := P ηχξir)(1-ηχ)R-r + Y(R) r=1
γi(R)	Y(R) :=(1-ηx)R(XiO)-Xj(1-λit)))
γ	γ := E[(A(t)b - y)sign(xj) lʃ^^];See f below.
xbi	bi := XiR) = xj(1- λ(t))+MR)	一
i =Fx* is the indicator function corresponding to the event that Sign(X*) = sign(x),
denoted by Fχ*, and similarly for the complement Fχ*
12
Published as a conference paper at ICLR 2019
B	Proof of Theorem 1
We now prove our main result. The detailed proofs of intermediate lemmas and claims are organized
in Appendix C and Appendix D, respectively. Furthermore, the standard concentration results are
stated in Appendix F for completeness. Also, see Table 3 for a map of dependence between the
results.
Overview
Given an (0, 2)-close estimate of the dictionary, the main property that allows us to make progress
on the dictionary is the recovery of the correct sign and support of the coefficients. Therefore, we
first show that the initial coefficient estimate (3) recovers the correct signed-support in Step I.A.
Now, the IHT-based coefficient update step also needs to preserve the correct signed-support. This
is to ensure that the approximate gradient descent-based update for the dictionary makes progress.
Therefore, in Step I.B, we derive the conditions under which the signed-support recovery condition
is preserved by the IHT update.
To get a handle on the coefficients, in Step II.A, we derive an upper-bound on the error incurred
by each non-zero element of the estimated coefficient vector, i.e., |bi - x*| for i ∈ S for a general
coefficient vector x*, and show that this error only depends on et (the column-wise error in the
dictionary) given enough IHT iterations R as per the chosen decay parameter δR . In addition, for
analysis of the dictionary update, we develop an expression for the estimated coefficient vector in
Step II.B.
We then use the coefficient estimate to show that the gradient vector satisfies the local descent con-
dition (Def. 5). This ensures that the gradient makes progress after taking the gradient descent-based
step (6). To begin, we first develop an expression for the expected gradient vector (corresponding to
each dictionary element) in Step III.A. Here, we use the closeness property Def 1 of the dictionary
estimate. Further, since we use an empirical estimate, we show that the empirical gradient vector
concentrates around its mean in Step III.B. Now using Lemma 15, we have that descent along this
direction makes progress.
Next in Step IV.A and Step IV.B, we show that the updated dictionary estimate maintains the close-
ness property Def 1. This sets the stage for the next dictionary update iteration. As a result, our
main result establishes the conditions under which any t-th iteration succeeds.
Our main result is as follows.
Theorem 1 (Main Result) Suppose that assumptions A.1-A.6 hold, and Algorithm 1 is provided
with P = Ω(mk2) new samples generated according to model (1) at each iteration t. Then, With
probability at least (1 — δ(2), given R = Ω(log(n)), the coefficient estimate bit) at t-th iteration
has the correct signed-support and satisfies
(Xlit)- x"2 = O(k(1 - ω)"2kA(°) - A"∣), for all i ∈ SUpp(X*).
Furthermore, for some 0 < ω < 1/2, the estimate A(t) at (t)-th iteration satisfies
kA(t) - A"∣2 ≤ (1 - ω)t∣∣A(°) - A"∣2, forall t = 1, 2,.....
Here,	δailtg)	is some small constant, where	δailtg)	=	δTit)	+	δβit)	+	δHW +	δgiti)	+	δgit),	δTit)	=
2m exp(-C2∕O*(e2)), δ? = 2k exp(-1∕O(eJ), δ*W = exp(-1∕O(et)), δgi = exp(-Ω(k)),
δg" = (n + m) exp(-Ω(m/log(n)), and ∣∣ A∣t) — A"∣ ≤ et.
Step I: Coefficients have the correct signed-support
As a first step, we ensure that our coefficient estimate has the correct signed-support (Def. 2). To
this end, we first show that the initialization has the correct signed-support, and then show that
the iterative hard-thresholding (IHT)-based update step preserves the correct signed-support for a
suitable choice of parameters.
13
Published as a conference paper at ICLR 2019
•	Step I.A: Showing that the initial coefficient estimate has the correct Signed-support-
GiVen an (e0, 2)-close estimate A(O) of A*, We first show that for a general sample y the
initialization step (3) recovers the correct signed-support with probability at least (1 -δT(t)),
where δTt) = 2m exp(-OC(IT)). This is encapsulated by the following lemma.
Lemma 1 (Signed-support recovery by coefficient initialization step). Suppose A(t)
is	et-close to	A*.	Then, if μ =	O(log(n)),	k =	O*(√n∕μlog(n)),	and	et	=
O*(1∕plog(m)), with probability at least (1 - δTt)) for each random sample y = A*x*:
sign(TC/2((A(t))>y) = sign(x*),
where δT) = 2m exp(一。:").
Note that this result only requires the dictionary to be column-wise close to the true dictio-
nary, and works for less stringent conditions on the initial dictionary estimate, i.e., requires
et = O*(1∕piog(m)) instead of et = O*(1/log(m)); see also (Arora et al., 2015).
•	Step I.B: The iterative IHT-type updates preserve the correct signed support- Next,
we show that the IHT-type coefficient update step (4) preserVes the correct signed-support
for an appropriate choice of step-size parameter ηx(r) and threshold τ(r). The choice of
these parameters arises from the analysis of the IHT-based update step. Specifically, we
show that at each iterate r, the step-size ηx(r) should be chosen to ensure that the component
corresponding to the true coefficient Value is greater than the “interference” introduced by
other non-zero coefficient elements. Then, if the threshold is chosen to reject this “noise”,
each iteration of the IHT-based update step preserVes the correct signed-support.
Lemma 2 (IHT update step preserves the correct signed-support). Suppose A(t) is et-
close to A*, μ = O(log(n)), k = O*(√n∕μlog(n)), and et = O*(1/ log(m)) Then, with
probability at least (1 - δβ(t) - δT(t)), each iterate of the IHT-based coefficient update step
shown in (4) has the correct signed-support, if for a constant CIr) (et, μ, k, n) = Ω(k2∕n),
the step size is chosen as ηx(r) ≤ c(1r) , and the threshold τ (r) is chosen as
T(r) = ηXr)(tβ + √ ∣∣χ(rτ)-x*∣∣ι):= c2r)(et,μ,k,n) = Ω (k2∕n),
for some constants ci and c?. Here, tβ = O(√ket), δ(Tt) = 2m exp(-OC(It)) ,and 6，)=
2k exp(-O(It)).
Note that, although we haVe a dependence on the iterate r in choice of ηx(r) and τ(r), these
can be set to some constants independent of r. In practice, this dependence allows for
greater flexibility in the choice of these parameters.
Step II : Analyzing the coefficient estimate
We now deriVe an upper-bound on the error incurred by each non-zero coefficient element. Further,
we deriVe an expression for the coefficient estimate at the t-th round of the online algorithm xb(t) :=
x(R); we use xb instead of xb(t) for simplicity.
• Step II.A: Derive a bound on the error incurred by the coefficient estimate- Since
Lemma 2 ensures that xb has the correct signed-support, we now focus on the error incurred
by each coefficient element on the support by analyzing xb. To this end, we carefully analyze
the effect of the recursiVe update (4), to decompose the error incurred by each element on
the support into two components - one that depends on the initial coefficient estimate x(0)
and other that depends on the error in the dictionary.
We show that the effect of the component that depends on the initial coefficient estimate
diminishes by a factor of (1 - ηx + ηx √μn) at each iteration r. Therefore, for a decay
parameter δR, we can choose the number of IHT iterations R, to make this component
arbitrarily small. Therefore, the error in the coefficients only depends on the per column
error in the dictionary, formalized by the following result.
14
Published as a conference paper at ICLR 2019
Lemma 3 (Upper-bound on the error in coefficient estimation). With probability at
least (1 - δβt) - δT)) the error incurred by each element iι ∈ SuPP(X*) of the coefficient
estimate is upper-bounded as
|bii - XI ≤ O(tβ) + ((R + 1)kηχ √⅛ max|x(0) - χ" +|x(0) - XM) δR, = O(tβ)
where tβ = O(√kei), 6r := (1 - & + %√)R, δ* = 2m exp(-OC^), δ^ =
2k exp(-O(^J), and μt is the incoherence between the columns of A⑶；see Claim 1.
This result allows us to show that if the column-wise error in the dictionary decreases at
each iteration t, then the corresponding estimates of the coefficients also improve.
•	Step II.B: Developing an expression for the coefficient estimate- Next, We derive the ex-
pression for the coefficient estimate in the following lemma. This expression is used to
analyze the dictionary update.
Lemma 4 (Expression for the coefficient estimate at the end of R-th IHT iteration).
With probability at least (1 - δT(t) - δβ(t)) the i1-th element of the coefficient estimate, for
each iι ∈ supp(x*), is given by
bii ：= X(R)= x：i(1-λ(t))+ 科?
Here,视R) is m(R)I = O(tβ), whereiφ = O(√ke?). Further, λ(t) = ∣hA(t) -A*1, AliI ≤
族,δT = 2m exp(- oC(e2) ) and δβt = 2k exp(- OIet) ).
We again observe that the error in the coefficient estimate depends on the error in the
dictionary via λi? and H(R).
Step III: Analyzing the gradient for dictionary update
Given the coefficient estimate we now show that the choice of the gradient as shown in (5) makes
progress at each step. To this end, we analyze the gradient vector corresponding to each dictionary
element to see if it satisfies the local descent condition of Def. 5. Our analysis of the gradient is
motivated from Arora et al. (2015). However, as opposed to the simple HT-based coefficient update
step used by Arora et al. (2015), our IHT-based coefficient estimate adds to significant overhead in
terms of analysis. Notwithstanding the complexity of the analysis, we show that this allows us to
remove the bias in the gradient estimate.
To this end, we first develop an expression for each expected gradient vector, show that the empirical
gradient estimate concentrates around its mean, and finally show that the empirical gradient vector
is (Ω(k∕m), Ω(m∕k), 0)-correlated with the descent direction, i.e. has no bias.
• Step III.A: Develop an expression for the expected gradient vector corresponding to
each dictionary element- The expression for the expected gradient vector gjt) correspond-
ing to j -th dictionary element is given by the following lemma.
Lemma 5 (Expression for the expected gradient vector). Suppose that A(t) is (t, 2)-
near to A*. Then, the dictionary update step in Algorithm 1 amounts to the following for
the j -th dictionary element
E[Aj(t+1)] = A(jt) + ηAgj(t),
where gj(t) is given by
gjt) = qjPj ((I- λjt))A(t)- A* + j δ7 ± Y),
λj(t)	=	IhA(jt)	-	Aj*,	Aj*iI,	and	∆(jt)	:=	E[A(St)H(SR)sign(Xj*)], where k∆(jt)k	=
O(√mqi,j Pj etkA⑴k).
• Step III.B: Show that the empirical gradient vector concentrates around its
expectation- Since we only have access to the empirical gradient vectors, we show that
these concentrate around their expected value via the following lemma.
15
Published as a conference paper at ICLR 2019
2
Lemma 6 (Concentration of the empirical gradient vector). Given P = Ω(mk2) Sam-
ples, the empirical gradient vector estimate corresponding to the i-th dictionary element,
gbi(t) concentrates around its expectation, i.e.,
kb(t) - g(t)k≤ o( mk-
with probability at least (1 - δg? - δ∖t - δ* - δ(tW), where δg) = exp(-Ω(k)).
•	Step III.C: Show that the empirical gradient vector is correlated with the descent direction-
Next, in the following lemma we show that the empirical gradient vector bgj(t) is correlated
with the descent direction. This is the main result which enables the progress in the dictio-
nary (and coefficients) at each iteration t.
Lemma 7 (Empirical gradient vector is correlated with the descent direction). Sup-
Pose A⑶ is (et, 2)-near to A*, k = O(√n) and nA = O(m∕k). Then, with Prob-
ability at least (1 - δT(t) - δβ(t) - δH(tW) - δg(ti) ) the empirical gradient vector bgj(t) is
(Ω(k/m),Ω(m∕k), 0)-correlated with (Ajt) - A*), and for any t ∈ [T],
kAjt+1)- A；k2 ≤ (1-ρnA)kAjt)- A；k2.
This result ensures for at any t ∈ [T], the gradient descent-based uPdates made via (5)
gets the columns of the dictionary estimate closer to the true dictionary, i.e., et+1 ≤ et .
Moreover, this step requires closeness between the dictionary estimate A⑴ and A*, in the
sPectral norm-sense, as Per Def 1.
Step IV: Show that the dictionary maintains the closeness property
As discussed above, the closeness property (Def 1) is crucial to show that the gradient vector is
correlated with the descent direction. Therefore, we now ensure that the updated dictionary A(t+1)
maintains this closeness property. Lemma 7 already ensures that et+1 ≤ et . As a result, we show
that A(t+1) maintains closeness in the spectral norm-sense as required by our algorithm, i.e., that it
is still (et+1, 2)-close to the true dictionary. Also, since we use the gradient matrix in this analysis,
we show that the empirical gradient matrix concentrates around its mean.
•	Step IV.A: The empirical gradient matrix concentrates around its expectation: We first show
that the empirical gradient matrix concentrates as formalized by the following lemma.
Lemma 8 (Concentration of the empirical gradient matrix). With probability at least
(1 - 6：)- δ, - δ(tW - δgt)), kb⑴-g(t)k is upper-bounded by O*(mk∣∣A*k), where
• Step IV.B: The “closeness” property is maintained after the updates made using the empiri-
cal gradient estimate: Next, the following lemma shows that the updated dictionary A(t+1)
maintains the closeness property.
Lemma 9 (A(t+1) maintains closeness). Suppose A⑶ is (et, 2) near to A* with et =
O*(1/log(n)), and number of samples used in step t is P = Ω (mk2), then with probability
at least (1 - δT(t) - δβ(t) - δH(tW) - δg(t)), A(t+1) satisfies kA(t+1) - A*k ≤ 2kA*k.
Step V: Combine results to show the main result
Proof of Theorem 1. From Lemma 7 we have that with probability at least (1 - δT(t) - δβ(t) - δH(tW) -
δg?), gjt) is (Ω(k∕m), Ω(m∕k), 0)-correlated with A*. Further, Lemma 9 ensures that each iterate
maintains the closeness property. Now, applying Lemma 15 we have that, for nA ≤ θ(m/k), with
probability at least (1 - δa(ltg)) any t ∈ [T] satisfies
kAj(t) - Aj*k2 ≤ (1 - ω)tkA(j0) - Aj*k2 ≤ (1 - ω)te02.
where for 0 < ω < 1/2 with ω = Ω(k∕m)nA. That is, the updates converge geometrically to
A* . Further, from Lemma 3, we have that the result on the error incurred by the coefficients. Here,
16
Published as a conference paper at ICLR 2019
δ(t) = δTt) + δ((t) + δ(tW + δg? + δgt)). That is, the updates converge geometrically to A*. Further,
from Lemma 3, we have that the error in the coefficients only depends on the error in the dictionary,
which leads us to our result on the error incurred by the coefficients. This completes the proof of
our main result.	□
C Appendix: Proof of Lemmas
We present the proofs of the Lemmas used to establish our main result. Also, see Table 3 for a map
of dependence between the results, and Appendix D for proofs of intermediate results.
Table 3: Proof map: dependence of results.
Lemmas	Result	Dependence
Lemma 1	Signed-support recovery by co- efficient initialization step	—
Lemma 2	IHT update step preserves the correct signed-support	Claim	1, Lemma	1, and Claim 2
Lemma 3	Upper-bound on the error in co- efficient estimation	Claim	1, Claim	2, Claim 3, and Claim 4
Lemma 4	Expression for the coefficient estimate at the end of R-th IHT iteration	Claim 5
Lemma 5	Expression for the expected gra- dient vector	Lemma 4 and Claim 7
Lemma 6	Concentration of the empirical gradient vector	Claim 8 and Claim 9
Lemma 7	Empirical gradient vector is cor- related with the descent direc- tion	Lemma 5, Claim 7 and Lemma 6
Lemma 8	Concentration of the empirical gradient matrix	Claim 8 and Claim 10
Lemma 9	A(t+1) maintains closeness	Lemma 5, Claim 7 and Lemma 8
Claims	Result	Dependence
Claim 1	Incoherence of A(t)	-
Claim 2	Bound on βj(t): the noise com- ponent in coefficient estimate that depends on t	-
Claim 3	Error in coefficient estimation for a general iterate (r + 1)	-
Claim 4	An intermediate result for bounding the error in coefficient calculations	Claim 2
Claim 5	Bound on the noise term in the estimation of a coefficient ele- ment in the support	Claim 6
Claim 6	An intermediate result for ^(ι R calculations	Claim 3
Claim 7	Bound on the noise term in ex- pected gradient vector estimate	Claim 6 and Claim 2
Claim 8	An intermediate result for con- centration results	Lemma	2 ,Lemma 4 and Claim 5
Claim 9	Bound on variance parameter for concentration of gradient vector	Claim 5
Claim 10	Bound on variance parameter for concentration of gradient matrix	Lemma 2 , Lemma 4 and Claim 5
Proof of Lemma 1. Let y ∈ Rn be general sample generated as y = A*x*, where x* ∈ Rm is a
sparse random vector with support S = supp(x*) distributed according to D.4.
The initial decoding step at the t-th iteration (shown in Algorithm 1) involves evaluating the inner-
product between the estimate of the dictionary A(t) , and y. The i-th element of the resulting vector
17
Published as a conference paper at ICLR 2019
can be written as
hA(t), yi = hA(t), Ahx + Wi,
where Wi = (A(t), A-ix-i>. Now, since ∣∣A* - A(t)∣∣2 ≤ et and
kA： - Ait)∣2 = ∣∣A"∣2 + ∣A(t)k2 - 2hA(t), A 力=2- 2(Ait), A》
we have
|hAi(t),Ai：i| ≥ 1 - et2/2.
Therefore, the term
2
≥ (1 -昼)C , if i ∈ S,
= 0	, otherwise.
Now, we focus on the Wi and show that it is small. By the definition of Wi we have
wi =	hAi	, a	A-ix-ii	= P hAi	, a	A：ix：	= P	hAi	, a	A：ix：.
'=i	'∈S∖{i}
|hAi(t),Ai：ixi：|
Here, since var(x：) = 1, Wi is a zero-mean random variable with variance
Var(Wi)=	P hA(t),A:i2.
'∈S∖{i}
Now, each term in this sum can be bounded as,
(A(t), Ai = IhAt- A：, A：i + (A：, A：i)2
≤ 2(H- A：, A：i2 + (A：, A：i2)
≤ 2(N)- A：, A：〉2 + μ2).
Next, P (A(t) — A：, A：〉2 can be upper-bounded as
'=i
'∈P{i}hA(t)- A：,A ≤kAS∖{i}k2e2.
Therefore, we have the following as per our assumptions on μ and k,
∣AS∖{i}k2 ≤ (1 + k√n) ≤ 2,
using Gershgorin Circle Theorem (Gershgorin, 1931). Therefore, we have
P hAt - A：, A：)2 ≤ 2ei.
'∈S∖{i}
Finally, we have that
P hA(tt, A：)2 ≤ 2(2ei + kμ2) = O*(e2).
'∈S∖{i}
Now, we apply the Chernoff bound for sub-Gaussian random variables Wi (shown in Lemma 12) to
conclude that
Pr[Wi∣ ≥ C/4] ≤ 2exp(-OC^).
Further, Wi corresponding to each m should follow this bound, applying union bound we conclude
that
Pr [max ∣Wi∣ ≥ C/4] ≤ 2m exp(-。&)):= 6，.
□
18
Published as a conference paper at ICLR 2019
Proof of Lemma 2. Consider the (r + 1)-th iterate x(r+1) for the t-th dictionary iterate, where
kA(t) - A*k ≤ t for all i ∈ [1, m] evaluated as the following by the update step described in
Algorithm 1,
x(r+1) = x(r) - ηx(r+1)A(t)> (A(t)x(r) - y)
=(I - ηXr+1)A(t)> A⑶)x(r) - ηXr+1)A⑴> A*x*,	(7)
where ηx(1) < 1 is the learning rate or the step-size parameter. Now, using Lemma 1 we know that
x(0) (3) has the correct signed-support with probability at least (1 - δT)). Further, since A(t)> A*
can be written as
A(t)>A* = (A(t) - A*)>A* + A*>A*,
we can write the (r + 1)-th iterate of the coefficient update step using (7) as
x(r+1) = (I - ηx(r+1)A(t)>A(t))x(r) - ηx(r+1)(A(t) -A*)>A*x* + ηx(r+1)A*>A*x*.
Further, the j -th entry of this vector is given by
χjr+I)=(I- ηXr+I)A⑴>a㈤)(j,:)X(T)- ηXr+I)((A㈤-A*)>A*)(j.：)x*+nXr+1) (a*>a* )(j,：)x*.
(8)
We now develop an expression for the j-th element of each of the term in (8) as follows. First, we
can write the first term as
(I - ηXr+1)A⑴>A⑴)(j,：)XS) = (1 -ηXr+I))Xjr)-ηXr+1) P(屋；),a”XR
i6=j
Next, the second term in (8) can be expressed as
ηx(r+1)((A(t) - A*)>A*)(j,:)X* = ηx(r+1) PhA(jt) - Aj*, Ai*iXi*
i
= ηx(r+1)hA(jt) - Aj*, Aj*iXj* + ηx(r+1) P hA(jt) - Aj*, Ai*iXi*.
i6=j
Finally, we have the following expression for the third term,
ηXr+1)(A*τA*)(j,：)x* = ηXr+1)χ* + ηXr+1) P(a*, a*)x*.
i6=j
Now using our definition of λjt) = KAjt) - A*, A*)| ≤ 号,combining all the results for (8), and
using the fact that since A(t) is close to A*, vectors A(jt) - Aj* and Aj* enclose an obtuse angle, we
have the following for the j-th entry of the (r + 1)-th iterate, X(r+1) is given by
X(jr+1) = (1 - ηx(r+1))X(jr) + ηx(r+1)(1 - λ(jt))Xj* + ηx(r+1)ξj(r+1).	(9)
Here ξj(r+1) is defined as
ξj(r+1) := P(hAj(t)-Aj*,Ai*i+hAj*,Ai*i)Xi*-PhA(jt),Ai(t)iXi(r).
i6=j	i6=j
Since, hAj*, Ai*i - hA(jt), Ai(t)i = hAj*, Ai* - Ai(t)i + hAj* - A(jt), Ai(t)i, we can write ξj(r+1) as
ξj(r+1) = βj(t) + PhAj(t),Ai(t)i(Xi* - Xi(r)),	(10)
i6=j
where βj(t) is defined as
βj(t) := P (hAj*,	Ai*	- Ai(t)i	+	hAj*	-	A(jt), Ai(t)i	+	hA(jt)	-Aj*,Ai*i)Xi*.	(11)
i6=j
19
Published as a conference paper at ICLR 2019
Note that βj(t) does not change for each iteration r of the coefficient update step. Further, by Claim 2
We show that ∣βjt) | ≤ tβ = O(√ket) with probability at least (1 - δ(t)). Next, We define ξjr+1) as
ξjr+1) := βjt) + P IhAjt), A(t)i7-x(r)|.
i6=j
(12)
where ξj(r+1) ≤ ξej(r+1). Further, using Claim 1,
ξjr+1) ≤ tβ + √⅛kx; - Xjr)kι := ξm+1) = O(√n),	(13)
since ∣∣x(r-1) - x*kι = O(k). Therefore, for the (r + 1)-th iteration, we choose the threshold to be
τ (r+1) := (r+1)ξe(r+1)	(14)
τ : ηx	max ,
and the step-size by setting the “noise” component of (9) to be smaller than the “signal” part, specif-
ically, half the signal component, i.e.,
√r+1)ξ-(r+1) ≤ (1-ηXr+1)) X(T) + S (1 -a)C
ηx ξmax ≤	2 Xmm +	2 (I 2 )〜
Also, since we choose the threshold as T(r) := ηx(r)ξem(ra)x, x(mri)n = ηx(r) ξem(ra)x, where x(m0i)n = C/2, we
have the following for the (r + 1)-th iteration,
）出&maX+"（i -竽）c.
n(r+1)ξ-(r + 1) ≤ (1-ηXr+1)
ηx	⅛max —	2
Therefore, for this step we choose ηx(r+1) as
ηx(r+1) ≤
ηXr) e(r)
2 max
Ξ7T	72
e(r+1) + nχ e(T) _1(i _lt )c
ξmax + 2 ξmax - 2 ( - 2 )
(15)
Therefore, ηx(r+1) can be chosen as
ηXr+1) ≤ c(r+1)(et,μ,k,n),
for a small constant c(r+1)(et, μ, k, n), ηXr+1). In addition, if we set all ηXr) = ηχ, we have that 加=
Ω(√n) and therefore T(r) = T = Ω(层).Further, since we initialize with the hard-thresholding step,
the entries in |x(0) | ≥ C/2. Here, we define ξem(0a)x = C and ηx(0) = 1/2, and set the threshold for
initial step as ηx(0)ξem(0a)x.
□
ProofofLemma 3. Using the definition of ξ(') as in (12), we have
ξ(') = β(t)+ P IhAit), A(t)i∣∣x*2 - xi'-1)∣.
i26=i1
From Claim 2 we have that Iβi(t) I ≤ tβ with probability at least (1 - δβ(t)). Further, using Claim 1 ,
and letting C(') := |x* - x(') ∣ = ∣xi') - x*|, ξ(') can be upper-bounded as
ξ(') ≤ β(t) + √ P Ci2-11.	(16)
i2 6=i1
Rearranging the expression for (r + 1)-th update (9), and using (16) we have the following upper-
bound
C(r+1) ≤ (1 - ηXr+1))C(r) + ηXr+1)λit)∣x*ι ∣ + ηXr+1)ξ(r+1).
Next, recursively substituting in for C(r), where we define Q；='(1 - ηXq+1)) = 1,
C(r+1)≤ Ci(O) Q(I- ηXq+1))	+ λ(t)∣x*ι I	rP1 ηX')	r∏(1	- ηXq+1))	+ rP1 ηX')ξ(')	r∏(1	- ηXq+1)).
q=0	'=1	q='	'=1	q='
20
Published as a conference paper at ICLR 2019
Substituting for the upper-bound of ξ(') from (16),
c(r+1) ≤ α(r+1)+√⅛ ¾⅛) p e`T) r∏1a - ηXq+1)).
'=1	i2=i1	q='
(17)
Here, αi(r+1) is defined as
αi(1r+1)
C(O) Q (1 -ηXq+1)) + N)MI + β(t))rp+1 ηX')r∏1(i -ηXq+1)).
q=0
'=1	q='
(18)
Our aim now will be to express C(') for ' > 0 in terms of C(0). Let each aj') ≤ Oe) where
j = iι, i2,..., ik. Similarly, let Cj0) ≤ C(0) for j = i1,i2,...,ik, and all η(e) = ηχ. Then, using
Claim 3 we have the following expression for Ci(R+1),
R
c(R+1) ≤ α(R+1) + (k -i)ηx√Pamax(1 - &+nx√)R-e
+(k -I)小 √ Cmax(I - ηχ+ηχ √)r.
Here, (1 -加产 ≤ (1 - & + &√n)r ≤ δβ. Next from Claim 4 we have that with probability at
least (1 - δβ(t)),
R
P αmax(1 - ηx + ηx √)	≤ CnmaxRδR H 门 1 μt、( ^t NMax1 + tβ )∙
e=ι	V	ηx(1-√n)
Therefore, for Cx = √μn/(1 - √μn)
c(R+1) ≤ α(R+1) + (k - 1)cx(品xmaxI + tβ) + (R +1)(k - 1)ηx√tncmaxδR.
Now, using the definition of αi(R+1), and using the result on sum of geometric series, we have
α(R+1) = C(0)(1 - ηx)R+1 + (λ(t) IXM + β(t)) RPInx(1 -ηx)R-s+1,
s=1
=C(0)δR + λ(t) |X；1 I + β(t) ≤ C(0)δR+1 + 42 IxmaxI + tβ.
Therefore, Ci(R) is upper-bounded as
C(R) ≤ (Cxk +1)( 4t IxmaxI + tβ ) + (R + 1)knx √ Cm0a)xδR + C(O)δR.
Further, since k = O(√n∕μ log(n)), kcx < 1, therefore, we have
C(R) ≤ O(tβ) + (R +1)knx√CmaxδR + C(0)δR,
with probability at least (1 - δβt)). Here, (R + 1)knx -√nCmOaXBr + Ci00§r U 0 for an appropriately
large R. Therefore, the error in each non-zero coefficient is
Ci(1R) = O(tβ).
with probability at least (1 - δg)).	口
Proof of Lemma 4. Using the expression for xi(R) as defined in (9), and recursively substituting for
xi(r) we have
RR
X(I) = (1 - nx)RXj) + χiι Σ nx(1 - λ(1))(1 -nx)Rf + Σ nxξ(r)(1 - nx)Rf
r=1	r=1
21
Published as a conference paper at ICLR 2019
where we set all ηxr to be ηx . Further, on defining
R
机I) = P ηχξ(r)(I- ηX)Rf + γ(1),	(19)
r=1
where YiR) = (1 - ηχ)R(χi0) - x/1 - λ(t))),we have
R
X(R) = (I- ηχ)Rχ(0) + x：i(1 - λ(t))(i - (1 - ηx)R) + P ηχξ(r)(i - ηx)R-r,
r=1
=X：1 (1 - λ(t)) + MR) ∙	(20)
Note that γi(R) can be made appropriately small by choice of R. Further, by Claim 5 we have
步(R)l≤o(tβ )∙
with probability at least (1 - 6，))，where t§ = O(√ket).	□
Proof of Lemma 5. From Lemma 4 we have that for each j ∈ S,
bs := XSi) = (I- ASo)XS+4R),
with probability at least (1 - δ(Tt) - δ?). Further, let Fχ* be the event that Sign(X*) = Sign(X),
and let IFx* denote the indicator function corresponding to this event. As We show in Lemma 2,
this event occurs with probability at least (1 - δβ(t) - δT(t)). Using this, we can write the expected
gradient vector corresponding to the j-th sample as IFx*
gjt) = E[(Ait)b - y)sign(X*) — + E[(Ait)b - y)sign(X*)IFx*],
=E[(A(t)b - y)sign(X*) 1%] ± γ.
Here, Y := E[(A(t)b - y)sign(X*)IF * ] is small and depends on δ(T) and δβt), which in turn
drops with eh Therefore, Y diminishes with eh Further, since 1fx* + IF * = 1, and Ρr[Fχ* ]=
(1 - δβ(t) - δT(t) ), is very large,
gjt) = E[(A(t)X - y)sign(X；)(I- IFx*)] ± γ,
=E[(A(t)X - y)sign(X*)] ± γ.
Therefore, we can write gj(t) as
gjt) = E[(A(t)X - y)sign(X*)] ± γ,
=E[(1 - ηχ)RAS^XS0) + A(t)(I - Λ的XS + aS⅜SR)- ASXS)sign(X*)] ± γ.
Since E[(1 - ηx)RA(St)X(S0)] can be made very small by choice of R, we absorb this term in Y .
Therefore,
gjt) = E[A(t)(I - Λ(t))XS + AS⅜SR)- ASXS)sign(X*)] ± γ.
Writing the expectation by sub-conditioning on the support,
gjt) = ES[ExS Ait)(I- ASo)XSSign(x；) - ASxSSignX)+ AS秋R)Sign(x；)|s]] ± γ,
=ES Ait)(I- AS°)ExS [χSSign(X:)|S] - aSExS [χSSign(X:)|S]] + E[AS⅜SR)Sign(X；)] ± γ,
=Es[Pj(1 - A7)Ajt)- PjA；] + ∆jt) ± γ,
where we have used the fact that Ex* [Sign(x；)] = 0 and introduced
∆jt) = E[AS⅜SR)Sign(X；)].
22
Published as a conference paper at ICLR 2019
Next, sincePj = Ex5[x*sign(x*)∣j ∈ S], therefore,
gjt) = ES[pj(1 - A?)Ajt)- pj A；] + △,土 γ.
Further, since qj = Pr[j ∈ S] = O(k/m),
gjt) = qjpj((1 - λjt)) Ajt)- Aj + jδ7 ± γ).
Further, by Claim 7 we have that
k∆jt)k = O(√m%,jPj et∣∣A ㈤ k)].
This completes the proof.	口
Proof of Lemma 6. Let W = {j : i ∈ supp(x(；j))} and then we have that
b(t) =IWWi 俞 Pj (y(j)- A(t) b(j))sign(b(j)(i)),
where xb(j)(i) denotes the i-th element of the coefficient estimate corresponding to the (j)-th sample.
Here, for ` = |W | the summation
Pj ` (y(j)- A⑴b(j))sign(x(j)(i)),
has the same distribution as Σ'=1zj-, where each Zj belongs to a distribution as
Z := '(y - A⑴b)sign(bi)∣i ∈ S.
Also, E[(y - A(t)b)sign(Xi)] = qiE[z], where qi = Pr[x； = 0] = Θ(-m). Therefore, since
p = Ω(mk2), We have ' = Pqi = Ω(k3) non-zero vectors,
kb(t) - g(t)k = O(m)k∑'=ι(zj- E[z])k.	(21)
Let wj = Zj - E[Z], we will now apply the vector Bernstein result shown in Lemma 11. For this,
we require bounds on two parameters for these - L := ∣∣Wjk and σ2 := ∣∣ΣjE[∣∣Wjk2]k. Note that,
since the quantity of interest is a function of xi； , which are sub-Gaussian, they are only bounded
almost surely. To this end, we will employ Lemma 14 (Lemma 45 in (Arora et al., 2015)) to get a
handle on the concentration.
Bound on the norm ∣W∣: This bound is evaluated in Claim 8, which states that with probability
at least (1 - δβ - δT - δHW),
L ：= kwk = kz - E[z]∣ = '∣(y - A㈤X)Sign(bi)|i ∈ Sk ≤ '∣(y - A⑴b)∣ = O(竿).
Bound on variance parameter E[kwk2]: Using Claim 9, we have E[kzk2] = O(kt2) + O(kt2β).
Therefore, the bound on the variance parameter σ2 is given by
σ2 ：= k∑jE[∣Wjk2]∣ ≤ ∣∣∑jE[∣∣Zjk2]∣≤O(k∙ + O(半).
From Claim 2 we have that with probability at least (1 - 6；"), t§ = O(√ket). Applying vector
Bernstein inequality shown in Lemma 11 and using Lemma 14 (Lemma 45 in (Arora et al., 2015)),
choosing ' = Ω(k3),we conclude
k Pj=I Zj- E[z]k = O(L)+ O(σ) = o(Q),
with probability at least (1 - δg?), where δg? = exp(-Ω(k)). Finally, substituting in (21) we have
kb：—=o( m )。&).
with probability at least (1 - δg? - 6；)- 6#)- δ(tW).	口
23
Published as a conference paper at ICLR 2019
Proof of Lemma 7. Since we only have access to the empirical estimate of the gradient gbi(t), we will
show that this estimate is correlated with (Ajt) - A；). To this end, first from Lemma 6 We have that
the empirical gradient vector concentrates around its mean, specifically,
kb(t) - g(t)k≤ o(mket),
with probability at least (1 - δg(ti) - δβ(t) - δT(t) - δH(tW) ). From Lemma 5, we have the following
expression for the expected gradient vector
gjt) = Pj qj (Ajt)- Aj)+ Pj qj (-λjt Aj + j δ'± Y) ∙
Let gjt) = 4p_(Ajt) - A；) + v, where 4ρ = Pjqj∙ and V is defined as
V =Pjqj(-λjt)Ajt) + j∆jt) ± γ).	(22)
Then, gbi(t) can be written as
gbi(t) = bgi(t) - gi(t) + gi(t),
=(b(t)- g(t)) + 4P-(Ajt)- A；) + v,
= 4ρ( Ajt)- A；)+ e,	(23)
where e = V + (b(t) - g(t)). Letkek ≤ p_|| A(t) - A； ∣∣. Using the definition of V as shown in (22)
we have
kek≤ qjPjλjt)kAjt)k + k∆jt)k + o(mket)± γ.
Now for the first term, since IlAjt)k = 1, we have λjt) = ∣hAjt) - A；, A；)| = 21∣ Ajt) - A；k2,
therefore
qjPjλjt)kAjt)k = qjPj2kAjt) - A；k2,
Further, using Claim 7
k∆jt)k = O(√m%,j Pu et∣∣A㈤k).
Now, since kA(t) - A； k ≤ 2kA； k (the closeness property (Def.1) is maintained at every step using
Lemma 9), and further since k A； k = O(，m/n), we have that
kA⑴k≤ kA㈤-A*k + ∣∣A*k = O*).
Therefore, we have
kSt)k + o( mk et) ± γ = O (VmqijPijtk A㈤k).
Here, we use the fact that γ drops with decreasing t as argued in Lemma 5. Next, using (23), we
have
kb(t)k≤ 4ρk Ajt)- A；k + kek.
Now, letting
k∆jt)k + o(mket) ± γ = Ο(√mqi,jPiιetkA(t)k) ≤ 粤|时)-A；k,	(24)
we have that, for k = Ο(√n)
kVek ≤qiPikA(jt) -Aj；k.
Substituting for ∣∣ek, this implies that ∣∣g(t)jk2 ≤ 25ρ2kAjt) - A；k2. Further, we also have the
following lower-bound
hbjt), Ajt) - A；)≥4ρ∣∣Ajt)- A；k2 -kekkAjt) - A；k.
24
Published as a conference paper at ICLR 2019
Here, We use the fact that R.H.S. can be minimized only ifve is directed opposite to the direction of
Ajt) - A*. Now, we show that this gradient is (p_, 1 / 100p_, 0) correlated,
hb(t), Ait)-A*〉-ρkA(t) - A*k2 — ɪkb(t)k2,
≥ 4P∣A(t) - A*k2 -ke∣kA(t) — A*∣ - ρ∣A(t) - A*∣2 — ɪkb(t)k2,
≥ 4P∣A(t) — A*k2 — 2ρkAit)- A"∣2-
≥ PkAit)- A*k2 ≥0.
25p2 kAit)-A/∣2
100ρ
Therefore, for this choice of k, i.e. k = O(√n), there is no bias in dictionary estimation in compar-
ison to Arora et al. (2015). This gain can be attributed to estimating the coefficients simultaneously
with the dictionary. Further, since we choose 4p_ = Pjqj∙, we have that p_ = θ(k/m), as a result
P+ = 1∕100ρ = Ω(m∕k). Applying Lemma 15 we have
kAjt+1) - A*k2 ≤ (1-ρηA)kAjt)- A*k2,
for ηA = O(m/k) with probability at least (1 - δT(t) - δβ(t) - δg(ti))
□
Proof of Lemma 8. Here, we will prove that bg(t) defined as
bg(t) = Pj(y(j) - A(t)xb(j))sign(xb(j))>,
concentrates around its mean. Notice that each summand (y(j) - A(t)xb(j))sign(xb(j))> is a random
matrix of the form (y - A(t)xb)sign(xb)>. Also, we have g(t) defined as
g(t) = E[(y - A(t)xb)sign(xb)>].
To bound ∣gb(t) - g(t) ∣, we are interested in ∣ Pjp=1 Wj ∣, where each matrix Wj is given by
Wj = P (y(j) — A(t)bCj))Sign(bCj))T — 1 E[(y - Aob)Sign㈤>].
Noting thatE[Wj] = 0, we will employ the matrix Bernstein result (Lemma 10) to bound ∣gb(t) -
g(t) ∣. To this end, we will bound ∣Wj ∣ and the variance proxy
v(Wj)=max{∣ Pjp=1E[WjWj>]∣,∣ Pjp=1E[Wj>Wj]∣}.
Bound on ∣∣Wj ∣∣- First, We can bound both terms in the expression for Wj by triangle inequality
as
IIWjk ≤ Pk(y(j) - A(t)b(j))sign(b(j))>k + PkEqy - A(t)b)sign(b)>k,
≤ P k(y - A(t)b)sign(x)>k.
Here, we use Jensen’s inequality for the second term, followed by upper-bounding the expected
value of the argument by k(y - A(t)xb)Sign(xb)> k.
Next, using Claim 8 we have that with probability at least (1 - δβ(t) - δT(t) - δH(tW) ), ky - A(t)xbk is
O(ktβ), and the fact that kSign(x)T k = k,
kWjk ≤ 2√kk(y — A(t)b)k = o(k√ktβ).
Bound on the variance statistic V(Wj)- For the variance statistic, we first look at
k P E[WjWj>]k,
E [Wj W>] = p2 E[(y(j) — A(t)b(j))sign(b(j))> — E[(y — A(t)x)sign(b)>]
× [Sign(xb(j))(y(j) - A(t)xb(j))> - (E[(y - A(t)xb)Sign(xb)>)>].
Since E[(y - A(t)xb)Sign(xb)>]E[(y - A(t)xb)Sign(xb)>]> is positive semidefinite,
E[WjW>] W P12E[(y(j) — A(t)X(j))sign(b(j))>sign(b(j))(y(j) — A(t)b(j))>].
25
Published as a conference paper at ICLR 2019
Now, since each xb(j) has k non-zeros, sign(xb(j))>sign(xb(j)) = k, and using Claim 10, with proba-
bility at least (1 - δT(t) - δβ(t) )
k P EWjW>]k ≤ PkE[(y(j) - A㈤b(j))(y(j) - A㈤bj))>]k,
k3t2
=0(京)kA*k2.
Similarly, expanding E[Wj>Wj], and using the fact that E[(y - A(t)xb)sign(xb)>]>E[(y -
A(t)xb)sign(xb)>] is positive semi-definite. Now, using Claim 8 and the fact that entries of
E[(sign(xb(j))sign(xb(j))>] are qi on the diagonal and zero elsewhere, where qi = O(k/m),
k PE[W>Wj]k W 1 kE[(sign(b(j))(y(j)- A㈤b(j))>(yj) - A(t)X(j))sign(x(R))>]k,
≤ P||E[(sign(b(j))sign(b(j))T]kky(j)- A㈤b(j)k2,
≤ 0( ɪ )O(k2t2) = 0( k3tβ).
mP	β	mP
Now, we are ready to apply the matrix Bernstein result. Since, m = O(n) the variance statistic
comes out to be 0(km)| A*∣∣2, then as long as We chooseP = Ω(mk2) (using the bound on t§),
with probability at least (1 - δβ(t) - δT(t) - δH(tW) - δg(t))
kb㈤-g㈤k ≤O(k√ktβ) + ∣∣A*kJθ(膏),
=o*( m kA*k).
where δgt) = (n + m) exp(一Ω(mplog(n)).
□
Proof of Lemma 9. This lemma ensures that the dictionary iterates maintain the closeness property
(Def.1) and satisfies the prerequisites for Lemma 7.
The update step for the i-th dictionary element at the s + 1 iteration can be written as
A(t+1)- Ai = Ait)- Ai - ηAg(t∖
=Ait) - A - ηAg(t) - ηA(b(t) - g(t)).
Here, gi(t) is given by the following as per Lemma 5 with probability at least (1 - δT(t) - δβ(t))
g(t) = qiPi(Ait)- A；) + qiPi(~λ(ttA(tt + 康δP ± Y).
Substituting the expression for gi(t) in the dictionary update step,
Ait+I)- Ai =(I- ηAPiqi)(A(t) - AT)- ηAPiqXtAt- DaN, - ηA(b(t - g(t)) ± Y,
where ∆jt) = E[A(t)H(R)Sign(x；)j. Therefore, the update step for the dictionary (matrix) can be
written as
A(t+1) - AT= (A(t) - AT)diag((1 - ηAPiqi)) +ηAU - ηAV ± γ - ηA(gb(t) - g(t)),	(25)
where, U = A(t)diag(Piqiλi(t)) and V = A(t)Q, with the matrix Q given by,
Qij = qi,j ExS 田 (R)Sign(x；)[S],
and using the following intermediate result shown in Claim 7,
ExS就R)Sign(x；)1S] (≤ Y(R),	fori =j,
S i	j = 0(Pjt),	for i 6= j,
we have kQik = O(√mqi,jPiet). Hence, we have
kQkF ≤ 0(mqi,jPit).
26
Published as a conference paper at ICLR 2019
Therefore,
kVk ≤ kA㈤Qk ≤ kA⑴kkQkF = O(mqi,jPietkA*∣∣) = O(m⅛y)∣∣A*∣∣.
We will now proceed to bound each term in (25). Starting with (A(t) - A* )diag(1 - ηAPiqi), and
using the fact that Pi = O⑴,qi = O(k∕m), and ∣∣ A(t) - A*k ≤ 2∣∣A*k, we have
k(A(t) - A*)diag(1 - ηAPiqi)k ≤ (1 - min ηAPiqi)k(A(t^ - A*)k ≤ 2(1 - Ω(ηak∕m))k A*∣∣.
i
Next, since IlAjt)k = 1, we have λjt) = KAjt) - A*, A*i∣ = 2∣∣A(t) - A*k2, and λ(t) ≤ e2∕2,
therefore
IIUk = IIAmdiag(Piqiλ(t))k ≤ maxPiqiIkA(t) - A* + A*k ≤ o(k∕m)∣∣A*∣∣.
i
Using the results derived above, and the the result derived in Lemma 8 which states that with prob-
ability at least (1 - Set)- δT)- δ(tW - δgt)), kb㈤-g㈤ k = O*( mk ∣∣A*k)) we have
kA(t+1)-A*k = k(A(t) - A*)D(1-ηApiqi)k + ηAkUk + ηAkVk + ηAk(bg(t) - g(t))k ± γ,
≤ 2(1 - Ωgm)kA*k + ogm)kA*k + O(ηAm⅛y)kA*k + o(ηA^∣A*k) ± γ,
≤ 2kA*k.
□
27
Published as a conference paper at ICLR 2019
D	Appendix: Proofs of intermediate results
Claim 1 (Incoherence of A(t)). If A* ∈ Rn×m is μ-incoherent and ∣∣ A* 一 A(t)k ≤ et holds for
each i ∈ [1... m] ,then A(t) ∈ Rn×m is μt -incoherent, where μt = μ + 2√net.
Proof of Claim 1. We start by looking at the incoherence between the columns of A*, for j 6= i,
hAi*, Aj*i = hAi* 一 Ai(t), Aj*i + hAi(t), Aj*i,
=(A* - A(t), A*i + hA(t), A* 一 Ajt)i + hA(t), A”
Since (A*, A*〉≤ √,
|hAi(t),A(jt)i| ≤ hAi*, Aj*i 一 hAi* 一 Ai(t), Aj*i 一 hAi(t), Aj* 一 A(jt)i,
≤ √n + 2et.
□
Claim 2 (Bound on βj(t): the noise component in coefficient estimate that depends on et). With
probability (1 — δ?), ∣βjt)∣ is upper-bounded by tβ = O(√ket), where δ* = 2k exp(-O(L)).
Proof of Claim 2. We have the following definition for βj(t) from (11),
βj(t) = P (hAj*, Ai* - Ai(t)i + hAj* -A(jt),Ai(t)i+hA(jt)-Aj*,Ai*i)xi*.
i6=j
Here, since xi* are independent sub-Gaussian random variables, βj(t) is a sub-Gaussian random vari-
able with the variance parameter evaluated as shown below
var[βj(t)] = Pi6=j (hAj*, Ai(t) - Ai*i + hA(jt) - Aj*, Ai(t)i + hA(jt) -Aj*,Ai*i)2 ≤ 9ket2.
Therefore, by Lemma 12
Pr[∣βjt)∣ >tβ] ≤ 2exp(-岛)∙
Now, we need this for each βj(t) for j ∈ supp(x*), union bounding over k coefficients
Pr[max ∣βj(t)∣ > tβ] ≤ δβ(t),
where Set) = 2k exp(- 18^). Choosing tg = O(√ket), We have that δe = 2k exp(- o(l-ɔ). 口
Claim 3 (Error in coefficient estimation for a general iterate (r + 1)). The error in a general
iterate r of the coefficient estimation is upper-bounded as
C(r+1) ≤ α(r+1) +(k-1)小 √n p atix(1- ηχ+ηχ √n),—
+(k-1)&√n CmaX(I -加+& √n)，
Proof of Claim 3 . From (17) we have the following expression for Ci(r+1)
c(r+1) ≤ α(r+ι)+养 ρ⅛) PCF rQ1(1 - ηxq+1)).
'=1	i2=i1	q='
Our aim will be to recursively substitute for C('-1) to develop an expression for C(：+1) as a func-
tion of Cm0 ax. To this end, we start by analyzing the iterates Ci(1), Ci(2), and so on to develop an
expression for Ci(r+1) as follows.
28
Published as a conference paper at ICLR 2019
Expression for C(I) - Consider C(I)
C⑴	⑴ I μt P P c('T)
Cii ≤ αiι + √n Tnx 工 Ci2
'=1	i2=i1
=α(I) + nx(√ P C(0)).
i1 6=i2
1
Q(1-ηx),
q='
(26)
Expression for C(2)-Next, C(2) is given by
22
C(2) ≤ α(2) + ηx√ P P C'T)Q (1-nx),
'=1 i2=i1	q='
≤ * + ηx √ ( P C(I) + P C(O)(I-ηx)).
i26=i1	i26=i1
Further, we know from (26) we have
C(I) = α(I) + ηx器 P CO).
i3 6=i2
Therefore, since P P = P ,
i26=i1 i36=i2	i36=i2 ,i1
C(I2)≤ 叱)+ ηx √ ( P (α(I) + ηx √ P C(O)) + P C(O)(I-ηx)),
i2 6=i1	i36=i2	i26=i1
=α(2)+ηx√n	P	α(I)+ηx√n(ηx√n	P	C(O)	+ P	C(O)(I-ηX)).	(27)
i2 6=i1	i3 6=i2 ,i1	i26=i1
Expression for C(3)-Next, We writing 或),
C(3) ≤ 斓)+ ηx√ P3= P C(T)(I- ηx尸,
i26=i1
=*+ ηx恭 P (C(O)(1-ηx)2 + C(I)(1-ηx) + Cd,
i26=i1
≤ α(3) + ηx器 P (C(O)(1-ηx)2 + (α(I) + ηx√ P C(O))(I-ηx) + ”.
i26=i1	i3 6=i2
Here, using (27) we have the following expression for Ci(2)
C2)≤ α(2) + ηx√ P α(I) + ηx器(ηx√ P C(O) + P C(O)(I-ηx)).
i3 6=i2	i46=i3 ,i2	i3 6=i2
Substituting for Ci(2) in the expression for Ci(3), and rearranging the terms in the expression for Ci(3),
we have
C(3) ≤ α(3) + ηx黄 P	α(2)	+	ηx器((1	-	ηx)	P *) +	ηx隽	P	*))
i26=i1	i26=i1	i3 6=i2 ,i1
+ ηx√ ((1 - ηx)2	P	C(O)+ 2(1-ηx)(ηx√)	P	C(O)+	(ηx√)2	P	C(O)).
i26=i1	i3 6=i2,i1	i46=i3 ,i2,i1
(28)
Expression for C(4)-Now, consider。(？
或) ≤ 斓) + ηx√ P4=ι Pi2=i1 C('-1)(1 - ηx)4-',
≤ α(4)+ηx √n (Pi2=i1 C(O)(I- ηx)3+Pi2=i1 Ci(I)(I- ηx)2+Pi2=i1 C(2)(1 - ηx)1
+Pi26=i1Ci(23)(1-ηx)O).
Substituting for Ci(3) from (28), Ci(2) from (27), Ci(1) using (26), and rearranging,
c(4)≤	α(4)+ηx√n	P	α(3)+	((I-ηX)I Pi2=i1	α(2)+ηx√n	P	α(2))
i2 6=i1	i3 6=i2 ,i1
29
Published as a conference paper at ICLR 2019
+ ( P αi1 (i-%)2 + 2ηx√⅛(i - %) P 。(？ +(加√⅛)2	P -
i2≠i1	i3=i2,i1	i4=i3,i2,i1	.
+η√n [ p C(O)(Ii)3+3%√⅛(1 -加)P CO)
L⅛2≠iι	i3=i2,i1
+ 3⅛c器)2(i-ηx)1 P	C(O)+ d恭)3	P	或).
i4=i3,i2,i1	i5 =i4,i3,i2 ,i1	.
Notice that the terms have a binomial series like form. To reveal this structure, let each αj') ≤ @焉X
where j = i1,i2,...,ik. Similarly, let C胃 ≤ CmaX for j = i1, i2,..., ik. Therefore, We have
C(Ii) ≤ *)+ ηx√⅛ (k - 1)a(3) + a(2) ^(1 - ηx)1(k - 1) + ηx√(k - 2))
+ α(I) ((k - 1)(1 - ηx)2 + 2(k - 2)ηx器(1 - ηx) + (k - 3)(ηx器)2)]
+ηχ√nC(O) (k -I)(I- %)3+3(k - 2)ηχ√n(I- %)2
+3(k - 3)(ηχ√n)2(1 -ηχ)1 + (k -4)(&√n)3.
Further upper-bounding the expression, we have
C(Ii) ≤ αi? + (k - 1)ηx√n a(3) + «(2) ((1 - ηx) + ηx√⅛)
+ αiI) ((1 - ηj + 2ηχ √⅛(1 - ηχ)+ 仇 √⅛)2)
+ (k - 1)ηx√⅛C(0) (1 - ηχ)3 + 3ηx√(1 - ηx)2 +3(ηx√)2(1 - ηx) + (ηx√)3 .
Therefore,
C(Ii) ≤ a(? + (k - 1)ηχ√n «(3)+α(2)(1 - IIX + ηχ√n)1 + α(I)(I - IIX + IIX√『
+ (k - 1)ηx恭C(0)(1 - ηχ + ηχ器)3.	(29)
Expression for C(：+1)- With this, we are ready to write the general term,
C(I+1) ≤ *+1) + (k- 1)ηχ √⅛ P ^maX α- ηχ+ηχ √⅛ )r -
+(k- 1M √⅛ CmaX(I - ηχ+ηχ √⅛ )r.
□
Claim 4 (An intermediate result for bounding the error in coefficient calculations). With prob-
ability (1 —砰)一δ(t)),
R
P αm∖x(1 - ηx + ηx √⅛)	≤ Ci RSR + J μt)(爰 IXmaXl + tβ )∙
'=ι	V	nx(1-√n)
ProofofClaim 4. Using (18), the quantity a(') is defined as
`
αf) = C(0)(1 - ηχ)' + (W)|x" + 的))P η,(1 - η,)一1.
s=1
30
Published as a conference paper at ICLR 2019
Therefore, we are interested in
PICi(0)(1 - ηχ)'(ι - ηχ+ηχ√)R-'
R	'
+ (λ(t)∣χ" + β(t)) PQ-ηχ + ηχ√)	P ηχ(i- ηx)'-s+1.
'=1	n	s=1
Consider the first term which depends on C(O). Since (1 -加)≤ (1 - & + 加 √μn) ,we have
R
Ci	P (I-	ηX)'(1 -	ηx + ηx √n)	≤	Ci	R(I- ηx	+ ηx √√n)	≤	Ci	RδR,
where δRis a small constant, and a parameter which determines the number of iterations R required
for the coefficient update step. Now, coming back to the quantity of interest
R
Σ α(')(ι - ηx + ηx √n) - ≤ CFRδR
R	` ` '
+ (λ(t)∣χ" + β(t)) P(i-ηχ + ηχ√)	P ηχ(i- ηx)'-s+1.
'=1	n	s=1
`
Now, using sum of geometric series result, we have that P ηχ(1 - ηχ)'-s+1, and
s=1
PL(i-ηχ + ηχ √n )r-'
ι-(1-ηχ+ηχ √n )R
μt
ηχ-ηχ 3
≤	1μττ.
ηχ(1-√n)
Therefore, with probability at least (1 - δβ(t)),
R
P amax(1 - ηx + ηx √n)	≤ Ci RδR +
1
ηχ(1-√√n)
2
(号 |xm&x|+tβ),
where λ(t) ≤ 鬓 and ∣β(t) | = t§ with probability at least (1 - δ(t)) using Claim 2.
□
Claim 5 (Bound on the noise term in the estimation of a coefficient element in the support).
With probability (1 — δS)), each entry H(R) of H(R) is upper-bounded as
WR) l ≤o(tβ).
Proof of Claim 5. From (19) Hi(R) is defined as
R
Hi(1 ) := P ηxξi(1r)(1 - ηx)R-r + γi(1 ),
r=1
where YiR) := (1 - &)R(Xi0) - XM(I - λ(7)). Further, ξf) is as defined in (10),
ξ(r) = βit) + P KAit), A(t)ilSign((Ait), Ait) i)C(r-1)sign(χ*2 - χ(r)).
i2 6=i1
Therefore, we have the following expression for Hi(R)
R
Hi(1) =βi(1) P ηx(1 - ηx)R-r
r=1
R
+ P ηx P |hAi(1), Ai(2)i|sign(hAi(1), Ai(2)i)Ci(2r- )sign(χiM2 - χi(2r))(1 -ηx)R-r +γi(1).
r=1	i2 6=i1
(30)
31
Published as a conference paper at ICLR 2019
Now MR) can be upper-bounded as
R	R
婷 ≤ * P 加(1 -加)RT + ηχ器 P PeI CL(I-MRT + Y(R),
r=1	r=1
R
≤ β(? + (k -1)%:辑 P CL(I-ηx)J + Y(R).
r=1
Since from Claim 6 we have
r— 1
C：T)(I-MRt ≤ (λm∖∣χmaxl + <L) [ P ηχ(i- MRT + kcx(i - ηx)R-r]
s=1
+kn： √n CmaXδR-2.
Further, since 1 - (1 - ηx)r-1 ≤ 1, we have that
R r — 1	R	r-ι	R	1
P P ηχ(1- MJ= P ηχ(1-&)R—r+11—(17X)	≤ P (1 - nx)R—r+1 ≤ ɪ.
r=1s=1	r=1	r=1
Therefore,
WR)I ≤ ∣*∣+(k -1)√⅛ (λmax%ax∣ + ∣βmax∣)(1+―+M 养)2RCmaXδ~+Y(R).
Now, since each ∣β(t)∣ = tβ with probability at least (1 - 6；)) for the t-th iterate, and k =
O*( μ Kn)), therefore kcx < 1, we have that
步(R)∣≤o(tβ).
with probability at least (1 - δβt)	口
Claim 6 (An intermediate result for HiR) calculations). For CX = √μn/(1 - -√n), we have
r—1
c(：T)(I-ηχ)Z≤ (λ(maχ∣xmaχ∣ + e(ɪ) P %(1- MRT + kc：(1 -ηX)Rf
L s=1	_
+knχ √n CmaX6r-2.
ProofofClaim 6. Here, from Claim 3 we have that for any i1,
C(II) ≤ α(r+1) + kηχ√n PamaX(1 -ηχ + ηχ√⅛YT + kηχ√CmaX(I- ηχ + ηχ√)，
therefore C(r—1)
is given by
r—2
1+kη √nP amax(1 - ηχ+ηχ √⅛ y	+kηχ √ CmaX。- &+& √),
C(r—1) ≤ a(r—1)
i2	— i2
Further, the term of interest C(r-1)(1 - ηχ)R—r can be upper-bounded by
r—2
c(:T)(I- ηx)R-r≤ α(rT)(1 - ηχ产r+(1 - ηχ4RTkηχ器 P «^(1 - η + η√⅛厂”2
+ kηχ√nCmaX(1-ηχ + ηχ器YT(I-ηχ)RT.
(2)	(r—1)
From the definition of ai ' from (18), * can be written as
α(rT)
r—1
CmaX(I - nx)r—:L+(XmaXIXmax ∣+βmtax) P &(I- &厂—s
s = 1
Therefore, we have
α(rT)(I- ηχ)J
r—1
CmaX(I- nx)R—1+(λmax%ax∣+(如 P 9ɑ -加)RT
s = 1
32
Published as a conference paper at ICLR 2019
Next, to get a handle on 01^ (1 - ηχ + ηχ√μn)r ' 2, consider the following using the definition of
α(' from (18), where ηXi) = ηχ for all i,
rr
P ^max(1-ηχ + ηχ√n),	=P CmaX(I - ηx)'(1 - ηx + ηx√n)r
r	'
+ (XmaXIXmaXι+βmax) P (1 - ηχ+ηχ√n)	P ηχ(I- ηχ)'-s+1,
'=1	V	s=1
rr
≤ P	CmaX(I -	ηx +	ηx √n)	+ (XmaxUax1	+	βmax)	P (1 - ηx	+ ηx √).
'=1	V	'=1	V
Therefore,
r-2	r-2
(1 - ηX)R-r PamaX(1 - ηχ + ηχ养)r	≤ PCm)a*(1 - ηx + ηx√)r-2(1 - ηX)R-r
r-2
+ (λmax∣xmax∣ + βmax)(1 - ηX)R-r P(I- ηχ + η 恭)
≤(R- 2)Cmax(1 -ηχ+ηχ√n)r 2+(XmaXIXmaxι+βmax)(I-”：兀].
nx(1-√n)
Therefore,
r-2
(1 - ηχ)R-r P α
2=1
max(1 - ηx + ηx√)r - 2
≤ (『-2)Cmax(1 - ηχ+ηχ √)R-2+(λmax ∣xmax∣+βmax)(1-；：%：
V	nx(1-√n)
Further, since (1 - ηx) ≤ (1 - ηx + ηx器),
kηχ√nc(2x(ι - ηχ+ηχ√n)"2(1 - ηχ)R-r ≤ kηχ√nC-X―一.
Therefore, combining all the results We have that, for a constant CX = √μn/(1 - √μn)：
CrT)(I- ηχ)R-r
≤ (江％ax
/ ∖	"r-1
I + βmax) P ηx(1 - ηx)R-S + kcχ(1 - ηχ)R-r
_ s=1
+kηχ √n CmaX δR-2∙
□
Claim 7 (Bound on the noise term in expected gradient vector estimate). ∣∣∆jt) ∣∣ where
E[A(t)H(R)Sign(x；)] is upper-bounded as,
□Ri = O(√mqi,j Pj etkA(t)k)].
ProofofClaim 7.
∆jt) = E[A(t)H( R)Sign(x；)] = ES [A 悭 EXS 田，SignX)|S]]
From (30) we have the following definition for HjR)
R
H(R)= βj)+ P ηx P KAj), A( )∣sign(hAj), A( ))C(r-I)Sign(x； - x(r))(1 - ηX)R-r+ 铲,
r=l	i=j
where βjt is defined as the following (11)
βjtt = P (hA；, A； - A)) + hA； - Ajt), Af)〉)x； + Pi=j(A7 - A；, A；〉x；.
i=j
33
Published as a conference paper at ICLR 2019
Consider Exa [^SR)sign(x*)|S], where HSR) is a vector with each element as defined in (30). There-
fore, the elements of the vector Ex* 田SR)Sign(x；)[S]] are given by
Ex* [H(R)SignX)|S] = (ExS 嵋)sign⑹1S]，for i= j，
S	Exs m jasign(x；)|S], for i = j.
Consider the general term of interest
Exs m(R)Sign(x； )|S]
R
≤ P ηx(1 — ηx)Rf Exs [βiSign(x*)∣S]
r = 1	、	{z	/
*
R
+ √ Xηχ(1 - ηχ)R-r Ps=i ExS[cSrT)Sign(x； -Xsr))SignX)IS], +γ(R).
r = 1	|	{z	'
.
Further, since
Ex*S[xi；Sign(xj；)|S] = 0p,j, ffoorr ii 6== jj,,
we have that
* = ExS [β(t)Sign(x; )IS] ≤ {3pj et，for i= j	(31)
, or i = j.
Further, for 4s := Ex* [CsrT)Sign(x； - Xsr))Sign(x；)|S] We have that
〜=(ExS [Cjr-1)(x； — x(rT))Sign(x；)|S] ≤ CyT), for S= j
s	0,	for s 6= j.
In addition, for Ps=i M we have that
P ▲ = (c(r-1), for i= j
s6=i s 0, for i = j.
(32)
Therefore, using the results for * and P Ms, we have that Ex* [H(jR)Sign(xj；)|S] = γi(R) for i = j,
s6=i
and for i 6= j we have
Ex*S [Hi(R)Sign(xj；)|S]
R
≤ 3Pjet + √tn P ExS[C(I)Sign(x； — Xjr))Sign(x；)|S]ηx(1 — ηx)R-r + Y(R),
r=1
R
≤ 3pjet + √n P CjrT)ηχ(1 — ηx)R-r + Y(R).	(33)
r=1
Here, from Claim 6, for Cx = -√n / (1 一 -√n) we have
Cj(r-1) (1 — ηx)R-r
r-1
≤ -maxUax1 + βmaX) P ηx(I -ηX)R-S + kcx(1 — ηx)R-r + kηx √n CmaX"-2.
s=1
Further, due to our assumptions on sparsity, kcx ≤ 1; in addition by Claim 2, and with probability
at least (1 — δ?) we have ∣βmtaχ∣ ≤ tβ, substituting,
R
P Cj(r-1)ηx(1 — ηx)R-r
r=1
34
Published as a conference paper at ICLR 2019
R	r-1	R
≤ (，max|xmax| + -miX) P ηχ P ηχ(I- ηX)R + kcx P ηχ(1 - ηχ)R	,
r=1	s=1	r=1
≤ (λmixιxmaxι+tβ)(I+kcχ),
= O(tβ),
with probability at least (1 - δβ(t)). Combining results from (31), (32) and substituting for the terms
in (33) using the analysis above,
ExS 初R)SignX) |S] ( ≤ ；；； + ɪ + (R) = O(	) for i = j,
I≤ 3pjtt + √ntβ + γi	=O(Pjct), for i = j.
Note that since Y(R) := (1 -加)R(X(O) - x*(1 - λ(t))) can be made small by choice of R. Also,
since Pr[i, j ∈ S] = qi,j, we have
k∆jt) II = IIES ASt)ExS 般)sign(x； )∣S]]k,
≤ O(VmqijpjetkA(t)k).
□
Claim 8 (An intermediate result for concentration results). With probability (1 - δβ(t) - δT(t) -
δH(tW) ) Iy - A(t)xbI is upper-bounded by Oe(ktβ) .
Proof of Claim 8. First, using Lemma 4 we have
biι ：= XiR) = x：i(一沿 + 端.
Therefore, the vector bs, for S ∈ SuPP(X*) can be written as
XS := XSR) = (I- Λ的XS + 4R),	(34)
where xb has the correct signed-support with probability at least (1 - δT ) using Lemma 2. Using this
result, we can write Iy - A(t)xXI as
ky - A(t)X|| = ∣ASxS - ASt)(I- Λ的XS - ASM].
Now, since ASt) ≤ 号 We have
ky - A(t)Xk ≤ ∣ASxS - (1 - 42)ASt)XS - A的SR],
=k ((1 - 42)(AS - ASt)) + 42AS) xS - A..SR) k.
'----------------{z-----------}	'—{z—}
*	■
With XS being independent and SUb-GaUSsian, using Lemma 13, which is a result based on the
Hanson-Wright result (Hanson and Wright, 1971) for sub-Gaussian random variables, and since
kASt)- AS k≤ kASt)- AS If ≤√ket,we have that with probability at least (1 - δHStW) )
k*xSk = k((1 - 42)(AS - ASt)) + 42AS)xSk ≤ O(k(1 - 42)(AS - ASt)) + 42AS∣f),
where δHW = exP(- ο(⅛).
Now, consider the k制IF, since ∣∣ASt) - AS∣∣f ≤ √ket
k*kF ：= k(1 - W )(AS - AW)) + 42 AS kF ≤ (1 - 42 )k(AS - AglF + 42k AS ∣∣f ,
≤ √k(1 - 4t )et + 4t IIaS IIf .
Consider the ∣∣4k term. Using Claim 5, each HjR) is bounded by O(tβ). with probability at least
(1 - δβSt)) Therefore,
∣*∣ = kA— ≤ kA-∣∣M(R)k = kA*∣√kθ(tβ).
35
Published as a conference paper at ICLR 2019
Again, since kASt)- AS∣∣ ≤ kASt)- AS∣∣f ≤ √ket,
kASt)k ≤ ∣ASt)- AS + ASk ≤ ∣ASt)- ASk + kAS∣ ≤ √ket + 2.
Finally, combining all the results and using the fact that k AS ∣f ≤ √kkASk ≤ 2√k,,
ky - A ⑴ bk = O(√k(i -亨)et + e2 √k) + kAS)k√ko(tβ),
= Oe(ktβ).
□
Claim 9 (Bound on variance parameter for concentration of gradient vector). For z := (y -
A(t)xb)sign(xbi)|i ∈ S the variance parameter E[kzk2] is bounded as E[kzk2] = O(kt2 ) + O(kt2β)
with probability at least (1 - δβ(t) - δT(t)).
Proof of Claim 9. For the variance E[kzk2], we focus on the following,
E[kzk2] = E[k(y - A(t)xb)sign(xbi)k2|i ∈ S].
Here, xbS is given by
X = (I- Λ(t))xS 十 &SR).
Therefore, E[kzk2] can we written as
E[k(y - A(t)xb)sign(xbi)k2|i ∈ S]
=E[k(y - A(t)(I - Λ(t))xS - AS⅜SR))sign(bi)k2∣i ∈ S],
≤ E[k(AS - A(t)(I - Λ(t)))xSk2∣i ∈ S] + E[kAS°∙SR)Sign(Xi)k2∣i ∈ S]. (35)
x-------------------{----------------} X--------------{-------------}
。	♦
We will now consider each term in (35) separately. We start with B. Since XSS are conditionally
independent of S, E[xSXS ] = I. Therefore, we can simplify this expression as
B ：= E[k(AS - A(t)(I - Λ(t)))xSk2∣i ∈ S] = E[kAS - A(t)(I - Λ(t))kF|i ∈ S].
Rearranging the terms we have the following for B,
B = E[kAS - A(t)(I - Λ(t))kF|i ∈ S] = E[kASΛ(t) + (AS - AS°)(I- Λ(t))kF|i ∈ S].
Therefore, B can be upper-bounded as
B ≤ E[kASΛ(t)kF|i ∈ S] + E[k(AS - AS°)(I- Λ(t))kF|i ∈ S]
x-------------y--------} x----------------{----------------}
+ 2E[kASΛ(t)kFk(AS - AS°)(I- Λ(t))kF|i ∈ S].
V---------------------{----------------------}
Q 3
(36)
For Bi, since k ASt)k ≤ √ket + 2, we have
Bi ：= E[kASΛ(t)kF|i ∈ S] ≤ E[kASkkΛ(t)kF『∈ S] ≤ IAk Pj∈S(λjt))2 ≤ k(√ket + 2)学.
Next, since (1 - λ(jt)) ≤ 1, we have the following bound for B2
B2 ：= E[k(AS - AS°)(I- Λ(t) )kF |i ∈ S] ≤ E[kAS - AS0 kF『∈ S] ≤ IA - A(t)kF ≤ 屣2 ∙
Further, B3 can be upper-bounded by using bounds for Bi and B2. Combining the results of upper-
bounding Bi, B2, and B3 we have the following for (36)
B ≤ E[k(AS - A(t)(I - Λ(t)))xSk2∣i ∈ S] = O(ke2).
36
Published as a conference paper at ICLR 2019
Next, by Claim 5, IOjR) is upper-bounded as W(R)I ≤ O(tβ). with probability (1 - δ(t)). Therefore,
the term ♦, the second term of (35), can be bounded as
♦ ≤ IlASt)OSR)Sign(bi)k2 ≤ (√ket + 2)2kO(tβ)2 = O(kt2β).
Finally, combining all the results, the term of interest in (35) has the following form
E[I(y - A(t)xb)sign(xbi)I2|i ∈ S] = O(kt2) + O(kt2β).
□
Claim 10 (Bound on variance parameter for concentration of gradient matrix). With probabil-
ity (1 - δT(t) - δβ(t)), the variance parameter IE[(y - A(t)xb)(y - Axb)>]I is upper-bounded by
o( kmβ )∣A*k2.
ProofofClaim 10. Let Fχ* be the event that Sign(X*) = sign(b), and let IFx* denote the indicator
function corresponding to this event. As we show in Lemma 2, this event occurs with probability at
least (1 - δβ(t) - δT(t)), therefore,
E[(y - A(t)Xb)(y - A(t)Xb)>]
=E[(y - A(t)X)(y - A(t)b)>lFχ*]+ E[(y - A(t)b)(y - A(t)X)>lFx* ],
=E[(y - A(t)X)(y - A(t)b)>lFχ* ] ± γ.
Here, Y is small. Under the event Fχ*, X has the correct signed-support. Again, since IFx* =
1 - IFx*,
E[(y - A(t)b)(y - A(t)b)>] = E[(y - A(t)b)(y - A(t)b)>(1 - IF。*)] ± γ,
= E[(y - A(t)Xb)(y - A(t)Xb)>] ± γ.
Now, using Lemma 4 with probability at least (1 - δT(t) - δβ(t)), XbS admits the following expression
bs := XSR) = (I- ASt))XS + oSR).
Therefore we have
y - A(t)X = (AS - ASt)(I- ΛSt)))xS - A)OR).
Using the expression above E[(y - A(t)Xb)(y - A(t)Xb)>] can be written as
E[(y - A(t)Xb)(y - A(t)Xb)>]
=E[((AS - ASt)(I- ASt)))XS - ASt)OSR))((AS - ASt)(I- ASt)))XS - ASt)OSR))>].
Sub-conditioning, we have
E[(y - A(t)Xb)(y-A(t)Xb)>]
=ES[(AS - ASt)(I- ASt)))ExS[XSXS> ∣S](AS> - (I - ASt))ASt)>)]
-ES [ASt)ExS [OSR)XS> ∣S](AS> - (I - ASt))ASt)>)]
-ES [(AS - ASt)(I- ASt)))ExS [XS (OSR))>∣S]ASt)>]
+ ES [A(St)Ex*S [O(SR)(O(SR))>|S]A(St)>].
Now, since Ex* [XSXS> ∣S] = I,
∣∣E[(y - A(t)b)(y - A(t)X)>]|| ≤ ∣ES[(AS - ASt)(I- ASt)))(AS> - (I- ASt))ASt)>)]∣
X-------------------------{-------------------------}
事
37
Published as a conference paper at ICLR 2019
+ kEs[ASt)ExS [⅛R)xS>∣S](AS> - (I - Λ的ASt)>)]k
X-----------------------V-------------------}
.
+ kEs[(AS - A(S)(I- Λ[))Exs [xS(4R))>|S]A，]||
V-----------------------V-------------------}
Q
+ kEs[ASt)Exs[MR)(4R))>∣S]ASt)>]k.	(37)
X--------------V--------------}
♦
Let's start with the first term (帛)of (37), which can be written as
* :≤ kEs[ASAS>]k + kEs[AS(I - Λ的ASt)>]k + ∣∣Es[ASt)(I - Λ的AS>]k
X--------------} X----------V---------} X-----------V---}
*1	42	*3
+kES[A(St)(I-Λ(St))2A(St)>]k.
X-----------{z-------------}
(38)
Now consider each term of equation (38). First, since
>	>	m>
Es [AS AS ]= Es [ P AiAj I/s ]= P AiAi ES [1 ”],
i,j∈S i,j=1
and ES[lij∈s] = 0(m),wecan upper-bound *1 := ∣∣Es[ASAS>]k as
*ι := IIES[ASAS>]∣∣ = 0(m)∣∣A*1 …Ajk= 0(m)∣∣A*∣∣2,
where 1m×m denotes an m X m matrix of ones. Now, we turn to *2 := ∣∣Es [AS (I 一 ASt))ASt) ]k
in (38), which can be simplified as
m>	2
*2 ≤k P ArAjt) Es[1 i,j∈s]k≤O(M)|仄*|||人叫|.
i,j=1
Further, since A(t) is (t, 2)-close to Ar, we have that kA(t)k ≤ kA(t) - Ark + kArk ≤ 3kArk,
therefore
*2 := kEs[AS(I - A勒Ap]k = 0(m)∣∣A*k2∙
Similarly, *3 (38) is also 0(k2)kA*∣2. Next, we consider *4 := ∣∣Es[ASt)(I — ASt))2ASt) ]∣∣ in
(38) which can also be bounded similarly as
*4=0( m )∣A*k2.
Therefore, we have the following for * in (37)
* := Es [(AS - ASt)(I- ASt)))(AS> - (I - ASt))ASt)>)] = 0( k2 )||A*『.	(39)
Consider 4 in (37). Letting M = Exa [HSR)xS> |S], and using the analysis similar to that shown in
7, we have that elements of M ∈ Rk×k are given by
M —E * WR)x*S (≤ O(Y(R)), fori = j,
Mij= ExS 叽 χjSj= 0(et),	for i= j.
We have the following,
♦ := Es [ASt)ExS [4R)XS>∣S](AS>-(I- ASt))ASt)>)] = ES [ASt)M(AS>-(I- ASt))ASt)>)].
Therefore, since ES[lij∈sT] = 0(悬),and ∣∣1m×mk = m,
4 := kES[A(St)M(ArS> - (I - A(St))A(St)>)]k
38
Published as a conference paper at ICLR 2019
m>
=k P Mi,jAaAj -(1- λjt))Ajt) )Es[1 i,j∈s|S]k,
i,j=1
m>
=O(et)k P Af)(Aj - (1 - λjt))Ajt))ES[1 ,j∈sF]k,
i,j=1
=O(et)O(m)(∣∣A⑴1m×mA*>∣∣ + kA ㈤ 1m×mA ⑴ >k),
=O(et)O( k )kA*k2.
Therefore,
♦ := kEs[ASt)M(AS>-(I- Λ的ASt)>)]k= O(k)et||A*『.
Similarly, O in (37) is also bounded as 4. Next, We consider ♦ in (37). In this case, letting
Ex自["SR)(HSR))>|S] = N, where N ∈ Rk×k is a matrix whose each entry Nij ≤ 出R)IwjR)|.
Further, by Claim 5, each element HjR) is upper-bounded as
IH(jR) I ≤ O(tβ).
with probability at least (1 - δβ(t)). Therefore,
m	>	m	>
♦	= k P NijAit)Ajt) ES[1 i,j∈s|S]k =max|H(R)||HjR)|O(.)k P A(t)Ajt) ∣∣.
i,j=1	i,j	i,j=1
Again, using the result on IHi(R) I, we have
♦	：= kEs[ASt)NASt)>]k = m max∣H(R)IIHjR)∣O(晨)∣∣A㈤∣∣∣∣A㈤k= O(譬)||A*『.
i,j
Combining all the results for 电 4, O and ♦, we have,
kE[(y - A(t)xb)(y-A(t)xb)>]k
=O( m )kA*k2 + O( k )et kAjk2 + O( k )etkA*k2 + O(等)||A*『,
k2t2
=O( kmtβ )kAjk2.
□
E Additional Experimental Results
We now present some additional results to highlight the features of NOODL. Specifically, we com-
pare the performance of NOODL (for both dictionary and coefficient recovery) with the state-of-the-
art provable techniques for DL presented in Arora et al. (2015) (when the coefficients are recovered
via a sparse approximation step after DL)3. We also compare the performance of NOODL with
the popular online DL algorithm in Mairal et al. (2009), denoted by Mairal ‘09. Here, the au-
thors show that alternating between a 'ι-based sparse approximation and dictionary update based
on block co-ordinate descent converges to a stationary point, as compared to the true factors in case
of NOODL.
Data Generation: We generate a (n = 1000) × (m = 1500) matrix, with entries drawn from
N(0, 1), and normalize its columns to form the ground-truth dictionary Aj . Next, we perturb Aj
with random Gaussian noise, such that the unit-norm columns of the resulting matrix, A(0) are
2/ log(n) away from Aj, in '2-norm sense, i.e., e° = 2/ log(n); this satisfies the initialization
assumptions in A.4. At each iteration, we generate p = 5000 samples Y ∈ R1000×5000 as Y =
AjXj, where Xj ∈ Rk×p has at most k = 10, 20, 50, and 100, entries per column, drawn from
the Radamacher distribution. We report the results in terms of relative Frobenius error for all the
experiments, i.e., for a recovered matrix M, we report kM - Mj kF/kMj kF. To form the coefficient
estimate for Mairal ‘09 via Lasso (Tibshirani, 1996) we use the FISTA (Beck and Teboulle, 2009)
algorithm by searching across 10 values of the regularization parameter at each iteration. Note that,
although our phase transition analysis for NOODL shows that p = m suffices, we use p = 5000 in
our convergence analysis for a fair comparison with related techniques.
3The associated code is made available at https://github.com/srambhatla/NOODL.
39
Published as a conference paper at ICLR 2019
E.1 Coefficient Recovery
Table 4 summarizes the results of the convergence analysis shown in Fig. 2. Here, we com-
pare the dictionary and coefficient recovery performance of NOODL with other techniques. For
Arora15(‘‘biased’’) and Arora15(‘‘unbiased’’), we report the error in recovered
coefficients after the HT step (XHT) and the best error via sparse approximation using Lasso4 Tib-
shirani (1996), denoted as XLasso , by scanning over 50 values of regularization parameter. For
Mairal ‘09 at each iteration of the algorithm we scan across 10 values5 of the regularization pa-
rameter, to recover the best coefficient estimate using Lasso ( via FISTA), denoted as XLasso .
We observe that NOODL exhibits significantly superior performance across the board. Also, we
observe that using sparse approximation after dictionary recovery, when the dictionary suffers
from a bias, leads to poor coefficient recovery6, as is the case with Arora15(‘‘biased’’),
Arora15(‘‘unbiased’’), and Mairal ‘09. This highlights the applicability of our approach
in real-world machine learning tasks where coefficient recovery is of interest. In fact, it is a testa-
ment to the fact that, even in cases where dictionary recovery is the primary goal, making progress
on the coefficients is also important for dictionary recovery.
In addition, the coefficient estimation step is also online in case of NOODL, while for the state-
of-the-art provable techniques (which only recover the dictionary and incur bias in estimation) need
additional sparse approximation step for coefficient recovery. Moreover, these sparse approximation
techniques (such as Lasso) are expensive to use in practice, and need significant tuning.
E.2 Computational Time
In addition to these convergence results, we also report the computational time taken by each of
these algorithms in Table 4. The results shown here were compiled using 5 cores and 200GB RAM
of Intel Xeon E5 - 2670 Sandy Bridge and Haswell E5-2680v3 processors.
The primary takeaway is that although NOODL takes marginally more time per iteration as com-
pared to other methods when accounting for just one Lasso update step for the coefficients, it (a) is
in fact faster per iteration since it does not involve any computationally expensive tuning procedure
to scan across regularization parameters; owing to its geometric convergence property (b) achieves
orders of magnitude superior error at convergence, and as a result, (c) overall takes significantly
less time to reach such a solution. Further, NOODL’s computation time can be further reduced via
implementations using the neural architecture illustrated in Section 4.
Note that since the coefficient estimates using just the HT step at every step may not yield a usable
result for Arora15(‘‘unbiased’’) and Arora15(‘‘biased’’) as shown in Table 4, in
practice, one has to employ an additional `1 -based sparse recovery step. Therefore, for a fair com-
parison, we account for running sparse recovery step(s) using Lasso (via the Fast Iterative Shrinkage-
Thresholding Algorithm (FISTA) (Beck and Teboulle, 2009) ) at every iteration of the algorithms
Arora15(‘‘biased’’) and Arora15(‘‘unbiased’’).
For our technique, we report the average computation time taken per iteration. However, for the rest
of the techniques, the coefficient recovery using Lasso (via FISTA) involves a search over various
values of the regularization parameters (10 values for this current exposition). As a result, we an-
alyze the computation time per iteration via two metrics. First of these is the average computation
time taken per iteration by accounting for the average time take per Lasso update (denoted as “Ac-
counting for one Lasso update”), and the second is the average time taken per iteration to scan over
all (10) values of the regularization parameter (denoted as “Overall Lasso search”) .
4We use the Fast Iterative Shrinkage-Thresholding Algorithm (FISTA)(BeCk and Teboulle, 2009), which
is among the most efficient algorithms for solving the `1 -regularized problems. Note that, in our experiments
we fix the step-size for FISTA as 1/L, where L is the estimate of the Lipschitz constant (since A is not known
exactly).
5Note that, although scanning across 50 values of the regularization parameter for this case would have
led to better coefficient estimates and dictionary recovery, we choose 10 values for this case since it is very
expensive to scan across 50 of regularization parameter at each step. This also highlights why Mairal ‘09
may be prohibitive for large scale applications.
6When the dictionary is not known exactly, the guarantees may exist on coefficient recovery only in terms
of closeness in '2-norm sense, due to the error-in-variables (EIV) model for the dictionary (Fuller, 2009; Wain-
wright, 2009).
40
Published as a conference paper at ICLR 2019
Table 4: Final error in recovery of the factors by various techniques and the computation time taken per iteration
(in seconds) corresponding to Fig. 2 across techniques. We report the coefficient estimate after the HT step (in
Arora et al. (2015)) as XHT. For the techniques presented in Arora et al. (2015), we scan across 50 values of
the regularization parameter for coefficient estimation using Lasso after learning the dictionary (A), and report
the optimal estimation error for the coefficients (XLasso), while for Mairal ‘09, at each step the coefficients
estimate is chosen by scanning across 10 values of the regularization parameters. For k = 100, the algorithms
of Arora et al. (2015) do not converge (shown as N/A).
Technique	Recovered Factor and Timing	k = 10	k = 20	k = 50	k = 100
	A	9.44 × 10-11	8.82 × 10-11	9.70 × 10-11	7.33 × 10-11
NOODL	X	1.14 × 10-11	1.76 × 10-11	3.58 × 10-11	4.74 × 10-11
	Avg. TimeZiteratiOn	46.500 sec-	53.303 sec-	64.800 sec-	96.195 sec-
	A	0≡3	0.031	037	N/A
	XHT	0.077	0.120	0.308	N/A
Arora15 (‘‘biased’’)	XLasso	0.006	0.018	0.097	N/A
	Avg. TimeZiteration (Accounting for one Lasso update) Avg. TimeZiteration (Overall LaSSO search)	39.390 sec 389.368 sec	39.371 sec 388.886 sec	39.434 sec 389.566 sec	40.063 sec 395.137 sec
	A	On	0.027	0.148	N/A
	XHT	0.078	0.122	0.371	N/A
Arora15 (‘‘unbiased’’)	XLasso	0.005	0.015	00921	N/A
	Avg. TimeZiteration (AccOunting fOr One LassO update) Avg. TimeZiteration (Overall Lasso search)	567.830 sec 917.809 sec	597.543 sec 947.059 sec	592.081 sec 942.212 sec	686.694 sec 1041.767 sec
	A	0.009	00T5	0.021	0.037
	XLasso	0.183	0.209	0.275	0.353
Mairal ‘09	Avg. TimeZiteration (Accounting for one Lasso update) Avg. TimeZiteration (Overall Lasso search)	39.110 sec 388.978 sec	39.077 sec 388.614 sec	39.163 sec 389.512 sec	39.672 sec 394.566 sec
As shown in Table 4, in comparison to NOODL the techniques described in Arora et al. (2015) still
incur a large error at convergence, while the popular online DL algorithm of Mairal et al. (2009)
exhibits very slow convergence rate. Combined with the convergence results shown in Fig. 2, we
observe that due to NOODL’s superior convergence properties, it is overall faster and also geomet-
rically converges to the true factors. This again highlights the applicability of NOODL in practical
applications, while guaranteeing convergence to the true factors.
F Appendix: S tandard Results
Definition 6 (SUb-GaUssian Random variable). Let X 〜SubGaussian(σ2). Then, for any t > 0, it
holds that
Pr[|x| >t] ≤ 2exp (袅).
F.1 Concentration results
Lemma 10 (Matrix Bernstein (Tropp, 2015)). Consider a finite seqUence Wk ∈ Rn×m of inde-
pendent, random, centered matrices with dimension n. AssUme that each random matrix satisfies
E[Wk] = 0 and kWkk ≤ R almost sUrely. Then, for all t ≥ 0,
Pr{kP WkIl ≥ t} ≤ (n + m)exp(σ-R-2∕3.),
k
where σ2 := max{I PE[WkWk>]I, I PE[Wk>Wk]I}.
kk
FUrthermore,
E[k P Wkk] ≤ p2σ2 log(n + m) + 1 Rlog(n + m).
k
41
Published as a conference paper at ICLR 2019
Lemma 11 (Vector Bernstein (Tropp, 2015)). Consider a finite sequence wk ∈ Rn of independent,
random, zero mean vectors with dimension n. Assume that each random vector satisfies E[wk] = 0
and kwkk ≤ R almost surely. Then, for all t ≥ 0,
Pr{k P wkk ≥ t} ≤ 2neχp(σ-+R‰)，
k
where σ2 := k P E[kwkk2 ]k. Furthermore,
k
E[k P wkk] ≤ √2σ2 log(2n) + 3Rlog(2n).
k
Lemma 12. Chernoff Bound for sub-Gaussian Random Variables Let w be an independent sub-
Gaussian random variables with variance parameter σ2 , then for any t > 0 it holds that
2
Ρr[∣w∣ > t] ≤ 2exp(-枭).
Lemma 13 (Sub-Gaussian concentration (Rudelson and Vershynin, 2013)). Let M ∈ Rn×m be
a fixed matrix. Let w be a vector of independent, sub-Gaussian random variables with mean zero
and variance one. Then, for an absolute constant c,
Pr[kMXk2 -kMkF > t] ≤ eχp(-kctφ ).
F.2 Results from (Arora et al., 2015)
Lemma 14 ((Arora et al., 2015) Lemma 45). Suppose that the distribution of Z satisfies Pr[kZk ≥
L(log(1∕ρ))C] ≤ ρ] for some constant C > 0, then
1. Ifp = nO(1) then kZ(j) k ≤ Oe(L) holds for each j with probability at least(1 - ρ) and,
2∙ kE[Z1∣z∣≥ω(L)]k = n-ω⑴.
In particular, if P Pp =ι Zj)(I - IkZk≥Ω(l)) is concentrated With probability (1 - ρ), then so is
P P"小.P
Lemma 15 (Theorem 40 (Arora et al., 2015)). Suppose random vector g(t) is a (p_，P+，Zt)-
correlated with high probability with Z for t ∈ [T] where T ≤ poly(n), and nA satisfies
0 < ηA ≤ 2ρ+ , then for any t ∈ [T],
E[kz(t+1) - z*k2] ≤ (1 - 2ρnA)kz(t) - z*k + 2nAZt.
In particular, if ∣∣z(0) - z*k ≤ e0 and Zt ≤ (PJo((I - 2ρ%)t)e0 + Z, where Z = maxt∈[τ]Zt, then
the updates converge to Z geometrically with systematic error Z/p in the sense that
E[kz(t+1) - z*k2] ≤ (1 - 2pnA)te0 + Z/p.
42