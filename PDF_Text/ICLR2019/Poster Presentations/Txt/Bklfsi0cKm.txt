Published as a conference paper at ICLR 2019
Deep Convolutional Networks as
shallow Gaussian Processes
Adria Garriga-Alonso
department of Engineering
University of Cambridge
ag919@cam.ac.uk
Laurence Aitchison
Department of Engineering
University of Cambridge
laurence.aitchison@gmail.com
Carl Edward Rasmussen
Department of Engineering
University of Cambridge
cer54@cam.ac.uk
Ab stract
We show that the output of a (residual) convolutional neural network (CNN) with
an appropriate prior over the weights and biases is a Gaussian process (GP) in the
limit of infinitely many convolutional filters, extending similar results for dense
networks. For a CNN, the equivalent kernel can be computed exactly and, unlike
“deep kernels”, has very few parameters: only the hyperparameters of the original
CNN. Further, we show that this kernel has two properties that allow it to be com-
puted efficiently; the cost of evaluating the kernel for a pair of images is similar
to a single forward pass through the original CNN with only one filter per layer.
The kernel equivalent to a 32-layer ResNet obtains 0.84% classification error on
MNIST, a new record for GPs with a comparable number of parameters. 1
1	Introduction
Convolutional Neural Networks (CNNs) have powerful pattern-recognition capabilities that have
recently given dramatic improvements in important tasks such as image classification (Krizhevsky
et al., 2012). However, as CNNs are increasingly being applied in real-world, safety-critical do-
mains, their vulnerability to adversarial examples (Szegedy et al., 2013; Kurakin et al., 2016), and
their poor uncertainty estimates are becoming increasingly problematic. Bayesian inference is a
theoretically principled and demonstrably successful (Snoek et al., 2012; Deisenroth & Rasmussen,
2011) framework for learning in the face of uncertainty, which may also help to address the prob-
lems of adversarial examples (Gal & Smith, 2018). Unfortunately, Bayesian inference in CNNs is
extremely difficult due to the very large number of parameters, requiring highly approximate fac-
torised variational approximations (Blundell et al., 2015; Gal & Ghahramani, 2015), or requiring
the storage (Lakshminarayanan et al., 2017) of large numbers of posterior samples (Welling & Teh,
2011; Mandt et al., 2017).
Other methods such as those based on Gaussian Processes (GPs) are more amenable to Bayesian
inference, allowing us to compute the posterior uncertainty exactly (Rasmussen & Williams, 2006).
This raises the question of whether it might be possible to combine the pattern-recognition capa-
bilities of CNNs with exact probabilistic computations in GPs. Two such approaches exist in the
literature. First, deep convolutional kernels (Wilson et al., 2016) parameterise a GP kernel using the
weights and biases of a CNN, which is used to embed the input images into some latent space before
computing their similarity. The CNN parameters of the resulting kernel then have to be optimised
by gradient descent. However, the large number of kernel parameters in the CNN reintroduces the
risk of overconfidence and overfitting. To avoid this risk, we need to infer a posterior over the CNN
kernel parameters, which is as difficult as directly inferring a posterior over the parameters of the
original CNN. Second, it is possible to define a convolutional GP (van der Wilk et al., 2017) or a
1Code to replicate this paper is available at https://github.com/convnets-as-gps/convnets-as-gps
1
Published as a conference paper at ICLR 2019
deep convolutional GP (Kumar et al., 2018) by defining a GP that takes an image patch as input,
and using that GP as a component in a larger CNN-like system. However, inference in such sys-
tems is very computationally expensive, at least without the use of potentially severe variational
approximations (van der Wilk et al., 2017).
An alternative approach is suggested by the underlying connection between Bayesian neural net-
works (NNs) and GPs. In particular, Neal (1996) showed that the function defined by a single-layer
fully-connected NN with infinitely many hidden units, and random independent zero-mean weights
and biases is equivalent to a GP, implying that we can do exact Bayesian inference in such a NN
by working with the equivalent GP. Recently, this result was extended to arbitrarily deep fully-
connected NNs with infinitely many hidden units at each layer (Lee et al., 2017; Matthews et al.,
2018a). However, these fully-connected networks are rarely used in practice, as they are unable
to exploit important properties of images such as translational invariance, raising the question of
whether state-of-the-art architectures such as CNNs (LeCun et al., 1990) and ResNets (He et al.,
2016a) have equivalent GP representations. Here, we answer in the affirmative, giving the GP ker-
nel corresponding to arbitrarily deep CNNs and to (convolutional) residual neural networks (He
et al., 2016a). In this case, if each hidden layer has an infinite number of convolutional filters, the
network prior is equivalent to a GP.
Furthermore, we show that two properties of the GP kernel induced by a CNN allow it to be com-
puted very efficiently. First, in previous work it was necessary to compute the covariance matrix
for the output of a single convolutional filter applied at all possible locations within a single image
(van der Wilk et al., 2017), which was prohibitively computationally expensive. In contrast, under
our prior, the downstream weights are independent with zero-mean, which decorrelates the contri-
bution from each location, and implies that it is necessary only to track the patch variances, and
not their covariances. Second, while it is still necessary to compute the variance of the output of
a convolutional filter applied at all locations within the image, the specific structure of the kernel
induced by the CNN means that the variance at every location can be computed simultaneously and
efficiently as a convolution.
Finally, we empirically demonstrate the performance increase coming from adding translation-
invariant structure to the GP prior. Without computing any gradients, and without augmenting
the training set (e.g. using translations), we obtain 0.84% error rate on the MNIST classification
benchmark, setting a new record for nonparametric GP-based methods.
2	GP behaviour in a CNN
For clarity of exposition, we will treat the case of a 2D convolutional NN. The result applies straight-
forwardly to nD convolutions, dilated convolutions and upconvolutions (“deconvolutions”), since
they can be represented as linear transformations with tied coefficients (see Fig. 1).
2.1	A 2D convolutional network prior
The network takes an arbitrary input image X of height H(0) and width D(0), as a C(0) ×(H(0)D(0))
real matrix. Each row, which we denote x1, x2, . . . , xC(0) , corresponds to a channel of the image
(e.g. C(0) = 3 for RGB), flattened to form a vector. The first activations A(1) (X) are a linear
transformation of the inputs. For i ∈ {1, . . . , C(1) }:
C(0)
ai(1)(X) :=bi(1)1+XWi(,1j)xj .	(1)
j=1
We consider a network with L hidden layers. The other activations of the network, from A(2) (X)
up to A(L+1) (X), are defined recursively:
C⑶
a'+I)(X) ：= by+I)I + χ w('+1)φ (a7(X)).	⑵
j=1
2
Published as a conference paper at ICLR 2019
Filter
旦
D^
A
C"
Input image’s jth channel:
Resulting
convolution
Figure 1: The 2D convolution U(O) * Xj as the dot product W(O)Xj. The blank elements of W(O)
are zeros. The μth row of W(0) corresponds to applying the filter to the μth convolutional patch of
the channel Xj .
The activations A(')(X) are C(') × (H(')D(')) matrices. Each row ai'+1) represents the flattened
jth channel of the image that results from applying a convolutional filter to φ(A⑶(X)).
The structure of the pseudo-weight matrices W('+1) and biases b('+1), for i ∈ {1,..., C('+1)}
and j ∈ {1,..., C⑶}, depends on the architecture. For a convolutional layer, each row of W('+1)
represents a position of the filter, such that the dot product of all the rows with the image vector
Xj represents applying the convolutional filter U(，I) to the jth channel. Thus, the elements of
each row of W('+1) are: 0 where the filter does not apply and the corresponding element of U('+1)
where it does, as illustrated in Fig. 1.
The outputs of the network are the last activations, A(L+1)(X). In the classification or regression
setting, the outputs are not spatially extended, so we have H(L+1) = D(L+1) = 1, which is equiva-
lent to a fully-connected output layer. In this case, the pseudo-weights Wi(,Lj+1) only have one row,
and the activations ai(L+1) are single-element vectors.
Finally, we define the prior distribution over functions by making the filters U，j and biases b(') be
independent Gaussian random variables (RVs). For each layer `, channels i, j and locations within
the filter x, y :
U(S,x,y 〜N(0, σW/C⑶)，	b(')〜N (0, σ2).	⑶
Note that, to keep the activation variance constant, the weight variance is divided by the number of
input channels. The weight variance can also be divided by the number of elements of the filter,
which makes it equivalent to the NN weight initialisation scheme introduced by He et al. (2016a).
2.2	Argument for GP behaviour
We follow the proofs by Lee et al. (2017) and Matthews et al. (2018a) to show that the output of the
CNN described in the previous section, A(L+1), defines a GP indexed by the inputs, X. Their proof
(Lee et al., 2017) proceeds by applying the multivariate Central Limit Theorem (CLT) to each layer
in sequence, i.e. taking the limit as N (1) → ∞, then N(2) → ∞ etc, where N (`) is the number
of hidden units in layer `. By analogy, we sequentially apply the multivariate CLT by taking the
limit as the number of channels goes to infinity, i.e. C(1) → ∞, then C(2) → ∞ etc. While this
is the simplest approach to taking the limits, other potentially more realistic approaches also exist
(Matthews et al., 2018a).
3
Published as a conference paper at ICLR 2019
The fundamental quantity we consider is a vector formed by concatenating the feature maps (or
equivalently channels), aj(`) (X) and aj(`) (X0) from data points X and X0,
a(')(X, X0)=(a(')(X))!.	⑷
This quantity (and the following arguments) can all be extended to the case of countably finite
numbers of input points.
Induction base case. For any pair of data points, X and X0 the feature-maps corresponding to
the jth channel, a(j1) (X, X0) have a multivariate Gaussian joint distribution. This is because each
element is a linear combination of shared Gaussian random variables: the biases, b(j0) and the filters,
Uj(,0:). Following Eq. (1),
ai(1)(X,X0)=bi(1)1+CXi=(01)W0i(,1j) W0i(,1j)!xx0ii,	(5)
where 1 is a vector of all-ones. While the elements within a feature map display strong correlations,
different feature maps are independent and identically distributed (iid) conditioned on the data (i.e.
ai(1)(X, X0) and ai(01)(X, X0) are iid for i 6= i0), because the parameters for different feature-maps
(i.e. the biases, bi(1) and the filters, Wi(,1:)) are themselves iid.
Induction step. Consider the feature maps at the `th layer, a(j`) (X, X0), to be iid multivariate
Gaussian RVs (i.e. for j = j0, aj') (X, X0) and a(') (X, X0) are iid). Our goal is to show that, taking
the number of channels at layer ' to infinity (i.e. C(') → ∞), the same properties hold at the next
layer (i.e. all feature maps, a('+1) (X, X0), are iid multivariate Gaussian RVs). Writing eq. (2) for
two training examples, X and X0, we obtain,
C(') (τχτ('+1)	C ∖
a('+1)(X, X0)	= b('+1)1	+ X( ij	w0+i)l Φ(aj')(X, X0))	(6)
j=1	0	Wi,j
We begin by showing that a('+1)(X, X0) is a multivariate Gaussian RV. The first term is multi-
variate Gaussian, as it is a linear function of b('+1), which is itself iid Gaussian. We can apply the
multivariate CLT to show that the second term is also Gaussian, because, in the limit as C(') → ∞,
it is the sum of infinitely many iid terms: aj')(X, X0) are iid by assumption, and W('+1) are iid
by definition. Note that the same argument applies to all feature maps jointly, so all elements of
A('+1)(X, X0) (defined by analogy with eq. 4) are jointly multivariate Gaussian.
Following Lee et al. (2017), to complete the argument, we need to show that the output feature maps
are iid, i.e. a('+1) (X, X0) and a('+1)(X, X0) are iid for i = i0. They are identically distributed,
as bi'+1) and W('+1) are iid and φ(aj')(X, X0)) is shared. To show that they are independent,
remember that ai'+1)(X, X0) and a('+1)(X, X0) are jointly Gaussian, so it is sufficient to show
that they are uncorrelated, and we can show that they are uncorrelated because the weights, W('+1)
are independent with zero-mean, eliminating any correlations that might arise through the shared
RV, φ(aj')(X, X0)). In the appendix, we consider the more complex case where we take limits
simultaneously.
3	The ConvNet and ResNet kernels
Here we derive a computationally efficient kernel corresponding to the CNN described in the pre-
vious section. It is surprising that we can compute the kernel efficiently because the feature maps,
4
Published as a conference paper at ICLR 2019
ai(`) (X), display rich covariance structure due to the shared convolutional filter. Computing and rep-
resenting these covariances would be prohibitively computationally expensive. However, in many
cases we only need the variance of the output, e.g. in the case of classification or regression with a
final dense layer. It turns out that this propagates backwards through the convolutional network, im-
plying that for every layer, we only need the “diagonal covariance” of the activations: the covariance
between the corresponding elements of a(j`) (X) and a(j`) (X0) (i.e. diag C ha(j`) (X), a(j`) (X0)i).
3.1	GP mean and covariance
A GP is completely specified by its mean and covariance (kernel) functions. These give the pa-
rameters of the joint Gaussian distribution of the RVs indexed by any two inputs, X and X0 . For
the purposes of computing the mean and covariance, it is easiest to consider the network as being
written entirely in index notation,
C(') H(')D(')
A('+1)(X) = b('+1) + X X WjIV φ(j (X)).
j=1	ν=1
where ' and ' + 1 denote the input and output layers respectively, j and i ∈ {1,...,C ('+1)} denote
the input and output channels, and V and μ ∈ {1,..., H('+1)D('+1)} denote the location within the
input and output channel or feature-maps.
The mean function is thus easy to compute
C⑷ H(')D(')
E [A('+1)(X)i = E [b('+1)i + XX E [W j1V Φ(j(X))] = O.
j=1	ν=1
_ J ('+1) __ Λ TT7-('+l) 1 __	_	_	_ ( TT7-('+l) __	∙ Λ Λ	.	♦-
as bi	，and Wij,*,V have zero mean, and Wij,”,j are independent of the activations at the previous
layer,φ(AjV(X)).
Now we show that it is possible to efficiently compute the covariance function. This is surprising
because for many networks, we need to compute the covariance of activations between all pairs of
locations in the feature map (i.e. C hA('+1)(X),A('+1)(X0)i for μ,μ0 ∈ {1,..., H('+1)D('+1)})
and this object is extremely high-dimensional, N2(H('+1)D('+1))2. However, it turns out that We
only need to consider the “diagonal” covariance, (i.e. We only need C [Ai'+1) (X), Ai'+1) (X0)] for
μ ∈ {1,..., H('+1)D('+1)}), which is a more manageable quantity of size N2(H('+1)D('+1)).
This is true at the output layer (L + 1): in order to achieve an output suitable for classification or re-
gression, we use only a single output location H(L+1) = D(L+1) = 1, with a number of “channels”
equal to the number of of outputs/classes, so it is only possible to compute the covariance at that
single location. We now show that, if we only need the covariance at corresponding locations in the
outputs, we only need the covariance at corresponding locations in the inputs, and this requirement
propagates backwards through the network.
Formally, as the activations are composed of a sum of terms, their covariance is the sum of the
covariances of all those underlying terms,
C hA('+1)(X),A('μ+1)(X0)i = V [b(')i +
C⑹ C⑷ H(')D(') H(')D(')	(7)
('+1)	(')	('+1)	(')	0
工工工 工 C [Wij,”,ν φ(Aj,V (X)),Wij0,4,V0 φ(Aj0,V0 (X)小
j=1j0 =1	V=1 V0 =1
As the terms in the covariance have mean zero, and as the weights and activations from the previous
layer are independent,
ChAg+1)(X),A 器1)(X0)i =σ2+
C(G C(') H(')D(') H(')D(')	(8)
XXX X E[Wj1,νWjμ),νoiE[φ(Ajν(χ))φ(j)ν,X))].
j=1j0=1	V=1	V0=1
5
Published as a conference paper at ICLR 2019
Algorithm 1 The ConvNet kernel k(X, X0)
1:	Input: two images, X, X0 ∈ RC(0)×(H(O)W⑼).
2:	Compute Kμ1)(X, X), K，1)(X, X0), and K1)(X0, X0) for μ ∈ {1,...,H (I)D(I)}; using
Eq. (10).
3:	for ` = 1, 2, . . . , L do
4:	Compute V;(')(X, X0), Vr(e) (X, X0) and V(')(X, X0) for μ ∈ {1,...,H ⑶D(')}; using
Eq. (13), or some other nonlinearity.
5:	Compute	κS'+1)(X, X),	κS'+1)(X, X0),	and Kg+1)(X0, X0) for μ ∈
{1,..., H ('+1)D('+* 1 2 * * * *)}; using Eq. (11).
6:	end for
7:	Output the scalar K1(L+1) (X, X0).
The weights are independent for different channels: W('+1) and W('j+1) are iid for j = j0, so
E ∣^Wi('+1VWi('+ 1)νο^∣ = 0 for j = j0 Further, each row μ of the weight matrices W('+1) only
,j,μ,	“,j ,μ,"	,j
contains independent variables or zeros (Fig. 1), so E Wi('+1) W('+ 1)i√ = 0 for V = V0. Thus, We
i	i μ 7	i i,j,μ,ν i,j ,μ,ν J	,
can eliminate the sums over j 0 and V0 :
C⑷
ChA 器1)(X),A('+1)(X0)i = σ2+X
j=1
H(')D(')
X E ∣^W('+1) W('+1)] E ∣^φ(A(') (X))φ(A(') (X0))]
乙 [rri,j,μ,ν r½,j,μ,νJ L [φ9j,ν (八 ))φ9j,ν (八 ))「
ν=1
(9)
The μth row of WWI is zero for indices V that do not belong to its convolutional patch, so We can
restrict the sum over V to that region. We also define vg(1)(X, X0), to emphasise that the covariances
are independent of the output channel, j . The variance of the first layer is
2 C(0)
Kμ1)(X, X0)= c[A(,iμ (X),Aιμ(X0)] =σ2 + 岛 X X	Xi Xi,ν.	(10)
i=1 ν∈μth patch
And we do the same for the other layers,
K'+1)(X, X0)= ChAg+1)(X),A('+1)(X0)i =σ2 + 0 X 匕⑶(X, X0),	(11)
ν∈μthpatch
where
V(')(X,X0) = E [φ(Aj'V(X))Φ(Aj'V(X0))]	(12)
is the covariance of the activations, which is again independent of the channel.
3.2 Covariance of the activities
The elementwise covariance in the right-hand side of Eq. (11) can be computed in closed form
for many choices of φ if the activations are Gaussian. For each element of the activations, one
needs to keep track of the 3 distinct entries of the bivariate covariance matrix between the inputs,
K'+1)(X, X), K'+1)(X, X0) and K^+1)(X0, X0).
For example, for the ReLU nonlinearity (φ(x) = max(0, x)), one can adapt Cho & Saul (2009) in
the same way as Matthews et al. (2018a, section 3) to obtain
κ ,	∕κV')(X, X)K')(X0, X0) / S	S (N
V(')(X, X0) = X——-——∏------------------(Sin θV') + (∏ - θV'))cοs θV'))	(13)
where θV') =CosT (κV')(X, X0) /，κV') (X, X)κV') (X0, X0)).
6
Published as a conference paper at ICLR 2019
3.3	Efficiency of the ConvNet kernel
We now have all the pieces for computing the kernel, as written in Algorithm 1.
Putting together Eq. (11) and Eq. (13) gives us the surprising result that the diagonal covariances of
the activations at layer ` + 1 only depend on the diagonal covariances of the activations at layer `.
This is very important, because it makes the computational cost of the kernel be within a constant
factor of the cost of a forward pass for the equivalent CNN with 1 filter per layer.
Thus, the algorithm is more efficient that one would naively think. A priori, one needs to compute
the covariance between all the elements of aj') (X) and aj') (X0) combined, yielding a 2H(')D(') X
2H⑶ D(') covariance matrix for every pair of points. Instead, We only need to keep track of a
H(')D(') -dimensional vector per layer and pair of points.
Furthermore, the particular form for the kernel (eq. 1 and eq. 2) implies that the required variances
and covariances at all required locations can be computed efficiently as a convolution.
3.4	Kernel for a residual CNN
The induction step in the argument for GP behaviour from Sec. 2.2 depends only on the previous ac-
tivations being iid Gaussian. Since all the activations are iid Gaussian, we can add skip connections
between the activations of different layers while preserving GP behaviour, e.g. A('+1) and A(E-S)
where s is the number of layers that the skip connection spans. If we change the NN recursion
(Eq. 2) to
C⑷
a('+I)(X) := ai'-s)(X)+ b('+1) + X Wfj)Φ (a(') (X)) ,	(14)
j=1
then the kernel recursion (Eq. 11) becomes
K'+1)(X, X0)= KL(X, X0)+ σb + σW	X	V(')(X, X0).	(15)
ν∈μthpatch
This way of adding skip connections is equivalent to the “pre-activation” shortcuts described by He
et al. (2016b). Remarkably, the natural way of adding residual connections to NNs is the one that
performed best in their empirical evaluations.
4 Experiments
We evaluate our kernel on the MNIST handwritten digit classification task. Classification likelihoods
are not conjugate for GPs, so we must make an approximation, and we follow Lee et al. (2017), in
re-framing classification as multi-output regression.
The training set is split into N = 50000 training and 10000 validation examples. The regression
targets Y ∈ {-1, 1}N×10 are a one-hot encoding of the example’s class: yn,c = 1 if the nth example
belongs to class c, and -1 otherwise.
Training is exact conjugate likelihood GP regression with noiseless targets Y (Rasmussen &
Williams, 2006). First we compute the N ×N kernel matrix Kxx, which contains the kernel between
every pair of examples. Then we compute Kx-x1 Y using a linear system solver.
The test set has NT = 10000 examples. We compute the NT × N matrix Kχ*χ, the kernel between
each test example and all the training examples. The predictions are given by the row-wise maximum
of Kx*xKx-x1Y.
For the “ConvNet GP” and “Residual CNN GP”, (Table 1) we optimise the kernel hyperparameters
by random search. We draw M random hyperparameter samples, compute the resulting kernel’s
performance in the validation set, and pick the highest performing run. The kernel hyperparame-
ters are: σb2 , σw2 ; the number of layers; the convolution stride, filter sizes and edge behaviour; the
nonlinearity (we consider the error function and ReLU); and the frequency of residual skip connec-
tions (for Residual CNN GPs). We do not retrain the model on the validation set after choosing
hyperparameters.
7
Published as a conference paper at ICLR 2019
Method	#samples	Validation error	Test error
NNGP (Lee et al., 2017)	≈ 250	一	1.21%
Convolutional GP (van der Wilk et al., 2017)	SGD	一	1.17%
Deep Conv. GP (Kumar et al., 2018)	SGD	一	1.34%
ConvNet GP	27	0.71%	1.03%
Residual CNN GP	27	0.72%	0.96%
ReSNetGP	—	0.68%	0.84%
GP + parametric deep kernel (Bradshaw et al., 2017)	SGD	一	0.60%
ResNet (Chen et al., 2018)	—	一	0.41%
Table 1: MNIST classification results. #samples gives the number of kernels that were randomly
sampled for the hyperparameter search. “ConvNet GP” and “Residual CNN GP” are random CNN
architectures with a fixed filter size, whereas “ResNet GP” is a slight modification of the architecture
by He et al. (2016b). Entries labelled “SGD” used stochastic gradient descent for tuning hyperpa-
rameters, by maximising the likelihood of the training set. The last two methods use parametric
neural networks. The hyperparameters of the ResNet GP were not optimised (they were fixed based
on the architecture from He et al., 2016b).
The “ResNet GP” (Table 1) is the kernel equivalent to a 32-layer version of the basic residual ar-
chitecture by He et al. (2016a). The differences are: an initial 3 × 3 convolutional layer and a final
dense layer instead of average pooling. We chose to remove the pooling because computing its out-
put variance requires the off-diagonal elements of the filter covariance, in which case we could not
exploit the efficiency gains described in Sec. 3.3.
We found that the despite it not being optimised, the 32-layer ResNet GP outperformed all other
comparable architectures (Table 1), including the NNGP in Lee et al. (2017), which is state-of-
the-art for non-convolutional networks, and convolutional GPs (van der Wilk et al., 2017; Kumar
et al., 2018). That said, our results have not reached state-of-the-art for methods that incorporate a
parametric neural network, such as a standard ResNet (Chen et al., 2018) and a Gaussian process
with a deep neural network kernel Bradshaw et al. (2017).
To check whether the GP limit is applicable to relatively small networks used practically (with of the
order of 100 channels in the first layers), we randomly sampled 10, 000 32-layer ResNets, with 3,
10, 30 and 100 channels in the first layers, and, following the usual practice for ResNets we increase
the number the number of hidden units when we downsample the feature maps. The probability
density plots show a good match around 100 channels (Fig. 2A), which matches a more sensitive
graphical procedure based on quantile-quantile plots (Fig. 2B). Notably, even for only 30 channels,
the moments match closely (Fig. 2C). For comparison, typical ResNets use from 64 (He et al.,
2016a) to 192 (Zagoruyko & Komodakis, 2016) channels in their first layers. We believe that this is
because the moment propagation equations only require the Gaussianity assumption for propagation
through the relu, and presumably this is robust to non-Gaussian input activations.
Computational efficiency. Asymptotically, computing the kernel matrix takes O(N 2LD) time,
where L is the number of layers in the network and D is the dimensionality of the input, and inverting
the kernel matrix takes O(N3). As such, we expect that for very large datasets, inverting the kernel
matrix will dominate the computation time. However, on MNIST, N3 is only around a factor of
10 larger than N2 LD. In practice, we found that it was more expensive to compute the kernel
matrix than to invert it. For the ResNet kernel, the most expensive, computing Kχχ, and Kχχ*
for validation and test took 3h 40min on two Tesla P100 GPUs. In contrast, inverting Kxx and
computing validation and test performance took 43.25 ± 8.8 seconds on a single Tesla P100 GPU. 5
5 Related work
Van der Wilk et al. (van der Wilk et al., 2017) also adapted GPs to image classification. They
defined a prior on functions f that takes an image and outputs a scalar. First, draw a function
g 〜GP(0, kp(X, X0)). Then, f is the sum of the output of g applied to each of the convolutional
patches. Their approach is also inspired by convolutional NNs, but their kernel kp is applied to all
pairs of patches ofX and X0. This makes their convolutional kernel expensive to evaluate, requiring
8
Published as a conference paper at ICLR 2019
B ∙b p-dEES
limiting q.	limiting q.	limiting q.	limiting q.
C.>00 ps-dEES
limiting cov.	limiting cov.	limiting cov.	limiting cov.
Figure 2: Comparison of the infinite limit, and outputs from finite 32-layer ResNets with 3, 10,
30, and 100 channels in their first layers. A Comparison of the empirical and limiting probability
densities. B A more sensitive test of Gaussianity is a quantile-quantile plot, which shows converges
with 100 channels. C The moments (variances and covariances) for 100 training inputs shows gives
a good match for all numbers of channels.
inter-domain inducing point approximations to remain tractable. The kernels in this work, directly
motivated by the infinite-filter limit of a CNN, only apply something like kp to the corresponding
pairs of patches within X and X0 (Eq. 10). As such, the CNN kernels are cheaper to compute and
exhibit superior performance (Table 1), despite the use of an approximate likelihood function.
Kumar et al. (2018) define a prior over functions by stacking several GPs with van der Wilk’s con-
volutional kernel, forming a “Deep GP” (Damianou & Lawrence, 2013). In contrast, the kernel in
this paper confines all hierarchy to the definition of the kernel, and the resulting GPs is shallow.
Wilson et al. (2016) introduced and Bradshaw et al. (2017) improved deep kernel learning. The
inputs to a classic GP kernel k (e.g. RBF) are preprocessed by applying a feature extractor g (a deep
NN) prior to computing the kernel: kdeep(X, X0) := k(g(X; θ), g(X0, θ)). The NN parameters are
optimised by gradient ascent using the likelihood as the objective, as in standard GP kernel learning
(Rasmussen & Williams, 2006, Chapter 5). Since deep kernel learning incorporates a state-of-the-art
NN with over 106 parameters, we expect it to perform similarly to aNN applied directly to the task of
image classification. At present both CNNs and deep kernel learning display superior performance
to the GP kernels in this work. However, the kernels defined here have far fewer parameters (around
10, compared to their 106).
Borovykh (2018) also suggests that a CNN exhibits GP behaviour. However, they take the infi-
nite limit with respect to the filter size, not the number of filters. Thus, their infinite network is
inapplicable to real data which is always of finite dimension.
Finally, there is a series of papers analysing the mean-field behaviour of deep NNs and CNNs which
aims to find good random initializations, i.e. those that do not exhibit vanishing or exploding gra-
dients or activations (Schoenholz et al., 2016; Yang & Schoenholz, 2017). Apart from their very
different focus, the key difference to our work is that they compute the variance for a single training-
9
Published as a conference paper at ICLR 2019
example, whereas to obtain the GPs kernel, we additionally need to compute the output covariances
for different training/test examples (Xiao et al., 2018).
6 Conclusions and future work
We have shown that deep Bayesian CNNs with infinitely many filters are equivalent to a GP with
a recursive kernel. We also derived the kernel for the GP equivalent to a CNN, and showed that,
in handwritten digit classification, it outperforms all previous GP approaches that do not incorpo-
rate a parametric NN into the kernel. Given that most state-of-the-art neural networks incorporate
structure (convolutional or otherwise) into their architecture, the equivalence between CNNs and
GPs is potentially of considerable practical relevance. In particular, we hope to apply GP CNNs in
domains as widespread as adversarial examples, lifelong learning and k-shot learning, and we hope
to improve them by developing efficient multi-layered inducing point approximation schemes.
References
JR Blum, H Chernoff, M Rosenblatt, and H Teicher. Central limit theorems for interchangeable
processes. Canad. J. Math,10:222-229,1958.
Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in
neural network. In International Conference on Machine Learning, pp. 1613-1622, 2015.
Anastasia Borovykh. A gaussian process perspective on convolutional neural networks. Research-
Gate, 05 2018.
John Bradshaw, Alexander G de G Matthews, and Zoubin Ghahramani. Adversarial examples,
uncertainty, and transfer testing robustness in gaussian process hybrid deep networks. arXiv
preprint arXiv:1707.02476, 2017.
Tian Qi Chen, Yulia Rubanova, Jesse Bettencourt, and David Duvenaud. Neural ordinary differential
equations. arXiv preprint arXiv:1806.07366, 2018.
Youngmin Cho and Lawrence K Saul. Kernel methods for deep learning. In Advances in neu-
ral information processing systems, pp. 342-350, 2009. URL http://papers.nips.cc/
paper/3628- kernel- methods- for- deep- learning.pdf.
Andreas Damianou and Neil Lawrence. Deep gaussian processes. In Carlos M. Carvalho and
Pradeep Ravikumar (eds.), Proceedings of the Sixteenth International Conference on Artificial
Intelligence and Statistics, volume 31 of Proceedings of Machine Learning Research, pp. 207-
215, Scottsdale, Arizona, USA, 29 Apr-01 May 2013. PMLR. URL http://proceedings.
mlr.press/v31/damianou13a.html.
Marc Deisenroth and Carl E Rasmussen. PILCO: A model-based and data-efficient approach to
policy search. In Proceedings of the 28th International Conference on machine learning (ICML-
11), pp. 465-472, 2011.
Yarin Gal and Zoubin Ghahramani. Dropout as a bayesian approximation: Representing model
uncertainty in deep learning. arXiv preprint arXiv:1506.02142, 2015.
Yarin Gal and Lewis Smith. Idealised bayesian neural networks cannot have adversarial examples:
Theoretical and empirical study. arXiv preprint arXiv:1806.00667, 2018.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016a. URL https://arxiv.org/pdf/1512.03385.pdf.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. In European conference on computer vision, pp. 630-645. Springer, 2016b.
10
Published as a conference paper at ICLR 2019
Daniel Herndndez-Iobato, Jose M. Herndndez-Iobato, and Pierre Dupont. Robust multi-
class gaussian process classification. In J. Shawe-Taylor, R. S. Zemel, P. L. Bartlett,
F. Pereira, and K. Q. Weinberger (eds.), Advances in Neural Information Process-
ing Systems 24, pp. 280-288. 2011. URL http://papers.nips.cc/paper/
4241- robust- multi- class- gaussian- process- classification.pdf.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
lutional neural networks. In Advances in neural information processing systems, pp. 1097-1105,
2012.
Vinayak Kumar, Vaibhav Singh, PK Srijith, and Andreas Damianou. Deep gaussian processes with
convolutional kernels. arXiv preprint arXiv:1806.01655, 2018.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial examples in the physical world.
arXiv preprint arXiv:1607.02533, 2016.
Balaji Lakshminarayanan, Alexander Pritzel, and Charles Blundell. Simple and scalable predictive
uncertainty estimation using deep ensembles. In Advances in Neural Information Processing
Systems, pp. 6402-6413, 2017.
Yann LeCun, Bernhard E Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne E
Hubbard, and Lawrence D Jackel. Handwritten digit recognition with a back-propagation net-
work. In Advances in neural information processing systems, pp. 396-404, 1990.
Jaehoon Lee, Yasaman Bahri, Roman Novak, Samuel S Schoenholz, Jeffrey Pennington, and Jascha
Sohl-Dickstein. Deep neural networks as gaussian processes. arXiv preprint arXiv:1711.00165,
2017.
Stephan Mandt, Matthew D Hoffman, and David M Blei. Stochastic gradient descent as approximate
bayesian inference. The Journal of Machine Learning Research, 18(1):4873-4907, 2017.
Alexander G. de G. Matthews, Jiri Hron, Mark Rowland, Richard E. Turner, and Zoubin Ghahra-
mani. Gaussian process behaviour in wide deep neural networks. In International Confer-
ence on Learning Representations, 2018a. URL https://openreview.net/forum?id=
H1-nGgWC-.
Alexander G de G Matthews, Mark Rowland, Jiri Hron, Richard E Turner, and Zoubin Ghahramani.
Gaussian process behaviour in wide deep neural networks. arXiv preprint arXiv:1804.11271,
2018b.
De G Matthews, G Alexander, Mark Van Der Wilk, Tom Nickson, Keisuke Fujii, Alexis Bouk-
ouvalas, Pablo Ledn-Villagrd, Zoubin Ghahramani, and James Hensman. GPflow: A gaussian
process library using TensorFlow. The Journal of Machine Learning Research, 18(1):1299-1304,
2017.
Radford M. Neal. Bayesian Learning for Neural Networks. Springer-Verlag, Berlin, Heidelberg,
1996. ISBN 0387947248.
Carl Edward Rasmussen and Christopher KI Williams. Gaussian processes for machine learning,
volume 1. MIT press Cambridge, 2006.
Samuel S Schoenholz, Justin Gilmer, Surya Ganguli, and Jascha Sohl-Dickstein. Deep information
propagation. arXiv preprint arXiv:1611.01232, 2016.
Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine
learning algorithms. In Advances in neural information processing systems, pp. 2951-2959, 2012.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
Mark van der Wilk, Carl Edward Rasmussen, and James Hensman. Convolutional gaussian pro-
cesses. In Advances in Neural Information Processing Systems, pp. 2845-2854, 2017.
11
Published as a conference paper at ICLR 2019
Max Welling and Yee W Teh. Bayesian learning via stochastic gradient langevin dynamics. In
Proceedings ofthe 28th International Conference on Machine Learning (ICML-11),pp. 681-688,
2011.
Andrew Gordon Wilson, Zhiting Hu, Ruslan Salakhutdinov, and Eric P. Xing. Deep kernel
learning. In Arthur Gretton and Christian C. Robert (eds.), Proceedings of the 19th Interna-
tional Conference on Artificial Intelligence and Statistics, volume 51 of Proceedings of Ma-
chine Learning Research, pp. 370-378, Cadiz, Spain, 09-11 May 2016. PMLR. URL http:
//proceedings.mlr.press/v51/wilson16.html.
Lechao Xiao, Yasaman Bahri, Jascha Sohl-Dickstein, Samuel S Schoenholz, and Jeffrey Penning-
ton. Dynamical isometry and a mean field theory of cnns: How to train 10,000-layer vanilla
convolutional neural networks. arXiv preprint arXiv:1806.05393, 2018.
Ge Yang and Samuel Schoenholz. Mean field residual networks: On the edge of chaos. In Advances
in neural information processing systems, pp. 7103-7114, 2017.
Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. arXiv preprint
arXiv:1605.07146, 2016.
7 Appendix
7.1	Technical notes on limits
The key technical issues in the proof (and the key differences between Lee et al. 2017 and Matthews
et al. 2018b) arise from exactly how and where we take limits. In particular, consider the activations
as being functions of the activities at the previous layer,
A(4) = A(4)(A(3)(A(2)(A(1)(X))))	(16)
Now, there are two approaches to taking limits. First, both our argument in the main text, and the
argument in Lee et al. (2017) is valid if we are able to take limits “inside” the network,
A(L4) =	lim A(4) lim A(3)	lim A(2) A(1)(X)	.	(17)
However, Matthews et al. (2018a;b) argue that is preferable to take limits “outside” the network. In
particular, Matthews et al. (2018b) take the limit with all layers simultaneously,
A(M4) = lim A(4) A(3) A(2) A(1)(X)	,	(18)
where C(') = C(') (n) goes to infinity as n → ∞. That said, similar technical issues arise if We take
limits in sequence, but outside the network.
7.2	Extending the derivations of Matthews et al. (20 1 8b) to the
CONVOLUTIONAL CASE
In the main text, we follow Lee et al. (2017) in sequentially taking the limit of each layer to infinity
(i.e. C(1) → ∞, then C(2) → ∞ etc.). This dramatically simplified the argument, because taking
the number of units in the previous layer to infinity means that the inputs from that layer are exactly
Gaussian distributed. However, Matthews et al. (2018b) argue that the more practically relevant limit
is where we take all layers to infinity simultaneously. This raises considerable additional difficulties,
because we must reason about convergence in the case where the previous layer is finite. Note that
this section is not intended to stand independently: it is intended to be read alongside Matthews et al.
(2018b), and we use several of their results without proof.
Mirroring Definition 3 in Matthews et al. (2018b), we begin by choosing a set of “width” functions,
C(') (n), for ' ∈ {1,...,L} which all approach infinityas n → ∞. In Matthews et al. (2018b),
these functions described the number of hidden units in each layer, whereas here they describe the
number of channels. Our goal is then to extend the proofs in Matthews et al. (2018b) (in particular,
12
Published as a conference paper at ICLR 2019
of theorem 4), to show that the output of our convolutional networks converge in distribution to a
Gaussian process as n → ∞, with mean zero and covariance given by the recursion in Eqs. (10 -
12).
The proof in Matthews et al. (2018b) has three main steps. First, they use the Cramer-Wold device,
to reduce the full problem to that of proving convergence of scalar random variables to a Gaussian
with specified variance. Second, if the previous layers have finite numbers of channels, then the
channels aj') (X) and aj') (X0) are uncorrelated but no longer independent, so We cannot apply the
CLT directly, as we did in the main text. Instead, they write the activations as a sum of exchangeable
random variables, and derive an adapted CLT for exchangeable (rather than independent) random
variables (Blum et al., 1958). Third, they show that moment conditions required by their exchange-
able CLT are satisfied.
To extend their proofs to the convolutional case, we begin by defining our networks in a form that is
easier to manipulate and as close as possible to Eq. (21-23) in Matthews et al. (2018b),
C(0)
Ai1μ=f(,μ)(x)=√Cwo) X X	Vj,μ,νxj,ν+b(i), i ∈ N
C j = 1 ν∈μth patch
g('μ (x)=φ (fS(x))
σw
C(')(n)
X X e('+1) √') (χ) + b('+1)	i ∈ N
乙 乙 6i,j,μ,νgj,ν (x) + bi ， i ∈ N
j = 1 ν∈μthpatch
where,
ei,j,μ,ν ~N(0, 1).
(19)
(20)
(21)
(22)
The first step is to use the Cramer-Wold device (Lemma 6 in Matthews et al., 2018b), which indicates
that convergence in distribution of a sequence of finite-dimensional vectors is equivalent to conver-
gence on all possible linear projections to the corresponding real-valued random variable. Mirroring
Eq. 25 in Matthews et al. (2018b), we consider convergence of random vectors, f2(x)[n] - b('),
projected onto a(xji,μ),
T⑶(L,α)[n]=	X α(x,i,μ) [虑(x)[n]-中].	(23)
(χ,i,μ)∈L
where L⊂X× N ×{1,..., H (')D(')} is a finite set of tuples of data points and channel indicies,
i, and indicies of elements within channels/feature maps, μ. The suffix [n] indicates width functions
that are instantiated with input, n.
Now, we must prove that these projections converge in distribution a Gaussian. We begin by defining
summands, as in Eq. 26 in Matthews et al. (2018b),
γj') (L, α) [n] := σw	X	α(x,i,μ)	X	M,",νgj'-1)(x)H	(24)
(x,i,μ)∈L	ν∈μthpatch
such that the projections can be written as a sum of the summands, exactly as in Eq. 27 in Matthews
et al. (2018b),
1	C('-1)(n)
T⑶(L,α)[n]= PC('_i)(n)	X γj') (L,α)[n].	(25)
Now we can apply the exchangeable CLT to prove that T(') (L, α) [n] converges to the limiting
Gaussian implied by the recursions in the main text. To apply the exchangeable CLT, the first step is
to mirror Lemma 8 in Matthews et al. (2018b), in showing that for each fixed n and ` ∈ {2, . . . , L +
1}, the summands, γj') (L, α) [n] are exchangeable with respect to the index j. In particular, we
apply de Finetti’s theorem, which states that a sequence of random variables is exchangeable if and
13
Published as a conference paper at ICLR 2019
only if they are i.i.d. conditional on some set of random variables, so it is sufficient to exhibit such
a set of random variables. Mirroring Eq. 29 in Matthews et al. (2018b), we apply the recursion,
(	C('-2) (n)
,⑶(L a)	[n]	:= σ X	a3’M	X	e(')	φ _________3______ X X	e('-1)	√'-2)(χ)[n]	+ b('+1)
Yj	(L,a)	[n]	:= σw	a	乙	ei,j,μ,νφ	I	PC('-2)(n)	乙 乙	ej,k,ν,ξgk,ξ	(x)[n]	+ bj
(x,i,μ)∈L	ν∈μth patch	∖V	k=1 ξ∈νth patch
(26)
As such, the summands are iid conditional on the finite set of random variables
{gk'-2)(x)[n] : k ∈ {1,..., C('-2)}, ξ ∈ {1,..., H('-2)D('-2)}, X ∈ LX}, where LX is the set
of input points in L.
The exchangeable CLT in Lemma 10 in Matthews et al. (2018b) indicates that T(') (L, a)[n] con-
verges in distribution to N(0, σ2) if the summands are exchangeable (which we showed above),
and if three conditions hold,
a)	En [γj')γj')] = 0
b)	limn→∞ En (γj')) (γj'))	= σ4
c)	En h∣γj')∣3i = o (√CW))
Condition a) follows immediately as the summands are uncorrelated and zero-mean. Conditions
b) and c) are more involved as convergence in distribution in the previous layers does not imply
convergence in moments for our activation functions.
We begin by considering the extension of Lemma 20 in Matthews et al. (2018b), which allow us to
show conditions b) and c) above, even in the case of unbounded but linearly enveloped nonlinearities
(Definition 1 in Matthews et al., 2018b). Lemma 20 states that the eighth moments of f，? (χ)[n] are
bounded by a finite constant independent of n ∈ N. We prove this by induction. The base case is
trivial, as fj[ (χ)[n] is Gaussian. Following Matthews et al. (2018b), assume the condition holds UP
to ` - 1, and show that the condition holds for layer `. Using Eq. (21), we can bound the activations
at layer `,
E [lfS(x)[n]∣8] ≤ 28-1 E
C('-1)(n)
1b(')18 +√⅛	X	ν.X∕μ,ν GE
(27)
Following Eq. 48 in Matthews et al. (2018b), which uses Lemma 19 in Matthews et al. (2018b), we
have,
C('-1)(n)
E I X	ν∈X∕μ,νG(X)[n]
24Γ(4+1∕2) E
Γ(1∕2)
2
σw2
_________kg('T)
C('-1)(n) kgj∈{1,∙
..,C('-1) (n)},ν∈μth patch(X)[n]k22
(28)
where gj；—1..,c('-i)(n)},ν∈μthpatch(x)[n] is the set of post-nonlinearities corresponding to j ∈
{1,..., C('-1)(n)} and V ∈ μth patch. Following Matthews et al. (2018b), observe that,
1	J	1	"-Rn)	J	2
C ('-1) (n) kgj∈-1LC('7(n)},ν∈μthpatCh(X)[n]k2 = C('-1)(n)	Σ Σ	(j-I)(X)[n])
' '	j j j = 1	ν∈μth patch
(29)
I	C('-1)(n)	2
≤ C('-1)⑹	X X	(C + mfSI)(X)[n]|)
v j j = 1	ν∈μth patch
(30)
14
Published as a conference paper at ICLR 2019
by the linear envelope property, |φ(u) | ≤ C+m|u|. Following Matthews et al. (2018b), we substitute
this bound back into Eq. (28) and suppress a multiplicative constant independent of x and n,
E
≤ -----------4 E
一(C ('T)(n))4
C('-1)(n)
X X	线,μ,ν gj'-1)(x)[n]
j = 1	ν∈μth patch
C('-1) (n)	I4
X x C+2cmifj(,'-I)(X)间+m2ifj'-I)(X)同2|
j = 1	ν∈μth patch	I
(31)
This can be multiplied out, yielding a weighted sum of expectations of the form,
E fk'-I)(X)[n]∣pι∣f(ξT)(X)[n产出r⑺网产糖'-I)(X)[n]叫	(32)
with pi ∈ {0,1, 2} for i = 1, 2, 3,4, and k,l,r,q ∈ {1,..., C ('-1)(n)}, and ν, ξ,π,ρ ∈ μth patch
where the weights of these terms are independent of n. Using Lemma 18 in Matthews et al.
(2018b), each of these terms is bounded if the eighth moments of fk'-1)(X)[n] are bounded, which
is our inductive hypothesis. The number of terms in the expanded sum is upper bounded by
(2C('τ)(n)∣μthpatch∣) , where ∣μth patch| is the number of elements in a convolutional patch.
Thus, we can use the same constant for any n due to the 1 / (C('T) (n)) scaling. As in Matthews
etal. (2018b), noting that f,('-1)(X)[n] are exchangeable over j for any X and n concludes the proof.
Using this result, we can obtain a straightforward adaptation of Lemmas 15, 16 and 21 in Matthews
et al. (2018b). Lemma 15 gives condition b), Lemma 16 gives condition c); Lemma 15 requires
uniform integrability, which is established by Lemma 21.
7.3 Calibration of Gaussian process uncertainty
It is important to check that the estimates of uncertainty produced by our Gaussian process are
reasonable. However, to make this assessment, we needed to use a proper likelihood, and not the
squared-error loss in the main text. We therefore used our kernel to perform the full, multi-class
classification problem in GPflow Matthews et al. (2017), with a RobustMax likelihood (Herngndez-
lobato et al., 2011). The more difficult non-conjugate inference problem forced us to use 1000
inducing points, randomly chosen from the training inputs. Both our kernel and an RBF kernel have
similar calibration curves, that closely track the diagonal, indicating accurate uncertainty estima-
tion. However, even in the inducing point setting, our convolutional kernel gave considerably better
performance than the RBF kernel (2.4% error vs 3.4% error).
15
Published as a conference paper at ICLR 2019
RBF-GP label probability.	ResNet-GP label probability.
Figure 3: Calibration plots for an RBF kernel (left) and the ResNet kernel (right). The x-axis gives
GP prediction for the label probability. The points give corresponding proportion of test points with
that label, and the bars give the proportion of training examples in each bin.
16