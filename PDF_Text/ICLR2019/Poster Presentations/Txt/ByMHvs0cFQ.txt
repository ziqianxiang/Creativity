Published as a conference paper at ICLR 2019
Quaternion Recurrent Neural Networks
Titouan ParcoHet1,4, Mirco Ravanelli2, Mohamed Morchid1, Georges Linares1,
Chiheb Trabelsi2,5, RenatoDeMori1,3, YoshuaBengio2 *
1	LIA, Universite d' Avignon, France
2	MILA, Universite de Montreal, Quebec, Canada
3	McGill University, Quebec, Canada
4	Orkis, Aix-en-provence, France
5	Element AI, Montreal, Quebec, Canada
titouan.parcollet@alumni.univ-avignon.fr,
mirco.ravanelli@gmail.com,
firstname.lastname@univ-avignon.fr,
chiheb.trabelsi@polymtl.ca, rdemori@cs.mcgill.ca
Ab stract
Recurrent neural networks (RNNs) are powerful architectures to model sequential
data, due to their capability to learn short and long-term dependencies between
the basic elements of a sequence. Nonetheless, popular tasks such as speech or
images recognition, involve multi-dimensional input features that are characterized
by strong internal dependencies between the dimensions of the input vector. We
propose a novel quaternion recurrent neural network (QRNN), alongside with
a quaternion long-short term memory neural network (QLSTM), that take into
account both the external relations and these internal structural dependencies
with the quaternion algebra. Similarly to capsules, quaternions allow the QRNN
to code internal dependencies by composing and processing multidimensional
features as single entities, while the recurrent operation reveals correlations between
the elements composing the sequence. We show that both QRNN and QLSTM
achieve better performances than RNN and LSTM in a realistic application of
automatic speech recognition. Finally, we show that QRNN and QLSTM reduce
by a maximum factor of 3.3x the number of free parameters needed, compared to
real-valued RNNs and LSTMs to reach better results, leading to a more compact
representation of the relevant information.
1	Introduction
In the last few years, deep neural networks (DNN) have encountered a wide success in different
domains due to their capability to learn highly complex input to output mapping. Among the different
DNN-based models, the recurrent neural network (RNN) is well adapted to process sequential
data. Indeed, RNNs build a vector of activations at each timestep to code latent relations between
input vectors. Deep RNNs have been recently used to obtain hidden representations of speech unit
sequences (Ravanelli et al., 2018a) or text word sequences (Conneau et al., 2018), and to achieve
state-of-the-art performances in many speech recognition tasks (Graves et al., 2013a;b; Amodei et al.,
2016; Povey et al., 2016; Chiu et al., 2018). However, many recent tasks based on multi-dimensional
input features, such as pixels of an image, acoustic features, or orientations of 3D models, require
to represent both external dependencies between different entities, and internal relations between
the features that compose each entity. Moreover, RNN-based algorithms commonly require a huge
number of parameters to represent sequential data in the hidden space.
Quaternions are hypercomplex numbers that contain a real and three separate imaginary
components, perfectly fitting to 3 and 4 dimensional feature vectors, such as for image processing
and robot kinematics (Sangwine, 1996; Pei & Cheng, 1999; Aspragathos & Dimitros, 1998). The
* CIFAR Senior Fellow
1
Published as a conference paper at ICLR 2019
idea of bundling groups of numbers into separate entities is also exploited by the recent manifold
and capsule networks (Chakraborty et al., 2018; Sabour et al., 2017). Contrary to traditional
homogeneous representations, capsule and quaternion networks bundle sets of features together.
Thereby, quaternion numbers allow neural network based models to code latent inter-dependencies
between groups of input features during the learning process with fewer parameters than RNNs, by
taking advantage of the Hamilton product as the equivalent of the ordinary product, but between
quaternions. Early applications of quaternion-valued backpropagation algorithms (Arena et al.,
1994; 1997) have efficiently solved quaternion functions approximation tasks. More recently, neural
networks of complex and hypercomplex numbers have received an increasing attention (Hirose &
Yoshida, 2012; Tygert et al., 2016; Danihelka et al., 2016; Wisdom et al., 2016), and some efforts
have shown promising results in different applications. In particular, a deep quaternion network
(Parcollet et al., 2016; 2017a;b), a deep quaternion convolutional network (Gaudet & Maida, 2018;
Parcollet et al., 2018), or a deep complex convolutional network (Trabelsi et al., 2017) have been
employed for challenging tasks such as images and language processing. However, these applications
do not include recurrent neural networks with operations defined by the quaternion algebra.
This paper proposes to integrate local spectral features in a novel model called quaternion
recurrent neural network1 (QRNN), and its gated extension called quaternion long-short term
memory neural network (QLSTM). The model is proposed along with a well-adapted parameters
initialization and turned out to learn both inter- and intra-dependencies between multidimensional
input features and the basic elements of a sequence with drastically fewer parameters (Section 3),
making the approach more suitable for low-resource applications. The effectiveness of the proposed
QRNN and QLSTM is evaluated on the realistic TIMIT phoneme recognition task (Section 4.2)
that shows that both QRNN and QLSTM obtain better performances than RNNs and LSTMs with a
best observed phoneme error rate (PER) of 18.5% and 15.1% for QRNN and QLSTM, compared
to 19.0% and 15.3% for RNN and LSTM. Moreover, these results are obtained alongside with a
reduction of 3.3 times of the number of free parameters. Similar results are observed with the larger
Wall Street Journal (WSJ) dataset, whose detailed performances are reported in the Appendix 6.1.1.
2	Motivations
A major challenge of current machine learning models is to well-represent in the latent space the
astonishing amount of data available for recent tasks. For this purpose, a good model has to efficiently
encode local relations within the input features, such as between the Red, Green, and Blue (R,G,B)
channels of a single image pixel, as well as structural relations, such as those describing edges or
shapes composed by groups of pixels. Moreover, in order to learn an adequate representation with the
available set of training data and to avoid overfitting, it is convenient to conceive a neural architecture
with the smallest number of parameters to be estimated. In the following, we detail the motivations
to employ a quaternion-valued RNN instead of a real-valued one to code inter and intra features
dependencies with fewer parameters.
As a first step, a better representation of multidimensional data has to be explored to naturally capture
internal relations within the input features. For example, an efficient way to represent the information
composing an image is to consider each pixel as being a whole entity of three strongly related
elements, instead of a group of uni-dimensional elements that could be related to each other, as in
traditional real-valued neural networks. Indeed, with a real-valued RNN, the latent relations between
the RGB components of a given pixel are hardly coded in the latent space since the weight has to
find out these relations among all the pixels composing the image. This problem is effectively solved
by replacing real numbers with quaternion numbers. Indeed, quaternions are fourth dimensional
and allow one to build and process entities made of up to four related features. The quaternion
algebra and more precisely the Hamilton product allows quaternion neural network to capture these
internal latent relations within the features encoded in a quaternion. It has been shown that QNNs
are able to restore the spatial relations within 3D coordinates (Matsui et al., 2004), and within color
pixels (Isokawa et al., 2003), while real-valued NN failed. This is easily explained by the fact that
the quaternion-weight components are shared through multiple quaternion-input parts during the
Hamilton product , creating relations within the elements. Indeed, Figure 1 shows that the multiple
weights required to code latent relations within a feature are considered at the same level as for
1 https://github.com/Orkis- Research/Pytorch- Quaternion- Neural- Networks
2
Published as a conference paper at ICLR 2019
Real-valued layer
RtoIHI
Quaternion-valued layer
Hamilton product between w and Qin to produce Qout
Figure 1: Illustration of the input features (Qin) latent relations learning ability of a quaternion-valued
layer (right) due to the quaternion weight sharing of the Hamilton product (Eq. 5), compared to a
standard real-valued layer (left).
learning global relations between different features, while the quaternion weight w codes these
internal relations within a unique quaternion Qout during the Hamilton product (right).
Then, while bigger neural networks allow better performances, quaternion neural networks make it
possible to deal with the same signal dimension but with four times less neural parameters. Indeed, a
4-number quaternion weight linking two 4-number quaternion units only has 4 degrees of freedom,
whereas a standard neural net parametrization has 4 × 4 = 16, i.e., a 4-fold saving in memory.
Therefore, the natural multidimensional representation of quaternions alongside with their ability
to drastically reduce the number of parameters indicate that hyper-complex numbers are a better fit
than real numbers to create more efficient models in multidimensional spaces. Based on the success
of previous deep quaternion convolutional neural networks and smaller quaternion feed-forward
architectures (Kusamichi et al., 2004; Isokawa et al., 2009; Parcollet et al., 2017a), this work proposes
to adapt the representation of hyper-complex numbers to the capability of recurrent neural networks
in a natural and efficient framework to multidimensional sequential tasks such as speech recognition.
Modern automatic speech recognition systems usually employ input sequences composed of mul-
tidimensional acoustic features, such as log Mel features, that are often enriched with their first,
second and third time derivatives (Davis & Mermelstein, 1990; Furui, 1986), to integrate contextual
information. In standard RNNs, static features are simply concatenated with their derivatives to form
a large input vector, without effectively considering that signal derivatives represent different views of
the same input. Nonetheless, it is crucial to consider that time derivatives of the spectral energy in a
given frequency band at a specific time frame represent a special state of a time-frame, and are linearly
correlated (Tokuda et al., 2003). Based on the above motivations and the results observed on previous
works about quaternion neural networks, we hypothesize that quaternion RNNs naturally provide
a more suitable representation of the input sequence, since these multiple views can be directly
embedded in the multiple dimensions space of the quaternion, leading to better generalization.
3	Quaternion recurrent neural networks
This Section describes the quaternion algebra (Section 3.1), the internal quaternion representation
(Section 3.2), the backpropagation through time (BPTT) for quaternions (Section 3.3.2), and proposes
an adapted weight initialization to quaternion-valued neurons (Section 3.4).
3.1	Quaternion algebra
The quaternion algebra H defines operations between quaternion numbers. A quaternion Q is an
extension of a complex number defined in a four dimensional space as:
Q = r1 + xi + yj + zk,
(1)
3
Published as a conference paper at ICLR 2019
where r, x, y, and z are real numbers, and 1, i, j, and k are the quaternion unit basis. In a quaternion,
r is the real part, while xi + yj + zk with i2 = j2 = k2 = ijk = -1 is the imaginary part, or the
vector part. Such a definition can be used to describe spatial rotations. The information embedded in
the quaterion Q can be summarized into the following matrix of real numbers:
r -x -y -z
x
y
r
z
Qmat
-z y
r -x
z -y x r
The conjugate Q* of Q is defined as:
Q* = r1 — Xi — yj — zk.
Then, a normalized or unit quaternion Q/ is expressed as:
Q/ =	, Q =.
r2 + x2 + y2 + z2
Finally, the Hamilton product 0 between two quaternions Qi and Q2 is computed as follows:
(2)
(3)
(4)
Q1 0 Q2 =(r1r2 — x1x2 — y1y2 — z1z2) + (r1x2 + x1r2 +y1z2 — z1y2)i+
(r1y2 — x1z2 +y1r2 + z1x2)j + (r1z2 + x1y2 — y1x2 + z1r2)k.	(5)
The Hamilton product (a graphical view is depicted in Figure 1) is used in QRNNs to perform
transformations of vectors representing quaternions, as well as scaling and interpolation between two
rotations following a geodesic over a sphere in the R3 space as shown in (Minemoto et al., 2017).
3.2	Quaternion representation
The QRNN is an extension of the real-valued (Medsker & Jain, 2001) and complex-valued (Hu
& Wang, 2012; Song & Yam, 1998) recurrent neural networks to hypercomplex numbers. In a
quaternion dense layer, all parameters are quaternions, including inputs, outputs, weights, and biases.
The quaternion algebra is ensured by manipulating matrices of real numbers (Gaudet & Maida, 2018).
Consequently, for each input vector of size N , output vector of size M, dimensions are split into
four parts: the first one equals to r, the second is xi, the third one equals to yj, and the last one to
zk to compose a quaternion Q = r1 + xi + yj + zk. The inference process of a fully-connected
layer is defined in the real-valued space by the dot product between an input vector and a real-valued
M × N weight matrix. In a QRNN, this operation is replaced with the Hamilton product (Eq. 5) with
quaternion-valued matrices (i.e. each entry in the weight matrix is a quaternion). The computational
complexity of quaternion-valued models is discussed in Appendix 6.1.2
3.3	Learning algorithm
The QRNN differs from the real-valued RNN in each learning sub-processes. Therefore, let xt be
the input vector at timestep t, ht the hidden state, Whx, Why and Whh the input, output and hidden
states weight matrices respectively. The vector bh is the bias of the hidden state and pt , yt are the
output and the expected target vectors. More details of the learning process and the parametrization
are available on Appendix 6.2.
3.3.1	Forward phase
Based on the forward propagation of the real-valued RNN (Medsker & Jain, 2001), the QRNN
forward equations are extended as follows:
ht=α(Whh0ht-1+Whx0xt+bh),	(6)
where α is a quaternion split activation function (Xu et al., 2017; Tripathi, 2016) defined as:
α(Q) = f(r) + f(x)i + f(y)j + f(z)k,	(7)
with f corresponding to any standard activation function. The split approach is preferred in this work
due to better prior investigations, better stability (i.e. pure quaternion activation functions contain
singularities), and simpler computations. The output vector pt is computed as:
pt = β(Why 0 ht),	(8)
where β is any split activation function. Finally, the objective function is a classical loss applied
component-wise (e.g., mean squared error, negative log-likelihood).
4
Published as a conference paper at ICLR 2019
3.3.2	Quaternion Backpropagation Through Time
The backpropagation through time (BPTT) for quaternion numbers (QBPTT) is an extension of the
standard quaternion backpropagation (Nitta, 1995), and its full derivation is available in Appendix
6.3. The gradient with respect to the loss Et is expressed for each weight matrix as ∆hy = ∂wEt ，
△hh = ∂Wt九,∆hx = ∂WE~, for the bias vector as ∆ = IEt, and is generalized to ∆t =筹 with:
∂Et = ∂El i ∂El .∂EL , k也
∂W = ∂Wr + i∂Wi + J ∂Wj + k ∂Wk.
(9)
Each term of the above relation is then computed by applying the chain rule. Indeed, and conversaly
to real-valued backpropagation, QBPTT must defines the dynamic of the loss w.r.t to each component
of the quaternion neural parameters. As a use-case for the equations, the mean squared error at a
timestep t and named Et is used as the loss function. Moreover, let λ be a fixed learning rate. First,
the weight matrix Why is only seen in the equations of pt . It is therefore straightforward to update
each weight of Why at timestep t following:
Why = Why -1'y % ht, with △hy = ∂W∖^ = (pt - yt),	(10)
where 局 is the conjugate of ht. Then, the weight matrices Wh,h,, Whx and biases bh are arguments
of ht with ht-1 involved, and the update equations are derived as:
Whh = Whh - X^hh,	Whx = Whx - 入及八虞,	bh = bh -1△1,	(11)
with,
tt	tt	tt
△hh = X (Y	δn)	%	hm-1,	∆hx	= X (Y	δn)	% xm,	∆b	= X (Y。八)，(12)
m=0 n=m	m=0 n=m	m=0 n=m
and,
δ =J Whh % δn+ι × α (hnreact)	if n = t	(13)
n — W Why % (Pn - yn) × β' (PpreaCD otherwise,	()
with hpnreact and ppnreact the pre-activation values of hn and pn respectively.
3.4	Parameter initialization
A well-designed parameter initialization scheme strongly impacts the efficiency of a DNN. An
appropriate initialization, in fact, improves DNN convergence, reduces the risk of exploding or
vanishing gradient, and often leads to a substantial performance improvement (Glorot & Bengio,
2010). It has been shown that the backpropagation through time algorithm of RNNs is degraded
by an inappropriated parameter initialization (Sutskever et al., 2013). Moreover, an hyper-complex
parameter cannot be simply initialized randomly and component-wise, due to the interactions between
components. Therefore, this Section proposes a procedure reported in Algorithm 1 to initialize a
matrix W of quaternion-valued weights. The proposed initialization equations are derived from the
polar form of a weight w of W :
W = ∣w∣eqimagθ = ∣w∣(cos(θ) + q/mag sin(θ)),	(14)
and,
Wr = 3cos(θ), wi = ψ q/magi sin(θ), Wj = φ q/magj sin(θ), Wk =中qimagk sin(θ). (15)
The angle θ is randomly generated in the interval [-π, π]. The quaternion qi/mag is defined as purely
normalized imaginary, and is expressed as qi/mag = 0 + xi + yj + zk. The imaginary components xi,
yj, and zk are sampled from an uniform distribution in [0, 1] to obtain qimag, which is then normalized
(following Eq. 4) to obtain q/mag. The parameter 夕 is a random number generated with respect to
well-known initialization criterions (such as Glorot or He algorithms) (Glorot & Bengio, 2010; He
et al., 2015). However, the equations derived in (Glorot & Bengio, 2010; He et al., 2015) are defined
for real-valued weight matrices. Therefore, the variance of W has to be investigated in the quaternion
space to obtain 夕(the full demonstration is provided in Appendix 6.2). The variance of W is:
V ar(W) = E(|W|2) - [E(|W|)]2, with [E(|W |)]2 = 0.	(16)
5
Published as a conference paper at ICLR 2019
Algorithm 1 Quaternion-valued weight initialization
1	: procedure QINIT(W, nin , nout)
2	σ{	,	1	==	. w.r.t to Glorot criterion and Eq. 18
	∖∕2(nin+nout)
3	:	for w in W do
4	θ J rαnd(-π, π)
5	φ J rand(-σ, σ)
6	: x, y, z J rand(0, 1)
7	: qimag J Quaternion(0, x, y, z)
8	:	qi/	J	qimag	 qimag	√N + y2+Z
9	Wr J φ X cos(θ)	. See Eq. 15
10	Wi J Ψ × q/magi × Sin⑹
11	Wj J Ψ × q/magj × Sin⑹
12	wk J Ψ × q/magk × Sin⑻
13	: W J Quaternion(Wr, Wi, Wj, Wk)
Indeed, the weight distribution is normalized. The value of V ar(W) = E(|W |2), instead, is not
trivial in the case of quaternion-valued matrices. Indeed, W follows a Chi-distribution with four
degrees of freedom (DOFs). Consequently, V ar(W) is expressed and computed as follows:
V ar(W)
E(|W |2) =	x2f(x) dx = 4σ2.
0
(17)
The Glorot (Glorot & Bengio, 2010) and He (He et al., 2015) criterions are extended to quaternion as:
1
σ =	二
2(nin + nout)
,and σ = /
2nin
(18)
with nin and n°u the number of neurons of the input and output layers respectively. Finally, φ can
be sampled from [-σ, σ] to complete the weight initialization of Eq. 15.
4	Experiments
This Section details the acoustic features extraction (Section 4.1), the experimental setups and the
results obtained with QRNNs, QLSTMs, RNNs and LSTMs on the TIMIT speech recognition tasks
(Section 4.2). The results reported in bold on tables are obtained with the best configurations of the
neural networks observed with the validation set.
4.1	Quaternion acoustic features
The raw audio is first splitted every 10ms with a window of 25ms. Then 40-dimensional log Mel-filter-
bank coefficients with first, second, and third order derivatives are extracted using the pytorch-kaldi2
(Ravanelli et al., 2018b) toolkit and the Kaldi s5 recipes (Povey et al., 2011). An acoustic quaternion
Q(f, t) associated with a frequency f and a time-frame t is formed as follows:
de(f,t	de (ft de(f,t) i , d2e(f,t) i , d3e(f,t).
Q(f,t) = e(f,t)+ ~^Γ-i +	j +	k.
(19)
Q,) represents multiple views of a frequency f	at time frame t, consisting of the energy e(f,t)
in the filter band at frequency f , its first time derivative describing a slope view, its second time
derivative describing a concavity view, and the third derivative describing the rate of change of the
second derivative. Quaternions are used to learn the spatial relations that exist between the 3 described
different views that characterize a same frequency (Tokuda et al., 2003). Thus, the quaternion input
vector length is 160/4 = 40. Decoding is based on Kaldi (Povey et al., 2011) and weighted finite
state transducers (WFST) (Mohri et al., 2002) that integrate acoustic, lexicon and language model
probabilities into a single HMM-based search graph.
2pytorch-kaldi is available at https://github.com/mravanelli/pytorch- kaldi
6
Published as a conference paper at ICLR 2019
4.2	THE TIMIT CORPUS
The training process is based on the standard 3, 696 sentences uttered by 462 speakers, while testing
is conducted on 192 sentences uttered by 24 speakers of the TIMIT (Garofolo et al., 1993) dataset.
A validation set composed of 400 sentences uttered by 50 speakers is used for hyper-parameter
tuning. The models are compared on a fixed number of layers M = 4 and by varying the number
of neurons N from 256 to 2, 048, and 64 to 512 for the RNN and QRNN respectively. Indeed, it is
worth underlying that the number of hidden neurons in the quaternion and real spaces do not handle
the same amount of real-number values. Indeed, 256 quaternion neurons output are 256 × 4 = 1024
real values. Tanh activations are used across all the layers except for the output layer that is based on
a softmax function. Models are optimized with RMSPROP with vanilla hyper-parameters and an
initial learning rate of 8 ∙ 10-4. The learning rate is progressively annealed using a halving factor of
0.5 that is applied when no performance improvement on the validation set is observed. The models
are trained during 25 epochs. All the models converged to a minimum loss, due to the annealed
learning rate. A dropout rate of 0.2 is applied over all the hidden layers (Srivastava et al., 2014)
except the output one. The negative log-likelihood loss function is used as an objective function.
All the experiments are repeated 5 times (5-folds) with different seeds and are averaged to limit any
variation due to the random initialization.
Table 1: Phoneme error rate (PER%) of QRNN and RNN models on the development and test sets of
the TIMIT dataset. “Params" stands for the total number of trainable parameters.
Models	Neurons	-Dev.-	Test	Params
	256	22.4^^	23.4	1M
RNN	512	19.6	20.4	2.8M
	1,024	17.9	19.0	9.4M
	2,048	20.0	20.7	33.4M
	64	23.6^^	23.9	0.6M
QRNN	128	19.2	20.1	1.4M
	256	17.4	18.5	3.8M
	512	17.5	18.7	11.2M
The results on the TIMIT task are reported in Table 1. The best PER in realistic conditions (w.r.t to
the best validation PER) is 18.5% and 19.0% on the test set for QRNN and RNN models respectively,
highlighting an absolute improvement of 0.5% obtained with QRNN. These results compare favorably
with the best results obtained so far with architectures that do not integrate access control in multiple
memory layers (Ravanelli et al., 2018a). In the latter, a PER of 18.3% is reported on the TIMIT
test set with batch-normalized RNNs . Moreover, a remarkable advantage of QRNNs is a drastic
reduction (with a factor of 2.5×) of the parameters needed to achieve these results. Indeed, such
PERs are obtained with models that employ the same internal dimensionality corresponding to
1, 024 real-valued neurons and 256 quaternion-valued ones, resulting in a number of parameters of
3.8M for QRNN against the 9.4M used in the real-valued RNN. It is also worth noting that QRNNs
consistently need fewer parameters than equivalently sized RNNs, with an average reduction factor
of 2.26 times. This is easily explained by considering the content of the quaternion algebra. Indeed,
for a fully-connected layer with 2, 048 input values and 2, 048 hidden units, a real-valued RNN has
2, 0482 ≈ 4.2M parameters, while to maintain equal input and output dimensions the quaternion
equivalent has 512 quaternions inputs and 512 quaternion hidden units. Therefore, the number of
parameters for the quaternion-valued model is 5122 × 4 ≈ 1M. Such a complexity reduction turns out
to produce better results and has other advantages such as a smaller memory footprint while saving
models on budget memory systems. This characteristic makes our QRNN model particularly suitable
for speech recognition conducted on low computational power devices like smartphones (Chen et al.,
2014). QRNNs and RNNs accuracies vary accordingly to the architecture with better PER on bigger
and wider topologies. Therefore, while good PER are observed with a higher number of parameters,
smaller architectures performed at 23.9% and 23.4%, with 1M and 0.6M parameters for the RNN
and the QRNN respectively. Such PER are due to a too small number of parameters to solve the task.
4.3	Quaternion long-short term memory neural networks
We propose to extend the QRNN to state-of-the-art models such as long-short term memory neural
networks (LSTM), to support and improve the results already observed with the QRNN compared to
the RNN in more realistic conditions. LSTM (Hochreiter & Schmidhuber, 1997) neural networks
7
Published as a conference paper at ICLR 2019
were introduced to solve the problems of long-term dependencies learning and vanishing or exploding
gradient observed with long sequences. Based on the equations of the forward propagation and
back propagation through time of QRNN described in Section 3.3.1, and Section 3.3.2, one can
easily derive the equations of a quaternion-valued LSTM. Gates are defined with quaternion numbers
following the proposal of Danihelka et al. (2016). Therefore, the gate action is characterized by an
independent modification of each component of the quaternion-valued signal following a component-
wise product with the quaternion-valued gate potential. Let ft,it, ot, ct, and ht be the forget, input,
output gates, cell states and the hidden state of a LSTM cell at time-step t:
ft =α(Wf 0 Xt + Rf 0 ht-i + bf),	(20)
it =α(Wi 0 Xt + Ri 0 ht-i + bi),	(21)
ct =ft × ct-1 + it × tanh(Wc 0 Xt + Rc 0	ht-1 + bc),	(22)
ot =α(Wo 0 Xt + Ro 0 ht-1 + bo),	(23)
ht =ot × tanh(ct),	(24)
where W are rectangular input weight matrices, Rare square recurrent weight matrices, and b are
bias vectors. α is the split activation function and × denotes a component-wise product between two
quaternions. Both QLSTM and LSTM are bidirectional and trained on the same conditions than for
the QRNN and RNN experiments.
Table 2: Phoneme error rate (PER%) of QLSTM and LSTM models on the development and test sets
of the TIMIT dataset. “Params" stands for the total number of trainable parameters.
Models	Neurons	-Dev.-	Test	Params
	256	^T4I9-	16.5	3.6M
LSTM	512	14.2	16.1	12.6M
	1,024	14.4	15.3	46.2M
	2,048	14.0	15.9	176.3M
	64	15.5	17.0	1.6M
QLSTM	128	14.1	16.0	4.6M
	256	14.0	15.1	14.4M
	512	14.2	15.1	49.9M
The results on the TIMIT corpus reported on Table 2 support the initial intuitions and the previously
established trends. We first point out that the best PER observed is 15.1% and 15.3% on the test set
for QLSTMs and LSTM models respectively with an absolute improvement of 0.2% obtained with
QLSTM using 3.3 times fewer parameters compared to LSTM. These results are among the top of
the line results (Graves et al., 2013b; Ravanelli et al., 2018a) and prove that the proposed quaternion
approach can be used in state-of-the-art models. A deeper investigation of QLSTMs performances
with the larger Wall Street Journal (WSJ) dataset can be found in Appendix 6.1.1.
5	Conclusion
Summary. This paper proposes to process sequences of multidimensional features (such as
acoustic data) with a novel quaternion recurrent neural network (QRNN) and quaternion long-short
term memory neural network (QLSTM). The experiments conducted on the TIMIT phoneme
recognition task show that QRNNs and QLSTMs are more effective to learn a compact representation
of multidimensional information by outperforming RNNs and LSTMs with 2 to 3 times less
free parameters. Therefore, our initial intuition that the quaternion algebra offers a better
and more compact representation for multidimensional features, alongside with a better learn-
ing capability of feature internal dependencies through the Hamilton product, have been demonstrated.
Future Work. Future investigations will develop other multi-view features that contribute to
decrease ambiguities in representing phonemes in the quaternion space. In this extent, a recent
approach based on a quaternion Fourier transform to create quaternion-valued signal has to be
investigated. Finally, other high-dimensional neural networks such as manifold and Clifford networks
remain mostly unexplored and can benefit from further research.
8
Published as a conference paper at ICLR 2019
References
Dario Amodei, Sundaram Ananthanarayanan, Rishita Anubhai, Jingliang Bai, Eric Battenberg, Carl
Case, Jared Casper, Bryan Catanzaro, Qiang Cheng, Guoliang Chen, et al. Deep speech 2: End-
to-end speech recognition in english and mandarin. In International Conference on Machine
Learning,pp.173-182, 2016.
Paolo Arena, Luigi Fortuna, Luigi Occhipinti, and Maria Gabriella Xibilia. Neural networks for
quaternion-valued function approximation. In Circuits and Systems, ISCAS’94., IEEE International
Symposium on, volume 6, pp. 307-310. IEEE, 1994.
Paolo Arena, Luigi Fortuna, Giovanni Muscato, and Maria Gabriella Xibilia. Multilayer perceptrons
to approximate quaternion valued functions. Neural Networks, 10(2):335-342, 1997.
Nicholas A Aspragathos and John K Dimitros. A comparative study of three methods for robot
kinematics. Systems, Man, and Cybernetics, Part B: Cybernetics, IEEE Transactions on, 28(2):
135-145, 1998.
Rudrasis Chakraborty, Jose Bouza, Jonathan Manton, and Baba C. Vemuri. Manifoldnet: A deep
network framework for manifold-valued data. arXiv preprint arXiv:1809.06211, 2018.
William Chan and Ian Lane. Deep recurrent neural networks for acoustic modelling. arXiv preprint
arXiv:1504.01482, 2015.
G. Chen, C. Parada, and G. Heigold. Small-footprint keyword spotting using deep neural networks.
In 2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), pp.
4087-4091, May 2014. doi: 10.1109/ICASSP.2014.6854370.
Chung-Cheng Chiu, Tara N Sainath, Yonghui Wu, Rohit Prabhavalkar, Patrick Nguyen, Zhifeng
Chen, Anjuli Kannan, Ron J Weiss, Kanishka Rao, Ekaterina Gonina, et al. State-of-the-art
speech recognition with sequence-to-sequence models. In 2018 IEEE International Conference on
Acoustics, Speech and Signal Processing (ICASSP), pp. 4774-4778. IEEE, 2018.
Alexis Conneau, German Kruszewski, GUillaUme Lample, Loic Barrault, and Marco Baroni. What
you can cram into a single vector: Probing sentence embeddings for linguistic properties, 2018.
Ivo Danihelka, Greg Wayne, Benigno Uria, Nal Kalchbrenner, and Alex Graves. Associative long
short-term memory. arXiv preprint arXiv:1602.03032, 2016.
Steven B Davis and Paul Mermelstein. Comparison of parametric representations for monosyllabic
word recognition in continuously spoken sentences. In Readings in speech recognition, pp. 65-74.
Elsevier, 1990.
Sadaoki Furui. Speaker-independent isolated word recognition based on emphasized spectral dynam-
ics. In Acoustics, Speech, and Signal Processing, IEEE International Conference on ICASSP’86.,
volume 11, pp. 1991-1994. IEEE, 1986.
John S Garofolo, Lori F Lamel, William M Fisher, Jonathan G Fiscus, and David S Pallett. Darpa
timit acoustic-phonetic continous speech corpus cd-rom. nist speech disc 1-1.1. NASA STI/Recon
technical report n, 93, 1993.
Chase J Gaudet and Anthony S Maida. Deep quaternion networks. In 2018 International Joint
Conference on Neural Networks (IJCNN), pp. 1-8. IEEE, 2018.
Xavier Glorot and Yoshua Bengio. Understanding the difficulty of training deep feedforward neural
networks. In International conference on artificial intelligence and statistics, pp. 249-256, 2010.
Alex Graves, Navdeep Jaitly, and Abdel-rahman Mohamed. Hybrid speech recognition with deep
bidirectional lstm. In Automatic Speech Recognition and Understanding (ASRU), 2013 IEEE
Workshop on, pp. 273-278. IEEE, 2013a.
Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recurrent
neural networks. In Acoustics, speech and signal processing (icassp), 2013 ieee international
conference on, pp. 6645-6649. IEEE, 2013b.
9
Published as a conference paper at ICLR 2019
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Delving deep into rectifiers: Surpassing
human-level performance on imagenet classification. In Proceedings of the IEEE international
conference on computer vision, pp. 1026-1034, 2015.
Akira Hirose and Shotaro Yoshida. Generalization characteristics of complex-valued feedforward
neural networks in relation to signal coherence. IEEE Transactions on Neural Networks and
learning systems, 23(4):541-551, 2012.
Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 9(8):
1735-1780, 1997.
Jin Hu and Jun Wang. Global stability of complex-valued recurrent neural networks with time-delays.
IEEE Transactions on Neural Networks and Learning Systems, 23(6):853-865, 2012.
Teijiro Isokawa, Tomoaki Kusakabe, Nobuyuki Matsui, and Ferdinand Peper. Quaternion neural
network and its application. In International Conference on Knowledge-Based and Intelligent
Information and Engineering Systems, pp. 318-324. Springer, 2003.
Teijiro Isokawa, Nobuyuki Matsui, and Haruhiko Nishimura. Quaternionic neural networks: Funda-
mental properties and applications. Complex-Valued Neural Networks: Utilizing High-Dimensional
Parameters, pp. 411-439, 2009.
Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Hiromi Kusamichi, Teijiro Isokawa, Nobuyuki Matsui, Yuzo Ogawa, and Kazuaki Maeda. A new
scheme for color night vision by quaternion neural network. In Proceedings of the 2nd International
Conference on Autonomous Robots and Agents, volume 1315, 2004.
Nobuyuki Matsui, Teijiro Isokawa, Hiromi Kusamichi, Ferdinand Peper, and Haruhiko Nishimura.
Quaternion neural network with geometrical operators. Journal of Intelligent & Fuzzy Systems, 15
(3, 4):149-164, 2004.
Larry R. Medsker and Lakhmi J. Jain. Recurrent neural networks. Design and Applications, 5, 2001.
Toshifumi Minemoto, Teijiro Isokawa, Haruhiko Nishimura, and Nobuyuki Matsui. Feed forward
neural network with random quaternionic neurons. Signal Processing, 136:59-68, 2017.
Mehryar Mohri, Fernando Pereira, and Michael Riley. Weighted finite-state transducers in speech
recognition. Computer Speech and Language, 16(1):69 - 88, 2002. ISSN 0885-2308. doi: https:
//doi.org/10.1006/csla.2001.0184. URL http://www.sciencedirect.com/science/
article/pii/S0885230801901846.
Mohamed Morchid. Parsimonious memory unit for recurrent neural networks with application to
natural language processing. Neurocomputing, 314:48-64, 2018.
Tohru Nitta. A quaternary version of the back-propagation algorithm. In Neural Networks, 1995.
Proceedings., IEEE International Conference on, volume 5, pp. 2753-2756. IEEE, 1995.
Titouan Parcollet, Mohamed Morchid, Pierre-Michel Bousquet, Richard Dufour, Georges Linares,
and Renato De Mori. Quaternion neural networks for spoken language understanding. In Spoken
Language Technology Workshop (SLT), 2016 IEEE, pp. 362-368. IEEE, 2016.
Titouan Parcollet, Morchid Mohamed, and Georges Linares. Quaternion denoising encoder-decoder
for theme identification of telephone conversations. Proc. Interspeech 2017, pp. 3325-3328, 2017a.
Titouan Parcollet, Mohamed Morchid, and Georges Linares. Deep quaternion neural networks for
spoken language understanding. In Automatic Speech Recognition and Understanding Workshop
(ASRU), 2017 IEEE, pp. 504-511. IEEE, 2017b.
Titouan Parcollet, Ying Zhang, Mohamed Morchid, Chiheb Trabelsi, Georges Linares, Renato
de Mori, and Yoshua Bengio. Quaternion convolutional neural networks for end-to-end automatic
speech recognition. In Interspeech 2018, 19th Annual Conference of the International Speech
Communication Association, Hyderabad, India, 2-6 September 2018., pp. 22-26, 2018. doi:
10.21437/Interspeech.2018- 1898. URL https://doi.org/10.21437/Interspeech.
2018-1898.
10
Published as a conference paper at ICLR 2019
Soo-Chang Pei and Ching-Min Cheng. Color image processing by using binary quaternion-moment-
preserving thresholding technique. IEEE Transactions on Image Processing, 8(5):614-628, 1999.
Daniel Povey, Arnab Ghoshal, Gilles Boulianne, Lukas Burget, Ondrej Glembek, Nagendra Goel,
Mirko Hannemann, Petr Motlicek, Yanmin Qian, Petr Schwarz, Jan Silovsky, Georg Stemmer, and
Karel Vesely. The kaldi speech recognition toolkit. In IEEE 2011 Workshop on Automatic Speech
Recognition and Understanding. IEEE Signal Processing Society, December 2011. IEEE Catalog
No.: CFP11SRW-USB.
Daniel Povey, Vijayaditya Peddinti, Daniel Galvez, Pegah Ghahremani, Vimal Manohar, Xingyu Na,
Yiming Wang, and Sanjeev Khudanpur. Purely sequence-trained neural networks for asr based on
lattice-free mmi. In Interspeech, pp. 2751-2755, 2016.
Mirco Ravanelli, Philemon Brakel, Maurizio Omologo, and Yoshua Bengio. Light gated recurrent
units for speech recognition. IEEE Transactions on Emerging Topics in Computational Intelligence,
2(2):92-102, 2018a.
Mirco Ravanelli, Titouan Parcollet, and Yoshua Bengio. The pytorch-kaldi speech recognition toolkit.
arXiv preprint arXiv:1811.07453, 2018b.
Sara Sabour, Nicholas Frosst, and Geoffrey E Hinton. Dynamic routing between capsules. arXiv
preprint arXiv:1710.09829v2, 2017.
Stephen John Sangwine. Fourier transforms of colour images using quaternion or hypercomplex,
numbers. Electronics letters, 32(21):1979-1980, 1996.
Jingyan Song and Yeung Yam. Complex recurrent neural network for computing the inverse and
pseudo-inverse of the complex matrix. Applied mathematics and computation, 93(2-3):195-205,
1998.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: A simple way to prevent neural networks from overfitting. The Journal of Machine
Learning Research, 15(1):1929-1958, 2014.
Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of initialization
and momentum in deep learning. In International conference on machine learning, pp. 1139-1147,
2013.
Keiichi Tokuda, Heiga Zen, and Tadashi Kitamura. Trajectory modeling based on hmms with the
explicit relationship between static and dynamic features. In Eighth European Conference on
Speech Communication and Technology, 2003.
Chiheb Trabelsi, Olexa Bilaniuk, Dmitriy Serdyuk, Sandeep Subramanian, Joao FeliPe Santos,
Soroush Mehri, Negar Rostamzadeh, Yoshua Bengio, and Christopher J Pal. Deep complex
networks. arXiv preprint arXiv:1705.09792, 2017.
Bipin Kumar Tripathi. High Dimensional Neurocomputing. Springer, 2016.
Mark Tygert, Joan Bruna, Soumith Chintala, Yann LeCun, Serkan Piantino, and Arthur Szlam. A
mathematical motivation for complex-valued convolutional networks. Neural computation, 28(5):
815-825, 2016.
Scott Wisdom, Thomas Powers, John Hershey, Jonathan Le Roux, and Les Atlas. Full-capacity
unitary recurrent neural networks. In Advances in Neural Information Processing Systems, pp.
4880-4888, 2016.
D Xu, L Zhang, and H Zhang. Learning alogrithms in quaternion neural networks using ghr calculus.
Neural Network World, 27(3):271, 2017.
11
Published as a conference paper at ICLR 2019
6 Appendix
6.1	Wall Street Journal experiments and computational complexity
This Section proposes to validate the scaling of the proposed QLSTMs to a bigger and more realistic
corpus, with a speech recognition task on the Wall Street Journal (WSJ) dataset. Finally, it discuses
the impact of the quaternion algebra in term of computational compexity.
6.1.1	Speech recognition with the Wall Street Journal corpus
We propose to evaluate both QLSTMs and LSTMs with a larger and more realistic corpus to validate
the scaling of the observed TIMIT results (Section 4.2). Acoustic input features are described in
Section 4.1, and extracted on both the 14 hour subset ‘train-si84’, and the full 81 hour dataset ’train-
si284’ of the Wall Street Journal (WSJ) corpus. The ‘test-dev93’ development set is employed for
validation, while ’test-eval92’ composes the testing set. Models architectures are fixed with respect to
the best results observed with the TIMIT corpus (Section 4.2). Therefore, both QLSTMs and LSTMs
contain four bidirectional layers of internal dimension of size 1, 024. Then, an additional layer of
internal size 1, 024 is added before the output layer. The only change on the training procedure
compared to the TIMIT experiments concerns the model optimizer, which is set to Adam (Kingma &
Ba, 2014) instead of RMSPROP. Results are from a 3-folds average.
Table 3: Word error rates (WER %) obtained with both training set (WSJ14h and WSJ81h) of the Wall
Street Journal corpus. ’test-dev93’ and ’test-eval92’ are used as validation and testing set respectively.
L expresses the number of recurrent layers.
Models	WSJ14 Dev.	WSJ14 Test	WSJ81 Dev.	WSJ81 Test	Params
LSTM	11.2	7.2	7.4	4.5	53.7M
QLSTM	10.9	6.9	7.2	4.3	18.7M
It is important to notice that reported results on Table 3 compare favorably with equivalent architec-
tures (Graves et al., 2013a) (WER of 11.7% on ’test-dev93’), and are competitive with state-of-the-art
and much more complex models based on better engineered features (Chan & Lane, 2015)(WER
of 3.8% with the 81 hours of training data, and on ’test-eval92’). According to Table 3, QLSTMs
outperform LSTM in all the training conditions (14 hours and 81 hours) and with respect to both
the validation and testing sets. Moreover, QLSTMs still need 2.9 times less neural parameters than
LSTMs to achieve such performances. This experiment demonstrates that QLSTMs scale well to
larger and more realistic speech datasets and are still more efficient than real-valued LSTMs.
6.1.2	Notes on computational complexity
A computational complexity of O(n2) with n the number of hidden states has been reported by
Morchid (2018) for real-valued LSTMs. QLSTMs just involve 4 times larger matrices during
computations. Therefore, the computational complexity remains unchanged and equals to O(n2).
Nonetheless, and due to the Hamilton product, a single forward propagation between two quaternion
neurons uses 28 operations, compared to a single one for two real-valued neurons, implying a longer
training time (up to 3 times slower). However, such worst speed performances could easily be
alleviated with a proper engineered cuDNN kernel for the Hamilton product, that would helps QNNs
to be more efficient than real-valued ones. A well-adapted CUDA kernel would allow QNNs to
perform more computations, with fewer parameters, and therefore less memory copy operations from
the CPU to the GPU.
6.2	Parameters initialization
Let us recall that a generated quaternion weight w from a weight matrix W has a polar form defined
as:
W = |w|eq/mag" = ∣w∣(cos(θ) + q/mag sin(θ)),	(25)
12
Published as a conference paper at ICLR 2019
with qi/mag = 0 + xi + yj + zk a purely imaginary and normalized quaternion. Therefore, w can be
computed following:
Wr = φ cos(θ),
Wi = Ψ q/magi sin(θ),	(26)
Wj = (Pqimagj sin(θ),
Wk = Pqimagk Sin⑻.
However, P represents a randomly generated variable with respect to the variance of the quaternion
weight and the selected initialization criterion. The initialization process follows (Glorot & Bengio,
2010) and (He et al., 2015) to derive the variance of the quaternion-valued weight parameters. Indeed,
the variance of W has to be investigated:
Var(W) =E(|W|2) - [E(|W|)]2.
(27)
[E(|W |)]2 is equals to 0 since the weight distribution is symmetric around 0. Nonetheless, the value
of V ar(W) = E(|W |2) is not trivial in the case of quaternion-valued matrices. Indeed, W follows a
Chi-distribution with four degrees of freedom (DOFs) and E(|W |2) is expressed and computed as
follows:
E(|W |2) =	x2f (x) dx,
0
(28)
With f (x) is the probability density function with four DOFs. A four-dimensional vector X =
{A, B, C, D} is considered to evaluate the density function f(x). X has components that are
normally distributed, centered at zero, and independent. Then, A, B, C and D have density functions:
e-x2∕2σ2
fA(x; σ) = fB (x; σ) = fc(x; σ) = f0(x; σ) =	__亍.	(29)
2πσ2
The four-dimensional vector X has a length L defined as L = √A2 + B2 + C2 + D2 with a
cumulative distribution function FL(x; σ) in the 4-sphere (n-sphere with n = 4) Sx:
FLE σ)=H SL
fA(x; σ)fB (x; σ)fC(x; σ)fD(x; σ) dSx
(30)
where Sx = {(a, b, c, d) : ʌ/a2 + b2 + c2 + d2 < x} and dSχ = dadbdcdd. The polar representa-
tions of the coordinates of X in a 4-dimensional space are defined to compute dSx:
a = ρcos θ,
b = ρsinθcosφ,
c = ρsinθsinφcosψ,
d = ρsinθsinφsinψ,
where P is the magnitude (P = √a2 + b2 + c2 + d2) and θ, φ, and ψ are the phases with 0 ≤ θ ≤ ∏,
0 ≤ φ ≤ π and 0 ≤ ψ ≤ 2π. Then, dSx is evaluated with the Jacobian Jf of f defined as:
∂ (a, b, c, d)	da db dc dd
f	∂(ρ,θ,φ,ψ)	dρ dθ dφ dψ
da
db
dc
dd
da	da
dθ	dφ
db	db
dθ	dφ
dc	dc_
dθ	dφ
dd	dd
dθ	dφ
da
第
dψ
dc
dψ
dd
dψ
cos θ
sin θ cos φ
= sin θ sin φ cos ψ
sin θ sin φ sin ψ
And,
-Psinθ
P sin θ cos φ
P cos θ sin φ cos ψ
P cos θ sin φ sin ψ
0
-Psinθsinφ
P sin θ cos φ cos ψ
P sin θ cos φ sin ψ
0
0
-Psinθsinφsinψ
P sin θ sin φ cos ψ
Jf = P3 sin2 θ sin φ.
(31)
13
Published as a conference paper at ICLR 2019
Therefore, by the Jacobian Jf, we have the polar form:
da db dc dd = ρ3 sin2 θ sin φ dρdθ dφ dψ.
(32)
Then, writing Eq.(30) in polar coordinates, we obtain:
FL (x, σ)
1
4π2σ4
Zxe-a2∕2σ2e-b2∕2σ2e-c2∕2σ2e-d2∕2σ2dSx
0
e-ρ2∕2σ2 ρ3 sin2 θ sin φdρdθdφdψ
0
2 4	Z	dψ Z	Sin φ dφ Z	sin2 θ dθ Z	ρ3e~-p2^σ	dρ
4π σ	0	0	0	0
π
4π2σ4 2π2
,4π∏
4π2σ4	2
£
2
Z0
sin2θ
4
x ρ3e-ρ2∕2σ2 dρ
0
ρ3^-ρ∕2σσ dρ,
—
0
Then,
FL (x, σ)
x ρ3e-ρ2∕2σ2 dρ.
(33)
The probability density function for X is the derivative of its cumulative distribution function, which
by the fundamental theorem of calculus is:
fL(x,σ) = -dχFL(χ,σ)
—1	3 -x2∕2σ2
=2σ4 X
(34)
The expectation of the squared magnitude becomes:
E(|W|2)
x2f(x) dx
0
Z x2-ɪ-x3e-x2∕2σ2 dx
Jo	2σ4
x5e-x2∕2σ2 dx.
With integration by parts we obtain:
E(|W|2)
ɪ f-χ4σ2e-x2∕2σ2∣∞ +
2σ4 1 xσ e	∣o +
χ⅛ Ji/2(T + Z
2σ2	0	0
Z∞ σ24x3e-x2∕2σ2
0
∞
4x3e-x
2∕2σ
(35)
The expectation E(|W |2) is the sum of two terms. The first one:
-x4e-x2∕2σ2∣∣∞= lim -x4e-x2∕2σ2
0	x→+∞
= lim -x4e-x2∕2σ2
x→+∞
lim
x→+0
x4e-x2∕2σ
—
14
Published as a conference paper at ICLR 2019
Based on the L'H6pitaTs rule, the undetermined limit becomes:
lim	-x4e-x2∕2σ2
x→+∞
- lim
x→+∞
4
x
ex2∕2σ2
-- IllM ------：--------Z-TT Z 
x→+∞ (1∕σ2)(P(x)ex /2σ )
0.
(36)
With P(x) is polynomial and has a limit to +∞. The second term is calculated in a same way
(integration by parts) and E(|W |2) becomes from Eq.(35):
E(|WI2) = ± Z∞ 4x3e-x2∕2σ2 dx
2σ2 0
=∣2 (x2σ2e-S2『+ /∞ σ22xe-x2/2-2 dx)
(37)
The limit of first term is equals to 0 with the same method than in Eq.(36). Therefore, the expectation
is:
(38)
And finally the variance is:
Var(|W|) = 4σ2.
(39)
6.3 Quaternion backpropagation through time
Let us recall the forward equations and parameters needed to derive the complete quaternion
backpropagation through time (QBPTT) algorithm.
6.3.1	Recall of the forward phase
Let xt be the input vector at timestep t, ht the hidden state, Whh , Wxh and Why the hidden state,
input and output weight matrices respectively. Finally bh is the biases vector of the hidden states and
pt , yt are the output and the expected target vector.
ht = α(htpreact),	(40)
with,
hpreact = Whh 乳 ht-1 + Wxh 乳 Xt + bh,	(41)
and α is the quaternion split activation function (Xu et al., 2017) of a quaternion Q defined as:
α(Q) =f(r)+if(x)+jf(y)+kf(z),	(42)
and f corresponding to any standard activation function. The output vector pt can be computed as:
pt = β(ptpreact),	(43)
with
Ppreact = Why 0 ht,	(44)
and β any split activation function. Finally, the objective function is a real-valued loss function
applied component-wise. The gradient with respect to the MSE loss is expressed for each weight
matrix as ∂Wt , JWt丸, 部：,and for the bias vector as ∂Et. In the real-valued space, the dynamic
of the loss is only investigated based on all previously connected neurons. In this extent, the QBPTT
differs from BPTT due to the fact that the loss must also be derived with respect to each component of
a quaternion neural parameter, making it bi-level. This could act as a regularizer during the training
process.
15
Published as a conference paper at ICLR 2019
6.3.2	Output weight matrix
The weight matrix Why is used only in the computation of pt. It is therefore straightforward to
comPute 森:
∂Et _ ∂Et ι , ∂Et ι , ∂Et 一 ∂Et	....
E = E + i∂Wξ+j∂Wξ + k∂Wξ.	( )
Each quaternion component is then derived following the chain rule:
∂Et _ ∂Et ∂pr ι ∂Et ∂pt	ι ∂Et ∂pj ι ∂Et M
而以=丽7 E +班而以+而而以+砒∂Wξ	(46)
=(Pr-或)× 传 + (pt - yt) × ht + (pj - yj) × hj + (Pt-y) × h2.
∂Et _ ∂Et ∂pr , ∂Et ∂pt , ∂Et ∂pj , ∂Et ∂pt
∂Wξ =丽7 而需 + 丽 ∂Wξ + 加 ∂Wξ + 砒 ∂Wξ	(47)
=(pr - ytt) × -ht + (pt - yt) × h + (pj - yj) × h + (Pt -斓)× -hj.
∂Et	∂Et dpr , ∂Et ∂pt , ∂Et ∂pj , ∂Et ∂pt
而惑=丽7 ∂Wξ + 丽而惑+ 赢 ∂Wj + 砒 ∂Wj	(48)
=(pt - yt) × -hj + (Pjt-Vi × -ht + (Pj-yj × h + (pt - yk) × Kt.
∂Et ∂Et dpr	, ∂Et ∂pt , ∂Et ∂pj ι ∂Et ∂pt
F =丽7 ∂Why + 丽 ∂why + 而 ∂Why + 前 ∂Why
=(IPt-V) × -忧 + (Pt - vi) × hj + (pj -翦 × -ht + (Pit -V) × ht.
By regrouping in a matrix form the ht components from these equations, one can define:
hj	h'
ht	-hj = h*
ht	h t.
-%	ht」
Therefore,
∂Wy = (Pt - yt)㊈ h
•2 工∙7 t >κ t
h---
(49)
(50)
(51)
k t
曙传心M
6.3.3	Hidden weight matrix
Conversely to Why the weight matrix Whh is an argument of ht with ht-ι involved. The recursive
backpropagation can thus be derived as:
∂E _XX ∂Et
∂Whh	与 ∂Whh
(52)
And,
∂Et
∂Whh
X ∂Em	∂Em	. ∂Em	k∂Em
m=0 百+iE+j∂Whh + ∂Whh,
(53)
with N the number of timesteps that compose the sequence. As for Why we start with 沫k :
*hh
∂Em =
m=o ∂wth	m=o
+
∂Et dhr ∂hm ∂Et ∂hit ∂him
,西西 E + 西 ∂hm ∂whh
∂Et ∂hj ∂hjm , ∂Et ∂ht a%
福∂j 否 +研诚∂Whh.
(54)
16
Published as a conference paper at ICLR 2019
Non-recursive elements are derived w.r.t r, ι,j, k:
∂Et	_ ∂Et	∂pr ∂Et	∂pt ∂Et ∂pj ∂Et	∂pk
∂hιt ∂p7t	∂hιt	+ ∂pt	∂hr	+ ∂pj ∂hr	+ ∂pk	∂hr
= (pr -或)× f0(pr) × Why + M-疝 ×f%t × Why
+ (pj - yj ) × f 0 (pj ) × Why + (pt -y ) × f' (pt ) × Why .
(55)
∂Et _	∂Et	∂pr ∂Et	∂pt ∂Et	∂pj ∂Et	∂pk
∂hit	∂p1t	∂hit	+ ∂pt	∂hit	+ ∂pj	∂hit	+ ∂pk	∂hit
=(pr - yr) × f0 (pr) × -wiiy + (Pi-W × f(而 × w^
+ (pj - yj) × f ((pj)× Wky + (pk - yk) × f((pk) × -Wjy.
∂Et _	∂Et ∂pr ∂Et ∂pt ∂Et	∂pj ∂Et ∂pt
∂hj	∂p∖ ∂hj	+ ∂pt ∂hj	+ ∂pj	∂hj	+ ∂plk ∂hj
=(pr - yr) × f((pr) × -Wjy + (Pii-yR×f(p) × -Wζ
+ (pj-yj)×f(pj)× W^y + (pk - yk) × f, (pk) × Wiy.
(56)
(57)
∂Et _ ∂Et ∂pr	∂Et ∂pt ∂Et ∂pj	∂Et ∂pk
而k = ~∂p 而k + 丽丽k + 而而k + ∂pk 而k
=(Tt-y) × f,(Prt) × -Wky + (Pit-yj×f'(启 × WM
+ (pj-yj)×f'(pj)× -Wiy + (pk - yk) × f,(pk) × Wr.
Then,
(58)
dhr,m
∂W r.
hh
dhr,m
∂WiΓ
∂hr,m
dWh
dhr,m
∂Wk,
h h
二 hr,t-1
-hi,t-1
-hj,t-1
-hk,t-1
dhi,m
∂Wr.
C 7. hh
dhi,m
∂Wr.
h h
dhi,m
∂w[7
dhi,m
∂w k
hh
二 hi,t-1
二 hi,t-1
-hk,t-1
二 hj,t-1
h™h
,rh∙,rh
w%lv
a a Q
-J
h
ð
%
小法
W
ð
-
-h
=
dhk,m
Wr
∂hk,rn
dWrr
dhk,m
∂Wj
∂hk,m
dWkr
hk,t-i
hk,t-i
hi,t-1
hr,t-1
崂.(59)
The remaining terms ∂h-
m
∂hi ∂hj	λ
,∂hi~,犷 and
m m<jm,
∂hk
dhm
are recursive and are written as:
户
ð
∂hr,t = TY ∂hr,n ∂hp^c + ∂h-n 讣f；Cc
∂hrm=n=m+1 ^∂^ ∂hr,n-i ∂hprct ∂hr,n-i
∂hr,n ∂hj 丁	∂hr,n ∂h也产
+ ∂hpnact ∂hr,n-1 + ∂hpr,^ct ∂hr,n-J
(60)
simplified with,
∂hr,t
∂hr,m
IY 券3∙ × W^h + 忌装 × Wih
n=m+1	r,n	'%,n
+× Wjh+∂⅛3 × Whh.
j,n k,n
(61)
17
Published as a conference paper at ICLR 2019
Consequently,
∂h*t dhi,m	T-Γ	dhi,n	iττi	dhi,n	τxrr =	[]	∂hWeαct × -Whh + abreact × Whh n=m+1	r,n	"气,n	(62) 十∖prenct × Whh+^r::Ct × -Whh. dhj,n	dhk,n
dhj,t 二 dhj,m	二 IY	∂j ×-Whh+费占 ×-Whh n=m+1	r,n	"气,n	(63) dhj,n	τ-1-7-r	dhj,n	IX『i + ahpreact × Whh + Q^eacC. × Whh. 5j	knk,n
∂hk,t dhk,m	=IY	×-Whh +	× Wjh n=m+1 dhr,n	Mn	碎 + ∂hpEct × -Whh + ∂hpTct × Whh. Ohj,n	dhk,n
The same operations are performed for i,j,k in Eq. 68 and 部鼠 can finally be expressed as:
	怒=XX0(nΠZn))屋一	(65)
with,
δn =	J Whh ㊈ δn+ι × a'(h^∙)	if n = t	(66) [W^y 乳(pn - yn) × β' (ppn'eact) else.	’)
6.3.4 Input weight matrix
部:is computed in the exact same manner as 帚^ .
∂E _XX ∂Et
∂whx = = ∂WhX.
And,
d Et _ X dEm	. d Em	. d Em	/ dEm
E = m=o dWL + "西匚 + j∂WhX + ∂wE.
Therefore 嘉t is easily extent as:
∂⅛ = X ( ItI δn)0 W.
m=0 n=m+1
(67)
(68)
(69)
6.3.5 Hidden biases
∂Et can easily be extended to:
∂E _ X ∂Et
西=t0西.
(70)
18
Published as a conference paper at ICLR 2019
And,
∂Et _ X ∂Em i∂Em .∂Em k∂Em
西=m=o西+"西+j西+砺k.
Nonetheless, since biases are not connected to any inputs or hidden states, the matrix of derivatives
defined in Eq. 59 becomes a matrix of 1. Consequently ∂Et can be summarized as:
∂Et
西
tt
X ( Y	δn).
m=0 n=m+1
(72)
19