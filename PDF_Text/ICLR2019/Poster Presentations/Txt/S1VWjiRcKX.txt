Published as a conference paper at ICLR 2019
Universal Successor Features Approximators
Diana Borsa*, Andre Barreto, John Quan, Daniel Mankowitz, Remi Munos
Hado van Hasselt, David Silver, Tom Schaul
DeepMind
London, UK
{borsa,andrebarreto,johnquan,dmankowitz,munos,
hado,davidsilver,schaul}@google.com
Ab stract
The ability of a reinforcement learning (RL) agent to learn about many reward
functions at the same time has many potential benefits, such as the decomposition
of complex tasks into simpler ones, the exchange of information between tasks,
and the reuse of skills. We focus on one aspect in particular, namely the ability to
generalise to unseen tasks. Parametric generalisation relies on the interpolation
power of a function approximator that is given the task description as input; one
of its most common form are universal value function approximators (UVFAs).
Another way to generalise to new tasks is to exploit structure in the RL problem
itself. Generalised policy improvement (GPI) combines solutions of previous tasks
into a policy for the unseen task; this relies on instantaneous policy evaluation of old
policies under the new reward function, which is made possible through successor
features (SFs). Our proposed universal successor features approximators (USFAs)
combine the advantages of all of these, namely the scalability of UVFAs, the instant
inference of SFs, and the strong generalisation of GPI. We discuss the challenges
involved in training a USFA, its generalisation properties and demonstrate its
practical benefits and transfer abilities on a large-scale domain in which the agent
has to navigate in a first-person perspective three-dimensional environment.
1	Introduction
Reinforcement learning (RL) provides a general framework to model sequential decision-making
problems with sparse evaluative feedback in the form of rewards. The recent successes in deep RL
have prompted interest in increasingly more complex tasks and a shift in focus towards scenarios in
which a single agent must solve multiple related problems, either simultaneously or sequentially. This
paradigm is formally known as multitask RL (Taylor and Stone, 2009; Teh et al., 2017). One of the
benefits of learning about multiple tasks at the same time is the possibility of transferring knowledge
across tasks; in essence, this means that by jointly learning about a set of tasks one should be able
to exploit their common structure to speed up learning and induce better generalisation (Taylor and
Stone, 2009; Lazaric, 2012). A particularly interesting instance of transfer is the generalisation to
new, unseen tasks. This potentially allows an agent to perform a task with little or no learning by
leveraging knowledge from previously learned tasks. In this paper we will be exploring this scenario.
Consider an RL agent in a persistent environment trying to master a number of tasks. In order to
generalise to unseen tasks, the agent needs to be able to identify and exploit some common structure
underlying the tasks. Two possible sources of structure in this scenario are: i) some similarity
between the solutions of the tasks, either in the policy or in the associated value-function space, and
ii) the shared dynamics of the environment (e.g., physics). In this paper we will attempt to build an
agent that can make use of both types of structure. For this, we will build on two frameworks that
exploit these structures in isolation. The first one are Schaul et al.’s (2015) universal value function
approximators (UVFAs). UVFAs extend the notion of value functions to also include the description
of a task, thus directly exploiting the common structure in the associated optimal value functions. The
second framework we build upon exploits the common structure in the environment and capitalises
on the power of dynamic programming. Barreto et al.’s (2017) framework is based on two core
* Corresponding author: borsa@google.com
1
Published as a conference paper at ICLR 2019
concepts: successor features (SFs), a representation scheme that allows a policy to be evaluated on
any task of a given format, and generalised policy improvement (GPI), a generalisation of dynamic
programming’s classic operator that uses a set of policies instead of a single one.
UVFAs and SF&GPI generalise to new tasks in quite different, and potentially complementary, ways.
UVFAs aim to generalise across the space of tasks by exploiting structure in the underlying space
of value functions. In contrast, SF&GPI strategy is to exploit the structure of the RL problem itself.
In this paper we propose a model that exhibits both types of generalisation. The basic insight is
to note that SFs are multi-dimensional value functions, so we can extend them in the same way a
universal value function extends their unidimensional counterparts. We call the resulting model
universal successor features approximators, or USFAs for short. USFA is a strict generalisation of its
precursors. Specifically, we show that by combining USFAs and GPI we can recover both UVFAs
and SF&GPI as particular cases. This opens up a new spectrum of possible approaches in between
these two extreme cases. We discuss the challenges involved in training a USFA and demonstrate
the practical benefits of doing so on a large-scale domain in which the agent has to navigate in a
three-dimensional environment using only images as observations.
2	Background
In this section we present some background material, formalise the scenario we are interested in, and
briefly describe the methods we build upon.
2.1	Multitask reinforcement learning
We consider the usual RL framework: an agent interacts with an environment and selects actions in
order to maximise the expected amount of reward received in the long run (Sutton and Barto, 1998).
As usual, we assume that such an interaction can be modeled as a Markov decision process (MDP,
Puterman, 1994). An MDP is defined as a tuple M ≡ (S, A, p, R, γ) where S and A are the state and
action spaces, p(∙∣s, a) gives the next-state distribution upon taking action a in state s, R(s, a, s0) is a
random variable representing the reward received at transition s -→a s0, and γ ∈ [0, 1) is a discount
factor that gives smaller weights to future rewards.
As mentioned in the introduction, in this paper we are interested in the multitask RL scenario, where
the agent has to solve multiple tasks. Each task is defined by a reward function Rw ; thus, instead of a
single MDP M, our environment is a set of MDPs that share the same structure except for the reward
function. Following Barreto et al. (2017), we assume that the expected one-step reward associated
with transition s -→a s0 is given by
E [Rw(s, a, s0)] = rw(s, a, s0) = φ(s, a, s0)>w,
(1)
where φ(s, a, s0) ∈ Rd are features of (s, a, s0) and w ∈ Rd are weights. The features φ(s, a, s0) can
be thought of as salient events that may be desirable or undesirable to the agent, such as for example
picking up an object, going through a door, or knocking into something. In this paper we assume that
the agent is able to recognise such events—that is, φ is observable—, but the solution we propose
can be easily extended to the case where φ must be learned (Barreto et al., 2017). Our solution also
applies to the case where (1) is only approximately satisfied, as discussed by Barreto et al. (2018).
Given w ∈ Rd representing a task, the goal of the agent is to find a policy πw : S 7→ A that
maximises the expected discounted sum of rewards, also called the return G(wt) = Pi∞=0 γiRw(t+i) ,
where Rw(t) = Rw(St, At, St+1) is the reward received at the tth time step. A principled way to
address this problem is to use methods derived from dynamic programming (DP), which heavily rely
on the concept of a value function (Puterman, 1994). The action-value function of a policy π on task
w is defined as Qπw(s, a) ≡ Eπ hG(wt) | St = s, At = a] , where En [∙] denotes expected value when
following policy π. Based on Qπw we can compute a greedy policy π0(s) ∈ argmaxaQπw (s, a); one
of the fundamental results in DP guarantees that Qπw0 (s, a) ≥ Qπw(s, a) for all (s, a) ∈ S × A. The
computation of Qπw(s, a) and π0 are called policy evaluation and policy improvement; under certain
conditions their successive application leads to the optimal value function Qw, from which one can
derive an optimal policy for task W as πw(S) ∈ argmax@Qw(s, a) (Sutton and Barto, 1998).
2
Published as a conference paper at ICLR 2019
As a convention, in this paper we will add a tilde to a symbol to indicate that the associated quantity
is an approximation; we will then refer to the respective tunable parameters as θ . For example, the
agent computes an approximation Qπw ≈ Qπw by tuning θQ .
2.2	Transfer learning
Here we focus on one aspect of multitask RL: how to transfer knowledge to unseen tasks (Taylor and
Stone, 2009; Lazaric, 2012). Specifically, we ask the following question: how can an agent leverage
knowledge accumulated on a set of tasks M ⊂ Rd to speed up the solution of a new task w0 ∈/ M?
In order to investigate the question above we recast it using the formalism commonly adopted in
learning. Specifically, we define a distribution Dw over Rd and assume the goal is for the agent to
perform as well as possible under this distribution. As usual, we assume a fixed budget of sample
transitions and define a training set M 〜DW that is used by the agent to learn about the tasks of
interest. We also define a test set M0 〜DW and use it to assess the agent,s generalisation—that is,
how well it performs on the distribution of MDPs induced by DW .
A natural way to address the learning problem above is to use Schaul et al.’s (2015) universal value-
function approximators (UVFAs). The basic insight behind UVFAs is to note that the concept of
optimal value function can be extended to include as one of its arguments a description of the task; an
obvious way to do so in the current context is to define the function Q*(s, a, W) : S ×A× Rd → R
as the optimal value function associated with task w. The function Q*(s, a, w) is called a universal
value function (UVF); a UVFA is then the corresponding approximation, Q(s, a, w). When we define
transfer as above it becomes clear that in principle a sufficiently expressive UVFA can identify and
exploit structure across the joint space S × A × Rd . In other words, a properly trained UVFA should
be able to generalise across the space of tasks.
A different way of generalising across tasks is to use Barreto et al.’s (2017) framework, which
builds on assumption (1) and two core concepts: successor features (SFs) and generalised policy
improvement (GPI). The SFs ψ ∈ Rd of a state-action pair (s, a) under policy π are given by
∞
ψπ (s,a) ≡ En X Yi-tφi+1 | St = s,At = a .	⑵
i=t
SFs allow one to immediately compute the value of a policy π on any task w: it is easy to show that,
when (1) holds, QπW (s, a) = ψπ (s, a)>w. It is also easy to see that SFs satisfy a Bellman equation
in which φ play the role of rewards, so ψ can be learned using any RL method (Szepesvari, 2θ10).
GPI is a generalisation of the policy improvement step described in Section 2.1. The difference is
that in GPI the improved policy is computed based on a set of value functions rather than on a single
one. Suppose that the agent has learned the SFs ψπi of policies π1 , π2, ..., πn. When exposed to
a new task defined by w, the agent can immediately compute QπWi (s, a) = ψπi (s, a)>w. Let the
GPI policy be defined as π(s) ∈ argmaxaQmax(s, a), where Qmax = maxi Qπi. The GPI theorem
states that Qπ(s, a) ≥ Qmax(s, a) for all (s, a) ∈ S × A. The result also extends to the scenario
where we replace Qπi with approximations Qπi (Barreto et al., 2017).
3	Universal Successor Features Approximators
UVFAs and SF&GPI address the transfer problem described in Section 2.2 in quite different ways.
With UVFAs, one trains an approximator Q(s, a, w) by solving the training tasks w ∈ M using
any RL algorithm of choice. One can then generalise to a new task by plugging its description w0
into Q and then acting according to the policy π(s) ∈ argmaxaQ(s, a, w0). With SF&GPI one
solves each task w ∈ M and computes an approximation of the SFs of the resulting policies πW ,
πw	π
ψ (s, a) ≈ ψπw(s, a). The way to generalise to a new task w0 is to use the GPI policy defined as
π(s) ∈ argmaXa maXw∈M ψ W (s,a)>w0.
The algorithmic differences between UVFAs and SF&GPI reflect the fact that these approaches
exploit distinct properties of the transfer problem. UVFAs aim at generalising across the space
of tasks by exploiting structure in the function Q*(s, a, w). In practice, such strategy materialises
in the choice of function approximator, which carries assumptions about the shape of Q"s,a, w).
For example, by using a neural network to represent Q(s, a, w) one is implicitly assuming that
3
Published as a conference paper at ICLR 2019
Q*(s, a, W) is smooth in the space of tasks; roughly speaking, this means that small perturbations to
W will result in small changes in Q*(s, a, w).
In contrast, SF&GPI’s strategy to generalise across tasks is to exploit structure in the RL problem
itself. GPI builds on the general fact that a greedy policy with respect to a value function will in
general perform better than the policy that originated the value function. SFs, in turn, exploit the
structure (1) to make it possible to quickly evaluate policies across tasks—and thus to apply GPI
in an efficient way. The difference between the types of generalisation promoted by UVFAs and
SF&GPI is perhaps even clearer when we note that the latter is completely agnostic to the way the
πw
approximations ψ are represented, and in fact it can applied even with a tabular representation.
Obviously, both UVFAs and GPI have advantages and limitations. In order to illustrate this point,
consider two tasks W and w0 that are “similar”, in the sense that ||w - w0∣∣ is small (|| ∙ || is a
norm in Rd). Suppose that we have trained a UVFA on task W and as a result we obtained a good
approximation Q(s, a, w) ≈ Q*(s, a, w). If the structural assumptions underlying Q(s, a, w) hold—
for example, Q(s, a, w) is smooth with respect to w—, it is likely that Q(s, a, w0) will be a good
approximation of Q*(s, a, w0). On the other hand, if such assumptions do not hold, we should not
expect UVFA to perform well. A sufficient condition for SF&GPI to generalise well from task w
to task w0 is that the policy π(s) J argmaxaψ W (s, a)>w0 does well on task w0, where ∏w is a
solution for task w. On the downside, SF&GPI will not exploit functional regularities at all, even if
they do exist. Let policy πw0 be a solution for tasks w0 . In principle we cannot say anything about
π0	πw	π
ψ πw0 (s, a), the SFs of πw0, even if we have a good approximation ψ (s, a) ≈ ψπw (s, a).
As one can see, the types of generalisation provided by UVFAs and SF&GPI are in some sense
complementary. It is then natural to ask if we can simultaneously have the two types of generalisation.
In this paper we propose a model that provides exactly that. The main insight is actually simple: since
SFs are multi-dimensional value functions, we can extend them in the same way as universal value
functions extend regular value functions. In the next section we elaborate on how exactly to do so.
3.1	Universal successor features
As discussed in Section 2.2, UVFS are an extension of standard value functions defined as Q*(s, a, w).
If πw is one of the optimal policies of task w, we can rewrite the definition as Qπw (s, a, w). This
makes it clear that the argument w plays two roles in the definition of a UVF: it determines both
the task w and the policy πw (which will be optimal with respect to w). This does not have to be
the case, though. Similarly to Sutton et al.’s (2011) general value functions (GVFs), we could in
principle define a function Q(s, a, w, π) that “disentangles” the task from the policy. This would
provide a model that is even more general than UVFs. In this section we show one way to construct
such a model when assumption (1) (approximately) holds.
Note that, when (1) is true, we can revisit the definition of SFs and write Q(s, a, w, π) =
ψ π(s, a)>w. If we want to be able to compute Q(s, a, w, π) for any π, we need SFs to span the
space of policies π. Thus, we define universal successor features as ψ(s, a, π) ≡ ψ π(s, a). Based on
such definition, we call ψ(s, a, π) ≈ ψ(s, a, π) a universal successor features approximator (USFA).
In practice, when defining a USFA we need to define a representation for the policies π. A natural
choice is to embed π onto Rk. Let e : (S 7→ A) 7→ Rk be a policy-encoding mapping, that is,
a function that turns policies π into vectors in Rk. We can then see USFs as a function of e(π):
ψ (s, a, e(π)). The definition of the policy-encoding mapping e(π) can have a strong impact on the
structure of the resulting USF. We now point out a general equivalence between policies and reward
functions that will provide a practical way of defining e(π). It is well known that any reward function
induces a set of optimal policies (Puterman, 1994). A point that is perhaps less immediate is that the
converse is also true. Given a deterministic policy π, one can easily define a set of reward functions
that induce this policy: for example, we can have r∏ (s, π(s), ∙) = 0 and r∏(s, a, ∙) = c, with c < 0,
for any a 6= π(s). Therefore, we can use rewards to refer to deterministic policies and vice-versa (as
long as potential ambiguities are removed when relevant).
Since here we are interested in reward functions of the form (1), if we restrict our attention to policies
induced by tasks z ∈ Rd we end up with a conveniently simple encoding function e(πz) = z. From
this encoding function it follows that Q(s, a, w, πz) = Q(s, a, w, z). It should be clear that UVFs
are a particular case of this definition when w = z. Going back to the definition of USFs, we can
4
Published as a conference paper at ICLR 2019
finally write Q(s, a, w, z) = ψ(s, a, z)>w. Thus, if we learn a USF ψ(s, a, z), we have a value
function that generalises over both tasks and policies, as promised.
3.2	USFA generalisation
We now revisit the question as to why USFAs should provide the benefits associated with both UVFAs
and SF&GPI. We will discuss how exactly to train a USFA in the next section, but for now suppose
that we have trained one such model ψ(s, a, z) using the training tasks in M. It is then not difficult
to see that we can recover the solutions provided by both UVFAs and SF&GPI. Given an unseen task
w0, let π be the GPI policy defined as
0	>0
π(s) ∈ argmaxa max Q(s, a, w0, z) = argmaxa max ψ(s, a, z)>w0,	(3)
a z∈C	a z∈C
where C ⊂ Rd. Clearly, if we make C = {w0}, we get exactly the sort of generalisation associated
with UVFAs. On the other hand, setting C = M essentially recovers SF&GPI.
The fact that we can recover both UVFAs and SF&GPI opens up a spectrum of possibilities in
between the two. For example, we could apply GPI over the training set augmented with the current
task, C = M ∪ {w0}. In fact, USFAs allow us to apply GPI over any set of tasks C ⊂ Rd. The
benefits of this flexibility are clear when we look at the theory supporting SF&GPI, as we do next.
Barreto et al. (2017) provide theoretical guarantees on the performance of SF&GPI applied to any
task w0 ∈ M0 based on a fixed set of SFs. Below we state a slightly more general version of this result
that highlights the two types of generalisation promoted by USFAs (proof in Barreto et al.’s (2017)
Theorem 2).
Proposition 1 Let w0 ∈ M0 and let Qπw0 be the action-value function of executing policy π on task
π
w0. Given approximations {Qπwz0 = ψ(s, a, z)>w0}z∈C, let π be the GPI policy defined in 3. Then,
/	∖f	∖
2
kQWo - QWok∞ ≤  ----minz∈c kΦk∞ kw0 - Zk	+max ∣∣w0∣∣ ∙∣∣ψπz - ψ(s,a,z)k∞	,	(4)
1 - Y	、---{z--}	z∈C	、--------{z-------}
δd(z)	δψ(z)
where QWo is the optimal value oftask w0, ψπz are the SFs corresponding to the optimal PoUcyfor
task z, and kf - gk∞ = maxs,a |f (s, a) - g(s, a)|.
When we write the result in this form, it becomes clear that, for each policy πz , the right-hand side
of (4) involves two terms: i) δd(z), the distance between the task of interest w0 and the task that
induced πz, and ii) δψ(z), the quality of the approximation of the SFs associated with πz.
In order to get the tightest possible bound (4) we want to include in C the policy z that minimises
δd(z) + δψ (z). This is exactly where the flexibility of choosing C provided by USFAs can come in
handy. Note that, if we choose C = M, we recover Barreto et al.’s (2017) bound, which may have an
irreducible minz∈Cδd(z) even with a perfect approximation of the SFs in M. On the other extreme,
we could query our USFA at the test point C = {w0}. This would result in δd (w0) = 0, but can
potentially incur a high cost due to the associated approximation error δψ (w0).
3.3 How to train a USFA
Now that we have an approximation Q(s, a, w, z) a natural question is how to train this model. In
this section We show that the decoupled nature of Q is reflected in the training process, which assigns
clearly distinct roles for tasks w and policies πz .
In our scenario, a transition at time t will be (st, at, φt+1, st+1). Note that φ allows us to compute
the reward for any task w, and since our policies are encoded by z, transitions of this form allow
us to learn the value function of any policy πz on any task w. To see why this is so, let us define
the temporal-difference (TD) error (Sutton and Barto, 1998) used in learning these value functions.
5
Published as a conference paper at ICLR 2019
Given transitions in the form above, the n-step TD error associated with policy πz on task w will be
t+n-1
δ wnz = 工 Y i-t rw (Si ,ai ,Si+1)+ Yn Q)(st+n ,∏z (st+n), w, Z) - Q(St ,at, w, Z)
i=t
t+n-1	>
=	Yi- Y i-t φ(si ,ai ,Si+1) + Yn ψ(st+n ,at+n, z) - ψ(st ,at, Z)	W = (δ Z,n )> w, (5)
i=t
where at+n = argmaxbQ(St+n, b, Z, Z) = argmaxbψ(St+n, b, Z)>Z. As is well known, the TD
error δ tw,nz allows us to learn the value of policy πz on task w; since here δ tw,nz is a function of Z and
w only, we can learn about any policy πz on any task w by just plugging in the appropriate vectors.
Equation (5) highlights some interesting (and subtle) aspects involved in training a USFA. Since the
value function Q(S, a, w, Z) can be decoupled into two components, ψ(S, a, Z) and w, the process
of evaluating a policy on a task reduces to learning ψ(s, a, z) using the vector-based TD error δZ,n
tn
showing up in (5). Since δtZ,n is a function of Z only, the updates to Q(S, a, w, Z) will not depend on
w. How do the tasks w influence the training of a USFA, then? If sample transitions are collected
by a behaviour policy, as is usually the case in online RL, a natural choice is to have this policy be
induced by a task w. When this is the case the training tasks w ∈ M will define the distribution used
to collect sample transitions. Whenever we want to update ψ(S, a, Z) for a different Z than the one
used in generating the data, we find ourselves under the off-policy regime (Sutton and Barto, 1998).
Assuming that the behaviour policy is induced by the tasks w ∈ M, training a USFA involves two
main decisions: how to sample tasks from M and how to sample policies πZ to be trained through (5)
or some variant. As alluded to before, these decisions may have a big impact on the performance of
the resulting USFA, and in particular on the trade-offs involved in the choice of the set of policies C
used by the GPI policy (3). As a form of illustration, Algorithm 1 shows a possible regime to train a
USFA based on particularly simple strategies to select tasks w ∈ M and to sample policies Z ∈ Rd .
One aspect of Algorithm 1 worth calling attention to is the fact that the distribution DZ used to select
policies can depend on the current task w. This allows one to focus on specific regions of the policy
space; for example, one can sample policies using a Gaussian distribution centred around w.
Algorithm 1 Learn USFA with -greedy Q-learning
Require: , training tasks M, distribution DZ over Rd, num-
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
ber of policies nZ
select initial state S ∈ S
for ns steps do
sample w uniformly at random from M
{sample policies, possibly based on current task}
for i - 1,2,…,nz do Zi 〜Dz(∙∣w)
if BernoUlli(e)=1 then a J Uniform(A)
else a J argmaXb maxi ψ(s, b, Zi)>W {GPI }
Execute action a and observe φ and S0
for i J 1,2,..., nz do {Update ψ}
a0 J argmaxbψ(S, b, Zi)>Zi {a0 ≡ πi(S0)}
θ <- [φ + Yψ(s0, a', Zi) - Ψψ(s, a, Zi)] Vθψ
S J S0
11 * 3: return θ Figure 1: USFA architecture
4	Experiments
In this section we describe the experiments conducted to test the proposed architecture in a multitask
setting and assess its ability to generalise to unseen tasks.
4.1 Illustrative example: Trip MDP
We start with a simple illustrative example to provide intuition on the kinds of generalisation provided
by UVFAs and SF&GPI. We also show how in this example USFAs can effectively leverage both
6
Published as a conference paper at ICLR 2019
Figure 2: Trip MDP: [Left] Depiction of MDP. [Right] Optimality gap (Difference between optimal
return and the return obtained by the different models) at different times in the training process.
Training iterations (10 episodes each)
types of generalisation and outperform its precursors. For this we will consider the simple two-state
MDP depicted in Figure 2. To motivate the example, suppose that state s1 of our MDP represents
the arrival of a traveler to a new city. The traveler likes coffee and food and wants to try what the
new city has to offer. In order to model that, we will use features φ ∈ R2, with φ1 representing
the quality of the coffee and φ2 representing the quality of the food, both ranging from 0 to 1. The
traveler has done some research and identified the places that serve the best coffee and the best food;
in our MDP these places are modelled by terminal states associated with actions ‘C’ and ‘F’ whose
respective associated rewards are φ(∙, C) = φ(C) = [1,0] and φ(F) = [0,1]. As one can infer from
these feature vectors, the best coffee place does not serve food and the best restaurant does not serve
coffee (at least not a very good one). Nevertheless, there are other places in town that serve both; as
before, we will model these places by actions Pi associated with features φ(Pi). We assume that
kφ(Pi)k2 = 1 and consider N = 5 alternative places Pi evenly spaced on the preference spectrum.
We model how much the traveler wants coffee and food on a given day by w ∈ R2 . If the traveler
happens to want only one of these (i.e. w ∈ {[1, 0], [0, 1]}), she can simply choose actions ‘C’ or
'F' and get a reward r = φ(∙)>w = 1. If instead she wants both coffee and food (i.e. if W is not an
“one-hot” vector), it may actually be best to venture out to one of the other places. Unfortunately,
this requires the traveler to spend some time researching the area, which we model by an action ‘E’
associated with feature φ(E) = [-, -]. After choosing ‘E’ the traveler lands on state s2 and can
now reach any place in town: C, F, P1, ..., PN. Note that, depending on the vector of preferences w,
it may be worth paying the cost of φ(E)>w to subsequently get a reward of φ(Pi)>w (here γ = 1).
In order to assess the transfer ability of UVFAs, SF&GPI and USFAs, we define a training set
M = {10, 01} and K = 50 test tasks corresponding to directions in the two-dimensional w-space:
M0 = {w0∣w0 = [cos(2∏κ), sin(累)],k = 0,1,..., K}. We start by analysing what SF&GPI would
do in this scenario. We focus on training task wC = [1, 0], but an analogous reasoning applies
to task wF = [0, 1]. Let πC be the optimal policy associated with task wC. It is easy to see that
π(s1) = π(s2) = C. Thus, under πC it should be clear that QπwC0 (s1, C) > QπwC0 (s1, E) for all test
tasks w0. Since the exact same reasoning applies to task wF if we replace action C with action F, the
GPI policy (3) computed over {ψπC, ψπF } will be suboptimal for most test tasks in M0. Training a
UVFA on the same set M, will not be perfect either due to the very limited number of training tasks.
Nonetheless the smoothness in the approximation allows for a slightly better generalisation in M0.
Alternatively, we can use Algorithm 1 to train a USFA on the training set M. In order to do so we
sampled n = 5 policies Z ∈ R2 using a uniformly random distribution Dz(∙∣w) = U([0,1]2) (see
line 5 in Algorithm 1). When acting on the test tasks w0 we considered two choices for the candidates
set: C = {w0} and C = {z∕zi 〜 U([0,1]2),i = 1,2,…，5}. Empirical results are provided in
Figure 2. As a reference we report the performance of SF&Gpi using the true {ψπC, ψπF } - no
approximation. We also show the learning curve of a UVFA. As shown in the figure, USFA clearly
outperforms its precursors and quickly achieves near optimal performance. This is due to two factors.
First, contrary to vanilla SF&GPI, USFA can discover and exploit the rich structure in the policy-
space, enjoying the same generalisation properties as UVFAs but now enhanced by the combination
of the off-policy and off-task training regime. Second, the ability to sample a candidate set C that
induces some diversity in the policies considered by GPI overcomes the suboptimality associated
with the training SFs ψπC and ψπF . We explore this effect in a bit more detail in the suppl. material.
7
Published as a conference paper at ICLR 2019
4.2	Large scale experiments
Figure 3: Environment.
Environment and tasks. We used the
DeepMind Lab platform to design a
3D environment consisting of one large
room containing four types of objects:
TVs, balls, hats, and balloons (Beattie
et al., 2016; Barreto et al., 2018). A
depiction of the environment through
the eyes of the agent can be seen in
Fig. 3. Features φi are indicator func-
tions associated with object types, i.e.,
φi (s, a, s0) = 1 if and only if the agent
collects an object of type i (say, a TV) on the transition s -→a s0 . A task is defined by four real
numbers w ∈ R4 indicating the rewards attached to each object. Note that these numbers can be
negative, in which case the agent has to avoid the corresponding object type. For instance, in task
w = [1-100] the agent is interested in objects of the first type and should avoid objects of the second.
Agent architecture. A depiction of the architecture used for the USFA agent is illustrated in Fig. 1.
The architecture has three main modules: i) A fairly standard input processing unit composed of
three convolution layers and an LSTM followed by a non-linearity (Schmidhuber, 1996); ii) A policy
conditioning module that combines the state embedding coming from the first module, s ≡ f (h),
and the policy embedding, z, and produces |A| ∙ d outputs corresponding to the SFS of policy πz,
ψ(s, a, z); and iii) The evaluation module, which, given a task w and the SFs ψ(s, a, z), will
construct the evaluation of policy πz on w, Q(s, a, w, z) = ψ(s, a, z)>w.
Training and baselines. We trained the above architecture end-to-end using a variation of Alg. 1
that uses Watkins’s (1989) Q(λ) to apply Q-learning with eligibility traces. As for the distribution Dz
used in line 5 of Alg. 1 We adopted a Gaussian centred at w: Z 〜N(w, 0.11), where I is the identity
matrix. We used the canonical vectors of R4 as the training set, M = {1000, 0100, 0010, 0001}.
Once an agent was trained on M we evaluated it on a separate set of unseen tasks, M0 , using the GPI
policy (3) over different sets of policies C. Specifically, we used: C = {w0}, which corresponds to a
UVFA with an architecture specialised to (1); C = M, which corresponds to doing GPI on the SFs of
the training policies (similar to (Barreto et al., 2017)), and C = M ∪ {w0}, which is a combination
of the previous two. We also included as baselines two standard UVFAs that do not take advantage of
the structure (1); one of them was trained on-policy and the other one was trained off-policy (see
supplement). The evaluation on the test tasks M0 was done by “freezing” the agent at different stages
of the learning process and using the GPI policy (3) to select actions. To collect and process the data
we used an asynchronous scheme similar to IMPALA (Espeholt et al., 2018).
4.3	Results and discussion
Fig. 4 shows the results of the agents after being trained on M. One thing that immediately stands
out in the figure is the fact that all architectures generalise quite well to the test tasks. This is a
surprisingly good result when we consider the difficulty of the scenario considered: recall that the
agents are solving the test tasks without any learning taking place. This performance is even more
impressive when we note that some test tasks contain negative rewards, something never experienced
by the agents during training. When we look at the relative performance of the agents, it is clear
that USFAs perform considerably better than the unstructured UVFAs. This is true even for the
case where C = {w0}, in which USFAs essentially reduce to a structured UVFA that was trained by
decoupling tasks and policies. The fact that USFAs outperform UVFAs in the scenario considered
here is not particularly surprising, since the former exploit the structure (1) while the latter cannot. In
any case, it is reassuring to see that our model can indeed exploit such a structure effectively. This
result also illustrates a particular way of turning prior knowledge about a problem into a favourable
inductive bias in the UVFA architecture.
It is also interesting to see how the different instantiations of USFAs compare against each other. As
shown in Fig. 4, there is a clear advantage in including M to the set of policies C used in GPI (3). This
suggests that, in the specific instantiation of this problem, the type of generalisation provided by SF&
GPI is more effective than that associated with UVFAs. One result that may seem counter-intuitive at
8
Published as a conference paper at ICLR 2019
Environment frame Ieg
Task 1100
tj-tj tj-2 0.4	σ.6 σ.a i-tj
Environment frame	Ieg
Environment frame	ɪeə
PJeMaJ 3POSQ.UJ
-5 ---------------------------------------------
tj-tj tj-2 0.4	σ.6 σ.a i-tj
Environment frame Ieg
-10 --------------------------------------------
tj-tj tj-2 0.4	σ.6 σ.a i-0
Environment frame Ieg
Environment frame	ɪeə
→- USFA (GPI over C = {w'})
UVFA
UVFA (OffpoIicy)
USFA (GPI over C = M)
USFA (GPI over C = M + {w'})
Figure 4:	Zero-shot generalisation performance, across different models, on a sample of test tasks
w0 ∈ M0 after training on M. Shaded areas represent one standard deviation over 10 runs.
Task 1100
∞5040302010
peMau QPoS-ʤ
0.2	0.4	0.6	0.8	1.0
Envlmnment frame le9
Task-IlOl
peMau QpoS-ʤ
0.0	0.2	0.4	0.6	0.8	1.0
Envimnment frame le9
peMaJΦpos-d3
Task-11-11
-*- USFA (GPl over C - {w,}>, o∙=0.L
-*- USFA(GP) over C - {w,}>, o∙=0.5
T- USFA (GPl over C - MJ1 o∙=0.1
-*- USFA (GPl over C - MJ1 o∙=0.5
0.2	0.4	0.6	0.8	1.0
Envlmnment frame le9
0.
Figure 5:	Generalisation performance on sample test tasks w0 ∈ M0 after training on M, with
Dz = N(w, σ I), for σ = 0.1 and σ = 0.5 (larger coverage of the z space). Average over 3 runs.
first is the fact that USFAs with C = M + {w0} sometimes perform worse than their counterparts
using C = M, especially on tasks with negative rewards. Here we note two points. First, although
including more tasks to C results in stronger guarantees for the GPI policy, strictly speaking there
are no guarantees that the resulting policy will perform better (see Barreto et al.’s Theorem 1, 2017).
Another explanation very likely in the current scenario is that errors in the approximations ψ(s, a, z)
may have a negative impact on the resulting GPI policy (3). As argued previously, adding a point to
C can sometimes increase the upper bound in (4), if the approximation at this point is not reliable.
On the other hand, comparing USFA’s results using C = M + {w0} and C = {w0}, we see that
by combining the generalisation of UVFAs and GPI we can boost the performance of a model that
only relies on one of them. This highlights the fine balance between the two error terms in (4) and
emphasizes how critical selecting low-error candidates in C can be.
In the above scenario, SF&GPI on the training set M seems to provide a more effective way
of generalising, as compared to UVFAs, even when the latter has a structure specialised to (1).
Nevertheless, with less conservative choices of Dz that provide a greater coverage of the z space we
expect the structured UVFA (C = {w0}) to generalise better. Note that this can be done without
changing M and is not possible with conventional UVFAs. One of the strengths of USFAs is exactly
that: by disentangling tasks and policies, one can learn about the latter without ever having to actually
try them out in the environment. We exploit this possibility to repeat our experiments now using
Dz = N(w, 0.5 I). Results are shown in Fig.5. As expected, the generalisation of the structured
UVFA improves considerably, almost matching that of GPI. This shows that USFAs can operate
in two regimes: i) with limited coverage of the policy space, GPI over M will provide a reliable
generalisation; ii) with a broader coverage of the space structured UVFAs will do increasingly better.1
1Videos of USFAs in action on the links https://youtu.be/Pn76cfXbf2Y and https://youtu.be/0afwHJofbB0.
9
Published as a conference paper at ICLR 2019
5	Related Work
Multitask RL is an important topic that has generated a large body of literature. Solutions to this
problem can result in better performance on the training set (Espeholt et al., 2018), can improve data
efficiency (Teh et al., 2017) and enable generalisation to new tasks. For a comprehensive presentation
of the subject please see Taylor and Stone (2009) and Lazaric (2012) and references therein.
There exist various techniques that incorporate tasks directly into the definition of the value function
for multitask learning (Kaelbling, 1993; Ashar, 1994; Sutton et al., 2011). UVFAs have been used for
zero-shot generalisation to combinations of tasks (Mankowitz et al., 2018; Hermann et al., 2017), or
to learn a set of fictitious goals previously encountered by the agent (Andrychowicz et al., 2017).
Many recent multitask methods have been developed for learning subtasks or skills for a hierarchical
controller (Vezhnevets et al., 2017; Andreas et al., 2016; Oh et al., 2017). In this context, Devin et al.
(2017) and Heess et al. (2016) proposed reusing and composing sub-networks that are shared across
tasks and agents in order to achieve generalisation to unseen configurations. Finn et al. (2017) uses
meta-learning to acquire skills that can be fine-tuned effectively. Sequential learning and how to
retain previously learned skills has been the focus of a number of investigations (Kirkpatrick et al.,
2016; Rusu et al., 2016). All of these works aim to train an agent (or a sub-module) to generalise
across many subtasks. All of these can be great use-cases for USFAs.
USFAs use a UVFA to estimate SFs over multiple policies. The main reason to do so is to apply GPI,
which provides a superior zero-shot policy in an unseen task. There have been previous attempts to
combine SFs and neural networks, but none of them used GPI (Kulkarni et al., 2016; Zhang et al.,
2016). Recently, Ma et al. (2018) have also considered combining SFs and UVFAs. They propose
building a goal-conditioned policy that aims to generalise over a collection of goals. In their work,
the SFs are trained to track this policy and only used to build the critic employed in training the
goal-conditioned policy. Thus, they are considering the extrapolation in π(s, g) and using the SFs
as an aid in training. Moreover, as both the training and SFs and π(s, g) are done on-policy, the
proposed system has only seen instances where the SFs, critic and policy are all conditioned on the
same goal. In contrast, in this work we argue and show the benefits of decoupling the task and policy
to enable generalisation via GPI when appropriate, while preserving the ability to exploit the structure
in the policy space. We use the SFs as a way to factorize and exploit effectively the structure in value
function space. And we will use these evaluations directly to inform our action selection
6	Conclusion
In this paper we presented USFAs, a generalisation of UVFAs through SFs. The combination of
USFAs and GPI results in a powerful model capable of exploiting the same types of regularity
exploited by its precursors: structure in the value function, like UVFAs, and structure in the problem
itself, like SF&GPI. This means that USFAs can not only recover their precursors but also provide
a whole new spectrum of possible models in between them. We described the choices involved in
training and evaluating a USFA and discussed the trade-offs associated with these alternatives. To
make the discussion concrete, we presented two examples aimed to illustrate different regimes of
operation. The first example embodies a MDP where the generalisation in the optimal policy space
is fairly easy but the number of optimal policies we would want to represent can be large. This is a
scenario where UVFAs would strive, while vanilla SF&GPI will struggle due to the large number
of policies needed to build a good GPI policy. In this case, we show that USFAs can leverage the
sort of parametric generalisation provided by UVFAs and even improve on it, due to its decoupled
training regime and the use of GPI in areas where the approximation is not quite perfect. Our second
example is in some sense a reciprocal one, where we know from previous work that the generalisation
provided via GPI can be very effective even on a small set of policies, while generalising in the space
of optimal policies, like UVFAs do, seems to require a lot more data. Here we show that USFAs can
recover the type of generalisation provided by SFs when appropriate. This example also highlights
some of the complexities involved in training at scale and shows how USFAs are readily applicable
to this scenario. Overall, we believe USFAs are a powerful model that can exploit the available
structure effectively: i) the structure induced by the shared dynamics (via SFs), ii) the structure in the
policy space (like UVFAs) and finally iii) the structure in the RL problem itself (via GPI), and could
potentially be useful across a wide range of RL applications that exhibit these properties.
10
Published as a conference paper at ICLR 2019
References
J. Andreas, D. Klein, and S. Levine. Modular multitask reinforcement learning with policy sketches.
arXiv preprint arXiv:1611.01796, 2016.
M. Andrychowicz, F. Wolski, A. Ray, J. Schneider, R. Fong, P. Welinder, B. McGrew, J. Tobin,
O. P. Abbeel, and W. Zaremba. Hindsight experience replay. In Advances in Neural Information
Processing Systems, pages 5048-5058, 2017.
R. Ashar. Hierarchical learning in stochastic domains. PhD thesis, Citeseer, 1994.
A. Barreto, W. Dabney, R. Munos, J. Hunt, T. Schaul, H. van Hasselt, and D. Silver. Successor
features for transfer in reinforcement learning. In Advances in Neural Information Processing
Systems (NIPS), 2017.
A. Barreto, D. Borsa, J. Quan, T. Schaul, D. Silver, M. Hessel, D. Mankowitz, A. Zidek, and
R. Munos. Transfer in deep reinforcement learning using successor features and generalised policy
improvement. In Proceedings of the International Conference on Machine Learning (ICML), pages
501-510, 2018.
C. Beattie, J. Z. Leibo, D. TePlyashin, T. Ward, M. Wainwright, H. Kuttler, A. Lefrancq, S. Green,
V. Valdes, A. Sadik, et al. Deepmind lab. arXiv preprint arXiv:1612.03801, 2016.
C. Devin, A. Gupta, T. Darrell, P. Abbeel, and S. Levine. Learning modular neural network policies for
multi-task and multi-robot transfer. In Robotics and Automation (ICRA), 2017 IEEE International
Conference on, pages 2169-2176. IEEE, 2017.
L. Espeholt, H. Soyer, R. Munos, K. Simonyan, V. Mnih, T. Ward, Y. Doron, V. Firoiu, T. Harley,
I. Dunning, et al. Impala: Scalable distributed deep-rl with importance weighted actor-learner
architectures. arXiv preprint arXiv:1802.01561, 2018.
C. Finn, P. Abbeel, and S. Levine. Model-agnostic meta-learning for fast adaptation of deep networks.
CoRR, abs/1703.03400, 2017. URL http://arxiv.org/abs/1703.03400.
N. Heess, G. Wayne, Y. Tassa, T. Lillicrap, M. Riedmiller, and D. Silver. Learning and transfer of
modulated locomotor controllers. arXiv preprint arXiv:1610.05182, 2016.
K.	M. Hermann, F. Hill, S. Green, F. Wang, R. Faulkner, H. Soyer, D. Szepesvari, W. Czarnecki,
M. Jaderberg, D. Teplyashin, et al. Grounded language learning in a simulated 3d world. arXiv
preprint arXiv:1706.06551, 2017.
L.	P. Kaelbling. Learning to achieve goals. In IJCAI, pages 1094-1099. Citeseer, 1993.
J. Kirkpatrick, R. Pascanu, N. C. Rabinowitz, J. Veness, G. Desjardins, A. A. Rusu, K. Milan, J. Quan,
T. Ramalho, A. Grabska-Barwinska, D. Hassabis, C. Clopath, D. Kumaran, and R. Hadsell.
Overcoming catastrophic forgetting in neural networks. CoRR, abs/1612.00796, 2016. URL
http://arxiv.org/abs/1612.00796.
T. D. Kulkarni, A. Saeedi, S. Gautam, and S. J. Gershman. Deep successor reinforcement learning.
arXiv preprint arXiv:1606.02396, 2016.
A. Lazaric. Transfer in Reinforcement Learning: A Framework and a Survey, pages 143-173. 2012.
C.	Ma, J. Wen, and Y. Bengio. Universal successor representations for transfer reinforcement learning.
arXiv preprint arXiv:1804.03758, 2018.
D.	J. Mankowitz, A. Zidek, A. Barreto, D. Horgan, M. Hessel, J. Quan, J. Oh, H. van Hasselt,
D. Silver, and T. Schaul. Unicorn: Continual learning with a universal, off-policy agent. arXiv
preprint arXiv:1802.08294, 2018.
V.	Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Ried-
miller, A. K. Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King,
D. Kumaran, D. Wierstra, S. Legg, and D. Hassabis. Human-level control through deep reinforce-
ment learning. Nature, 518(7540):529-533, 2015.
11
Published as a conference paper at ICLR 2019
J. Oh, S. P. Singh, H. Lee, and P. Kohli. Zero-shot task generalization with multi-task deep reinforce-
ment learning. CoRR, abs/1706.05064, 2017. URL http://arxiv.org/abs/1706.05064.
M. L. Puterman. Markov Decision Processes—Discrete Stochastic Dynamic Programming. John
Wiley & Sons, Inc., 1994.
A. A. Rusu, N. C. Rabinowitz, G. Desjardins, H. Soyer, J. Kirkpatrick, K. Kavukcuoglu, R. Pascanu,
and R. Hadsell. Progressive neural networks. CoRR, abs/1606.04671, 2016. URL http:
//arxiv.org/abs/1606.04671.
T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal Value Function Approximators. In
International Conference on Machine Learning (ICML), pages 1312-1320, 2015.
J. Schmidhuber. A general method for incremental self-improvement and multi-agent learning in
unrestricted environments. In Evolutionary Computation: Theory and Applications. Scientific
Publishing Company, 1996.
R. S. Sutton and A. G. Barto. Reinforcement Learning: An Introduction. MIT Press, 1998. URL
http://www-anw.cs.umass.edu/~rich∕book∕the-book.html.
R. S. Sutton, J. Modayil, M. Delp, T. Degris, P. M. Pilarski, A. White, and D. Precup. Horde: A
scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction.
In International Conference on Autonomous Agents and Multiagent Systems, pages 761-768, 2011.
C. Szepesvari. Algorithmsfor Reinforcement Learning. Synthesis Lectures on Artificial Intelligence
and Machine Learning. Morgan & Claypool Publishers, 2010.
M. E. Taylor and P. Stone. Transfer learning for reinforcement learning domains: A survey. Journal
of Machine Learning Research, 10(1):1633-1685, 2009.
Y. W. Teh, V. Bapst, W. M. Czarnecki, J. Quan, J. Kirkpatrick, R. Hadsell, N. Heess, and R. Pascanu.
Distral: Robust multitask reinforcement learning. In Advances in Neural Information Processing
Systems (NIPS), pages 4499-4509, 2017.
A. S. Vezhnevets, S. Osindero, T. Schaul, N. Heess, M. Jaderberg, D. Silver, and K. Kavukcuoglu.
FeUdal networks for hierarchical reinforcement learning. In Proceedings of the International
Conference on Machine Learning (ICML), pages 3540-3549, 2017.
C. Watkins. Learning from Delayed Rewards. PhD thesis, University of Cambridge, England, 1989.
J. Zhang, J. T. Springenberg, J. Boedecker, and W. Burgard. Deep reinforcement learning with
successor features for navigation across similar environments. CoRR, abs/1612.05533, 2016.
12
Published as a conference paper at ICLR 2019
Universal Successor Features Approximators
- Supplementary Material -
A Two types of generalisation: Intuition
In this paper we argue that one of the main benefits provided by USFAs is the ability to combine the
types of generalisation associated with UVFAs and GPI. In this section, we will take a close look at
a very simple example to illustrate the two of generalisation we are considering and how they are
different. This is a very small example where the number of optimal policies are very limited and
the induced tasks are not that interesting, but we chose this solely to illustrate the decision process
induced by GPI and how it differs from parametric generalisation in w via a functional approximator
(FA).
Let us consider a an MDP with a single state s and two actions. Upon executing action a1 the agent
gets a reward of 0 and remains in state s; the execution of action a2 leads to a potentially non-zero
reward followed by termination. We define unidimensional features φ ∈ R as φ(s, a1) = 0 and
φ(s, a2) = 1. A task is thus induced by a scalar w ∈ R which essentially re-scales φ(s, a2) and
defines the reward rw = w the agent receives before termination. In this environment, the space of
tasks considered are induced by a scalar w ∈ R. In this space of tasks, one can easily see that there
are only two optimal policies: taking action a1 and receiving the reward rw = w if w ≤ 0, or taking
action a0 and remaining in s0 indefinitely. Thus the space of optimal value functions is very simple.
For convenience, we include a depiction of this space in Figure 6.
Optimal Values
Figure 6: Optimal value space as a function of a scalar task description w
Suppose now we are in the scenario studied in the paper, where after training on a set of tasks
M the agent should generalise to a test task w0 . Specifically, let us consider three points in this
space M = {wι, w2, w3}- three tasks We are going to consider for learning and approximating
their optimal policies {QWι, Qwl, QW1}. Given these three points we are going to fit a parametric
function that aims to generalise in the space of w. A depiction of this is included in Figure 7(a). NoW,
given a new point w0 we can obtain a zero-shot estimate QwO for QW - see Figure 7(b). Due to
approximation error under a very limited number of training points, this estimate will typically not
recover perfectly QW = 0. In the case of UVFA (and other FAS trying to generalise in task space),
we are going to get a guess based on optimal value function we have built, and we are going to take
decision based on this estimate Qwo.
Given the same base tasks M = {w1, w2, w3} we can now look at what the other method of
generalisation would be doing. We are going to denote by πzi the (inferred) optimal policy of task
wi. Since we have learnt the SFs corresponding to all of these policies ψπzi, we can now evaluate
how well each of these policies would do on the current test task w0: Qπwz0 (s, a) = ψπz (s, a)T w0 for
all z ∈ M. A depiction of this step is included in Figure 8(a). Given these evaluations of previous
behaviours, GPI takes the maximum of these values - ”trusting”, in a sense, the most promising value.
In our case this corresponds to the behaviour associated with task w3 , which in this case happens to
13
Published as a conference paper at ICLR 2019
Figure 7: UVFA-like generalisation.
have the same optimal policy as our test task w0 . Thus in this particular example, the evaluation of a
previously learned behaviour gives us a much better basis for inducing a behaviour in our test task
w0 . Moreover if the SFs are perfect we would automatically get the optimal value function for w0 .
(a) Evaluating previous policies via SFs
(b) Trusting the most promising evaluation
Figure 8: GPI generalisation.
It is worth noting that, in this case, by learning a USFA we can recover both scenarios described
above based on our choice of the candidate set for GPI C. In particular, if C = {w0} we recover the
mechanism in Figure 7, while for C = M we recover the generalisation in Figure 8. Furthermore, for
any choice of trained points that include one positive and one negative choice of w, by relying on
GPI we can generalise perfectly to the whole space of tasks, while an approach based exclusively on
the sort of generalisation provided by UVFAs may struggle to fit the full function. Analogously, in
scenarios where the structure of the optimal space favours (UV)FAs, we expect USFAs to leverage
this type of generalisation. An example of such a scenario is given in the first part of the experimental
section - Section 4.1, and further details in Section B.
14
Published as a conference paper at ICLR 2019
B Illustrative example: Trip MDP
In this section we provide some additional analysis and results omitted from the main text. As a
reminder, this is a two state MDP, where the first state is a root state, the transition from s1 → s2
comes at a cost rw(s1, E) = φ(s1, E)Tw = -(w1 + w2) and all other actions lead to a final
positive reward corresponding to how much the resulting state/restaurant alligns with our preferences
(our task) right now. For convenience, we provide below the depiction of the Trip MDP introduced in
Section 4.1.
In the experiments run we considered a fixed set of training tasks M = {01, 10} for all methods.
The set of outcomes from the exploratory state s2 is defined as φ(s2, a) = [cos(θ), sin(θ)] for
θ ∈ {k∏∕2N}k=o,N. Note that this includes the binary states for k = 0 and respectively k = N.We
ran this MDP with N = 6, and = 0.05. Thus outside the binary outcomes, the agent can select
N - 1 = 5 other mixed outcomes and, as argued in the main text, under these conditions there will
be a selection of the w-space in which each of these outcomes will be optimal. Thus the space of
optimal policies, we hope to recover, is generally N + 1. Nevertheless, there is a lot of structure in
this space, that the functional approximators can uncover and employ in their generalization.
B.1 Additional results
In the main paper, we reported the zero-shot aggregated performance over all direction M0 =
{w0∣w0 = [cos(2∏K), sin(条)],k ∈ ZK}. This should cover most of the space of tasks/trade-offs We
would be interest in. In this section we include the generalization for other sets M0. First in Fig. 9
We depict the performance of the algorithms considered across the Whole w0 space M0 = [0, 1]2. Fig.
10 is just a different visualization of the previous plot, Where We focus on hoW far these algorithms
are from recovering the optimal performance. This also shoWs the subtle effect mentioned in the
discussion in the main text, induced by the choice of C in the USFA evaluation.
15
Published as a conference paper at ICLR 2019
1.0
0.8
0.6
0.4
0.2
0.0
Optimal PerfomarKe
0.8
0.6
0.4
0.2
Perfomance: UVFA
0.8
0.6
0.4
0.2
Perfbmance: SF&GPI
,ʌ Pert⅛mance: USFAC=random⑸
1-0
0.8
0.6
0.4
0.2
1.0
0.8
0.6
0.4
0.2
0.0
Perft>marκe: USFAC={w}
0.0	0.2	04	0.6	0.8	1.0
1.6∞
1.371
1.143
0.914
0.6β6
0.457
0.229
0.000
0.0	0.2	0.4	0.6	0.8	1.0	0.0	0.2	0.4	0.6	0.8	1.0	0.0	0.2	0.4	0.6	0.8	1.0	0.0	0.2	0.4	0.6	0.8	1.0
Figure 9: [Sample run] Performance of the different methods (in this order, starting with the second
subplot): UVFA, SF&GPIon the perfect SFs induced by M, USFA with C = random(5) and USFA
with C = {w0 } as compared to the optimal performance one could get in this MDP (first plot). These
correspond to one sample run, where we trained the UVFA and USFA for 1000 episodes. The optimal
performance and the SF&GPIwere computed exactly.
1.0
0.8
0.6
0.4
0.2
0.0
OpHmaIIty Gap: UVFA
0.0	0.2	0.4	0.β	0.8	1.0
1.0
0.8
0.β
0.4
0.2
0.0
OpHmaittyGap: SF&GPI
0.0	0.2	0.4	0.β	0.8	1.0
10 Optlmallty Gap: USFA C={w}
0.8
0.β
0.4
0.2
0.0
0.0	0.2	0.4	0.6	0.8	1.0
10 OpHmaIttyGap: USFA C=random(5)
0.8
0.β
0.4
0.2
0.0
0.0	0.2	0.4	0.β	0.8	1.0
0.0010
-0.0491
-0.0993
-0.1494
-0.1996
-0.2497
-0.2999
-0.3500
Figure 10: [Sample run] Optimality gap over the whole task space. These correspond to the same
sample run as above, where we trained the UVFA and USFA for 1000 episodes. We can now see
more clearly that USFAs manage to recover better policies and optimality across a much greater
portion of the task space. The last two plots correspond to the same USFA just using different choices
of the candidate set C. Something to note here is that by having a more diverse choice in C, we can
recover an optimal policy even in areas of the space where our approximation has not yet optimally
generalised (like the upper-left corner in the w-space in the figures above).
A particularly adversarial choice of test tasks for the vanilla SF&GPIwould be the diagonal in the
[0, 1]2 quadrant depicted in the plot above: M0 = {w0|w10 = w20 , w1 ∈ [0, 1]}. This is, in a sense,
maximally away from the training tasks and both of the precursor models are bound to struggle in
this portion of the space. This intuition was indeed empirically validated. Results are provided in Fig.
11. As mentioned above, this is an adversarial evaluation, mainly to point out that, in general, there
might be regions of the space were the generalization of the previous models can be very bad, but
where the combination of them can still recover close to optimal performance.
Figure 11: Zero-shot performance on the diagonal: Optimality gap for M0 = {w0|w10 = w20 , w1 ∈
[0, 1]}. These results were averaged over 10 runs.
16
Published as a conference paper at ICLR 2019
C Large scale experiments: Details
C.1 Agent’ s architecture
This section contains a detailed description of the USFA agent used in our experimental section. As a
reminder, we include the agent’s architecture below (Figure 1 in the main text).
Figure 12: USFA architecture
As highlighted in Section 4.2, our agent comprises of three main modules:
•	Input processing module: computes a state representation f(ht) from observation ot. This
module is made up of three convolutional layers (structure identical to the one used in (Mnih
et al., 2015)), the output of which then serves as input to a LSTM (256). This LSTM takes
as input the previously executed action at-1. The output of the LSTM is passed through a
non-linearity f (chosen here to be a ReLu) to produce a vector of 128 units, f (ht).
•	Policy conditioning module: compute the SFs ψ(s, a, z), given a (sampled) policy em-
bedding z and the state representation f(ht). This module first produces nz number of
Z ZDz samples (n = 30 in our experiments). Each of these is then transformed via a
2-layer MLP(32,32) to produce a vector of size 32, for each sample z. This vector g(z)
gets concatenated with the state representation f (ht ) and the resulting vector is further
processed by a 2-layer MLP that produces a tensor of dimensions d × |A| for each z, where
d = dim(φ). These correspond to SFs ψ(s, a, z) for policy πz. Note that this computation
can be done quite efficiently by reusing the state embedding f (ht), doing the downstream
computation in parallel for each policy embedding z.
•	Task evaluation module: computes the value function Q(s, a, z, W) = ψ(s, a, Z)TW for a
given task description w. This module does not have any parameters as the value functions
are simply composable from ψ(s, a, Z) and the task description W via assumption (1). This
module with output nz value functions that will be used to produce a behavior via GPI.
An important decision in this design was how and where to introduce the conditioning on the policy.
In all experiments shown here the conditioning was done simply by concatenating the two embeddings
W and Z, although stronger conditioning via an inner product was tried yielding similar performance.
17
Published as a conference paper at ICLR 2019
The ’where’ on the other hand is much more important. As the conditioning on the policy happens
quite late in the network, most of the processing (up to f (ht)) can be done only once, and we
πz
can sample multiple z and compute the corresponding ψ at a fairly low computational cost. As
mentioned above, these will be combined with the task vector w to produce the candidate action
value functions for GPI. Note that this helps both in training and in acting, as otherwise the unroll of
the LSTM would be policy conditioned, making the computation of the SFs and the off-policy n-step
learning quite expensive. Furthermore, if we look at the learning step we see that this step can also
benefit from this structure, as the gradient computation of f can be reused. We will only have a linear
dependence on nz on the update of the parameters and computations in the red blocks in Figure 12.
UVFA baseline agents have a similar architecture, but now the task description w is fed in as an
input to the network. The conditioning on the task of UVFAs is done in a similar fashion as we
did the conditioning on the policies in USFAs, to make the computational power and capacity
comparable. The input processing module is the same and now downstream, instead of conditioning
on the policy embedding z, we condition on task description w. This conditioning if followed by
a 2-layer MLP that computes the value functions Q (s, a, w), which induces the greedy policy
π(UVFA) =argmaxa Q*(s,a, w).
C.2 Agent’ s training
The agents’ training was carried out using the IMPALA architecture (Espeholt et al., 2018). On the
learner side, we adopted a simplified version of IMPALA that uses Q(λ) as the RL algorithm. In
our experiments, for all agents we used λ = 0.9. Depending on the sampling distribution Dz, in
learning we will be often off-policy. That is, most of the time, we are going to learn about a policy
πz1 and update its corresponding SFs approximations ψ(s, a, z1), using data generated by acting
in the environment according to some other policy πz2 . In order to account for this off-policiness,
whenever computing the n-step return required in eq. 5, we are going to cut traces whenever the
policies start to disagree and bootstrap from this step on (Sutton and Barto, 1998). Here we can see
how the data distribution induce by the choice of training tasks M can influence the training process.
If the data distribution Dz is very close to the set M, as in our first experiment, most of the policies
we are going to sample will be close to the policies that generated the data. This means that we might
be able to make use of longer trajectories in this data, as the policies will rarely disagree. On the other
hand, by staying close to the training tasks, we might hurt our ability to generalise in the policy space,
as our first experiment suggest (see Figure 4). By having a broader distribution Dz = N(w, 0.5I),
we can learn about more diverse policies in this space, but we will also increase our off-policiness.
We can see from Figure 5, that our algorithm can successfully learn and operate in both of these
regimes.
For the distributed collection of data we used 50 actors per task. Each actor gathered trajectories of
length 32 that were then added to the common queue. The collection of data followed an -greedy
policy with a fixed = 0.1. The training curves shown in the paper correspond to the performance of
the the -greedy policy (that is, they include exploratory actions of the agents).
C.3 Agent’ s evaluation
All agents were evaluated in the same fashion. During the training process, periodically (every 20M
frames) we will evaluate the agents performance on a test of held out test tasks. We take these
intermediate snapshots of our agents and ’freeze’ their parameters to assess zero-shot generalisation.
Once a test task w0 is provided, the agent interacts with the environment for 20 episodes, one minute
each and the average (undiscounted) reward is recorded. These produce the evaluation curves in
Figure 4. Evaluations are done with a small = 0.001, following a GPI policy with different
instantiations of C . For the pure UVFA agents, the evaluation is similar: -greedy on the produced
value functions Q*(s,a, w), with the same evaluation E = 0.001.
D	Additional results
In our experiments we defined a set of easy test tasks (close to M) and a set of harder tasks, in order
to cover reasonably well a few distinct scenarios:
18
Published as a conference paper at ICLR 2019
•	Testing generalisation to tasks very similar to the training set, e.g. w0 = [0, 0.9, 0, 0.1];
•	Testing generalisation to harder tasks with different reward profiles: only positive rewards,
only negative rewards, and mixed rewards.
In the main text, we included only a selection of these for illustrative purposes. Here we present the
full results.
D. 1 Canonical basis: Zero-shot generalisation
This section contains the complete results of the first experiment conducted. As a reminder, in
this experiment we were training a USFA agent on M = {1000, 0100, 0010, 0001}, with Dz =
N(w, 0.1I) and compare its performance with two conventional UVFA agents (one trained on-policy
and the other one using all the data generated to learn off-policy) on a range of unseen test tasks.
Complete set of result is included below, as follows: Figure 13 includes results on easy tasks, close to
the tasks contained in the training set M (generalisation to those should be fairly straightforward);
Figure 14 and Figure 15 present results on more challenging tasks, quite far away from the training
set, testing out agents ability to generate to the whole 4D hypercube.
Task 000.90.1
(a) Task 0.,0.,0.9,0.1
Task 00.70.20.1
(b) Task 0.,0.7,0.2,0.1
Task 00.1-0.10.8
(C) Task0.,0.1,-0.1,0.8
Task 00-0.11
(d) Task 0.,0.,-0.1,1.
UVFA	→- USFA (GPI over C = M)
→- UVFA (offpolicy) →- USFA (GPI over C = M + {w'})
→- USFA (GPI over C = {w'})
Figure 13:	Zero-shot performance on the easy evaluation set: Average reward per episode on test
tasks not shown in the main paper. This is Comparing a USFA agent trained on the CanoniCal training
set M = {1000, 0100, 0010, 0001}, with Dz = N(w, 0.1I) and the two UVFA agents: one trained
on-poliCy, one employing off-poliCy.
19
Published as a conference paper at ICLR 2019
10
0
60
50
Task 1100
0.0	0.2	0.4	0.6	0.8	1.
Environment frame	le9
TaskOlll
PJeMaJ əposa 山
0.2	0.4	0.6	0.8	1.0
Environment frame le9
(a)	Task 1100
(b)	Task 0111
Environment frame le9
U O 2 4 6
-Illl
PJeMQJ əposo,山
0.2	0.4	0.6	0.8	1.0
Environment frame le9
(C)TaSk1111	(d)Task-1-100
UVFA	T- USFA (GPI over C = M)
UVFA (OffpoIicy)	τ- USFA (GPI over C = M + {w'})
→- USFA (GPI over C = {w'})
Figure 14:	Zero-shot performance on harder tasks: Average reward per episode on test tasks not
shown in the main paper. This is comparing a USFA agent trained on the canonical training set
M = {1000, 0100, 0010, 0001}, with Dz = N(w, 0.1I) and the two UVFA agents: one trained
on-policy, one employing off-policy. (Part 1)
20
Published as a conference paper at ICLR 2019
PJeMQJ əposo,山
Task -1100
0.2	0.4	0.6	0.8	1.0
Environment frame le9
PJeMQJ əposo,山
Task-1101
0.2	0.4	0.6	0.8	1.0
Environment frame le9
(a) Task-1100
(b) Task -1101
Task-11-10
25	50
5 O
PJeMQJ əposo,山
0.0	0.2	0.4	0.6	0.8	1.0
Environment frame le9
(C)TaSk-11-10
Task-11-11
PJeMaJ əposa 山
-10 -------------------------------------
0.0	0.2	0.4	0.6	0.8	1.0
Environment frame le9
(d)Task-11-11
UVFA	T- USFA (GPI over C = M)
UVFA (OffpoIicy)	τ- USFA (GPI over C = M + {w'})
→- USFA (GPI over C = {w'})
Figure 15:	Zero-shot performance on harder tasks: Average reward per epiSode on teSt taSkS not
Shown in the main paper. ThiS iS Comparing a USFA agent trained on the CanoniCal training Set
M = {1000, 0100, 0010, 0001}, with Dz = N(w, 0.1I) and the two UVFA agentS: one trained
on-poliCy, one employing off-poliCy. (Part 2)
21
Published as a conference paper at ICLR 2019
D.2 Canonical basis: USFAs in different training regimes.
In this section, we include the omitted results from our second experiment. As a reminder, in this
experiment we were training two USFA agents on the same set of canonical tasks, but employing
different distributions DZ, one will low variance σ = 0.1, focusing in learning policies around the
training set M, and another one with larger variance σ = 0.5, that will try to learn about a lot more
policies away from the training set, thus potentially facilitating the generalisation provided by the
UVFA component. Results are displayed in Figures 16-17 on all tasks in the hard evaluation set.
60
50
Task 1100
TaskOlll
Ooo
4 3 2
PJeMVJφpo<2dw
10
0 ------------------------------------------
0.0	0.2	0.4	0.6	0.8	1.0
Environment frame le9
80
70
PJeMOJ əposs
10
o ----------------------------------------
0.0	0.2	0.4	0.6	0.8	1.0
Environment frame le9
(b) Task 0111
(a) Task 1100
(c) Task 1111
(d) Task -1-100
USFA (GPI over C = {w,})rσ = 0.1
USFA (GPI over C = {w,}), σ = 0.5
-→- USFA (GPI over C = M), σ = 0.1
r- USFA (GPI over C = M)f σ = 0.5
Figure 16:	Different DZ - Zero-shot performance on harder tasks: Average reward per episode
on test tasks not shown in the main paper. This is comparing the generalisations of two USFA agent
trained on the canonical training set M = {1000, 0100, 0010, 0001}, with DZ = N(w, 0.1I), and
DZ = N(w, 0.5I). (Part 1)
22
Published as a conference paper at ICLR 2019
(a) Task -1100.
(b) Task -1101
(c) Task -11-10
(d) Task -11-11
USFA (GPI over C = {w,})rσ = 0.1
USFA (GPI over C = {w,}), σ = 0.5
-→- USFA (GPI over C = M), σ = 0.1
r- USFA (GPI over C = M)f σ = 0.5

Figure 17:	Different DZ - Zero-shot performance on harder tasks: Average reward per episode
on test tasks not shown in the main paper. This is comparing a USFA agent trained on the canonical
training set M = {1000, 0100, 0010, 0001}, with DZ = N(w, 0.1I), and DZ = N(w, 0.5I). (Part
2)
23
Published as a conference paper at ICLR 2019
D.3 Larger collection of training tasks
We also trained our USFA agent on a larger set of training tasks that include the previous canonical
tasks, as well as four other tasks that contain both positive and negative reward M = {1000, 0100,
0010, 0001, 1-100, 01-10, 001-1, -1000}. Thus we expect this agent to generalises better as a result
of its training. A selection of these results and sample performance in training are included in Fig. 18.
envɪ ronment_fra me	le9
USFA (GPl over C = M + {w_test})
USFA(GPIoverC = M)
USFA (GPI over C = {wjest})
envlronment-frame le9	envlronment-frame le9	envlronment_frame le9
Figure 18:	Large M. Learning curves for training task [1000] ∈ M and generalisation performance
on a sample of test tasks w0 ∈ M0 after training on all the tasks M. This is a selection of the hard
evaluation tasks. Results are average over 10 training runs.
24