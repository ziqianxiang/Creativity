Published as a conference paper at ICLR 2019
Unsupervised Learning of the Set of Local
Maxima
Lior Wolf
Facebook AI Research &
The School of Computer Science
Tel Aviv University
wolf@fb.com, wolf@cs.tau.ac.il
Sagie Benaim & Tomer Galanti
The School of Computer Science
Tel Aviv University
sagieb@mail.tau.ac.il
tomerga2@post.tau.ac.il
Ab stract
This paper describes a new form of unsupervised learning, whose input is a set
of unlabeled points that are assumed to be local maxima of an unknown value
function v in an unknown subset of the vector space. Two functions are learned:
(i) a set indicator c, which is a binary classifier, and (ii) a comparator function
h that given two nearby samples, predicts which sample has the higher value of
the unknown function v . Loss terms are used to ensure that all training samples
x are a local maxima of v, according to h and satisfy c(x) = 1. Therefore,
c and h provide training signals to each other: a point x0 in the vicinity of x
satisfies c(x) = -1 or is deemed by h to be lower in value than x. We present
an algorithm, show an example where it is more efficient to use local maxima
as an indicator function than to employ conventional classification, and derive
a suitable generalization bound. Our experiments show that the method is able
to outperform one-class classification algorithms in the task of anomaly detection
and also provide an additional signal that is extracted in a completely unsupervised
way.
1	Introduction
...from so simple a beginning endless forms most beautiful and most wonderful
have been, and are being, evolved. (Darwin, 1859)
When we observe the natural world, we see the “most wonderful” forms. We do not observe the
even larger quantity of less spectacular forms and we cannot see those forms that are incompatible
with existence. In other words, each sample we observe is the result of optimizing some fitness or
value function under a set of constraints: the alternative, lower-value, samples are removed and the
samples that do not satisfy the constraints are also missing.
The same principle also holds at the sub-cellular level. For example, a gene can have many forms.
Some of them are completely synonymous, while others are viable alternatives. The gene forms that
become most frequent are those which are not only viable, but which also minimize the energetic
cost of their expression (Farkas et al., 2018). For example, the genes that encode proteins comprised
of amino acids of higher availability or that require lower expression levels to achieve the same
outcome have an advantage. One can expect to observe most often the gene variants that: (i) adhere
to a set of unknown constraints (“viable genes”), and (ii) optimize an unknown value function that
includes energetic efficiency considerations.
The same idea, of mixing constraints with optimality, also holds for man-made objects. Consider,
for example, the set of houses in a given neighborhood. Each architect optimizes the final built
form to cope with various aspects, such as the maximal residential floor area, site accessibility,
parking considerations, the energy efficiency of the built product, etc. What architects find most
challenging, is that this optimization process needs to correspond to a comprehensive set of state
and city regulations that regard, for example, the proximity of the built mass of the house to the lot’s
boundaries, or the compliance of the egress sizes with current fire codes.
1
Published as a conference paper at ICLR 2019
In another instance, consider the weights of multiple neural networks trained to minimize the same
loss on the same training data, each using a different random initialization. Considering the weights
of each trained neural network as a single vector in a sample domain, also fits into the framework
of local optimality under constraints. By the nature of the problem, the obtained weights are the
local optimum of some loss optimization process. In addition, the weights are sometimes subject to
constraints, e.g., by using weight normalization.
The task tackled in this paper is learning the value function and the constraints, by observing only the
local maxima of the value function among points that satisfy the constraints. This is an unsupervised
problem: no labels are given in addition to the samples.
The closest computational problem in the literature is one-class classification (Moya et al., 1993),
where one learns a classifier c in order to model a set of unlabeled training samples, all from a single
class. In our formulation, two functions are learned: a classifier and a separate value function. Split-
ting the modeling task between the two, a simpler classifier can be used (we prove this for a specific
case) and we also observe improved empirical performance. In addition, we show that the value
function, which is trained with different losses and structure from those of the classifier, models a
different aspect of the training set. For example, if the samples are images from a certain class, the
classifier would capture class membership and the value function would encode image quality. The
emergence of a quality model makes sense, since the training images are often homogeneous in their
quality.
The classifier c and the value function v provide training signals to each other, in an unsupervised
setting, somewhat similar to the way adversarial training is done in GANs (Goodfellow et al., 2014),
although the situation between c and v is not adversarial. Instead, both work collaboratively to
minimize similar loss functions. Let S be the set of unlabeled training samples from a space X.
Every x ∈ S satisfies c(x) = 1 for a classifier c : X → {±1} that models the adherence to the set
of constraints (satisfies or not). Alternatively, we can think of c as a class membership function that
specifies, if a given input is within the class or not. In addition, we also consider a value function v ,
and for every point x0, such that kx0-xk ≤ , for a sufficiently small > 0, we have: v(x0) < v(x).
This structure leads to a co-training of v and c, such that every point x0 in the vicinity of x can be
used either to apply the constraint v(x0) < v(x) on v, or as a negative training sample for c. Which
constraint to apply, depends on the other function: if c(x0) = 1, then the first constraint applies; if
v(x0) ≥ v(x), then x0 is a negative sample for c. Since the only information we have on v pertains to
its local maxima, we can only recover it up to an unknown monotonic transformation. We therefore
do not learn it directly and instead learn a comparator function h, which given two inputs, returns an
indication which input has the higher value in v .
An alternative view of the learning problem we introduce considers the value function v (or equiv-
alently h) as part of a density estimation problem, and not as part of a multi-network game. In this
view, c is the characteristic function (of belonging to the support) and h is the comparator of the
probability density function (PDF).
2	Related Work
The input to our method is a set of unlabeled points. The goal is to model this set. This form of input
is shared with the family of methods called one-class classification. The main application of these
methods is anomaly detection, i.e., identifying an outlier, given a set of mostly normal (the opposite
of abnormal) samples (Chandola et al., 2009).
The literature on one class classification can be roughly divided into three parts. The first includes
the classical methods, mostly kernel-base methods, which were applying regularization in order to
model the in-class samples in a tight way (Scholkopf et al., 2001). The second group of methods,
which follow the advent of neural representation learning, employ classical one-class methods to
representations that are learned in an unsupervised way (Hawkins et al., 2002; Sakurada & Yairi,
2014; Xia et al., 2015; Xu et al., 2015; Erfani et al., 2016), e.g., by using autoencoders. Lastly, a
few methods have attempted to apply a suitable one-class loss, in order to learn a neural network-
based representation from scratch (Ruff et al., 2018). This loss can be generic or specific to a data
domain. Recently, Golan & El-Yaniv (2018) achieved state of the art one-class results for visual
datasets by training a network to predict the predefined image transformation that is applied to each
2
Published as a conference paper at ICLR 2019
of the training images. A score is then used to evaluate the success of this classifier on test images,
assuming that out of class images would be affected differently by the image transformations.
Despite having the same structure of the input (an unlabeled training set), our method stands out of
the one-class classification and anomaly detection methods we are aware of, by optimizing a specific
model that disentangles two aspects of the data: one aspect is captured by a class membership
function, similar to many one-class approaches; the other aspect compares pairs of samples. This
dual modeling captures the notion that the samples are not nearly random samples from some class,
but also the local maximum in this class. While “the local maxima of in-class points” is a class by
itself, a classifier-based modeling of this class would require a higher complexity than a model that
relies on the structure of the class as pertaining to local maxima, as is proved, for one example, in
Sec. A. In addition to the characterization as local maxima, the factorization between the constraints
and the values also assists modeling. This is reminiscent of many other cases in machine learning,
where a divide and conquer approach reduces complexity. For example, using prior knowledge
on the structure of the problem, helps to reduce the complexity in hierarchical models, such as
LDA (Blei et al., 2003).
While we use the term “value function”, and this function is learned, we do not operate in a reinforce-
ment learning setting, where the term value is often used. Specifically, our problem is not inverse
reinforcement learning (Ng & Russell, 2000) and we do not have actions, rewards, or policies.
3	Method
Recall that S is the set of unlabeled training samples, and that we learn two functions c and v such
that for all x ∈ S it holds that: (i) c(x) = 1, and (ii) x is a local maxima of v.
For every monotonic function f, the setting we define cannot distinguish between v, and f ◦ v.
This ambiguity is eliminated, if we replace v by a binary function h that satisfies h(x, x0) = 1 if
v(x) ≥ v(x0) and h(x, x0) = -1 otherwise. We found that training h in lieu of v is considerably
more stable. Note that we do not enforce transitivity, when training h, and, therefore, h can be such
that no underlying v exists.
3.1	TRAINING c AND h
When training c, the training samples in S = {xi}im=1 are positive examples. Without additional
constraints, the recovery of c is an ill-posed problem. For example, Ruff et al. (2018) add an ad-
ditional constraint on the compactness of the representation space. Here, we rely on the ability to
generate hard negative points1. There are two generators Gc and Gh, each dedicated to generating
negative training points to either c or h, as described in Sec. 3.2 below.
The two generators are conditioned on a positive point x ∈ S and each generates one negative point
per each x: x0 = Gc(x) and x00 = Gh(x). The constraints on the negative points are achieved
by multiplying two losses: one pushing c(x0) to be negative, and the other pushing h(x00, x) to be
negative.
Let '(p,y) := -1 ((y +1)log(p) + (1 - y)log(1 -P)) be the binary cross entropy loss for y ∈ {±1}.
c and h are implemented as neural networks trained to minimize the following losses, respectively:
LC ：= ɪ X '(c(x), 1) + L X'(c(Gc(x)), -1) ∙ '(h(Gc(x), x),-1)	(1)
mm
x∈S	x∈S
LH ：= — X '(h(x, x), 1) + — X '(c(Gh(x)),-1) ∙ '(h(Gh(x), x), -1)	⑵
mm
x∈S	x∈S
The first sum in LC ensures that c classifies all positive points as positive. The second sum links the
outcome of h and c for points generated by Gc . It is given as a multiplication of two losses. This
multiplication encourages c to focus on the cases where h predicts with a higher probability that the
point Gc(x) is more valued than x.
1“hard negative” is a terminology often used in the object detection and boosting literature, which means
negative points that challenge the training process.
3
Published as a conference paper at ICLR 2019
Algorithm 1 Training c and h
Require: S: positive training points; λ: a trade-off parameter; T: number of epochs.
1:	Initialize c, h, Gc and Gh randomly.
2:	for i = 1, ..., T do
3:	Train Gc for one epoch to minimize -LC
4:	Train c for one epoch to minimize LC
5:	Train Gh for one epoch to minimize -λ Pχ∈s ||x - Gh(X)|| - LH
6:	Train h for one epoch to minimize LH
7:	return c, h
The first term of LC (respectively LH) depends on c’s (respectively h’s) parameters only. The
second term of LC (respectively LH), however, depends on both h’s and c’s parameters as well as
Gc’s (respectively Gh ’s) parameters.
The loss LH is mostly similar. It ensures that h has positive values when the two inputs are the
same, at least at the training points. In addition, it ensures that for the generated negative points x0 ,
h(x0, x) is -1, especially when c(x0) is high.
One can alternatively use a symmetric LH, by including an additional term
ml Pχ∈s '(c(Gh(x)), -1) ∙ '(h(x, Gh(x)), 1). This, in our experiments, leads to very simi-
lar results, and we opt for the slightly simpler version.
3.2	Negative Point Generation
We train two generators, Gc and Gh, to produce hard negative samples for the training of c and h,
respectively. The two generators both receive a point x ∈ S as input, and generate another point in
the same space X. They are constructed using an encoder-decoder architecture, see Sec. 3.4 for the
exact specifications.
When training Gc, the loss -LC is minimized. In other words, Gc finds, in an adversarial way,
points x0, that maximize the error of c (the first term of LC does not involve Gc and does not
contribute, when training Gc).
Gh minimizes during training the loss mλ Pχ∈s ||x - Gh(X)II- LH, for some parameter λ. Here,
in addition to the adversarial term, we add a term that encourages Gh (x) to be in the vicinity of
X. This is added, since the purpose of h is to compare nearby points, allowing for the recovery of
points that are local maxima. In all our experiments we set λ = 1.
The need for two generators, instead of just one, is verified in our ablation analysis, presented in
Sec. 4. One may wonder why two are needed. One reason stems from the difference in the training
loss: h is learned locally, while c can be applied anywhere. In addition, c and h are challenged by
different points, depending on their current state during training. By the structure of the generators,
they only produce one point per input X, which is not enough to challenge both c and h.
3.3	Training Procedure
The training procedure follows the simple interleaving scheme presented in Alg. 1. We train the
networks in turns: Gc and then c, followed by Gh and then h. Since the datasets in our experiments
are relatively small, each turn is done using all mini-batches of the training dataset S. The ADAM
optimization scheme is used with mini-batches of size 32.
The training procedure has self regularization properties. For example, assuming that Gh(X) 6= X,
LH as a function of h, has a trivial global minima. This solution is to assign h(X0, X) to 1 iff
X0 = X. However, for this specific h, the only way for Gh to maximize LH is to rely on c and h
being smooth and to select points X0 = Gh(X) that converge to X, at least for some points in X ∈ S.
In this case, both '(c(Gh(x)), -1) and '(h(G八(x), x), -1) will become high, since c(x0) ≈ 1 and
h(X0, X) ≈ 1.
4
Published as a conference paper at ICLR 2019
3.4	Architecture
In the image experiments (MNIST, CIFAR10 and GTSRB), the neural networks Gh and Gc employ
the DCGAN architecture of Radford et al. (2015). This architecture consists of an encoder-decoder
type structure, where both the encoder and the decoder have five blocks. Each encoder (resp. de-
coder) block consists of a 2-strided convolution (resp. deconvolution) followed by a batch norm
layer, and a ReLU activation. The fifth decoder block consists of a 2-strided convolution followed
by a tanh activation instead. c and h’s architectures consist of four blocks of the same structure as
for the encoder. This is followed by a sigmoid activation.
For the Cancer Genome Atlas experiment, each encoder (resp. decoder) block consists of a fully
connected (FC) layer, a batch norm layer and a Leaky Relay activation (slope of 0.2). Two blocks
are used for the encoder and decoder. The encoder’s first FC layer reduces the dimension to 512 and
the second to 256. The decoder is built to mirror this. c and h consist of two blocks, where the first
FC layer reduces the dimension to 512 and the second to 1. This is followed by a sigmoid activation.
3.5	Analysis
In Appendix A, We show an example in which modeling using local-maxima-points is an efficient
way to model, in comparison to the conventional classification-based approach. We then extend the
framework of spectral-norm bounds, which were derived in the context of classification, to the case
of unsupervised learning using local maxima.
4	Experiments
Since we share the same form of input with one-class classification, we conduct experiments using
one-class classification benchmarks. These experiments both help to understand the power of our
model in capturing a given set of samples, as well as study the properties of the two underlying
functions c and h.
Following acceptable benchmarks in the field, specifically the experiments done by Ruff et al.
(2018), we consider single classes out of multiclass benchmarks, as the basis of one-class prob-
lems. For example, in MNIST, the set S is taken to be the set of all training images of a particular
digit. When applying our method, we train h and c on this set. To clarify: there are no negative
samples during training.
Post training, we evaluate both c and h on the one class classification task: positive points are now
the MNIST test images of the same digit used for training, and negative points are the test images of
all other digits. This is repeated ten times, for digits 0-9. In order to evaluate h, which is a binary
function, we provide it with two replicas of the test point.
The classification ability is evaluated as the AUC obtained on this classification task. The same
experiment was conducted for CIFAR-10 where instead of digits we consider the ten different class
labels. The results are reported in Tab. 1, which also states the literature baseline values reported
by Ruff et al. (2018). As can be seen, for both CIFAR-10 and MNIST, c strongly captures class-
membership, outperforming the baseline results in most cases. h is less correlated with class mem-
bership, resulting in much lower mean AUC values and higher standard deviations. However, it
should not come as a surprise that h does contain such information.
Indeed, the difference in shape (single input vs. two inputs) between c and h makes them different
but not independent. c, as a classifier, strongly captures class membership. We can expect h, which
compares two samples, to capture relative properties. In addition, h, due to the way negative samples
are collected, is expected to model local changes, at a finer resolution than c. Since it is natural to
expect that the samples in the training set would provide images that locally maximize some clarity
score, among all local perturbations, one can expect quality to be captured by h.
To test this hypothesis, we considered positive points to be test points of the relevant one-class, and
negative points to be points with varying degree of Gaussian noise added to them. We then measure
using AUC, the ability to distinguish between these two classes.
5
Published as a conference paper at ICLR 2019
Table 1: One class experiments on the MNIST and CIFAR-10 datasets. For MNIST, there is one experiment per digit, where the training samples are the training set of this digit. The reported numbers are the AUC for classifying one-vs-rest, using the test set of this digit vs. the test sets of all other digits. For CIFAR-10, the same experiment is run with a class label, instead of the digits. Reported numbers (in all tables) are averaged over 10 runs with random initializations. Each reported value is the mean result ± the standard deviation.					
Digit	KDE (Parzen, 1962)	AnoGAN (SchlegL 2017)	Deep SVDD (Ruff et al., 2018)	Our c	Our h
0	97.1±0.0	96.6±1.3	98.0±0.7	99.1±0.2	83.5±11.6
1	98.9±0.0	99.2±0.6	99.7±0.1	97.2±0.7	50.7±25.7
2	79.0±0.0	85.0±2.9	91.7±0.8	91.9±0.4	67.1±15.7
3	86.2±0.0	88.7±2.1	91.9±1.5	94.3±0.7	62.4±25.9
4	87.9±0.0	89.4±1.3	94.9±0.8	94.2±0.3	85.7±10.7
5	73.8±0.0	88.3±2.9	88.5±0.9	87.2±2.0	73.3±14.5
6	87.6±0.0	94.7±2.7	98.3±0.5	98.8±0.2	62.8±15.9
7	91.4±0.0	93.5±1.8	94.6±0.9	93.9±0.5	61.6±10.8
8	79.2±0.0	84.9±2.1	93.9±1.6	96.0±0.1	45.8±17.7
9	88.2±0.0	92.4±1.1	96.5±0.3	96.7±0.3	66.8±14.5
Airplane	61.2±0.0	67.1±2.5	61.7±4.2	74.0±1.2	48.9±13.1
Automobile	64.0±0.0	54.1±3.4	65.9±2.1	74.7±1.6	64.6±5.4
Bird	50.1±0.0	52.9±3.0	50.8±0.8	62.8±2.0	53.2±4.5
Cat	56.4±0.0	54.5±1.9	59.1±1.4	57.2±2.0	51.4±6.6
Deer	66.2±0.0	65.1±3.2	60.9±1.1	67.8±2.2	55.0±9.3
Dog	62.4±0.0	60.3±2.6	65.7±2.5	60.2±1.6	58.9±3.7
Frog	74.9±0.0	58.5±1.4	67.7±2.6	75.3±3.9	60.7±4.5
Horse	62.6±0.0	62.5±0.8	67.3±0.9	68.5±2.8	58.1±3.8
Ship	75.1±0.0	75.8±4.1	75.9±1.2	78.1±1.2	66.9±7.1
Truck	76.0±0.0	66.5±2.8	73.1±1.2	79.5±1.5	70.3±8.3
Table 2: An ablation analysis on the ten CIFAR classes (shown in order, Airplane to Truck).
	1	2	3	4	5	6	7	8	9	10
Baseline c	74.0	74.7	62.8	57.2	67.8	60.2	75.3	68.5	78.1	79.5
Baseline h	48.9	64.6	53.2	51.4	55.0	58.9	60.7	58.1	66.9	70.3
c only	73.0	63.8	59.1	59.6	60.4	60.7	62.8	62.1	77.2	73.3
h only	35.6	51.9	50.1	48.0	48.3	48.0	68.0	54.7	75.6	73.1
c with Gc only	73.4	74.3	61.2	58.8	66.4	59.0	72.7	70.3	77.1	75.1
h with Gc only	63.7	68.3	59.2	56.6	58.8	57.4	60.7	65.5	71.3	74.2
c with Gh only	73.2	71.2	59.6	51.7	65.4	60.9	68.3	68.9	76.7	77.2
h with Gh only	56.0	65.3	55.5	53.2	50.6	58.6	54.8	58.4	65.2	71.8
As can be seen in Fig. 1, h is much better at identifying noisy images than c, for all noise levels.
This property is class independent, and in Fig. 3 (Appendix C), we repeat the experiment for all test
images (not just from the one class used during training), observing the same phenomenon.
We employ CIFAR also to perform an ablation analysis comparing the baseline method’s c and h
with four alternatives: (i) training c without training h, employing only Gc ; (ii) training h and Gh
without training c nor Gc ; (iii) training both h and c but using only the Gc generator to obtain
negative samples to both networks; and (iv) training both h and c but using only the Gh generator
for both. The results, which can be seen in Tab. 2, indicate that the complete method is superior to
the variants, since it outperform these in the vast majority of the experiments.
Next, we evaluate our method on data from the German Traffic Sign Recognition (GTSRB) Bench-
mark of Houben et al. (2013). The dataset contains 43 classes, from which one class (stop signs,
class #15) was used by Ruff et al. (2018) to demonstrate one-class classification where the negative
class is the class of adversarial samples (presumably based on a classifier trained on all 43 classes).
6
Published as a conference paper at ICLR 2019
CIFAR-10	MNIST
Figure 1: The ability to differentiate between an in-class image and an in-class image with added
noise for both c (yellow) and h (blue). The x-axis is the amount of noise (SD of the Gaussian noise).
The y-axis is the AUC. As can be seen, for both CIFAR-10 and MNIST, h is much more attuned to
the image quality.
We were not able to obtain these samples by the time of the submission. Instead, We employ the
sign data in order to evaluate three other one-class tasks: (i) the conventional task, in which a class
is compared to images out of all other 42 classes; (ii) class image vs. noise image, as above, using
Gaussian noise with a fixed noise level of σ = 0.2; (iii) same as (ii) only that after training on one
class, we evaluate on images from all classes.
The results are presented, for the first 20 classes of GTSRB, in Tab. 3. The reported results are
an average over 10 random runs. On the conventional one-class task (i), both our c and h neural
networks outperform the baseline Deep-SVDD method, with c performing better than h, as in the
MNIST and CIFAR experiments. Also following the same pattern as before, the results indicate that
h captures image noise better than both c and Deep-SVDD, for both the test images of the training
class and the test images from all 43 classes.
In order to explore the possibility of using the method out of the context of one-class experiments
and for scientific data analysis, we downloaded samples from the Cancer Genome Atlas (https:
//cancergenome.nih.gov/). The data contains mRNA expression levels for over 22,000
genes, measured from the blood of 9,492 cancer patients. For most of the patients, there is also
survival data in days. We split the data to 90% train and 10% test.
We run our method on the entire train data and try to measure whether the functions recovered are
correlated with the survival data on the test data. While, as mentioned in Sec. 1, the gene expression
optimizes a fitness function, and one can claim that gene expressions that are less fit, indicate an
expected shortening in longevity, this argument is speculative. Nevertheless, since survival is the
only regression signal we have, we focus on this experiment.
We compare five methods: (i) the h we recover, (ii) the c we recover, (iii) the h we recover, when
learning only h and not c, (iv) the c we recover, when learning only c and not h, (v) the first PCA of
the expression data, (vi) the classifier of DeepSVDD. The latter is used as baseline due to the shared
form of input with our method. However, we do not perform an anomaly detection experiment.
7
Published as a conference paper at ICLR 2019
Table 3: Results obtained on the GTSRB dataset on three one-class tasks. Reported are AUC values in percents. DS denotes Deep-SVDD by Ruff et al. (2018).									
Class	(i) Multiclass			(ii) Noise in-class			(iii) Noise all images.		
	c	h	DS	c	h	DS	c	h	DS
1	92.6	77.8	86.2	61.1	62.3	61.8	55.1	58.9	44.7
2	78.0	75.4	71.9	75.6	96.3	74.7	71.4	92.3	51.4
3	78.3	79.5	65.8	71.0	95.0	66.1	79.0	98.5	50.0
4	79.7	81.7	63.9	89.1	97.0	66.3	71.0	82.0	53.2
5	79.7	79.3	73.2	90.1	95.6	48.7	72.3	84.5	56.3
6	73.8	66.4	81.8	91.1	85.3	88.1	75.3	75.2	62.0
7	91.0	90.2	73.6	93.0	94.1	84.1	58.1	72.4	55.2
8	82.1	75.4	74.6	93.7	93.9	51.6	71.0	82.1	56.7
9	80.2	84.7	73.4	92.4	93.7	54.3	70.5	81.0	53.8
10	85.8	74.9	79.2	82.0	93.4	88.7	71.0	84.0	57.7
11	81.9	81.7	82.7	93.4	93.9	65.0	78.2	78.4	68.3
12	86.9	84.6	54.3	78.3	92.6	89.8	70.3	89.1	64.5
13	88.1	82.1	60.0	84.0	91.2	74.6	78.2	79.1	60.5
14	93.5	93.7	57.6	82.3	85.4	78.9	76.0	77.4	63.4
15	98.2	93.7	71.9	67.3	81.2	65.0	54.0	64.0	49.2
16	87.6	90.5	71.8	59.0	78.3	90.0	55.3	63.2	55.6
17	92.5	96.8	76.7	73.1	83.4	83.1	58.3	67.2	55.6
18	99.3	85.4	64.4	73.0	92.1	77.7	87.3	97.2	50.7
19	79.5	79.7	52.2	68.1	81.2	90.4	62.0	78.3	57.8
20	92.9	92.9	52.1	76.3	78.2	81.6	52.3	63.0	74.0
Avg	86.1	83.3	69.4	79.7	88.2	74.0	68.3	78.4	57.0
Table 4: Correlation between the recovered functions and the patient's survival.
Local	Standard
Method	Pearson correlation	P-value	Pearson correlation	P-value
Our h	0.076	0.021	0.041	0.384
Our c	0.020	0.520	0.029	0.444
Our h trained without c	0.033	0.405	0.017	0.716
Our c trained without h	0.029	0.444	0.031	0.420
First PCA of mRNA expression	0.047	0.308	0.006	0.903
Deep-SVDD	0.021	0.510	0.032	0.410
In the simplest experiment, we treat h as a unary function by replicating the single input, as done
above. We call this the standard correlation experiment. However, h was trained in order to compare
two local points and we, therefore, design the local correlation protocol. First, we identify for each
test datapoint, the closest test point. We then measure the difference in the target value (the patient’s
survival) between the two datapoints, the difference in value for unary functions (e.g., for c or for the
first PCA), or h computed for the two datapoints. This way vectors of the length of the number of test
data points are obtained. We use the Pearson correlation between these vectors and the associated
p-values as the test statistic.
The results are reported in Tab. 4. As can be seen, the standard correlation is low for all methods.
However, for local correlation, which is what h is trained to recover, the h obtained when learning
both h and c is considerably more correlated than the other options, obtaining a significant p-value
of 0.021. Interestingly, the ability to carve out parts of the space with c, when learning h seems
significant and learning h without c results in a much reduced correlation.
Finally, we test our method on the Gaussian Mixture Model data following Balduzzi et al. (2018),
who perform a similar experiment in order to study the phenomenon of mode hopping. In this
experiment, the data is sampled from 16 Gaussians placed on a 4x4 grid with coordinates -1.5, 0.5,
8
Published as a conference paper at ICLR 2019
(a)	(b)
(c)	(d)
Figure 2: Results for a mixture of Gaussians placed on a 2D grid, following Balduzzi et al. (2018).
(a) The values of the function c across the 2D domain, when c and h are jointly trained. (b) The
comparator h shown as a quiver plot of the direction of maximal increase in value. (c) The values of
c when it is trained alone without h. (d) A quiver plot for h, when it is trained without c.
0.5 and 1.5 in each axis. In our case, since we model local maxima, we take each Gaussian to have
a standard deviation that is ten times smaller than that of Balduzzi et al. (2018): 0.01 instead of
0.1. We treat the mixture as a single class and sample a training set from it, to which we apply our
methods as well as the variants where each network trains separately.
The results are depicted in Fig. 2, where we present both c and h. As can be seen, our complete
method captures with c the entire distribution, while training c without h runs leads to an unstable
selection of a subset of the modes. Similarly, training h without c leads to an h function that is much
less informative than the one extracted when the two networks are trained together.
5 Discussion
The current machine learning literature focuses on models that are smooth almost everywhere. The
label of a sample is implicitly assumed as likely to be the same as those of the nearby samples. In
contrast to this curve-based world view, we focus on the cusps. This novel world view could be
beneficial also in supervised learning, e.g., in the modeling of sparse events.
Our model recovers two functions: c and h, which are different in form. This difference may be
further utilized to allow them to play different roles post learning. Consider, e.g., the problem of
drug design, in which one is given a library of drugs. The constraint function c can be used, post
training, to filter a large collection of molecules, eliminating toxic or unstable ones. The value
function h can be used as a local optimization score in order to search locally for a better molecule.
9
Published as a conference paper at ICLR 2019
Acknowledgements
This project has received funding from the European Research Council (ERC) under the European
Unions Horizon 2020 research and innovation programme (grant ERC CoG 725974). The contribu-
tion of Sagie Benaim is part of Ph.D. thesis research conducted at Tel Aviv University.
References
Raman Arora, Amitabh Basu, Poorya Mianjy, and Anirbit Mukherjee. Understanding deep neural
networks with rectified linear units. In International Conference on Learning Representations,
2018.
David Balduzzi, Sebastien Racaniere, James Martens, Jakob Foerster, Karl Tuyls, and Thore Grae-
pel. The mechanics of n-player differentiable games. In Jennifer Dy and Andreas Krause (eds.),
Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceed-
ings of Machine Learning Research, pp. 354-363, Stockholmsmssan, Stockholm Sweden, 10-
15 Jul 2018. PMLR. URL http://proceedings.mlr.press/v80/balduzzi18a.
html.
Peter L Bartlett, Dylan J Foster, and Matus J Telgarsky. Spectrally-normalized margin bounds for
neural networks. In NIPS.
David M. Blei, Andrew Y. Ng, Michael I. Jordan, and John Lafferty. Latent dirichlet allocation.
Journal of Machine Learning Research, 3:2003, 2003.
Varun Chandola, Arindam Banerjee, and Vipin Kumar. Anomaly detection: A survey. ACM com-
puting surveys (CSUR), 41(3):15, 2009.
Charles Darwin. On the Origin of Species by Means of Natural Selection. Murray, London, 1859.
or the Preservation of Favored Races in the Struggle for Life.
Sarah M Erfani, Sutharshan Rajasegarar, Shanika Karunasekera, and Christopher Leckie. High-
dimensional and large-scale anomaly detection using a linear one-class svm with deep learning.
Pattern Recognition, 58:121-134, 2016.
Zoltan Farkas, Dorottya Kalapis, Zoltan Bodi, Bela Szamecz, Andreea Daraba, Karola Almasi,
Karoly Kovacs, Gabor Boross, Ferenc Pal, Peter Horvath, et al. Hsp70-associated chaperones
have a critical role in buffering protein production costs. eLife, 7:e29845, 2018.
Izhak Golan and Ran El-Yaniv. Deep anomaly detection using geometric transforma-
tions. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and
R. Garnett (eds.), Advances in Neural Information Processing Systems 31, pp. 9781-
9791. Curran Associates, Inc., 2018. URL http://papers.nips.cc/paper/
8183-deep-anomaly-detection-using-geometric-transformations.pdf.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NIPS, pp. 2672-2680,
2014.
Simon Hawkins, Hongxing He, Graham Williams, and Rohan Baxter. Outlier detection using repli-
cator neural networks. In International Conference on Data Warehousing and Knowledge Dis-
covery, pp. 170-180. Springer, 2002.
Sebastian Houben, Johannes Stallkamp, Jan Salmen, Marc Schlipsing, and Christian Igel. Detec-
tion of traffic signs in real-world images: The German Traffic Sign Detection Benchmark. In
International Joint Conference on Neural Networks, number 1288, 2013.
David Mcallester. Simplified pac-bayesian margin bounds. In In COLT, pp. 203-215, 2003.
M. M. Moya, M. W. Koch, and L. D. Hostetler. One-class classifier networks for target recognition
applications. NASA STI/Recon Technical Report N, 93, 1993.
10
Published as a conference paper at ICLR 2019
Behnam Neyshabur, Srinadh Bhojanapalli, and Nathan Srebro. A PAC-bayesian approach to
spectrally-normalized margin bounds for neural networks. In ICLR, 2018.
Andrew Y Ng and Stuart J Russell. Algorithms for inverse reinforcement learning. In ICML, pp.
663-670, 2000.
Emanuel Parzen. On estimation of a probability density function and mode. The Annals of Mathe-
matical Statistics, 33(3):1065-1076, 09 1962.
Alec Radford, Luke Metz, and Soumith Chintala. Unsupervised representation learning with deep
convolutional generative adversarial networks. arXiv preprint arXiv:1511.06434, 2015.
Lukas Ruff, Robert Vandermeulen, Nico Goernitz, Lucas Deecke, Shoaib Ahmed Siddiqui, Alexan-
der Binder, Emmanuel Muller, and Marius Kloft. Deep one-class classification. In ICML, 2018.
Mayu Sakurada and Takehisa Yairi. Anomaly detection using autoencoders with nonlinear dimen-
sionality reduction. In Proceedings of the MLSDA 2014 2nd Workshop on Machine Learning for
Sensory Data Analysis, pp. 4. ACM, 2014.
Seebock Schlegl. Unsupervised anomaly detection with generative adversarial networks to guide
marker discovery. IPMI, pp. 146157, 2017.
Bernhard Scholkopf, John C. Platt, John C. Shawe-Taylor, Alex J. Smola, and Robert C. Williamson.
Estimating the support of a high-dimensional distribution. Neural Computing, 13(7):1443-1471,
2001.
Y. Xia, X. Cao, F. Wen, G. Hua, and J. Sun. Learning discriminative reconstructions for unsupervised
outlier removal. In 2015 IEEE International Conference on Computer Vision (ICCV), 2015.
Dan Xu, Elisa Ricci, Yan Yan, Jingkuan Song, and Nicu Sebe. Learning deep representations of
appearance and motion for anomalous event detection. arXiv preprint arXiv:1510.01553, 2015.
A Analysis
We show an example in which modeling using local-maxima-points is an efficient way to model,
in comparison to the conventional classification-based approach. We then extend the framework of
spectral-norm bounds, which were derived in the context of classification, to the case of unsuper-
vised learning using local maxima.
A. 1 MODELING USING arg maxv IS BENEFICIAL
While modeling with a classifier cis commonplace, modeling a setS = {xi}im=1 as the local maxima
of a function is much less conventional. Next, we will argue that at least in some situations, it may
be advantageous.
We compare the complexity of a ReLU neural network W2φ(W1x+b) modeling a set S = {xi}im=1
of m real numbers as either a classifier or as maxima of a value function. Here, W1 and W2 are
linear transformations, b is a vector and φ(u1, . . . , un) := (max(0, u1), . . . , max(0, un)) is the
ReLU activation function, for u1 , . . . , un ∈ R and n ∈ N. We denote by cS : R → {±1} the
function that satisfies, cS(x) = 1 if and only ifx ∈ S.
For this purpose, we take any distribution D over [x1 - 1, xm + 1] that has positive probability for
sampling from S. Formally, D is a mixture distribution that samples at probability q > 0 from D0
and probability 1 - q from D1 , where D0 is a distribution supported by S and D1 is a distribution
supported by the segment [x1 - 1, xm + 1]. The task is to achieves error ≤ in approximating cS.
The error of a function C : R → R is measured by 1χ〜D [c(χ) = cs(x)], which is the probability of
C incorrectly labeling a random number X 〜D.
We show that there is a ReLU neural network v(x) = W2φ(W1x + b) with 2m neurons, such
that, the set of local maxima of V is S. In particular, we have: Ex〜D1 [q (x) = CS(x)] = 0. Here,
Cv : R → {±1}, that satisfies, Cv(x) = 1 if and only if x is a local maxima of v. Additionally,
11
Published as a conference paper at ICLR 2019
we show that any such v has at least 2m - 1 hidden neurons. On the other hand, we show that
for any distribution D (with the specifications above), any classification neural network c(x) =
W2φ(W1x + b) that has error Ex〜D 1[c(χ) = cs(x)] ≤ E has at least 3m hidden neurons.
Theorem 1. Let S = {xi}im=1 ⊂ R be any set of points such that xi < xi+1 for all i ∈ {1, . . . , m -
1}. We define cS : R → {±1} to be the function, such that cS(x) = 1 if and only if x ∈ S. Then,
1.	There is a ReLU neural network v : R → R of the form v(x) = W2φ(W1x + b) with 2m
hidden neurons such that the set of local maximum points of v is S.
2.	Any ReLU neural network v : R → R of the form v(x) = W2φ(W1x + b) such that any
x ∈ S is a local maxima of v has at least 2m - 1 neurons.
3.	Let D = q ∙ Do ∪ (1 一 q) ∙ Di be a distribution that samples at probability q > 0 from
D0 and probability 1 - q from D1, where D0 is a distribution supported by S and D1 is a
distribution supported by the segment [x1 一 1, xm + 1]. Then, for a small enough E > 0,
every ReLU neural network c : R → R of the form c(x) = W2φ(W1x + b), such that
Ex〜D1 [c(x) = cs(x)] ≤ E has at least 3m hidden neurons.
Proof. We begin by proving (1). We construct v as follows:
•	∀x ∈ (-∞, Xι]: v(x) = X — Xi + 1.
•	∀i ∈ {1, ..., m — 1} : ∀x ∈ [xi, xi+χi+1 ]： V(X) = x 二-x. (x — Xi) + 1.
•	∀i ∈{1,...,m - 1} : ∀x ∈ [ xi+χi+1 ,Xi+i ]： V(X) = xi+1-xi (x - Xi+i) + 1.
•	∀X ∈ [Xm, ∞): v(X) = Xm — X + 1.
we consider that V is a piece-wise linear function with 2m linear pieces and arg maxV = S. By
Thm. 2.2 in Arora et al. (2018), this function can be represented as a ReLU neural network of the
form V(X) = W2φ(WiX + b), that has 2m hidden neurons.
Next, we prove (2). Let V : R → R be a function of the form V(X) = W2φ(WiX + b), such that
each X ∈ S is a local maxima of it. First, by Thm. 2.1 in Arora et al. (2018), V is a piece-wise linear
function. We claim that V has at least two linear pieces between each consecutive points Xi andXi+i,
for i ∈ {1, . . . , m - 1}. Assume the contrary, i.e., there is an index i ∈ {1, . . . , m - 1}, such that,
V has only one piece between Xi and Xi+i. If V(Xi) = V(Xi+i), then, V is constant between Xi and
Xi+i, and therefore, Xi and Xi+i are not local maximas of V, in contradiction. If V(Xi) < V(Xi+i),
then, because V is linear between Xi andXi+i, for every point X ∈ (Xi, Xi+i), we have V(Xi) < V(X),
in contradiction to the assumption that Xi is a local maxima of V. If V(Xi) > V(Xi+i), then, because
V is linear between Xi and Xi+i, for every point X ∈ (Xi, Xi+i), we have V(Xi+i) < V(X), in
contradiction to the assumption that Xi+i is a local maxima of V. We conclude that V has at least
two linear pieces between the points Xi and Xi+i, for all i ∈ {1, . . . , m - 1}. Therefore, V has at
least 2m pieces. By Thm. 2.2 in Arora et al. (2018), V has at least 2m - 1 hidden neurons.
Next, we prove (3). We denote X0 = Xi - 1 and Xm+i = Xm + 1. Let PD0 [Xi] be the probability
of sampling Xi from Do. Since Do is supported by S, We have: q ∙ Pd° [x∕ > 0. We define
α := q mini∈{i,...,m} PD0 [Xi]. In addition, Di is a continuous distribution supported by the closed
segment [Xi - 1, Xm + 1]. Thus, by Weierstrass’ extreme value theorem, the probability density
function PD1 [X] of Di that is a continuous function, obtains its extreme values Within the segment.
In addition, since Di is supported by [Xi - 1, Xm + 1], We have: PD1 [X] > 0 for all X ∈ [Xi -
1, Xm + 1]. By combining the above two statements, we conclude that there is a point x* ∈ [xi -
1,Xm + 1] such that PdJx] ≥ PdJx*] > 0 for every X ∈ [xi - 1,Xm + 1]. We denote by
β := (1 - q) mini∈{o,...,m} PD1 [X ∈ (Xi, Xi+i)] > 0. Since we are interested in proving the claim
for a small enough E > 0, we can simply assume that E < min(α, β) and c : R → R a ReLU neural
network of the form c(X) = W2φ(WiX + b).
12
Published as a conference paper at ICLR 2019
We have:
Eχ~D 1[c(x) = cs(x)] = qEχ~Do 1[c(x) = cs(x)] + (1 - q)Eχ~0ι 1[c(x) = cs(x)]
m	(3)
≥ qEχ~Do 1[c(x) = Cs(x)] ≥ a£ 1[c(x) = cs(x)]
i=1
Assume by contradiction that: C(Xi) = CS(xi). Then, Ex~d 1[c(x) = cs(x)] ≥ a > e in Contradic-
tion. Therefore, c(xi) = cS(xi) = 1 for every xi ∈ S.
We also have:
Eχ~D 1[c(x) = Cs(x)] = qEχ~Do 1[c(x) = Cs(x)] + (1 - q)Eχ~D]1[c(x) = Cs(x)]
≥ (1 - q)Eχ~Dι 1[c(x) = Cs(x)]
Assume by contradiction that there is i ∈ {1, . . . , m - 1}, such that the set Ei = {x ∈
(xi, xi+1)|C(x) = 0} is finite. Then,
Eχ~D 1[c(x) = Cs(x)] ≥ (1 - q)Eχ~Dι 1[c(x) = cs(x)]
≥ (1 - q)PD1 [x ∈ (xi, xi+1)] ≥ β >
in contradiction. Let i ∈ {1, . . . , m - 1}, ai and bi be two points such that xi < ai < bi < xi+1
and C(ai) = C(bi) = 0. Since C is a continuous function and piece-wise linear and the four points
(xi, 1), (a, 0), (b, 0), (xi+1, 1) are not co-linear, we conclude that C has at least three linear pieces in
the segment [xi, xi+1]. Similarly, C has at least two linear pieces in each of the segments [x1 - 1, x1]
and [xm, xm + 1]. We conclude that C has at least 3m+ 1 pieces. By Thm. 2.2 in Arora et al. (2018),
c has at least 3m hidden neurons.	口
In the above theorem we showed that there exists a ReLU neural network v(x) = W2φ(W1x + b)
with 2m hidden neurons that captures the set S as its local maximas. Furthermore, we note that the
set of functions that satisfy these conditions (i.e., shallow ReLU neural networks with 2m hidden
neurons that capture the set S) is relatively limited. For instance, any such v behaves as a piece-
wise linear function between any xi and xi+1 with only two linear pieces. Therefore, any such v is
uniquely determined by the set S up to some freedom in the selection of the linear pieces between
xi and xi+1 in S. On the other hand, a shallow ReLU neural network v(x) = W2φ(W1x + b) with
more than 2m hidden neurons is capable of having more than two linear pieces between any xi and
xi+1.
A.2 A Generalization Bound
The following lemma provides a generalization bound that expresses the generalization of learning
C along with v . In the following generalization bound, we assume there is an arbitrary distribution D
of positive samples. In addition, we parameterize the class, V = {vθ : Rd → R | θ ∈ Θ}, of value
functions by vectors of parameters θ ∈ Θ and the class, C = {sign ofω : Rd → {±1} | ω ∈ Ω},
of classifiers by ω ∈ Ω. We upper bound the probability of a mistake done by any classifier Cω ∈ C
and value function vθ ∈ V on a random sample X 〜 D. In this case, vθ and Cω mistake if X is not a
local maxima ofvθ or classified as negative by Cω. The upper bound is decomposed into the sum of
the average error of Cω and V on a dataset S 吮 Dm and a regularization term.
See Appendix B for the exact formulation and the proof.
Lemma 1 (Informal). Let V = {vθ : Rd → R | θ ∈ Θ} be a class of value functions and
C = {sign ofω : Rd → {±1} | ω ∈ Ω} a class of classifiers. Assume that vθ and fω are ReLU
neural networks of fixed architectures, with parameters θ and ω (resp.). Let C(g) is the spectral
complexity of the neural network g and N(X) := {u ∈ Rd | ku - Xk2 ≤ } an -neighborhood of
X. Let D be a distribution of positive examples. With probability at least 1 - δ over the selection of
13
Published as a conference paper at ICLR 2019
the data S = {xi}m=ι i.i.d Dm ,for every vθ ∈ V and Cω ∈ C, we have:
Px vθ (x) 6= max vθ (u) or cω (x) 6= 1
u∈N (x)
1m
≤一 废 1 vθ(Xi)= max vθ(U) or Cω(xi) = 1
m	u∈N(xi)
i=1
(6)
+O(V
C(V ) + C(fω)+lθg (詈)
m
The above lemma shows that the probability of X 〜 D to be a local maxima of V and classified
as a positive example by cω , is at most the sum of the probability of x ∈ S to be a local maxima
of vθ and classified as a positive example by cω and a penalty term. The penalty in this case is
of the form O (j °C(vθ )十0fmHlog(m∕6 ), where m is the number of examples in the dataset and
C(vθ) + C(fω) is the sum of the spectral norms ofvθ andfω. This suggests a tradeoff between the
sum of the spectral complexities of vθ and fω and the ability to generalize. The bound is similar
asymptotically to the bounds of Neyshabur et al. (2018) and Bartlett et al. for (multi-class) super-
vised classification. In their bound, the penalty term is of the form O
(√1≡P≡ ),where
the (multi-class) classifier is of the form c(X) = argmaxi∈{1,...,t}f(X)i, for a neural network
f : Rd → Rt .
Our analysis focused on the value vθ and not on the comparator h. However, the complexities of the
two are expected to be similar, since a value function can be converted to a comparator by employing
h(X1, X2) = sign(vθ(X1) - vθ(X2)).
B A Formal Statement of the Generalization Bound
In this section, we build upon the theory presented by Neyshabur et al. (2018) and provide a gener-
alization bound that expresses the guarantees of learning c, along with v for a specific setting.
Before we introduce the generalization bound, we introduce the necessary terminology and
setup. We assume that the sampling space is a ball of radius B, i.e., X = XB,d := {X ∈
Rd | ||X||2 ≤ B}. Each value function vθ ∈ V is a ReLU neural network of the form
vθ(X) = Wrφ(Wr-1φ(. . . φ(W1X)), where, Wi ∈ Rdi×di+1 for i ∈ {1, . . . , r} such that
dr+1 := 1 and d1 := d. In addition, φ(X) = (max(0, x1), . . . , max(0, xn)) is the ReLU activation
function extended to all n ∈ N and X ∈ Rn. We denote, θ = (W1, . . . , Wr). The set C consists
of classifiers Cω := sign ofω SUch that each function fω : Rd → R is a ReLU neural network of
the formfω(X) = Usφ(Us-1φ(. . . φ(U1X)), where, Ui ∈ Rd0i×d0i+1 for i ∈ {1, . . . , s} such that
es+1 := 1 and d01 := d. We denote ω = (U1, . . . , Us). Additionally, we denote, q1 := max{di}ir=+11
and q2 := max{d0i}is=+11.
The spectral complexity ofa ReLU neural network gβ = Vkφ(Vk-1φ(. . . φ(V1X)) with parameters
β = (V1, . . . , Vk) is defined as follows:
C(gβ) := C(β) := YY IIWill2 XXT∣W⅛	(7)
i=1	i=1	i 2
For two distributions P and Q over a set X, we denote the KL-divergence between them by,
DKL(QIIP) ：= Ex〜Q[log(Q(x)∕P(x))]. For two functions function f,g : R → R, we denote
the asymptotic symbols: g(χ) = O(f (x)) to specify that g(χ) ≤ C ∙ f (x), for some constant c > 0.
We denote by 1[x] the indicator, ifa boolean x ∈ {true, false} is true or false.
We define a margin loss '八门6? : X X Ω X Θ → R of the form:
'γ1,γ2 (x; ω,θ) := 1 vθ(x) < max V(u) — γι or sign(fω (x) — γ2) = 1	(8)
u∈N (x)
14
Published as a conference paper at ICLR 2019
where, γ1, γ2 > 0 are fixed margins and N(x) := {u | ||u - x||2 ≤ } is the -neighborhood
of x, for a fixed > 0. In this model, the margins serve as parameters that dictate the amount of
tolerance in classifying an example as positive. Similar to the standard learning framework, for a
fixed distribution D over X, the goal of a learning procedure is to return (given some input) ω and θ
that minimize the following generalization risk function:
FD[ω,θ] := Ex〜D['o,o(x;ω,θ)]	(9)
The learning process has no direct access to the distribution D. Instead, it is provided with a set
of m i.i.d samples from D, S = {xi}m=ι Lt Dm. In order to estimate the generalization risk, the
empirical risk function is used during training:
m
FSY1,γ2[ω,θ] ：= - X 'γi,Y2 (Xi ； ω,θ)
m i=1
(10)
The following lemma provides a generalization bound that expresses the generalization of learning
c along with h.
Lemma 2. Let X := XB,n, V andC be as above. Let D be a distribution of positive examples. With
probability at least 1 - δ over the selection of the data S = {xi}im=1 it.i.d Dm , for every vθ ∈ V and
cω ∈ C, we have:
/ ~ ■ ∖
ʌ	B2 r2qι log(rqι) C(vθ) + s2q2 log(sq2) C(fω) +log (胃)
FD[θ,ω] ≤ FSγ1'γ2[θ,ω] + O t ------------------------Y--------------------ɪJ--------------
m
(11)
(12)
(13)
(14)
B.1 Proof of Lem. 2
All over the proofs, we will make use of two generic classes of functions G = {gθ : X → R2 | θ ∈
Θ} and H = {hω : X → R2 | ω ∈ Ω}. For simplicity, We denote the indices of gθ(x) and
hω(x) by -1 and 1 (instead of 1 and 2). Given a target function y : X → {±1} and two functions
gθ : X → R2 and hω : X → R2, We denote the loss of them With respect to a sample x by:
eγ1,γ2 (x; θ, ω) := 1gθ(x)[-y(xi)] - γ1 > gθ(x)[y(xi)]
∨ 1hω(x)[-y(xi)] - γ2 > hω(x)[y(xi)]
The generalization risk:
L71,72 [θ,ω]:= Ex〜D [e7ι,72 (x; θ, ω)]
And the empirical risk:
1m
L71,72 [θ,ω] := - X e∙γι ,γ2(xi; θ,ω)
m 12
i=1
We modify the proof of Lem. 1 in Neyshabur et al. (2018), such that it Will fit our purposes.
Lemma 3. Let y : X → {±1} be a target function. Let G = {gθ : X → R2 | θ ∈ Θ} and
H = {hω : X → R2 | ω ∈ Ω} be two classes class of functions (not necessarily neural networks).
Let Pi and P? be any two distributions on the parameters Θ and Ω (resp.) that are independent Ofthe
training data. Then, for any γ1, γ2, δ > 0, with probability ≥ 1-δ over the training set of size m, for
any two posterior distributions qe and qω over Θ and Ω (resp.), such that Pθo,ω√ [∣gθo (x)-gθ (x)∣∞ ≤
741 and ∣hω0(x) — hω(x)∣∞ ≤ 72] ≥ 2, we have:
T S ] V ^ S 1 ,aJ DKL(qe ||P1) + DKL(qω ||P2) + log( 6m)	“ 个、
L0,0[θ,ω] ≤ L71,72 [θ,ω] +41/-----------------m-1---------------- (15)
Proof. Let S71)72 ⊂ Θ × Ω be a set with the following properties:
s7,1ω,72 = n (θ0, ω0) ∈ θ × ω I ∀x ∈ X ： lgθ0 (X)- gθ (χ)l∞ < -4- and lhω0 (x) — hω (x)l∞ < ɪ }
(16)
15
Published as a conference paper at ICLR 2019
We construct a distribution Q over Θ X Ω, With probability density function:
…S ʃ qθ(θ0) ∙ qω (ω0) if — ∈ Sγiωγ2	(17)
Z 0	otherWise
Here, Z is a normalizing constant. By the assumption in the lemma, Z = P[(θ0, ω0) ∈ Sγια,γ2 ] ≥ 1.
By the definition of Q, We have:
γ1	γ2
max ∣gθ0(x) — gθ(x)∣∞ < ɪ and max ∣hωθ(X)— hω(x)∣∞ < -4
Therefore,
maxhgθ0(x)[—1] — gθ0(X)[1]| - |g©(x)[—1] — gθ(x)[l]|| < γ1
x∈X	2
and also,
maxllhω0 (x)[—1] — hω0 (X)[1]] — lhω (X)[—1] — hω (X)[1]|| < CY
x∈X	2
Since this equation holds uniformly for all X ∈ X, We have:
L0,0[θ, ω] ≤ Lγι γ2 [θ0,ω0]
00
L γ1, γ2 [θ , ω ] ≤ LYI ,Y2 [θ, ω]
(18)
(19)
(20)
(21)
NoW using the above inequalities together With Eq. 6 in Mcallester (2003), With probability 1 — δ
over the training set We have:
L0,0(θ, ω) ≤ Eθ0,ω0LYi,γ2 [θ0,ω0]
≤ Eθ0,ω0 L Yi,等[θ0,ω0] + 2s2(DKL(qllTp1)+lθg三
Zf S 40 /2(DκL(q∣∣Pι × P2)+log(竿))	(22)
≤ LYI ,Y2 [θ, ω] + 2y------m-1-------------
Vf S JzI /DκL(qθ X qω ||P1 X P2)+lθg(竿)
≤ LYi ,Y2 [θ, ω]+4y----------m-1-------------
Where the last inequality folloWs from the folloWing observation.
Let Sc denote the complement set of SY1ωγ2 and qc denote the density function q := q8 ×qω restricted
to Sc and normalized. In addition, We denote p := P1 X P2 . Then,
DκL(q∣∣p) = ZDκL(q∣∣p) + (1 — Z)DKL0||p) — H(Z)	(23)
Where H(Z) = —Z log Z — (1 — Z) log(1 — Z) ≤ 1 is the binary entropy function. Since the
KL-divergence is alWays positive, We get,
DκL(q∣∣p)=春[DκL(q∣∣p) + H(Z) — (1 — Z)DκL(qc∣∣p)] ≤ 2(DκL(q∣∣p) + 1)	(24)
Z
Since P1 XP2 are qθ X qω are independent joint distributions, We have: DκL(qθ X qω ||P1 XP2) =
DκL(qθ ||P1) + DκL(qω ∣∣P2).	口
Lemma 4. Let V = {vθ : X → [0, 1] | θ ∈ Θ} be a class of value functions vθ (X) ∈ [0, 1]
and C = {cω = sign ofω | fω ： X → R,ω ∈ Ω} a class of classifiers (not necessarily neural
networks). We define two classes of functions G = {gθ = (maxu∈N (x) vθ (u), vθ (X)) | θ ∈ Θ} and
H = {hω = (0,fω (x)) | ω ∈ Ω} .Then,
γ1	γ2
Pθ0,ω0 m^ ∣gθ0 (x) — gθ (x)∣∞ < -4 and m^ ∣hω0 (x) — hω (x)∣∞ < -4
≥ Pθ0 max ∣Vθ0 (x) — Vθ (x)| < γ41 ∙ Pω0 max Ifω0 (x) — fω (x)| < γ2
(25)
where, θ0 〜q§ and ω0 〜qω.
16
Published as a conference paper at ICLR 2019
Proof. We would like to prove that maxχ∈χ ∣gθo (x) 一 gθ (x)∣∞ ≤ γ11 if maxχ∈χ ∣vθo (x) 一 vθ (x)| ≤
γι and ∣hω0 (x) - hω (x)∣∞ ≤ Y2 if∣fω0 (x) - fω (x)| ≤ γ2. Since θ0 and ω0 are independent, it will
prove the desired inequality.
First, we consider that:
∣gθ0 (x) — gθ (x)∣∞ = max ( I max	(x) — max V (x)∣,∣vθ' (x) — V (x)| )
u∈N (x)	u∈N (x)
I	I	(26)
≤ max I I max v®； (x) — max vθ (x)l, γ1 ∣
u∈N (x)	u∈N (x)	4
With no loss of generality, we assume that maxu∈N(x) vθ0 (x) ≥ maxu∈N(x) vθ(x) and denote
x* = argmaxu∈Ne(χ) v®；(x). Therefore, We have:
I max vθ0 (x) — max vθ (x)I = max vθ0 (x) — max vθ (x)
u∈N (x)	u∈N (x)	u∈N (x)	u∈N (x)
= v®； (x*) — max v®(x)	(27)
u∈N (x)
≤ v®0(x*) — Vθ(x*) ≤ γ41
Next, we consider that:
∣hω0(x) — hω(x)∣∞ = max (|0 — 0|, |fs；(x) — fω(x)|) ≤ γ2	(28)
□
Lemma 5. Let V = {v® : X → [0, 1] | θ ∈ Θ} be a class of value functions v® (x) ∈ [0, 1]
and C = {cω = sign ofω | fω : X → R,ω ∈ Ω} a class of classifiers (not necessarily neural
networks). Let Pi and P? be any two distributions over the parameters Θ and Ω (resp.) that are
independent of the training data. Then, for any γ1, γ2, δ > 0, with probability ≥ 1 — δ over the
training set ofsize m ,for any two posterior distributions q® and qω over Θ and Ω (resp.), such that
Pθ0〜qθ[∣vθ0 (x) — Vθ(x)∣≤ γ1 ] ≥ √12 and Ps；〜q” [|fs；(x) — fω(x)l ≤ γ2] ≥ √2, we have:
Ex〜D1	max v®(u) > v®(x) or sign(fω(x)) = 1
u∈N (x)
1m
≤一 废 1 max v®(u) — γι > v®(Xi) or sign(fω(Xi) — Y2)= 1
m	u∈N (x)
i=i
+4

DKL (q® IIPI) + DKL (qω ||P2) + log( 6m)
m—1
Proof. Let G and H be as in Lem. 4. By Lem. 4 and our assumption,
P®0,s0
γi	γ2
m^ Ig®；(x) — g®(x)∣∞ < ɪ and m^ |hs；(x) — hω(x)∣∞ < ɪ
(29)
≥ 2	(30)
We note that all of the samples in D are positive. Therefore, by Lem. 3, with probability at least
1 — δ, we have:
Ex〜D1 [g®(x)[-1] > g®(x)[1] or hω(x)[—1] > hω(x)[1]]
1m
≤一 X 1 [g®(xi)[—1] — Yi > g®(xi)[1] or hω(xi)[—1] — Y2 > hω(xi)[1]]
m i=i
(31)
+4

DKL (q® 11PQ + DKL (qω〔1⑸ + log( 6m)
m—1
By the definition of g®: g®(X)[—1] = maxu∈N(x) v®(u), g®(X)[1] = v®(X). In addition, by the
definition of hω: hω (X)[—1] = 0 and hω (X)[1] = fω (X). Therefore, we can rephrase Eq. 31 as
17
Published as a conference paper at ICLR 2019
follows:
Ex〜D1	max Vθ(U) > vθ(x) or sign(fω(x)) = 1
u∈N(x)
+4
max	vθ(u)	-	γ1	>	vθ(xi) or sign(fω (xi)	-	γ2)	6=	1
u∈N(x)
(32)
DKL (qs 11PI) + DKL Sω llP^ + log( 6m )
m-1
□
Proof of Lem. 2. We apply Lem. 5 with priors P1 , P2 and posteriors qθ , qω , distributions simi-
lar the proof of Thm. 1 in (Neyshabur et al., 2018). In their proof, they show that for their
selection of prior and posterior distributions: (1) Pg，〜q@ [maxx∈χ ∣vθ(x) - V(x)| < γ1] ≥
2 holds and (2) Dkl(qg||P) = O(dr2B2qlog(rq)C(θ)∕γ2). By taking γι to be half
of the value the use and therefore, σ (from their proof) to be half of the value they use
as well, We obtain Pg，〜q@ [maxx∈χ |vg(x) - vg(x)| < 亭] ≥	√ and Dkl(qg||P)=
O(dr2Bl2qlog(rq)C(θ)∕γ2). We select P2 and qω in a similar fashion. In particular, we can re-
place the penalty term in Lem. 5 as follows:
4 SDKL(qg MP。+ DKL (qω "⑸ + log (6m)
m-1
--------------------------------------------------------∖	(33)
B2(r2qi log(rqι)C(vg)∕γ2 + s2q2 log(sq2)C(fω)∕γ2) + log (胃)\
m
□
C Additional Figures
18
Published as a conference paper at ICLR 2019
CIFAR-10
(Ship)
(Automobile)
(Cat)
(Dog)
MNIST
(8)
(9)
Figure 3: Same as Fig. 1, but where the images are taken from the test set of all classes, regardless
of the single class used for training.
19