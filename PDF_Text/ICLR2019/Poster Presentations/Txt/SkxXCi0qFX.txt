Published as a conference paper at ICLR 2019
ProMP: Proximal Meta-Policy Search
Jonas Rothfuss*
UC Berkeley, KIT
jonas.rothfuss@gmail.com
Dennis Lee* , Ignasi Clavera*
UC Berkeley
{dennisl88,iclavera}@berkeley.edu
Tamim Asfour
Karlsruhe Inst. of Technology (KIT)
asfour@kit.edu
Pieter Abbeel
UC Berkeley, Covariant.ai
pabbeel@cs.berkeley.edu
Ab stract
Credit assignment in Meta-reinforcement learning (Meta-RL) is still poorly un-
derstood. Existing methods either neglect credit assignment to pre-adaptation be-
havior or implement it naively. This leads to poor sample-efficiency during meta-
training as well as ineffective task identification strategies. This paper provides
a theoretical analysis of credit assignment in gradient-based Meta-RL. Building
on the gained insights we develop a novel meta-learning algorithm that over-
comes both the issue of poor credit assignment and previous difficulties in es-
timating meta-policy gradients. By controlling the statistical distance of both
pre-adaptation and adapted policies during meta-policy search, the proposed algo-
rithm endows efficient and stable meta-learning. Our approach leads to superior
pre-adaptation policy behavior and consistently outperforms previous Meta-RL
algorithms in sample-efficiency, wall-clock time, and asymptotic performance.
1	Introduction
A remarkable trait of human intelligence is the ability to adapt to new situations in the face of
limited experience. In contrast, our most successful artificial agents struggle in such scenarios.
While achieving impressive results, they suffer from high sample complexity in learning even a
single task, fail to generalize to new situations, and require large amounts of additional data to
successfully adapt to new environments. Meta-learning addresses these shortcomings by learning
how to learn. Its objective is to learn an algorithm that allows the artificial agent to succeed in an
unseen task when only limited experience is available, aiming to achieve the same fast adaptation
that humans possess (Schmidhuber, 1987; Thrun & Pratt, 1998).
Despite recent progress, deep reinforcement learning (RL) still relies heavily on hand-crafted fea-
tures and reward functions as well as engineered problem specific inductive bias. Meta-RL aims
to forego such reliance by acquiring inductive bias in a data-driven manner. Recent work proves
this approach to be promising, demonstrating that Meta-RL allows agents to obtain a diverse set of
skills, attain better exploration strategies, and learn faster through meta-learned dynamics models or
synthetic returns (Duan et al., 2016; Xu et al., 2018; Gupta et al., 2018b; Saemundsson et al., 2018).
Meta-RL is a multi-stage process in which the agent, after a few sampled environment interactions,
adapts its behavior to the given task. Despite its wide utilization, little work has been done to pro-
mote theoretical understanding of this process, leaving Meta-RL grounded on unstable foundations.
Although the behavior prior to the adaptation step is instrumental for task identification, the in-
terplay between pre-adaptation sampling and posterior performance of the policy remains poorly
understood. In fact, prior work in gradient-based Meta-RL has either entirely neglected credit as-
signment to the pre-update distribution (Finn et al., 2017) or implemented such credit assignment in
a naive way (Al-Shedivat et al., 2018; Stadie et al., 2018).
To our knowledge, we provide the first formal in-depth analysis of credit assignment w.r.t. pre-
adaptation sampling distribution in Meta-RL. Based on our findings, we develop a novel Meta-RL
algorithm. First, we analyze two distinct methods for assigning credit to pre-adaptation behavior.
* authors contributed equally to this work
1
Published as a conference paper at ICLR 2019
We show that the recent formulation introduced by Al-Shedivat et al. (2018) and Stadie et al. (2018)
leads to poor credit assignment, while the MAML formulation (Finn et al., 2017) potentially yields
superior meta-policy updates. Second, based on insights from our formal analysis, we highlight both
the importance and difficulty of proper meta-policy gradient estimates. In light of this, we propose
the low variance curvature (LVC) surrogate objective which yields gradient estimates with a favor-
able bias-variance trade-off. Finally, building upon the LVC estimator we develop Proximal Meta-
Policy Search (ProMP), an efficient and stable meta-learning algorithm for RL. In our experiments,
we show that ProMP consistently outperforms previous Meta-RL algorithms in sample-efficiency,
wall-clock time, and asymptotic performance.
2	Related Work
Meta-Learning concerns the question of “learning to learn”, aiming to acquire inductive bias in a
data driven manner, so that the learning process in face of unseen data or new problem settings is
accelerated (Schmidhuber, 1987; Schmidhuber et al., 1997; Thrun & Pratt, 1998).
This can be achieved in various ways. One category of methods attempts to learn the “learning pro-
gram” of an universal Turing machine in form of a recurrent / memory-augmented model that ingests
datasets and either outputs the parameters of the trained model (Hochreiter et al., 2001; Andrychow-
icz et al., 2016; Chen et al., 2017; Ravi & Larochelle, 2017) or directly outputs predictions for given
test inputs (Duan et al., 2016; Santoro et al., 2016; Mishra et al., 2018). Though very flexible and
capable of learning very efficient adaptations, such methods lack performance guarantees and are
difficult to train on long sequences that arise in Meta-RL.
Another set of methods embeds the structure of a classical learning algorithm in the meta-learning
procedure, and optimizes the parameters of the embedded learner during the meta-training (Husken
& Goerick, 2000; Finn et al., 2017; Nichol et al., 2018; Miconi et al., 2018). A particular instance of
the latter that has proven to be particularly successful in the context of RL is gradient-based meta-
learning (Finn et al., 2017; Al-Shedivat et al., 2018; Stadie et al., 2018). Its objective is to learn an
initialization such that after one or few steps of policy gradients the agent attains full performance
on a new task. A desirable property of this approach is that even if fast adaptation fails, the agent
just falls back on vanilla policy-gradients. However, as we show, previous gradient-based Meta-RL
methods either neglect or perform poor credit assignment w.r.t. the pre-update sampling distribution.
A diverse set of methods building on Meta-RL, has recently been introduced. This includes: learn-
ing exploration strategies (Gupta et al., 2018b), synthetic rewards (Sung et al., 2017; Xu et al.,
2018), unsupervised policy acquisition (Gupta et al., 2018a), model-based RL (Clavera et al., 2018;
Saemundsson et al., 2018), learning in competitive environments (Al-Shedivat et al., 2018) and
meta-learning modular policies (Frans et al., 2018; Alet et al., 2018). Many of the mentioned ap-
proaches build on previous gradient-based meta-learning methods that insufficiently account for the
pre-update distribution. ProMP overcomes these deficiencies, providing the necessary framework
for novel applications of Meta-RL in unsolved problems.
3	Background
Reinforcement Learning. A discrete-time finite Markov decision process (MDP), T, is defined
by the tuple (S, A,p,p0, r, H). Here, S is the set of states, A the action space, p(st+1 |st, at)
the transition distribution, p0 represents the initial state distribution, r : S × A → R is a reward
function, and H the time horizon. We omit the discount factor γ in the following elaborations
for notational brevity. However, it is straightforward to include it by substituting the reward by
r(st, at) := γtr(st, at). We define the return R(τ) as the sum of rewards along a trajectory τ :=
(so, ao,…,SH-ι, aH-ι, SH). The goal of reinforcement learning is to find a policy π(a∣s) that
maximizes the expected return ET~p『(T∣∏) [R(τ)].
Meta-Reinforcement Learning goes one step further, aiming to learn a learning algorithm which is
able to quickly learn the optimal policy for a task T drawn from a distribution of tasks ρ(T). Each
task T corresponds to a different MDP. Typically, it is assumed that the distribution of tasks share
the action and state space, but may differ in their reward function or their dynamics.
Gradient-based meta-learning aims to solve this problem by learning the parameters θ of a policy
πθ such that performing a single or few steps of vanilla policy gradient (VPG) with the given task
leads to the optimal policy for that task. This meta-learning formulation, also known under the name
2
Published as a conference paper at ICLR 2019
of MAML, was first introduced by Finn et al. (2017). We refer to it as formulation I which can be
expressed as maximizing the objective
JI(θ) = ET〜P(T)[Eτ0〜PT(T0∣θ0) [R(τ0)] ] With θ0 := U(θ, T) = θ + αVθE-Pτ(T∣θ) [R(τ)]
In that U denotes the update function which depends on the task T, and performs one VPG step
toWards maximizing the performance of the policy in T. For national brevity and conciseness We
assume a single policy gradient adaptation step. Nonetheless, all presented concepts can easily be
extended to multiple adaptation steps.
Later Work proposes a slightly different notion of gradient-based Meta-RL, also knoWn as E-MAML,
that attempts to circumvent issues With the meta-gradient estimation in MAML (Al-Shedivat et al.,
2018; Stadie et al., 2018):
N
J II (θ) = ET〜P(T)此 LN 〜PT (τ fθ)[R(τ 0)]] with θ0 := U (θ,τ 1:N )= θ + αVθ X [R(τ 叼
T0〜PT (τo∣θo)	n=1
Formulation II views U as a deterministic function that depends on N sampled trajectories from a
specific task. In contrast to formulation I, the expectation over pre-update trajectories τ is applied
outside of the update function. Throughout this paper we refer to πθ as pre-update policy, and πθ0
as post-update policy.
4 Sampling Distribution Credit Assignment
This section analyzes the two gradient-based Meta-RL formulations introduced in Section 3. Fig-
ure 1 illustrates the stochastic computation graphs (Schulman et al., 2015b) of both formulations.
The red arrows depict how credit assignment w.r.t the pre-update sampling distribution PT(T∣θ) is
propagated. Formulation I (left) propagates the credit assignment through the update step, thereby
exploiting the full problem structure. In contrast, formulation II (right) neglects the inherent struc-
ture, directly assigning credit from post-update return R0 to the pre-update policy πθ which leads to
noisier, less effective credit assignment.
Figure 1: Stochastic computation graphs of meta-learning formulation I (left) and formulation II (right). The
red arrows illustrate the credit assignment from the post-update returns R0 to the pre-update policy πθ through
Vθ Jpre. (Deterministic nodes: Square; Stochastic nodes: Circle)
Both formulations optimize for the same objective, and are equivalent at the 0th order. However,
because of the difference in their formulation and stochastic computation graph, their gradients and
the resulting optimization step differs. In the following, we shed light on how and where formu-
lation II loses signal by analyzing the gradients of both formulations, which can be written as (see
Appendix A for more details and derivations)
Vθ J(θ) = ET〜P(T)E T〜PT(τ∣θ)	Vθ JTOSt(T, T0) + Vθ Jpre(τ, T0)	(1)
τ0〜PT(τo∣θo) -
The first term VθJpost(T, T0) is equal in both formulations, but the second term, VθJpre(T, T0),
differs between them. In particular, they correspond to
VθJpost(T,T0)
Vθ,log ∏θ(τ0)R(τ0) (I + αR(τ)V2 logπθ> (T)))
'---------{z--------------------------V---------------}
▽ θ0Jouter	transformation from θ0 to θ
VθJpIrIe(T,T0) = αVθ log πθ (T)R(T0)
VθJpIre(T,T0) = αVθ logπθ(T) (Vθ log πθ (T)R(T))> (Vθ0 log πθ0 (T 0)R(T 0))
s-------------------------------------------------------}×----------------------}
(2)
(3)
(4)
^^^{^^^
▽ Jinner
^^^^{^^^^™
▽e，Jouter
3
Published as a conference paper at ICLR 2019
Vθ Jpost(T, T0) simply corresponds to a policy gradient step on the post-update policy ∏θo w.r.t θ0,
followed by a linear transformation from post- to pre-update parameters. It corresponds to increasing
the likelihood of the trajectories T0 that led to higher returns. However, this term does not optimize
for the pre-update sampling distribution, i.e., which trajectories T led to better adaptation steps.
The credit assignment w.r.t. the pre-updated sampling distribution is carried out by the second term.
In formulation II, VθJpIrIe can be viewed as standard reinforcement learning on πθ with R(T0) as
reward signal, treating the update function U as part of the unknown dynamics of the system. This
shifts the pre-update sampling distribution to better adaptation steps.
Formulation I takes the causal dependence of PT(T0∣θ0) on PT(T∣θ) into account. It does so by
maximizing the inner product of pre-update and post-update policy gradients (see Eq. 4). This steers
the pre-update policy towards 1) larger post-updates returns 2) larger adaptation steps αVθ Jinner, 3)
better alignment of pre- and post-update policy gradients (Li et al., 2017; Nichol et al., 2018). When
combined, these effects directly optimize for adaptation. As a result, we expect the first meta-policy
gradient formulation, JI, to yield superior learning properties.
5 Low Variance Curvature Estimator
In the previous section we show that the formulation introduced by Finn et al. (2017) results in
superior meta-gradient updates, which should in principle lead to improved convergence proper-
ties. However, obtaining correct and low variance estimates of the respective meta-gradients proves
challenging. As discussed by Foerster et al. (2018), and shown in Appendix B.3, the score func-
tion surrogate objective approach is ill suited for calculating higher order derivatives via automatic
differentiation toolboxes. This important fact was overlooked in the original RL-MAML implemen-
tation (Finn et al., 2017) leading to incorrect meta-gradient estimates1. As a result, VθJpre does
not appear in the gradients of the meta-objective (i.e. Vθ J = Vθ Jpost). Hence, MAML does not
perform any credit assignment to pre-adaptation behavior.
But, even when properly implemented, we show that the meta-gradients exhibit high variance.
Specifically, the estimation of the hessian of the RL-objective, which is inherent in the meta-
gradients, requires special consideration. In this section, we motivate and introduce the low variance
curvature estimator (LVC): an improved estimator for the hessian of the RL-objective which pro-
motes better meta-policy gradient updates. As we show in Appendix A.1, we can write the gradient
of the meta-learning objective as
vθ JI ⑻=ET〜P(T) hET0 〜PT (τ 0∣θ0) [Vθ0 logPT(T0∣θ0)R(τ0)VθU(θ,T)]]	(5)
Since the update function U resembles a policy gradient step, its gradient VθU(θ, T) involves com-
puting the hessian of the reinforcement learning objective, i.e., V ET〜PT(T∣θ) [R(t)]. Estimating
this hessian has been discussed in Baxter & Bartlett (2001) and Furmston et al. (2016). In the infi-
nite horizon MDP case, Baxter & Bartlett (2001) derived a decomposition of the hessian. We extend
their finding to the finite horizon case, showing that the hessian can be decomposed into three matrix
terms (see Appendix B.2 for proof):
vθU(θ, T) = I + αv2 ET〜PT(τ∣θ) [R(T)] = I + α(H1 + H2 + H12 + H>2)	⑹
whereby
HI = Eτ 〜PT (τ ∣θ)
H-1
Vθlogπθ(at, st)Vθ logπθ(at, st)>
t=0
HtX0=-t1
r(st0, at0)
))
H2 = Eτ 〜PT (τ ∣θ)
H-1
Vθ2 log πθ (at, st)
t=0
HtX0=-t1
r(st0, at0)
))
H12 = Eτ 〜PT (τ ∣θ)
H-1
X Vθ logπθ(at, st)VθQtπθ(st, at)>
t=0
1 Note that MAML is theoretically sound, but does not attend to correctly estimating the meta-policy gradi-
ents. As consequence, the gradients in the corresponding implementation do not comply with the theory.
4
Published as a conference paper at ICLR 2019
Here Q∏θ(st, at) = ETt+i：H-i〜PT(∙∣θ) [PH—t1 r(st, at"∣st, at] denotes the expected state-action
value function under policy πθ at time t.
Computing the expectation of the RL-objective is in general intractable. Typically, its gradients are
computed with a Monte Carlo estimate based on the policy gradient theorem (Eq. 82). In practical
implementations, such an estimate is obtained by automatically differentiating a surrogate objec-
tive (Schulman et al., 2015b). However, this results in a highly biased hessian estimate which just
computes H2, entirely dropping the terms H1 andH12+H1>2. In the notation of the previous section,
it leads to neglecting the VjJpre term, ignoring the influence of the pre-update sampling distribution.
The issue can be overcome using the DiCE formulation, which allows to compute unbiased higher-
order Monte Carlos estimates of arbitrary stochastic computation graphs (Foerster et al., 2018). The
DiCE-RL objective can be rewritten as follows
JDiCE(T) = XIYtI ;叫))! r(st, at) T 〜PT(T)	⑺
t=0 ∖t=0 ⊥(πθ(at0lst0)))
EiPT(τ∣θ) [V2JDiCE(T)] = Hi + H + H12 + H>2	⑻
In that, ⊥ denotes the "stop_gradient" operator, i.e., ⊥(fθ(x)) → fθ(x) but Vj⊥(fθ(x)) → 0. The
sequential dependence of ∏θ(at∣st) within the trajectory, manifesting itself through the product of
importance weights in (7), results in high variance estimates of the hessian V2 ET〜PT(T∣θ) [R(τ)].
As noted by Furmston et al. (2016), H12 is particularly difficult to estimate, since it involves three
nested sums along the trajectory. In section 7.2 we empirically show that the high variance estimates
of the DiCE objective lead to noisy meta-policy gradients and poor learning performance.
To facilitate a sample efficient meta-learning, we introduce the low variance curvature (LVC) esti-
mator:
JLVC(T) = XL r(atR)(IXr(st, at"!	T 〜PT(τ)	⑼
t=0 ⊥(πθ(at|St)) \念	)
ET 〜PT (τ | θ) [Vj2JLVC(T)] = HL +H2	(10)
By removing the sequential dependence of ∏θ(at∣st) within trajectories, the hessian estimate ne-
glects the term HL2 + HL>2 which leads to a variance reduction, but makes the estimate biased. The
choice of this objective function is motivated by findings in Furmston et al. (2016): under certain
conditions the term H12 + H> vanishes around local optima θ*, i.e., Eτ [V2JLVC] → ET [V2JDiCE]
as θ → θ*. Hence, the bias of the LVC estimator becomes negligible close to local optima. The
experiments in section 7.2 underpin the theoretical findings, showing that the low variance hessian
estimates obtained through JLVC improve the sample-efficiency of meta-learning by a significant
margin when compared to JDiCE. We refer the interested reader to Appendix B for derivations and a
more detailed discussion.
6	ProMP: Proximal Meta-Policy Search
Building on the previous sections, we develop a novel meta-policy search method based on the low
variance curvature objective which aims to solve the following optimization problem:
max ET〜P(T) [Et，〜PT(T'∣Θ') [R(t0)]]	with θ0 := θ + α VjEt〜PT(t∣θ) [JLVC(T)]	(11)
j
Prior work has optimized this objective using either vanilla policy gradient (VPG) or TRPO (Schul-
man et al., 2015a). TRPO holds the promise to be more data efficient and stable during the learning
process when compared to VPG. However, it requires computing the Fisher information matrix
(FIM). Estimating the FIM is particularly problematic in the meta-learning set up. The meta-policy
gradients already involve second order derivatives; as a result, the time complexity of the FIM es-
timate is cubic in the number of policy parameters. Typically, the problem is circumvented using
finite difference methods, which introduce further approximation errors.
The recently introduced PPO algorithm (Schulman et al., 2017) achieves comparable results to
TRPO with the advantage of being a first order method. PPO uses a surrogate clipping objective
which allows it to safely take multiple gradient steps without re-sampling trajectories.
τCLIP∕n∖ _ w	, c 、 ΓpH-1 rn;π π πθ(atlst) d∏θo (GC、 r1ir>1+e ( πθ(at|st)、d∏θo (Q C 'lʌl
JT (θ) = ET〜PT(TSo) [Tt=0 min (∏θo(at∣st) A (St，at) , CliPIi (∏θo(at∣st) ) A (st，at) j∖
5
Published as a conference paper at ICLR 2019
Algorithm 1 Proximal Meta-Policy Search (ProMP)
Require: Task distribution ρ, step sizes α, β, KL-Penalty coefficient η, clipping range E
1:	Randomly initialize θ
2:	while θ not converged do
3:	Sample batch of tasks Ti 〜P(T)
4:	for step n = 0, ..., N - 1 do
5:	if n = 0 then
6:	Set θo - θ
7:	for all Ti 〜ρ(T) do
8:	Sample pre-update trajectories Di = {τi} from Ti using πθ
9:	Compute adapted parameters θθ i J θ + α Vθ JTLR(θ.) with Di = {τi}
10:	Sample post-update trajectories D0i = {τi0} from Ti using πθ0
11:	Update θ J θ+βPT VθJTProMP(θ) using each Di0 = {τi0}	,
In case of Meta-RL, it does not suffice to just replace the post-update reward objective with JTCLIP. In
order to safely perform multiple meta-gradient steps based on the same sampled data from a recent
policy ∏θo, We also need to 1) account for changes in the pre-update action distribution ∏θ(at∣st),
and 2) bound changes in the pre-update state visitation distribution (Kakade & Langford, 2002).
We propose Proximal Meta-Policy Search (ProMP) which incorporates both the benefits of proximal
policy optimization and the low variance curvature objective (see Alg. 1.) In order to comply with
requirement 1), ProMP replaces the “stop gradient” importance weight
ratio
∏θ (at∣st)
πθo (at|St))
∏θ (at∣st)
⊥(∏θ (at∣st))
by the likelihood
, which results in the following objective
JTR(θ) = EiPT (T ,θo)
H-1
X
t=0
∏θ (at∣St)
πθo (at|st)
Aπθo (st, at)
(12)
An important feature of this objective is that its derivatives w.r.t θ evaluated at θo are identical to
those of the LVC objective, and it additionally accounts for changes in the pre-update action distribu-
tion. To satisfy condition 2) we extend the clipped meta-objective with a KL-penalty term between
πθ and πθo. This KL-penalty term enforces a soft local “trust region” around πθo, preventing the
shift in state visitation distribution to become large during optimization. This enables us to take
multiple meta-policy gradient steps without re-sampling. Altogether, ProMP optimizes
JTroMP(θ) = JTLIP(θ0)-ηDκK∏θo ,∏θ) s.t. θ0 = θ + α Vθ JTR(θ), T 〜P(T)	(13)
ProMP consolidates the insights developed throughout the course of this paper, while at the same
time making maximal use of recently developed policy gradients algorithms. First, its meta-learning
formulation exploits the full structural knowledge of gradient-based meta-learning. Second, it in-
corporates a low variance estimate of the RL-objective hessian. Third, ProMP controls the statistical
distance of both pre- and post-adaptation policies, promoting efficient and stable meta-learning.
All in all, ProMP consistently outperforms previous gradient-based meta-RL algorithms in sample
complexity, wall clock time, and asymptotic performance (see Section 7.1).
7	Experiments
In order to empirically validate the theoretical arguments outlined above, this section provides a
detailed experimental analysis that aims to answer the following questions: (i) How does ProMP
perform against previous Meta-RL algorithms? (ii) How do the lower variance but biased LVC
gradient estimates compare to the high variance, unbiased DiCE estimates? (iii) Do the different
formulations result in different pre-update exploration properties? (iv) How do formulation I and
formulation II differ in their meta-gradient estimates and convergence properties?
To answer the posed questions, we evaluate our approach on six continuous control Meta-RL bench-
mark environments based on OpenAI Gym and the Mujoco simulator (Brockman et al., 2016;
Todorov et al., 2012). A description of the experimental setup is found in Appendix D. In all ex-
periments, the reported curves are averaged over at least three random seeds. Returns are estimated
6
Published as a conference paper at ICLR 2019
ProMP (ours)	MAML-TRPO	E-MAML-TRPO	MAML-VPG
Figure 2: Meta-learning curves of ProMP and previous gradient-based meta-learning algorithms in six differ-
ent MuJoCo environments. ProMP outperforms previous work in all the the environments.
based on sampled trajectories from the adapted post-update policies and averaged over sampled
tasks. The source code and the experiment data are available on our supplementary website.2
7.1	Meta-Gradient Based Comparison
We compare our method, ProMP, in sample complexity and asymptotic performance to the gradient-
based meta-learning approaches MAML-TRPO (Finn et al., 2017) and E-MAML-TRPO (see Fig.
2). Note that MAML corresponds to the original implementation of RL-MAML by (Finn et al.,
2017) where no credit assignment to the pre-adaptation policy is happening (see Appendix B.3
for details). Moreover, we provide a second study which focuses on the underlying meta-gradient
estimator. Specifically, we compare the LVC, DiCE, MAML and E-MAML estimators while opti-
mizing meta-learning objective with vanilla policy gradient (VPG) ascent. This can be viewed as an
ablated version of the algorithms which tries to eliminate the influences of the outer optimizers on
the learning performance (see Fig. 3).
These algorithms are benchmarked on six different locomotion tasks that require adaptation: the
half-cheetah and walker must switch between running forward and backward, the high-dimensional
agents ant and humanoid must learn to adapt to run in different directions in the 2D-plane, and the
hopper and walker have to adapt to different configuration of their dynamics.
AntRandDir
180
160
140
0.0
HaIfCheetahFwdBack
LVC-VPG (ours)	MAML-VPG	E-MAML-VPG	DiCE-VPG
Figure 3: Meta-learning curves corresponding to different meta-gradient estimators in conjunction with VPG.
The introduced LVC approach Consistently outperforms the other estimators.
2https://sites.google.com/view/pro-mp
7
Published as a conference paper at ICLR 2019
AntRandDir
HaIfCheetahFwdBack
WaIkerRandParams
Oon
4 2
u-ln¾α ΦCTEω><
—LVC
——DiCE
p4S ①>⅛ωB
O O
O O
2 1
P4S ① >4eω0≤
Figure 4: Top: Relative standard deviation of meta-policy gradients. Bottom: Returns in the respective
environments throughout the learning process. LVC exhibits less variance in its meta-gradients which may
explain its superior performance when compared to DiCE.
The results in Figure 2 highlight the strength of ProMP in terms of sample efficiency and asymptotic
performance. In the meta-gradient estimator study in Fig. 3, we demonstrate the positive effect
of the LVC objective, as it consistently outperforms the other estimators. In contrast, DiCE learns
only slowly when compared to the other approaches. As we have motivated mathematically and
substantiate empirically in the following experiment, the poor performance of DiCE may be ascribed
to the high variance of its meta-gradient estimates. The fact that the results of MAML and E-
MAML are comparable underpins the ineffectiveness of the naive pre-update credit assignment (i.e.
formulation II), as discussed in section 4.
Results for four additional environments are displayed in Appendix D along with hyperparameter
settings, environment specifications and a wall-clock time comparison of the algorithms.
7.2	Gradient Estimator Variance and Its Effect on Meta-Learning
In Section 5 we discussed how the DiCE formulation yields unbiased but high variance estimates
of the RL-objective hessian and served as motivation for the low variance curvature (LVC) estima-
tor. Here we investigate the meta-gradient variance of both estimators as well as its implication
on the learning performance. Specifically, we report the relative standard deviation of the meta-
policy gradients as well as the average return throughout the learning process in three of the meta-
environments.
The results, depicted in Figure 4, highlight the advantage of the low variance curvature estimate.
The trajectory level dependencies inherent in the DiCE estimator leads to a meta-gradient standard
deviation that is on average 60% higher when compared to LVC. As the learning curves indicate,
the noisy gradients may be a driving factor for the poor performance of DiCE, impeding sample
efficient meta-learning. Meta-policy search based on the LVC estimator leads to substantially better
sample-efficiency and asymptotic performance.
In case of HalfCheetahFwdBack, we observe some unstable learning behavior of LVC-VPG which
is most likely caused by the bias of LVC in combination with the naive VPG optimizer. However, the
mechanisms in ProMP that ensure proximity w.r.t. to the policys KL-divergence seem to counteract
these instabilities during training, giving us a stable and efficient meta-learning algorithm.
7.3	Comparison of Initial Sampling Distributions
Here we evaluate the effect of the different objectives on the learned pre-update sampling distri-
bution. We compare the low variance curvature (LVC) estimator with TRPO (LVC-TRPO) against
MAML (Finn et al., 2017) and E-MAML-TRPO (Stadie et al., 2018) in a 2D environment on which
the exploration behavior can be visualized. Each task of this environment corresponds to reaching
a different corner location; however, the 2D agent only experiences reward when it is sufficiently
close to the corner (translucent regions of Figure 5). Thus, to successfully identify the task, the agent
must explore the different regions. We perform three inner adaptation steps on each task, allowing
the agent to fully change its behavior from exploration to exploitation.
8
Published as a conference paper at ICLR 2019
LVC
-2	-1 O 1	2
MAML
-2	-1 O 1	2
• Pre-update
Post-update
Figure 5: Exploration patterns of the pre-update policy and exploitation post-update with different update
functions. Through its superior credit assignment, the LVC objective learns a pre-update policy that is able to
identify the current task and respectively adapt its policy, successfully reaching the goal (dark green circle).
The different exploration-exploitation strategies are displayed in Figure 5. Since the MAML imple-
mentation does not assign credit to the pre-update sampling trajectory, it is unable to learn a sound
exploration strategy for task identification and thus fails to accomplish the task. On the other hand,
E-MAML, which corresponds to formulation II, learns to explore in long but random paths: because
it can only assign credit to batches of pre-update trajectories, there is no notion of which actions
in particular facilitate good task adaptation. As consequence the adapted policy slightly misses the
task-specific target. The LVC estimator, instead, learns a consistent pattern of exploration, visiting
each of the four regions, which it harnesses to fully solve the task.
7.4	Gradient Update Directions of the Two Meta-RL Formulations
To shed more light on the differences of the gradients of formu-
lation I and formulation II, we evaluate the meta-gradient up-
dates and the corresponding convergence to the optimum of both
formulations in a simple 1D environment. In this environment,
the agent starts in a random position in the real line and has to
reach a goal located at the position 1 or -1. In order to visualize
the convergence, we parameterize the policy with only two pa-
rameters θ0 and θ1 . We employ formulation I by optimizing the
DiCE objective with VPG, and formulation II by optimizing its
(E-MAML) objective with VPG.
Figure 6 depicts meta-gradient updates of the parameters θi for
both formulations. Formulation I (red) exploits the internal
structure of the adaptation update yielding faster and steadier
convergence to the optimum. Due to its inferior credit assign-
ment, formulation II (green) produces noisier gradient estimates
leading to worse convergence properties.
Figure 6: Meta-gradient updates of
policy parameters θ0 and θ1 in a
1D environment w.r.t Formulation I
(red) and Formulation II (green).
8	Conclusion
In this paper we propose a novel Meta-RL algorithm, proximal meta-policy search (ProMP), which
fully optimizes for the pre-update sampling distribution leading to effective task identification. Our
method is the result of a theoretical analysis of gradient-based Meta-RL formulations, based on
which we develop the low variance curvature (LVC) surrogate objective that produces low variance
meta-policy gradient estimates. Experimental results demonstrate that our approach surpasses previ-
ous meta-reinforcement learning approaches in a diverse set of continuous control tasks. Finally, we
underpin our theoretical contributions with illustrative examples which further justify the soundness
and effectiveness of our method.
Acknowledgments
Ignasi Clavera was supported by the La Caixa Fellowship. The research leading to these results has
received funding from the German Research Foundation (DFG: Deutsche Forschungsgemeinschaft)
under Priority Program on Autonomous Learning (SPP 1527) and was supported by Berkeley Deep
Drive, Amazon Web Services, and Huawei. Also we thank Abhishek Gupta, Chelsea Finn, aand
Aviv Tamar for their valuable feedback.
9
Published as a conference paper at ICLR 2019
References
Joshua Achiam, David Held, Aviv Tamar, and Pieter Abbeel. Constrained Policy Optimization.
Technical report, 2017. URL https://arxiv.org/pdf/1705.10528.pdf.
Maruan Al-Shedivat, Trapit Bansal, Umass Amherst, Yura Burda, Openai Ilya, Sutskever Openai,
Igor Mordatch Openai, and Pieter Abbeel. Continuous Adaptation via Meta-Learning in Nonsta-
tionary and Competitive Environments. In ICLR, 2018. URL https://goo.gl/tboqaN.
Ferran Alet, Toms Lozano-Perez, and Leslie P. Kaelbling. Modular meta-learning. Technical report,
6 2018. URL http://arxiv.org/abs/1806.10166.
Marcin Andrychowicz, Misha Denil, Sergio Gmez Colmenarejo, Matthew W Hoffman, David Pfau,
Tom Schaul, Brendan Shillingford, and Nando De Freitas. Learning to learn by gradient de-
scent by gradient descent. Technical report, 2016. URL https://arxiv.org/pdf/1606.
04474.pdf.
Jonathan Baxter and Peter L Bartlett. Infinite-Horizon Policy-Gradient Estimation. Technical report,
2001. URL https://arxiv.org/pdf/1106.0665.pdf.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. OpenAI Gym. Technical report, 6 2016. URL http://arxiv.org/
abs/1606.01540.
Yutian Chen, Matthew W Hoffman, Sergio Gmez Colmenarejo, Misha Denil, Timothy P Lillicrap,
Matt Botvinick, and Nando De Freitas. Learning to Learn without Gradient Descent by Gradient
Descent. In ICML, 2017.
Ignasi Clavera, Jonas Rothfuss, John Schulman, Yasuhiro Fujita, Tamim Asfour, and Pieter Abbeel.
Model-Based Reinforcement Learning via Meta-Policy Optimization. In CoRL, 2018. URL
http://arxiv.org/abs/1809.05214.
Yan Duan, John Schulman, Xi Chen, Peter L. Bartlett, Ilya Sutskever, and Pieter Abbeel. RL$八2$:
Fast Reinforcement Learning via Slow Reinforcement Learning. CoRR, abs/1611.0:1-14, 2016.
ISSN 0004-6361. doi: 10.1051/0004-6361/201527329. URL http://arxiv.org/abs/
1611.02779.
Chelsea Finn, Pieter Abbeel, and Sergey Levine. Model-Agnostic Meta-Learning for Fast Adapta-
tion of Deep Networks. In ICML, 2017.
Jakob Foerster, Gregory Farquhar, Maruan Al-Shedivat, Tim Rocktaschel, Eric P Xing, and Shimon
Whiteson. DiCE: The Infinitely Differentiable Monte Carlo Estimator. In ICML, 2018. URL
https://goo.gl/xkkGxN.
Kevin Frans, Jonathan Ho, Xi Chen, Pieter Abbeel, and John Schulman. Meta Learning Shared
Hierarchies. In ICLR, 10 2018. URL http://arxiv.org/abs/1710.09767.
Thomas Furmston, Guy Lever, David Barber, and Joelle Pineau. Approximate Newton Methods for
Policy Search in Markov Decision Processes. Technical report, 2016. URL http://jmlr.
org/papers/volume17/15-414/15-414.pdf.
Abhishek Gupta, Benjamin Eysenbach, Chelsea Finn, and Sergey Levine. Unsupervised Meta-
Learning for Reinforcement Learning. In ICML, 2018a.
Abhishek Gupta, Russell Mendonca, Yuxuan Liu, Pieter Abbeel, and Sergey Levine. Meta-
Reinforcement Learning of Structured Exploration Strategies. In ICML, 2018b. URL https:
//arxiv.org/pdf/1802.07245.pdf.
Sepp Hochreiter, A. Steven Younger, and Peter R. Conwell. Learning To Learn Using Gradient De-
scent. In ICANN, pp. 87-94, 2001. URL http://citeseerx.ist.psu.edu/viewdoc/
summary?doi=10.1.1.5.323.
10
Published as a conference paper at ICLR 2019
Michael Husken and Christian Goerick. Fast learning for problem classes using knowl-
edge based network initialization. In IJCNN. IEEE Computer Society Press, 2000.
URL http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.31.
9720&rep=rep1&type=pdf.
Sham Kakade and John Langford. Approximately Optimal Approximate Reinforcement Learn-
ing. In ICML, 2002. URL https://people.eecs.berkeley.edu/~pabbeel/
cs287-fa09/readings/KakadeLangford-icml2002.pdf.
Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M Hospedales. Learning to Generalize: Meta-
Learning for Domain Generalization. In AAAI, 2017. URL www.aaai.org.
Thomas Miconi, Jeff Clune, and Kenneth O. Stanley. Differentiable plasticity: training plastic neural
networks with backpropagation. In ICML, 4 2018. URL https://arxiv.org/abs/1804.
02464.
Nikhil Mishra, Mostafa Rohaninejad, Xi Chen, and Pieter Abbeel. A Simple Neural Attentive Meta-
Learner. In ICLR, 7 2018. URL http://arxiv.org/abs/1707.03141.
Alex Nichol, Joshua Achiam, and John Schulman. On First-Order Meta-Learning Algorithms. Tech-
nical report, 2018. URL http://arxiv.org/abs/1803.02999.
Jan Peters and Stefan Schaal. Policy Gradient Methods for Robotics. In 2006 IEEE/RSJ Inter-
national Conference on Intelligent Robots and Systems, pp. 2219-2225. IEEE, 10 2006. ISBN
1-4244-0258-1. doi: 10.1109/IROS.2006.282564. URL http://ieeexplore.ieee.org/
document/4058714/.
Sachin Ravi and Hugo Larochelle. Optimization as a Model for Few-Shot Learning. In ICLR, 11
2017. URL https://openreview.net/forum?id=rJY0-Kcll.
Steindr Saemundsson, Katja Hofmann, and Marc Peter Deisenroth. Meta Reinforcement Learning
with Latent Variable Gaussian Processes. In UAI, 2018. URL https://arxiv.org/pdf/
1803.07551.pdf.
Adam Santoro, Sergey Bartunov, Matthew Botvinick, Daan Wierstra, Timothy Lillicrap, and Google
Deepmind. Meta-Learning with Memory-Augmented Neural Networks. In ICML, 2016. URL
http://proceedings.mlr.press/v48/santoro16.pdf.
Juergen Schmidhuber. Evolutionary principles in self-referential learning. On learning how to learn:
The meta-meta-... hook. PhD thesis, Technische Universitaet Munchen, 1987. URL http:
//people.idsia.ch/~juergen/diploma.html.
Jrgen Schmidhuber, Jieyu Zhao, and Marco Wiering. Shifting Inductive Bias with Success-Story
Algorithm, Adaptive Levin Search, and Incremental Self-Improvement. Machine Learning, 28
(1):105-130, 1997. ISSN 08856125. doi: 10.1023/A:1007383707642. URL http://link.
springer.com/10.1023/A:1007383707642.
John Schulman, Nicolas Heess, Theophane Weber, and Pieter Abbeel. Gradient Estimation Using
Stochastic Computation Graphs. In NIPS, 2015a. URL https://arxiv.org/pdf/1506.
05254.pdf.
John Schulman, Sergey Levine, Philipp Moritz, Michael I. Jordan, and Pieter Abbeel. Trust Region
Policy Optimization. ICML, 2015b. ISSN 2158-3226. doi: 10.1063/1.4927398. URL http:
//arxiv.org/abs/1502.05477.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov Openai. Proximal
Policy Optimization Algorithms. CoRR, 2017. URL https://arxiv.org/pdf/1707.
06347.pdf.
Bradly C Stadie, Ge Yang, Rein Houthooft, Xi Chen, Yan Duan, Yuhuai Wu, Pieter Abbeel, and
Ilya Sutskever. Some Considerations on Learning to Explore via Meta-Reinforcement Learning.
Technical report, 2018. URL https://arxiv.org/pdf/1803.01118.pdf.
11
Published as a conference paper at ICLR 2019
Flood Sung, Li Zhang, Tao Xiang, Timothy Hospedales, and Yongxin Yang. Learning to Learn:
Meta-Critic Networks for Sample Efficient Learning. Technical report, 6 2017. URL http:
//arxiv.org/abs/1706.09529.
Richard S. Sutton, David Mcallester, Satinder Singh, and Yishay Mansour. Policy Gradient Methods
for Reinforcement Learning with Function Approximation. In NIPS, 2000. ISBN 0-262-19450-3.
doi: 10.1.1.37.9714.
Sebastian Thrun and Lorien Pratt. Learning to learn. 1998. ISBN 0792380479. URL https:
//dl.acm.org/citation.cfm?id=296639.
Emanuel Todorov, Tom Erez, and Yuval Tassa. MuJoCo: A physics engine for model-based control.
In IROS, pp. 5026-5033. IEEE, 10 2012. ISBN 978-1-4673-1736-8. doi: 10.1109/IROS.2012.
6386109. URL http://ieeexplore.ieee.org/document/6386109/.
Zhongwen Xu, Hado van Hasselt, and David Silver. Meta-Gradient Reinforcement Learning. Tech-
nical report, 5 2018. URL http://arxiv.org/abs/1805.09801.
12
Published as a conference paper at ICLR 2019
A Two Meta-Policy Gradient Formulations
In this section we discuss two different gradient-based meta-learning formulations, derive their gra-
dients and analyze the differences between them.
A. 1 Meta-Policy Gradient Formulation I
The first meta-learning formulation, known as MAML (Finn et al., 2017), views the inner update rule
U(θ, T) as a mapping from the pre-update parameter θ and the task T to an adapted policy parameter
θ0 . The update function can be viewed as stand-alone procedure that encapsulates sampling from
the task-specific trajectory distribution PT(T ∣∏θ) and updating the policy parameters. Building on
this concept, the meta-objective can be written as
JI(θ) = ET〜P(T) [Eτ，〜PT(T0∣θ0) [R(τ0)]]	with θ0 := U(θ,T)	(14)
The task-specific gradients follow as
Vθ JT(θ) = VθET，〜PT(τ0∣θ0) [R(τ0)]	(15)
=ET，〜PT(τ0∣θ0) [Vθ logPT(T0∣θ0)R(τ0)]	(16)
=ET，〜PT(τ0∣θ0) ", logPT(τ0∣θ0)R(τ0)Vθθ0]	(17)
In order to derive the gradients of the inner update Vθθ0 = VθU(θ, T) it is necessary to know the
structure of U. The main part of this paper assumes the inner update rule to be a policy gradient
descent step
VθU(θ, T) = Vθ (θ + α VθET〜PT(τ∣θ) [R(τ)])	(18)
= I + αVθ2
ET〜PT(t|θ) [R(T)]	(19)
Thereby the second term in (19) is the local curvature (hessian) of the inner adaptation objective
function. The correct hessian of the inner objective can be derived as follows:
V2 EiPT(t∣θ) [R(τ)] = Vθ EiPT(t∣θ) [Vθ log∏θ(τ)R(τ)]
Vθ
/ PT (T ∣Θ)Vθ log ∏θ (τ )R(τ )dτ
/ PT (T ∣Θ)Vθ log ∏θ (τ )Vθ log ∏θ(t )>R(τ)+
PT(t∣θ)V2 log ∏θ(t)R(t)dT
(20)
(21)
(22)
(23)
ET 〜PT (t | θ) [R(τ) (V2 log∏θ(τ) + Vθ log∏θ(τ)Vθ log∏θ(τ)>)]
(24)
A.2 Meta-Policy Gradient Formulation II
The second meta-reinforCement learning formulation views the the inner update θ0 = U(θ,τ 1:N)
as a deterministic function of the pre-update policy parameters θ and N trajectories T 1:N 〜
PT(τ 1:N∣θ) sampled from the pre-update trajectory distribution. This formulation was introduced
in Al-Shedivat et al. (2018) and further discussed with respect to its exploration properties in Stadie
et al. (2018).
Viewing U as a function that adapts the policy parameters θ to a specific task T given policy rollouts
in this task, the corresponding meta-learning objective can be written as
JII(θ) = ET〜P(T) ETLN〜PT(Tln∣Θ)[Et，〜PT(τ0∣θ0)[R(τ0)]i	with θ0 := U(θ,T 1:N)	(25)
Since the first part of the gradient derivation is agnostic to the inner update rule U(θ, T1:N), We only
assume that the inner update function U is differentiable w.r.t. θ. First we rewrite the meta-objective
J(θ) as expectation of task specific objectives JTII (θ) under the task distribution. This allows us to
express the meta-policy gradients as expectation of task-specific gradients:
Vθ JII(θ) = ET〜P(T) [Vθ JT(θ)]
(26)
13
Published as a conference paper at ICLR 2019
The task specific gradients can be calculated as follows
Vθ JT (θ)
Ne ET 〜PT (T 1：N ∣θ)
hEτ0 〜PT (τ0∣θ0) R(τ 0)
Vθ / / R(T0) Pt(T0∣θ0) Pt(T 1:N∣θ) dτ0 dτ
//R(T0) PT(T0∣θ0) VθlogPT(T 1:N∣θ)Pτ(T 1:N∣θ)+
R(T0) Vθ logPT(T0∣θ0)Pτ(T0∣θ0) PT(T 1:N∣θ) dr0 dr
ET1：N 〜PT (τ ln∣θJr(t 0) (vθ log Pt (t 0∣θ0) + XX Vθ log PT (t (n)∣θ) J
τ0〜PT(T0∣θ0) L	∖	i=1	)-
N
ETLN〜PT(τi：N|e)R(t0) Vθ0 log Pt(t0∣Θ0)Vθθ0 + X Vθ log PT(t(n)∣θ)
τ0 〜PT (T01 θ0) -	∖	n=1
As in A.1 the structure of U(θ, T1:N) must be known in order to derive the gradient Vθθ0. Since we
assume the inner update to be vanilla policy gradient, the respective gradient follows as
N	H-1
U(θ,τ 1:N) = e+&N X Vθ log∏θ(τ(n)))R(τ(n)) with Vθ log ∏(τ) = X Vθ log∏e(at∣st)
n=1	t=0
The respective gradient of U(θ,τ 1:N) follows as
VθU(θ,τ 1:N) = Vθ (θ + α^F Xx Vθ log∏θ(τS)))R(T(n)))	(27)
1N
=I + αN £V2 log∏θ(τ(n)))R(τ(n))	(28)
n=1
A.3 Comparing the Gradients of the Two Formulations
In the following we analyze the differences between the gradients derived for the two formulations.
To do so, we begin with VθJTI (θ) by inserting the gradient of the inner adaptation step (19) into
(17):
VθJTI (θ)
=ET0 〜PT (t 0∣θ0) [Vθ0 log Pt(t0∣θ0)R(τ0) (I + αV2 EiPT(τ∣θ) [R(τ)])]	(29)
We can substitute the hessian of the inner objective by its derived expression from (24) and then
rearrange the terms. Also note that Vθ logPT(τ∣θ) = V log ∏e(τ) = PH=-I log∏e(at∣st) where
H is the MDP horizon.
Vθ JT(θ) = ET，〜PT(τ0∣θ0) Vθ0 log Pt(t0∣θ0)R(τ0)(I + αE,〜PT(τ∣θ) [R(τ)	(30)
(V2 log∏θ(τ) + Vθ log∏θ(τ)Vθ log ∏θ(τ)>)])	(31)
E τ〜PT(τ|θ)
τ0 〜PT (τ 0∣θ0)
Vθ0 log πθ0 (T 0)R(T 0)
I + αR(T)Vθ2 log
(32)
▽e Jpost(τ,T0)
+αVθ0 logπθ0(T0)R(T0)R(T)Vθ logπθ(T)Vθ logπθ(T)>
'-------------------------------------------------}
(33)
{^^^^^^"
▽e Jpre(T ,τ 0)
14
Published as a conference paper at ICLR 2019
Next, we rearrange the gradient of JII into a similar form as Vθ JT(θ). For that, we start by inserting
(28) for Vθ θ0 and replacing the expectation over pre-update trajectories T 1:N by the expectation over
a single trajectory τ .
VθJTI (θ) =	E
T 〜PT (T | θ)	R(T0)Vθ0 log∏θ(TMI + αR(τ)V2 log∏(T)))	(34)
T0〜PT(T0∣θ0) LX-------------------{z----------------------}
▽e Jpost (τ ,T 0)
+R(T0)Vθ log πθ (T)	(35)
V------------------}_
▽eJpre(T ,τO)
While the first part of the gradients match ((32) and (34)), the second part ((33) and (35)) differs.
Since the second gradient term can be viewed as responsible for shifting the pre-update sampling
distribution PT(τ∣θ) towards higher post-update returns, We refer to it as VθJPre(T, T0) . To further
analyze the difference between Vθ JpIre and Vθ JpIrIe we slightly rearrange (33) and put both gradient
terms next to each other:
VθJpre(T, T0) = αVθ log∏θ(t)	(Vθ log∏(T)R(t))> (Vθo log ∏θo(T0)R(t0))]	(36)
X-----------V-----------'、----------V-----------}
▽	▽e Jinner	▽eO Jouter	)
VθJpIrIe(T,T0) = αVθ log πθ(T)R(T0)	(37)
In the following we interpret and and compare of the derived gradient terms, aiming to provide
intuition for the differences between the formulations:
The first gradient term Jpost that matches in both formulations corresponds to a policy gradient step
on the post-update policy πθO. Since θ0 itself is a function of θ, the term I + αR(T)Vθ2 logπθ(τ))
can be seen as linear transformation of the policy gradient update R(T 0)VθO log πθ(T0) from the
post-update parameter θ0 into θ. Although Jpost takes into account the functional relationship be-
tween θ0 and θ, it does not take into account the pre-update sampling distribution PT(t∣θ).
This is where Vθ Jpre comes into play: Vθ JpIre can be viewed as policy gradient update of the pre-
update policy πθ w.r.t. to the post-update return R(τ0). Hence this gradient term aims to shift the
pre-update sampling distribution so that higher post-update returns are achieved. However, Vθ JpIrIe
does not take into account the causal dependence of the post-update policy on the pre-update policy.
Thus a change in θ due to VθJpIrIe may counteract the change due to VθJpIoIst. In contrast, Vθ JpIre takes
the dependence of the the post-update policy on the pre-update sampling distribution into account.
Instead of simply weighting the gradients of the pre-update policy Vθ log πθ (T) with R(τ0) as in
VθJpIost, VθJpIost weights the gradients with inner product of the pre-update and post-update policy
gradients. This inner product can be written as
VθJinner>Vθo JOUter = ∣∣VθJinner∣∣2 ∙∣∣Vθo JOUter∣∣2 ∙ cos(δ)	(38)
wherein δ denotes the angle between the the inner and outer pre-update and post-update policy
gradients. Hence, VθJpIost steers the pre-update policy towards not only towards larger post-updates
returns but also towards larger adaptation steps αVθ Jinner, and better alignment of pre- and post-
update policy gradients. This directly optimizes for maximal improvement / adaptation for the
respective task. See Li et al. (2017); Nichol et al. (2018) for a comparable analysis in case of
domain generalization and supervised meta-learning. Also note that (38) allows formulation I to
perform credit assignment on the trajectory level whereas formulation II can only assign credit to
entire batches of N pre-update trajectories T 1:N.
As a result, we expect the first meta-policy gradient formulation to learn faster and more stably since
the respective gradients take the dependence of the pre-update returns on the pre-update sampling
distribution into account while this causal link is neglected in the second formulation.
B	Estimating the Meta-Policy Gradients
When employing formulation I for gradient-based meta-learning, we aim maximize the loss
J(θ)= ET〜ρ(T) [Eto〜PT(to∣θo) [R(τ0)]]	with θ0 ：= θ + α VθET〜PT(T∣θ) [R(τ)]	(39)
15
Published as a conference paper at ICLR 2019
by performing a form of gradient-descent on J(θ). Note that we, from now on, assume J := JI and
thus omit the superscript indicating the respective meta-learning formulation. As shown in A.2 the
gradient can be derived as Vθ J(θ) = E(T)〜P(T)[Vθ JT(θ)] with
Vθ JT⑹=Eτ0〜PT(τ0∣θ0) vθ0 log PT(T0∣θO)R(TO) ( I + αv2 ET〜PT(T∣θ) [R(τ)] I	(4O)
where V2Ji∩∩er(θ) := V ET〜PT(T∣θ) [R(τ)] denotes hessian of the inner adaptation objective w.r.t.
θ . This section concerns the question of how to properly estimate this hessian.
B.1 Estimating Gradients of the RL Reward Objective
Since the expectation over the trajectory distribution PT(τ∣θ) is in general intractable, the score
function trick is typically used to used to produce a Monte Carlo estimate of the policy gradients.
Although the gradient estimate can be directly defined, when using a automatic-differentiation tool-
box it is usually more convenient to use an objective function whose gradients correspond to the
policy gradient estimate. Due to the Policy Gradient Theorem (PGT) Sutton et al. (2000) such a
“surrogate” objective can be written as:
1	H-1
JPGT = K∑∑log∏θ(at∣st)	Ir(StO,at，) I Tk 〜PT(τ)
τk t=0
1	H-1
=K∑∑	∏θ(at∣St) ) r(st0,at0) Tk 〜PT(τ)
τk t=0
(41)
(42)
While (41) and (42) are equivalent (Peters & Schaal, 2006), the more popular formulation formula-
tion (41) can be seen as forward looking credit assignment while (42) can be interpreted as backward
looking credit assignment (Foerster et al., 2018). A generalized procedure for constructing “surro-
gate” objectives for arbitrary stochastic computation graphs can be found in Schulman et al. (2015a).
B.2	A decomposition of the hessian
Estimating the the hessian of the reinforcement learning objective has been discussed in Furmston
et al. (2016) and Baxter & Bartlett (2001) with focus on second order policy gradient methods. In
the infinite horizon MDP case, Baxter & Bartlett (2001) derive a decomposition of the hessian. In
the following, we extend their finding to the finite horizon case.
Proposition. The hessian of the RL objective can be decomposed into four matrix terms:
Vθ2Jinner(θ) = H1 + H2 + H12 + H1>2	(43)
where
HI = ET 〜PT (τ ∣θ)
H-1
Vθlogπθ(at,st)Vθlogπθ(at, st)>
t=0
HtX0=-t1
r(st0, at0)
H2 = ET 〜PT (T ∣θ)
H-1
V2θlogπθ(at,st)
t=0
(st0, at0)
))
H12 = ET 〜PT (T ∣θ)
H-1
X Vθlogπθ(at,st)VθQtπθ(st,at)>
t=0
(44)
(45)
(46)
Here Qfθ (st, at) = ETt+i：H-i〜PT(∙∣θ) ∣PH-t1
value function under policy πθ at time t.
r(st0,at0)|st,at
denotes the expected state-action
16
Published as a conference paper at ICLR 2019
Proof. As derived in (24), the hessian of Jinner(θ) follows as:
V2 Jinner = ET 〜PT (T ∣θ) [R(τ )(V2 log ∏θ (τ ) + Vθ log ∏θ (τ )Vθ log ∏θ (τ )>)]
(47)
H-1 t
ET 〜PT (T ∣θ) E (£v2 log ∏θ (ato, Sto) r(st, at)
(48)
t=0 to=0
ΓH-1
+ ET〜PT(t∣θ)	Vθ log∏θ(at，, Sto)
t=0
Vθ log πθ (ato, Sto)	r(St, at)
(49)
H-1
ET〜PT(τ∣θ)	£ V2 log∏θ(at, St)
t=0
H-1
+ ET 〜PT (t ∣θ)	E
t=0
r(St0, at0)
(50)
Vθ log∏θ(ato, Sto)Vθ log∏θ(ah, Sh)> r(st, at)
(51)
The term in (50) is equal to H2 . We continue by showing that the remaining term in (51) is equivalent
to H1 + H12 + H1>2 . For that, we split the inner double sum in (51) into three components:
H-1
ET 〜PT (τ ∣θ)	E
H-1
X
t=0
Vθlogπθ(ato,Sto)Vθlogπθ(ah,Sh)> r(St, at)
Vθlogπθ(ato,Sto)Vθlogπθ(ato,Sto)> r(St, at)
t=0
H-1 t	to-1
Σ	ΣΣVθlogπθ(ato, Sto)Vθ log πθ (ah, Sh)> r(St, at)
t=0	to=0 h=0
H-1	t
Σ	Σ Vθlogπθ(ato,Sto)Vθlogπθ(ah,Sh)> r(St, at)
t=0	h=to +1
(52)
(53)
(54)
(55)
By changing the backward looking summation over outer products into a forward looking summa-
tion of rewards, (53) can be shown to be equal to H1:
ET 〜PT (τ | θ)
H-1
X
t=0
Vθlogπθ(ato,Sto)Vθlogπθ(ato,Sto)>
H1
H-1
Vθ log πθ (at, St)Vθ logπθ(at, St)>
t=0
r(Sto,ato)
(56)
(57)
(58)
By simply exchanging the summation indices t0 and h in (55) it is straightforward to show that (55)
is the transpose of (54). Hence it is sufficient to show that (54) is equivalent to H12 . However,
instead of following the direction of the previous proof we will now start with the definition of H12
and derive the expression in (54).
H-1
H12 = ET 〜PT (τ ∣θ) X Vθ log ∏θ(at, Stw Qtθ (st, at)>
t=0
The gradient of Qtπθ can be expressed recursively:
Vθ Qtπθ (St, at) = Vθ E st+1 [Qtπ+θ 1 (St+1, at+1)
at+1
= East+1 Vθ logπθ(at+1, St+1)Qtπ+θ1(St+1, at+1) + VθQtπ+θ1(St+1, at+1)
(59)
(60)
(61)
(62)
17
Published as a conference paper at ICLR 2019
By induction, it follows that
NθQt θ (st, at) = ETt+1：H-1 ^Pt(∙∣θ)
H-1
Nθ log πθ (at0, st0)
t0=t+1
r(sh, ah)
(63)
When inserting (63) into (59) and swapping the summation, we are able to show that H12 is equiv-
alent to (54).
H12 = Eτ 〜PT (T ∣θ)
H-1 H-1
Σ Σ Nθlogπθ(at,st)Nθlogπθ(at0,st0)>
t=0 t0=t+1
r(sh, ah)
H-1	t t0-1
i (τ∣θ) ∑	∑∑Nθlogπθ(at0, st0)Nθlogπθ(ah,sh)> r(st, at)
t=0	t0=0 h=0
(64)
(65)
This concludes the proof that the hessian of the expected sum of rewards under policy πθ and an
MDP with finite time horizon H can be decomposed into H1 + H2 + H12 + H1>2.

B.3	Estimating the Hessian of the RL Reward Objective
As pointed out by Al-Shedivat et al. (2018); Stadie et al. (2018) and Foerster et al. (2018), sim-
ply differentiating through the gradient of surrogate objective JPGT as done in the original MAML
version (Finn et al., 2017) leads to biased hessian estimates. Specifically, when compared with the
unbiased estimate, as derived in (24) and decomposed in Appendix B.2, both H1 and H12 + H1>2 are
missing. Thus, NθJpre does not appear in the gradients of the meta-objective (i.e. NθJ = NθJpost).
Only performing gradient descent with Nθ Jpost entirely neglects influences of the pre-update sam-
pling distribution. This issue was overseen in the RL-MAML implementation of Finn et al. (2017).
As discussed in Stadie et al. (2018) this leads to poor performance in meta-learning problems that
require exploration during the pre-update sampling.
B.3.1	The DICE Monte-Carlo Estimator
Addressing the issue of incorrect higher-order derivatives of monte-carlo estimators, Foerster et al.
(2018) propose DICE which mainly builds upon an newly introduced MagicBox() operator. This
operator allows to formulate monte-carlo estimators with correct higher-order derivatives. A DICE
formulation of a policy gradient estimator reads as:
H-1
JDICE = X θ({at0≤t})r(st, at)	(66)
t=0
= Eexp ( Elog∏θ(ato|st，)一⊥(log∏θ(at，厢，)r(st,at)	(67)
t=0	t0=0
In that，⊥ denotes a "stop_gradient" operator (i.e. ⊥(fθ(x)) → fθ(x) but Vθ⊥(fθ(x)) → 0).
Note that → denotes a “evaluates to” and does not necessarily imply equality w.r.t. to gradients.
Hence, J DICE(θ) evaluates to the sum of rewards at 0th order but produces the unbiased gradients
VθnJ DICE(θ) when differentiated n-times (see Foerster et al. (2018) for proof). To shed more light
on the maverick DICE formulation, we rewrite (67) as follows:
JDICE = S (∏0 ⊥Π≡⅛⅛! r(st,at)	(68)
Interpreting this novel formulation, the MagicBox operator θ({at0≤t}) can be understood as “dry”
importance sampling weight. At 0th order it evaluates to 1 and leaves the objective function unaf-
fected, but when differentiated once it yields an estimator for the marginal rate of return due to a
change in the policy-implied trajectory distribution.
18
Published as a conference paper at ICLR 2019
In the following we show that on expectation 1) the gradients of (81) match standard policy gradients
and 2) its hessian estimate is equal to the hessian of inner RL objective, derived in B.2.
Vθ J DICE = X1Vθ(Y	∏θ ”) ! r(st, at)	(69)
t=0	[=0l⊥ ⊥(πθ(at0lst0)))
=X Y∏ I丁(；”|：01)! (Xvθlogπθ(at0ιsto)!T(St,at)	(7O)
t=0 ∖悬 ⊥(πθ(at0lst0))) ∖t⅛	)
→Ε I Vθ∣ Vθ log∏θ(at0∣st0) ) r(st, at)	(71)
t=0 t0=0
Here, (71) corresponds to the backward looking credit assignment formulation of policy gradients
VθJPGT as discussed in B.1. Once again we take the derivative in order to obtain the Hessian of
JDICE:
t
H1
Vθ2JDICE =	Vθ
t=0	t0=0
+	∏t
t0=0
H-1
→X
t=0
log ∏θ (at0 ∣Stο) r(st,at)
∏θ (at0 ∣Stο)
⊥(∏θ (at ∣Stο))
∏θ (atο∣Stο)
⊥(∏θ (atο∣Stο))
Vθ log πθ (at0 |St0)
Vθ log ∏θ (atο |st，) r(st,at)
Vθ log ∏θ (atο∣stο) Y(St ,at)
Vθ log∏θ(at0∣St0) ) r(st,at)
(72)
(73)
(74)
(75)
In expectation, ET〜PT(T ∣θ) Vθ JDICE] the DICE monte carlo estimate of the hessian is equivalent to
the hessian of the inner objective. To show this, we use the expression of Vθ2Jinner (49):
H-1
ET 〜PT(T ∣θ)	E
t=0
Vθ log ∏θ(at0 ∣sto)
Vθ log πθ (at0 |St0)
H1 +H2 +H12 + H1>2
r(St, at) +
log πθ (at0 |St0)
r(St, at)
(76)
(77)
(78)
(79)
(80)
>
B.4	Bias and variance of the curvature estimate
As shown in the previous section, Vθ2JDICE provides an unbiased estimate of the hessian of the inner
objective Jinner = ET〜PT(τ∣θ) [R(τ)]. However, recall the DICE objective involves a product of
importance weights along the trajectory.
JDICE=X1 (t∏0 u⅛⅛! …t)	(81)
Taking the 2nd derivative of this product leads to the outer product of sums in (74) which is of high
variance w.r.t to τ. Specifically, this outer product of sums can be decomposed into three terms
H1 +H12 + H1>2 (see Appendix B.2). As noted by Furmston et al. (2016), H12 + H1>2 is particularly
difficult to estimate. In section 7.2 we empirically show that the high variance curvature estimates
obtained with the DICE objective require large batch sizes and impede sample efficient learning.
In the following we develop a low variance curvature (LVC) estimator JLVC which matches J DICE
at the gradient level and yields lower-variance estimates of the hessian by neglecting H12 + H1>2 .
19
Published as a conference paper at ICLR 2019
Before formally introducing JLVC, we motivate such estimator starting with the policy gradient
estimate that was originally derived in Sutton et al. (2000), followed by marginalizing the trajectory
level distribution PT(T∣θ) over states St and actions at. Note that We omit reward baselines for
notational simplicity.
Ne Jinner = ET 〜PT (T ∣θ)
H-1
E Vθ log∏θ(at |st)
t=0
r(st0, at0)
H-1
XE πθ
St 〜Ptθ (St)
t=0 at 〜∏θ (at∣st)
Vθ log∏θ(at∣St)
X r(st0,at0)
(82)
(83)
In that, ptπθ (st) denotes the state visitation frequency at time step t, i.e. the probability density of
being in st after t steps under the policy πθ. In the general case ptπθ (st) is intractable but depends
on the policy parameter θ. We make the simplifying assumption that ptπθ (st) is fixed in a local
region of θ. Since we make this assumption at the gradient level, this corresponds to a 1st order
Taylor expansion of ptπθ (st) in θ. Note that this assumption is also used in the Monotonic Policy
Improvement Theory (Kakade & Langford, 2002; Schulman et al., 2015a). Based on this condition,
the hessian follows as derivative of (83) whereby a "stop_gradient" expression around the state
visitation frequency ptπθ (st) resembles the 1st order Taylor approximation:
H-1
ET [v2JLVC] = vθ X Est〜Up：。(st))
t=0	at 〜∏θ (at∣st)
Vθ log∏θ(at∣St)
r(st0, at0)
))
H-1	H-1
EEst〜⊥(pπθ(st)) Vθ log∏θ(at∣st)Vθ log∏(at∣st)> I ET(St0, at)
t=0	at〜∏θ(at∣st) L	∖t0 = t
+ V2 log ∏θ (at∣st) (X r(sto ,at，))
(84)
(85)
(86)
Since the expectation in (84) is intractable it must be evaluated by a monte carlo estimate. However,
simply replacing the expectation with an average of samples trajectories induces a wrong hessian
that does not correspond to (86) since outer product of log-gradients would be missing when dif-
ferentiated. To ensure that automatic differentiation still yields the correct hessian, we add a “dry”
importance weight comparable to DICE:
Vθ JLVC = X I πθ(atlst∣、Vθ log∏θ(at∣st) XX r(st0,at0)]	T 〜PT(T∣θ)
=⊥(πθ (at|St))	\念	)
When integrated this resembles the LVC “surrogate” objective JLVC.
JLVC = X1 T⅛ (XIr(St',at'))	T 〜。TEθ)
The gradients of JLVC match Vθ J DICE and resemble an unbiased policy gradient estimate:
V。JLVC = S 5θ≡ (XLr(St0,at0))
=X iπS⅛⅛Ve logπθ(at|St) (XJS
H-1	H-1
→ E Ve log ∏θ(at∣St) I E r(Sf ,ae) I
t=0	t0=t
(87)
(88)
(89)
(90)
(91)
20
Published as a conference paper at ICLR 2019
The respective Hessian can be obtained by differentiating (90):
V2JLVC = VθX1 l∏θ (atlSt).. Vθ log ∏θ (at∣st) (XIr(St,,at，))
t=0 ⊥(πθ(at|St))	Lt	)
=X ⊥∏∏(at1SS))) Vθ log∏θ(at∣st)Vθ log∏θ(at∣St)> (X r(st，,at，)
+ I ："；，)、V2 log πθ (at|St) X X MSt ,at，))
⊥(πθ (at|St))	∖t⅛	)
H-1	H-1
→ £ Vθ log∏θ(at∣St)Vθ log∏θ(at∣St)> I £ 9t,at，)
t=0	t，=t
+ Vθ log ∏θ (at∣st) I Er(StO ,at，)
t0=t
E I E Vθ log ∏θ(at，∣Sto)Vθ log∏θ(at∣st)> r(st,at)
t=0 t，=0
+ I E V2 log ∏θ(at，|st，) r(st,at)
t0=0
(92)
(93)
(94)
(95)
(96)
(97)
(98)
In expectation V2 JLVC is equivalent to Hi + H2:
ET 〜PT (T | θ) JLVC
=ET 〜PT (T | θ)
E I £ Vθlog∏θ(at，|st，)V©log∏θ(at∣st)> I r(st, at)
t=0 t，=0
(99)
+ ET 〜PT (T | θ)
H1 + H2
H-1
X
t=0
log ∏θ (at，|st，)
r(st, at)
(100)
(101)
The Hessian V2θ J LVC no longer provides an unbiased estimate of Vθ2Jinner since neglects the matrix
term H12 +H1>2. This approximation is based on the assumption that the state visitation distribution
is locally unaffected by marginal changes in θ and leads to a substantial reduction of variance in
the hessian estimate. Furmston et al. (2016) show that under certain conditions (i.e. infinite horizon
MDP, sufficiently rich policy parameterisation) the termH12+H1>2 vanishes around a local optimum
θ*. Given that the conditions hold, this implies that E"V2JLVC] → ET[V2JDice] as θ → θ*, i.e.
the bias of the LCV estimator becomes negligible close to the local optimum. The experiments
in section 7.2 confirm this theoretical argument empirically and show that using the low variance
curvature estimates obtained through JLVC improve the sample-efficiency of meta-learning by a
significant margin.
C Proximal Policy Search Methods
C.1 Monotonic Policy Improvement Theory
This section provides a brief introduction to policy performance bounds and the theory of monotonic
policy improvement in the setting of reinforcement learning. While Section 6 discusses the extension
of this theory to meta learning, the following explanations assume a standard RL setting where T
is exogenously given. Hence, we will omit mentioning the dependence on T for notational brevity.
Since the monotonic policy improvement frameworks relies on infinite-time horizon MDPs, we
assume H → ∞ for the remainder of this chapter.
21
Published as a conference paper at ICLR 2019
In addition to the expected reward J(π) under policy π, we will use the state value function V π, the
state-action value function Qπ as well as the advantage function Aπ :
∞
V π (s) = Ea0,s1 ,... X γ r(st , at)st = s
t=0
∞
Qπ (s, a) = EsI ,aι,…〉:γr(st, at) St = s, a0 = a = r(s, a) + YEs0~p(s0∣s,a) [Vπ (S )]
t=0
Aπ (s, a) = Qπ (s, a) - V π(s)
with at ~ ∏(at∣st) and st+ι ~ p(st+ι∣st, at).
The expected return under a policy ∏ can be expressed as the sum of the expected return of another
policy ∏ and the expected discounted advantage of ∏ over ∏ (see Schulman et al.(2015a) for proof).
∞
J(∏) = J(∏) + Eτ~p(τ,∏)	X YtAπ(st, at)
t=0
Let dπ denote the discounted state visitation frequency:
∞
d∏(s) = Yt Ep(St = s∣∏)
t=0
We can use d∏ to express the expectation over trajectories T 〜pπ (τ) in terms of states and actions:
J(∏) = J(∏) + Es~d∏(s) [Aπ (s, a)]	(102)
a~∏(a∣s)
Local policy search aims to find a policy update ∏ → ∏ in the proximity of ∏ so that J(∏) is
maximized. Since J(∏) is not affected by the policy update ∏ → ∏, it is sufficient to maximize
the expected advantage under ∏. However, the complex dependence of d∏(s) on ∏ makes it hard to
directly maximize the objective in (102). Using a local approximation of (102) where it is assumed
that the state visitation frequencies d∏ and d∏ are identical, the optimization can be phrased as
≈	....	一 ，	、	一	、r	-，	、	一
J∏(∏) = J(∏) + Es~d∏ (s)	[A (s, a)] = J(∏) + Es~d∏(s)
a~∏(a∣s)	a~π(a∣s)
[当An (s, a)
π(a∣s)
(103)
In the following We refer to J(∏) as surrogate objective. It can be shown that the surrogate objective
J matches J to first order when ∏ = ∏ (see Kakade & Langford (2002)). If ∏θ is a parametric and
differentiable function with parameter vector θ, this means that for any θo :
J∏θo(πθo ) = J∏θo(πθo ) and Vθ J∏θo(πθ)lθo= Vθ J∏θo(πθ )lθo	(104)
When ∏ = ∏, an approximation error of the surrogate objective J w.r.t. to the true objective J is
introduced. Achiam et al. (2017) derive a lower bound for the true expected return of ∏:
J (∏) ≥ Jπ (∏) - C pEs~d∏ [Dkl[∏(∙∣s)∣∣∏(∙∣s)]] = Jπ(∏)- CqDKL [∏ ∣∣∏]	(105)
with C = √-2γ maxs ∣Ea~∏(a,s)[Aπ(s, a)]|
C.2 Trust Region Policy Optimization (TRPO)
Trust region policy optimization (TPRO) (Schulman et al., 2015a) attempts to approximate the
bound in (105) by phrasing local policy search as a constrained optimization problem:
argmax Es~d∏ (s)	"θ*s)ʌ Anθo (s, a)	s.t. Dkl[∏θ0∣∣∏θ] ≤ δ	(106)
θ	πθo	πθo (a|s)
a~∏θo (a|s)	o
22
Published as a conference paper at ICLR 2019
Thereby the KL-constraint δ induces a local trust region around the current policy πθo. A practical
implementation of TPRO uses a quadratic approximation of the KL-constraint which leads to the
following update rule:
θ - θ +
(107)
With g := VθEs〜d.“ (s)
θo
∏θ(a∣s)
πθo(aIs)
Aπθo (s, a) being the gradient of the objective and F
_	a 〜∏θo (a∣s)
V2DDkl [∏θo ∣∣∏θ] the Fisher information matrix of the current policy ∏θo . In order to avoid the cubic
time complexity that arise When inverting F, the Conjugate Gradient (CG) algorithm is typically
used to approximate the Hessian vector product F -1g.
C.3 Proximal Policy Optimization (PPO)
While TPRO is framed as constrained optimization, the theory discussed in Appendix C.1 suggest
to optimize the loWer bound. Based on this insight, Schulman et al. (2017) propose adding a KL
penalty to the objective and solve the folloWing unconstrained optimization problem:
arg max Es 〜d∏ (s)	叫。?、Aπθo (s, a) - βD⅛L[∏θ0 (∙∣s)∣∣∏θ (∙∣s)]	(108)
θ	πθo	πθo (a|s)
a 〜∏θo (a∣s)	o
HoWever, they also shoW that it is not sufficient to set a fixed penalty coefficient β and propose tWo
alternative methods, knoWn as Proximal Policy Optimization (PPO) that aim toWards alleviating this
issue:
1)	Adapting the KL coefficient β so that a desired target KL-divergence Dkl[∏θo ∣∣∏θ] between the
policy before and after the parameter update is achieved
2)	Clipping the likelihood ratio so that the optimization has no incentive to move the policy πθ too
far away from the original policy πθo. A corresponding optimization objective reads as:
JCLIP = Es 〜d∏θo (s)
a 〜∏θo(a∣s)
min π πθ(QIs) Aπθo (s a) CliD 1+e ( πθ(a|s) ʌ Aπθo (S a)
min Uθo(a∣s)A (S,Q), Pj Uθo(a∣s)L (S,Q)
(109)
Empirical results show that the latter approach leads to better learning performance (Schulman et al.,
2017).
Since PPO objective keeps πθ in proximity of πθo , it allows to perform multiple gradient steps
without re-sampling trajectories from the updated policy. This property substantially improves the
data-efficiency of PPO over vanilla policy gradient methods which need to re-estimate the gradients
after each step.
D Experiments
D. 1 Hyperparameter Choice
The optimal hyperparameter for each algorithm was determined using parameter sweeps. Table 1
contains the hyperparameter settings used for the different algorithms. Any environment specific
modifications are noted in the respective paragraph describing the environment.
D.2 Environment S pecifications
PointEnv (used in the experiment in 7.3)
•	Trajectory Length : 100
•	Num Adapt Steps : 3
23
Published as a conference paper at ICLR 2019
All Algorithms	
Policy Hidden Layer Sizes NUm Adapt Steps Inner Step Size ɑ Tasks Per Iteration Trajectories Per Task	(64, 64) (128,128) for Humanoid 1 0.01 40 	20	
ProMP	
Outer Learning Rate β Grad Steps Per ProMP Iteration Outer Clip Ratio E KL Penalty Coef. η	0.001 5 0.3 	0.0005	
MAML-TRPO	
Trust Region Size	0.01
MAML-VPG	
Outer Learning Rate β	0.001
Table 1: Hyperparameter settings used in each algorithm
In this environment, each task corresponds to one corner of the area. The point mass must reach
the goal by applying directional forces. The agent only experiences a reward when within a certain
radius of the goal, and the magnitude of the reward is equal to the distance to the goal.
HalfCheetahFwdBack, AntFwdBack, WalkerFwdBack, HumanoidFwdBack
•	Trajectory Length : 100 (HalfCheetah, Ant); 200 (Humanoid, Walker)
•	Num Adapt Steps: 1
The task is chosen between two directions - forward and backward. Each agent must run along the
goal direction as far as possible, with reward equal to average velocity minus control costs.
AntRandDirec, HumanoidRandDirec
•	Trajectory Length : 100 (Ant); 200 (Humanoid)
•	Num Adapt Steps: 1
Each task corresponds to a random direction in the XY plane. As above, each agent must learn to
run in that direction as far as possible, with reward equal to average velocity minus control costs.
AntRandGoal
•	Trajectory Length : 200
•	Num Adapt Steps: 2
In this environment, each task is a location randomly chosen from a circle in the XY plane. The goal
is not given to the agent - it must learn to locate, approach, and stop at the target. The agent receives
a penalty equal to the distance from the goal.
HopperRandParams, WalkerRandParams
•	Trajectory Length : 200
•	Inner LR : 0.05
•	Num Adapt Steps: 1
The agent must move forward as quickly as it can. Each task is a different randomization of the
simulation parameters, including friction, joint mass, and inertia. The agent receives a reward equal
to its velocity.
24
Published as a conference paper at ICLR 2019
D.3 Further Experiments Results
In addition to the six environments displayed in 2, we ran experiments on the other four continuous
control environments described above. The results are displayed in 7.
Figure 7: Meta-learning curves of ProMP and four other gradient-based meta-learning algorithms in
four new Mujoco environments
In addition to the improved sample complexity and better asymptotic performance, another ad-
vantage of ProMP is its computation time. Figure 8 shows the average time spent per iteration
throughout the learning process in the humanoid environment differences of ProMP, LVC-VPG,
and MAML-TRPO. Due to the expensive conjugate gradient steps used in TRPO, MAML takes far
longer than either first order method. Since ProMP takes multiple stochastic gradient descent steps
per iteration, it leads to longer outer update times compared to VPG, but in both cases the update
time is a fraction of the time spent sampling from the environment.
The difference in sampling time is due to the reset process: resetting the environment when the agent
“dies” is an expensive operation. ProMP acquires better performance quicker, and as a result the
agent experiences longer trajectories and the environment is reset less often. In our setup, instances
of the environment are run in parallel and performing a reset blocks all environments.
Time-Sampling Time-SampIeProc Time-InnerStep Time-OuterStep
Figure 8: Comparison of wall clock time with different algorithms on HumanoidRandDirec, aver-
aged over all iterations
25