Published as a conference paper at ICLR 2019
Algorithmic Framework for Model-based
Deep Reinforcement Learning with Theoreti-
cal Guarantees
Yuping Luo *1, Huazhe Xu *2, Yuanzhi Li4, Yuandong Tian3, Trevor Darrell2, and Tengyu Ma4
1Princeton University, yupingl@cs.princeton.edu
2 University of California, Berkeley, {huazhe_xu,trevor}@eecs.berkeley.edu
3Facebook AI Research, yuandong@fb.com
4 Stanford University. {yuanzhil,tengyuma}@stanford.edu
Ab stract
Model-based reinforcement learning (RL) is considered to be a promising approach
to reduce the sample complexity that hinders model-free RL. However, the theoret-
ical understanding of such methods has been rather limited. This paper introduces
a novel algorithmic framework for designing and analyzing model-based RL algo-
rithms with theoretical guarantees. We design a meta-algorithm with a theoretical
guarantee of monotone improvement to a local maximum of the expected reward.
The meta-algorithm iteratively builds a lower bound of the expected reward based
on the estimated dynamical model and sample trajectories, and then maximizes the
lower bound jointly over the policy and the model. The framework extends the
optimism-in-face-of-uncertainty principle to non-linear dynamical models in a way
that requires no explicit uncertainty quantification. Instantiating our framework
with simplification gives a variant of model-based RL algorithms Stochastic Lower
Bounds Optimization (SLBO). Experiments demonstrate that SLBO achieves state-
of-the-art performance when only one million or fewer samples are permitted on a
range of continuous control benchmark tasks.* 1
1	Introduction
In recent years deep reinforcement learning has achieved strong empirical success, including super-
human performances on Atari games and Go (Mnih et al., 2015; Silver et al., 2017) and learning
locomotion and manipulation skills in robotics (Levine et al., 2016; Schulman et al., 2015b; Lillicrap
et al., 2015). Many of these results are achieved by model-free RL algorithms that often require
a massive number of samples, and therefore their applications are mostly limited to simulated
environments. Model-based deep reinforcement learning, in contrast, exploits the information from
state observations explicitly — by planning with an estimated dynamical model — and is considered
to be a promising approach to reduce the sample complexity. Indeed, empirical results (Deisenroth &
Rasmussen, 2011b; Deisenroth et al., 2013; Levine et al., 2016; Nagabandi et al., 2017; Kurutach
et al., 2018; Pong et al., 2018a) have shown strong improvements in sample efficiency.
Despite promising empirical findings, many of theoretical properties of model-based deep reinforce-
ment learning are not well-understood. For example, how does the error of the estimated model affect
the estimation of the value function and the planning? Can model-based RL algorithms be guaranteed
to improve the policy monotonically and converge to a local maximum of the value function? How
do we quantify the uncertainty in the dynamical models?
It’s challenging to address these questions theoretically in the context of deep RL with continuous
state and action space and non-linear dynamical models. Due to the high-dimensionality, learning
models from observations in one part of the state space and extrapolating to another part sometimes
0* indicates equal contribution
1The source code of this work is available at https://github.com/roosephu/slbo
1
Published as a conference paper at ICLR 2019
involves a leap of faith. The uncertainty quantification of the non-linear parameterized dynamical
models is difficult — even without the RL components, it is an active but widely-open research
area. Prior work in model-based RL mostly quantifies uncertainty with either heuristics or simpler
models (Moldovan et al., 2015; Xie et al., 2016; Deisenroth & Rasmussen, 2011a).
Previous theoretical work on model-based RL mostly focuses on either the finite-state MDPs (Jaksch
et al., 2010; Bartlett & Tewari, 2009; Fruit et al., 2018; Lakshmanan et al., 2015; Hinderer, 2005;
Pirotta et al., 2015; 2013), or the linear parametrization of the dynamics, policy, or value func-
tion (Abbasi-Yadkori & Szepesvdri, 2011; SimchoWitz et al., 2018; Dean et al., 2017; SUtton et al.,
2012; Tamar et al., 2012), but not much on non-linear models. Even with an oracle prediction
intervals2 or posterior estimation, to the best of oUr knoWledge, there Was no previoUs algorithm With
convergence gUarantees for model-based deep RL.
ToWards addressing these challenges, the main contribUtion of this paper is to propose a novel
algorithmic frameWork for model-based deep RL With theoretical gUarantees. OUr meta-algorithm
(Algorithm 1) extends the optimism-in-face-of-Uncertainty principle to non-linear dynamical models
in a Way that reqUires no explicit Uncertainty qUantification of the dynamical models.
Let V π be the valUe fUnction V π of a policy π on the trUe environment, and let Vb π be the valUe
fUnction of the policy π on the estimated model Mc. We design provable Upper boUnds, denoted by
Dπ,M, on hoW mUch the error can compoUnd and divert the expected valUe Vbπ of the imaginary
rolloUts from their real valUe V π, in a neighborhood of some reference policy. SUch Upper boUnds
captUre the intrinsic difference betWeen the estimated and real dynamical model With respect to the
particUlar reWard fUnction Under consideration.
The discrepancy boUnds Dπ,M natUrally leads to a loWer boUnd for the trUe valUe fUnction:
Vπ ≥ Vbπ - Dπ
,Mc
(1.1)
OUr algorithm iteratively collects batches of samples from the interactions With environments, bUilds
the loWer boUnd above, and then maximizes it over
both the dynamical model Mc and the policy
π. We can Use any RL algorithms to optimize the loWer boUnds, becaUse it Will be designed to
only depend on the sample trajectories from a fixed reference policy (as opposed to reqUiring neW
interactions With the policy iterate.)
We shoW that the performance of the policy is gUaranteed to monotonically increase, assUming the
optimization Within each iteration sUcceeds (see Theorem 3.1.) To the best of oUr knoWledge, this is
the first theoretical gUarantee of monotone improvement for model-based deep RL.
Readers may have realized that optimizing a robUst loWer boUnd is reminiscent of robUst control
and robUst optimization. The distinction is that We optimistically and iteratively maximize the RHS
of (1.1) jointly over the model and the policy. The iterative approach alloWs the algorithms to collect
higher qUality trajectory adaptively, and the optimism in model optimization encoUrages explorations
of the parts of space that are not covered by the cUrrent discrepancy boUnds.
To instantiate the meta-algorithm, We design a feW valid discrepancy boUnds in Section 4. In
Section 4.1, We recover the norm-based model loss by imposing the additional assUmption of a
Lipschitz valUe fUnction. The resUlt sUggests a norm is preferred compared to the sqUare of the norm.
Indeed in Section 6.2, We shoW that experimentally learning With `2 loss significantly oUtperforms
the mean-squared error loss ('2).
In Section 4.2, We design a discrepancy boUnd that is invariant to the representation of the state space.
Here We measure the loss of the model by the difference betWeen the value of the predicted next
state and the value of the true next state. Such a loss function is shoWn to be invariant to one-to-one
transformation of the state space. Thus We argue that the loss is an intrinsic measure for the model
error Without any information beyond observing the reWards. We also refine our bounds in Section A
by utilizing some mathematical tools of measuring the difference betWeen policies in χ2-divergence
(instead of KL divergence or TV distance).
2We note that the confidence interval of parameters are likely meaningless for over-parameterized neural
netWorks models.
2
Published as a conference paper at ICLR 2019
Our analysis also sheds light on the comparison between model-based RL and on-policy model-free
RL algorithms such as policy gradient or TRPO (Schulman et al., 2015a). The RHS of equation (1.1)
is likely to be a good approximator of V π in a larger neighborhood than the linear approximation of
V π used in policy gradient is (see Remark 4.5.)
Finally, inspired by our framework and analysis, we design a variant of model-based RL algorithms
Stochastic Lower Bounds Optimization (SLBO). Experiments demonstrate that SLBO achieves
state-of-the-art performance when only 1M samples are permitted on a range of continuous control
benchmark tasks.
2	Notations and Preliminaries
We denote the state space by S, the action space by A. A policy ∏(∙∣s) specifies the conditional
distribution over the action space given a state s. A dynamical model M(∙∣s,a) specifies the
conditional distribution of the next state given the current state s and action a. We will use M?
globally to denote the unknown true dynamical model. Our target applications are problems with the
continuous state and action space, although the results apply to discrete state or action space as well.
When the model is deterministic, M(∙∣s, a) is a dirac measure. In this case, We use M(s, a) to denote
the unique value of s0 and view M as a function from S × A to S. Let M denote a (parameterized)
family of models that We are interested in, and Π denote a (parameterized) family of policies.
Unless otherWise stated, for random variable X , We Will use pX to denote its density function.
Let S0 be the random variable for the initial state. Let Stπ,M to denote the random variable of the
states at steps t When We execute the policy π on the dynamic model M stating With S0 . Note that
S0π,M = S0 unless otherWise stated. We Will omit the subscript When it’s clear from the context. We
use At to denote the actions at step t similarly. We often use τ to denote the random variable for the
trajectory (S0, A1, . . . , St, At, . . . ). Let R(s, a) be the reWard function at each step. We assume R
is known throughout the paper, although R can be also considered as part of the model if unknoWn.
Let γ be the discount factor.
Let V π,M be the value function on the model M and policy π defined as:
∞
Vπ,M(s)= E	XγtR(St,At) |S0=s	(2.1)
∀t≥0,At 〜π(∙∣St) t=0
St+ι〜M(∙∣St,At) Lt=0	」
We define Vπ,M = E Vπ,M(S0) as the expected reWard-to-go at Step 0 (averaged over the random
initial states). Our goal is to maximize the reWard-to-go on the true dynamical model, that is, V π,M?,
over the policy π. For simplicity, throughout the paper, We set κ = γ(1 - γ)-1 since it occurs
frequently in our equations. Every policy π induces a distribution of states visited by policy π :
Definition 2.1. For a policy π, define ρπ,M as the discounted distribution of the states visited by
π on M. Let ρπ be a shorthand for ρπ,M? and We omit the superscript M? throughout the paper.
Concretely,we have ρπ = (1 - Y) P∞=0 Yt ∙ ps∏
3 Algorithmic Framework
As mentioned in the introduction, towards optimizing Vπ,M? ,3 our plan is to build a lower bound for
Vπ,M? of the following type and optimize it iteratively:
Vπ,M? ≥ V π,Mc - D(Mc, π)	(3.1)
Mc	M?
where D(M, π) ∈ R≥0 bounds from above the discrepancy between Vπ,M and Vπ,M . Building
such an optimizable discrepancy bound globally that holds for all Mc and π turns out to be rather
difficult, if not impossible. Instead, we shoot for establishing such a bound over the neighborhood of
a reference policy πref.
Vπ,M? ≥ Vπ,Mc-Dπref,δ(Mc,π),	∀π s.t. d(π, πref) ≤ δ	(R1)
3Note that in the introduction we used V π for simplicity, and in the rest of the paper we will make the
dependency on M? explicit.
3
Published as a conference paper at ICLR 2019
Here d(∙, ∙) is a function that measures the closeness of two policies, which will be chosen later in
alignment with the choice of D. We will mostly omit the subscript δ in D for simplicity in the rest of
the paper. We will require our
discrepancy bound to vanish when Mcis an accurate model:
Mc = M =⇒ Dπref (Mc, π) = 0,	∀π, πref
(R2)
The third requirement for the discrepancy bound D is that it can be estimated and optimized in the
sense that
Dπref (Mc, π) is of the form E	[f (Mc, π, τ)]	(R3)
T 〜∏ref,M ?
where f is a known differentiable function. We can estimate such discrepancy bounds for every π in
the neighborhood of πref by sampling empirical trajectories τ(1), . . . , τ(n) from executing policy πref
on the real environment M? and compute the average of f (M, ∏, T(i))'s. We would have to insist
that the expectation cannot be over the randomness of trajectories from π on M? , because then we
would have to re-sample trajectories for every possible π encountered.
For example, assuming the dynamical models are all deterministic, one of the valid discrepancy
bounds (under some strong assumptions) that will prove in Section 4 is a multiple of the error of the
prediction of Mc
on the trajectories from πref:
Dnref (Cn= L ∙ S0,..,StE∏ref,M ・^^ (St)- k 1
Suppose we can establish such an discrepancy bound D (and the distance function d) with properties
(R1), (R2), and (R3), — which will be the main focus of Section 4 —, then we can devise the
following meta-algorithm (Algorithm 1). We iteratively optimize the lower bound over the policy
πk+1 and the model Mk+1, subject to the constraint that the policy is not very far from the reference
policy πk obtained in the previous iteration. For simplicity, we only state the population version with
the exact computation of Dπref (M, π), though empirically it is estimated by sampling trajectories.
Algorithm 1 Meta-Algorithm for Model-based RL
Inputs: Initial policy ∏o. Discrepancy bound D and distance function d that satisfy equation (R1)
and (R2).
For k = 0 to T :
πk+1, Mk+1 = argmax Vπ,M - Dπk,δ(M, π)	(3.3)
π∈Π, M∈M
s.t. d(π, πk) ≤ δ	(3.4)
We first remark that the discrepancy bound Dπk (M, π) in the objective plays the role of learning the
dynamical model by ensuring the model to fit to the sampled trajectories. For example, using the
discrepancy bound in the form of equation (3.2), we roughly recover the standard objective for model
learning, with the caveat that we only have the norm instead of the square of the norm in MSE. Such
distinction turns out to be empirically important for better performance (see Section 6.2).
Second, our algorithm can be viewed as an extension of the optimism-in-face-of-uncertainty (OFU)
principle to non-linear parameterized setting: jointly optimizing M and π encourages the algorithm
to choose the most optimistic model among those that can be used to accurately estimate the value
function. (See (Jaksch et al., 2010; Bartlett & Tewari, 2009; Fruit et al., 2018; Lakshmanan et al., 2015;
Pirotta et al., 2015; 2013) and references therein for the OFU principle in finite-state MDPs.) The
main novelty here is to optimize the lower bound directly, without explicitly building any confidence
intervals, which turns out to be challenging in deep learning. In other words, the uncertainty is
measured straightforwardly by how the error would affect the estimation of the value function.
Thirdly, the maximization of V π,M, when M is fixed, can be solved by any model-free RL algorithms
with M as the environment without querying any real samples. Optimizing V π,M jointly over π, M
can be also viewed as another RL problem with an extended actions space using the known “extended
MDP technique”. See (Jaksch et al., 2010, section 3.1) for details.
4
Published as a conference paper at ICLR 2019
Our main theorem shows formally that the policy performance in the real environment is non-
decreasing under the assumption that the real dynamics belongs to our parameterized family M.4
Theorem 3.1. Suppose that M? ∈ M, that D and d satisfy equation (R1) and (R2), and the
optimization problem in equation (3.3) is solvable at each iteration. Then, Algorithm 1 produces a
sequence of policies π0, . . . , πT with monotonically increasing values:
V∏0,M? ≤ V∏1,M? ≤ ∙∙∙ ≤ V∏t,M'
(3.5)
Moreover, as k → ∞, the value Vπk,M? converges to some Vπ,M?, where π is a local maximum of
Vπ,M? in domain Π.
The theorem above can also be extended to a finite sample complexity result with standard concen-
tration inequalities. We show in Theorem G.2 that we can obtain an approximate local maximum
in O(1∕ε) iterations with sample complexity (in the number of trajectories) that is polynomial in
dimension and accuracy ε and is logarithmic in certain smoothness parameters.
Proof of Theorem 3.1. Since D and d satisfy equation (R1), we have that
Vπk+1,M? ≥ Vπk+1,Mk+1 - Dπk (Mk+1, πk+1)
By the definition that πk+1 and Mk+1 are the optimizers of equation (3.3), we have that
V πk+1,Mk+1 - Dnk (Mk+1,∏k+1) ≥ Vπk ,M ? - Dnk (M *,∏k) = V πk,M ?	(by equation R2)
Combing the two equations above we complete the proof of equation (3.5).
For the second part of the theorem, by compactness, we have that a subsequence of πk converges
to some π. By the monotonicity We have Vnk,M ≤ Vn,M for every k ≥ 0. For the sake of
contradiction, we assume ∏ is a not a local maximum, then in the neighborhood of ∏ there exists ∏0
such that Vn0,M? > Vn,M? and d(∏,∏0) < δ∕2. Let t be such that ∏t is in the δ∕2-neighborhood of ∏.
Then we see that (π0, M?) is a better solution than (πt+1, Mt+1) for the optimization problem (3.3)
in iteration t because Vn0,M? > Vn,M? ≥ Vnt+1,M? ≥ Vnt+1,Mt+1 一 Dnt(Mt+ι,∏t+ι). (Herethe
last inequality uses equation (R1) with πt as πref.) The fact (π0, M?) is a strictly better solution than
(πt+1, Mt+1) contradicts the fact that (πt+1, Mt+1) is defined to be the optimal solution of (3.3) .
Therefore ∏ is a local maximum and we complete the proof.
4	Discrepancy Bounds Design	口
In this section, we design discrepancy bounds that can provably satisfy the requirements (R1), (R2),
and (R3). We design increasingly stronger discrepancy bounds from section 4.1 to section A.
4.1	Norm-based prediction error bounds
in this subsection, we assume the dynamical model M? is deterministic and we also learn with a
deterministic model Mc. Under assumptions defined below, we derive a discrepancy bound D of the
form kM (S, A) - M?(S, A)k averaged over the observed state-action pair (S, A) on the dynamical
model Mc. This suggests that the norm is a better metric than the mean-squared error for learning the
model, which is empirically shown in section 6.2. Through the derivation, we will also introduce a
telescoping lemma, which serves as the main building block towards other finer discrepancy bounds.
We make the (strong) assumption that the value function Vn,M on the estimated dynamical model is
L-Lipschitz w.r.t to some norm k ∙ k in the sense that
∀s, s0 ∈ S, ∣Vn,M(S) — Vn,M(s0)∣ ≤ L ∙∣∣s — s0k	(4.1)
in other words, nearby starting points should give reward-to-go under the same policy π. We note
that not every real environment M? has this property, let alone the estimated dynamical models.
4We note that such an assumption, though restricted, may not be very far from reality: optimistically speaking,
we only need to approximate the dynamical model accurately on the trajectories of the optimal policy. This
might be much easier than approximating the dynamical model globally.
5
Published as a conference paper at ICLR 2019
However, once the real dynamical model induces a Lipschitz value function, we may penalize the
Lipschitz-ness of the value function of the estimated model during the training.
We start off with a lemma showing that the expected prediction error is an upper bound of the
discrepancy between the real and imaginary values.
Lemma 4.1. Suppose V π,M is L-Lipschitz (in the sense of (4.1)). Recall κ = γ(1 - γ)-1.
V π,Mc - Vπ,M? ≤ κL E	kMc(S, A) -M?(S,A)k
S〜ρπ L	」
A 〜π(∙∣S)
(4.2)
However, in RHS in equation 4.2 cannot serve as a discrepancy bound because it does not satisfy the
requirement (R3) — to optimize it over π we need to collect samples from ρπ for every iterate π —
the state distribution of the policy π on the real model M? . The main proposition of this subsection
stated next shows that for every π in the neighborhood of a reference policy πref, we can replace the
distribution ρπ be a fixed distribution ρπref with incurring only a higher order approximation. We use
the expected KL divergence between two π and πref to define the neighborhood:
dKL(∏,∏ref )= E [KL(∏(∙∣S),∏ref(∙∣S ))1/2]
S〜Pn L	」
(4.3)
Proposition 4.2. In the same setting of Lemma 4.1, assume in addition that π is close to a reference
policy πref in the sense that dKL(π, πref) ≤ δ, and that the states in S are uniformly bounded in the
sense that ksk ≤ B, ∀s ∈ S. Then,
V π,Mc - V π,M? ≤ κL E	hkMc(S, A) -M?(S,A)ki + 2κ2δB	(4.4)
S〜pF L	」
A 〜π(∙∣S)
In a benign scenario, the second term in the RHS of equation (4.4) should be dominated by the first
term when the neighborhood size δ is sufficiently small. Moreover, the term B can also be replaced
by maxS,AkM(S, A) - M?(S, A)k (see the proof that is deferred to Section C.). The dependency
on κ may not be tight for real-life instances, but we note that most analysis of similar nature loses the
additional κ factor Schulman et al. (2015a); Achiam et al. (2017), and it’s inevitable in the worst-case.
A telescoping lemma. Towards proving Propositions 4.2 and deriving stronger discrepancy bound,
?
we define the following quantity that captures the discrepancy between M and M? on a single
state-action pair (s, a).
c	r?	r?
Gπ,M(s,a) =	E	Vπ,M(^0) - E	Vπ,M(s0)	(4.5)
S0 〜c(∙∣s,a)	S 〜M *(Ts,a)
Note that if M, M are deterministic, then Gπ,M(s, a) = Vπ,M(M(s, a)) — Vπ,M(M?(s, a)). We
give a telescoping lemma that decompose the discrepancy between Vπ,M and Vπ,M? into the
expected single-step discrepancy G.
Lemma 4.3. [Telescoping Lemma] Recall that κ := γ(1 - γ)-1. For any policy π and dynamical
models M, Mc, we have that
V π,Mc - Vπ,M = κ E	hGπ,Mc(S, A)i	(4.6)
S〜ρπ,M L	」
A 〜∏(∙∣ S)
The proof is reminiscent of the telescoping expansion in Kakade & Langford (2002) (c.f. Schulman
et al. (2015a)) for characterizing the value difference of two policies, but we apply it to deal
with the discrepancy between models. The detail is deferred to Section B. With the telescoping
Lemma 4.3, Proposition 4.1 follows straightforwardly from Lipschitzness of the imaginary value
function. Proposition 4.2 follows from that ρπ and ρπref are close. We defer the proof to Appendix C.
4.2	Representation-invariant Discrepancy Bounds
The main limitation of the norm-based discrepancy bounds in previous subsection is that it depends
on the state representation. Let T be a one-to-one map from the state space S to some other space S0,
6
Published as a conference paper at ICLR 2019
and for simplicity of this discussion let’s assume a model M is deterministic. Then if we represent
every state s by its transformed representation Ts, then the transformed model MT defined as
MT (s, a) , T M(T -1s, a) together with the transformed reward RT (s, a) , R(T-1s, a) and
transformed policy πT (s) , π(T -1s) is equivalent to the original set of the model, reward, and
policy in terms of the performance (Lemma C.1). Thus such transformation T is not identifiable
from only observing the reward. However, the norm in the state space is a notion that depends on the
hidden choice of the transformation T. 5
Another limitation is that the loss for the model learning should also depend on the state itself instead
Γ∙ 1	.ι t ∙ i`i`	-π^r /CA'	Tl ʃ-i- / ΓA Λ ∖ T. ∙	∙ι ι .t	t	C ♦	.	∙ . ∙ ι	∙ . ∙
of only on the difference M(S, A) - M? (S, A). It is possible that when S is at a critical position,
the prediction error needs to be highly accurate so that the model Mc can be useful for planning. On
the other hand, at other states, the dynamical model is allowed to make bigger mistakes because they
are not essential to the reward.
We propose the following discrepancy bound towards addressing the limitations above. Recall
the definition of Gπ,M (s, a) = Vπ,M(Mc(s, a)) - V π,M (M ?(s, a)) which measures the difference
between Mc(s, a)) and M?(s, a) according to their imaginary rewards. We construct a discrepancy
bound using the absolute value of G. Let's define ει and εmaχ as the average of ∣Gπ,M| and
its maximum: ει = ES〜Pnrefh∣Gπ,M(5")|] andεmaχ = maxs ∣Gπ,M(S)I where Gπ,M(S)=
EA〜∏ [gπ,m(S, A)]. We will show that the following discrepancy bound DGef (M, ∏) satisfies the
property (R1), (R2).
DGef (M, π) = K ∙ ει + κ2δεmaχ	(4.7)
Proposition 4.4. Let dKL and DG be defined as in equation (4.3) and (4.7). Then the choice d = dKL
and D = DG satisfies the basic requirements (equation (R1) and (R2)). Moreover, G is invariant
w.r.t any one-to-one transformation of the state space (in the sense of equation C.1 in the proof).
The proof follows from the telescoping lemma (Lemma 4.3) and is deferred to Section C. We
remark that the first term κε1 can in principle be estimated and optimized approximately: the
expectation be replaced by empirical samples from ρπref, and Gπ,M is an analytical function of π and
—
M when they are both deterministic, and therefore can be optimized by back-propagation through
time (BPTT). (When π and Mc and
are stochastic with a re-parameterizable noise such as Gaussian
distribution Kingma & Welling (2013), we can also use back-propagation to estimate the gradient.)
The second term in equation (4.7) is difficult to optimize because it involves the maximum. However,
it can be in theory considered as a second-order term because δ can be chosen to be a fairly small
number. (In the refined bound in Section A, the dependency on δ is even milder.)
Remark 4.5. Proposition 4.4 intuitively suggests a technical reason of why model-based approach
can be more sample-efficient than policy gradient based algorithms such as TRPO or PPO (Schulman
et al., 2015a; 2017). The approximation error of Vπ,M in model-based approach decreases as the
model error ε1 , εmax decrease or the neighborhood size δ decreases, whereas the approximation error
in policy gradient only linearly depends on the the neighborhood size Schulman et al. (2015a). In
other words, model-based algorithms can trade model accuracy for a larger neighborhood size, and
therefore the convergence can be faster (in terms of outer iterations.) This is consistent with our
empirical observation that the model can be accurate in a descent neighborhood of the current policy
so that the constraint (3.4) can be empirically dropped. We also refine our bonds in Section A, where
the discrepancy bounds is proved to decay faster in δ.
5	Additional Related work
Model-based reinforcement learning is expected to require fewer samples than model-free algo-
rithms (Deisenroth et al., 2013) and has been successfully applied to robotics in both simulation and
in the real world (Deisenroth & Rasmussen, 2011b; Morimoto & Atkeson, 2003; Deisenroth et al.,
2011) using dynamical models ranging from Gaussian process (Deisenroth & Rasmussen, 2011b; Ko
5That said, in many cases the reward function itself is known, and the states have physical meanings, and
therefore we may be able to use the domain knowledge to figure out the best norm.
7
Published as a conference paper at ICLR 2019
&	Fox, 2009), time-varying linear models (Levine & Koltun, 2013; Lioutikov et al., 2014; Levine &
Abbeel, 2014; Yip & Camarillo, 2014), mixture of Gaussians (Khansari-Zadeh & Billard, 2011), to
neural networks (Hunt et al., 1992; Nagabandi et al., 2017; Kurutach et al., 2018; Tangkaratt et al.,
2014; Sanchez-Gonzalez et al., 2018; Pascanu et al., 2017). In particular, the work of Kurutach et al.
(2018) uses an ensemble of neural networks to learn the dynamical model, and significantly reduces
the sample complexity compared to model-free approaches. The work of Chua et al. (2018) makes
further improvement by using a probabilistic model ensemble. Clavera et al. (Clavera et al., 2018)
extended this method with meta-policy optimization and improve the robustness to model error. In
contrast, we focus on theoretical understanding of model-based RL and the design of new algorithms,
and our experiments use a single neural network to estimate the dynamical model.
Our discrepancy bound in Section 4 is closely related to the work (Farahmand et al., 2017) on the
value-aware model loss. Our approach differs from it in three details: a) we use the absolute value
of the value difference instead of the squared difference; b) we use the imaginary value function
from the estimated dynamical model to define the loss, which makes the loss purely a function of the
estimated model and the policy; c) we show that the iterative algorithm, using the loss function as a
building block, can converge to a local maximum, partly by cause of the particular choices made in a)
and b). Asadi et al. (2018) also study the discrepancy bounds under Lipschitz condition of the MDP.
Prior work explores a variety of ways of combining model-free and model-based ideas to achieve
the best of the two methods (SUtton,1991; 1990; Racaniere et al., 2017; Mordatch et al., 2016; SUn
et al., 2018). For example, estimated models (Levine & Koltun, 2013; Gu et al., 2016; Kalweit &
Boedecker, 2017) are Used to enrich the replay bUffer in the model-free off-policy RL. Pong et al.
(2018b) proposes goal-conditioned valUe fUnctions trained by model-free algorithms and Uses it
for model-based controls. Feinberg et al. (2018); BUckman et al. (2018) Use dynamical models to
improve the estimation of the valUe fUnctions in the model-free algorithms.
On the control theory side, Dean et al. (2018; 2017) provide strong finite sample complexity boUnds
for solving linear qUadratic regUlator Using model-based approach. Boczar et al. (2018) provide finite-
data gUarantees for the “coarse-ID control” pipeline, which is composed of a system identification
step followed by a robUst controller synthesis procedUre. OUr method is inspired by the general idea
of maximizing a low boUnd of the reward in (Dean et al., 2017). By contrast, oUr work applies to
non-linear dynamical systems. OUr algorithms also estimate the models iteratively based on trajectory
samples from the learned policies.
Strong model-based and model-free sample complexity boUnds have been achieved in the tabUlar
case (finite state space). We refer the readers to (Kakade et al., 2018; Dann et al., 2017; Szita &
Szepesvari, 2010; Kearns & Singh, 2002; Jaksch et al., 2010; Agrawal & Jia, 2017) and the reference
therein. OUr work focUs on continUoUs and high-dimensional state space (thoUgh the resUlts also
apply to tabUlar case).
Another line of work of model-based reinforcement learning is to learn a dynamic model in a hidden
representation space, which is especially necessary for pixel state spaces (Kakade et al., 2018; Dann
et al., 2017; Szita & Szepesvari, 2010; Kearns & Singh, 2002; Jaksch et al., 2010). Srinivas et al.
(2018) shows the possibility to learn an abstract transition model to imitate expert policy. Oh et al.
(2017) learns the hidden state ofa dynamical model to predict the valUe of the fUtUre states and applies
RL or planning on top of it. Serban et al. (2018); Ha & SchmidhUber (2018) learns a bottleneck
representation of the states. OUr framework can be potentially combined with this line of research.
6	Practical Implementation and Experiments
6.1	Practical implementation
We design with simplification of oUr framework a variant of model-based RL algorithms, Stochastic
Lower BoUnd Optimization (SLBO). First, we removed the constraints (3.4). Second, we stop the
gradient w.r.t M (bUt not π) from the occUrrence of M in Vπ,M in eqUation (3.3) (and thUs oUr
practical implementation is not optimism-driven.)
Extending the discrepancy boUnd in Section 4.1, we Use a mUlti-step prediction loss for learning the
models with '2 norm. For a state St and action sequence at：t+h, we define the h-step prediction ^t+h
8
Published as a conference paper at ICLR 2019
as St = st, and for h ≥ 0, ^t+h+ι = Mφ(^t+h, at+h), The H-step loss is then defined as
(H)	1 H
Lφ ((st:t+h, at:t+h)； φ) = H ɪ2 k(st+i - st+i-1) - (st+i - st+i-l)k2∙
(6.1)
i=1
A similar loss is also used in Nagabandi et al. (2017) for validation. We note that motivation by the
theory in Section 4.1, We use '2-norm instead of the square of '2 norm. The loss function We attempt
to optimize at iteration k is thus6
max Vπθ,sg(cφ) - λ	E	[LφH)((st"+h, at:t+h);
φ,θ	(St：t+h ,at：t+h)~nk,M? L
Where λ is a tunable parameter and sg denotes the stop gradient operation.
，‹≈∙,
(6.2)
c
We note that the term V πθ ,sg(Mφ) depends on both the parameter θ and the parameter φ but there
is no gradient passed through φ, Whereas L(φH) only depends on the φ. We optimize equation (6.2)
by alternatively maximizing V πθ,sg(Mφ) and minimizing L(φH): for the former, We use TRPO With
samples from the estimated dynamical model Mφ (by treating Mφ as a fixed simulator), and for
the latter We use standard stochastic gradient methods. Algorithm 2 gives a pseudo-code for the
algorithm. The nmodel and npolicy iterations are used to balance the number of steps of TRPO and
Adam updates Within the loop indexed by ninner.7
Algorithm 2 Stochastic Lower Bound Optimization (SLBO)
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
Initialize model network parameters φ and policy network parameters θ
Initialize dataset D - 0
for nouter iterations do
D - D ∪ { collect ncollect samples from real environment using πθ with noises }
for ninner iterations do
for nmodel iterations do
. optimize (6.2) with stochastic alternating updates
optimize (6.1) over φ With sampled data from D by one step of Adam
for npolicy iterations do
D0 - { collect ntrpo samples using Mcφ as dynamics }
optimize πθ by running TRPO on D0
Power of stochasticity and connection to standard MB RL: We identify the main advantage of
our algorithms over standard model-based RL algorithms is that We alternate the updates of the model
and the policy Within an outer iteration. By contrast, most of the existing model-based RL methods
only optimize the models once (for a lot of steps) after collecting a batch of samples (see Algorithm
3 for an example). The stochasticity introduced from the alternation With stochastic samples seems to
dramatically reduce the overfitting (of the policy to the estimated dynamical model) in a Way similar
to that SGD regularizes ordinary supervised training. 8 Another Way to vieW the algorithm is that
the model obtained from line 7 of Algorithm 2 at different inner iteration serves as an ensemble of
models. We do believe that a cleaner and easier instantiation of our frameWork (With optimism) exists,
and the current version, though performing very Well, is not necessarily the best implementation.
Entropy regularization: An additional component We apply to SLBO is the commonly-adopted
entropy regularization in policy gradient method (Williams & Peng, 1991; Mnih et al., 2016), Which
Was found to significantly boost the performance in our experiments (ablation study in Appendix F.5).
Specifically, an additional entropy term is added to the objective function in TRPO. We hypothesize
that entropy bonus helps exploration, diversifies the collected data, and thus prevents overfitting.
6This is technically not a Well-defined mathematical objective. The sg operation means identity When the
function is evaluated, Whereas When computing the update, sg(Mφ) is considered fixed.
7In principle, to balance the number of steps, it suffices to take one of nmodel and npolicy to be 1. HoWever,
empirically We found the optimal balance is achieved With larger nmodel and npolicy , possibly due to complicated
interactions betWeen the tWo optimization problem.
8Similar stochasticity can potentially be obtained by an extreme hyperparameter choice of the standard MB
RL algorithm: in each outer iteration of Algorithm 3, We only sample a very small number of trajectories and
take a feW model updates and policy updates. We argue our interpretation of stochastic optimization of the loWer
bound (6.2) is more natural in that it reveals the regularization from stochastic optimization.
9
Published as a conference paper at ICLR 2019
6.2 Experimental Results
We evaluate our algorithm SLBO (Algorithm 2) on five continuous control tasks from rllab (Duan
et al., 2016), including Swimmer, Half Cheetah, Humanoid, Ant, Walker. All environments that we
test have a maximum horizon of 500, which is longer than most of the existing model-based RL work
(Nagabandi et al., 2017; Kurutach et al., 2018). (Environments with longer horizons are commonly
harder to train.) More details can be found in Appendix F.1.
Baselines. We compare our algorithm with 3 other algorithms including: (1) Soft Actor-Critic (SAC)
(Haarnoja et al., 2018), the state-of-the-art model-free off-policy algorithm in sample efficiency;
(2) Trust-Region Policy Optimization (TRPO) (Schulman et al., 2015a), a policy-gradient based
algorithm; and (3) Model-Based TRPO, a standard model-based algorithm described in Algorithm 3.
Details of these algorithms can be found in Appendix F.4.9
The result is shown in Figure 1. In Fig 1, our algorithm shows superior convergence rate (in number of
samples) than all the baseline algorithms while achieving better final performance with 1M samples.
Specifically, we mark model-free TRPO performance after 8 million steps by the dotted line in Fig 1
and find out that our algorithm can achieve comparable or better final performance in one million
steps. For ablation study, we also add the performance of SLBO-MSE, which corresponds to running
SLBO with squared `2 model loss instead of `2 . SLBO-MSE performs significantly worse than
SLBO on four environments, which is consistent with our derived model loss in Section 4.1. We also
study the performance of SLBO and baselines with 4 million training samples in F.5. Ablation study
of multi-step model training can be found in Appendix F.5.10
120
100
⅛ 80
S
gι 60
I 40
4 20
0
OQ 62	0.4	66	0.8
# samples (million)
UJnsh∙,6bjsλv
# samples (million)
0.0	0.2	0.4	0.6	0.θ	1.0
# samples (million)
(a) Swimmer	(b) Half Cheetah	(c) Ant
E3Mvtf aβMJSΛV
(d) Walker	(e) Humanoid
—— SLBO	SLBO-MSE — MB-TRPO —— SAC	MF-TRPO
Figure 1: Comparison between SLBO (ours), SLBO with squared `2 model loss (SLBO-MSE),
vanilla model-based TRPO (MB-TRPO), model-free TRPO (MF-TRPO), and Soft Actor-Critic
(SAC). We average the results over 10 different random seeds, where the solid lines indicate the mean
and shaded areas indicate one standard deviation. The dotted reference lines are the total rewards of
MF-TRPO after 8 million steps.
7 Conclusions
We devise a novel algorithmic framework for designing and analyzing model-based RL algorithms
with the guarantee to convergence monotonically to a local maximum of the reward. Experimental
results show that our proposed algorithm (SLBO) achieves new state-of-the-art performance on
several mujoco benchmark tasks when one million or fewer samples are permitted.
9We did not have the chance to implement the competitive random search algorithms in (Mania et al., 2018)
yet, although our test performance with 500 episode length is higher than theirs with 1000 episode on Half
Cheetach (3950 by ours vs 2345 by theirs) and Walker (3650 by ours vs 894 by theirs).
10Videos demonstrations are available at https://sites.google.com/view/algombrl/home. A link to the codebase
is available at https://github.com/roosephu/slbo.
10
Published as a conference paper at ICLR 2019
A compelling (but obvious) empirical open question then given rise to is whether model-based
RL can achieve near-optimal reward on other more complicated tasks or real-world robotic tasks
with fewer samples. We believe that understanding the trade-off between optimism and robustness
is essential to design more sample-efficient algorithms. Currently, we observed empirically that
the optimism-driven part of our proposed meta-algorithm (optimizing V π,M over Mc) may lead to
instability in the optimization, and therefore don’t in general help the performance. It’s left for future
work to find practical implementation of the optimism-driven approach.
In our theory, we assume that the parameterized model class contains the true dynamical model.
Removing this assumption is also another interesting open question. It would be also very interesting
if the theoretical analysis can be applied other settings involving model-based approaches (e.g.,
model-based imitation learning).
Acknowledgments:
We thank the anonymous reviewers for detailed, thoughtful, and helpful reviews. We’d like to thank
Emma Brunskill, Chelsea Finn, Shane Gu, Ben Recht, and Haoran Tang for many helpful comments
and discussions.
References
Yasin Abbasi-Yadkori and Csaba Szepesvdri. Regret bounds for the adaptive control of linear quadratic systems.
In Proceedings of the 24th Annual Conference on Learning Theory, pp. 1-26, 2011.
Joshua Achiam, David Held, Aviv Tamar, and Pieter Abbeel. Constrained policy optimization. arXiv preprint
arXiv:1705.10528, 2017.
Shipra Agrawal and Randy Jia. Optimistic posterior sampling for reinforcement learning: worst-case regret
bounds. In Advances in Neural Information Processing Systems, pp. 1184-1194, 2017.
Kavosh Asadi, Dipendra Misra, and Michael L Littman. Lipschitz continuity in model-based reinforcement
learning. arXiv preprint arXiv:1804.07193, 2018.
Peter L Bartlett and Ambuj Tewari. Regal: A regularization based algorithm for reinforcement learning in
weakly communicating mdps. In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial
Intelligence, pp. 35-42. AUAI Press, 2009.
Ross Boczar, Nikolai Matni, and Benjamin Recht. Finite-data performance guarantees for the output-feedback
control of an unknown system. arXiv preprint arXiv:1803.09186, 2018.
J. Buckman, D. Hafner, G. Tucker, E. Brevdo, and H. Lee. Sample-Efficient Reinforcement Learning with
Stochastic Ensemble Value Expansion. ArXive-prints, July 2018.
Kurtland Chua, Roberto Calandra, Rowan McAllister, and Sergey Levine. Deep reinforcement learning in a
handful of trials using probabilistic dynamics models. arXiv preprint arXiv:1805.12114, 2018.
Ignasi Clavera, Jonas Rothfuss, John Schulman, Yasuhiro Fujita, Tamim Asfour, and Pieter Abbeel. Model-based
reinforcement learning via meta-policy optimization. arXiv preprint arXiv:1809.05214, 2018.
Thomas M Cover and Joy A Thomas. Elements of information theory. John Wiley & Sons, 2012.
Christoph Dann, Tor Lattimore, and Emma Brunskill. Unifying pac and regret: Uniform pac bounds for episodic
reinforcement learning. In Advances in Neural Information Processing Systems, pp. 5713-5723, 2017.
Sarah Dean, Horia Mania, Nikolai Matni, Benjamin Recht, and Stephen Tu. On the sample complexity of the
linear quadratic regulator. arXiv preprint arXiv:1710.01688, 2017.
Sarah Dean, Horia Mania, Nikolai Matni, Benjamin Recht, and Stephen Tu. Regret bounds for robust adaptive
control of the linear quadratic regulator. arXiv preprint arXiv:1805.09388, 2018.
Marc Deisenroth and Carl E Rasmussen. Pilco: A model-based and data-efficient approach to policy search. In
Proceedings of the 28th International Conference on machine learning (ICML-11), pp. 465-472, 2011a.
Marc Deisenroth and Carl E Rasmussen. Pilco: A model-based and data-efficient approach to policy search. In
Proceedings of the 28th International Conference on machine learning (ICML-11), pp. 465-472, 2011b.
Marc Peter Deisenroth, Carl Edward Rasmussen, and Dieter Fox. Learning to control a low-cost manipulator
using data-efficient reinforcement learning. 2011.
11
Published as a conference paper at ICLR 2019
Marc Peter Deisenroth, Gerhard Neumann, Jan Peters, et al. A survey on policy search for robotics. Foundations
and Trends® in Robotics, 2(1-2):1-142, 2013.
Yan Duan, Xi Chen, Rein Houthooft, John Schulman, and Pieter Abbeel. Benchmarking deep reinforcement
learning for continuous control. In International Conference on Machine Learning, pp. 1329-1338, 2016.
Amir-massoud Farahmand, Andre Barreto, and Daniel Nikovski. Value-aware loss function for model-based
reinforcement learning. In Artificial Intelligence and Statistics, pp. 1486-1494, 2017.
Vladimir Feinberg, Alvin Wan, Ion Stoica, Michael I Jordan, Joseph E Gonzalez, and Sergey Levine. Model-
based value estimation for efficient model-free reinforcement learning. arXiv preprint arXiv:1803.00101,
2018.
Ronan Fruit, Matteo Pirotta, Alessandro Lazaric, and Ronald Ortner. Efficient bias-span-constrained exploration-
exploitation in reinforcement learning. arXiv preprint arXiv:1802.04020, 2018.
Shixiang Gu, Timothy Lillicrap, Ilya Sutskever, and Sergey Levine. Continuous deep q-learning with model-
based acceleration. In International Conference on Machine Learning, pp. 2829-2838, 2016.
David Ha and Jurgen Schmidhuber. World models. arXivpreprint arXiv:1803.10122, 2018.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maximum
entropy deep reinforcement learning with a stochastic actor. arXiv preprint arXiv:1801.01290, 2018.
Karl Hinderer. Lipschitz continuity of value functions in markovian decision processes. Mathematical Methods
of Operations Research, 62(1):3-22, 2005.
K Jetal Hunt, D Sbarbaro, R Zbikowski, and Peter J Gawthrop. Neural networks for control systems—a survey.
Automatica, 28(6):1083-1112, 1992.
Thomas Jaksch, Ronald Ortner, and Peter Auer. Near-optimal regret bounds for reinforcement learning. Journal
of Machine Learning Research, 11(Apr):1563-1600, 2010.
S. Kakade, M. Wang, and L. F. Yang. Variance Reduction Methods for Sublinear Reinforcement Learning.
ArXiv e-prints, February 2018.
Sham Kakade and John Langford. Approximately optimal approximate reinforcement learning. In ICML,
volume 2, pp. 267-274, 2002.
Gabriel Kalweit and Joschka Boedecker. Uncertainty-driven imagination for continuous deep reinforcement
learning. In Conference on Robot Learning, pp. 195-206, 2017.
Michael Kearns and Satinder Singh. Near-optimal reinforcement learning in polynomial time. Machine learning,
49(2-3):209-232, 2002.
S Mohammad Khansari-Zadeh and Aude Billard. Learning stable nonlinear dynamical systems with gaussian
mixture models. IEEE Transactions on Robotics, 27(5):943-957, 2011.
Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.
Jonathan Ko and Dieter Fox. Gp-bayesfilters: Bayesian filtering using gaussian process prediction and observa-
tion models. Autonomous Robots, 27(1):75-90, 2009.
Thanard Kurutach, Ignasi Clavera, Yan Duan, Aviv Tamar, and Pieter Abbeel. Model-ensemble trust-region
policy optimization. arXiv preprint arXiv:1802.10592, 2018.
Kailasam Lakshmanan, Ronald Ortner, and Daniil Ryabko. Improved regret bounds for undiscounted continuous
reinforcement learning. In International Conference on Machine Learning, pp. 524-532, 2015.
Sergey Levine and Pieter Abbeel. Learning neural network policies with guided policy search under unknown
dynamics. In Advances in Neural Information Processing Systems, pp. 1071-1079, 2014.
Sergey Levine and Vladlen Koltun. Guided policy search. In International Conference on Machine Learning,
pp. 1-9, 2013.
Sergey Levine, Chelsea Finn, Trevor Darrell, and Pieter Abbeel. End-to-end training of deep visuomotor policies.
The Journal of Machine Learning Research, 17(1):1334-1373, 2016.
12
Published as a conference paper at ICLR 2019
Timothy P Lillicrap, Jonathan J Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver,
and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971,
2015.
Rudolf Lioutikov, Alexandros Paraschos, Jan Peters, and Gerhard Neumann. Sample-based informationl-theoretic
stochastic optimal control. In Robotics and Automation (ICRA), 2014 IEEE International Conference on, pp.
3896-3902. IEEE, 2014.
Horia Mania, Aurelia Guy, and Benjamin Recht. Simple random search provides a competitive approach to
reinforcement learning. arXiv preprint arXiv:1803.07055, 2018.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare, Alex
Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control through deep
reinforcement learning. Nature, 518(7540):529, 2015.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim Harley, David
Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement learning. In International
conference on machine learning, pp. 1928-1937, 2016.
Teodor Mihai Moldovan, Sergey Levine, Michael I Jordan, and Pieter Abbeel. Optimism-driven exploration
for nonlinear systems. In Robotics and Automation (ICRA), 2015 IEEE International Conference on, pp.
3239-3246. IEEE, 2015.
Igor Mordatch, Nikhil Mishra, Clemens Eppner, and Pieter Abbeel. Combining model-based pol-
icy search with online model learning for control of physical humanoids. In RoboticsandAutoma-
tion(ICRA),2016IEEEInternationalConferenceon, pp. 242-248. IEEE, 2016.
Jun Morimoto and Christopher G Atkeson. Minimax differential dynamic programming: An application to
robust biped walking. In Advances in neural information processing systems, pp. 1563-1570, 2003.
Anusha Nagabandi, Gregory Kahn, Ronald S Fearing, and Sergey Levine. Neural network dynamics for
model-based deep reinforcement learning with model-free fine-tuning. arXiv preprint arXiv:1708.02596,
2017.
Frank Nielsen and Richard Nock. On the chi square and higher-order chi distances for approximating f-
divergences. IEEE Signal Processing Letters, 21(1):10-13, 2014.
Junhyuk Oh, Satinder Singh, and Honglak Lee. Value prediction network. In Advances in NeuralInformation-
ProcessingSystems, pp. 6118-6128, 2017.
Razvan Pascanu, Yujia Li, Oriol Vinyals, Nicolas Heess, Lars Buesing, Sebastien Racan论re, David Reichert,
ThCophane Weber, Daan Wierstra, and Peter Battaglia. Learning model-based planning from scratch. arXiv
preprint arXiv:1707.06170, 2017.
Deepak Pathak, Parsa Mahmoudieh, Guanghao Luo, Pulkit Agrawal, Dian Chen, Yide Shentu, Evan Shelhamer,
Jitendra Malik, Alexei A Efros, and Trevor Darrell. Zero-shot visual imitation. In International Conference
on Learning Representations, 2018.
Matteo Pirotta, Marcello Restelli, and Luca Bascetta. Adaptive step-size for policy gradient methods. In
Advances in Neural Information Processing Systems, pp. 1394-1402, 2013.
Matteo Pirotta, Marcello Restelli, and Luca Bascetta. Policy gradient in lipschitz markov decision processes.
Machine Learning, 100(2-3):255-283, 2015.
Vitchyr Pong, Shixiang Gu, Murtaza Dalal, and Sergey Levine. Temporal difference models: Model-free deep rl
for model-based control. arXiv preprint arXiv:1802.09081, 2018a.
Vitchyr Pong, Shixiang Gu, Murtaza Dalal, and Sergey Levine. Temporal difference models: Model-free deep rl
for model-based control. International Conference on Learning Representations, 2018b.
SCbastien RacaniBre, ThCophane Weber, David Reichert, Lars Buesing, Arthur Guez, Danilo Jimenez Rezende,
Adr论 PUigdOmeneCh Badia, Oriol Vinyals, Nicolas Heess, Yujia Li, et al. Imagination-augmented agents for
deep reinforcement learning. In AdvancesinNeuralInformationProcessingSystems, pp. 5690-5701, 2017.
Alvaro Sanchez-Gonzalez, Nicolas Heess, Jost Tobias Springenberg, Josh Merel, Martin Riedmiller, Raia
Hadsell, and Peter Battaglia. Graph networks as learnable physics engines for inference and control. arXiv
preprint arXiv:1806.01242, 2018.
13
Published as a conference paper at ICLR 2019
Igal Sason and Sergio Verdd. f -divergence inequalities. IEEE Transactions on Information Theory, 62(11):
5973-6006, 2016.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region policy
optimization. In International Conference on Machine Learning, pp. 1889-1897, 2015a.
John Schulman, Philipp Moritz, Sergey Levine, Michael Jordan, and Pieter Abbeel. High-dimensional continuous
control using generalized advantage estimation. arXiv preprint arXiv:1506.02438, 2015b.
John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization
algorithms. arXiv preprint arXiv:1707.06347, 2017.
Iulian Vlad Serban, Chinnadhurai Sankar, Michael Pieper, Joelle Pineau, and Yoshua Bengio. The bottleneck
simulator: A model-based deep reinforcement learning approach. arXiv preprint arXiv:1807.04723, 2018.
David Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur Guez, Thomas
Hubert, Lucas Baker, Matthew Lai, Adrian Bolton, et al. Mastering the game of go without human knowledge.
Nature, 550(7676):354, 2017.
Max Simchowitz, Horia Mania, Stephen Tu, Michael I Jordan, and Benjamin Recht. Learning without mixing:
Towards a sharp analysis of linear system identification. arXiv preprint arXiv:1802.08334, 2018.
Aravind Srinivas, Allan Jabri, Pieter Abbeel, Sergey Levine, and Chelsea Finn. Universal planning networks.
arXiv preprint arXiv:1804.00645, 2018.
Wen Sun, Geoffrey J Gordon, Byron Boots, and J Andrew Bagnell. Dual policy iteration. arXiv preprint
arXiv:1805.10755, 2018.
Richard S Sutton. Integrated architectures for learning, planning, and reacting based on approximating dynamic
programming. In Machine Learning Proceedings 1990, pp. 216-224. Elsevier, 1990.
Richard S Sutton. Dyna, an integrated architecture for learning, planning, and reacting. ACM SIGART Bulletin,
2(4):160-163, 1991.
Richard S Sutton, Csaba Szepesvdri, Alborz Geramifard, and Michael P Bowling. Dyna-Style planning With
linear function approximation and prioritized sweeping. arXiv preprint arXiv:1206.3285, 2012.
Istvdn Szita and Csaba Szepesvdri. Model-based reinforcement learning with nearly tight exploration complexity
bounds. In Proceedings of the 27th International Conference on Machine Learning (ICML-10), pp. 1031-1038,
2010.
Aviv Tamar, Dotan Di Castro, and Ron Meir. Integrating a partial model into model free reinforcement learning.
Journal of Machine Learning Research, 13(Jun):1927-1966, 2012.
Voot Tangkaratt, Syogo Mori, Tingting Zhao, Jun Morimoto, and Masashi Sugiyama. Model-based policy
gradients with parameter-based exploration by least-squares conditional density estimation. Neural networks,
57:128-140, 2014.
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control. In Intelligent
Robots and Systems (IROS), 2012 IEEE/RSJ International Conference on, pp. 5026-5033. IEEE, 2012.
Ronald J Williams and Jing Peng. Function optimization using connectionist reinforcement learning algorithms.
Connection Science, 3(3):241-268, 1991.
Chris Xie, Sachin Patil, Teodor Moldovan, Sergey Levine, and Pieter Abbeel. Model-based reinforcement
learning with parametrized physical models and optimism-driven exploration. In 2016 IEEE International
Conference on Robotics and Automation (ICRA), pp. 504-511. IEEE, 2016.
Michael C Yip and David B Camarillo. Model-less feedback control of continuum manipulators in constrained
environments. IEEE Transactions on Robotics, 30(4):880-889, 2014.
14
Published as a conference paper at ICLR 2019
A Refined bounds
G
The theoretical limitation of the discrepancy bound DG(M, π) is that the second term involving εmax
is not rigorously optimizable by stochastic samples. In the worst case, there seem to exist situations
where such infinity norm of Gπ,M is inevitable. In this section we tighten the discrepancy bounds
with a different closeness measure d, χ2-divergence, in the policy space, and the dependency on the
εmax is smaller (though not entirely removed.) We note that χ2-divergence has the same second order
approximation as KL-divergence around the local neighborhood the reference policy and thus locally
affects the optimization much.
We start by defining a re-weighted version βπ of the distribution ρπ where examples in later step are
slightly weighted up. We can effectively sample from βπ by importance sampling from ρπ
Definition A.1. For a policy π, define βπ as the re-weighted version of discounted distribution of
the states visited by π on M? . Recall that pSπ is the distribution of the state at step t, we define
βπ = (1-γ)2Pt∞=1tγt-1pStπ.
Then we are ready to state our discrepancy bound. Let
dχ2 (∏,∏ref) = max{ E	[χ2(∏(∙∣S), ∏ref(∙∣S))] , E	[χ2(∏(∙∣S),∏ref(∙∣S))]}	(A.1)
S 〜Pntef	S 〜βπref
DXf (Mc, ∏) = (1 - γ)-1ει + (1- γ)-2δε2 + (1- Y)-5/263/2£max	(A.2)
where ε = ES〜β∏ref [gπ,m(S, A)2] and ει,εmaχ are defined in equation (4.2).
Proposition A.2. The discrepancy bound Dχ2 and closeness measure dχ2 satisfies requirements
(R1) and (R2).
We defer the proof to Section C so that we can group relevant proofs with similar tools together.
Some of these tools may be of independent interests and used for better analysis of model-free
reinforcement learning algorithms such as TRPO Schulman et al. (2015a), PPO Schulman et al.
(2017) and CPO Achiam et al. (2017).
B Proof of Lemma 4.3
Proof of Lemma 4.3. Let Wj be the cumulative reward when we use dynamical model M for j steps
and then Mc for the rest of the steps, that is,
Wj =	E
∀t≥0,At 〜π(∙∣St)
∀j>t≥0,St+ι 〜M (∙∣St,At)
∀t≥j,St+ι 〜c(∙∣St,At)
∞
X γtR(St, At) | S0=s
t=0
c
By definition, we have that W∞ = V π,M(s) and W0 = Vπ,M(s). Then, we decompose the target
into a telescoping sum,
∞
Vπ,M(s)-Vπ,Mc(s)=	(Wj+1-Wj)
j=0
(B.1)
Now we re-write each of the summands Wj+1 - Wj . Comparing the trajectory dis-
tribution in the definition of Wj+1 and Wj , we see that they only differ in the dy-
namical model applied in j -th step. Concretely, Wj and Wj +1 can be rewritten
as Wj	=
ESj,Aj 〜π,M ?
R + ESj,Aj 〜π,M
底+1 〜C(∙∣Sj,Aj) [Yj+1Vπ,c(Sj+ι)]] and Wj+ι = R +
ESj+
1〜M(∙∣Sj,Aj )
γj+1V π,Mc(Sj+1)
where R denotes the reward from the first j
steps from policy π and model M ? . Canceling the shared term in the two equations above, we get
Wj+1
- Wj = Yj +1	E
Sj ,Aj〜π,M
E
fS,j + ι^M(∙lSj ,Aj)
Sj + 1 〜M (∙∣Sj,Aj)
V π,Mc(Sj+1) - V π,Mc(Sbj+1)
15
Published as a conference paper at ICLR 2019
Combining the equation above with equation (B.1) concludes that
Vπ,M - Vπ,c = -ɪ E	E	Vπ,c(S0) - E	Vπ,c(S0)
1 - Y S~Pπ,A~∏(S) [S0~M?(，|S,A)	So〜C(∙∣S,A)
□
C Missing Proofs in Section 4
C.1 Proof of Proposition 4.4
Towards proving the second part of Proposition 4.4 regarding the invariance, we state the following
lemma:
Lemma C.1. Suppose for simplicity the model and the policy are both deterministic. For any one-
to-one transformation from S to S0, let MT (s, a) , T M(T -1s, a), RT (s, a) , R(T -1s, a), and
πT (s) , π(T -1s) be a set of transformed model, reward and policy. Then we have that (M, π, R)
is equivalent to (MT , πT , RT ) in the sense that
VπT,MT(Ts)=Vπ,M(s)
where the value function VπT ,MT is defined with respect to RT .
Proof. Let s0T = Ts, . . . , be the sequence of states visited by policy πT on model MT starting from
s. We have that s0T = Ts = Ts0 . We prove by induction that stT = Tst. Assume this is true for
some value t, then we prove that st+1 T = T st+1 holds:
stT+1 = MT (stT , πT (stT )) = MT (T st, πT (Tst))	(by inductive hypothesis)
= TM(st, π(st))	(by defintion of MT , πT )
= T st+1
Thus We have RT(ST, aT) = R(st, at). Therefore VπT,MT(TS) = Vπ,M(s).	□
Proof of Proposition 4.4. We first show the invariant of G under deterministic models and policies.
The same result applies to stochastic policies With slight modification. Let ST = TS. We consider
the transformation applied to M and M ? and the resulting G function
GT(sT,a)，|VπT,MT(MT(ST, a)) - VπT,MT(M?,T(ST, a))|
Note that by Lemma C.1, We have that VπT,MT (MT(ST, a)) = Vπ,M(T-1MT(ST, a)) =
Vπ,M (M(S, a)). Similarly, VπT,MT (M?,T(ST, a)) = V π,M (M ?(S, a)). Therefore We obtain
that
GT(ST, a) = G(S, a)	(C.1)
By Lemma 4.3 and triangle inequality, We have that
1——Y ∣Vπ,M - Vπ,M∣ ≤ E h∣Gπ,M(S)∣i	(triangleinequality)
≤ S E. t h∣Gπ,c(S)∣i + Iρπ - ρπref∣ι ∙ max∣Gπ,c(S)∣
(Holder inequality)
By Corollary E.7 We have that ∣ρπ - ρπref∣ι ≤ I-Y ES〜ρ∏ref [KL(π(S),∏ref(S))1∕2∣S] = ιδγγ.
Combining this with the equation above, we complete the proof.	□
16
Published as a conference paper at ICLR 2019
C.2 Proof of Proof of Proposition A.2
Proofof Proposition A.2. Let μ be the distribution of the initial state So, and let P0 and P be
the state-to-state transition kernel under policy ∏ and ∏ref. Let GG = (1 - Y) P∞=0 YkPk and
GG0 = (1 - Y) P∞=o γkP0k. Under these notations, We can re-write Pnref = GGμ and ρπ = GG0μ.
Moreover, we observe that βπref = GPGμ.
Let δι = (1 - γ)-1χGμ(P0,P)1/2 and δ2 = (1 - Y)TXGPG*(P0,P)1/2 by the χ2 divergence
between P0 and P, measured with respect to distributions Gμ = Pnref and GPGμ = βπref. By
Lemma D.1, we have that the χ2-divergence between the states can be bounded by the χ2-divergence
between the actions in the sense that:
χGμ(P0,P )1/2 = χP∏ref (P ,P 中/ ≤
xGpGμ(P,P )1/2 = Xβ∏ref T, P )e ≤
E	[χ2(∏(∙∣S),∏ref(∙∣S))]
S 〜ρπref
E	[χ2(∏(∙∣S),∏ref(∙∣S))]
S 〜βπref
1/2
1/2
Therefore we obtain that δ1 ≤ (1 - Y)-1δ, δ2 ≤ (1 - Y)-1δ. Let f(s) = Gn,M (s). By Lemma D.4,
we can control the difference between hPnref, fi and hPn, fi by
Eπ	Gn,Mc(S) - E Gn,Mc(S)	= |hPnref, f i - hPn,fi|
≤ δ1hGPGμ, f2i1/2 + δ1δ2∕2kfk∞
≤ δ1ε2 + δ1δ2/ εmax
It follows that
V n,Mc - V n,M ≤ Y(1 - Y)-1
≤ Y(1 - Y)-1
≤ Y(1 - Y)-1
≤ (1 - γ)-1ε1 + (1 - γ)-2δε2 + (1 - γ)-5∕2δ3∕2εmaχ
□
E Gn,Mc(S)
S〜Pnref L	」
E
S〜Pnref
(by Lemma 4.3)
E
S 〜Pntef
Gn,Mc(S) - E
S〜Pn
hGn,Mc(S)i
[Gn,c(S)] + Y(1 - γ)-1δ1ε2 + γ(1 - γ)-1 S1s1&max
+
C.3 Proof of Proposition 4.1 and 4.2
Proof of Proposition 4.1 and 4.2 . By definition of G and the Lipschitzness of V n,M , we have that
|Gn,M (s, a)| ≤ L|Mc(s, a) - M?(s, a)|. Then, by Lemma 4.3 and triangle inequality, we have that
IV n，c - Vn，M ?| = K ∙ I E [Gn,c(S,A)i I ≤ K E h∣Gn,c(S,A)∣i
A〜P(∙∣s)	A〜πP(∙∣S)
≤ K E	hkMc(S, A) - M?(S, A)ki .	(C.2)
S〜Pn L	」
A 〜n(∙∣ S)
Next we prove the main part of the proposition. Thus we proved Proposition 4.1. Note that for any
distribution P and ρ0 and function f, we have ES 〜P f(S) = ES 〜。，f (S) + hρ-ρ0, fi ≤ ES 〜。，f(S) +
∣∣P - P0k 1 kf k∞. Thus applying this inequality with f(S) = EA〜∏(∙∣s) [kc(S, A) - M*(S, A)∣∣],
we obtain that
SEJkc(S,A)- M ?(S，A)k] ≤	S 〜EnJkc(S，A)- M ?(S，A)k]
A 〜n(∙∣S)	A 〜n(∙∣S)
+ kPnref - ρk1msxA4∣s)[kc(S,A)-M ?(S，A)kl
17
Published as a conference paper at ICLR 2019
≤ E	kMc(S, A) - M? (S, A)k + 2δκB
S〜Pnref L	」
A 〜π(∙∣S)
(C.3)
where the last inequality uses the inequalities (see Corollary E.7) that kρπ - ρπref k1 ≤
1-γγ ES 〜Pnref [KL(n(S),nref(S))1/2|S] = δκ and that kc(S,A) - M *(S,A)k ≤ 2B. Com-
bining (C.3) and (C.2) We complete the proof of Proposition 4.2.	□
D χ2-DIVERGENCE BASED INEQUALITIES
Lemma D.1. Let S be a random variable over the domain S. Let π and π0 be two policies and and
A 〜π(∙ | S) and A0 〜∏0(∙ | S). Let Y 〜M(∙ | S, A) and Y0 〜M(∙ | S, A0) be the random
variables for the next states under two policies. Then,
E [χ2(Y∣S,Y0∣S)] ≤ E [x2(A∣S,A0∣S)]
Proof. By definition, We have that Y|S = s, A = a has the same density as Y0|S = s, A0 = a for
any a and s. Therefore by Theorem E.4 (setting X, X0, Y, Y0 in Theorem E.4 by A|S = s, A0|S = s,
Y |S = s, Y0 |S = s respectively), We have
χ2(YIS = s,YIS = S) ≤ X2(AIS = s, AIS = S)
Taking expectation over the randomness of S We complete the proof.
□
D. 1 Properties of Markov Processes
In this subsection, We consider bounded the difference of the distributions induced by tWo markov
process starting from the same initial distributions μ. Let P,P0 be two transition kernels. Let
G = P∞=ο γkPk and G = (1 - γ)G. Define G and G0 similarly. Therefore we have that Gμ is the
discounted distribution of states visited by the markov process starting from distribution μ. In other
Words, if μ is the distribution of So, and P is the transition kernel induced by some policy π, then
G μ = ρπ.
First of all, let ∆ = γ(P0 - P) and we note that with simple algebraic manipulation,
G0 - G=(1 - γ)-1G0∆G	(D.1)
Let f be some function. We will mostly interested in the difference between ES〜g* [f] and
ES〜G0μ [f], which can be rewritten as h(G0 - G)μ, f). We will bound this quantity from above by
some divergence measure between P0 and P .
We start off with a simple lemma that controls the form hp - q, fi by the χ2 divergence between p
and q. With this lemma We can reduce our problem of bounding h(G0 - G)μ, f〉to characterizing the
χ2 divergence between Gμ and Gμ.
Lemma D.2. Let p and q be probability distributions. Then we have
hq-p,fi2 ≤ χ2(q,p) ∙ hp, f2i
Proof. By Cauchy-Schwartz inequality, we have
hq - p,fi2 ≤ (/ (q(X)P-P(X)) d') (Zp(χ)f(χ)2) = χ2(q,p) ∙hp,f2i
□
The following Lemma is a refinement of the lemma above. It deals with the distributions p and q
with the special structure P = WP0μ and q = WPμ.
18
Published as a conference paper at ICLR 2019
Lemma D.3. Let W, P0, P be transition kernels and μ be a distribution. Then,
hW(P0- P)μ,fi2 ≤ X2μ(P0,P)hWPμ, f 2i
where %μ(P0, P) is a divergence between transitions defined in Definition E.3.
Proof. By Lemma D.2 with P = WPμ and q = WP0μ, We conclude that
hW(P0 - P)μ,fi2 ≤ χ2(q,p) ∙ hp,f2i ≤ X2(WP0μ, WPμ)hWPμ,f2i
By Theorem E.4 and Theorem E.5 we have that χ2(WP0μ, WPμ) ≤ χ2(P0μ, Pμ) ≤ Xi(P∖ P),
plugging this into the equation above we complete the proof.	□
Now we are ready to state the main result of this subsection.
Lemma D.4. Let G,G∖P∖P,f as defined in the beginning of this section. Let δι = (1 一
Y)-1 xG”(P0, P)1/2 and δ2 = (1 - γ)-1 χGPGμ(P0, P)1/2. Then,
IhGG0μ,fi-hGμ,fi∣≤ δ1kfk∞	(D.2)
IhGG0μ,fi- hGμ,fi∣ ≤ δ1hGGPGμ,fT1/ + δ1δ^kfk∞
Proof. Recall by equation (D.1), we have
h(G0 - GG)μ, fi = (1- γ)-1hGG0∆Gμ,f i	(D.3)
By Lemma D.3,
hGG0∆GGμ,fi ≤ χGμ(P0,P)1∕2hG0PGμ,f2i1∕2	(D.4)
By Holder inequality and the fact that kGG∣∣1→1 = 1, ∣IG0k1→1 = 1 and ∣∣P∣∣1→1 = 1, we have
hGG0∆GGμ,f i ≤ χGμ(P0,P)1∕2hG0PGμ,f 2i1/2
≤ xGμ(P0,P)1/2∣GJ0PGJμk 1/2kf2k∞2
≤ χGμ(P0,P)1∕2kfk∞	(by ∣GG0PGμk1 ≤ kG0k1→1∣∣P∣∣1→1 IlGG∣∣1→1∣∣μ∣∣1 ≤ I)
≤ (1 - γ)δ1∣f∣∞	(D.5)
Combining equation (D.3) and (D.5) we complete the proof of equation (D.2).
Next we bound hGG0PGGμ, f 2)1/2 in a more refined manner. By equation (D.1), we have
hGG0PGGμ,f2)1/2 = (hGPGμ,f2i + 占G0∆GPGμ,f2i) /
≤ h<GP<5μ, f2)1/2 + (1 - γ)-1/2 (G0∆GPGμ, f 2)1/2	(D.6)
By Lemma D.3 again, we have that
hG0∆GPG,f2)2 ≤ χGpGμ(P0,P)hG0PGPGμ,f4)	(D.7)
By Holder inequality and the fact that ∣GG∣∣1→1 = 1, ∣∣G0∣1→1 = 1 and ∣∣P∣∣1→1 = 1, we have
hG0PGPGGμ,f4i ≤ ∣G0PGPG4^]]/4∣∞ ≤ ∣f∣∞	(D.8)
Combining equation (D.6), (D.8) gives
(1 -γ)-1∕2hG0∆GPG,f2i1∕2 ≤ ((1 -γ)-1χGpGμ(P0,P)1/2)1/21/£ = S/Ifh (D.9)
Then, combining equation (D.3), (D.4), (D.9), we have
h(G0-G)μ,fi = (1 - γ )-1χGμ (P 0,P )1∕2hG 0PGμ,f2i1∕2	(by equation (D.3), (D.4))
=δ1hG0PG μ,f 2)1/2
≤ δ1h<GP<Gμ, f 2)1/2 + δ1(1 - γ)-1∕2(G0∆GPGμ, f 2)1/2 (by equation (D.6))
≤ δ1<GPGμ,f2)1∕2 + 8161/2|团屋	(by equation (D.9))
□
19
Published as a conference paper at ICLR 2019
The following Lemma is a stronger extension of Lemma D.4, which can be used to future improve
Proposition A.2, and may be of other potential independent interests. We state it for completeness.
Lemma D.5. Let G, GG0, P0, P,f as defined in the beginning of this section. Let dk = (GP )kGGμ
and δk = (1 - γ)-1χ2d	(P0, P)1/2, then we have that for any K,
KG0μ,fi-hGμ,fi∣ ≤ δ1(d1,f2i-1/2 + δι码/电,f4i-1/4
+δ1...δK2-K+1hdk,f2Ki2-K+δ1...δK2-K+1kfk∞
Proof. We first use induction to prove that:
K(G 0 - G)μ, f i| ≤ XK	Y	δs2+-s1 hdk,f2ki2-k
k=1	0≤s≤k-1
+ ( Y δ2+1 I hG0∆(GP)KGμ,f2Ki2-K (D.10)
0≤s≤K-1
By the first equation of Lemma D.4, we got the case for K = 1. Assuming we have proved the case
for K , then applying
(G0∆(GP)kGμ,f2Ki = (G∆(GP)kGμ,f2Ki + (1 - Y)-1(G∆(GP)K+1Gμ, f 2Ki
(D.11)
≤ hG∆(GP)kGμ,f2Ki
+ (1-Y)TXdK (P0,P )”(G0∆(Gp )K+1G μ,f 2K+1 i1/2
≤ {G∆(GP)KGμ,f2Ki + δκ+ι(G0∆(GP)K+1Gμ,f2K+1 i1/2
By Cauchy-Schwartz inequality, we obtain that
(G0∆(GP)KGμ,f2Ki2-K ≤ hG∆(GP)KGμ,f2Ki2-K +
δκ+MG 0∆(G P )K+1Gμ,f2K+1i2-Kτ
Plugging the equation above into equation (D.10), we provide the induction hypothesis for the case
with K + 1.
Now applying (G0∆(GP)KGμ, f 2Ki2-K ≤ ∣∣f k∞ with equation (D.10) We complete the proof.
□
E Toolb ox
Definition E.1 (χ2 distance, c.f. Nielsen & Nock (2014); Cover & Thomas (2012)). The Neyman χ2
distance between two distributions p and q is defined as
χ2 (p, q) ,
(P(X) — q(X)) dx
q(x)
For notational simplicity, suppose two random variables X and Y has distributions pX and pY , we
often write χ2 (X, Y ) as a simplification for χ2(pX,pY ).
Theorem E.2 (Sason & Verdu (2016)). The KuUbaCk-Leibler(KL) divergence between two distribu-
tions p, q is bounded from above by the χ2 distance:
KL(p, q) ≤ χ2 (p, q)
Proof. Since log is a concave function, by Jensen inequality we have
KL(p,q) = Pp(x) log PXdx ≤ log PP(X) ∙ PXdx
,	q(X)	q(X)
20
Published as a conference paper at ICLR 2019
= log(χ2 (p, q) + 1) ≤ χ2 (p, q)
□
Definition E.3 (χ2 distance between transitions). Given two transition kernels P, P0. For any
distribution μ, We define χj(P0, P) as:
χ2μ(P0,P) , /μ(x)χ2(P0(∙lX = x),P(∙lX = X))dx
Theorem E.4. Suppose random variables (X, Y ) and (X0, Y 0) satisfy that pY |X = pY0|X0. Then
χ2(Y,Y0) ≤ χ2(X, X0)
Or equivalently,for any transition kernel P and distribution μ, μ0, we have
χ2 (Pμ,pμ0) ≤ χ2(μ,μ0)
Proof. Denote pY |X(y | x) = pY0|X0 (y | x) by p(y | x), and We reWrite pX as p andpX0 as p0. By
Cauchy-SchWarz inequality, We have:
pY (y)
p(y|x)p(x)dx
p(y|x)p0(x)d
p(y∣x) p7x)- dx
p0(x)
pγo(y) ( Zp(y∣x)p(x)-dx
p (x)
(E.1)
It folloWs that
1 ≤∕dy∕p⑶x) W dx- 1 = χ2(X,X 0)
□
Theorem E.5. Let X, Y, Y 0 are three random variables. Then,
χ2(Y,Y0) ≤ E χ2(Y |X, Y 0|X)
We note that the expectation on the right hand side is over the randomness of X.11 As a direct
corollary, we havefor transition kernel P0 and P and distribution μ,
χ2(P0μ,Pμ) ≤ Xμ(P0,p)
Proof. We denotepY0|X(y|x) byp0(y | x) andpY|X(y|x) by p(y|x), and let p(x) be a simplification
forpX(x). We have by Cauchy-SchWarz,
PY(y)2 = (Rp(y|x)p(X)dx)2 ≤ / p(y∣x)2 ( )d
pγo(y)	Rp0(y | x)p(x)dx - P p0(y∣x)p" ,
It folloWs that
χ2(Y,Y0) = /PY^dy -1 ≤ /p(yx)2p(x)dxdy -1 = E [χ2(Y∣x,y0∣x) IX]
□
Claim E.6. Let μ be a distribution over the state space S. Let P and P0 be two transition kernels.
G = PM(YP)k = (Id-YP)-1 and G = P∞=o(γP0)k = (Id-YP)T. Let d =(1 - γ)Gμ
and d = (1 一 γ)G0μ be the discounted distribution startingfrom μ induced by the transition kernels
G and G0. Then,
Id - d011 ≤ τ--|δ”∣ 1
1-Y
Moreover, let Y(P0 - P) = ∆. Then, we have
∞
G0 - G = X(G∆)kG
_______________________________ k=1
11Observe χ2 (Y|X, Y0∣X) deterministically depends on X.
21
Published as a conference paper at ICLR 2019
Proof. With algebraic manipulation, we obtain,
G0 -G = (Id-γP0)-1((Id-γP) - (Id-γP0)(Id-γP)-1
= G0∆G	(E.2)
It follows that
|d — d0∣1 = (1 — γ)∣G0∆Gμ∣ι ≤ ∣∆Gμ∣ι	(since (1 - γ)∣G0∣ι→ι ≤ 1)
=占公站
Replacing G0 in the RHS of the equation (E.2) by G0 = G + G0∆G, and doing this recursively gives
∞
G0 — G = X(G∆)kG
k=1
□
Corollary E.7. Let π and π0 be two policies and let ρπ be defined as in Definition 2.1. Then,
|pn - P011 ≤ 亡 SEJKL(n(S"(SWIS
Proof. Let P and P0 be the state-state transition matrix under policy π andπ 0 and ∆ = γ(P0 - P)
By Claim E.6, we have that
Iρπ -ρπ0∣ι ≤ ɪ∣∆ρπ∣ι =
1-γ
≤
≤
γ
L E
1 — Y S〜ρπ
γ
L E
1 — γ S〜ρπ
γ
L E
1 — γ S〜ρπ
IjpM ?(S,n(S))|S - PM ?(S,n0(S))|S |1
Ijpn(S)IS — Pπ0(S)∣S |1
hK L(π (S ), π0(S ))1/2 |S i (by Pinkser’s inequality)
□
F Implementation Details
F.1 Environment Setup
We benchmark our algorithm on six tasks based on physics simulator Mujoco (Todorov et al., 2012).
We use rllab’s implementation (Duan et al., 2016) 12 to interact with Mujoco. All the environments
we use have a maximum horizon of 500 steps. We remove all contact information from observation.
To compute reward from states, we put the velocity of center of mass into the states.
F.2 Network Architecture and Model Learning
We use the same reward function as in rllab, except that all the coefficients Ccontact in front of the
contact force s are set to 0 in our case. We refer the readers to (Duan et al., 2016) Supp Material
1.2 for more details. All actions are projected to the action space by clipping. We normalize all
observations by s0 = s-μ where μ,σ ∈ Rdobservation are computed from all observations We collect
from the real environment. Note that μ, σ may change as we collect new data. Our policy will always
produce an action a in [—1, 1]daction and the action a0, which is fed into the environment, is scaled
linearly by a0 = 1-a amin + 1++a amax, where amin, amax are the min or max values allowed at each
entry.
12commit b3a2899 in https://github.com/rll/rllab/
22
Published as a conference paper at ICLR 2019
Table 1: TRPO Hyperparameters.
Hyperparameters Values
batch size	4000
max KL divergence	0.01
discount γ	0.99
GAE λ	0.95
CG iterations	10
CG damping	0.1
F.3 SLBO Details
The dynamical model is represented by a feed-forward neural network with two hidden layers, each
of which contains 500 hidden units. The activation function at each layer is ReLU. We use Adam to
optimize the loss function with learning rate 10-3 and L2 regularization 10-5. The network does
not predict the next state directly; instead, it predicts the normalized difference of st+1 - st . The
normalization scheme and statistics are the same as those of observations: We maintain μ, σ from
collected data in the real environment and may change them as we collect more, and the normalized
difference is st+1-st-σ.
μ
The policy network is a feed-forward network with two hidden layers, each of which contains 32
hidden units. The policy network uses tanh as activation function and outputs a Gaussian distribution
N(μ(s), σ2) where σ a state-independent trainable vector.
During our evaluation, we use H = 2 for multi-step model training and the batch size is given by
2H6 = 128, i.e., We enforce the model to see 256 transitions at each batch.
We run our algorithm nouter = 100 iterations. We collect ntrain = 10000 steps of real samples from
the environment at the start of each iteration using current policy with Ornstein-Uhlunbeck noise
(with parameter θ = 0.15, σ = 0.3) for better exploration. At each iteration, we optimize dynamics
model and policy alternatively for ninner = 20 times. At each iteration, we optimize dynamics model
for nmodel = 100 times and optimize policy for npolicy = 40 times.
F.4 Baselines
TRPO. TRPO hyperparameters are listed at Table 1, which are the same as OpenAI Baselines’
implementation. These hyperparameters are fixed for all experiments where TRPO is used, includ-
ing ours, MB-TRPO and MF-TRPO. We do not tune these hyperparameters. We also normalize
observations as our algorithm and OpenAI Baselines do.
We use a neural network as the value function to reduce variance, which has 2 hidden layers of units
64 and uses tanh as activation functions. We use Generalized Advantage Estimator (GAE) Schulman
et al. (2015b) to estimate advantages. Both TRPO used in our algorithm and that in model-free
algorithm share the same set of hyperparameters.
SAC. For fair comparison, we do not use a large policy network (2 hidden layers, one of which has
256 hidden units) as the authors suggest, but use exactly the same policy network as ours. All other
hyperparameters are kept the same as the authors’. Note that Q network and value network have 256
hidden units at each hidden layers, which is more than TRPO’s. We refer the readers to Haarnoja
et al. (2018) Appendix D for more details.
MB-TRPO. Model-Based TRPO (MB-TRPO) is similar to our algorithm SLBO but does not
optimize model and policy alternatively during one iteration. We do not tune the hyperparameter
nmodel since any number beyond a certain threshold would bring similar results. For npolicy we try
{100, 200, 400, 800} on Ant and find npolicy = 200 works best in Ant so we use it for all other
environments. Note that when Algo 2 uses 800 Adam updates (per outer iteration), it has the same
amount of updates (per outer iteration) as in Algo 3. As suggested by Section 6.1, we use 0.005 as
the coefficient of entropy bonus for all experiments.
23
Published as a conference paper at ICLR 2019
Algorithm 3 Model-Based Trust Region Policy Optimization (MB-TRPO)
1:
2:
3:
4:
5:
6:
7:
8:
9:
initialize model network parameters φ and policy network parameters θ
initialize dataset D - 0
for nouter iterations do
D - D ∪ { collect ncollect samples from real environment using πθ with noises }
for nmodel iterations do
optimize (6.1) over φ with sampled data from D by one step of Adam
for npolicy iterations do
D0 - { collect ntrpo samples using Mcφ as dynamics }
optimize πθ by running TRPO on D0
SLBO. We tune multi-step model training parameter H ∈ {1, 2, 4, 8}, entropy regularization
coefficient λ ∈ {0, 0.001, 0.003, 0.005} and npolicy ∈ {10, 20, 40} on Ant and find H = 2, λ =
0.005, npolicy = 40 work best, then we fix them in all environments, though environment-specific
hyperparameters may work better. The other hyperparameters, including ninner , nmodel and network
architecture, are never tuned. We observe that at the first several iterations, the policy overfits to the
learnt model so a reduction of npolicy at the beginning can further speed up convergence but we omit
this for simplicity.
The most important hyperparameters we found are npolicy and the coefficient in front of the entropy
regularizer λ. It seems that once nmodel is large enough we don’t see any significant changes. We did
have a held-out set for model prediction (with the same distribution as the training set) and found out
the model doesn’t overfit much. As mentioned in F.3, we also found out normalizing the state helped
a lot since the raw entries in the state have different magnitudes; if we don’t normalize them, the loss
will be dominated by the loss of some large entries.
F.5 Ablation Study
Multi-step model training. We compare multi-step model training with single-step model training
and the results are shown on Figure 2. Note that H = 1 means we use single-step model training. We
observe that small H (e.g., 2 or 4) can be beneficial, but larger H (e.g., 8) can hurt. We hypothesize
that smaller H can help the model learn the uncertainty in the input and address the error-propagation
issue to some extent. Pathak et al. (2018) uses an auto-regressive recurrent model to predict a
multi-step loss on a trajectory, which is closely related to ours. However, theirs differs from ours in
the sense that they do not use the predicted output xt+1 as the input for the prediction of xt+2, and so
on and so forth.
(a) Ant	(b) Walker
----H = I -------- H = 2	---- H = 4	---- H = B
Figure 2: Ablation study on multi-step model training. All the experiments are average over 10
random seeds. The x-axis shows the total amount of real samples from the environment. The y-axis
shows the averaged return from execution of our learned policy. The solid line is the mean of the
total rewards from each seed. The shaded area is one-standard deviation.
(c) Humanoid
Entropy regularization. Figure 3 shows that entropy reguarization can improve both sample
efficiency and final performance. More entropy regularization leads to better sample efficiency and
higher total rewards. We observe that in the late iterations of training, entropy regularization may
hurt the performance thus we stop using entropy regularization in the second half of training.
24
Published as a conference paper at ICLR 2019
(a) Ant	(b) Walker
-λ=Q	Λ =0.001	—— A = 0.003	—— A =0.005	—— A = 0.01
Figure 3: Ablation study on entropy regularization. λ is the coefficient of entropy regularization in
the TRPO’s objective. All the experiments are averaged over 10 random seeds. The x-axis shows
the total amount of real samples from the environment. The y-axis shows the averaged return from
execution of our learned policy. The solid line is the mean of the total rewards from each seed. The
shaded area is one-standard deviation.
SLBO with 4M training steps. Figure 4 shows that SLBO is superior to SAC and MF-TRPO in
Swimmer, Half Cheetah, Walker and Humanoid when 4 million samples or fewer samples are allowed.
For Ant environment , although SLBO with less than one million samples reaches the performance
of MF-TRPO with 8 million samples, SAC’s performance surpasses SLBO after 2 million steps of
training. Since model-free TRPO almost stops improving after 8M steps and our algorithms uses
TRPO for optimizing the estimated environment, we don’t expect SLBO can significantly outperform
the reward of TRPO at 8M steps. The result shows that SLBO is also satisfactory in terms of
asymptotic convergence (compared to TRPO.) It also indicates a better planner or policy optimizer
instead of TRPO might be necessary to further improve the performance.
(a) Swimmer
(b) Half Cheetah
(c) Ant
(d) Walker
(e) Humanoid
——SLBO	SLBO-MSE — MB-TRPO ——SAC	MF-TRPO
Figure 4: Comparison among SLBO (ours), SLBO with squared `2 model loss (SLBO-MSE), vanilla
model-based TRPO (MB-TRPO), model-free TRPO (MF-TRPO), and Soft Actor-Critic (SAC) with
more samples than in Figure 1. SLBO, SAC, MF-TRPO are trained with 4 million real samples. We
average the results over 10 different random seeds, where the solid lines indicate the mean and shaded
areas indicate one standard deviation. The dotted reference lines are the total rewards of MF-TRPO
after 8 million steps.
25
Published as a conference paper at ICLR 2019
G Sample Complexity Bounds
In this section, we extend Theorem 3.1 to a final sample complexity result. For simplicity, let
Lππ,M,δ = V π,M - Dπk,δ(M, π) be the lower bound of V π,M? . We omit the subscript δ when it’s
clear from contexts. When D satisfies (R1), we have that,
V π,M? ≥ Lππr,eMf,δ	∀π s.t. d(π,πref) ≤ δ	(G.1)
When D satisfies (R3), we use Lbππ,M,δ to denotes its empirical estimates. Namely, we replace the
expectation in equation (R3) by empirical samples τ(1), . . . , τ(n). In other words, we optimize
1n
∏k+1,Mk+1 = argmax L∏* = V仆M - — Ef(C,π,τ⑴)	(G.2)
π∈Π, M ∈M πref,δ	n i=1
instead of equation (3.3).
Let p be the total number of parameters in the policy and model parameterization. We assume
that we have a discrepancy bound Dπref (π, M) satisfying (R3) with a function f that is bounded
with [-Bf, Bf] and that is Lf -Lipschitz in the parameters of π and M. That is, suppose π is
parameterized by θ and M is parameterized by φ, then we require |f (Mφ,φθ,τ) - f (M@: ,φθo, τ )| ≤
Lf (kφ - φ0k22 + kθ - θ0k2) for all τ, θ, θ0, φ, φ0. We note that Lf is likely to be exponential in
dimension due to the recursive nature of the problem, but our bounds only depends on its logarithm.
We also restrict our attention to parameters in an Euclidean ball {θ : kθk2 ≤ B} and {φ : kφk2 ≤ B}.
Our bounds will be logarithmic in B .
We need the following definition of approximate local maximum since with sampling error we cannot
hope to converge to the exact local maximum.
Definition G.1. We say π is a (δ, ε)-local maximum of Vπ,M? with respect to the constraint set Π
and metric d, if for any π0 ∈ Π with d(π, π0) ≤ δ, we have Vπ,M ? ≥ V π0,M? - ε.
We show a sample complexity bounds that scales linearly in p and logarithmically in Lf, B and Bf.
Theorem G.2. Let ε > 0. In the setting of Theorem 3.1, under the additional assumptions above,
suppose we use n = O(BfPlog(BLf /ε)∕ε2) trajectories to estimate the discrepancy bound in
Algorithm 1. Then, for any t, if πt is not a (δ, ε)-local maximum, then the total reward will increase
in the next step: with high probability,
Vπt+1,M
≥ Vπt,M? + ε∕2
(G.3)
As a direct consequence, suppose the maximum possible total reward is BR and the initial total
reward is 0, then for some T = O(BR∕ε), we have that πT is a (δ, ε)-local maximum of the Vπ,M?.
Proof. By Hoeffiding’s inequality, we have for fix π and Mc, with probability 1 - nO(1) over the
randomness of τ(1), . . . , τ(n),
1n
-M,∏(M,∏,τ( )) -	E	[f(M,∏,τ)]
n	T〜∏ref,M?
i=1	re
T	. . ∙	1	I 余	/71”、
In more succinct notations, we have |Dnk ,δ (M,∏)一
≤ 4∖IBfbgn.
n
(G.4)
Dnk ,δ (M,∏)l≤ 4 √fgn
and therefore
∣Ln,M - LnM| ≤ 4.IBfbgn.
n
(G.5)
By a standard ε-cover + union bound argument, we can prove the uniform convergence: with high
probability (at least 1 - nO(1)) over the choice of τ(1), . . . , τ(n), for all policy and model, for all
policy π and dynamics M,
∣L∏,m -LnM | ≤ 4^fp lOg(nBLf) = ε∕4.
(G.6)
26
Published as a conference paper at ICLR 2019
Suppose at iteration t, we are at policy πt which is not a (δ, ε)-local maximum of Vπ,M?. Then, there
exists π0 such that d(π0 , πt) ≤ δ and
V π0,M? ≥ Vπt,M? +ε.	(G.7)
Then, we have that
V πt+1,M ? ≥ Lπt+1,Mt+1
≥ Lπt+1,Mt+1 - ε∕4
≥ L∏0,M? -ε∕4
≥ Lππt0,M? - ε∕2
= V π0,M? - ε∕2
= V πt,M? + ε∕2
(by equation (G.1))
(by uniform convergence, equation (G.6))
(by the definition of πt+1, Mt+1)
(by uniform convergence, equation (G.6))
(by equation (R2))
(by equation (G.7))
Note that the total reward can only improve by ε∕2 for at most O(BR∕ε) steps. Therefore, in the first
O(BR∕ε) iterations, we must have hit a solution that is a (δ, ε)-local maximum. This completes the
proof.
□
27