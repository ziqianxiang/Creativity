Published as a conference paper at ICLR 2019
Quasi-hyperbolic momentum and Adam for
DEEP LEARNING
Jerry Ma
Facebook AI Research
Menlo Park, CA, USA
maj@fb.com
Denis Yarats
Facebook AI Research & New York University
New York, NY, USA
denisy@fb.com
Ab stract
Momentum-based acceleration of stochastic gradient descent (SGD) is widely
used in deep learning. We propose the quasi-hyperbolic momentum algorithm
(QHM) as an extremely simple alteration of momentum SGD, averaging a plain
SGD step with a momentum step. We describe numerous connections to and iden-
tities with other algorithms, and we characterize the set of two-state optimization
algorithms that QHM can recover. Finally, we propose a QH variant of Adam
called QHAdam, and we empirically demonstrate that our algorithms lead to sig-
nificantly improved training in a variety of settings, including a new state-of-the-
art result on WMT16 EN-DE. We hope that these empirical results, combined with
the conceptual and practical simplicity of QHM and QHAdam, will spur interest
from both practitioners and researchers. Code is immediately available. 1
1	Introduction
Stochastic gradient descent (SGD) serves as the optimizer of choice for many recent advances in
deep learning across domains (Krizhevsky et al., 2012; He et al., 2016a; Gehring et al., 2017). SGD
for deep learning is typically augmented with either the “heavy ball” momentum technique of Polyak
(1964) or the accelerated gradient of Nesterov (1983). In the deterministic setting, these methods
provably yield faster convergence in fairly general settings. In the stochastic setting, these methods
lose many theoretical advantages. However, due to its implicit gradient averaging, momentum can
confer the benefit of variance reduction, applying less noisy parameter updates than plain SGD.
Recent work has explicitly shown the use of momentum as a variance reducer (Roux et al., 2018).
Algorithms Starting with gradient variance reduction as an informal and speculative motivation,
we introduce the quasi-hyperbolic momentum (QHM) optimization algorithm in Section 3. Put
as simply as possible, QHM’s update rule is a weighted average of momentum’s and plain SGD’s
update rule. We later propose a similar variant of Adam (QHAdam) in Section 5.
Connecting the dots QHM is simple yet expressive. In Section 4, we connect QHM with plain
SGD, momentum, Nesterov’s accelerated gradient, PID control algorithms (Recht, 2018; An et al.,
2018), synthesized Nesterov variants (Lessard et al., 2016), noise-robust momentum (Cyrus et al.,
2018), Triple Momentum (Scoy et al., 2018), and least-squares acceleration of SGD (Kidambi et al.,
2018). Such connections yield reciprocal benefits - these algorithms aid in analyzing QHM, and
conversely QHM recovers many of these algorithms in a more efficient and conceptually simpler
manner. We then characterize the set of optimization algorithms that QHM recovers.
Practical validation and considerations In Section 6, we empirically demonstrate that QHM and
QHAdam provide superior optimization in a variety of deep learning settings. We provide both
comprehensive parameter sweep analyses on smaller models and case studies on large real-world
models. We demonstrate improvements on strong (sometimes state-of-the-art) models simply by
swapping out the vanilla algorithms with the QH counterpart. Notably, taking the WMT16 EN-DE
translation model of Ott et al. (2018), we achieve a 40% improvement in stability, along with a new
state-of-the-art result of 29.45 BLEU. We then offer some practical tips for QHM and QHAdam.
1https://github.com/facebookresearch/qhoptim/
1
Published as a conference paper at ICLR 2019
Miscellany We provide errata for Kingma & Ba (2015), Recht (2018), and Kidambi et al. (2018).
We also offer evidence that momentum often yields negligible improvement over plain SGD.
We emphasize QHM and QHAdam’s efficiency and conceptual simplicity. QHM has no extra over-
head vs. Nesterov’s accelerated gradient, and QHAdam has very little overhead vs. Adam. Also,
both algorithms are easily understood as an interpolation between two other well-known algorithms,
so they are accessible to practitioners and can be tuned starting with existing practical intuitions. We
believe that this contributes strongly to the algorithms’ practical promise.
2	Preliminaries
We begin with notation and a brief review of stochastic gradient descent (SGD) and momentum.
Primitives In this paper, θ ∈ Rp denotes a vector of model parameters. L(θ) : Rp → R denotes a
loss function to be minimized via θ. L(θ) : Rp → R denotes an approximator of the loss function
(e.g. over a minibatch). VL denotes the gradient of function L. Unless otherwise specified, all
vector operations are element-wise. We use g, a, s, v, w ∈ Rp as auxiliary buffers, and g is typically
the “momentum buffer”. θ, L(∙), and all buffers are subscriptable by t, the optimization step.
Optimization algorithms We consider optimization algorithms that perform a sequence of steps
(indexed by t), updating θ at each step towards minimizing L(θ). For brevity, we write algorithms
as “update rules”, which describe the algorithm’s behavior during a single step t, rather than as full
pseudocode. Update rules take this basic form (optionally with one or more auxiliary steps):
θt+ι - θt - [...]
Plain SGD The SGD algorithm, parameterized by learning rate α ∈ R, uses the update rule:
_ _ _____________________________________________ʌ , _ .
Θt+1 J θt - α ∙ VLt(θt)
Momentum The momentum algorithm, parameterized by α ∈ R and β ∈ R, uses the update rule:
_ , 一、 ______________________________________________ʌ , _ .
gt+1 - β ∙ gt + (I- β) ∙ vlt(θt)	⑴
θt+1 - θt - α ∙ gt+1	(2)
where g is commonly called the “momentum buffer”. Note that β = 0 recovers plain SGD.
The exponential discount factor β controls how slowly the momentum buffer is updated. In the
stochastic setting, β also controls the variance of a normalized momentum buffer. A common rule
of thumb for momentum is β = 0.9 (Ruder, 2016). 2
In contrast to common formulations of momentum (Polyak, 1964; Sutskever et al., 2013), we nor-
malize, or “dampen”, the momentum buffer g by (1 - β) in (1). This serves both to remove depen-
dence of the update step magnitude on β, and to allow the interpretation of g as a weighted average
of past gradients (and thus a gradient estimator). Of course, this also shrinks the updates by a factor
of 1 - β vs. common formulations; this is easily reversible with a corresponding increase to α.
3	Algorithm: Quasi-hyperbolic momentum (QHM)
In this section, we propose and discuss the quasi-hyperbolic momentum (QHM) algorithm.
QHM update rule
QHM, parameterized by a ∈ R, β ∈ R, and V ∈ R, uses the update rule:
gt+1 - β ∙ gt + (I- β) ∙vLt(θt)	⑶
Θt+1 J θt 一 α [(1 一 V) ∙ VLt(θt) + V ∙ gt+ι]	(4)
Section 7.1 provides a recommended rule of thumb (ν = 0.7 and β = 0.999).
2Additionally, Kingma & Ba (2015) recommends β1 = 0.9 for Adam, and β1 = 0.9 is the default for Adam
in both the PyTorch and TensorFlow frameworks (Paszke et al., 2017; Abadi et al., 2015).
2
Published as a conference paper at ICLR 2019
Interpretation QHM introduces the immediate discount factor ν, encapsulating plain SGD (ν =
0) and momentum (ν = 1). A self-evident interpretation of QHM is as a ν-weighted average of the
momentum update step and the plain SGD update step.
QHM vs. momentum Comparing (2) and (4), QHM may seem at first glance identical to momen-
tum with discount factor νβ. Appendix A.8 analytically demonstrates that this is not the case. We
note that the expressive power of QHM intuitively comes from decoupling the momentum buffer’s
discount factor (β) from the current gradient’s contribution to the update rule (1 - νβ). In contrast,
momentum tightly couples the discount factor (β) and the current gradient’s contribution (1 - β).
Variance reduction QHM is originally motivated by an informal and speculative variance reduc-
tion analysis; for brevity, we provide the full details in Appendix A. 3 In short, the square bracket
term in (4) can be viewed as a gradient estimator (modulo initialization bias). When ν = 1, this is
simply the momentum buffer gt+1. Increasing β decreases the variance of the momentum buffer,
but potentially at the cost of making it unusably “stale” (biased). QHM allows for the mitigation of
this staleness by upweighting the current, unbiased gradient (i.e. setting ν < 1).
Efficiency QHM, like momentum, requires 1 auxiliary buffer of memory. It also requires 1 in-place
scalar-vector multiplication and 3 scaled vector additions per update step.
4 Connections to other algorithms
We now present numerous connections between QHM and other optimization algorithms. The com-
mon theme is that QHM recovers almost all of these algorithms, and thus is a highly interpretable
and more efficient implementation of these algorithms. The first few subsections present these con-
nections, 4 Table 1 summarizes these connections, and Section 4.5 provides discussion.
4.1	Nes terov’ s accelerated gradient
Nesterov (1983)’s accelerated gradient (NAG) can be viewed as a closely related cousin of momen-
tum. In fact, replacing the gt+ι term m (2) With [(1 - β) ∙ VLt(θt) + β ∙ gt+ι] yields NAG.
Connection with QHM It follows from (4) that QHM recovers NAG with ν = β . This sheds light
on the someWhat unintuitive NAG algorithm, providing a natural interpretation of NAG’s update
rule as a β-Weighted average betWeen momentum and plain SGD.
Efficiency NAG’s compute/memory cost is equivalent to that of QHM.
4.2	PID control
Recht (2018) draWs a strong connection betWeen gradient-based optimization and PID control. We
regurgitate the excellent exposition (With minor modifications) in Appendix B.
Update rule A PID control optimizer, parameterized by kP , kI, kD ∈ R, uses the update rule:
et《----VLt(Bt)	Vt - β ∙ vt-1 + (1 - β)(et - et-i)	Wt - wt-1 + et
θt+ι - θo + kp ∙ et + kɪ ∙ Wt + k。∙ Vt
Connection with QHM We fully relate QHM and PID in Appendix C.3. To summarize, PID is a
superfamily of QHM. VieWing β as a constant, QHM imposes a restriction on the ratio betWeen kP
and kD. VieWing β as a free variable, hoWever, QHM can recover nearly all PID coefficients.
Efficiency Recht (2018) provides a transformation of variables that reduces the memory cost to 2
auxiliary buffers, and the compute cost to 1 in-place scalar-vector multiplication and 4 scaled vector
additions per update step. This is still costlier than QHM.
3The appendix also sheds some light on the nomenclature, adopted from the hyperbolic discounting Work
pioneered by Chung & Hernstein (1961), Phelps & Pollak (1968), and Laibson (1997) in consumer choice. We
caution that “quasi-hyperbolic” does not directly relate to the geometry of hyperbolas.
4Appendix C presents a deeper theoretical treatment of Section 4.2 through Section 4.4, Which are largely
narrative.
3
Published as a conference paper at ICLR 2019
Alternative PID setting In Appendix E, we briefly discuss another PID setting by An et al. (2018)
and relate the resulting optimization algorithm to QHM. In short, the setting is degenerate as the P,
I, and D terms are linearly dependent. Thus, QHM can recover the resulting PID control optimizer.
4.3	Synthesized Nesterov Variants (SNV)
Section 6 of Lessard et al. (2016) describes a “synthesized Nesterov variant” algorithm, which we
call “SNV” for convenience. This algorithm is used to analyze and improve optimizer robustness
under “relative deterministic noise” (i.e. multiplicative noise of the gradient).
Update rule SNV, parameterized by γ, β1, β2 ∈ R, uses the update rule: 5
ξt+ι - ξt - Y ∙ ▽£t(θt) + βι(ξt - ξt-ι)
θt+1 - ξt+1 + β2(ξt+1 - ξt)
Connection with QHM We fully relate QHM and SNV in Appendix C.4. To summarize, QHM
and SNV recover each other. By extension, QHM recovers the Robust Momentum method, which
is a specific parameterization of SNV (Cyrus et al., 2018). Moreover, since Robust Momentum
recovers the Triple Momentum of Scoy et al. (2018), QHM also recovers Triple Momentum.
Efficiency SNV is costlier than QHM, requiring 2 auxiliary buffers and 5 scaled vector additions.
4.4	ACCSGD
Jain et al. (2017) and Kidambi et al. (2018) point out various failures of momentum and NAG in the
setting of stochastic least squares optimization. This motivates their proposal of the AccSGD algo-
rithm, which yields faster convergence over momentum and NAG in certain least-squares regression
settings. Here, we discuss the formulation of Kidambi et al. (2018).
Update rule AccSGD, parameterized by δ > 0, κ > 1, ξ ≤ √κ, and e < 1, uses the update rule:
2ξ	2ξ	κδ
wt+14----—∙ Wt +(1---------— w Wt-----— ∙ VLt(θt)
ξ	κ
Θt+1 = Wt+14------.一T Wt - δ ∙ VLt(θt) +------1-- ∙ Wt+1
κ + ξ	κ + ξ
Connection with QHM We fully relate QHM and AccSGD in Appendix C.5. To summarize,
QHM recovers AccSGD. In the reverse direction, AccSGD does not recover QHM; specifically, we
disprove the claim in Kidambi et al. (2018) that AccSGD recovers NAG. Since QHM recovers NAG,
AccSGD cannot fully recover QHM.
Efficiency AccSGD, like QHM, requires 1 auxiliary buffer. Computationally, AccSGD is costlier,
requiring 2 in-place scalar-vector multiplications and 4 scaled vector additions per update step.
4.5 Discussion
Theoretical convergence results We note that various convergence results follow simply via these
connections. In the deterministic (full-batch) case, since QHM recovers Triple Momentum, QHM
also recovers the global linear convergence rate of 1 - 1/√κ for strongly convex, smooth loss
functions. 6 For first-order methods, this is the fastest known global convergence rate for such
functions. In the stochastic (minibatch) case, QHM's recovery of AccSGD gives QHM the same
convergence results as in Kidambi et al. (2018)'s least-squares regression setting, of O(√κ ∙ log K ∙
log ɪ) iterations for ^-approximation of the minimal loss.
Unifying two-state optimization algorithms These connections demonstrate that many two-state
optimization algorithms are functionally similar or equivalent to each other. However, they are often
implemented inefficiently and their parameterizations can be inaccessible to practitioners. QHM
yields a highly accessible and efficient version of these algorithms.
5The learning rate is α in the original paper; we use γ to avoid confusion with QHM’s α.
6Here, K is the ratio between the Lipschitz constant of VL(∙) and the strong convexity parameter of L(∙).
4
Published as a conference paper at ICLR 2019
Table 1: Summary of connections between QHM and other optimization algorithms
ALGORITHM	RELATION *	EFFj	BRIEF NOTES
Plain SGD	subfamily	better	recovered by QHM with V = 0
Momentum (Polyak,1964)	subfamily	better	recovered by QHM with V = 1
NAG (NeSteroV,1983)	subfamily	same	recovered by QHM with V = β
PID (ReCht, 2018)	parent	worse	QHM's β restricts PID's kp/k0
PID (An etal., 2018)	bijective	worse	degenerate; either “PI” or“PD”
SNV (LeSSard et al., 2016)	bijective	worse	used in handling multiplicative noise
Robust M. (Cyrus et al., 2018)	subfamily	worse	SNV w/ convergence guarantees
Triple M. (Scoy etal., 2018)-	subfamily	worse	“fastest” for str. convex, smooth L(∙)
AccSGD (Kidambi et al., 20Γ8T	subfamily	worse	acceleration for least-squares SGD
* “subfamily” means that QHM recovers the algorithm but not vice-versa. “parent” means that the algo-
rithm recovers QHM but not vice-versa. “bijective” means that the algorithms recover each other.
t Efficiency (compute and/or memory) vs. QHM.
In Appendix D, we characterize the set of two-state optimization algorithms recoverable by QHM.
Our hope here is to provide future work with a routine conversion to QHM so that they may leverage
the accessibility and efficiency benefits, as well as the many connections to other algorithms.
Many-state optimization algorithms Going beyond a single momentum buffer, it is possible to
recover many-state algorithms by linearly combining many momentum buffers (with different dis-
count factors) in the update rule. However, we found in preliminary experiments that using multiple
momentum buffers yields negligible value over using a single slow-decaying momentum buffer and
setting an appropriate immediate discount - that is, using QHM with high β and appropriate V.
We note that the Aggregated Momentum (AggMo) algorithm (Lucas et al., 2018) precisely performs
this linear combination of multiple momentum buffers. While AggMo takes a simple average of the
buffers, an extended variant of AggMo allows for other linear combinations. This extended AggMo
can be viewed as a many-state generalization of two-state algorithms (including QHM), recovering
them when two buffers are used. Appendix H provides a supplemental discussion and empirical
comparison of QHM and AggMo, corroborating our preliminary experiments’ findings.
5 Algorithm: QHAdam
The Adam optimizer (Kingma & Ba, 2015) has enabled many compelling results in deep learn-
ing (Xu et al., 2015; Vaswani et al., 2017; Yu et al., 2018). We propose to replace both of Adam’s
moment estimators with quasi-hyperbolic terms, and we name the resulting algorithm QHAdam.
QHAdam update rule
QHAdam, parameterized by a, e ≥ 0, βι, β2 ∈ [0,1), and ν∖,ν? ∈ R, uses the update rule:
_ , _ 、 ___________ʌ , _ .
gt+1 - βι∙ gt + (1 - βι) ∙ VLt(θt)
st+1 - β2 ∙ Vt + (1- β2)(VLt(θt))2
g0+ι J (1 - βt+1) ∙ gt+ι
st+ι J (1 - β2+1) ∙ vt+ι
θt+ι 一 θt — α
,. .一 ʌ ,,. .
__(1-_vi)^VI.t(0t)+_vi^gt+^_
q/(1 - ν2)(VLt(θt))2 + ν2 ∙ st+ι + C
Note that only the last expression differs from vanilla Adam. In fact, QHAdam recovers Adam when
ν1 = ν2 = 1. Moreover, modulo bias correction, QHAdam recovers RMSProp (Hinton et al., 2012)
when ν1 = 0 and ν2 = 1, and NAdam (Dozat, 2016) when ν1 = β1 and ν2 = 1. We note that
Adam has inspired many variants such as AMSGrad (Reddi et al., 2018) and AdamW (Loshchilov
& Hutter, 2017), which can be analogously modified.
5
Published as a conference paper at ICLR 2019
Table 2: Summary of experimental settings
SHORT NAME	MODEL	DATASET/TASK	OPTIMIZER
Logistic-EMNIST-QHM PS	logistic regression	EMNIST digits	QHM
Logistic-EMNIST-QHAdam PS	logistic regression	EMNIST digits	QHAdam
MLP-EMNIST-QHM PS	3-layer tanh MLP	EMNIST digits	QHM
MLP-EMNIST-QHAdam PS	3-layer tanh MLP	EMNIST digits	QHAdam
RN18-CIFAR10-QHM PS	PreActReSNet18-	CIFAR10	QHM
RN50-ImageNet-QHM PS	ReSNet50	ILSVRC2012	QHM
RN152-ImageNet-QHM CS	ReSNet152	ILSVRC2012	QHM
FConvLM-WikiText103-QHM CS	FConvLM	WikiText-103	QHM
TD3-MuJoCo-QHAdam CS	TD3	MuJoCo	QHAdam
TF-WMT16ENDE-QHAdam CS	Transformer	WMT16 EN-DE	QHAdam 一
PS Parameter sweep experiment (Section 6.1). CS Case study (Section 6.2).
Efficiency QHAdam incurs four extra scaled vector additions over Adam.
Practical notes We leave formal convergence analysis to future work. However, a couple of infor-
mal points are worth mentioning. Firstly, ν1 and β1 can be reasoned about in a similar manner to
QHM’s ν and β. Secondly, when replacing Adam with QHAdam, setting ν2 = 1 and β2 unchanged
is usually reasonable if the original Adam training is stable. Thirdly, when Adam training is not
stable, it is possible that setting ν2 < 1 can improve stability by imposing a tighter step size bound
-Appendix F elaborates, disproving the step size bound claimed in Kingma & Ba (2015).
6	Experiments
We perform two categories of experiments: parameter sweeps and case studies. For brevity, all
experimental settings are summarized in Table 2 and comprehensively detailed in Appendix I.
6.1	Parameter sweeps
With parameter sweeps, we aim to comprehensively study the various parameterizations of the QH
algorithms using relatively small models. We train for 90 epochs with size-64 minibatches. For
QHM, we initialize α = 1 and decay it 10-fold every 30 epochs. The sweep grid for QHM (encap-
sulating various parameterizations of plain SGD, momentum, and NAG) is:
ν ∈ {0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995, 0.998, 0.999, 0.9995, 1}
β ∈ {0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995, 0.998, 0.999, 0.9995}
For QHAdam, we fix α = 10-3, = 10-8, ν2 = 1, and β2 = 0.999, and sweep over ν1 and β1.
“Default” ν and β values Motivated by the popular momentum/NAG “default” of β = 0.9, we
select a QH “default” of ν = 0.7 and β = 0.999 based on preliminary experimentation on the
MNIST dataset (LeCun, 1998) along with the intuitions from Appendix A. In the following figures,
we show these defaults along with the globally optimal parameterizations.
Results Fig. 1 presents selected results of these sweep experiments (full results in Appendix J).
Perhaps the most immediate observation is that the QH algorithms improve both training and vali-
dation metrics. Even the hardcoded default ν = 0.7 and β = 0.999 handily outperforms the optimal
parameterization of NAG or Adam in all settings. In some settings, there remains a large gap be-
tween the QH and vanilla algorithms at the end of training. In other settings, the gap shrinks to
smaller levels. However, even for these latter settings, the QH algorithm converges much faster,
suggesting that a more aggressive learning rate schedule can significantly reduce training time.
What about plain SGD? We note that in most of these experiments, there is little difference be-
tween the performance of plain SGD and NAG (particularly when compared to QHM). Although
not shown in the figures, there is also little difference between plain SGD and momentum. This in-
dicates that the benefit of momentum and NAG (in the common, unnormalized formulations) comes
6
Published as a conference paper at ICLR 2019
MLP-EMNIST-QHM	MLP-EMNIST-QHAdam
Figure 1: Selected parameter sweep results (full results in Appendix J). Top row shows train loss.
Bottom row shows validation error. “Best” refers to the optimal parameterization within the sweep,
with respect to the metric. Shaded bands indicate ±1 standard deviation.
RN50-ImageNet-QHM
40383634
AI×①一∈-①d U.2WP=e>
—NAG (β = 0.99)
I——QHM (V = 0∙98, B = 0.998)
I
Adam (βι = 0.9, β2 = 0.98)
QHAdam (vɪ = 0.8, Bl = 0.95,
Adam (βι = 0.9, β2 = 0.999)
QHAdam (vɪ = 09, Bl = 0.9,
V2 = 1.0, β2 = 0,999)
Figure 2: Case study results. Top row: RN152-Imagenet-QHM (left), FConvLM-WikiText103-
QHM (center), and TF-WMT16ENDE-QHAdam (right). Bottom row: TD3-MuJoCo-QHAdam
Ant (left), HalfCheetah (center), Hopper (right). Shaded bands indicate ±1 standard deviation.
in large part from the increase in effective step size. We thus suspect that much of the folk wisdom
about momentum’s benefits for SGD should instead be folk wisdom about using sensible learning
rates. In contrast, QHM provides significant benefits without changing the effective step size.
6.2	Case studies
With case studies, we apply the QH algorithms to diverse settings, with (currently or recently) state-
of-the-art models. Our case studies cover image recognition, language modeling, reinforcement
learning, and neural machine translation. Each case study features a baseline setting and a QH
setting, which are identical modulo the optimizer used. Results are presented in Fig. 2 and Table 3.
Image recognition (RN152-ImageNet-QHM) We train a ResNet152 model (He et al., 2016a) on
the ILSVRC2012 dataset (Russakovsky et al., 2015). The baseline setting is nearly identical to the
size-256 minibatch baseline in Goyal et al. (2017), using NAG with β = 0.9 and a decaying learning
rate schedule. The QH setting swaps out NAG for QHM, with ν = 0.7 and β = 0.999. 7
7Here, we did not sweep over alternate parameterizations.
7
Published as a conference paper at ICLR 2019
Table 3: Case study results
SHORT NAME	QH	BASELINE
RN152-ImageNet-QHM ERR	一	02128±0.0005	0.2137±0.0011
FConvLM-WikiText103-QHM PPL	一	34.45±0.17	34.92±0.33
ITO-MuJoCo-QHAdam HalfCheetah AR	一	10001.66±1106.50	9829.95±872.29
TD3-MuJoCo-QHAdam Hopper AR	一	2948.14± 1078.70	2401.39±1566.00
TD3-MuJoCo-QHAdamWalker2d AR	—	4282.15±707.78	4356.95±860.73
TD3-MuJoCo-QHAdam Ant AR	一	4657.12±881.03	4303.32± 1279.86
TD3-MuJoCo-QHAdam InvPendulum AR	一	986.30±59.70	950.27±186.63
TD3-MuJoCo-QHAdam InvDoublePendulum AR	8890.59±1941.56	9333.49±20.02
TD3-MuJοCο-QHAdam Reacher AR	一	-3.99±0.55	-3.98±0.56
TF-WMT16ENDE-QHAdam BLEU	一	29.45±0.06 *	29.17±0.07
ERR Validation top-1 error rate. PPL Validation perplexity. BLEU Validation BLEU score.
AR Average reward. * State-of-the-art result.
Running 3 seeds, QHM plainly trains much faster than NAG, and QHM converges to a marginally
superior validation error as well. 8
Language modeling (FConvLM-WikiText103-QHM) Deep learning for NLP often features
“spiky” gradient distributions (e.g. encountering rare words). We train a FConv language
model (Dauphin et al., 2016) on the WikiText-103 dataset (Merity et al., 2016). The baseline setting
precisely follows the original paper, using NAG with β = 0.99. The QH setting swaps out NAG for
QHM, with ν = 0.98 and β = 0.998. 7 We suspect that high β improves stability in the presense of
spiky gradients, and QHM’s ν allows the use of high β.
Running 10 seeds, QHM outperforms the NAG baseline on validation perplexity by half a point.
Reinforcement learning (TD3-MuJoCo-QHAdam) Reinforcement learning presents a challeng-
ing task for gradient-based optimization, since the objective L is not stationary. QH algorithms
provide a natural way of upweighting the most recent gradient. Here, we apply the TD3 algo-
rithm (Fujimoto et al., 2018) to various MuJoCo environments (Todorov et al., 2012). The baseline
precisely follows Fujimoto et al. (2018)’s setup, which uses Adam with β1 = 0.9 and β2 = 0.999.
The QH setting swaps out Adam for QHAdam, with ν1 = 0.9 and other parameters identical. 9
Running 10 seeds, QHAdam yields improvements in average reward on four environments out of
seven tested, and virtually ties on another.
Neural machine translation (TF-WMT16ENDE-QHAdam) Many state-of-the-art neural ma-
chine translation (NMT) models are fragile to train. As in language modeling, the gradient distribu-
tion is often “spiky”; thus, Adam training often fails to converge due to a very small number of large
parameter updates. 10 Here, we empirically demonstrate that QHAdam improves both performance
and robustness by using ν2 to control the maximum per-step update. We train a large transformer
model (Vaswani et al., 2017) on the WMT16 English-German dataset. The baseline setting precisely
follows the state-of-the-art setup of Ott et al. (2018), using β1 = 0.9 and β2 = 0.98 for Adam. The
QH setting swaps out Adam for QHAdam, with ν1 = 0.8, β1 = 0.95, ν2 = 0.7, and β2 = 0.98. 11
Running 10 seeds, the Adam baseline explodes on 4 seeds. QHAdam is more robust, converging
for all seeds. Ultimately, QHAdam yields a new state-of-the-art-result of 29.45 BLEU. Thus, we
improve both the stability and performance of the state-of-the-art with a simple optimizer swap.
8We also train the model using plain SGD, again finding that plain SGD performs nearly as well as NAG
throughout training. Although not shown, plain SGD in fact performs better than momentum. The validation
loss curves for plain SGD, momentum, and NAG are indistinguishable throughout training, suggesting that
momentum/NAG is not needed in Goyal et al. (2017).
9Here, we tried higher values of β1 . Significantly increasing β1 was not fruitful for either algorithm.
10Refer to Appendix F for a more detailed theoretical treatment.
11Here, we tried two other parameterizations (higher β1 ) with marginal success.
8
Published as a conference paper at ICLR 2019
7	Discussion
7.1	Practical suggestions
We offer some practical suggestions for deep learning practitioners, particularly those who default
to momentum, NAG, or Adam with β = 0.9 as a rule of thumb:
•	Consider using QHM or QHAdam, instead of momentum, NAG, or Adam.
•	While QHM parameters should be tuned when feasible, a decent rule of thumb is to set
ν = 0.7 and β = 0.999. QHAdam parameter selection is somewhat more situational,
although as discussed in Section 5, ν2 = 1 and β2 unchanged is usually reasonable when
replacing a stable Adam optimizer with QHAdam.
•	Be mindful of learning rate differences between (unnormalized) momentum/NAG and
QHM. Convert learning rates from the former to the latter via multiplication by (1 - β)-1.
For example, momentum/NAG with α = 0.1 and β = 0.9 should be replaced by QHM
with α = 1. This conversion is unnecessary for Adam, as it already normalizes all buffers.
7.2	Future work
This paper has only scratched the surface when it comes to empirical evaluation of QHM and
QHAdam. Future work could apply the algorithms to other well-studied tasks and architectures,
both to assess the extent of their performance gains in diverse domains, and to further develop in-
sights into hyperparameter choice.
Effective hyperparameter autotuning methods can improve the practicality of any optimization al-
gorithm. Thus, a useful direction for future work is to create an effective ν, β adapter, possibly
based on techniques such as YellowFin (Zhang et al., 2017) or via continuous-time optimal control
analysis, as in Li et al. (2017). Moreover, learning rate adaptation techniques such as Hypergradient
Descent (Baydin et al., 2018) can be applied to both QHM and QHAdam.
Future work could develop convergence results for QHAdam. Convergence results for QHM in a
reasonably general stochastic setting would also be appealing, although we are not aware of com-
pelling analogous results for momentum or NAG.
Finally, momentum has been studied in the distributed, asynchronous setting, with some noting
that the delays in asynchronous SGD are, in some sense, akin to adding momentum (Mitliagkas
et al., 2016). As a result, the optimal momentum constant β shrinks as more asynchronous workers
are added to optimization. It would be interesting to extend these results to QHM, especially to
disentagle the implicit effects of asynchrony on ν and β .
7.3	Conclusion
QHM and QHAdam are computationally cheap, intuitive to interpret, and simple to implement.
They can serve as excellent replacements for momentum/NAG and Adam in a variety of settings.
In particular, they enable the use of high exponential discount factors (i.e. β) through the use of
immediate discounting (i.e. ν). QHM recovers numerous other algorithms in an efficient and acces-
sible manner. Parameter sweep experiments and case studies demonstrate that the QH algorithms
can handily outpace their vanilla counterparts. We hope that practitioners and researchers will find
these algorithms both practically useful and interesting as a subject of further study.
Acknowledgments
We thank Aaron Defazio, Nicolas Loizou, Yann Olivier, Mark Tygert, and anonymous reviewers
and commenters for insightful discussions and valuable suggestions.
References
K. J. Aastrom and T. HagglUnd. PID Controllers: Theory, Design, and Tuning. Instrument Society
of America, Research Triangle Park, NC, 2 edition, 1995.
9
Published as a conference paper at ICLR 2019
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S.
Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew
Harp, Geoffrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz Kaiser, Manjunath
Kudlur, Josh Levenberg, Dandelion Mane, Rajat Monga, Sherry Moore, Derek Murray, Chris
Olah, Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker,
Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden, Martin Wat-
tenberg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. TensorFlow: Large-scale machine learn-
ing on heterogeneous systems, 2015. URL https://www.tensorflow.org/. Software
available from tensorflow.org.
Zeyuan Allen-Zhu. Katyusha: The first direct acceleration of stochastic gradient methods. Journal
ofMachine Learning Research,18:221:1-221:51, 2017. URL http://jmlr.org/papers/
v18/papers/v18/16-410.html.
Wangpeng An, Haoqian Wang, Qingyun Sun, Jun Xu, Qionghai Dai, and Lei Zhang. A pid controller
approach for stochastic optimization of deep networks. In The IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), June 2018.
Atilim Gunes Baydin, Robert Cornish, David Martinez Rubio, Mark Schmidt, and Frank Wood. On-
line learning rate adaptation with hypergradient descent. In International Conference on Learning
Representations, 2018. URL https://openreview.net/forum?id=BkrsAzWAb.
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym. CoRR, abs/1606.01540, 2016. URL http://arxiv.org/
abs/1606.01540.
Shin-ho Chung and Richard J Hernstein. Relative and absolute strength of response as a function of
frequency of reinforcement 1, 2. Journal of the experimental analysis of behavior, 4(3):267-272,
1961.
Gregory Cohen, Saeed Afshar, Jonathan Tapson, and Andre van Schaik. EMNIST: an extension
of MNIST to handwritten letters. CoRR, abs/1702.05373, 2017. URL http://arxiv.org/
abs/1702.05373.
Saman Cyrus, Bin Hu, Bryan Van Scoy, and Laurent Lessard. A robust accelerated optimization
algorithm for strongly convex functions. In 2018 Annual American Control Conference, ACC
2018, Milwaukee, WI, USA, June 27-29, 2018, pp. 1376-1381, 2018. doi: 10.23919/ACC.2018.
8430824. URL https://doi.org/10.23919/ACC.2018.8430824.
Yann N Dauphin, Angela Fan, Michael Auli Auli, and David Grangier. Language modeling with
gated convolutional networks. arXiv preprint arXiv:1612.08083, 2016.
Aaron Defazio, Francis R. Bach, and Simon Lacoste-Julien. SAGA: A fast incremental gradient
method with support for non-strongly convex composite objectives. In Advances in Neural In-
formation Processing Systems 27: Annual Conference on Neural Information Processing Systems
2014, December 8-13 2014, Montreal, Quebec, Canada, pp. 1646-1654, 2014.
Timothy Dozat. Incorporating nesterov momentum into adam. ICLR Workshop, 2016.
Scott Fujimoto, Herke van Hoof, and Dave Meger. Addressing function approximation error in
actor-critic methods. arXiv preprint arXiv:1802.09477, 2018.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional
sequence to sequence learning. arXiv preprint arXiv:1705.03122, 2017.
Priya Goyal, Piotr Dollar, Ross B. Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola,
Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch SGD: training im-
agenet in 1 hour. CoRR, abs/1706.02677, 2017. URL http://arxiv.org/abs/1706.
02677.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp.
770-778, 2016a.
10
Published as a conference paper at ICLR 2019
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. In Computer Vision - ECCV 2016 - 14th European Conference, Amsterdam, The
Netherlands, October 11-14, 2016, Proceedings, PartIV, pp. 630-645, 2016b. doi: 10.1007/
978-3-319-46493-0∖_38. URL https://doi.org/10.1O07/978-3-319-4 64 93-0_
38.
Geoffrey Hinton, Nitish Srivastava, and Kevin Swersky. Neural networks for machine learning:
Lecture 6a, 2012.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. In Proceedings of the 32nd International Conference on Machine
Learning, ICML 2015, Lille, France, 6-11 July 2015, pp. 448-456, 2015. URL http://jmlr.
org/proceedings/papers/v37/ioffe15.html.
Prateek Jain, Sham Kakade, Rahul Kidambi, Praneeth Netrapalli, and Aaron Sidford. Accelerating
stochastic gradient descent. CoRR, abs/1704.08227, 2017.
Rie Johnson and Tong Zhang. Accelerating stochastic gradient descent using predictive variance
reduction. In Advances in Neural Information Processing Systems 26: 27th Annual Conference
on Neural Information Processing Systems 2013. Proceedings of a meeting held December 5-8,
2013, Lake Tahoe, Nevada, United States., pp. 315-323, 2013.
Rahul Kidambi, Praneeth Netrapalli, Prateek Jain, and Sham M. Kakade. On the insufficiency of ex-
isting momentum schemes for stochastic optimization. In International Conference on Learning
Representations, 2018. URL https://openreview.net/forum?id=rJTutzbA-.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In Proceedings
of 3rd International Conference on Learning Representations, 2015.
Alex Krizhevsky. Learning multiple layers of features from tiny images. Technical report, Citeseer,
2009.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
lutional neural networks. In Advances in Neural Information Processing Systems, pp. 1097-1105,
2012.
David Laibson. Golden eggs and hyperbolic discounting. The Quarterly Journal of Economics, 112
(2):443-478, 1997.
Yann LeCun. The mnist database of handwritten digits. 1998.
Laurent Lessard, Benjamin Recht, and Andrew Packard. Analysis and design of optimization algo-
rithms via integral quadratic constraints. SIAM Journal on Optimization, 26(1):57-95, 2016. doi:
10.1137/15M1009597. URL https://doi.org/10.1137/15M1009597.
Qianxiao Li, Cheng Tai, and Weinan E. Stochastic modified equations and adaptive stochastic
gradient algorithms. In Proceedings of the 34th International Conference on Machine Learning,
ICML 2017, Sydney, NSW, Australia, 6-11 August 2017, pp. 2101-2110, 2017. URL http:
//proceedings.mlr.press/v70/li17f.html.
Kuang Liu. Pytorch cifar. https://github.com/kuangliu/pytorch-cifar, 2017.
Nicolas Loizou and Peter Richtarik. Momentum and stochastic momentum for stochastic gradient,
newton, proximal point and subspace descent methods. CoRR, abs/1712.09677, 2017. URL
http://arxiv.org/abs/1712.09677.
Ilya Loshchilov and Frank Hutter. Fixing weight decay regularization in adam.	CoRR,
abs/1711.05101, 2017. URL http://arxiv.org/abs/1711.05101.
James Lucas, Richard S. Zemel, and Roger Grosse. Aggregated momentum: Stability through
passive damping. CoRR, abs/1804.00325, 2018. URL http://arxiv.org/abs/1804.
00325.
11
Published as a conference paper at ICLR 2019
Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture
models. CoRR, abs/1609.07843, 2016. URL http://arxiv.org/abs/1609.07843.
Ioannis Mitliagkas, Ce Zhang, Stefan Hadjis, and Christopher Re. Asynchrony begets momentum,
with an application to deep learning. In 54th Annual Allerton Conference on Communication,
Control, and Computing, Allerton 2016, Monticello, IL, USA, September 27-30, 2016, pp. 997—
1004, 2016. doi: 10.1109/ALLERTON.2016.7852343. URL https://doi.org/10.1109/
ALLERTON.2016.7852343.
Yurii E Nesterov. A method for solving the convex programming problem with convergence rate o
(1∕k^ 2).In Dokl. Akad. Nauk SSSR, volume 269, pp. 543-547,1983.
Myle Ott, Sergey Edunov, David Grangier Grangier, and Michael Auli. Scaling neural machine
translation. arXiv preprint arXiv:1806.00187, 2018.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Pytorch examples. https:
//github.com/pytorch/examples, 2016.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
pytorch. 2017.
Edmund S Phelps and Robert A Pollak. On second-best national saving and game-equilibrium
growth. The Review of Economic Studies, 35(2):185-199, 1968.
BT Polyak. Some methods of speeding up the convergence of iteration methods. USSR Computa-
tional Mathematics and Mathematical Physics, 4(5):1-17, 1964.
Ben Recht. The best things in life are model free. argmin (personal blog), 2018. URL http:
//www.argmin.net/2018/04/19/pid/.
Sashank J. Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In
International Conference on Learning Representations, 2018. URL https://openreview.
net/forum?id=ryQu7f-RZ.
Nicolas Le Roux, Reza Babanezhad, and Pierre-Antoine Manzagol. Online variance-reducing opti-
mization, 2018. URL https://openreview.net/forum?id=r1qKBtJvG.
Sebastian Ruder. An overview of gradient descent optimization algorithms. arXiv preprint
arXiv:1609.04747, 2016.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael S. Bernstein, Alexander C. Berg, and Fei-
Fei Li. Imagenet large scale visual recognition challenge. International Journal of Computer
Vision, 115(3):211-252, 2015. doi: 10.1007/s11263-015-0816-y. URL https://doi.org/
10.1007/s11263-015-0816-y.
Mark W. Schmidt, Nicolas Le Roux, and Francis R. Bach. Minimizing finite sums with the stochas-
tic average gradient. CoRR, abs/1309.2388, 2013. URL http://arxiv.org/abs/1309.
2388.
Bryan Van Scoy, Randy A. Freeman, and Kevin M. Lynch. The fastest known globally convergent
first-order method for minimizing strongly convex functions. IEEE Control Systems Letters, 2
(1):49-54, 2018. doi: 10.1109/LCSYS.2017.2722406. URL https://doi.org/10.1109/
LCSYS.2017.2722406.
Fanhua Shang, Yuanyuan Liu, James Cheng, and Jiacheng Zhuo. Fast stochastic variance reduced
gradient method with momentum acceleration for machine learning. CoRR, abs/1703.07948,
2017. URL http://arxiv.org/abs/1703.07948.
Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of initial-
ization and momentum in deep learning. In International conference on machine learning, pp.
1139-1147, 2013.
12
Published as a conference paper at ICLR 2019
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems, IROS 2012, Vil-
amoura, Algarve, Portugal, October 7-12,2012,pp. 5026-5033, 2012. doi: 10.1109/IROS.2012.
6386109. URL https://doi.org/10.1109/IROS.2012.6386109.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez,
Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural In-
formation Processing Systems 30: Annual Conference on Neural Information Processing Sys-
tems 2017, 4-9 December 2017, Long Beach, CA, USA, pp. 6000-6010, 2017. URL http:
//papers.nips.cc/paper/7181-attention-is-all-you-need.
Kelvin Xu, Jimmy Ba, Ryan Kiros, Kyunghyun Cho, Aaron C. Courville, Ruslan Salakhutdinov,
Richard S. Zemel, and Yoshua Bengio. Show, attend and tell: Neural image caption generation
with visual attention. In Proceedings of the 32nd International Conference on Machine Learning,
ICML 2015, Lille, France, 6-11 July 2015, pp. 2048-2057, 2015. URL http://jmlr.org/
proceedings/papers/v37/xuc15.html.
Adams Wei Yu, David Dohan, Minh-Thang Luong, Rui Zhao, Kai Chen, Mohammad Norouzi, and
Quoc V Le. Qanet: Combining local convolution with global self-attention for reading compre-
hension. arXiv preprint arXiv:1804.09541, 2018.
Jian Zhang, Ioannis Mitliagkas, and Christopher Re. YelloWfin and the art of momentum tuning.
CoRR, abs/1706.03471, 2017. URL http://arxiv.org/abs/1706.03471.
13
Published as a conference paper at ICLR 2019
Appendices
Organization This paper’s appendices are ordered as follows:
•	Appendix A presents a view of momentum and QHM as discounted sums, and provides the
original motivation for the development of QHM.
•	Appendix B regurgitates Recht (2018)’s excellent exposition of gradient-based optimiza-
tion as PID control, with minor modifications.
•	Appendix C presents analyses of various other algorithms, towards connecting them to
QHM.
•	Appendix D describes the set of all two-state optimization algorithms recovered by QHM.
•	Appendix E briefly discusses a PID control optimization setting by An et al. (2018).
•	Appendix F derives a tight upper bound on the updates of Adam and QHAdam (conse-
quently disproving the bound in Kingma & Ba (2015)), then discusses the implications on
training stability.
•	Appendix G provides miscellaneous derivations that do not cleanly fit in other sections.
•	Appendix H provides discussion and an empirical comparison of QHM and AggMo (Lucas
et al., 2018).
•	Appendix I comprehensively describes the setup of this paper’s parameter sweep and case
study experiments.
•	Appendix J comprehensively presents the results of this paper’s parameter sweep experi-
ments.
14
Published as a conference paper at ICLR 2019
A Discounted sum estimators (original variance reduction
motivation for QHM)
We now provide an interpretation of the momentum buffer as a discounted sum estimator, seeking
to motivate the QHM algorithm from a variance reduction perspective.
A.1 Discounted sums
For a discount function δ : N≥0 → R and a sequence of vectors x0...t ∈ Rp, we define a discounted
sum DSδ (x0...t) as:
DSδ (xo…t) = X δ(i) ∙ xt-i
i=0
When Pti=0 δ(i) = 1 for all t ≥ 0, we call this a discounted sum average. When Pi∞=0 δ(i) = 1,
we call this a discounted sum average (modulo initialization bias).
A.2 Exponential discounting and EWMA
For β ∈ (-1, 1), we define the exponential discount function δEXP,β as:
δEXP,β(i)= (1 - β)βi
and the exponentially weighted moving average EWMAβ (x0...t) as:
EWMAβ(x0...t) = DSδEXP,β (x0...t)
t
= (1- β) ∙X βi ∙ xt-i
The EWMA is a discounted sum average (modulo initialization bias), so it can be viewed as an
estimator of the expectation of a random variable X if xo...t 〜x. Note that the momentum buffer gt
from (1) is precisely an EWMA - specifically, gt = EWMAe WL0…t(θo…t)).
It is well known that the exponential discount function is the only time-consistent (commonly “mem-
oryless”), discount function 一 i.e. for any i,τ ≥ 0, the ratio d(i + T)/d(i) depends only on τ. This
is precisely why the EWMA can be tracked with no auxiliary memory - for example, as in momen-
tum’s update rule.
A.3 EWMA as variance reduction
We now provide the following fact about the covariance of the EWMA when x0...t are random
variables.
Fact A.1 (Limit covariance of EWMA). Assume that x0...t are independent random vectors, each
with the covariance matrix Σ. Then:
t→m∞ Cov[EWMAβ(xo...t)] = (I- ]2 ∙ Σ
Proof. Corollary of Fact A.2.	□
This means that arbitrary variance reduction of the EWMA is possible by increasing β. For example,
β = 0.9 implies that the covariance is reduced to =∙ Σ, and β = 0.99 implies that the covariance
is reduced to +∙ Σ.
This provides an intuitive explanation of momentum as a variance reduction technique. Assuming
that the momentum buffer is normalized (and thus interpretable as an estimator of the gradient),
applying momentum will reduce the variance of the update steps, with higher β leading to more
variance reduction.
15
Published as a conference paper at ICLR 2019
However, the flip side is that higher β induces more bias (informally, “staleness”) in the momentum
buffer with respect to the true gradient, as the momentum buffer becomes extremely slow to update.
Thus, the question arises: can we achieve variance reduction while guaranteeing that recent gradients
contribute significantly to the update step? For this, we must introduce time-inconsistency.
A.4 (Pure) hyperbolic discounting and HWMA
Hyperbolic discounting, first proposed by Chung & Hernstein (1961), is the classical time-
inconsistent discount function in consumer choice. It is commonly used to model individual be-
haviors such as impatience. We consider its use in the setting of stochastic optimization (in place of
the EWMA buffer of momentum).
For constants c, k > 0, we define the hyperbolic discount function as: 12
δH,c,k (i) = 1⅛
and the hyperbolic weighted moving average HWMAc,k (x0...t) as:
HWMAc,k(x0...t) = DSδH,c,k (x0...t)
t1
=c •--------— ∙ Xt-i
乙 1 + ki
i=0
Note that the hyperbolic discount function is time-inconsistent, since:
δH,c,k(i + T) _	1 + ki
δH,c,k (i)	1 + k(i + τ)
depends on both i and τ.
Unlike the EWMA, the HWMA is not a discounted sum average - in fact, P∞=0 δH,c,k(i) = ∞ holds
regardless of choice of c or k. Thus, to use an HWMA of gradients in an optimization algorithm,
c (or the learning rate α) must be decayed at a logarithmic rate. More concerning, however, is the
computational inefficiency of the HWMA; specifically, the sum must be recomputed from scratch at
each iteration from all past gradients. This is unacceptable for use in most practical applications.
However, in preliminary stochastic optimization experiments, we did observe a marked benefit of
HWMA over EWMA (i.e. momentum), limiting the number of past gradients used for tractability.
This indicates that time-inconsistency might be a useful property to have in a stochastic optimizer.
A.5 Quasi-hyperbolic discounting and QHWMA
Quasi-hyperbolic discounting, proposed by Phelps & Pollak (1968) and popularized in consumer
choice by Laibson (1997), seeks to qualitatively approximate the time-inconsistency of hyperbolic
discounting by applying a discontinuous “upweighting” of the current step. Its tractability has re-
sulted in much wider adoption in consumer choice vs. pure hyperbolic discounting, and we find that
it is also more suited for use in practical optimization.
For constants ν ∈ R and β ∈ (-1, 1), we define the quasi-hyperbolic discount function as: 13
δ	1 - νβ i = 0
δQH,ν,β(i)= ν(1 - β)βi i>0
and the quasi-hyperbolic weighted moving average QHWMAν,β (x0...t) as:
QHWMAν,β(x0...t) = DSδQH,ν,β (x0...t)
t
(1 - Ve) ∙ x0 + V(1 - β) ∙ ^X βi ∙ xt-i
t
(1 - V) ∙ x0 + V(1 - β) ∙ ^X βi ∙ xt-i	(5)
12Slightly adapted from the original formulation.
13Significantly adapted from (but still equivalent to) the original formulation.
16
Published as a conference paper at ICLR 2019
The QHWMA, like the EWMA, is a discounted sum average (modulo initialization bias), so it can
also be viewed as an estimator under the same assumptions.
When ν = 1, the QHWMA is precisely the EWMA (with identical β), and the quasi-hyperbolic
discount function is precisely the exponential discount function (and thus time-consistent). When
ν 6= 1, the quasi-hyperbolic discount function, like the hyperbolic discount function, is time-
inconsistent since:
δQH,ν,β (i + T) = J*β) βτ i = 0
δQH,ν,β (i)	[βτ	i > 0
depends on both i and τ ; specifically, i = 0 yields a different ratio than i > 0.
Note from (5) that the QHWMA is a ν-weighted average of the EWMA (with identical β) and x0 .
This means that the QHWMA can be easily computed online by simply keeping track of the EWMA,
thus requiring no additional memory.
A.6 Variance of QHWMA
We now characterize the variance of a QHWMA using this fact:
Fact A.2 (Limit covariance of QHWMA). Assume that x0...t are independent random vectors, each
with the covariance matrix Σ. Then:
ilimCov[QHWMAν,β(xo...t)] = P ∙ ∑
where ρ is defined as:
P =(1-νβ)2 + ▼£
1-β
Proof. Provided in Appendix G.
□
P is essentially a scaling factor for the covariance of the QHWMA. It can be verified that P decreases
(thus inducing variance reduction) with both increasing β and increasing ν.
A.7 Motivating QHM
This leads to our motivation for QHM, which simply replaces the EWMA momentum buffer
with a QHWMA. Starting with any momentum parameterization (ν = 1 and β ∈ (0, 1)), β can be
increased towards variance reduction (i.e. lowering P). Then, ν can be decreased to make the QH-
WMA less biased as a gradient estimator, thus mitigating the aforementioned “staleness” problem.
Note, however, that since decreasing ν will also increase P, we cannot simply decrease ν to zero.
Specifically, any ν < 1 imposes a tight lower bound of (1 - ν)2 on P, regardless of choice of β.
A.8 Momentum and QHM update rules
For completeness, we explicitly write the update rules for the momentum and QHM algorithms.
Momentum The momentum update rule is:
t
θt+ι - θt - α (I - β) ∙ Xβi ∙ VLtt-i(θt-i)	⑹
which can be efficiently written using an auxiliary buffer gt as:
_ , 一、 ____________ʌ , _ .
gt+1 J β ∙ gt + (I - β) ∙ VLt(Ot)
θt+ι - θt - α ∙ gt+1
(1, revisited from Section 2)
(2, revisited from Section 2)
17
Published as a conference paper at ICLR 2019
QHM The QHM update rule is:
t
Θt+1 一 θt- α (1 - Ve) ∙VLt(θt)+ ν(1 - β) ∙ Xβi ∙ VLɪ(θɪ)	⑺
which can be efficiently written using an auxiliary buffer gt as:
gt+1 . β ∙ gt + (1 一 β) ∙ VLt(θt)	(3, revisited from Section 3)
θt+ι J θt 一 α [(1 一 v) ∙ VLt(θt) + v ∙ gt+ι]	(4, revisited from Section 3)
QHM vs. momentum Comparing (2) and (4), QHM may seem at first glance identical to momen-
tum with discount factor vβ. However, replacing the β in (6) with vβ yields:
t
θt+1 - θt 一 α (I- Ve) ∙ X(Ve)i ∙ VLt-i(θt-i)
i=0
t
J θt - α (1 一 Ve) ∙ VLt(θt) + (1 一 vβ) ∙V (Vey	∙VL t-i(θt-i)
S{z} i=1 l^z^}
differs from (7) i=1 differs from (7)
which plainly differs from (7) - most notably, in the exponential discount factor (Ve) for past gradi-
ents. Thus, momentum with discount factor Ve does not recover QHM.
A.9 Related work in variance reduction
Section 4 presents numerous connections to other optimization algorithms that shed light on both
deterministic and stochastic convergence properties of QHM. However, we do not formally analyze
the convergence properties of QHM from a variance reduction standpoint; this remains future work.
Here, we briefly discuss other work in variance reduction.
Finite sums Recently, much effort has been devoted towards reducing the variance of the stochas-
tic gradients used in optimization algorithms. Perhaps the most widely-studied setting is the “finite
sum”, or offline, stochastic optimization setting. Methods analyzed in the finite-sum setting in-
clude SAG (Schmidt et al., 2013), SAGA (Defazio et al., 2014), SVRG (Johnson & Zhang, 2013),
FSVRG (Shang et al., 2017), Katyusha (Allen-Zhu, 2017), and others. We do not comment in detail
on the finite sum setting due to its limited practical applicability to large-scale deep learning; for a
fuller discussion of such methods, see Kidambi et al. (2018).
Momentum as variance reduction Some work in variance reduction has drawn an explicit con-
nection to momentum. For example, Roux et al. (2018) propose a method involving Bayesian up-
dates of gradient estimates, which induces adaptive gradient averaging. The authors note that this
method boils down to momentum with an adaptive e .
18
Published as a conference paper at ICLR 2019
B PID controllers and optimization
u(t) = kP [e(t)] + kI
0
We follow Recht (2018) in describing the connection between PID control and gradient-based opti-
mization.
Continuous PID We slightly adapt the setting from Aastrom & HagglUnd (1995). t denotes time.
There is a setpoint (i.e. target state), r(t), and a process variable (i.e. current state), y(t). The
error of the system is defined as e(t) d=ef r(t) - y(t). A “controller” oUtpUts a control signal u(t),
UsUally towards the goal of making the error zero. The controller’s choice of u(t) affects y(t) in
some Unspecified manner.
A PID controller, parameterized by kP , kI, and kD, Uses the control fUnction:
t e(t')dt] + kD [M]	(8)
Here, the terms in the sqUare brackets are typically referred to as the P, I, and D terms, respectively.
Discrete approximation In discrete time, the setpoint, process variable, and error are trivially
discretized as rt, yt, and et d=ef rt - yt, respectively. The I term, which we label wt, is discretized as:
Wt — wt-1 + et
The D term, which we label vt, coUld be discretized as vt = et - et-1 (first differences). However,
a low-pass filter is often applied to mitigate noise, thUs resUlting in:
Vt — βvt-i + (1 - β)(et - et-i)
We simplify exposition by considering e-1, w-1, and v-1 to be 0.
Finally, the PID control fUnction (8) is trivially discretized as:
Ut = kp ∙ et + kɪ ∙ wt + k。∙ Vt	(9)
Optimization Recht (2018) relates optimization to PID control as follows:
yt =	V-Lt(θt)	;	rt	= 0	; et	==	rt	- yt = -V-Lt(θt)	;	Ut = θt+ι	- θo
That is, the process variable is the stochastic gradient, the controller’s goal is to make this gradient
zero, and the controller achieves this by choosing the next step’s model parameters according to the
update rule θt+ι J ut + θ0. The update rule for a PID control optimizer is thus:
et J -VLt(θt)	Vt J β Vt-1 + (1 - β)(et - et-1)	wt J wt-1 + et
θt+1 J θ0 + kP ∙ et + kI ∙ wt + kD ∙ vt
Recht demonstrates that PID in this setting encapsulates gradient descent, momentum, and NAG;
for example, gradient descent is recovered when kP = kD = 0 and kI = α.
Intuition Finally, to provide some additional intuition, we can state the following fact about the D
term (Vt):
Fact B.1 (D term is gradient and momentum). Vt can be written as:
t
-VLt(θt) + (1 - β) ∙ Xβi ∙VLt-i(θt-i)
Proof. Provided in Appendix G.	□
Thus, theD term is simply a weighted sum of an EWMA of gradients (i.e. momentum buffer) and the
current gradient, and a PID control optimizer’s output is simply a weighted sum of the momentum
buffer, the current gradient, and the sum of all past gradients.
1 - β
β
Vt
19
Published as a conference paper at ICLR 2019
C Connections to other algorithms (in-depth)
This appendix presents a deeper theoretical treatment of Section 4.2 through Section 4.4, deriving
and discussing connections between QHM and various other optimization algorithms.
C.1 Linear operator analysis
Along the lines of Lessard et al. (2016), we consider optimizers as linear operators, interrupted by
a nonlinear step (the gradient evaluation). In this setting, optimizers have b internal state buffers,
which We write as a stacked vector St ∈ Rb∙p. Optimizers accept the current optimizer state (St)
and gradient (VLt(θt)), and they produce the new optimizer state (St+ι) and parameters (θt) using
a square matrix T ∈ R(b+2)p×(b+2)p. 14
Update rule For convenience, we impose the restriction that the output θt can only depend on the
state St. Then, for analytical purposes, the optimizer can be written as the following update rule:
[St+1	0	0]| 一 T [St VLt(θt)	0p]|
[0 0 θt+ι]1 - T [St+ι 0p 0p]|
where 0p denotes the size-p zero vector, 0 denotes throwaway values, and [v1 v2 . . .] denotes
vector stacking.
Coordinate-wise decomposition Since we only consider optimizers that act coordinate-wise (ex-
cept for the gradient evaluation), we can write T as the Kronecker product of a coordinate-wise
transition matrix A ∈ R(b+2)×(b+2) and the identity matrix Ip. That is, T = A 0 Ip.
Then, for t > 0, we can write θt in terms of the initial state S0,{1...b} and all past gradients, using
the last row of various matrix powers of A:
bt
θt = X [(At+1)b+2,i SM + X [(Ai+1)b+2,b+1 ∙ VLl(θt-i)]	(10)
i=1	i=1
C.2 QHM
The internal state of QHM includes two buffers: gt (momentum buffer) and θt (model parameters).
The transition matrix	TQhm, mapping from	[gt	θt	vLt(θt)	0p]| to	[gt+ι	θt+ι	0p	θt]1,
is:
AQHM
β	0	1-β	0-
-ανβ	1	-α(1 - νβ)	0
0	0	0	0
0	1	0	0
TQHM = AQHM 0 Ip
For n > 0, routine computation yields the last row of the (n + 1)-th matrix power:
(AQ+M)4= [-ανβ-βn 1 -α(1-νβn) θ]
Applying (10), the optimizer state θt can be written as:
t
θt = (AQHM)4,1 ∙ g0 + (AQIM)4,2 ∙ θ0 + X(AQ)HM)4,3 ∙ vLt-i(θt-i)
i=1
—
I go+θ0-α ∙ X Qii ∙vL t-i(θt-i)
14Typically, the output would be θt+1 ; however, we lag one step so that the parameters can be specified in
terms of the current-step state. This is done purely for notational convenience.
20
Published as a conference paper at ICLR 2019
In the typical case of g0 = 0, we have:
θt = θ0 - α ∙ XX(1 - Vei) ∙ VLt-i(θt-i)
i=1
(11)
C.3 PID
Recht (2018) draws a strong connection between gradient-based optimization and PID control. We
regurgitate the excellent exposition (with minor modifications) in Appendix B.
Update rule A PID control optimizer, parameterized by kP , kI, kD ∈ R, uses the update rule:
et《-----VLt(Bt)	Vt	- β ∙ vt-1	+ (1 — β)(et —	et-i)	Wt	-	wt-1	+ et
θt+ι - θo + kp ∙ et + kɪ ∙ Wt + k。∙ Vt
Coordinate-wise decomposition The internal state of a PID control optimizer includes four
buffers: et-1 (P term), Wt-1 (I term), Vt-1 (D term), and θ0 (initial parameters). 15
The transition matrix	TPID,	mapping from	[et-1	wt-1	vt-1	θo	VLt(θt)	0p] |	to
[et Wt Vt θo Op θt]l,is:
	0	O	O	O	-1	O
	O	1	O	O	-1	O
APID =	-(I - β)	O	β	O	-(1 - β)	O
	O	O	O	1	O	O
	O	O	O	O	O	O
	kP	kI	k。	O	O	O
TPID = APID X Ip
For n > 0, routine computation yields the last row of the (n + 1)-th matrix power:
(AnID 1)6 = h-kDβn-;(I-β)	kɪ kD β n 1 (AnID1)6,5 o]
where:
n+1	- [kP + kI + (1 - β)kD]
APID 6,5 = - kI - (1 - β)2βn-2kD
n=1
n>1
Applying (10), the optimizer state θt can be written as:
θt = (APID1)6,1 ∙ e-1 + (APID1) 6,2 ∙ WT (APID1) 6,3 ∙ VT + (APIDI)6,4 ∙ θ0
t
+ X(APIDL)6,5 ∙VLt-i(θt-i)
i=1
kDβt-1(1 - β)	n
=------------z-----∙ e-1 + kɪ ∙ w-i + k。β ∙ v-i
β
t
+ θo + X(APIDL)6,5 ∙VLt-i(θt-i)
i=1
Relationship with QHM In the typical case of e-1 = W-1 = V-1 = 0p, we have:
t
θt = θ0 + X(AP+1)6,5 ∙VLt-i(θt-i)
i=1
15The offset of -1 in the P, I, and D term subscripts is purely for convenience.
21
Published as a conference paper at ICLR 2019
Then, equating with (11), we have that QHM is PID with: 16
ανβ kp =	 P	1 - β		kI = α
or that PID is QHM with:		
α = kI	ν=	kp2 =	 kD ∙ kɪ
kD
ανβ2
(1-β)2
Viewing β as a constant, the following restriction holds on the PID coefficients that QHM can
recover:
kD	β
—=------
kp 1 — β
This restriction is looser than those for plain SGD (which has the additional restriction kP = kD =
0), momentum (which has the additional restriction kP /kI = kD/kP), and NAG (which has the
additional restriction kp/k∕ = βk0/kp).
Viewing β as a hyperparameter, QHM can recover all PID coefficients except when kI = 0 (i.e. P,
D, or PD controller), or kp 6= 0 = kD (i.e. PI controller).
To summarize, PID is a superfamily of QHM. Viewing β as a constant, QHM imposes a restriction
on the ratio between kp and kD . Viewing β as a free variable, however, QHM can recover nearly
all PID coefficients.
C.4 SNV
Section 6 of Lessard et al. (2016) describes a “synthesized Nesterov variant” algorithm, which we
call “SNV” for convenience. This algorithm is used to analyze and improve optimizer robustness
under “relative deterministic noise” (i.e. multiplicative noise of the gradient). 17
Update rule SNV, parameterized by γ, β1, β2 ∈ R, uses the update rule: 18
ξt+ι - ξt - Y • ▽£t(θt) + βι(ξt - ξt-ι)
θt+1 - ξt+1 + β2(ξt+1 - ξt)
Coordinate-wise decomposition The internal state of a SNV optimizer includes two buffers: ξt
and ξt-1.
The transition matrix TSnv, mapping from [ξtt ξt-ι VLt(θt) 0p] | to [ξt+ι ξt 0p θt]1, is:
1 + β1	-β1
1	0
0	0
1 + β2	-β2
-γ	0
0	0
0	0
0	0
TSnv = ASNV 0 Ip
For n > 0, routine computation gives us the last row of the (n + 1)-th matrix power:
(Asnv)4 = [ 1⅛ (1 + Xn)	- T⅛ (β + Xn)	- β1(i-β1) (β + Xn)	0i
where:
Xn = β1n (β2 (1 - β1 ) - β1 )
16This is inconsistent with Recht (2018),s derivation by a factor of (1 — β) in kp ,k° and (1 — β)∕β in kɪ.
While (1 - β) is explainable as the difference between a normalized and unnormalized momentum buffer, we
suspect that the extra factor of β in kI is a mistake in the original derivation.
17This is similar to the vanishing gradient assumption used in Loizou & RiChtarik (2017), which removes
the need to consider variance reduction of the gradient.
18The learning rate is α in the original paper; we use γ to avoid confusion with QHM’s α.
22
Published as a conference paper at ICLR 2019
Applying (10), the optimizer state θt can be written as:
t
t+1	t+1	i+1
θt = (TSNV)4,1 ∙ w0 + (TSNV)4,2 ∙ w0 + ʌ, (TSNV)4,3，VLt-"θI)
i=1
1
1-βι
t
-X
i=1
(I+Xt) ∙ ξ0- τ⅛ (β1+Xt) ∙ξ-1
β1(1 - β1) (β1 + Xi) ∙ vLt-i(θt-i)
Relationship with QHM Initialize ξ0 = ξ-1 = θ0 . The optimizer state θt is:
t
θt = θ0 - X β∖(1 — β∖ ) (β + Xi) ∙ vL t-i(θt-i)
Then, equating with (11), we have that QHM is SNV with:
γ= α(1 - β)
β1 = β
β2=(I-V VE
or that SNV is QHM with:
γ
α =-------
1 - βι
V = 1 - 1-包 β2
βι	β2
β = β1
To summarize, QHM and SNV recover each other. By extension, QHM recovers the Robust Mo-
mentum method, which is a specific parameterization of SNV (Cyrus et al., 2018). Moreover, since
Robust Momentum recovers the Triple Momentum of Scoy et al. (2018), QHM also recovers Triple
Momentum.
C.5 ACCSGD
Jain et al. (2017) and Kidambi et al. (2018) point out various failures of momentum and NAG in the
setting of stochastic least squares optimization. This motivates their proposal of the AccSGD algo-
rithm, which yields faster convergence over momentum and NAG in certain least-squares regression
settings. Here, we discuss the formulation of Kidambi et al. (2018).
Update rule AccSGD, parameterized by δ > 0, κ > 1, ξ ≤ √κ, and e < 1, uses the update rule:
W 套∙ Wt
κ
θt+1 = wt+1- K¾ hwt- δ ∙vLt(θt)i +
κδ ∙VLt(θt)
κ
一Γ^Ξ ∙ wt+ι
κ + ξ
Coordinate-wise decomposition The internal state ofan AccSGD optimizer includes two buffers:
Wt (a buffer) and Wt (the iterate, identical to θt).
The transition matrix	TAccSGD,	mapping from
[Wt+1 Wt+1	0p θt]1, is:
[Wt	Wt	VLt(θt)	0p]| to
AAccSGD
W -δeξ 0
κ+e¾∕κ	-δ ≤+2ξ2	0
κ+ξ	κ+ξ
0	00
1	00
TAccSGD = AAccSGD X Ip
23
Published as a conference paper at ICLR 2019
For n > 0, routine computation gives us the last row of the (n + 1)-th matrix power:
(An+1 ) — h κ-e2ξ-(κ-e2ξ)χn	e(κ+∈ξ) + (κ-e2ξ)χn	e(ι+ξ)-(eξ-i)χn	]
kAAccSGD； 4 =[----K(T+)------- ------4Γ+^------ -δ--------1+------ 0I
where:
_ κ - e2ξ
X =	I^^F
κ+ξ
Applying (10), the optimizer state θt can be written as:
t
θt = (tACcSgd)4,1 ∙ w0 + (TAccSGD)4,2。w0 + X (TA+cSgd)4,3。^Lt-i(θt-i)
i=1
K - E2ξ - (K - E2ξ) Xt
K(1 + E)
• W0 +
E(K + Eξ)+ (K - E2ξ) Xt
K(1 + E)
• w0
e(1+ ξ) -(Eξ - 1)χi
1 + E
V-Lt-i(θt-i)
Relationship with QHM Fix E ∈ (0,1), and initialize w° = w0 = θ0. The optimizer state θt is:
θt
e(1 + ξ)-(Eξ - 1)χi
1 + E
__ʌ , _ 、
VLt-i(θt-i )
Then, equating with (11), we have that QHM is AccSGD with:
δ = α(1 - ν)
(β + E)(EV + 1)
(I- V)(I- β)
EV + 1
E(I - V)
or that AccSGD is QHM with:
δE(1+ ξ)
1 + E
α
ν
Eξ -1
e(1+ ξ)
K - E2ξ
K + Eξ
β
AccSGD cannot recover NAG Based on the above analysis, NAG (i.e. V = β) is recovered
when ξ = ±(1 — E +，4k + (1 — e)2).19 This disproves the claim in Kidambi et al. (2018) that
AccSGD recovers NAG when ξ = √K. In fact, we demonstrate that AccSGD cannot recover NAG
at all. For E ∈ (0,1) and the aforementioned value of ξ, We have that ξ > √K:
ξ 二 21E(1 - E + P4k +(1-e)2 ) > 21E P4k +(1-e)2
2e
> √K
Since AccSGD requires that ξ ≤ √K and that E ∈ (0,1)20, AccSGD cannot recover NAG.
To summarize, QHM recovers AccSGD. In the reverse direction, AccSGD does not recover QHM;
specifically, we disprove the claim in Kidambi et al. (2018) that AccSGD recovers NAG. Since
QHM recovers NAG, AccSGD cannot fully recover QHM.
19Empirical simulations confirm this finding.
20The recommended value for is 0.7 (Kidambi et al., 2018).
24
Published as a conference paper at ICLR 2019
D General two-state optimizer
This appendix describes a generic two-state optimizer (“TSO”) where one of the states is the iterate
(θt) and the other is an auxiliary buffer (at). The optimizer is parameterized by h, k, l, m, q, z ∈ R,
and the update rule is:
at+1 - h ∙ at + k ∙ θt + l ∙ VLt(θt)
Θt+1 J m ∙ at + q ∙ θt + Z ∙ VLt(θt)
We can write this as a transition matrix TTSO ∈ R3×3 :
hkl
TTSO = m q z
000
To simplify further derivations we diagonalize TTSO as:
φ = (h - q)2 + 4km
ψ = km - hq
	-lq-kz	h —q一φ	h —q+φ-
	ψ	2m	2m
QTSO =	hz — lm ψ	1	1
	1	0	0
00	0
Λtso = 0	21 (h + q - φ)	0
0	0	1 (h + q + φ)
TTSO = QTSO ΛTSO QT-S1O
Relationship with QHM If ψ = 0, φ = 0, φ ≤ 1, ɪ (h + q + φ) = 1, h 一 q + φ = 0, and
1 - l = 1 (h + q - φ), then QHM implements the TSO optimizer with:
(2 ― (h + q ― φ))ψ
(h + q - φ)(lq - kz)
α
] [(h - q - φ)(lm - hz) + 2m(lq - kz)]
2ψφ
2m(lq - kz)
(h - q - φ)(lm - hz) + 2m(lq - kz)
β = 2(h + q - φ)
Proof. We can write down the unrolled TSO update rule for θt, as follows:
t-1
θt J (TTSO)2,1 ∙ a0 + (TTSO)2,2 ∙ θ0 + X(TTSO)2,3 ∙ VLiR)
i=0
Similarly, for QHM we can define a transition matrix TQHM ∈ R3×3 that advances state
[gt θt VLt(θt)] as:
β 0	(1 - β)
TQHM = -ανβ 1 -α(1 - νβ)
00	0
Thus, the unrolled update rule for QHM takes the following form:
t-1
θt J (TQHM)2,1 ∙ g0 + (TQHM)2,2 ∙ θ0 + X(TQHM)2,3 ∙ VLiR)
i=0
25
Published as a conference paper at ICLR 2019
Now we match the corresponding coefficients in both of the update rules to establish dependencies:
(TQHM)2,3 ∙ VLi(θi) = (TtsO)2,3 ∙ VLi(θi) ∀i ∈ [0,t - 1]
(TQHM)2,1 ∙ g0 + (TQt
HM)2,2 ∙ θ0 = (TtSO)2,1 ∙ a0 + (TtSO)2,2 ∙ θ0
By solving the first equation we can establish values for α, β, and ν:
(TQt-HMi )2,
(TQt-HMi )2,
,3
,3
-α(1 - νβt-i)
= (TTtS-Oi)2,3 ∀i∈ [0,t-1]
= (QTSOΛtT-SOiQT-S1O)2,3	∀i∈ [0,t-1]
1
=2ψφ (ATSO)2,2 [(h - q + O)(Im - hZ) + 2m(lq - kZ)]
1
- 2ψφ (ATSO)3,3 [(h - q - φ)(lm - hZ) + 2m(lq - kZ)] ∀i ∈ [0,t - 1]
Per our assumption (Λtso)3,3 = 21 (h + q + φ) = 1 and h — q + φ = 0, we can recover the following
relationships:
β = (Λtso)2,2 = 2 (h + q — φ)
α = i^φφ [(h — q — φ)(lm — hz) + 2m(lq — kz)]
2m(lq — kZ)
(h — q — φ)(lm — hZ) + 2m(lq — kZ)
We can solve the second equation to find g0 :
(TQHM)2,1 ∙ g0 + (TQHM)2,2 ∙ θ0 = (TtSO)2,1 ∙ a0 + (TtSO)2,2 ∙ θ0
1	— βt	m t	t
—αβν ι - § ∙ g0 + θ0 = φ [(ATSO)3,3 - (ATSO)2,2〕∙ a0
+ 2φ [(ATSO)2,2(h - q + φ) - (ATSO)3,3(h - q - φ)] ∙ θ0
Given that (ATSO)3,3 = 1 and h 一 q + φ = 0 =⇒ h — q — φ = —2φ, We can simplify:
1	— βt	m
—αβν------— ∙ go + θ0 = —(1 ― β ) ∙ a0 + θ0
1 — β	φ
(1 — β)m
g0
αβνφ	a0
(2 — (h + q — φ))ψ ^
(h + q — φ)(lq — kz) 00
—
g0
—
as desired.
□
26
Published as a conference paper at ICLR 2019
E	An alternative PID setting
We very briefly comment on An et al. (2018)’s PID control setting.
Update rule An et al. (2018)’s PID control optimizer, parameterized by r, kD , β > 0, uses the
following update rule: 21
et《----VLt(θt)	Vt  β ∙ vt-1 - (1 - β)(et - et-i)	Wt - β ∙ wt-i + r ∙ et
Ut — Wt + kD ∙ Vt
θt+ι - θt + Ut
Discussion This setting departs somewhat from typical PID control, in that the signal ut controls
the derivative of the controller’s output (i.e. θt+1 - θt) rather than the output itself (i.e. θt+1 - θ0).
To avoid parameter blowup, this formulation necessitates the addition of exponential decay to the I
term, with discount factor β . 22
The I term thus becomes the momentum buffer. However, recall from Fact B.1 that the D term is a
weighted sum of the momentum buffer and the P term. It follows that the D term is a weighted sum
of the P and I terms, and that this setting is degenerate (either “PI” or “PD”).
As a consequence, the proposed PID algorithm of An et al. (2018) is less expressive than that
of Recht (2018). Specifically, applying Fact B.1 demonstrates a mapping into QHM:
α = r	V =1 - kD(I - Be	β = unchanged
1	- β	rβ
Efficiency This PID control optimizer is costlier than QHM. It requires 2 auxiliary buffers of mem-
ory. Computationally, it requires 2 in-place scalar-vector multiplications and 5 scaled vector addi-
tions per update step.
21The exponential discount is α in the original paper; we use β to avoid confusion.
22One final oddity is that the D term (vt) calculates the negation of the derivative.
27
Published as a conference paper at ICLR 2019
F	(QH)Adam’ s update bound
This appendix elaborates on Adam and QHAdam’s stability properties through the lens of a step
size upper bound.
It is well known that the training process for deep learning models can often “explode” due to a very
small number of large parameter updates. With Adam, these large updates can occur if there exist
parameters whose stochastic gradients are almost always near zero but incur rare “spikes”. 23. This
is because the square root of the second moment estimate, used in normalizing the gradient for the
update step, will be far below the magnitude of these spikes.
There are three main ways to address this instability:
•	Firstly, one can simply decrease the learning rate α. However, this may be undesirable due
to slower training.
•	Secondly, one can increase the hyperparameter. However, the appropriate setting of
depends on the exact magnitudes of these gradient spikes, which is often unknown. Setting
too high effectively turns Adam into SGD. Thus, setting often reduces to guesswork.
•	Thirdly, one can clip gradients. However, the appropriate magnitude of the gradient clip-
ping also depends on the stochastic gradient distribution. Thus, this solution also involves
a fair amount of guesswork.
However, Adam does provide a useful guarantee - unlike SGD, Adam has an upper bound on the
per-step update (Kingma & Ba, 2015). This upper bound is independent of the gradient distribution
(or even temporal correlation), depending only on the hyperparameters α, β1, and β2. Thus, no
matter the gradient distribution, Adam will restrict the magnitude of the per-step updates to some
known constant. Kingma & Ba (2015) intuitively describe this bound as “establishing a trust region
around the current parameter value”.
We show that the step size upper bound claimed in Section 2.1 of Kingma & Ba (2015) is incor-
rect, by providing the correct tight bound for both Adam and QHAdam. We then demonstrate that
with QHAdam, one can lower the maximum per-step update (and thus improve stability) simply by
lowering ν2 to be below 1.
F.1 Setting
We make two simplifications. Firstly, we fix = 0. 24 Secondly, we remove the bias correction of
the moment estimators (i.e. We use g0+ι J gt+ι and s；+、J st+ι).
In this setting, QHAdam applies the following update rule:
θt+ι → θt — α ∙
gt+1
where:
t
gt+ι = (I - VI) ∙ VL√t(θt) + VI(I -eI) ∙ Xβi ∙ V.Lt-i(θt-i)
t
st+1 = (1 — V2)(VLt(θt))2 + V2(1 — β2) ∙ Xβ2(VLt-i(θt-i))2
i=0
(12)
(13)
F.2 Implicit update bound
We now bound QHAdam’s update (before scaling by α) by a constant dependent only on β1, β2, V1,
and V2 :
23Somewhat more concretely, a stochastic gradient is “spiky” if its distribution has extremely large higher-
order cumulants relative to its typical magnitudes.
24The analysis with free follows the same approach but is somewhat messier.
28
Published as a conference paper at ICLR 2019
Fact F.1 (QHAdam tight upper bound on update). Assume that St+ι is nonzero at each coordinate
and that 0 < βι < √β2 < L Then, thefollowing per-coordinate tight upper bound holds:
(1-νιβι)2	MeI(I-βI)]2 [1-(β
1 — V2β2 +	V2(1 — β2)(β2 — β2)
t
Proof. Firstly and without loss of generality, we can treat the gradients as single coordinates xi ∈ R.
That is, Xi = NLi(θi) ∈ R for i ∈ [0,t].
We perform the following simplification of (12) and (13):
t
gt+1 = (I - VIeI) ∙ Xt + VI(I - βI) ∙X ei ∙χι	(14)
t
3t+1 = (I- ν2e2) ∙ x2 + ν2 (I- β2) ∙ ^X β2 ∙ x2-i	(15)
i=1
一	∙ ・	-	- - 一	~	■	∙	. g2l.	.................一 -	一
We now Wish to find the values of X2 that maximize it+1. Applying (14) and (15), these values are
characterized by the following first-order conditions:
Xi
St + 1
gt + 1
§t + 1
gt + 1
νι(1-βι)βi
ν2(l-β2)βi
1-νιβι^∣
1-ν2β21
i<t
i=t
(16)
…	■	∙	32「 .	.	一	........ ~ 一	•一一 一、
Since the quantity jt+1 is invariant to scalar multiplication of all X2, we can simplify (16) to:
f νι(1-βι)βi
V ν2(i-β2)βi
1 1-νιβι
11-ν2β2
i<t
i=t
(17)
Plugging the values of Xi from (17) into (14) and (15) yields:
2
gt+1
max〜
χ0...t st+1
(1 - νιβι)2
1 — V2 e2
[νιβι(1 — βι)]2 1 —停)‘
ν2(1 - 82)(82 — e2)
The desired result follows immediately.
Limit case Consider the limit case oft → ∞. Then, the bound in Fact F.1 simplifies to:
gt+1
≤ I(I - VIβI)2 ]	[ν1β1(I — βI)]2
∞ — V 1 — ν2β2	ν2(1 — β2)(β2 — e2)
(18)
For vanilla Adam (i.e. V1 = V2 = 1), (18) simplifies further to:
gt+1
≤ (I- β1)]∕(1 — e2βe2 -^W)
(19)
□
Note that since the bound in (19) is tight, this result contradicts the claim in Section 2.1 of
Kingma & Ba (2015) that Adam,s per-coordinate step size is bounded above by α ∙ max{1, (1 一
βι)∕√1 — 82}.25 In the following discussion, we use the correct bounds from (18) and (19).
25The difference can be rather large - for example, for the recommended Adam parameters of βι = 0.9 and
β2 = 0.999, Kingma & Ba (2015) claim an upper bound of . 3.16 ∙ α, while (19) implies a tight bound of
.7.27 ∙α.
29
Published as a conference paper at ICLR 2019
F.3 Discussion
The recommended vanilla Adam setting ofβ2 = 0.999 in Kingma & Ba (2015) makes the right-hand
side of (19) to be large, and various work has employed Adam with a significantly lower β2 ; e.g.
0.98 (Vaswani et al., 2017; Ott et al., 2018). 26 Decreasing β2 is undesirable, often slowing down
training. 27 Moving from Adam to QHAdam, an alternative solution is to decrease ν2 to be below
1. This decreases the right-hand side of (18), up to a point, and thus imposes a tighter constraint on
the magnitudes of updates than the vanilla Adam setting of ν2 = 1. Fig. 3 shows an example of this
phenomenon using a fixed ν1, β1, and β2.
Figure 3: Bound from (18), fixing ν1 = 0.8, β1 = 0.95, and β2 = 0.98, and varying ν2.
26We performed experiments on these models indicating that increasing β2 far beyond 0.98 led to training
explosion. We suspect that these instability issues are especially prevalent in settings with rare inputs or labels,
such as machine translation.
27In proposing the AdamNC algorithm, Reddi et al. (2018) suggests that β2 should be high to capture a
sufficiently long history of past gradients.
30
Published as a conference paper at ICLR 2019
G Miscellaneous derivations
This appendix provides miscellaneous derivations that do not cleanly fit elsewhere.
Fact A.2 (Limit covariance of QHWMA). Assume that x0...t are independent random vectors, each
with the covariance matrix Σ. Then:
ilimCov[QHWMAν,β(xo...t)] = P ∙ ∑
where ρ is defined as:
P =(1-νβ)2 + 叵—
1-β
Proof. Due to the independence assumption, the covariance matrix of the QHWMA for t > 0 is
simply:
t
Cov[QHWMAν,β(x0...t)] = XδQ2H,ν,β(i) Σ
i=0
t
=(1 - IVeY + X(V(I- β)βi)2 Σ
i=1
t
= (1-νβ)2+(ν(1-β))2Xβ2i Σ
i=1
= …2 +V VQTe)蓝-泮)卜
1 - β2
The desired result follows immediately.	□
Fact B.1 (D term is gradient and momentum). vt can be written as:
1 — β
β
vt
t
-VL√t(θt) +(I- β) ∙ X βi
i=0
__ʌ , _ 、
VL t-i(θt-i)
Proof. We expand vt as follows, recalling that v-1 = 0:
Vt =f β ∙ vt-i + (1 — β)(et — et-i)
t
=(I - β) ∙ ^X βi (et-i - et-i-1)
i=0
(20)
We then proceed by separating out the sum in (20), recalling that e-1 = 0:
(1-β)
(1-β)
t
et- X βi-1 (1 - β) ∙ et-i
i=1
et-----βj^ ∙ et - yX βi-1(1 - β) ∙ et-i
β	i=0
1 - β
β
t
et-(1- β) X βi ∙ et-i
i=0
(21)
The desired result follows by substituting et = -VLt(θt) into (21).
□
31
Published as a conference paper at ICLR 2019
H QHM and Aggregated Momentum
We perform a brief empirical comparison of QHM and Aggregated Momentum (AggMo), proposed
by Lucas et al. (2018). In short, we find that for an autoencoder task, we can take the optimal
parameterization of AggMo from an extensive parameter sweep, and from that we can construct a
QHM parameterization by hand which outperforms the optimal AggMo parameterization.
H.	1 Algorithm: Aggregated Momentum (AggMo)
AggMo is a many-state optimizer that aggregates multiple momentum buffers in its update rule.
AggMo update rule The AggMo algorithm, parameterized by discount factors β ∈ RK and learn-
ing rate γ > 0, uses the update rule:
g(+)ι 一 β(i) ∙ g(i) + VLt(θt)	for i ∈ [1, K]	(22)
1K
θt+1 J θt - Y K ∙ Eg(+)1	(23)
K i=1
Intuitively, AggMo maintains K unnormalized momentum buffers with different discount factors
and uses the average of these buffers in the update rule.
H.2 Empirical comparison of QHM and AggMo
Experimental setup: EMNIST autoencoders We perform the autoencoder experiments of Lucas
et al. (2018) using the authors’ implementation, 28 with two changes:
1.	We replace the MNIST dataset (LeCun, 1998) with the richer digits subset of the EMNIST
dataset (Cohen et al., 2017). We hold out 10% of the training dataset for validation.
2.	We change the minibatch size from 200 to 256 for computational efficiency.
Parameterizing AggMo Lucas et al. (2018) conduct a sweep over parameterizations of AggMo.
Performing the same sweep, we find that the best parameterization of AggMo uses discount factors
β = [0, 0.9, 0.99, 0.999] and learning rate γ = 0.1. We name this parameterization “AggMo-Best”.
Parameterizing QHM We now apply intuition to convert AggMo-Best into a QHM parameteriza-
tion, which we name “QHM-Converted”. We calculate the effective step size α of AggMo-Best:
4
4 ∙ X
α
40[1 + 10 + 100 + 1000]
27.775
We round up and use α = 28 as the learning rate for QHM-Converted.
From Section 7.1, our rule of thumb for QHM is ν = 0.7 and β = 0.999. However, noting that this
rule of thumb is toward replacing momentum/NAG with discount factor 0.9, and observing that the
best NAG parameterization reported by Lucas et al. (2018) uses discount factor 0.99, we instead use
ν = 0.97 and β = 0.999 for QHM-Converted.
In summary, the parameterization of QHM-Converted is α = 28, ν = 0.97, and β = 0.999, and no
optimization or parameter sweeps on this task were performed to construct this parameterization.
Results Fig. 4 and Table 4 present the performance of AggMo-Best and QHM-Converted on the
autoencoder task. QHM-Converted outperforms AggMo-Best on the mean squared error (MSE)
metric over the training, validation, and testing datasets.
28https://github.com/AtheMathmo/AggMo
32
Published as a conference paper at ICLR 2019
Table 4: Final performance on EMNIST autoencoder task
Optimizer	Training MSE	Validation MSE	Testing MSE
AggMo-Best	2.0823±0.0312	2.2895±0.0236	2.2827±0.0247
QHM-Converted	L7330±0.0W2-	2.0921±0.0078	2.0851±0.007Γ-
200	400
Epochs
AggMo-Best
----QHM-Converted
Figure 4: Training and validation MSE of AggMo-Best and QHM-Converted over the first 500
epochs. The shaded region corresponds to one standard deviation over 15 runs.
H.3 Discussion
To recap, we take the optimal AggMo parameterization from an extensive sweep, we convert that
parameterization by hand to one for QHM, and we find that the latter outperforms the former on this
autoencoder task.
These results indicate that using multiple momentum buffers with an arbitrary weighting scheme
(i.e. AggMo with K > 2) provides negligible benefit over using a single slow-decaying momentum
buffer with an appropriate weight (i.e. QHM with high β and appropriate ν).
Passive damping Lucas et al. (2018) offer an interpretation of AggMo as passive damping for
physical systems. In this interpretation, fast-decaying momentum buffers “dampen” the oscillations
of slow-decaying momentum buffers by providing velocity in an opposite direction.
In this context and considering these results, we conjecture that the current gradient already pro-
vides adequate damping for a slow-decaying momentum buffer, and that the damping provided by
additional momentum buffers is of marginal value.
Extended AggMo Lucas et al. (2018) propose an extension of AggMo which allows for alternate
weighting schemes via separate per-buffer learning rates. The learning rate becomes a vector γ ∈
RK and (23) becomes the following:
1K
θt+ι 一 θt - K ∙ £ γ()∙ gt+ι	(24)
i=1
Lucas et al. (2018) motivate this extension by the recovery of NAG. In fact, we observe that this
extension, with K = 2 and discount factors [0, β], recovers QHM as well.
In independent preliminary experiments on different tasks, we found that various alternate weighting
schemes of multiple momentum buffers (i.e. various parameterizations of extended AggMo with
K > 2) did not result in material improvements over the single momentum buffer. However, this
preliminary investigation was neither rigorous nor conclusive. Lucas et al. (2018) do not empirically
explore these alternate weighting schemes, and it is unclear how to do so both comprehensively and
efficiently, since the number of hyperparameters scales linearly with the number of momentum
buffers K .
Toward improving the usability of extended AggMo, we suggest as future work to investigate the-
oretically grounded or empirically tractable methods to determine good weighting schemes for ex-
tended AggMo. However, given the added costs and complexity of AggMo (both standard and
extended), we surmise in the meantime that QHM may be preferable for most practical applications.
33
Published as a conference paper at ICLR 2019
I Full details of experimental setup
Environment All experiments use Python 3.7 and PyTorch 0.4.1 (Paszke et al., 2017). Experi-
ments are run on a mix of NVIDIA P100 and V100 GPUs, along with a mix of CUDA 9.0 and
9.2.
I.1	Parameter sweep experiments
Common settings (all experiments) Training occurs over 90 epochs (minibatch size 64). The first
epoch uses linear warmup of the learning rate α (i.e. α starts from zero and grows to its “regular”
value by the end of the epoch). Each training run uses a single GPU.
Each parameterization is run 3 times with different seeds, and we report training loss, training top-1
error, and validation top-1 error.
Common settings (QHM experiments) We use a step decay schedule for the learning rate: α ∈
{1, 0.1, 0.01}. That is, the first 30 epochs use α = 1.0, the next 30 epochs use α = 0.1, and the final
30 epochs use α = 0.01. 29
We sweep over ν and β using the following two-dimensional grid:
ν ∈ {0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995, 0.998, 0.999, 0.9995, 1}
β ∈ {0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995, 0.998, 0.999, 0.9995}
Note that this grid encapsulates numerous parameterizations of plain SGD, momentum, and NAG
(specifically, all parameterizations with the β values enumerated above).
Common settings (QHAdam experiments) We fix α = 0.001, β2 = 0.999, and = 10-8, as
suggested in Kingma & Ba (2015). We also fix ν2 = 1.
We sweep over ν1 and β1 using the same grid as for QHM’s ν and β.
I.1.1	Experiment: Logistic-EMNIST-QHM
Model The model is multinomial logistic regression with pixel vector input.
Task The task is digit recognition over the EMNIST dataset - specifically, the digits subset (Cohen
et al., 2017).
Optimizer The model is optimized with QHM. The optimization objective is cross-entropy loss,
plus L2 regularization with coefficient 1 ∙ 10-4.
I.1.2	Experiment: Logistic-EMNIST-QHAdam
Model Same as in Logistic-EMNIST-QHM.
Task Same as in Logistic-EMNIST-QHM.
Optimizer The model is optimized with QHAdam. The optimization objective is the same as in
Logistic-EMNIST-QHM.
I.1.3	EXPERIMENT: MLP-EMNIST-QHM
Model The model is a multilayer perceptron (specifically, 3 layer feed forward network) with pixel
vector input. The hidden layer sizes are 200, 100, and 50 units, and all hidden units are tanh non-
linearities. The final layer is followed by softmax.
Task Same as in Logistic-EMNIST-QHM.
Optimizer Same as in Logistic-EMNIST-QHM.
29These learning rates may seem high, but recall that the effective step size is identical to that of “typical”,
unnormalized momentum/NAG with α ∈ {0.1, 0.01, 0.001} and β = 0.9.
34
Published as a conference paper at ICLR 2019
I.1.4	EXPERIMENT: MLP-EMNIST-QHADAM
Model Same as in MLP-EMNIST-QHM.
Task Same as in MLP-EMNIST-QHM.
Optimizer Same as in Logistic-EMNIST-QHAdam.
I.1.5	Experiment: RN18-CIFAR10-QHM
Model The model is a 18-layer convolutional residual network with preactivations (He et al.,
2016b).
Task The task is image recognition on the CIFAR-10 dataset (Krizhevsky, 2009).
Optimizer The model is optimized with QHM. The optimization objective is cross-entropy loss,
plus L2 regularization with coefficient 1 ∙ (5 ∙ 10-4).
Other details The implementation generally follows Liu (2017). Data augmentation includes hor-
izontal flipping at random, as well as random 32-pixel crops with 4-pixel padding. For batch nor-
malization (Ioffe & Szegedy, 2015), we use online calculation of moments with 0.99 exponential
decay.
I.1.6	Experiment: RN50-ImageNet-QHM
Model The model is a 50-layer convolutional residual network (He et al., 2016a).
Task The task is image recognition on the ILSVRC2012 (“ImageNet”) 1000-class dataset (Rus-
sakovsky et al., 2015).
Optimizer The model is optimized with QHM. The optimization objective is cross-entropy loss,
plus L2 regularization with coefficient 1 ∙ 10-4.
Other details The implementation generally follows Paszke et al. (2016). Data augmentation in-
cludes horizontal flipping at random, as well as random 224-pixel crops. Validation is performed on
224-pixel center crops. For batch normalization, we use online calculation of moments with 0.99
exponential decay. The model is trained with half-precision floating point.
I.2	Case studies
I.2.	1 Experiment: RN 1 5 2-ImageNet- QHM
Model The model is a 152-layer convolutional residual network (He et al., 2016a).
Task Same as in RN50-ImageNet-QHM.
Optimizer (baseline) We use the baseline configuration (NAG with size-256 minibatches) de-
scribed in Goyal et al. (2017). Specifically, the learning rate schedule is α = 0.1 for the first 30
epochs, α = 0.01 for the next 30 epochs, α = 0.001 for the next 20 epochs, and α = 0.0001 for
the final 10 epochs. The optimization objective is cross-entropy loss, plus L2 regularization with
coefficient 2 ∙ 10-4. The only departure from Goyal et al. (2017) is that we employ a first-epoch
linear warmup of α (as in the parameter sweep experiments).
Optimizer (QHM) The non-baseline optimizer is QHM with ν = 0.7 and β = 0.999. Following
Section 7.1, we increase the learning rate (α) 10-fold. All other details are identical to the baseline.
Evaluation For each optimizer, we run 3 seeds and report validation top-1 error.
Other details See RN50-ImageNet-QHM for implementation details.
I.2.2	Experiment: FConvLM-WikiText103-QHM
Model The model is the GCNN-14 variant of the gated convolutional language model described in
Dauphin et al. (2016).
Dataset The task is language modeling on the WikiText-103 language dataset (Merity et al., 2016).
35
Published as a conference paper at ICLR 2019
Optimizer (baseline) For the baseline, we use the configuration described in Dauphin et al. (2016).
Specifically, the model is optimized with 60 epochs of NAG (β = 0.99). We initialize the learning
rate to α = 1.0, and we halve it when validation loss begins to increase. The optimization objective
is adaptive cross-entropy, plus direct weight decay with coefficient 5 ∙ 10-6. We also clip gradient
norm with maximum norm of 0.1.
Optimizer (QHM) The non-baseline optimizer is QHM with ν = 0.98 and β = 0.998. Following
Section 7.1, we increase the initial learning rate (α) 100-fold. All other details are identical to the
baseline.
Evaluation For each optimizer, we run 10 seeds and report validation perplexity.
Other details The implementation is exactly that of fairseq-py (Gehring et al., 2017). We train
each model on 8 GPUs with half-precision floating point.
I.2.3	Experiment: TD3-MuJoCo-QHAdam
Model We use the Twin Delayed Deep Deterministic Policy Gradients (TD3) algorithm (Fujimoto
et al., 2018) for actor/critic learning. Both the actor and the critic are represented as multilayer
perceptrons.
Task We use a suite of MuJoCo continuous control tasks (Todorov et al., 2012). In particular, we
perform evaluation on the following environments: HalfCheetah, Hopper, Walker2d, Ant, Reacher,
InvertedPendulum, and InvertedDoublePendulum.
Optimizer (baseline) For the baseline, we use Adam with the default parameters (α = 0.001,
β1 = 0.9, β2 = 0.999, and = 10-8) as in Fujimoto et al. (2018). We train for 106 iterations.
Optimizer (QHAdam) The non-baseline optimizer is QHAdam. We set ν1 = 0.9, ν2 = 1, and
otherwise leave the baseline setting unchanged.
Evaluation For each optimizer, we run 10 seeds. For each seed, we report average reward (on 10
episodes) every 5000 iterations of training, following Fujimoto et al. (2018).
Other details We use Fujimoto et al. (2018)’s open-sourced implementation 30, along with version
2 of OpenAI Gym (Brockman et al., 2016).
I.2.4	Experiment: TF-WMT 1 6ENDE- QHAdam
Model We use a Transformer-based model (Vaswani et al., 2017) described in Ott et al. (2018).
Task We train our models on a filtered version of the WMT16 English-German machine translation
dataset as in Vaswani et al. (2017), and evaluate on newstest14 for English-German. Our evaluation
setup is identical to the one in Ott et al. (2018).
Optimizer (baseline) For the baseline, we use Adam (β1 = 0.9, β2 = 0.98, and = 10-8) as in
Ott et al. (2018), training over 70 epochs. We use the same learning rate schedule as in Vaswani et al.
(2017) and Ott et al. (2018). Specifically, we increase the learning rate from 10-7 to 10-3 linearly
for 4000 steps, then decay it proportionally to the inverse square root of the number of steps. We
optimize the label smoothed cross-entropy loss as in Vaswani et al. (2017), with label smoothing of
0.1.
Optimizer (QHAdam) We use QHAdam (ν1 = 0.8, β1 = 0.95, ν2 = 0.7, β2 = 0.98, and
= 10-8) as a non-baseline optimizer. The other settings are identical to the baseline.
Evaluation For each optimizer, we run 10 seeds and report validation perplexity and validation
BLEU scores. We observe that 4 seeds for the baseline Adam optimizer “explode” (fail to converge).
Thus, we only consider the 6 best seeds for each optimizer.
Other details We use Ott et al. (2018)’s open-sourced implementation in fairseq-py (Gehring et al.,
2017). We train each model on 8 GPUs with half-precision floating point. Note that Ott et al. (2018)
uses 128 GPUs; to eliminate this discrepancy and precisely reproduce the training environment, we
accumulate gradients over 16 minibatches before each optimization step.
30https://github.com/sfujim/TD3
36
Published as a conference paper at ICLR 2019
J	Full parameter sweep results
Fig. 5 shows summary graphs for all parameter sweep experiments. These summary graphs display
selected parameterizations and optimal parameterizations of both the vanilla and QH algorithms.
Full details of experimental settings can be found in Appendix I.
Since each experimental setting contains nearly 200 parameterizations with 3 seeds each, we cannot
fully present the data with graphs or tables. Thus, we provide data files describing all runs in CSV
format. 31
(a) Logistic-EMNIST-QHM train-(b) Logistic-EMNIST-QHM train-(c) Logistic-EMNIST-QHM vali-
ing loss	ing error	dation error
(d) Logistic-EMNIST-QHAdam(e) Logistic-EMNIST-QHAdam(f) Logistic-EMNIST-QHAdam
training loss	training error	validation error
(g) MLP-EMNIST-QHM training(h) MLP-EMNIST-QHM training(i) MLP-EMNIST-QHM validation
loss	error	error
(j) MLP-EMNIST-QHAdam train-(k) MLP-EMNIST-QHAdam train-(l) MLP-EMNIST-QHAdam vali-
ing loss
dation error
ing error
Figure 5: Full parameter sweep results (part 1 of 2). Shaded bands indicate ±1 standard deviation.
31https://github.com/facebookresearch/qhoptim/releases/download/
emptytag/qhoptim_parameter_sweep_data.tar.gz
37
Published as a conference paper at ICLR 2019
(m) RN18-CIFAR10-QHM train-(n) RN18-CIFAR10-QHM training(o) RN18-CIFAR10-QHM valida-
ing loss	error	tion error
25	50
Epoch
—SGD (β = 0)
—NAG (β = 0.9)
—NAG (best)
——QHM (v = 0.7, β = 0,999)
——QHM (best)
25	50
Epoch
25	50
Epoch
——SGD (β = 0)
—NAG (β = 0.9)
—NAG (best)
——QHM (v = 0.7, β = 0,999)
——QHM (best)
—SGD (β = 0)
—NAG (β = 0.9)
—NAG (best)
——QHM (V = 0.7, β = 0,999)
——QHM (best)
(p) RN50-ImageNet-QHM training(q) RN50-ImageNet-QHM training(r) RN50-ImageNet-QHM valida-
loss	error	tion error
Figure 5: Full parameter sweep results (part 2 of 2). Shaded bands indicate ±1 standard deviation.
38