Published as a conference paper at ICLR 2019
Systematic Generalization: What Is Required
and Can It Be Learned?
Dzmitry Bahdanau*	ShikharMurty*	Michael Noukhovitch
Mila, Universite de Montreal	Mila, Universite de Montreal	Mila, UniVersite de Montreal
AdeptMind Scholar
Element AI
Thien Huu Nguyen	Harm de Vries	Aaron Courville
University of Oregon	Mila, Universite de Montreal	Mila, Universite de Montreal
CIFAR Fellow
Ab stract
Numerous models for grounded language understanding have been recently pro-
posed, including (i) generic models that can be easily adapted to any given task
and (ii) intuitively appealing modular models that require background knowledge
to be instantiated. We compare both types of models in how much they lend them-
selves to a particular form of systematic generalization. Using a synthetic VQA
test, we evaluate which models are capable of reasoning about all possible object
pairs after training on only a small subset of them. Our findings show that the
generalization of modular models is much more systematic and that it is highly
sensitive to the module layout, i.e. to how exactly the modules are connected.
We furthermore investigate if modular models that generalize well could be made
more end-to-end by learning their layout and parametrization. We find that end-
to-end methods from prior work often learn inappropriate layouts or parametriza-
tions that do not facilitate systematic generalization. Our results suggest that, in
addition to modularity, systematic generalization in language understanding may
require explicit regularizers or priors.
1	Introduction
In recent years, neural network based models have become the workhorse of natural language un-
derstanding and generation. They empower industrial machine translation (Wu et al., 2016) and text
generation (Kannan et al., 2016) systems and show state-of-the-art performance on numerous bench-
marks including Recognizing Textual Entailment (Gong et al., 2017), Visual Question Answering
(Jiang et al., 2018), and Reading Comprehension (Wang et al., 2018). Despite these successes, a
growing body of literature suggests that these approaches do not generalize outside of the specific
distributions on which they are trained, something that is necessary for a language understanding
system to be widely deployed in the real world. Investigations on the three aforementioned tasks
have shown that neural models easily latch onto statistical regularities which are omnipresent in
existing datasets (Agrawal et al., 2016; Gururangan et al., 2018; Jia & Liang, 2017) and extremely
hard to avoid in large scale data collection. Having learned such dataset-specific solutions, neural
networks fail to make correct predictions for examples that are even slightly out of domain, yet are
trivial for humans. These findings have been corroborated by a recent investigation on a synthetic
instruction-following task (Lake & Baroni, 2018), in which seq2seq models (Sutskever et al., 2014;
Bahdanau et al., 2015) have shown little systematicity (Fodor & Pylyshyn, 1988) in how they gen-
eralize, that is they do not learn general rules on how to compose words and fail spectacularly when
for example asked to interpret “jump twice” after training on “jump”, “run twice” and “walk twice”.
An appealing direction to improve the generalization capabilities of neural models is to add mod-
ularity and structure to their design to make them structurally resemble the kind of rules they are
* Equal contribution
1
Published as a conference paper at ICLR 2019
supposed to learn (Andreas et al., 2016; Gaunt et al., 2016). For example, in the Neural Module Net-
work paradigm (NMN, Andreas et al. (2016)), a neural network is assembled from several neural
modules, where each module is meant to perform a particular subtask of the input processing, much
like a computer program composed of functions. The NMN approach is intuitively appealing but its
widespread adoption has been hindered by the large amount of domain knowledge that is required
to decide (Andreas et al., 2016) or predict (Johnson et al., 2017; Hu et al., 2017) how the modules
should be created (parametrization) and how they should be connected (layout) based on a natural
language utterance. Besides, their performance has often been matched by more traditional neural
models, such as FiLM (Perez et al., 2017), Relations Networks (Santoro et al., 2017), and MAC
networks (Hudson & Manning, 2018). Lastly, generalization properties of NMNs, to the best of our
knowledge, have not been rigorously studied prior to this work.
Here, we investigate the impact of explicit modularity and structure on systematic generalization of
NMNs and contrast their generalization abilities to those of generic models. For this case study, we
focus on the task of visual question answering (VQA), in particular its simplest binary form, when
the answer is either “yes” or “no”. Such a binary VQA task can be seen as a fundamental task of
language understanding, as it requires one to evaluate the truth value of the utterance with respect to
the state of the world. Among many systematic generalization requirements that are desirable for a
VQA model, we choose the following basic one: a good model should be able to reason about all
possible object combinations despite being trained on a very small subset of them. We believe that
this is a key prerequisite to using VQA models in the real world, because they should be robust at
handling unlikely combinations of objects. We implement our generalization demands in the form of
a new synthetic dataset, called Spatial Queries On Object Pairs (SQOOP), in which a model has to
perform spatial relational reasoning about pairs of randomly scattered letters and digits in the image
(e.g. answering the question “Is there a letter A left of a letter B?”). The main challenge in SQOOP
is that models are evaluated on all possible object pairs, but trained on only a subset of them.
Our first finding is that NMNs do generalize better than other neural models when layout and
parametrization are chosen appropriately. We then investigate which factors contribute to improved
generalization performance and find that using a layout that matches the task (i.e. a tree layout,
as opposed to a chain layout), is crucial for solving the hardest version of our dataset. Lastly, and
perhaps most importantly, we experiment with existing methods for making NMNs more end-to-end
by inducing the module layout (Johnson et al., 2017) or learning module parametrization through
soft-attention over the question (Hu et al., 2017). Our experiments show that such end-to-end ap-
proaches often fail by not converging to tree layouts or by learning a blurred parameterization for
modules, which results in poor generalization on the hardest version of our dataset. We believe that
our findings challenge the intuition of researchers in the field and provide a foundation for improving
systematic generalization of neural approaches to language understanding.
2	The SQOOP Dataset For Testing Systematic Generalization
We perform all experiments of this study on the SQOOP dataset. SQOOP is a minimalistic VQA task
that is designed to test the model’s ability to interpret unseen combinations of known relation and
object words. Clearly, given known objects X, Y and a known relation R, a human can easily verify
whether or not the objects X and Y are in relation R. Some instances of such queries are common in
daily life (is there a cup on the table), some are extremely rare (is there a violin under the car), and
some are unlikely but have similar, more likely counter-parts (is there grass on the frisbee vs is there
a frisbee on the grass). Still, a person can easily answer these questions by understanding them as
just the composition of the three separate concepts. Such compositional reasoning skills are clearly
required for language understanding models, and SQOOP is explicitly designed to test for them.
Concretely speaking, SQOOP requires observing a 64 × 64 RGB image x and answering a yes-no
question q = XRY about whether objects X and Y are in a spatial relation R. The questions are
represented in a redundancy-free X RY form; we did not aim to make the questions look like natural
language. Each image contains 5 randomly chosen and randomly positioned objects. There are 36
objects: the latin letters A-Z and digits 0-9, and there are 4 relations: left_of, right_of, above,
and BELOW. This results in 36 ∙ 35 ∙ 4 = 5040 possible unique questions (We do not allow questions
about identical objects). To make negative examples challenging, we ensure that both X and Y of
a question are always present in the associated image and that there are distractor objects Y 0 6= Y
2
Published as a conference paper at ICLR 2019
Figure 1: Different NMN layouts: NMN-Chain-Shortcut
(left), NMN-Chain (center), NMN-Tree (right). See Section
3.2 for details.
a:	S above T? Yes
b:	W left of A? No
Figure 2: A positive (top) and
negative (bottom) example from
the SQOOP dataset.
and X 0 6= X such that X R Y 0 and X 0 R Y are both true for the image. These extra precautions
guarantee that answering a question requires the model to locate all possible X and Y then check if
any pair of them are in the relation R. Two SQOOP examples are shown in Figure 2.
Our goal is to discover which models can correctly answer questions about all 36 ∙ 35 possible object
pairs in SQOOP after having been trained on only a subset. For this purpose we build training sets
containing 36 ∙ 4 ∙ k unique questions by sampling k different right-hand-side (RHS) objects Yi,
Y2, ..., Yk for each left-hand-side (LHS) object X. We use this procedure instead of just uniformly
sampling object pairs in order to ensure that each object appears in at least one training question,
thereby keeping the all versions of the dataset solvable. We will refer to k as the #rhs/lhs parameter
of the dataset. Our test set is composed from the remaining 36 ∙ 4 ∙ (35 - k) questions. We generate
training and test sets for rhs/lhs values of 1,2,4,8 and 18, as well as a control version of the dataset,
#rhs/lhs=35, in which both the training and the test set contain all the questions (with different
images). Note that lower #rhs/lhs versions are harder for generalization due to the presence of
spurious dependencies between the words X and Y to which the models may adapt. In order to
exclude a possible compounding factor of overfitting on the training images, all our training sets
contain 1 million examples, so for a dataset with #rhs/lhs = k We generate approximately 106/(36 ∙
4∙k) different images per unique question. Appendix D contains pseudocode for SQOOP generation.
3	Models
A great variety of VQA models have been recently proposed in the literature, among which we can
distinguish two trends. Some of the recently proposed models, such as FiLM (Perez et al., 2017) and
Relation Networks (RelNet, Santoro et al. (2017)) are highly generic and do not require any task-
specific knowledge to be applied on a new dataset. On the opposite end of the spectrum are modular
and structured models, typically flavours of Neural Module Networks (Andreas et al., 2016), that
do require some knowledge about the task at hand to be instantiated. Here, we evaluate systematic
generalization of several state-of-the-art models in both families. In all models, the image x is first
fed through a CNN based network, that we refer to as the stem, to produce a feature-level 3D tensor
hx. This is passed through a model-specific computation conditioned on the question q, to produce
a joint representation hq x . Lastly, this representation is fed into a fully-connected classifier network
to produce logits for prediction. Therefore, the main difference between the models we consider is
how the computation hqx = model(hx, q) is performed.
3.1	Generic Models
We consider four generic models in this paper: CNN+LSTM, FiLM, Relation Network (RelNet),
and Memory-Attention-Control (MAC) network. For CNN+LSTM, FiLM, and RelNet models, the
question q is first encoded into a fixed-size representation hq using a unidirectional LSTM network.
CNN+LSTM flattens the 3D tensor hx to a vector and concatenates it with hq to produce hqx:
hqx = [f latten(hx); hq].	(1)
3
Published as a conference paper at ICLR 2019
RelNet (Santoro et al., 2017) uses a network g which is applied to all pairs of feature columns of hx
concatenated with the question representation hq, all of which is then pooled to obtain hqx:
hqx = X g(hx(i), hx(j), hq)	(2)
i,j
where hx(i) is the i-th feature column of hx. FiLM networks (Perez et al., 2017) use N convo-
lutional FiLM blocks applied to hx. A FiLM block is a residual block (He et al., 2016) in which
a feature-wise affine transformation (FiLM layer) is inserted after the 2nd convolutional layer. The
FiLM layer is conditioned on the question at hand via prediction of the scaling and shifting param-
eters γn and βn :
[Yn； βn]= Wnhq + %	(3)
~ .. . -1 ..
hnx = BNW * ReLU(Wn * hn-1 + bn))	(4)
.. -1 . ~ .. .
hqx = hn-1 + ReLU(Yn © hqx ㊉ βn)	(5)
where BN stands for batch normalization (Ioffe & Szegedy, 2015), * stands for convolution and
stands for element-wise multiplications. hqnx is the output of the n-th FiLM block and hq0x = hx.
The output of the last FiLM block hqNx undergoes an extra 1 × 1 convolution and max-pooling to
produce hqx. MAC network of Hudson & Manning (2018) produces hqx by repeatedly applying a
Memory-Attention-Composition (MAC) cell that is conditioned on the question through an attention
mechanism. The MAC model is too complex to be fully described here and we refer the reader to
the original paper for details.
3.2	Neural Module Networks
Neural Module Networks (NMN) (Andreas et al., 2016) are an elegant approach to question answer-
ing that constructs a question-specific network by composing together trainable neural modules,
drawing inspiration from symbolic approaches to question answering (Malinowski & Fritz, 2014).
To answer a question with an NMN, one first constructs the computation graph by making the fol-
lowing decisions: (a) how many modules and of which types will be used, (b) how will the modules
be connected to each other, and (c) how are these modules parametrized based on the question. We
refer to the aspects (a) and (b) of the computation graph as the layout and the aspect (c) as the
parametrization. In the original NMN and in many follow-up works, different module types are
used to perform very different computations, e.g. the Find module from Hu et al. (2017) performs
trainable convolutions on the input attention map, whereas the And module from the same paper
computes an element-wise maximum for two input attention maps. In this work, we follow the trend
of using more homogeneous modules started by Johnson et al. (2017), who use only two types of
modules: unary and binary, both performing similar computations. We restrict our study to NMNs
with homogeneous modules because they require less prior knowledge to be instantiated and be-
cause they performed well in our preliminary experiments despite their relative simplicity. We go
one step further than Johnson et al. (2017) and retain a single binary module type, using a zero tensor
for the second input when only one input is available. Additionally, we choose to use exactly three
modules, which simplifies the layout decision to just determining how the modules are connected.
Our preliminary experiments have shown that, even after these simplifications, NMNs are far ahead
of other models in terms of generalization.
In the original NMN, the layout and parametrization were set in an ad-hoc manner for each question
by analyzing a dependency parse. In the follow-up works (Johnson et al., 2017; Hu et al., 2017),
these aspects of the computation are predicted by learnable mechanisms with the goal of reducing
the amount of background knowledge required to apply the NMN approach to a new task. We ex-
periment with the End-to-End NMN (N2NMN) (Hu et al., 2017) paradigm from this family, which
predicts the layout with a seq2seq model (Sutskever et al., 2014) and computes the parametriza-
tion of the modules using a soft attention mechanism. Since all the questions in SQOOP have the
same structure, we do not employ a seq2seq model but instead have a trainable layout variable and
trainable attention variables for each module.
Formally, our NMN is constructed by repeatedly applying a generic neural module f(θ, Y, s0, s1),
which takes as inputs the shared parameters θ, the question-specific parametrization Y and the left-
hand side and right-hand side inputs s0 and s1 . Three such modules are connected and conditioned
4
Published as a conference paper at ICLR 2019
on a question q = (q1 , q2 , q3) as follows:
3
γk = X αk,ie(qi)	(6)
i=1
k-1
skm = X τmk,j sj	(7)
j=-1
sk = f(θ, γk , s0k, s1k)	(8)
hqx = s3	(9)
In the equations above, s-1 = 0 is the zero tensor input, s0 = hx are the image features outputted
by the stem, e is the embedding table for question words. k ∈ {1, 2, 3} is the module number,
sk is the output of the k-th module and skm are its left (m = 0) and right (m = 1) inputs. We
refer to A = (αk,i) and T = (τmk,j) as the parametrization attention matrix and the layout tensor
respectively.
We experiment with two choices for the NMN’s generic neural module: the Find module from Hu
et al. (2017) and the Residual module from Johnson et al. (2017). The equations for the Residual
module are as follows:
[W1k;b1k;W2k;b2k;W3k;b3k] =γk	(10)
氤=ReLU(W3k * [sk； sk] + bk),	(11)
fResiduagk, Sk, Sk) = ReLU(Sk + Wk * ReLU(W2k * . + bkk)) + bl),	(12)
and for Find module as follows:
[W1;b1;W2;b2] =θ, (13)
fFind(θ,γk, S0k, S1k) = ReLU (W1 * γk	ReLU (W2 * S0k; S1k + b2) + b1).	(14)
In the formulas above all W’s stand for convolution weights, and all b’s are biases. Equations 10 and
13 should be understood as taking vectors γk and θ respectively and chunking them into weights and
biases. The main difference between Residual and Find is that in Residual all parameters depend
on the questions words (hence θ is omitted from the signature of fResidual), where as in Find
convolutional weights are the same for all questions, and only the element-wise multipliers γk vary
based on the question. We note that the specific Find module we use in this work is slightly different
from the one used in (Hu et al., 2017) in that it outputs a feature tensor, not just an attention map.
This change was required in order to connect multiple Find modules in the same way as we connect
multiple residual ones.
Based on the generic NMN model described above, we experiment with several specific architectures
that differ in the way the modules are connected and parametrized (see Figure 1). In NMN-Chain the
modules form a sequential chain. Modules 1, 2 and 3 are parametrized based on the first object word,
second object word and the relation word respectively, which is achieved by setting the attention
maps α1, α2, α3 to the corresponding one-hot vectors. We also experiment with giving the image
features hx as the right-hand side input to all 3 modules and call the resulting model NMN-Chain-
Shortcut. NMN-Tree is similar to NMN-Chain in that the attention vectors are similarly hard-
coded, but we change the connectivity between the modules to be tree-like. Stochastic N2NMN
follows the N2NMN approach by Hu et al. (2017) for inducing layout. We treat the layout T as a
stochastic latent variable. T is allowed to take two values: Ttree as in NMN-Tree, and Tchain as in
NMN-Chain. We calculate the output probabilities by marginalizing out the layout i.e. probability
of answer being “yes” is computed as p(yes|x, q) = PT ∈{T ,T	} p(yes|T, x, q)p(T). Lastly,
Attention N2NMN uses the N2NMN method for learning parametrization (Hu et al., 2017). It is
StrUctUredjUstlike NMN-Tree but has αk computed as Softmax(αk), where αk is a trainable vector.
We use Attention N2NMN only with the Find module because using it with the Residual module
woUld involve a highly non-standard interpolation between convolUtional weights.
5
Published as a conference paper at ICLR 2019
4	Experiments
In our experiments we aimed to: (a) understand which models are capable of exhibiting systematic
generalization as required by SQOOP, and (b) understand whether it is possible to induce, in an
end-to-end way, the successful architectural decisions that lead to systematic generalization.
All models share the same stem architecture which consists of6 layers of convolution (8 for Relation
Networks), batch normalization and max pooling. The input to the stem is a 64 × 64 × 3 image,
and the feature dimension used throughout the stem is 64. Further details can be found in Appendix
A. The code for all experiments is available online1 .
4.1	Which Models Generalize Better?
We report the performance for all models on datasets of varying difficulty in Figure 3. Our first
observation is that the modular and tree-structured NMN-Tree model exhibits strong systematic
generalization. Both versions of this model, with Residual and Find modules, robustly solve all
versions of our dataset, including the most challenging #rhs/lhs=1 split.
The results of NMN-Tree should be contrasted with those of generic models. 2 out of 4 models
(Conv+LSTM and RelNet) are not able to learn to answer all SQOOP questions, no matter how easy
the split was (for high #rhs/lhs Conv+LSTM overfitted and RelNet did not train). The results of
other two models, MAC and FiLM, are similar. Both models are clearly able to solve the SQOOP
task, as suggested by their almost perfect < 1% error rate on the control #rhs/lhs=35 split, yet they
struggle to generalize on splits with lower #rhs/lhs. In particular, we observe 13.67 ± 9.97% errors
for MAC and a 34.73 ± 4.61% errors for FiLM on the hardest #rhs/lhs=1 split. For the splits of
intermediate difficulty we saw the error rates of both models decreasing as we increased the #rhs/lhs
ratio from 2 to 18. Interestingly, even with 18 #rhs/lhs some MAC and FiLM runs result in a test
error rate of 〜2%. Given the simplicity and minimalism of SQOOP questions, We believe that these
results should be considered a failure to pass the SQOOP test for both MAC and FiLM. That said,
We note a difference in hoW exactly FiLM and MAC fail on #rhs/lhs=1: in several runs (3 out of 15)
MAC exhibits a strong generalization performance (〜0.5% error rate), whereas in all runs OfFiLM
the error rate is about 30%. We examine the successful MAC models and find that they converge to
a successful setting of the control attention weights, where specific MAC units consistently attend
to the right questions words. In particular, MAC models that generalize strongly for each question
seem to have a unit focusing strongly on X and a unit focusing strongly on Y (see Appendix B
for more details). As MAC was the strongest competitor of NMN-Tree across generic models, we
perform an ablation study for this model, in which we vary the number of modules and hidden
units, as well as experiment with weight decay. These modifications do not result in any significant
reduction of the gap between MAC and NMN-Tree. Interestingly, we find that using the default
high number of MAC units, namely 12, is helpful, possibly because it increases the likelihood that
at least one unit converges to focus on X and Y words (see Appendix B for details).
4.2	What is Essential to Strong Generalization of NMN?
The superior generalization of NMN-Tree raises the following question: what is the key architectural
difference between NMN-Tree and generic models that explains the performance gap between them?
We consider two candidate explanations. First, the NMN-Tree model differs from the generic models
in that it does not use a language encoder and is instead built from modules that are parametrized
by question words directly. Second, NMN-Tree is structured in a particular way, with the idea that
modules 1 and 2 may learn to locate objects and module 3 can learn to reason about object locations
independently of their identities. To understand which of the two differences is responsible for the
superior generalization, we compare the performance of the NMN-Tree, NMN-Chain and NMN-
Chain-Shortcut models (see Figure 1). These 3 versions of NMN are similar in that none of them are
using a language encoder, but they differ in how the modules are connected. The results in Figure 3
show that for both Find and Residual module architectures, using a tree layout is absolutely crucial
(and sufficient) for generalization, meaning that the generalization gap between NMN-Tree and
generic models can not be explained merely by the language encoding step in the latter. In particular,
NMN-Chain models perform barely above random chance, doing even worse than generic models on
1https://github.com/rizar/systematic-generalization-sqoop
6
Published as a conference paper at ICLR 2019
14-
12-
10-
8-
6-
4-
(s32」。」」山
NMN-Tree NMN-Tree	Conv+LSTM
(Residual) (Find)
ReINet
MAC
14-
12-
10-
8-
6-
4-
(s32」。」」山
NMN-Iree	NMN-Iree	NMN-Chain	NMN-Chain	NMN-Chain-ShortcUt	NMN-Chain-ShortcUt
(Residual)	(Find)	(Find)	(Residual)	(Find)	(Residual)
Figure 3: Top: Comparing the performance of generic models on datasets of varying diffi-
culty (lower #rhs/lhs is more difficult). Note that NMN-Tree generalizes perfectly on the hardest
#rhs/lhs=1 version of SQOOP, whereas MAC and FiLM fail to solve completely even the easi-
est #rhs/lhs=18 version. Bottom: Comparing NMNs with different layouts and modules. We can
clearly observe the superior generalization of NMN-Tree, poor generalization of NMN-Chain and
mediocre generalization of NMN-Chain-Shortcut. Means and standard deviations after at least 5
runs are reported.
the #rhs/lhs=1 version of the dataset and dramatically failing even on the easiest #rhs/lhs=18 split.
This is in stark contrast with NMN-Tree models that exhibits nearly perfect performance on the
hardest #rhs/lhs=1 split. As a sanity check we train NMN-Chain models on the vanilla #rhs/lhs=35
split. We find that NMN-Chain has little difficulty learning to answer SQOOP questions when it
sees all of them at training time, even though it previously shows poor generalization when testing
on unseen examples. Interestingly, NMN-Chain-Shortcut performs much better than NMN-Chain
and quite similarly to generic models. We find it remarkable that such a slight change in the model
layout as adding shortcut connections from image features hx to the modules results in a drastic
change in generalization performance. In an attempt to understand why NMN-Chain generalizes so
poorly we compare the test set responses of the 5 NMN-Chain models trained on #rhs/lhs=1 split.
Notably, there was very little agreement between predictions of these 5 runs (Fleiss κ = 0.05),
suggesting that NMN-Chain performs rather randomly outside of the training set.
4.3	Can the Right Kind of NMN Be Induced?
The strong generalization of the NMN-Tree is impressive, but a significant amount of prior knowl-
edge about the task was required to come up with the successful layout and parametrization used in
this model. We therefore investigate whether the amount of such prior knowledge can be reduced
by fixing one of these structural aspects and inducing the other.
4.3.1	Layout Induction
In our layout induction experiments, we use the Stochastic N2NMN model which treats the layout
as a stochastic latent variable with two values (Ttree and Tchain, see Section 3.2 for details). We
experiment with N2NMNs using both Find and Residual modules and report results with different
7
Published as a conference paper at ICLR 2019
Figure 4: Learning dynamics of layout in-
duction on 1 rhs/lhs and 18 rhs/lhs datasets
using the Residual module with p0 (tree) =
0.5. All 5 runs do not learn to use the tree lay-
out for 1 rhs/lhs, the very setting where the
tree layout is necessary for generalization.
g40
φ 30
2 20
E 10
0 J
0.4
0.5
∙∙
1 rhs/lhs
2 rhs/lhs
18 rhs/lhs
0.7
0.8
Attention quality κ
0.9
0.7
拼0.5
0.3
0.1
O	50000 IOOOOO
Iterations
Figure 5: Attention quality κ vs accuracy for
Attention N2NMN models trained on differ-
ent #rhs/lhs splits. We can observe that gen-
eralization is strongly associated with high κ
for #rhs/lhs=1, while for splits with 2 and 18
rhs/lhs blurry attention may be sufficient.
Figure 6: An example of how attention weights of modules 1 (left), 2 (middle), and 3 (right) evolve
during training of an Attention N2NMN model on the 18 rhs/lhs version of SQOOP. Modules 1
and 2 learn to focus on different objects words, X and Y respectively in this example, but they also
assign high weight to the relation word R. Module 3 learns to focus exclusively on R.
initial conditions, p0 (tree) ∈ 0.1, 0.5, 0.9. We believe that the initial probability p0 (tree) = 0.1
should not be considered small, since in more challenging datasets the space of layouts would be
exponentially large, and sampling the right layout in 10% of all cases should be considered a very
lucky initialization. We repeat all experiments on #rhs/lhs=1 and on #rhs/lhs=18 splits, the for-
mer to study generalization, and the latter to control whether the failures on #rhs/lhs=1 are caused
specifically by the difficulty of this split. The results (see Table 1) show that the success of layout
induction (i.e. converging to a p(tree) close to 0.9) depends in a complex way on all the factors that
we considered in our experiments. The initialization has the most influence: models initialized with
p0(tree) = 0.1 typically do not converge to a tree (exception being experiments with Residual mod-
ule on #rhs/lhs=18, in which 3 out of 5 runs converged to a solution with a high p(tree)). Likewise,
models initialized with p0 (tree) = 0.9 always stay in a regime with a high p(tree). In the interme-
diate setting of p0(tree) = 0.5 we observe differences in behaviors for Residual and Find modules.
In particular, N2NMN based on Residual modules stays spurious with p(tree) = 0.5 ± 0.08 when
#rhs/lhs=1, whereas N2NMN based on Find modules always converges to a tree.
One counterintuitive result in Table 1 is that for the Stochastic N2NMNs with Residual modules,
trained with p0 (tree) = 0.5 and #rhs/lhs=1, make just 1.64±1.79% test error despite never resolving
the layout uncertainty through training (p200K (tree) = 0.56 ± 0.06). We offer an investigation of
this result in Appendix C.
4.3.2	Parametrization Induction
Next, we experiment with the Attention N2NMN model (see Section 3.2) in which the parametriza-
tion is learned for each module as an attention-weighted average of word embeddings. In these
experiments, We fix the layout to be tree-like and sample the Pre-Softmax attention weights α from
a uniform distribution U[0; 1]. As in the layout induction investigations, we experiment with several
SQOOP splits, namely we try #rhs/lhs ∈ {1, 2, 18}. The results (reported in Table 2) show that
Attention N2NMN fails dramatically on #rhs/lhs=1 but quickly catches up as soon as #rhs/lhs is
increased to 2. Notably, 9 out of 10 runs on #rhs/lhs=2 result in almost perfect performance, and 1
run completely fails to generalize (26% error rate), resulting in a high 8.18% variance of the mean
8
Published as a conference paper at ICLR 2019
Table 1: Tree layout induction results for Stochastic N2NMNs using Residual and Find modules
on 1 rhs/lhs and 18 rhs/lhs datasets. For each setting of p0 (tree) we report results after 5 runs.
p200K (tree) is the probability of using a tree layout after 200K training iterations.
module	#rhs/lhs	p0 (tree)	Test error rate (%)	Test loss	p200K(tree)
		0.1	31.89 ± 0.75-	0.64 ± 0.03	0.08 ± 0.01
	1	0.5	1.64 ± 1.79	0.27 ± 0.04	0.56 ± 0.06
Residual		0.9	0.16 ± 0.11	0.03 ± 0.01	0.96 ± 0.00
		0.1	3.99 ± 5.33	0.15 ± 0.06	0.59 ± 0.34
	18	0.5	0.19 ± 0.11	0.06 ± 0.02	0.99 ± 0.01
		0.9	0.12 ± 0.12	0.01 ± 0.00	1.00 ± 0.00
		0.1	47.54 ± 0.95-	1.78 ± 0.47	0.00 ± 0.00
	1	0.5	0.78 ± 0.52	0.05 ± 0.04	0.94 ± 0.07
Find		0.9	0.41 ± 0.07	0.02 ± 0.00	1.00 ± 0.00
		0.1	5.11 ± 1.19	0.14 ± 0.03	0.02 ± 0.04
	18	0.5	0.17 ± 0.16	0.01 ± 0.01	1.00 ± 0.00
		0.9	0.11 ± 0.03	0.00 ± 0.00	1.00 ± 0.00
Table 2: Parameterization induction results for 1,2,18 rhs/lhs datasets for Attention N2NMN. The
model does not generalize well in the difficult 1 rhs/lhs setting. Results for MAC are presented for
comparison. Means and standard deviations were estimated based on at least 10 runs.
Model	#rhs/lhs	Test error rate (%)	Test loss (%)
Attention N2NMN	1	27.19 ± 16.02	1.22 ± 0.71
Attention N2NMN	2	2.82 ± 8.18	0.14 ± 0.41
Attention N2NMN	18	0.16 ± 0.12	0.00 ± 0.00
MAC	1	13.67 ± 9.97	0.41 ± 0.32
MAC	2	9.21 ± 4.31	0.28 ± 0.15
MAC	18	0.53 ± 0.74	0.01 ± 0.02
error rate. All 10 runs on the split with 18 rhs/lhs generalize flawlessly. Furthermore, we inspect the
learned attention weights and find that for typical successful runs, module 3 focuses on the relation
word, whereas modules 1 and 2 focus on different object words (see Figure 6) while still focusing
on the relation word. To better understand the relationship between successful layout induction and
generalization, We define an attention quality metric K = mi□w∈{χ,γ} maxk∈1,2 αk,w/(1 - ak,R).
Intuitively, κ is large when for each word w ∈ X, Y there is a module i that focuses mostly on this
Word. The renormalization by 1/(1 - αk,R) is necessary to factor out the amount of attention that
modules 1 and 2 assign to the relation Word. For the ground-truth parametrization that We use for
NMN-Tree κ takes a value of 1, and if both modules 1 and 2 focus on X, completely ignoring Y, κ
equals 0. The scatterplot of the test error rate versus κ (Figure 5) shoWs that for #rhs/lhs=1 high gen-
eralization is strongly associated With higher κ, meaning that it is indeed necessary to have different
modules strongly focusing on different object Words in order to generalize in this most challenging
setting. Interestingly, for #rhs/lhs=2 We see a lot of cases Where N2NMN generalizes Well despite
attention being rather spurious (κ ≈ 0.6).
In order to put Attention N2NMN results in context We compare them to those of MAC (see Table 2).
Such a comparison can be of interest because both models perform attention over the question. For
1 rhs/lhs MAC seems to be better on average, but as We increase #rhs/lhs to 2 We note that Attention
N2NMN succeeds in 9 out of 10 cases on the #rhs/lhs=2 split, much more often than 1 success out
of 10 observed for MAC2. This result suggests that Attention N2NMNs retains some of the strong
generalization potential of NMNs With hard-coded parametrization.
5	Related Work
The notion of systematicity Was originally introduced by (Fodor & Pylyshyn, 1988) as the property
of human cognition Whereby “the ability to entertain a given thought implies the ability to entertain
thoughts With semantically related contents”. They illustrate this With an example that no English
2If We judge a run successful When the error rate is loWer than τ = 1%, these success rates are different
With a p-value of 0.001 according to the Fisher exact test. Same holds for any other threshold τ ∈ [1%; 5%].
9
Published as a conference paper at ICLR 2019
speaker can understand the phrase “John loves the girl” without being also able to understand the
phrase “the girl loves John”. The question of whether or not connectionist models of cognition can
account for the systematicity phenomenon has been a subject of a long debate in cognitive science
(Fodor & Pylyshyn, 1988; Smolensky, 1987; Marcus, 1998; 2003; Calvo & Colunga, 2003). Recent
research has shown that lack of systematicity in the generalization is still a concern for the modern
seq2seq models (Lake & Baroni, 2018; Bastings et al., 2018; Loula et al., 2018). Our findings about
the weak systematic generalization of generic VQA models corroborate the aforementioned seq2seq
results. We also go beyond merely stating negative generalization results and showcase the high
systematicity potential of adding explicit modularity and structure to modern deep learning models.
Besides the theoretical appeal of systematicity, our study is inspired by highly related prior evidence
that when trained on downstream language understanding tasks, neural networks often generalize
poorly and latch on to dataset-specific regularities. Agrawal et al. (2016) report how neural models
exploit biases in a VQA dataset, e.g. responding “snow” to the question “what covers the ground”
regardless of the image because “snow” is the most common answer to this question. Gururangan
et al. (2018) report that many successes in natural language entailment are actually due to exploiting
statistical biases as opposed to solving entailment, and that state-of-the-art systems are much less
performant when tested on unbiased data. Jia & Liang (2017) demonstrate that seemingly state-of-
the-art reading comprehension system can be misled by simply appending an unrelated sentence that
resembles the question to the document.
Using synthetic VQA datasets to study grounded language understanding is a recent trend started by
the CLEVR dataset (Johnson et al., 2016). CLEVR images are 3D-rendered and CLEVR questions
are longer and more complex than ours, but in the associated generalization split CLEVR-CoGenT
the training and test distributions of images are different. In our design of SQOOP we aimed instead
to minimize the difference between training and test images to make sure that we test a model’s
ability to interpret unknown combinations of known words. The ShapeWorld family of datasets by
Kuhnle & Copestake (2017) is another synthetic VQA platform with a number of generalization
tests, but none of them tests SQOOP-style generalization of relational reasoning to unseen object
pairs. Most closely related to our work is the recent study of generalization to long-tail questions
about rare objects done by Bingham et al. (2017). They do not, however, consider as many models as
we do and do not study the question of whether the best-performing models can be made end-to-end.
The key paradigm that we test in our experiments is Neural Module Networks (NMN). Andreas
et al. (2016) introduced NMNs as a modular, structured VQA model where a fixed number of hand-
crafted neural modules (such as Find, or Compare) are chosen and composed together in a layout
determined by the dependency parse of the question. Andreas et al. (2016) show that the modular
structure allows answering questions that are longer than the training ones, a kind of generalization
that is complementary to the one we study here. Hu et al. (2017) and Johnson et al. (2017) followed
up by making NMNs end-to-end, removing the non-differentiable parser. Both Hu et al. (2017)
and Johnson et al. (2017) reported that several thousands of ground-truth layouts are required to
pretrain the layout predictor in order for their approaches to work. In a recent work, Hu et al. (2018)
attempt to soften the layout decisions, but training their models end-to-end from scratch performed
substantially lower than best models on the CLEVR task. Gupta & Lewis (2018) report successful
layout induction on CLEVR for a carefully engineered heterogeneous NMN that takes a scene graph
as opposed to a raw image as the input.
6	Conclusion and Discussion
We have conducted a rigorous investigation of an important form of systematic generalization re-
quired for grounded language understanding: the ability to reason about all possible pairs of objects
despite being trained on a small subset of such pairs. Our results allow one to draw two important
conclusions. For one, the intuitive appeal of modularity and structure in designing neural architec-
tures for language understanding is now supported by our results, which show how a modular model
consisting of general purpose residual blocks generalizes much better than a number of baselines,
including architectures such as MAC, FiLM and RelNet that were designed specifically for visual
reasoning. While this may seem unsurprising, to the best of our knowledge, the literature has lacked
such a clear empirical evidence in favor of modular and structured networks before this work. Im-
portantly, we have also shown how sensitive the high performance of the modular models is to the
10
Published as a conference paper at ICLR 2019
layout of modules, and how a tree-like structure generalizes much stronger than a typical chain of
layers.
Our second key conclusion is that coming up with an end-to-end and/or soft version of modular
models may be not sufficient for strong generalization. In the very setting where strong generaliza-
tion is required, end-to-end methods often converge to a different, less compositional solution (e.g.
a chain layout or blurred attention). This can be observed especially clearly in our NMN layout
and parametrization induction experiments on the #rhs/lhs=1 version of SQOOP, but notably, strong
initialization sensitivity of layout induction remains an issue even on the #rhs/lhs=18 split. This
conclusion is relevant in the view of recent work in the direction of making NMNs more end-to-
end (Suarez et al., 2018; Hu et al., 2018; Hudson & Manning, 2018; Gupta & Lewis, 2018). Our
findings suggest that merely replacing hard-coded components with learnable counterparts can be
insufficient, and that research on regularizers or priors that steer the learning towards more system-
atic solutions can be required. That said, our parametrization induction results on the #rhs/lhs=2
split are encouraging, as they show that compared to generic models, a weaker nudge (in the form
of a richer training signal or a prior) towards systematicity may suffice for end-to-end NMNs.
While our investigation has been performed on a synthetic dataset, we believe that it is the real-
world language understanding where our findings may be most relevant. It is possible to construct a
synthetic dataset that is bias-free and that can only be solved if the model has understood the entirety
of the dataset’s language. It is, on the contrary, much harder to collect real-world datasets that do
not permit highly dataset-specific solutions, as numerous dataset analysis papers of recent years have
shown (see Section 5 for a review). We believe that approaches that can generalize strongly from
imperfect and biased data will likely be required, and our experiments can be seen as a simulation of
such a scenario. We hope, therefore, that our findings will inform researchers working on language
understanding and provide them with a useful intuition about what facilitates strong generalization
and what is likely to inhibit it.
Acknowledgements
We thank Maxime Chevalier-Boisvert, Yoshua Bengio and Jacob Andreas for useful dis-
cussions. This research was enabled in part by support provided by Compute Canada
(www.computecanada.ca), NSERC, Canada Research Chairs and Microsoft Research. We also
thank Nvidia for donating NVIDIA DGX-1 used for this research.
References
Aishwarya Agrawal, Dhruv Batra, and Devi Parikh. Analyzing the Behavior of Visual Question
Answering Models. In Proceedings of the 2016 Conference on Empirical Methods in Natural
Language Processing, January 2016.
Jacob Andreas, Marcus Rohrbach, Trevor Darrell, and Dan Klein. Neural Module Networks. In
Proceedings of 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR),
2016. URL http://arxiv.org/abs/1511.02799.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural Machine Translation by Jointly
Learning to Align and Translate. In Proceedings of the 2015 International Conference on Learn-
ing Representations, 2015.
Joost Bastings, Marco Baroni, Jason Weston, Kyunghyun Cho, and Douwe Kiela. Jump to better
conclusions: SCAN both left and right. In Proceedings of the 2018 EMNLP Workshop Black-
boxNLP: Analyzing and Interpreting Neural Networks for NLP, pp. 47-55, Brussels, Belgium,
November 2018. Association for Computational Linguistics. URL https://www.aclweb.
org/anthology/W18-5407.
Eli Bingham, Piero Molino, Paul Szerlip, Obermeyer Fritz, and Goodman Noah. Characterizing how
Visual Question Answering scales with the world. In NIPS 2017 Visually-Grounded Interaction
and Language Workshop, 2017.
Francisco Calvo and Eliana Colunga. The statistical brain: Reply to Marcus The algebraic mind. In
Proceedings of the Annual Meeting of the Cognitive Science Society, volume 25, 2003.
11
Published as a conference paper at ICLR 2019
Jerry A. Fodor and Zenon W. Pylyshyn. Connectionism and cognitive architecture: A critical anal-
ysis. Cognition, 28(1):3-71,1988.
Alexander L. Gaunt, Marc Brockschmidt, Nate Kushman, and Daniel Tarlow. Differentiable Pro-
grams with Neural Libraries. In Proceedings of the 34th International Conference on Ma-
chine Learning, November 2016. URL http://arxiv.org/abs/1611.02109. arXiv:
1611.02109.
Yichen Gong, Heng Luo, and Jian Zhang. Natural Language Inference over Interaction Space.
In Proceedings of the 2018 International Conference on Learning Representations, 2017. URL
http://arxiv.org/abs/1709.04348. arXiv: 1709.04348.
Nitish Gupta and Mike Lewis. Neural Compositional Denotational Semantics for Question An-
swering. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language
Processing. Association for Computational Linguistics, 2018. URL http://aclweb.org/
anthology/D18-1239.
Suchin Gururangan, Swabha Swayamdipta, Omer Levy, Roy Schwartz, Samuel R. Bowman, and
Noah A. Smith. Annotation Artifacts in Natural Language Inference Data. In Proceedings of
NAACL-HLT 2018, March 2018. URL http://arxiv.org/abs/1803.02324. arXiv:
1803.02324.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
2016.
Ronghang Hu, Jacob Andreas, Marcus Rohrbach, Trevor Darrell, and Kate Saenko. Learning to
Reason: End-to-End Module Networks for Visual Question Answering. In Proceedings of 2017
IEEE International Conference on Computer Vision, April 2017. URL http://arxiv.org/
abs/1704.05526. arXiv: 1704.05526.
Ronghang Hu, Jacob Andreas, Trevor Darrell, and Kate Saenko. Explainable Neural Computation
via Stack Neural Module Networks. In Proceedings of 2018 European Conference on Computer
Vision, July 2018. URL http://arxiv.org/abs/1807.08556. arXiv: 1807.08556.
Drew A. Hudson and Christopher D. Manning. Compositional Attention Networks for Machine
Reasoning. In Proceedings of the 2018 International Conference on Learning Representations,
February 2018. URL https://openreview.net/forum?id=S1Euwz-Rb.
Sergey Ioffe and Christian Szegedy. Batch Normalization: Accelerating Deep Network Training
by Reducing Internal Covariate Shift. In Proceedings of the 32nd International Conference on
Machine Learning, ICML 2015, Lille, France, 6-11 July 2015, pp. 448-456, 2015. URL http:
//jmlr.org/proceedings/papers/v37/ioffe15.html.
Robin Jia and Percy Liang. Adversarial Examples for Evaluating Reading Comprehension Systems.
Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pp.
2021-2031, 2017. doi: 10.18653/v1/D17-1215. URL https://aclanthology.coli.
uni-saarland.de/papers/D17-1215/d17-1215.
Yu Jiang, Vivek Natarajan, Xinlei Chen, Marcus Rohrbach, Dhruv Batra, and Devi Parikh.
Pythia v0.1: The winning entry to the vqa challenge 2018. https://github.com/
facebookresearch/pythia, 2018.
Justin Johnson, Bharath Hariharan, Laurens van der Maaten, Li Fei-Fei, C. Lawrence Zitnick, and
Ross Girshick. CLEVR: A Diagnostic Dataset for Compositional Language and Elementary Vi-
sual Reasoning. In Proceedings of 2017 IEEE Conference on Computer Vision and Pattern Recog-
nition (CVPR), December 2016. URL http://arxiv.org/abs/1612.06890. arXiv:
1612.06890.
Justin Johnson, Bharath Hariharan, Laurens van der Maaten, Judy Hoffman, Li Fei-Fei, C. Lawrence
Zitnick, and Ross Girshick. Inferring and Executing Programs for Visual Reasoning. In Pro-
ceedings of 2017 IEEE International Conference on Computer Vision, 2017. URL http:
//arxiv.org/abs/1705.03633.
12
Published as a conference paper at ICLR 2019
Anjuli Kannan, Karol Kurach, Sujith Ravi, Tobias Kaufmann, Andrew Tomkins, Balint Miklos,
Greg Corrado, Laszlo Lukacs, Marina Ganea, Peter Young, and Vivek Ramavajjala. Smart Reply:
Automated Response Suggestion for Email. In Proceedings of the 22Nd ACM SIGKDD Inter-
national Conference on Knowledge Discovery and Data Mining, KDD ,16, pp. 955-964, New
York, NY, USA, 2016. ACM. ISBN 978-1-4503-4232-2. doi: 10.1145/2939672.2939801. URL
http://doi.acm.org/10.1145/2939672.2939801.
Diederik P. Kingma and Jimmy Ba. Adam: A Method for Stochastic Optimization. In Proceedings of
the 2015 International Conference on Learning Representations, 2015. URL http://arxiv.
org/abs/1412.6980. arXiv: 1412.6980.
Alexander Kuhnle and Ann Copestake. ShapeWorld - A new test methodology for multimodal
language understanding. arXiv:1704.04517 [cs], April 2017. URL http://arxiv.org/
abs/1704.04517. arXiv: 1704.04517.
Brenden M. Lake and Marco Baroni. Generalization without systematicity: On the compositional
skills of sequence-to-sequence recurrent networks. In Proceedings of the 36th International Con-
ference on Machine Learning, 2018. URL http://arxiv.org/abs/1711.00350. arXiv:
1711.00350.
Joao Loula, Marco Baroni, and Brenden M. Lake. Rearranging the Familiar: Testing Composi-
tional Generalization in Recurrent Networks. In Proceedings of the 2018 BlackboxNLP EMNLP
Workshop, July 2018. URL https://arxiv.org/abs/1807.07545.
Mateusz Malinowski and Mario Fritz. A Multi-world Approach to Question Answering About Real-
world Scenes Based on Uncertain Input. In Proceedings of the 27th International Conference on
Neural Information Processing Systems, NIPS’14, pp. 1682-1690, Cambridge, MA, USA, 2014.
MIT Press. URL http://dl.acm.org/citation.cfm?id=2968826.2969014.
Gary F. Marcus. Rethinking Eliminative Connectionism. Cognitive Psychology, 37(3):243-282,
December 1998. ISSN 0010-0285. doi: 10.1006/cogp.1998.0694. URL http://www.
sciencedirect.com/science/article/pii/S0010028598906946.
Gary F. Marcus. The algebraic mind: Integrating connectionism and cognitive science. MIT press,
2003.
Ethan Perez, Florian Strub, Harm de Vries, Vincent Dumoulin, and Aaron Courville. FiLM: Visual
Reasoning with a General Conditioning Layer. In In Proceedings of the 2017 AAAI Conference
on Artificial Intelligence, 2017. URL http://arxiv.org/abs/1709.07871.
Adam Santoro, David Raposo, David G. T. Barrett, Mateusz Malinowski, Razvan Pascanu, Peter
Battaglia, and Timothy Lillicrap. A simple neural network module for relational reasoning. In
Advances in Neural Information Processing Systems 31, June 2017. URL http://arxiv.
org/abs/1706.01427. arXiv: 1706.01427.
Paul Smolensky. The constituent structure of connectionist mental states: A reply to Fodor and
Pylyshyn. Southern Journal of Philosophy, 26(Supplement):137-161, 1987.
Joseph Suarez, Justin Johnson, and Fei-Fei Li. DDRprog: A CLEVR Differentiable Dynamic Rea-
soning Programmer. arXiv:1803.11361 [cs], March 2018. URL http://arxiv.org/abs/
1803.11361. arXiv: 1803.11361.
Ilya Sutskever, Oriol Vinyals, and Quoc V Le. Sequence to Sequence Learning with Neural Net-
works. In Advances in Neural Information Processing Systems 27, pp. 3104-3112, 2014.
Wei Wang, Ming Yan, and Chen Wu. Multi-Granularity Hierarchical Attention Fusion Net-
works for Reading Comprehension and Question Answering. In Proceedings of the 56th An-
nual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pp.
1705-1714, Melbourne, Australia, 2018. Association for Computational Linguistics. URL
http://aclweb.org/anthology/P18-1158.
Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, and others. Google’s Neural Machine
Translation System: Bridging the Gap between Human and Machine Translation. arXiv preprint
arXiv:1609.08144, 2016.
13
Published as a conference paper at ICLR 2019
A Experiment Details
We trained all models by minimizing the cross entropy loss logp(y|x, q) on the training set, where
y ∈ {yes, no} is the correct answer, x is the image, q is the question. In all our experiments
we used the Adam optimizer (Kingma & Ba, 2015) with hyperparameters α = 0.0001, β1 = 0.9,
β2 = 0.999, = 10-10. We continuously monitored validation set performance of all models during
training, selected the best one and reported its performance on the test set. The number of training
iterations for each model was selected in preliminary investigations based on our observations of
how long it takes for different models to converge. This information, as well as other training
details, can be found in Table 3.
Table 3: Training details for all models. The subsampling factor is the ratio between the original
spatial dimensions of the input image and those of the representation produced by the stem. It is
effectively equal to 2k, where k is the number of 2x2 max-pooling operations in the stem.
model	stem layers	subsampling factor	iterations	batch size
FiLM	6	4^	200000	64
MAC	6	4	100000	128
Conv+LSTM	6	4	200000	128
RelNet	8	8	500000	64
NMN (Residual)	6	4	50000	64
NMN (Find)	6	4	200000	64
Stochastic NMN (Residual)	6	4	200000	64
Stochastic NMN (Find)	6	4	200000	64
Attention NMN (Find)	6	4	50000	64
B Additional Results for MAC Model
We performed an ablation study in which we varied the number of MAC units, the model dimen-
sionality and the level of weight decay for the MAC model. The results can be found in Table
4.
Table 4: Results of an ablation study for MAC. The default model has 12 MAC units of dimension-
ality 128 and uses no weight decay. For each experiment we report means and standard deviations
based on 5 repetitions.
model	#rhs/lhs	train error rate (%)	test error rate (%)
default	1	0.17 ± 0.21	13.67 ± 9.97
1 unit	1	0.27 ± 0.35	28.67 ± 1.91
2 units	1	0.23 ± 0.13	24.28 ± 2.05
3 units	1	0.16 ± 0.15	26.47 ± 1.12
6 units	1	0.18 ± 0.17	20.84 ± 5.56
24 units	1	0.04 ± 0.05	9.11 ± 7.67
dim. 64	1	0.27 ± 0.33	23.61 ± 6.27
dim. 256	1	0.00 ± 0.00	4.62 ± 5.07
dim. 512	1	0.02 ± 0.04	8.37 ± 7.45
weight decay 0.00001	1	0.20 ± 0.23	19.21 ± 9.27
weight decay 0.0001	1	1.00 ± 0.54	31.19 ± 0.87
weight decay 0.001	1	40.55 ± 1.35	45.11 ± 0.74
We also perform qualitative investigations to understand the high variance in MAC’s performance.
In particular, we focus on control attention weights (c) for each run and aim to understand if runs that
generalize have clear differences when compared to runs that failed. Interestingly, we observe that in
successful runs each word w ∈ X, Y has a unit that is strongly focused on it. To present our observa-
tions in quantitative terms, we plot attention quality K = mi□w∈{χ,γ} maxk∈[i]2] αk,w/(1 — ak,R),
where α are control scores vs accuracy in Figure 7 for each run (see Section 4.3.2 for an explanation
of κ). We can clearly see a positive correlation between κ and error rate, especially for low #rhs/lhs.
14
Published as a conference paper at ICLR 2019
(a) 1 rhs/lhs
OL	,	∙,
0.4	0.5	0.6	0.7	0.8	0.9	1.0
Attention quality κ
(c) 4 rhs/lhs
(b) 2 rhs/lhs
Od...................................................∙
0.825 0.850 0.875 0.900 0.925 0.950 0.975 1.000
Attention quality «
(d) 8 rhs/lhs
(e) 18 rhs/lhs
Figure 7: Model test accuracy vs κ for the MAC model on different versions of SQOOP. All exper-
iments are run 10 times with different random seeds. We can observe a clear correlation between κ
and error rate for 1, 2 and 4 rhs/lhs. Also note that perfect generalization is always associated with
κ close to 1.
Next, we experiment with a hard-coded variation of MAC. In this model, we use hard-coded control
scores such that given a SQOOP question XRY, the first half of all modules focuses on X while
the second half focuses on Y. The relationship between MAC and hardcoded MAC is similar to that
between NMN-Tree and end-to-end NMN with parameterization induction. However, this model
has not performed as well as the successful runs of MAC. We hypothesize that this could be due to
the interactions between the control scores and the visual attention part of the model.
C Investigation of Correct Predictions with Spurious Layouts
In Section 4.3.1 we observed that an NMN with the Residual module can answer test questions
with a relative low error rate of 1.64 ± 1.79%, despite being a mixture of a tree and a chain (see
15
Published as a conference paper at ICLR 2019
results in Table 1, p0 (tree) = 0.5). Our explanation for this phenomenon is as follows: when
connected in a tree, modules of such spurious models generalize well, and when connected as a chain
they generalize poorly. The output distribution of the whole model is thus a mixture of the mostly
correct p(y|T = Ttree, x, q) and mostly random p(y|T = Tchain, x, q). We verify our reasoning
by explicitly evaluating test accuracies for p(y|T = Ttree, x, q) and p(y|T = Tchain, x, q), and find
them to be around 99% and 60% respectively, confirming our hypothesis. As a result the predictions
of the spurious models with p(tree) ≈ 0.5 have lower confidence than those of sharp tree models,
as indicated by the high log loss of 0.27 ± 0.04. We visualize the progress of structure induction for
the Residual module with p0 (tree) = 0.5 in Figure 4 which shows how p(tree) saturates to 1.0 for
#rhs/lhs=18 and remains around 0.5 when #rhs/lhs=1.
D SQOOP Pseudocode
Algorithm 1 Pseudocode for creating SQOOP
1: 2:	S -{A,B,C,…，Z, 0,1,2,3,...,9}
	Rel J {left-of, RIGHT-of, above, below}	. relations
3:	function CREATESQOOP(k)
4:	T rainQuestions J []
5:	AllQuestions J []
6:	for all X in S do
7:	AllRhs J RandomSample(S \ {X}, k) . sample without replacement from S \ {X}
8:	AllQuestions J {X} × Rel × (S \ {X}) ∪ AllQuestions
9:	for all R, Y in AllRhs × Rel do
10:	T rainQuestions J (X, R, Y ) ∪ T rainQuestions
11:	end for
12:	end for
13:	T estQuestions J AllQuestions \ T rainQuestions
14:	function GENERATEEXAMPLE(X, R, Y )
15:	a 〜{Yes, No}
16:	if a = Yes then
17:	I J place X and Y objects so that R holds	. create the image
18:	I J sample 3 objects from S and add to I
19:	else
20:	repeat
21:	X0 J Sample X0 from S \ {X}
22:	Y 0 J Sample Y 0 from S \ {Y }
23:	I J place X0 and Y objects so that R holds	. create the image
24:	I J add X and Y 0 objects to I so that R holds
25:	I J sample 1 more object from S and add to I
26:	until X and Y are not in relation R in I
27:	end if
28:	return I, X, R, Y , a
29:	end function
30:	Train — sample |7：@分二2：：§[0二§| examples for each (X,R,Y) ∈ TrainQuestions from GENERATEEXAMPLE(X, R, Y )
31:	Test J sample 10 examples for each (X,R,Y) ∈ T estQuestions from GENERATEEXAM- PLE(X, R, Y )
32:	end function
16