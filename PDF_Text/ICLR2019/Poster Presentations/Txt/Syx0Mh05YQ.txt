Published as a conference paper at ICLR 2019
Learning Grid Cells as Vector Representa-
tion of Self-Position Coupled with Matrix
Representation of Self-Motion
Ruiqi Gao1 ； JianWen Xie2； SOng-Chun Zhu1 & Ying Nian Wu1
1 University of California, Los Angeles, USA
2Hikvision Research Institute, Santa Clara, USA
{ruiqigao, jianwen}@ucla.edu, {sczhu, ywu}@stat.ucla.edu
Abstract
This paper proposes a representational model for grid cells. In this model, the 2D
self-position of the agent is represented by a high-dimensional vector, and the 2D
self-motion or displacement of the agent is represented by a matrix that transforms
the vector. Each component of the vector is a unit or a cell. The model consists of
the following three sub-models. (1) Vector-matrix multiplication. The movement
from the current position to the next position is modeled by matrix-vector multi-
plication, i.e., the vector of the next position is obtained by multiplying the matrix
of the motion to the vector of the current position. (2) Magnified local isometry.
The angle between two nearby vectors equals the Euclidean distance between the
two corresponding positions multiplied by a magnifying factor. (3) Global ad-
jacency kernel. The inner product between two vectors measures the adjacency
between the two corresponding positions, which is defined by a kernel function of
the Euclidean distance between the two positions. Our representational model has
explicit algebra and geometry. It can learn hexagon patterns of grid cells, and it is
capable of error correction, path integral and path planning.
1 Introduction
Imagine you are walking in your living room in the dark at night without any visual cues. Purely
based on your self-motion, you know where you are while you are walking simply by integrating
your self-motion. This is called path integral (Hafting et al. (2005); Fiete et al. (2008); McNaughton
et al. (2006)). You can also plan your path to the light switch or to the door. This is called path
planning (Fiete et al. (2008); Erdem & Hasselmo (2012); Bush et al. (2015)). You need to thank
your grid cells for performing such navigation tasks.
(a)
(b)
(c)
(d)
Figure 1: Place cells and grid cells. (a) The rat is moving within a square region. (b) The activity of a neuron
is recorded. (c) When the rat moves around (the curve is the trajectory), each place cell fires at a particular
location, but each grid cell fires at multiple locations that form a hexagon grid. (d) The place cells and grid
cells exist in the brains of both rat and human. (Source of pictures: internet)
Figure 1(a) shows Dr. May-Britt Moser, who together with Dr. Edvard Moser, won the 2014 Nobel
Prize for Physiology or Medicine, for their discovery of the grid cells (Hafting et al. (2005); Fyhn
et al. (2008); Yartsev et al. (2011); Killian et al. (2012); Jacobs et al. (2013); Doeller et al. (2010))
* Equal contributions.
1
Published as a conference paper at ICLR 2019
in 2005. Their thesis advisor, Dr. John O’keefe, shared the prize for his discovery of the place cells
(O’Keefe (1979)). Both the place cells and grid cells are used for navigation. The discoveries of
these cells were made by recording the activities of the neurons of the rat when it moves within
a square region. See Figure 1(b). Some neurons in the Hippocampus area are place cells. Each
place cell fires when the rat moves to a particular location, and different place cells fire at different
locations. The whole collection of place cells cover the whole square region. The discovery of grid
cells was much more surprising and unexpected. The grid cells exist in the Entorhinal cortex. Each
grid cell fires at multiple locations, and these locations form a regular hexagon grid. See Figure 1(c).
The grid cells have been discovered across mammalian species, including human. See Figure 1(d).
In this paper, we propose a representational model to explain the hexagon patterns of the grid cells,
and to explain how the grid cells perform path integral and path planning. We shall show that the
grid cells are capable of error correction, which provides a justification for the grid cells.
v(x)
M (∆x)
Av(X + ∆x)
(1) Vector-matrix multiplication (2) Magnified local isometry (3) Global adjacency kernel
Figure 2: Grid cells form a high-dimensional vector representation of 2D self-position. Three sub-
models: (1) Local motion is modeled by vector-matrix multiplication. (2) Angle between two nearby
vectors magnifies the Euclidean distance. (3) Inner product between any two vectors measures the
adjacency which is a kernel function of the Euclidean distance.
Figure 2 illustrates our model. The 2D self-position of the agent is represented by a high-
dimensional vector, and the 2D self-motion or displacement of the agent is represented by a matrix
that acts on the vector. Each component of the vector is a unit or a cell. In Figure 2, x denotes the 2D
self-position, v(x) is the high-dimensional vector representation of the 2D x. ∆x is the self-motion
or one-step displacement. M (∆x) is the matrix representation of ∆x. The model consists of the
following three sub-models. (1) Vector-matrix multiplication. The movement from the current po-
sition x to the next position x + ∆x is modeled by matrix-vector multiplication, i.e., the vector of
the next position v(x + ∆x) is obtained by multiplying the matrix of the motion, M (∆x), to the
vector of the current position v(x). (2) Magnified local isometry. The angle between two nearby
vectors equals the Euclidean distance ∣∆χ∣ between the two corresponding positions multiplied by a
magnifying factor. (3) Global adjacency kernel. The inner product between two vectors hv(x), v(y)i
measures the adjacency between the two corresponding positions, which is defined by a kernel func-
tion f of the Euclidean distance |x - y | between the two positions x and y . One additional feature
is that the whole vector v(x) is partitioned into multiple sub-vectors, and each sub-vector is driven
by an associated sub-matrix. The whole system is like a multi-arm clock, with each arm rotating at
a magnified speed and spanning a 2D sub-manifold on a high-dimensional sphere.
Our experiments show that sub-models (1) and (2) are sufficient for the emergence of the hexagon
grid patterns of the grid cells. Sub-model (2) makes the vector representation robust to noises or
errors due to the magnification of the distance. Sub-model (3) enables unique decoding of the
position from the vector, because f is unimodal and peaked at 0, and it may serve as the link between
the grid cells and place cells. Together with sub-model (1), sub-model (3) enables path integral and
path planning, because the adjacency hv(x), v(y)i informs the Euclidean distance |x - y|. All the
three sub-models can be implemented by one-layer neural networks.
2	Contributions and related work
The following are the contributions of our work. (1) We propose a representational model for grid
cells, where the self-position is represented by a vector and the self-motion is represented by a matrix
that acts on the vector. (2) We show that our model can learn hexagon grid patterns. (3) We show
our model is capable of path integral, path planning, and error correction.
2
Published as a conference paper at ICLR 2019
Many mathematical and computational models (Burak & Fiete (2009); Sreenivasan & Fiete (2011);
Blair et al. (2007); de Almeida et al. (2009)) have been proposed to explain the formation and
function of grid cells. Compared to previous computational models on grid cells, our model only
makes very generic assumptions about the algebra and geometry of the representational scheme,
without assuming Fourier plane waves or clock arithmetics.
Recently, deep learning models (Banino et al. (2018); Cueva & Wei (2018)) have been proposed
to learn the grid-like units for navigation. Our work was inspired by them. Compared with these
models, our model has explicit algebra and geometry. In terms of algebra, our model has explicit
matrix representation of self-motion, and the change of self-position is modeled by vector-matrix
multiplication. In terms of geometry, our model assumes that the vector rotates while the agent
moves, and our model assumes magnified local isometry and global adjacency kernel based on the
angles between the vectors.
Expressing the adjacency kernel as the inner product between the vectors is related to the kernel
trick (Cortes & Vapnik (1995)), random Fourier basis (Ng et al. (2002)), and spectral clustering (Ng
et al. (2002)).
3	Representational model of grid cells
Consider an agent navigating within a domain D = [0, 1] × [0, 1] (actually the shape does not matter,
and it can be R2). We can discretize D into an N × N lattice. N = 40 in our experiments. Let
x = (x1, x2) ∈ D be the self-position of the agent. x is 2D. Suppose the agent wants to represent its
self-position by a d-dimensional hidden vector v(x). We introduce the following three sub-models.
3.1	Sub-model 1 about motion algebra: vector-matrix multiplication
Suppose at a position x, the self-motion or one-step displacement is ∆x, so that the agent moves to
x + ∆x after one step. We assume that
v(x + ∆x) = M (∆x)v(x),	(1)
where M (∆x) is a d × d matrix that depends on ∆x. While v(x) is the vector representation of
the self-position x, M (∆x) is the matrix representation of the self-motion ∆x. We can illustrate the
motion model by the following diagram:
+∆x
Motion :	xt --------→	xt+1
JJJ	(2)
M (∆x)×
v(xt) -----→ v(xt+1)
See Figure 2(1). Both v(x) and M (∆x) are to be learned.
We can discretize ∆x, and learn a motion matrix M for each ∆x. We can also learn a parametric
model for M. To this end, We can further parametrize M = I + M(∆χ) such that each element of
∙-v
M (∆x) is a quadratic (or polynomial) function of ∆x = (∆x1, ∆x2):
Mij (∆x) = β(1)∆xι + β(2)∆x2 + β(11)∆x2 + β(22)∆x2 + β(12)∆xι∆x2,	(3)
Where the coefficients β are to be learned. The above may be considered a second-order Taylor
expansion Which is expected to be accurate for small ∆x ∈ ∆, Where ∆ is the alloWed collection of
one-step displacements, e.g., ±3 grid points in each direction on the 40 × 40 grid.
The motion model can be considered a linear recurrent neural netWork (RNN). HoWever, if We are
to interpret M as the Weight matrix, then the Weight matrix is dynamic because it depends on the
motion ∆x. One may implement it by discretizing ∆x, so that We have a finite set of ∆x, and thus
a finite set of M (∆x). Then at each time step, the RNN sWitches betWeen the finite set of motion
matrices. This is like the gearing operation ofa multi-speed bicycle.
3.2	Disentangled blocks or modules
For the sake of estimation accuracy and computational efficiency, We further assume that M (∆x)
is block diagonal, i.e., We can divide v into K blocks of sub-vectors, v = (v(k), k = 1, ..., K), and
3
Published as a conference paper at ICLR 2019
v(k) (x + ∆x) = M(k) (∆x)v(k) (x). That is, the vector v consists of sub-vectors, each of which
rotates in its own subspace, so that the dynamics of the sub-vectors are disentangled.
The assumption of disentangled blocks in our model is related to the modular organization of grid
cells in neuroscience (Stensola et al. (2012)), where a module refers to a region of grid cells where
all cells share similar grid scales and orientations.
3.3	Sub-model 2 about local geometry: magnified local isometry
The above motion algebra alone is not sufficient for learning the vector matrix representations,
because a trivial solution is that all the v(x) are the same, and the matrix M (∆x) is always identity.
We need to properly displace the vectors v(x). So we shall model hv(x), v(y)i both locally and
globally.
Let d be the dimensionality of v(k), i.e., the number of grid cells within the k-th block. For the local
geometry, we assume that for each block,
hv(k)(x), Vlkk (X + ∆x)i = d(1 — ak∣∆x∣2),	(4)
for all x and	∆x	such that ak∣∆x∣2 ≤ c, i.e., ∆x ∈ ∆(ak)	=	{∆x	:	αk∣∆x∣2	≤	c}.	In our
experiments, we take c = 1.5. αk can be either designed or learned.
Based on sub-model (4), kv(k)(x)k2 = d for every x. The inner product on the left hand side
is dcos(∆θ)	where	∆θ	is the angle between v(k)(x)	and	v(k)(x	+	∆x).	1 —	α%∣∆x∣2 on the
right hand side may be considered a second order Taylor expansion of a function f (r) such that
f (0) = 1, f (0) = 0, i.e., 0 is the maximum, and f00(θ) = -2ɑk. It is also an approximation to
cos(√2αk |∆x|). Let ωk = √2ɑk, We have
Magnified local isometry : ∆θ = ωk∣∆x∣,	(5)
i.e., the angle between v(χ) and v(χ + ∆χ) magnifies the distance ∣∆χ∣ by a factor of ωk uniformly
for all x. See Figure 2(2).
The factor ωk defines the metric of block k.
3.4	Rotation and projection
Since kv(k) (x)k is a constant for all x, M(k) (∆x) is an orthogonal matrix, and the self-motion is
represented by a rotation in the d-dimensional space. ωk ∣∆x∣ is the angular speed of rotation of the
sub-vector k. (v(k)(x), ∀x) forms a 2D sub-manifold on the sphere in the d-dimensional space. v(k)
is like an arm of a clock except that the clock is not a 1D circle, but a 2D sub-manifold.
This 2D sub-manifold becomes a local codebook for the 2D positions within a local neighborhood.
For a vector v(k), we can decode its position by projecting it onto the 2D sub-manifold, to get
X = arg maxχhv(k), v(k) (x)i where the maximization is within the local neighborhood.
3.5	Error correction
The neurons are intrinsically noisy and error prone. For ωk = √20k>1, the magnification offers
error correction because v(k) (X) and v(k) (X + ∆X) are far apart, which is resistant to noises or
corruptions. That is, projection to the 2D sub-manifold codebook removes the noises.
Specifically, suppose we have a vector U = v(k)(x) + e, where E 〜 N(0, s2Id), and Id is the
d-dimensional identity matrix. We can decode X from U based on the codebook by maximizing
hu, v(k)(y)i = hv(k)(x), v(k) (y)i +〈g v(k)(y)i = d(1 — αk |y — x|2) + √dsZ over y that is within a
local neighborhood of x, where Z 〜N(0,1). The optimal y will be close to X because if y deviates
from x by ∆x, then the first term will drop by dɑk ∣∆x∣2, which cannot be made up by the second
term JdsZ due to noises, unless the noise level S is extremely large. From the above analysis, we
can also see that the larger d is, the more resistant the system is to noise, because the first term is of
order d and the second term is of order √d.
In addition to additive noises, the system is also resistant to multiplicative noises including dropout
errors, i.e., multiplicative Bernoulli 0/1 errors. The dropout errors may occur due to noises, aging, or
diseases. They may also be related to the asynchronous nature of the neuron activities in computing.
4
Published as a conference paper at ICLR 2019
3.6	Hexagon grid patterns
While the magnified local isometry enables error correction, it also causes global periodicity. Be-
cause the angle between nearby v(k) (x) and v(k) (x + ∆x) is magnified, when we vary x, the vector
v(k) (x) will rotate at a magnified speed ωk ∣∆χ∣, so that it quickly rotates back to itself, like an arm
ofa clock. Thus each unit of v(k) (x) is periodic with ωk determining the periodicity.
Our experiments show that sub-models (1) and (2) are sufficient for the emergence of hexagon grid
patterns. In fact, we have the following analytical solution (see Appendix for a proof):
Theorem 1. Let e(x) = (eihaj,xi,j = 1, 2, 3)>, and aι, a2, a3 are three 2D vectors so that the
angle between ai and aj is 2π∕3 for ∀i = j and |aj | = 2√a for ∀j. Let C be a random 3 X 3
complex matrix such that C*C = I. Then v(x) = Ce(X), M(∆x) = Cdiag(e(∆x))C* satisfy
equation 1 and equation 4 approximately for all x and small ∆x.
v(x) amounts to a 6-dimensional real vector. Since the angle between ai and aj is 2π∕3 for ∀i 6= j,
patterns of v(x) over x have hexagon periodicity. Moreover, the scale of the patterns is controlled
by the length of aj, i.e., the scaling parameter α.
We want to emphasize that sub-models (1) and (2) are about local ∆x, where we do not make
any assumptions about global patterns, such as Fourier basis. In contrast, the solution in the above
theorem is global. That is, our model assumes much less than the solution in the theorem. Our
experiments show that the hexagon patterns will emerge as long as the number of units is greater
than or equal to 6.
3.7	Sub-model 3 about global geometry: adjacency kernel
Because of the periodicity, each block (v(k) (x), ∀x) does not form a global codebook of 2D posi-
tions, i.e., there can be x 6= y, but v(k) (x) = v(k) (y), i.e., v(k) does not encode x uniquely. We
can combine multiple blocks to resolve the global ambiguity. Specifically, let v(x) = (v(k) (x), k =
1, ..., K) be the whole vector, we assume the following global adjacency sub-model for the whole
vector:
K
hv(x), v(y)i = Xhv(k)(x), v(k)(y)i = (K d)f (|x - y|),	(6)
k=1
where (v(x), M(∆x),αk, ∀x, ∆x, k) are to be learned.
Recall d is the number of grid cells in each block, and K is the number of blocks. f(r) is the
adjacency kernel that decreases monotonically as the Euclidean distance r = |x - y | increases.
One example of f is the Gaussian kernel f(r) = exp -r2∕2σ2 . Another example is the exponen-
tial kernel f(r) = exp (-r∕σ) . As a matter of normalization, we assume f(0) = 1, which is the
maximum of f(r).
Since f(0) = 1, kv(x)k2 = Kd for any x, and hv(x), v(y)i = (Kd) cos θ, where θ is the angle
between v(x) and v(y), and we have
Global adjacency : cos θ = f(|x - y|).	(7)
The angle between any two vectors is always less than π∕2. See Figure 2(3).
By fitting the multiple sub-vectors together, we still retain the error correction capacity due to magni-
fied local isometry, meanwhile we eliminate the ambiguity by letting hv(k) (x), v(k) (y)i for different
k cancel each other out by destructive interference as y moves away from x, so that we obtain unique
decoding of positions. Let C = {v(x), x ∈ D} be the codebook sub-manifold, error correction of a
vector u is obtained by projection onto C: arg maxv∈C hu, vi.
The whole vector V is like a K-arm clock, with each v(k) being an arm rotating at a speed ωk ∣∆x∣ =
√2αk∣∆x∣.
3.8	Localization and heat map
(v(x), ∀x) forms a global codebook for x. It is a 2D sub-manifold on the sphere in the (Kd)-
dimensional space. For a vector v, we can decode its position by its projection on the codebook
5
Published as a conference paper at ICLR 2019
manifold. Since f(r) is monotonically decreasing, h(x) = hv, v(x)i gives us the heat map to decode
the position of V uniquely. Let the decoded position be x, then X = argmaxχhv,v(x)i. We can
obtain the one-hot representation δχ of X by non-maximum suppression on the heat map h(χ).
Let V = (v(x), ∀x) be the (Kd) × N2 matrix (recall the domain D = [0, 1]2 is discretized into an
N × N lattice), where each column is a v(X). We can write the heat map h(X) = hv, v(X)i as a
N 2 -dimensional vector h = V >v, which serves to decode the position X encoded by v. Conversely,
for a one-hot representation of a position X, i.e., δx, which is a one-hot N 2 -dimensional vector, we
can encode it by v = V δx . Both the encoder and decoder can be implemented by a linear neural
network with connection weights V and V > respectively, as illustrated by the following diagram:
V>×
Localization : v ---------→ h (heat map and decoding to δx)
V×
δx -------→ v(X)	(encoding)
(8)
Note that in decoding v → h(X) → δx and encoding δx → v, we do not represent or operate on
the 2D coordinate X explicitly, i.e., X itself is never explicitly represented, although we may use the
notation X in the description of the experiments.
3.9	Path integral
Path integral (also referred to as dead-reckoning) is the task of inferring the self-position based
on self-motion (e.g., imagine walking in a dark room). Specifically, the input to path integral is a
previously determined initial position X0 and motion sequences {∆X1, ..., ∆XT}, and the output is
the prediction of one’s current position XT . We first encode the initial position X0 as v(X0). Then,
by the motion model, the hidden vector v(XT) at time T can be predicted as:
1
v(XT) =	t=T M(∆Xt)v(X0).	(9)
We can then decode XT from v(XT).
3.10	Path planning
Our representation system can plan direct path from the starting position X0 to the target position y
by steepest ascent on the inner product hv(X), v(y)i, i.e., let v0 = v(X0), the algorithm iterates
∆Xt = arg max hv(y), M (∆X)vt-1 i,	(10)
∆x∈∆
vt = M(∆Xt)vt-1,	(11)
where ∆ is the set of allowable displacements ∆X.
When a rat does path planning, even if it is not moving, its grid cells are expected to be active. This
may be explained by the above algorithm. In path planning, the rat can also fantasize bigger step
sizes that are beyond its physical capacity, by letting ∆ include physically impossible large steps.
In general, our representation scheme (v(X), M (∆X), f(|X - y|)) mirrors (X, ∆X, |X - y|). Thus
the learned representation is capable of implementing existing path planning algorithms in robotics
(Siegwart et al. (2011)) even though our system does not have explicit coordinates in 2D (i.e., the
2D coordinates X are never explicitly represented by two neurons).
3.11	Place cells and scale
For each X, we may interpret hv(X), v(y)i/(Kd) = f(|X - y|) as a place cell whose response is
f(|X - y|) if the agent is at y, or at least, we may consider f(|X - y|) as an internal input to the place
cell based on self-motion, in addition to external visual cues.
For the Gaussian kernel f (r) = exp(-r2/2σ2), the choice of σ determines the scale. In path
integral, for accurate decoding of the position X from the vector v in the presence of noises, we
want σ to be small so that f(r) drops to zero quickly. However, in path planning, for a vector v,
we also want to know the Euclidean distance between its position X to a target position y, which
6
Published as a conference paper at ICLR 2019
may be far away from x. The distance is |x - y| = f-1(hv, v(y)i/(Kd)). For accurate estimation
of long distance in the presence of noises, we need σ to be large, so that the slope of f-1 is not
too big. Perhaps we need multiple f (r) with different σ, and for each f (r) we have (Kd)f (r) =
PkK=1 γk hv(k) (x), v(k) (y)i, where different f(r) have different coefficients (γk) while sharing the
same (v(k) (x)). We shall study this issue in future work.
3.12	Group representation in motor cortex
Where does the self-motion ∆x come from? It comes from the movements of head and legs, i.e.,
each step of navigation involves a whole process of path integral and path planning of the movements
of head and legs (as well as arms). In general, we can use the same system we have developed for
the movements of head, legs, arms, fingers, etc. Their movements form groups of actions. In
navigation, the movements belong to 2D Euclidean group. In body movements, the movements
belong to various Lie groups. Our method can be used to learn the representational systems of
these groups, and such representations may exist in motor cortex. We leave this problem to future
investigation.
4	Learning representation
The square domain D is discretized into a 40 × 40 lattice, and the agent is only allowed to move on
the lattice. We can learn (v(x), ∀x) and (M (∆x), ∀∆x) (or the β coefficients that parametrize M)
by minimizing the following loss functions.
For sub-model (1) on vector-matrix multiplication, the loss function is
L1 = Ex,∆x kv(x + ∆x) - M (∆x)v(x)k2 ,	(12)
where x is sampled from the uniform distribution on D = [0, 1]2, and ∆x is sampled from the
uniform distribution within a certain range ∆1 (3 grid points in each direction in our experiments).
The above motion loss is a single-step loss. It can be generalized to multi-step loss
L1,T = Ex,∆x1,...∆xT kv(x + ∆x1 + ... + ∆xT) - M(∆xT)...M(∆x1)v(x)k2 ,	(13)
where (∆xt, t = 1, ..., T) is a sequence of T steps of displacements, i.e., a simulated trajectory.
For sub-model (2) on magnified local isometry, the loss function is
L2,k = Eχ,∆x [(hv(k)(x),v(k)(x + ∆x)i - (d(1 - αk∣∆x∣2))2] ,	(14)
where for fixed ak, ∆x is sampled uniformly within the range ∆2(ɑk) = {∆x : αk∣∆x∣2 ≤ c}
(c = 1.5 in our experiments). We can define L2 = PkK=1 L2,k.
For sub-model (3) on global adjacency kernel, the loss function is
L3 = Ex,y ((K d)f (|x -y|) - hv(x), v(y)i)2 ,	(15)
where both x and y are sampled uniformly from D.
Let v(x) = (vi(x), i = 1, ..., Kd), we also impose a regularization loss L0 = PiK=d1(Ex[vi(x)2] -
1)2 , to enforce uniform energy among the grid cell. It also helps to break the symmetry caused by
the fact that the loss function is invariant under the transformation v(x) → Qv(x), ∀x, where Q is
an arbitrary orthogonal matrix. This loss is not crucial though, so we will make it implicit for the
rest of the paper.
Fixing the magnitude of Ex [vi (x)] within a certain range is biologically plausible, because vi (x)
is a single cell. For mathematical and computational convenience, we can also normalize v(x) so
that Ilv(X)k2 = 1, hv(χ),v(y)i = f(|x — y|), hv(k)(χ),v(k)(χ + ∆χ)i = (1 一 αk∣∆x∣2)/K,
and Ex [vi(x)2] = 1/(Kd). When learning a single block, we can normalize v(k) (x) so that
∣∣v(k)(x)k2 = 1, hv(k)(x), v(k) (x + ∆x)i = 1 — αk ∣∆x∣2 and Eχ[vi(x)2] = 1/d.
The total loss function is a linear combination of the above losses, where the weights for combining
the losses are chosen so that the weighted losses are of the same order of magnitude.
7
Published as a conference paper at ICLR 2019
The loss function is minimized by Adam optimizer (Kingma & Ba (2014)) (lr = 0.03) for 6, 000
iterations. A batch of 30, 000 examples, i.e., (x, ∆xt, t = 1, ..., T)) for L1, (x, ∆x) for L2, and
(x, y) for L3 are sampled at each learning iteration as the input to the loss function. In the later
stage of learning (≥ 4, 000 iterations), kv(x)k = 1 is enforced by projected gradient descent, i.e.,
normalizing each v(x) after the gradient descent step.
5	Experiments
5.1	Learning single blocks: hexagon patterns and metrics
(a) Learned single block with 6 units
Figure 3: Learned units of a single block with fixed α. (a) Learned single block with 6 units. Every row shows
the learned units with a given α. (b) Learned single block with 100 units and α = 72.
(b) Learned single block with 100 units
We first learn a single block with fixed αk by minimizing L1 + λ2L2,k (we shall drop the subscript
k in this subsection for simplicity). Figure 3 shows the learned units over the 40 × 40 lattice of x.
Figure 3(a) shows the learned results with 6 units and different values ofα. The scale or metric of the
lattice is controlled by α. The units within a block have patterns with similar scale and arrangement,
yet different phases. Figure 3(b) shows the learned results with 100 units and α = 72, indicating
that the grid-like patterns are stable and easy to learn even when the number of units is large.
5.2	Learning multiple hexagon blocks and metrics
αk
3.9
4.7
11.9
17.0
17.3
35.7
39.1
39.7
Learned blocks
三1KN"3
播寞修服或过
心球溢彩M翔
αk
Learned blocks
44.1
56.3
57.0
61.7
73.0
85.7
87.5
94.7
(b) Disentangled blocks
(a) Learned multiple blocks and metrics
Figure 4: (a) Response maps of learned units of the vector representation and learned scaling parameters αk .
Block size equals 6 and each row shows the units belonging to the same block. (b) Illustration of block-wise
activities of the units (where the activities are rectified to be positive).
8
Published as a conference paper at ICLR 2019
We learn multiple blocks by minimizing L1 + λ2L2 + λ3L3. Instead of manually assigning αk, we
learn αk by gradient descent, simultaneously with v and M .
In Figure 4(a), we show the learned units v(x) over the 40 × 40 lattice of x and the learned metrics
αk. A Gaussian kernel with σ = 0.08 is used for the global adjacency measure f(|x - y|). Block
size is set to 6 and each row shows the learned units belonging to the same block. The scales of the
firing fields are controlled by the learned αk .
Figure 4(b) illustrates the combination of multiple blocks. For the localization model, given a vector
v, the heat map of a single block hv(k) , v(k) (x)i has periodic firing fields and cannot determine a
location uniquely. However, ambiguity disappears by combing the heat maps of multiple blocks,
which have firing fields of multiple scales and phases that add up to a Gaussian kernel hv, v(x)i.
The Gaussian kernel informs the place cell, by which the location is determined uniquely. For a
motion ∆x, every block rotates in its own subspace with motion matrix M(k) (∆x), resulting in
phase shifting in the heat map of each single block.
In the subsequent experiments, we shall learn the grid cells by minimizing L1 + λ3L3 for simplicity.
5.3	Path integral
(a) Predicted path	(b) MSE over time step (c) Selection of block sizes and kernels
Figure 5: (a) Path integral prediction. The black line depicts the real path while red dotted line is the predicted
path by the learned model. (b) Mean square error over time step. The error is average over 1, 000 episodes.
The curves correspond to different numbers of steps used in the multi-step motion loss. (c) Mean square error
performed by models with different block sizes and different kernel types. Error is measured by number of
grids.
Figure 5(a) shows an example of path integral result (time duration T = 40), where we use single
step motion loss L1,T =1 in learning. Gaussian kernel with σ = 0.08 is used as the adjacency
measure in L3 . We find single-step loss is sufficient for performing path integral. The mean square
error remains small (〜1.2 grid) even after 400 steps of motions (figure 5(b)). The error is averaged
over 1, 000 episodes. The motion loss can be generalized to multi-step L1,T , as shown by equation
13. In Figure 5(b), we show that multi-step loss can improve the performance slightly.
In Figure 5(c) we compare the learned models with fixed number of units (96) but different block
sizes. We also compare the performance of models using Gaussian kernel (σ = 0.08) and expo-
nential kernel (σ = 0.3) as the adjacency measure in the localization model. The result shows that
models with Gaussian kernel and block size ≥ 3, and with exponential kernel and block size ≥ 4
have performances comparable to the model learned without block-diagonal assumption (block size
= 96).
5.4	Path planning
For path planning, we assume continuous x and ∆x. First, we design the set of allowable motions
∆. For a small length r, we evenly divide [0, 2π] into n directions {θi, i = 1, ..., n}, resulting in
n candidate motions ∆ = {∆xi = (r cos(θi), r sin(θi)), i = 1, ..., n}. These n small motions
serve as motion basis. Larger motion can be further added to ∆ by estimating the motion matrix
M (k∆xi) = Mk (∆xi). The starting position and destination can also be any continuous values,
where the encoding to the latent vector is approximated by bilinear interpolation of nearest neighbors
on the lattice.
9
Published as a conference paper at ICLR 2019
In the experiments, we choose r = 0.05 and n = 100, and add another set of motions with length
0.025 to enable accurate planning. The system is learned with exponential kernel (σ = 0.3) as
global adjacency to encourage connection of long distance. Figure 6(a) shows planning examples
with six settings of motion ranges ∆. Including larger motions accelerates the planning process so
that it finishes with less steps. We define one episode to be a success if the distance between the
end position and the destination is less than 0.025. We achieve a success rate of > 99% over 1, 000
episodes for all the six settings.
(a) Simple planning
(b) Planning with dot obstacle
(c) Various obstacles
Figure 6: (a) Planning examples with different motion ranges. Red star represents the destination y and green
dots represent the planned position {x0 + it=1 ∆xi }. (b) Planning examples with a dot obstacle. Left figure
shows the effect of changing scaling parameter a, while right figure shows the effect of changing annealing
parameter b. (c) Planning examples with obstacles mimicking walls, large objects and simple mazes.
The learned system can also perform planning with obstacles, where the global adjacency between
the agent’s current position and an obstacle serves as a repulsive forces. Specifically, suppose z is
an obstacle to avoid, the agent can choose the motion ∆xt at time t by
∆xt = arg max hv(y), M(∆x)vti - ahv(z), M (∆x)vt ib ,	(16)
where a and b are the scaling and annealing parameters. Figure 6(b) shows the planning result with
a dot obstacle laid on the direct path between the starting position and destination, with tuning of a
and b. We choose a = 0.5 and b = 6 in subsequent experiments.
Now suppose we have more complicated obstacles {zi}im=1. They can be included by summing
over the kernels of every obstacle {ahv(zi), M (∆x)vtib}im=1 and choosing ∆xt at time t by
∆xt = arg max∆x∈∆ hv(y), M(∆x)vti - Pim=1 ahv(zi), M (∆x)vtib . Figure 6(c) shows some
examples, where the obstacles mimicking walls, large objects and simple mazes.
The above method is related to the potential field method in robotics (Siegwart et al. (2011)).
6	Discussion: rotationist-connectionist model?
In terms of general modeling methodology, a typical recurrent network is of the form vt =
tanh(W (vt-1, δt)), where vt is the latent vector, δt is the input change or action. vt-1 and δt
are concatenated and linearly mixed by W , followed by coordinate-wise tanh non-linearity. We re-
place it by a model of the form vt = M (δt)vt-1, where M(δt) is a matrix that is non-linear in δt.
M(δt) is a matrix representation of δt. vt can be interpreted as neuron activities. We can discretize
the value of δt into a finite set {δ}, and each M(δ) can be stored as synaptic connection weights that
drive the neuron activities. In prediction, the input δt activates M(δt). In planning or control, all the
{M (δ)} are activated, and among them the optimal δ is chosen.
The matrix representation of the above model is inspired by the group representation theory, where
the group elements are represented by matrices acting on the vectors (Fulton & Harris (2013)). It
underlies much of modern mathematics and holds the key to the quantum theory (Zee (2016)). Per-
haps it also underlies the visual and motor cortex, where neurons form rotating sub-vectors driven by
matrices representing groups of transformations. One may call it a rotationist-connectionist model.
10
Published as a conference paper at ICLR 2019
Project page
http://www.stat.ucla.edu/'ruiqigao/gridcell/main.html
Acknowledgement
We thank the three reviewers for their insightful comments and suggestions. Part of the work was
done while Ruiqi Gao was an intern at Hikvision Research Institute during the summer of 2018. She
thanks Director Jane Chen for her help and guidance. We also thank Jiayu Wu for her help with
experiments and Zilong Zheng for his help with visualization. The work is supported by DARPA
XAI project N66001-17-2-4029; ARO project W911NF1810296; ONR MURI project N00014-16-
1-2007; and a Hikvision gift to UCLA. We gratefully acknowledge the support of NVIDIA Corpo-
ration with the donation of the Titan Xp GPU used for this research.
References
Andrea Banino, Caswell Barry, Benigno Uria, Charles Blundell, Timothy Lillicrap, Piotr Mirowski,
Alexander Pritzel, Martin J Chadwick, Thomas Degris, Joseph Modayil, et al. Vector-based
navigation using grid-like representations in artificial agents. Nature, 557(7705):429, 2018.
Hugh T Blair, Adam C Welday, and Kechen Zhang. Scale-invariant memory representations emerge
from moire interference between grid fields that produce theta oscillations: a computational
model. Journal OfNeuroscience, 27(12):3211-3229, 2007.
Yoram Burak and Ila R Fiete. Accurate path integration in continuous attractor network models of
grid cells. PLoS computational biology, 5(2):e1000291, 2009.
Daniel Bush, Caswell Barry, Daniel Manson, and Neil Burgess. Using grid cells for navigation.
Neuron, 87(3):507-520, 2015.
Corinna Cortes and Vladimir Vapnik. Support-vector networks. Machine learning, 20(3):273-297,
1995.
Christopher J Cueva and Xue-Xin Wei. Emergence of grid-like representations by training recurrent
neural networks to perform spatial localization. arXiv preprint arXiv:1803.07770, 2018.
Licurgo de Almeida, Marco Idiart, and John E Lisman. The input-output transformation of the
hippocampal granule cells: from grid cells to place fields. Journal of Neuroscience, 29(23):7504-
7512, 2009.
Christian F Doeller, Caswell Barry, and Neil Burgess. Evidence for grid cells in a human memory
network. Nature, 463(7281):657, 2010.
Ugur M Erdem and Michael Hasselmo. A goal-directed spatial navigation model using forward
trajectory planning based on grid cells. European Journal of Neuroscience, 35(6):916-931, 2012.
Ila R Fiete, Yoram Burak, and Ted Brookings. What grid cells convey about rat location. Journal of
Neuroscience, 28(27):6858-6871, 2008.
William Fulton and Joe Harris. Representation theory: a first course, volume 129. Springer Science
& Business Media, 2013.
Marianne Fyhn, Torkel Hafting, Menno P Witter, Edvard I Moser, and May-Britt Moser. Grid cells
in mice. Hippocampus, 18(12):1230-1238, 2008.
Torkel Hafting, Marianne Fyhn, Sturla Molden, May-Britt Moser, and Edvard I Moser. Microstruc-
ture ofa spatial map in the entorhinal cortex. Nature, 436(7052):801, 2005.
Joshua Jacobs, Christoph T Weidemann, Jonathan F Miller, Alec Solway, John F Burke, Xue-Xin
Wei, Nanthia Suthana, Michael R Sperling, Ashwini D Sharan, Itzhak Fried, et al. Direct record-
ings of grid-like neuronal activity in human spatial navigation. Nature neuroscience, 16(9):1188,
2013.
11
Published as a conference paper at ICLR 2019
Nathaniel J Killian, Michael J Jutras, and Elizabeth A Buffalo. A map of visual space in the primate
entorhinal cortex. Nature, 491(7426):761, 2012.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Rosamund F Langston, James A Ainge, Jonathan J Couey, Cathrin B Canto, Tale L Bjerknes,
Menno P Witter, Edvard I Moser, and May-Britt Moser. Development of the spatial represen-
tation system in the rat. Science, 328(5985):1576-1580, 2010.
Bruce L McNaughton, Francesco P Battaglia, Ole Jensen, Edvard I Moser, and May-Britt Moser.
Path integration and the neural basis of the’cognitive map’. Nature Reviews Neuroscience, 7(8):
663, 2006.
Andrew Y Ng, Michael I Jordan, and Yair Weiss. On spectral clustering: Analysis and an algorithm.
In Advances in neural information processing systems, pp. 849-856, 2002.
John O’Keefe. A review of the hippocampal place cells. Progress in neurobiology, 13(4):419-439,
1979.
Francesca Sargolini, Marianne Fyhn, Torkel Hafting, Bruce L McNaughton, Menno P Witter, May-
Britt Moser, and Edvard I Moser. Conjunctive representation of position, direction, and velocity
in entorhinal cortex. Science, 312(5774):758-762, 2006.
Roland Siegwart, Illah Reza Nourbakhsh, Davide Scaramuzza, and Ronald C Arkin. Introduction to
autonomous mobile robots. MIT press, 2011.
Sameet Sreenivasan and Ila Fiete. Grid cells generate an analog error-correcting code for singularly
precise neural computation. Nature neuroscience, 14(10):1330, 2011.
Hanne Stensola, Tor Stensola, Trygve Solstad, Kristian Fr0land, May-Britt Moser, and Edvard I
Moser. The entorhinal grid map is discretized. Nature, 492(7427):72, 2012.
Albert Tsao, J0rgen Sugar, Li Lu, Cheng Wang, James J Knierim, May-Britt Moser, and Edvard I
Moser. Integrating time from experience in the lateral entorhinal cortex. Nature, 561(7721):57,
2018.
Michael M Yartsev, Menno P Witter, and Nachum Ulanovsky. Grid cells without theta oscillations
in the entorhinal cortex of bats. Nature, 479(7371):103, 2011.
Anthony Zee. Group theory in a nutshell for physicists. Princeton University Press, 2016.
12
Published as a conference paper at ICLR 2019
A Proof for section 3.6
Proof. (aj , j = 1, 2, 3) forms a tight frame P3=1hx, aji2 (X |x|2.	in the 2D space, in that for any vector x	in 2D,
Since C* C = I, We have		
hv(x), v(y)i	= v(x)*v(y)	(17)
	= e(x)*C*Ce(y)	(18)
		
	3 =	eihaj,y-xi. j=1	(19)
		
Then We have		
RE(hv(x), v(x + ∆x)i)	3 =	cos(haj , ∆xi) j=1	(20)
		
	≈ X(I -haj, ∆χi2/2) j=1	(21)
		
	3 =3 - Xhaj, Xxi /2	(22)
	j=1	
	=3(1 — α∣∆x∣2),	(23)
where ∣o7-1 = 2√ɑ. The self motion from v(x) to v(x + ∆x) is		
v(x + ∆x) =	Ce(x + ∆x)	(24)
=	CD(∆x)e(x)	(25)
=	CD(∆x)C*v(x)	(26)
=	M (∆x)v (x),	(27)
where D(∆x) = diag(eihaj,∆xi ,j = 1, 2, 3).		□
If K > 1 and block size = 6, we can fit the multiple blocks together by a Fourier expansion of the		
kernel function		
f(|x - y|) =	hv(x), v(y)i	(28)
	K3	
≈	XX eihakj,y -xi	(29)
	k=1 j=1	
	K	
=	Xhv(k)(x),v(k)(y)i.	(30)
	k=1	
B Hexagon grid patterns and metrics
B.1 Simulated input data
We obtain input data for learning the model by simulating agent trajectories with the number of
∙-v
steps equal to T in the square domain D. D is discretized into a 40 × 40 lattice and the agent is
only allowed to move on the lattice. The agent starts at a random location x0 . At each time step t,
a small motion ∆xt (≤ 3 grids in each direction) is randomly sampled with the restriction of not
■—
t t ∙ .ι	. . ∙ i .< t t	t. ∙ ♦	♦ ι.ι.	t	t―'t A	m
leading the agent outside the boundary, resulting in a simulated trajectory {x0 + i=1 ∆xi}tT=1. T
is set to 1, 000 to obtain trajectories that are uniformly distributed over the whole area. Although
the trajectories used for training are restricted to the lattice and with small motions, in Section 5.4
13
Published as a conference paper at ICLR 2019
we show that the learned model can be easily generalized to handle continuous positions and large
motions. In training, pairs of locations (x, y) are randomly sampled from each trajectory as the input
to the adjacency loss L3, while consecutive position sequences (x, ∆xt, t = 1, ..., T ) are randomly
sampled as the input to the motion loss L1, with length specified by T (which is usually much
smaller than the whole length of the trajectory T).
B.2	Learned single block units with different block sizes
In (Blair et al. (2007)), the grid cell response is modeled by three cosine gratings with different
orientations and phases. In our model, we learn such patterns of different scales without inserting
artificial assumptions.
(g) Block size = 9
(a) Block size = 2
(h) Block size = 10
(b) Block size = 3
(i) Block size = 20
(c) Block size = 4
(d) Block size = 5
(e) Block size = 7
(f) Block size = 8
Figure 7: Response maps of learned single block units with different block sizes
(j) Block size = 40
Figure 7 displays the response maps of the learned single block units with different block sizes. For
block sizes 4 and 5, the learned maps show square lattice patterns. For block sizes greater than or
equal to 6, the learned maps show hexagon lattice patterns.
B.3	Learned multiple block units and metrics
B.3.1	With different block sizes
Figure 8 displays the response maps of the multiple block units with different block sizes. The
metrics of the multiple blocks are learned automatically.
B.3.2 With different shapes of area
Figure 9 displays the response maps of the multiple block units with different shapes of the area,
such as circle and triangle.
B.4	Quantitative analysis of spatial activity
We assess the spatial activity of the learned units quantitatively using measures adopted from the
neuroscience literature. Specifically, we quantify the hexagonal regularity of the grid-like patterns
using the gridness score (Langston et al. (2010); Sargolini et al. (2006)). The measure is derived
from the spatial autocorrelogram of each unit’s response map. A unit is classified as a grid cell
if its gridness score is larger than 0. For those units that are classified as grid cells, grid scale and
orientation can be further derived from the autocorrelogram following Sargolini et al. (2006). Figure
10(a) summarizes the results. 76 out of 96 learned units are classified as grid cells. Most units with
large learned αk are classified as grid cells, while those units with small αk are not due to the lack
of a full period of hexagonal patterns. The grid scales and orientations vary among units, while
14
Published as a conference paper at ICLR 2019
αk	Learned blocks	αk	Learned blocks
5.7	口 K	4.6	
7.7		6.7	■■■
10.4		10.6	
10.7	Illlf	11.0	”：：：
11.6	慌”	13.9	V?.;-
12.7	岸	23.4	：：：：££，：:
18.0	■■	31.3	联:靠煎
31.2		38.9	添彩番
31.2	力％	39.3	避戮崔
37.8	mi mi	56.7	源麴侬
56.0	多爰	64.5	⅛¾i⅛≡
68.0	≡≡	72.3	≡≡B:
73.5		75.4	潮:然修
74.3	≡≡	80.5	娥穿越
86.5		84.4	舞德舞
92.5		93.0	逑蕊卷
(a) Block size = 2
(b) Block size = 3
αk	Learned blocks
37579793113763
.............................................................................
28958912516708
11122345566678
αk	Learned blocks
1.8
9.1
12.4
18.5
28.6
32.8
41.9
48.6
49.9
58.0
64.5
73.0
74.9
77.8
81.7
97.1
(d) Block size = 5
remaining similar within each block. We show the histograms of the grid orientations and scales
in Figure 10(b) and 10(c) respectively. Moreover, we average the grid scales within each block and
make the scatter plot of the averaged grid scales and the learned 1 /√ak in figure 10(d). Interestingly,
the grid scale is nicely proportional to the learned 1∕√ak.
B.5	Ablation studies
We conduct ablation studies to assess various assumptions in our model.
B.5.1	Loss terms
We learn v and M with multiple blocks by minimizing L1 + λ2L2 + λ3L3, which consists of (1) a
motion loss L1, (2) a local isometry loss L2, and (3) a global adjacency loss L3. Figure 11 shows
the learned units when using only some of the components. Grid-like patterns do not emerge if
using only the adjacency loss L3, or only the isometry loss L2 . If using only the motion loss, the
motion equation is approximately satisfied at the beginning of training, since both v and M are
initialized from small values that are close to 0. The system cannot be learned without an extra
term to push v(x) apart from each other. Figure 11(c) shows the learned units using the adjacency
loss and the motion loss, leaving out the isometry loss. Grid-like patterns still emerge (also some
strip-like patterns), although less obvious than the ones learned using the full loss.
B.5.2	Assumptions of motion matrix
In another ablation study, we drop the quadratic parametrization by β coefficients and the block
diagonal assumption of the motion matrix. A separate motion matrix M (∆x) is learned for each
displacement ∆x, and v(x) is assumed to be a single block. We use either the local isometry loss L2
or the global adjacency loss L3 in addition to the motion loss L1. The results are shown in Figure
12. With the isometry loss, the setting is similar to the one of learning single block, except that the
parametrization of M (∆x) is dropped. As shown in figure 12(a), the learned units resemble the
ones learned with parametrized M (∆x), but when the block size is large, the grid-like patterns are
less obvious. With the adjacency loss, grid-like patterns do not emerge any more.
15
PUbHShed as a ConferenCe PaPersICLR 2s9
Leamed blocks
3-
6.8
10.3
1L7
142
21
2L9
24
25.8
45
56.4
65.3
66
67.7
72.6
93J
•♦- - b ∙ ɪ 5.4
・ b - I - 7.2
⅜t▼二• • ・ Q 8.5
■ ♦ ■?• ■ • 4 14.5
■•・*18.5
・•/二√∙rΛ; ・•,・,・ γ⅝∙19.5
・/ JI∙∙∙∙∙w⅜0√∙"・ 一•*2∞1
J •;• I ~∙46.9
;•«二 J - r∙>c√∙∙∙γ∙∕•二∙∙r 47.8
•・・:.••• ∙.∙∙∙J∙√∙4∙: • : 1 -・•・••▲ 56.2
(e) BIOCk SiZeH 7
皴缕髅雷蹦炉跟浮二:Q弓臣i工/ZZ
I趣懑强冷劈第修殂就道常少％；二二
复戮撼展潴密再漆瘦瘟僚迷声,力广S
I镶殿速能畿固锻点修喏花：£■＞："
尊溪校处	不：沁腐5«"
趣教软爨覆琶系送揍此之信心毛注公
懿添淑：;蜃怒慧花•我贷学T，H二j”匕
Qk
5.3
6.4
62
15.4
16J
25
21.0
32
38J
42
65J
65J
67.5
74.5
75.8
76J
Learned blocks
NU二wκy
lvutfsrx∕N”
u%‰τwwv
⅛l∙l∙vvmejw
Z拳EKSCKkS
⅛爆尼必宓近第券£
忑及油NQ害器若>
鬲国"½,⅛选E演华
窥落我前承技免善%
溺⅛袋房：讼行笫裟海
葭喙可
焦烈酒滋党运爱例案
球经望≡,≡谍嶷柒盛
峰溶匏次燮≡添≡≡
城≡携獴漫遨勰≡嬷
&SBSS
(g) Block SiZeH 9
3.9
8.8
9.3
10.5
13.9
19.3
20.4
20.9
31.6
34.9
35.7
57.5
61.3
67.5
78.7
80.0
Learned blocks
rlυtsf ys
蜜a∙∙∙∙∙∙”::
0U,N»<∙ZO
κκ∕euMEl52sκ
••X三力火N«'••，晨
≡s%∙>胆心盘⅞∙∙∙∙κ
工总七⅛≡^E»•:?壬过
›∙½κ∙κ⅛wt不vα
3瓶褂登心%⅛⅞送⅛
次过篁寤结端舞奥宾温
嗡温靖粉/索万¾窸然
泊澎逑拜潦，不怒翻潦舞
演≡温泰≡缢懑圆穿⅛⅛
秘算犍裳篌花疑卷零统
部堡登B急君施累缴≡
翱≡您潘Bi⅛崇懑僦≡
Ch) BIOCk SiZeHlO
FigUre90Lea3ed multiple-OCk UnirS and msrics Wirh different:-OCk SiZeS
C MoDELlNG EGoCENTRlC MOTlON
The model Can be generaHZedhandle egocenrc motion rhvves head direcrn∙
16
Published as a conference paper at ICLR 2019
αk
5.6
5.9
10.2
12.0
12.6
18.3
22.5
23.9
26.3
31.7
37.9
60.2
71.8
72.0
93.7
94.4
Learned blocks
快0 ∙∙“Q∙⅛
硬Λ V，2密
湍目然&需暂
右硅除霏嘘场
总第⑥出期录
埠电电⅛ ⅞ ：；:
要卷费⅛矮。
举等啰零缝检
涌亲瀚口搬卷
砂好感卷落薄
醇鎏除密维耀
缴脸建然祗:密
(a) Circular area
αk
4.3
6.5
10.8
13.4
16.0
18.7
19.9
20.6
26.1
36.5
37.5
54.4
59.5
62.3
83.8
85.4
Learned blocks
&4 aλλ∕∖λaʌ /ʌ,AAAA之盛⅛
AAΛl⅛,Λ.:∙A以 j 心A.*..承承.兴.¾
▲AA4。AAA立A尻AA愿忌∕⅛
(b) Triangular area
Figure 9: Learned multiple block units and metrics with different shapes of the area
C.1 Coupling two grid systems
The egocentric motion consists of angular velocity in the change of head direction and the spatial
velocity along the current head direction. We couple two grid systems, one for head direction and
the other for the spatial position. For notational simplicity, we put the “hat” notation on top of v and
M notation to denote the vector and matrix for the head direction.
Specifically, the agent has a head direction θ, which may change over time. The agent moves along
ʌ
its head direction with scalar motion. We can discretize the range of θ, [0, 2π], into N equally spaced
values {θi,i = 1,...,N}, and introduce a vector representation of self-direction. That is, the agent
ʌ
represents its self-direction by a d-dimensional hidden vector V(θ).
C.1.1 Motion sub-model
Suppose at a position x, the agent has a head direction θ. The self-motion is decomposed into (1) a
scalar motion δ along the head direction θ and then (2) a head direction rotation ∆θ. The self-motion
∆x = (δ cos θ, δ sin θ). We assume
ʌ
V(θ + ∆θ) = M(∆θ)V(θ),
v(x + ∆x) = M(δ, V(θ))v(x),
(31)
(32)
ʌ ʌ ʌ
where M (∆θ) is a d X d matrix that depends on ∆θ, and M (∆θ, V(θ)) is a d X d matrix that
ʌ
depends on δ and V(θ). M(∆θ) is the matrix representation of the head direction rotation ∆θ, while
M(δ,V(θ)) is the matrix representation of scalar motion δ along the direction θ.
17
Published as a conference paper at ICLR 2019
αk	Autocorrelograms of the learned units’s spatial rate maps	αk
Autocorrelograms of the learned units
13070757
...................................................
46713574
45567889
eɪ•¥a∙I0篓
O.O.LO.O.O.O.
∙≡¥••∙∙∙
0.0.LCiC!0.0.0.
-M - . - S 可:一-⅜-- M -∙⅛∙
0.d0.60.0.0.0.
(a) Autocorrelograms of the learned units’ response maps.
(c) Histogram of grid scales
(b) Histogram of grid
orientations
(d) Scatter plot of grid scales and
learned 1 / √αk
Figure 10: (a) Autocorrelograms of the learned units’ response maps. Gridness scores are calculated
based on the autocorrelograms. A unit is classified as a grid cell if the gridness score is larger than 0.
The gridness score is shown in red color if a unit fails to be classified as a grid cell. For those units
that are classified as grid cells, gridness score, scale and orientation are listed sequentially in black
color. Orientation is computed using a camera-fixed reference line (0°) and in counterclockwise
direction. (b) Histogram of grid orientations. (c) Histogram of grid scales. (d) Scatter plot of
averaged grid scales within each block versus the corresponding learned 1 / √Ok.
We can model M(δ, V(θ)) by an attention (or selection) mechanism:
hV(θ),V(θi ib
Pi = —K-------------------,
PN=i hv(θ),v(θi )ib
M (δ,V(θ)) = XNdiM ⑶(δ),
i=1
(33)
(34)
where M(i) (δ) is the matrix representation of scalar motion δ given the head direction θi. The inner
product hV(θ),V(θi)i, that informs the angular distance between θ and θi, serves as the attention
weight. b is an annealing (inverse temperature) parameter. If b → ∞, P = (pi,i = 1,...,TN)
becomes a one-hot vector for selection. We can further assume that M(∆θ) and M(i) (δ) are block
diagonal, and learn a parametric model for each of them by the second order Taylor expansion at
∆θ and δ respectively.
C.1.2 Localization sub-model
For the localization sub-model, we define the adjacency measures of self-direction and self-position
ʌ
separately. Let f (∣θ1 - θ21) be the adjacency measure between two directions θ1 and θ2 . We use
von Mises kernel f (r) = exp((cos(r) — 1)∕σ2), where f (0) = 1. For adjacency measure between
self-positions x and y, we keep it the same as described in section 3.7.
18
Published as a conference paper at ICLR 2019
;≡∙W2∙K・应“ 一∙s23%
备纥a充版 XN∙∙∙E∙∙IINil
■7HiIK，夕打 A≡KM∙∙
πMi!∙∙'HW∙∙∙∙ES∕a∙
^lslssass^
H 妁HE∙ΠSΠ∙ w∙∙m
(c) L1 + λ3L3, without L2.
Figure 11: Ablation study of the components in the training loss. (a) Learn the model using only
the localization loss with global adjacency. (b) Learn the model using only the localization loss with
local adjacency. (c) Using global adjacency and motion loss, leaving out local adjacency.
C.1.3 Loss function for learning
For learning the system, We can first learn v
minimizing
and MM (or the coefficients that parametrize M) by
Eθ1,θ2 [(/(∣θι - θ2∣) -hv(θ1),v(θ2)i)2] + λEθ,∆θ [kv(θ + ∆θ) - ΛM(∆θ)v(θ)k2] ,	(35)
and then We learn v and M (or the coefficients that parametrize M ) as before.
C.2 Learned units for self-direction and self-position
Figure 13 shoWs a result of learning such an egocentric motion model by displaying the response
curves of the learned units in the head direction system, v(θ), for θ ∈ [0, 2π], as well as the response
maps of the learned multiple block units in the self-position system, v(x), for x ∈ [0, 1]2.
C.3 Clock and timestamp
We may re-purpose the head direction system as a clock, by interpreting θ ∈ [0, 2π] as the time on
a clock, and V(θ) as a timestamp for events happening over time. This may be related to the recent
neuroscience observations in Tsao et al. (2018).
D Errors
D.1 Error correction
Unlike commonly used embedding in machine learning, here we embed a 2D position into a high-
dimensional space, and the embedding is a highly distributed representation or population code. The
19
Published as a conference paper at ICLR 2019
block size = 100
block size = 2
block size = 4
block size = 6
=10

(a)	With local isometry L2: scaling parameter α = 72

我Ar赛B
心通%无酒」
■■■圈
媪兢；' 第√'
「上次添齐
片大震冒
./&•∙'¾" 一^
⅛⅛⅛÷W4
(b)	With global adjacency L3 : Gaussian kernel with σ = 0.08
Figure 12:	Learned units by dropping the parametrization and the block diagonal assumption of the
motion matrix M (∆x).
advantage of such a redundant code lies in its tolerance to errors. We show that the learned system
is tolerant to various sources of errors. Specifically, in both path integral and path planning tasks,
at every time step t, we randomly add (1) Gaussian noises or (2) dropout masks to the hidden units
and see if the system can still perform the tasks well. We find that the decoding-encoding process
(DE) is important for error correction. That is, at each time step t, given the noisy hidden vector vt ,
we decode it to xt = arg maxx hvt, v(x)i and then re-encode it to the hidden vector v(xt). Actually
the whole process can be accomplished by projection to the codebook sub-manifold without explicit
decoding, by obtaining the vector: arg maxv∈C hvt, vi, where C = {v(x), x ∈ [0, 1]2}.
Table 1 shows the error correction results tested on path integral and path planning tasks. Each
number is averaged over 1, 000 episodes. We compute the overall standard deviation of {v(x)} for
all x and treat it as the reference standard deviation (s) for the Gaussian noise. For dropout noise,
we set a percentage to drop at each time step. With the decoding-encoding process, the system is
quite robust to the Gaussian noise and dropout error, and the system still works even if 70% units
are silenced at each step.
D.2 Noisy self-motion input
Besides adding noises to the hidden units, we also experiment with adding noises to the self-motion
∆x, and compare the performance of path integral with the one performed in the original 2D co-
ordinates. Specifically, at each time step, we add Gaussian noises to the self-motion ∆x. For path
integral, we compute the mean square error between the predicted locations and ground truth lo-
cations. Besides, we also compute the predicted locations using the 2D coordinates with the noisy
self-motions. Its mean square error serves as the reference error. Table 2 shows the result, indicat-
ing that the error of the learned system is close to the error in the original 2D coordinates, i.e., our
system does not blow up the noise.
20
Published as a conference paper at ICLR 2019
(a)
αk
3.2
6.6
8.4
14.9
21.2
26.3
33.5
43.2
43.4
46.0
59.0
61.2
72.5
80.5
82.5
85.3
Learned blocks
,∙jM[∙τC⅛⅛¾i⅛卷错说≡若那雅
£:«•:而一”κ⅛器⅞静髡巡尊圈膝密
■4-?£»篇普例系寇常爨㈱翼翊襄
二心磨我笠纥就翁戢颊蒸谟卷遢
NWo主»M⅞AΦ¾傕绥磴勰麴■翦
7 ∙∙3≡¾⅛汽¾酒期8.S僚
(b)
Figure 13:	(a) Response curves of learned units in the head direction model, v(θ). Each block shows the units
belonging to the same sub-vector in the model. The horizontal axis represents the angle within a range of [0,
2π], while the vertical axis indicates the values of responses. (b) Response maps of the learned multiple block
units of the self-position model, v(x), for x ∈ [0, 1]2.
Path integral: MSE
Path planning: success rate
Noise type	1s	0.75s	0.5s	0.25s	0.1s	1s	0.75s	0.5s	0.25s	0.1s
Gaussian (DE)	1.687	1.135	0.384	0.017	0	0.928	0.959	0.961	0.977	0.985
Gaussian	6.578	2.999	1.603	0.549	0.250	0.503	0.791	0.934	0.966	0.982
Noise type	70%	50%	30%	10%	5%	70%	50%	30%	10%	5%
Dropout (DE)	2.837	1.920	1.102	0.109	0.013	0.810	0.916	0.961	0.970	0.978
Dropout	19.611	16.883	14.137	3.416	0.602	0.067	0.186	0.603	0.952	0.964
Table 1: Error correction results on the vector representation. The performance of path integral is measured
by mean square error between predicted locations and ground truth locations; while for path planning, the
performance is measured by success rate. Experiments are conducted using several noise levels: Gaussian
noise with different standard deviations in terms of the reference standard deviation s and dropout mask with
different percentages. DE means implementing decoding-encoding process when performing the tasks.
E 3D environment and 1D time
The system can be generalized to 3D environments. Specifically, we assume the agent navigates
within a domain D = [0, 1] × [0, 1] × [0, 1], which is discretized into a 40 × 40 × 40 lattice. We
learn a parametric model for motion matrix M in a residual form M = I + M (∆x), where M (∆x)
is approximated by the second order Taylor expansion of ∆x.
We first learn a single block with fixed αk by minimizing L1 +λ2L2,k. A batch of 500,000 examples
of (x, y) and (x, ∆xt, t = 1, ..., T) is sampled online at every iteration for training. Figure 14 shows
the learned units.
21
Published as a conference paper at ICLR 2019
Standard deviation	1.2	0.9	0.6	0.3
Learned system	6.020	4.382	3.000	1.422
Reference	5.852	4.185	2.873	1.315
Table 2: Path integral results with noises in the self-motion. Performance is measured by mean square error
(MSE) between the predicted locations and ground truth locations in the path integral task. Noises are added to
self-motions ∆x by several noise levels: Gaussian noise with different standard deviations in terms of number
of grids. Reference MSE is computed by path integral in 2D coordinates.
α = 18
α = 36
α = 72
α = 108
α = 144
α = 180
Figure 14: Learned units of a single block with fixed α in 3D environment. Every row shows the learned units
with a given α.
Next we learn multiple blocks by minimizing L1 + λ3L3, and use the learned models to perform 3D
path integral and path planning. For simplicity, we remove L2. We use 8 blocks of units with block
size 8 and exponential kernel (σ = 0.3) for path planning. A batch of 200,000 examples is sampled
online at every iteration for training.
E.1 3D path integral
Figure 15 shows some results of3D path integral with duration T = 30. Gaussian Kernel (σ = 0.08)
is used as the adjacency measure.
E.2 3D path planning
Figure 16 shows some results of 3D simple path planning. Exponential kernel (σ = 0.3) is
used as the adjacency measure. We design a set of allowable motions ∆: m lengths of ra-
dius r are used, and for each r, we evenly divide the inclination θ ∈ [0, π] and the arimuth
α ∈ [0, 2π] into n directions, which results in a motion pool with mn2 candidate motions
∆ = {(r sin(θ) cos(α), r sin(θ) sin(α), r cos(θ))}. We use m = 2, n = 90 in this experiment.
E.3 3D path planning with obstacles
Figure 17 shows some examples of 3D path planning with a cuboid obstacle. a = 38 and b = 24 in
equation 16.
22
Published as a conference paper at ICLR 2019
Figure 15: Examples of 3D path integral with duration T = 30.
Figure 16: Examples of 3D simple path planning, where the agent is capable of planning a direct trajectory.
E.4 Learning in 1D
The system can also be applied to 1D. Inspired by Tsao et al. (2018), the learned system in 1D may
serve as a timestamp of events. We assume domain D = [0, 1] and discretize it into 100 time points.
A parametric M is learned by a residual form M = I + M (∆t), where each element of M (∆t)
is parametrized as a function of (∆t, ∆t2). 16 blocks of hidden units with block size 6 are used.
Figure 18 visualizes the learned units over the 100 time points. The response wave of every unit
23
Published as a conference paper at ICLR 2019
Figure 17: Examples of 3D path planning with a cuboid obstacle.
shows strong periodicity of a specific scale or frequency. Within each block, the response waves of
units have similar patterns, with different phases.
value of responses.
24