Published as a conference paper at ICLR 2020
Oblique Decision Trees from Derivatives of
ReLU Networks
Guang-He Lee & Tommi S. Jaakkola
Computer Science and Artificial Intelligence Lab
MIT
{guanghe,tommi}@csail.mit.edu
Ab stract
We show how neural models can be used to realize piece-wise constant functions
such as decision trees. The proposed architecture, which we call locally con-
stant networks, builds on ReLU networks that are piece-wise linear and hence
their associated gradients with respect to the inputs are locally constant. We for-
mally establish the equivalence between the classes of locally constant networks
and decision trees. Moreover, we highlight several advantageous properties of lo-
cally constant networks, including how they realize decision trees with parameter
sharing across branching / leaves. Indeed, only M neurons suffice to implicitly
model an oblique decision tree with 2M leaf nodes. The neural representation
also enables us to adopt many tools developed for deep networks (e.g., DropCon-
nect (Wan et al., 2013)) while implicitly training decision trees. We demonstrate
that our method outperforms alternative techniques for training oblique decision
trees in the context of molecular property classification and regression tasks.1
1	Introduction
Decision trees (Breiman et al., 1984) employ a series of simple decision nodes, arranged in a tree, to
transparently capture how the predicted outcome is reached. Functionally, such tree-based models,
including random forest (Breiman, 2001), realize piece-wise constant functions. Beyond their status
as de facto interpretable models, they have also persisted as the state of the art models in some tab-
ular (Sandulescu & Chiru, 2016) and chemical datasets (Wu et al., 2018). Deep neural models, in
contrast, are highly flexible and continuous, demonstrably effective in practice, though lack trans-
parency. We merge these two contrasting views by introducing a new family of neural models that
implicitly learn and represent oblique decision trees.
Prior work has attempted to generalize classic decision trees by extending coordinate-wise cuts to
be weighted, linear classifications. The resulting family of models is known as oblique decision
trees (Murthy et al., 1993). However, the generalization accompanies a challenging combinatorial,
non-differentiable optimization problem over the linear parameters at each decision point. Simple
sorting procedures used for successively finding branch-wise optimal coordinate cuts are no longer
available, making these models considerably harder to train. While finding the optimal oblique
decision tree can be cast as a mixed integer linear program (Bertsimas & Dunn, 2017), scaling
remains a challenge.
In this work, we provide an effective, implicit representation of piece-wise constant mappings,
termed locally constant networks. Our approach exploits piece-wise linear models such as ReLU
networks as basic building blocks. Linearity of the mapping in each region in such models means
that the gradient with respect to the input coordinates is locally constant. We therefore implicitly
represent piece-wise constant networks through gradients evaluated from ReLU networks. We prove
the equivalence between the class of oblique decision trees and these proposed locally constant neu-
ral models. However, the sizes required for equivalent representations can be substantially different.
For example, a locally constant network with M neurons can implicitly realize an oblique decision
tree whose explicit form requires 2M - 1 oblique decision nodes. The exponential complexity reduc-
1Our implementation and data are available at https://github.com/guanghelee/iclr20-lcn.
1
Published as a conference paper at ICLR 2020
tion in the corresponding neural representation illustrates the degree to which parameters are shared
across the locally constant regions.
Our locally constant networks can be learned via gradient descent, and they can be explicitly con-
verted back to oblique decision trees for interpretability. For learning via gradient descent, however,
it is necessary to employ some smooth annealing of piece-wise linear activation functions so as to
keep the gradients themselves continuous. Moreover, we need to evaluate the gradients of all the
neurons with respect to the inputs. To address this bottleneck, we devise a dynamic programming
algorithm which computes all the necessary gradient information in a single forward pass. A number
of extensions are possible. For instance, we can construct approximately locally constant networks
by switching activation functions, or apply helpful techniques used with normal deep learning mod-
els (e.g., DropConnect (Wan et al., 2013)) while implicitly training tree models.
We empirically test our model in the context of molecular property classification and regression
tasks (Wu et al., 2018), where tree-based models remain state-of-the-art. We compare our approach
against recent methods for training oblique decision trees and classic ensemble methods such as
gradient boosting (Friedman, 2001) and random forest. Empirically, a locally constant network
always outperforms alternative methods for training oblique decision trees by a large margin, and
the ensemble of locally constant networks is competitive with classic ensemble methods.
2	Related Work
Locally constant networks are built on a mixed integer linear representation of piece-wise linear
networks, defined as any feed-forward network with a piece-wise linear activation function such as
ReLU (Nair & Hinton, 2010). One can specify a set of integers encoding the active linear piece
of each neuron, which is called an activation pattern (Raghu et al., 2017). The feasible set of an
activation pattern forms a convex polyhedron in the input space (Lee et al., 2019), where the net-
work degenerates to a linear model. The framework motivates us to leverage the locally invariant
derivatives of the networks to construct a locally constant network. The activation pattern is also
exploited in literature for other purposes such as deriving robustness certificates (Weng et al., 2018).
We refer the readers to the recent work (Lee et al., 2019) and the references therein.
Locally constant networks use the gradients of deep networks with respect to inputs as the repre-
sentations to build discriminative models. Such gradients have been used in literature for different
purposes. They have been widely used for local sensitivity analysis of trained networks (Simonyan
et al., 2013; Smilkov et al., 2017). When the deep networks model an energy function (LeCun et al.,
2006), the gradients can be used to draw samples from the distribution specified by the normalized
energy function (Du & Mordatch, 2019; Song & Ermon, 2019). The gradients can also be used
to train generative models (Goodfellow et al., 2014) or perform knowledge distillation (Srinivas &
Fleuret, 2018).
The class of locally constant networks is equivalent to the class of oblique decision trees. There are
some classic methods that also construct neural networks that reproduce decision trees (Sethi, 1990;
Brent, 1991; Cios & Liu, 1992), by utilizing step functions and logic gates (e.g., AND/NEGATION) as
the activation function. The methods were developed when back-propagation was not yet practically
useful, and the motivation is to exploit effective learning procedures of decision trees to train neural
networks. Instead, our goal is to leverage the successful deep models to train oblique decision trees.
Recently, Yang et al. (2018) proposed a network architecture with arg max activations to represent
classic decision trees with coordinate cuts, but their parameterization scales exponentially with input
dimension. In stark contrast, our parameterization only scales linearly with input dimension (see our
complexity analyses in §3.7).
Learning oblique decision trees is challenging, even for a greedy algorithm; for a single oblique split,
there can be PD=O (N) different Ways to separate N data points in D-dimensional space (VaPnik
& Chervonenkis, 1971) (cf. ND possibilities for coordinate-cuts). Existing learning algorithms for
oblique decision trees include greedy induction, global optimization, and iterative refinements on an
initial tree. We revieW some representative Works, and refer the readers to the references therein.
Optimizing each oblique split in greedy induction can be realized by coordinate descent (Murthy
et al., 1994) or a coordinate-cut search in some linear projection space (Menze et al., 2011; Wickra-
marachchi et al., 2016). HoWever, the greedy constructions tend to get stuck in poor local optimum.
2
Published as a conference paper at ICLR 2020
There are some works which attempt to find the global optimum given a fixed tree structure by for-
mulating a linear program (Bennett, 1994) or a mixed integer linear program (Bertsimas & Dunn,
2017), but the methods are not scalable to ordinary tree sizes (e.g., depth more than 4). The itera-
tive refinements are more scalable than global optimization, where CART (Breiman et al., 1984) is
the typical initialization. Carreira-Perpinan & Tavallali (2018) develop an alternating optimization
method via iteratively training a linear classifier on each decision node, which yield the state-of-the-
art empirical performance, but the approach is only applicable to classification problems. Norouzi
et al. (2015) proposed to do gradient descent on a sub-differentiable upperbound of tree prediction
errors, but the gradients with respect to oblique decision nodes are unavailable whenever the up-
perbound is tight. In contrast, our method conducts gradient descent on a differentiable relaxation,
which is gradually annealed to a locally constant network.
3	Methodology
In this section, we introduce the notation and basics in §3.1, construct the locally constant networks
in §3.2-3.3, analyze the networks in §3.4-3.5, and develop practical formulations and algorithms in
§3.6-3.7. Note that we will propose two (equivalent) architectures of locally constant networks in
§3.3 and §3.6, which are useful for theoretical analyses and practical purposes, respectively.
3.1	Notation and basics
The proposed approach is built on feed-forward networks that yield piece-wise linear mappings.
Here we first introduce a canonical example of such networks, and elaborate its piece-wise linearity.
We consider the densely connected architecture (Huang et al., 2017), where each hidden layer takes
as input all the previous layers; it subsumes other existing feed-forward architectures such as residual
networks (He et al., 2016). For such a network fθ : RD → RL with the set of parameters θ, we
denote the number of hidden layers as M and the number of neurons in the ith layer as Ni ; we denote
the neurons in the ith layer, before and after activation, as zi ∈ RNi and ai ∈ RNi , respectively,
where we sometimes interchangeably denote the input instance x as a0 ∈ RN0 with N0 , D .
To simplify exposition, we denote the concatenation of (a0, a1,..., ai) as ai ∈ RNi with Ni，
Pj=0 Ni, ∀i ∈ {0, 1, . . . , M}. The neurons are defined via the weight matrix Wi ∈ RNi×Ni-1
and the bias vector bi ∈ RNi in each layer i ∈ [M] , {1, 2, . . . , M }. Concretely,
a0，x, Zi，Wiai-1 + bi, ai，σ(zi),∀i ∈ [M],	(1)
where σ(∙) is a point-wise activation function. Note that both a and Z are functions of the specific
instance denoted by x, where we drop the functional dependency to simplify notation. We use the
set I to denote the set of all the neuron indices in this network {(i, j)|j ∈ [Ni], i ∈ [M]}. In this
work, we will use ReLU (Nair & Hinton, 2010) as a canonical example for the activation function
aij = σ(Zi)j , max(0, Zji), ∀(i, j) ∈ I,	(2)
but the results naturally generalize to other piece-wise linear activation functions such as leaky
ReLU (Maas et al., 2013). The output of the entire network fθ(x) is the affine transformation from
--一一.一一 .	一 κ, .一一	.一	__n ʃ i 1	— r、，TCT	一一.	_ i ʃ i i — r
all the hidden layers aM with the weight matrix WM+1 ∈ RL×NM and bias vector bM +1 ∈ RL.
3.2	Local linearity
It is widely known that the class of networks fθ(∙) yields a piece-wise linear function. The results
are typically proved via associating the end-to-end behavior of the network with its activation pattern
一 which linear piece in each neuron is activated; once an activation pattern is fixed across the entire
network, the network degenerates to a linear model and the feasible set with respect to an activation
pattern is a natural characterization of a locally linear region of the network.
Formally, we define the activation pattern as the collection of activation indicator functions for each
neuron oij : RD → {0, 1}, ∀(i, j) ∈ I (or, equivalently, the derivatives of ReLU units; see below)2:
∂ai
oj = dzj , I[zj ≥ 0], ∀(i,j) ∈I,	⑶
2Note that each oij is again a function of x, where we omit the dependency for brevity.
3
Published as a conference paper at ICLR 2020
Define
z1 = x1- x2 + 1;於=-4%ι + %2 + 4q1 + 4; z3 = -x1 + x2 + 1∙5q1 — 0.3a2 - 3.
M = 3
g([0,0,0]) = 0
g([0,0,l]) = 1
g([0,1,0]) = 1
g([0,1,1]) = 0
g([l,0,0]) = 1
g([l,0,l]) = 0
g([1,1.0D = 0
g([l,1,l]) = 1
Locally constant networks
0	11	0	1	0	0	1
Decision trees
Figure 1: Toy examples for the equivalent representations of the same mappings for different M .
Here the locally constant networks have 1 neuron per layer. We show the locally constant networks
on the LHS, the raw mappings in the middle, and the equivalent oblique decision trees on the RHS.
where IH is the indicator function. Note that, for mathematical correctness, We define ∂aj∕∂zj = 1
at Zj = 0; this choice is arbitrary, and one can change it to ∂aj∕∂zj = 0 at Zj = 0 without affecting
most of the derivations. Given a fixed activation pattern Oj ∈ {0,1}, ∀(i,j), we can specify a
feasible set in RD that corresponds to this activation pattern {x ∈ RD |oj = Oj, ∀(i, j) ∈ I} (note
that each oij is a function of x). Due to the fixed activation pattern, the non-linear ReLU can be
re-written as a linear function for all the inputs in the feasible Set. For example, for an Oj = 0, we
can re-write aij = 0 × Zji. As a result, the network has a consistent end-to-end linear behavior across
the entire feasible set. One can prove that all the feasible sets partition the space RD into disjoint
convex polyhedra3, which realize a natural representation of the locally linear regions. Since we will
only use the result to motivate the construction of locally constant networks, we refer the readers to
Lee et al. (2019) for a detailed justification of the piece-wise linearity of such networks.
3.3	Canonical locally constant networks
Since the ReLU network fθ(x) is piece-wise linear, it immediately implies that its derivatives with
respect to the input x is a piece-wise constant function. Here we use Jxfθ(x) ∈ RL×D to denote
the Jacobian matrix (i.e., [Jxfθ (x)]i,j = ∂fθ (x)i∕∂xj), and we assume the Jacobian is consistent
with Eq. (3) at the boundary of the locally linear regions. Since any function taking the piece-
wise constant Jacobian as input will remain itself piece-wise constant, we can construct a variety of
locally constant networks by composition.
However, in order to simplify the derivation, we first make a trivial observation that the activation
pattern in each locally linear region is also locally invariant. More broadly, any invariant quantity in
each locally linear region can be utilized so as to build locally constant networks. We thus define the
locally constant networks as any composite function that leverage the local invariance of piece-wise
linear networks. For the theoretical analyses, we consider the below architecture.
G
Canonical architecture. We denote OM ∈ {0,1}NM as the concatenation of (o1,..., OM). We
will use the composite function g(OM) as the canonical architecture of locally constant networks for
G
theoretical analyses, where g : {0, 1}NM → RL is simply a table.
Before elucidating on the representational equivalence to oblique decision trees, we first show some
toy examples of the canonical locally constant networks and their equivalent mappings in Fig. 1,
3The boundary of the polyhedron depends on the specific definition of the activation pattern, so, under some
definition in literature, the resulting convex polyhedra may not be disjoint in the boundary.
4
Published as a conference paper at ICLR 2020
which illustrates their constructions when there is only 1 neuron per layer (i.e., zi = z1i, and simi-
larly for oi and ai). When M = 1, o1 = 1 ⇔ x1 - x2 + 1 ≥ 0, thus the locally constant network
is equivalent to a linear model shown in the middle, which can also be represented as an oblique
decision tree with depth = 1. When M > 1, the activations in the previous layers control different
linear behaviors of a neuron with respect to the input, thus realizing a hierarchical structure as an
oblique decision tree. For example, for M = 2, o1 = 0 ⇔ z1 < 0 ⇒ z2 = -4x1 + x2 + 4 and
o1 = 1 ⇔ z1 ≥ 0 ⇒ z2 = -3x2 + 8; hence, it can also be interpreted as the decision tree on
the RHS, where the concrete realization of z2 depends on the previous decision variable z 1 ≥ 0.
Afterwards, we can map either the activation patterns on the LHS or the decision patterns on the
RHS to an output value, which leads to the mapping in the middle.
3.4	Representational equivalence
In this section, we prove the equivalence between the class of oblique decision trees and the class
of locally constant networks. We first make an observation that any unbalanced oblique decision
tree can be re-written to be balanced by adding dummy decision nodes 0>x ≥ -1. Hence, we can
define the class of oblique decision trees with the balance constraint:
Definition 1. The class of oblique decision trees contains any functions that can be procedurally
defined (with some depth T ∈ Z>0) for x ∈ RD:
1.	ri，I[ω>x + β0 ≥ 0], where ω0 ∈ RD and β0 ∈ R denote the weight and bias of the
root decision node.
2.	For i ∈ (2, 3,..., T), r，1^二一 x+βm-ι ≥ 0], where 3七:一 ∈ RD ande门:一 ∈ R
denote the weight and bias for the decision node after the decision pattern r1:i-1.
3.	v : {0, 1}T → RL outputs the leaf value v(r1:T) associated with the decision pattern r1:T.
The class of locally constant networks is defined by the canonical architecture with finite M and
Ni , ∀i ∈ [M]. We first prove that we can represent any oblique decision tree as a locally constant
network. Since a typical oblique decision tree can produce an arbitrary weight in each decision node
(cf. the structurally dependent weights in the oblique decision trees in Fig. 1), the idea is to utilize a
network with only 1 hidden layer such that the neurons do not constrain one another. Concretely,
Theorem 2.	The class of locally constant networks ⊇ the class of oblique decision trees.
Proof. For any oblique decision tree with depth T, it contains 2T - 1 weights and biases. We thus
construct a locally constant network with M = 1 and N1 = 2T - 1 such that each pair of (ω, β) in
the oblique decision tree is equal to some Wk1,: and b1k in the constructed locally constant network.
For each leaf node in the decision tree, itis associated with an output value y ∈ RL and T decisions;
the decisions can be written as Wi1dx[j],:x + bi1dx[j] ≥ 0 for j ∈ {1, 2, . . . , T0} and Wi1dx[j],:x +
b1idx[j] < 0 for j ∈ {T0 + 1, T0 + 2, . . . , T} for some index function idx : [T] → [2T - 1] and
some T0 ∈ {0,1,...,T}. We can set the table g(∙) of the locally constant network as
if(o1idx[j] = 1(⇔ Wi1dx[j],:x + b1idx[j] ≥0),forj ∈ {1,2,...,T0}, and
y, if o1idx[j] = 0(⇔ Wi1dx[j],:x + b1idx[j] <0),forj∈{T0+1,T0+2,...,T}.
As a result, the constructed locally constant network yields the same output as the given oblique
decision tree for all the inputs that are routed to each leaf node, which concludes the proof. □
Then we prove that the class of locally constant networks is a subset of the class of oblique decision
trees, which simply follows the construction of the toy examples in Fig. 1.
Theorem 3.	The class of locally constant networks ⊆ the class of oblique decision trees.
Proof. For any locally constant network, it can be re-written to have 1 neuron per layer, by ex-
panding any layer with Ni > 1 neurons to be Ni different layers such that they do not have effective
intra-connections. Below the notation refers to the converted locally constant network with 1 neuron
per layer. We define the following oblique decision tree with T = M for x ∈ RD:
1. ri，o1 = I[ω>x + β0 ≥ 0] with ω0 = W1,： and β0 = b匕
5
Published as a conference paper at ICLR 2020
2.	For i ∈ (2,3,...,M), r，I[ω>ιi-ι x + /人一 ≥ 0], where 3个旧-1 = VχZi and
βrι∙i-ι = Zi - (Vxz1)>x. Note that r = I[z： ≥ 0] = o∖.
3.	v = g.
Note that, in order to be a valid decision tree, 3上门—1 and βin-ι have to be unique for all X
that yield the same decision pattern r1:i-1. To see this, for i ∈ (2, 3, . . . , M), as r1:i-1 =
(o11, . . . , oi1-1), we know each z1i is a fixed affine function given an activation pattern for the pre-
ceding neurons, so Vxz1i and z1i - x>Vxz1i are fixed quantities given a decision pattern r1:i-1.
Since ri：M = oM and V =g, We conclude that they yield the same mapping.	□
Despite the simplicity of the proof, it has some practical implications:
Remark 4. The proof of Theorem 3 implies that we can train a locally constant network with M
neurons, and convert it to an oblique decision tree with depth M (for interpretability).
Remark 5. The proof of Theorem 3 establishes that, given a fixed number of neurons, it suffices
(representationally) to only consider the locally constant networks with one neuron per layer.
Remark 5 is important for learning small locally constant networks (which can be converted to
shallow decision trees for interpretability), since representation capacity is critical for low capacity
models. In the remainder of the paper, we will only consider the setting with Ni = 1, ∀i ∈ [M].
3.5	Structurally shared parameterization
Although we have established the exact class-level equivalence between locally constant networks
and oblique decision trees, once we restrict the depth of the locally constant networks M, it can no
longer re-produce all the decision trees with depth M. The result can be intuitively understood by the
following reason: we are effectively using M pairs of (weight, bias) in the locally constant network
to implicitly realize 2M - 1 pairs of (weight, bias) in the corresponding oblique decision tree. Such
exponential reduction on the effective parameters in the representation of oblique decision trees
yields “dimension reduction” of the model capacity. This section aims to reveal the implied shared
parameterization embedded in the oblique decision trees derived from locally constant networks.
In this section, the oblique decision trees and the associated parameters refer to the decision trees
obtained via the proof of Theorem 3. We start the analysis by a decomposition of 3^ among the
preceding weights ω0,3九1,...,幻九一「 To simplify notation, we denote 3^：。，ω0. Since
3ri：i = Vxz1+1 and z1+1 is an affine transformation of the vector (a0, a1,..., aɪ),
ik	i
3ri：i = Vxzi+1 = Wi++1D + X Wi++k × 募 ×Vxzk = W；+：D +XWi+1+k ×rk ×3rι*-ι,
k=1	∂z1	k=1
where we simply re-write the derivatives in terms of tree parameters. Since W1i,+1:1D is fixed for all the
3r1:i , the above decomposition implies that, in the induced tree, all the weights 3r1:i in the same
depth i are restricted to be a linear combination of the fixed basis W1i,+1:1D and the corresponding
preceding weights 3r1:0, . . . , 3r1:i-1 .We can extend this analysis to compare weights in same layer,
and we begin the analysis by comparing weights whose `0 distance in decision pattern is 1. To help
interpret the statement, note that 3r1:j-1 is the weight that leads to the decision rj (or rj0 ; see below).
Lemma 6. For an oblique decision tree with depth T > 1, ∀i ∈ [T - 1] and any r1:i, r10 :i such that
rk = rk0 for all k ∈ [i] except that rj 6= rj0 for some j ∈ [i], we have
3r1:i - 3r0 = α × 3r1:j-1 , for some α ∈ R.
The proof involves some algebraic manipulation, and is deferred to Appendix A.1. Lemma 6 charac-
terizes an interesting structural constraint embedded in the oblique decision trees realized by locally
constant networks, where the structural discrepancy rj in decision patterns (r1:i versus r10 :i) is re-
flected on the discrepancy of the corresponding weights (up to a scaling factor α). The analysis can
be generalized for all the weights in the same layer, but the message is similar.
Proposition 7. For the oblique decision tree with depth T > 1, ∀i ∈ [T - 1] and any r1:i, r10:i such
that rk = rk0 for all k ∈ [i] except for n ∈ [i] coordinates j1, . . . , jn ∈ [i], we have
n
3r1:i - 3r10:i = αk × 3r1:jk -1, for some αk ∈ R,∀k ∈ [n].	(4)
k=1
6
Published as a conference paper at ICLR 2020
The statement can be proved by applying Lemma 6 multiple times.
Discussion. Here we summarize this section and provide some discussion. Locally constant net-
works implicitly represent oblique decision trees with the same depth and structurally shared pa-
rameterization. In the implied oblique decision trees, the weight of each decision node is a linear
combination of a shared weight across the whole layer and all the preceding weights. The analysis
explains how locally constant networks use only M weights to model a decision tree with 2M - 1
decision nodes; it yields a strong regularization effect to avoid overfitting, and helps computation by
exponentially reducing the memory consumption on the weights.
3.6	Standard locally constant networks and extensions
The simple structure of the canonical locally constant networks is beneficial for theoretical analysis,
but the structure is not practical for learning since the discrete activation pattern does not exhibit gra-
dients for learning the networks. Indeed, Vomg(0M) is undefined, which implies that Vwig(0M)
is also undefined. Here we present another architecture that is equivalent to the canonical architec-
ture, but exhibits sub-gradients with respect to model parameters and is flexible for model extension.
Standard architecture. We assume Ni = 1, ∀i ∈ [M]. We denote the Jacobian of all the neurons
after activation aM as JxaM ∈ RM× D, and denote JxaM as the vectorized version. We then define
the standard architecture as gφ(JxaM), where gφ : R(M×D) → RL is a fully-connected network.
We abbreviate the standard locally constant networks as LCN. Note that each ai1 is locally linear
and thus the Jacobian JxaM is locally constant. We replace OM with JxaM as the invariant rep-
resentation for each locally linear region4, and replace the table g with a differentiable function gφ
that takes as input real vectors. The gradients of Lcn with respect to parameters is thus established
through the derivatives of gφ and the mixed partial derivatives of the neurons (derivatives of JxaM).
Fortunately, all the previous analyses also apply to the standard architecture, due to a fine-grained
equivalence between the two architectures.
Theorem 8. Given any fixed fθ, any canonical locally constant network g(OM) can be equivalently
represented by a standard locally constant network gφ(Jxa M), and vice versa.
Since fθ and g control the decision nodes and leaf nodes in the associated oblique decision tree,
respectively (see Theorem 3), Theorem 8 essentially states that both architectures are equally com-
petent for assigning leaf nodes. Combining Theorem 8 with the analyses in §3.4, we have class-level
equivalence among the two architectures of locally constant networks and oblique decision trees.
The analyses in §3.5 are also inherited since the analyses only depend on decision nodes (i.e., fθ).
The core ideas for proving Theorem 8 are two-fold: 1) we find a bijection between the activation
pattern OM and the Jacobian JxaM, and 2) feed-forward networks gφ can map the (finitely many)
Jacobian JxaM as flexibly as a table g. The complete proof is deferred to Appendix A.2.
Discussion. The standard architecture yields a new property that is only partially exhibited in the
canonical architecture. For all the decision and leaf nodes which no training data is routed to, there
is no way to obtain learning signals in classic oblique decision trees. However, due to shared pa-
rameterization (see §3.5), locally constant networks can “learn” all the decision nodes in the implied
oblique decision trees (if there is a way to optimize the networks), and the standard architecture can
even “learn” all the leaf nodes due to the parameterized output function gφ.
Extensions. The construction of (standard) locally constant networks enables several natural exten-
sions due to the flexibility of the neural architecture and the interpretation of decision trees. The
original locally linear networks (LLN) fθ, which outputs a linear function instead of a constant
function for each region, can be regarded as one extension. Here we discuss two examples.
•	Approximately locally constant networks (ALCN): we can change the activation function while
keeping the model architecture of LCN. For example, we can replace ReLU max(0, x) with
softplus log(1 + exp(x)), which will lead to an approximately locally constant network, as the
softplus function has an approximately locally constant derivative for inputs with large absolute
value. Note that the canonical architecture (tabular g) is not compatible with such extension.
4In practice, We also include each bias al — (Vχa1)>x, which is omitted here to simplify exposition.
7
Published as a conference paper at ICLR 2020
•	Ensemble locally constant networks (ELCN): since each LCN can only output 2M different val-
ues, it is limited for complex tasks like regression (akin to decision trees). We can instead use an
additive ensemble of LCN or ALCN to increase the capacity. We use g% (jXaM,[e]) to denote a
base model in the ensemble, and denote the ensemble with E models as PE=I g；] (JxaM,[e]).
3.7 Computation and learning
In this section, we discuss computation and learning algorithms for the proposed models. In the
following complexity analyses, we assume gφ to be a linear model.
Space complexity. The space complexity of LCN is Θ(M D) for representing decision nodes and
Θ(M DL) for representing leaf nodes. In contrast, the space complexity of classic oblique decision
trees is Θ((2M - 1)D) for decision nodes and Θ(2M L) for leaf nodes. Hence, our representation
improves the space complexity over classic oblique decision trees exponentially.
Computation and time complexity. LCN and AL CN are built on the gradients of all the neurons
Jx a M = [vxaM,..., Vxal], which can be computationally challenging to obtain. Existing auto-
matic differentiation (e.g., back-propagation) only computes the gradient ofa scalar output. Instead,
here we propose an efficient dynamic programming procedure which only requires a forward pass:
1.	vxa11 = o11 × W1.
2.	∀i∈ {2,...,M},vxai1 =oi1 × (W1i,1:D + Pik-=11 W1i,D+kvxa1k),
The complexity of the dynamic programming is Θ(M2) due to the inner-summation inside each
iteration. Straightforward back-propagation re-computes the partial solutions vxa1k for each vxai1,
so the complexity is Θ(M3). We can parallelize the inner-summation on a GPU, and the complexity
of the dynamic programming and straightforward back-propagation will become Θ(M) and Θ(M2),
respectively. Note that the complexity of a forward pass of a typical network is also Θ(M) on a
GPU. The time complexity of learning LCN by (stochastic) gradient descent is thus Θ(Mτ), where
τ denotes the number of iterations. In contrast, the computation of existing oblique decision tree
training algorithms is typically data-dependent and thus the complexity is hard to characterize.
Training LCN and ALCN. Even though LCN is sub-differentiable, whenever oi1 = 0, the network
does not exhibit useful gradient information for learning each locally constant representation vx ai1
(note that JxaM = [Vxa1,..., VxaM]), since, operationally, oɪ = 0 implies aɪ J 0 and there
is no useful gradient of Vx ai1 = Vx0 = 0 with respect to model parameters. To alleviate the
problem, we propose to leverage softplus as an infinitely differentiable approximation of ReLU to
obtain meaningful learning signals for Vxai1. Concretely, we conduct the annealing during training:
ai1 = λt max(0, z1i) + (1 - λt) log(1 + exp(z1i)), ∀i ∈ [M], λt ∈ [0, 1],	(5)
where λt is an iteration-dependent annealing parameter. Both LCN and ALCN can be constructed as
a special case of Eq. (5). We train LCN with λt equal to the ratio between the current epoch and the
total epochs, and ALCN with λt = 0. Both models are optimized via stochastic gradient descent.
We also include DropConnect (Wan et al., 2013) to the weight matrices W i J drop(W i) during
training. Despite the simple structure of DropConnect in the locally constant networks, it entails
a structural dropout on the weights in the corresponding oblique decision trees (see §3.5), which
is challenging to reproduce in typical oblique decision trees. In addition, it also encourages the
exploration of parameter space, which is easy to see for the raw Lcn: the randomization enables the
exploration that flips oi1 = 0 to oi1 = 1 to establish effective learning signal. Note that the standard
DropOut (Srivastava et al., 2014) is not ideal for the low capacity models that we consider here.
Training Elcn. Since each ensemble component is sub-differentiable, we can directly learn the
whole ensemble through gradient descent. However, the approach is not scalable due to memory
constraints in practice. Instead, we propose to train the ensemble in a boosting fashion:
1.	We first train an initial locally constant network g；1 (Jxa M,[1]).
2.	For each iteration e0 ∈ {2, 3,..., E}, We incrementally optimize P；=i g；] (JxaM,[e]).
Note that, in the second step, only the latest model is optimized, and thus we can simply store the
predictions of the preceding models without loading them into the memory. Each partial ensemble
can be directly learned through gradient descent, without resorting to complex meta-algorithms such
as adaptive boosting (Freund & Schapire, 1997) or gradient boosting (Friedman, 2001).
8
Published as a conference paper at ICLR 2020
Table 1: Dataset statistics
Dataset	Bace	HIV	SIDER	Tox21	PDBbind
Task	(Multi-label) binary classification				Regression
Number of labels	1	1	27	12	1
Number of data	1,513	41,127	1,427	7,831	11,908
Table 2: Main results. The 1st section refers to (oblique) decision tree methods, the 2nd section refers
to single model extensions of LCN, the 3rd section refers to ensemble methods, and the last section is
Gcn. The results of Gcn are copied from (Wu et al., 2018), where the results in SIDER and Tox21
are not directly comparable due to lack of standard splittings. The best result in each section is in
bold letters.
Dataset	Bace (AUC)	HIV (AUC)	SIDER (AUC)	Tox21 (AUC)	PDBbind (RMSE)
Cart	0.652 ± 0.024	0.544 ± 0.009	0.570 ± 0.010	0.651 ± 0.005	1.573 ± 0.000
Hhcart	0.545 ± 0.016	0.636 ± 0.000	0.570 ± 0.009	0.638 ± 0.007	1.530 ± 0.000
Tao	0.734 ± 0.000	0.627 ± 0.000	0.577 ± 0.004	0.676 ± 0.003	Not applicable
Lcn	0.839 ± 0.013	0.728 ± 0.013	0.624 ± 0.044	0.781 ± 0.017	1.508 ± 0.017
Lln	0.818 ± 0.007	0.737 ± 0.009	0.677 ± 0.014	0.813 ± 0.009	1.627 ± 0.008
Alcn	0.854 ± 0.007	0.738 ± 0.009	0.653 ± 0.044	0.814 ± 0.009	1.369 ± 0.007
Rf	0.869 ± 0.003	0.796 ± 0.007	0.685 ± 0.011	0.839 ± 0.007	1.256 ± 0.002
Gbdt	0.859 ± 0.005	0.748 ± 0.001	0.668 ± 0.014	0.812 ± 0.011	1.247 ± 0.002
Elcn	0.874 ± 0.005	0.757 ± 0.011	0.685 ± 0.010	0.822 ± 0.006	1.219 ± 0.007
GCN	0.783 ± 0.014	0.763 ± 0.016	*0.638 ± 0.012	*0.829 ± 0.006	1.44 ± 0.12
4	Experiment
Here we evaluate the efficacy of our models (Lcn, Alcn, and Elcn) using the chemical prop-
erty prediction datasets from MoleculeNet (Wu et al., 2018), where random forest performs com-
petitively. We include 4 (multi-label) binary classification datasets and 1 regression dataset. The
statistics are available in Table 1. We follow the literature to construct the feature (Wu et al., 2018).
Specifically, we use the standard Morgan fingerprint (Rogers & Hahn, 2010), 2,048 binary indi-
cators of chemical substructures, for the classification datasets, and ‘grid features’ (fingerprints of
pairs between ligand and protein, see Wu et al. (2018)) for the regression dataset. Each dataset is
splitted into (train, validation, test) sets under the criterion specified in MoleculeNet.
We compare Lcn and its extensions (Lln, Alcn, and Elcn) with the following baselines:
•	(Oblique) decision trees: CART (Breiman et al. (1984)), HHCART (Wickramarachchi et al.
(2016); oblique decision trees induced greedily on linear projections), and Tao (Carreira-
Perpinan & Tavallali (2018); oblique decision trees trained via alternating optimization).
•	Tree ensembles: RF (Breiman (2001); random forest) and GBDT (Friedman (2001); gradient
boosting decision trees).
•	Graph networks: GCN (Duvenaud et al. (2015); graph convolutional networks on molecules).
For decision trees, LCN, LLN, and ALCN, we tune the tree depth in {2, 3, . . . , 12}. For LCN, LLN,
and ALCN, we also tune the DropConnect probability in {0, 0.25, 0.5, 0.75}. Since regression tasks
require precise estimations of the prediction values while classification tasks do not, we tune the
number of hidden layers of gφ in {0, 1, 2, 3, 4} (each with 256 neurons) for the regression task, and
simply use a linear model gφ for the classification tasks. For ELCN, we use ALCN as the base model,
tune the ensemble size E ∈ {20, 21, . . . , 26} for the classification tasks, and E ∈ {20, 21, . . . , 29}
for the regression task. To train our models, we use the cross entropy loss for the classification tasks,
and mean squared error for the regression task. Other minor details are available in Appendix B.
We follow the chemistry literature (Wu et al., 2018) to measure the performance by AUC for classi-
fication, and root-mean-squared error (RMSE) for regression. For each dataset, we train a model for
9
Published as a conference paper at ICLR 2020
1	4	7	10 13 15 19 22 25 28
Epoch
(a) Learning curve of LCN
(b) Training performance
T- CART (test)	T- TAO (test)
→- HHCART (tBSt>	-♦- LCN (test)
(c) Testing performance
Figure 2: Empirical analysis for oblique decision trees on the HIV dataset. Fig. 2a is an ablation
study for Lcn and Fig. 2b-2c compare different training methods.
each label, compute the mean and standard deviation of the performance across 10 different random
seeds, and report their average across all the labels within the dataset. The results are in Table 2.
Among the (oblique) decision tree training algorithms, our Lcn achieves the state-of-the-art per-
formance. The continuous extension (Alcn) always improves the empirical performance of Lcn,
which is expected since Lcn is limited for the number of possible outputs (leaf nodes). Among
the ensemble methods, the proposed Elcn always outperforms the classic counterpart, Gbdt, and
sometimes outperforms Rf. Overall, Lcn is the state-of-the-art method for learning oblique deci-
sion trees, and Elcn performs competitively against other alternatives for training tree ensembles.
Empirical analysis. Here we analyze the proposed LCN in terms of the optimization and general-
ization performance in the large HIV dataset. We conduct an ablation study on the proposed method
for training Lcn in Figure 2a. Direct training (without annealing) does not suffice to learn Lcn,
while the proposed annealing succeed in optimization; even better optimization and generalization
performance can be achieved by introducing DropConnect, which corroborates our hypothesis on
the exploration effect during training in §3.7 and its well-known regularization effect. Compared to
other methods (Fig. 2b), only Tao has a comparable training performance. In terms of generaliza-
tion (Fig. 2c), all of the competitors do not perform well and overfit fairly quickly. In stark contrast,
Lcn outperforms the competitors by a large margin and gets even more accurate as the depth in-
creases. This is expected due to the strong regularization of Lcn that uses a linear number of
effective weights to construct an exponential number of decision nodes, as discussed in §3.5. Some
additional analysis and the visualization of the tree converted from Lcn are included in Appendix C.
5 Discussion and conclusion
We create a novel neural architecture by casting the derivatives of deep networks as the representa-
tion, which realizes a new class of neural models that is equivalent to oblique decision trees. The
induced oblique decision trees embed rich structures and are compatible with deep learning meth-
ods. This work can be used to interpret methods that utilize derivatives of a network, such as training
a generator through the gradient of a discriminator (Goodfellow et al., 2014). The work opens up
many avenues for future work, from building representations from the derivatives of neural models
to the incorporation of more structures, such as the inner randomization of random forest.
Acknowledgments
GH and TJ were in part supported by a grant from Siemens Corporation. The authors thank Shub-
hendu Trivedi and Menghua Wu for proofreading, and thank the anonymous reviewers for their
helpful comments.
References
Kristin P Bennett. Global tree optimization: A non-greedy decision tree algorithm. Computing
Science and Statistics, pp. 156-156, 1994.
Dimitris Bertsimas and Jack Dunn. Optimal classification trees. Machine Learning, 106(7):1039—
1082, 2017.
10
Published as a conference paper at ICLR 2020
L. Breiman, J. Friedman, R. Olshen, and C. Stone. Classification and Regression Trees. Wadsworth
and Brooks, Monterey, CA, 1984.
Leo Breiman. Random forests. Machine Learning, 45(1):5-32, 2001.
Richard P Brent. Fast training algorithms for multilayer neural nets. IEEE Transactions on Neural
Networks, 2(3):346-354, 1991.
MigUel A Carreira-Perpinan and Pooya Tavallali. Alternating optimization of decision trees, with
application to learning sparse oblique trees. In Advances in Neural Information Processing Sys-
tems, pp. 1211-1221, 2018.
Krzysztof J Cios and Ning LiU. A machine learning method for generation of a neUral network
architectUre: A continUoUs id3 algorithm. IEEE Transactions on Neural Networks, 3(2):280-291,
1992.
YilUn DU and Igor Mordatch. Implicit generation and modeling with energy based models. In
Advances in Neural Information Processing Systems, pp. 3603-3613, 2019.
David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Alan
AspUrU-GUzik, and Ryan P Adams. ConvolUtional networks on graphs for learning molecUlar
fingerprints. In Advances in Neural Information Processing Systems, pp. 2224-2232, 2015.
Yoav Freund and Robert E Schapire. A decision-theoretic generalization of on-line learning and an
application to boosting. Journal of Computer and System Sciences, 55(1):119-139, 1997.
Jerome H Friedman. Greedy function approximation: a gradient boosting machine. Annals of
Statistics, pp. 1189-1232, 2001.
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in Neural Infor-
mation Processing Systems, pp. 2672-2680, 2014.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In IEEE Conference on Computer Vision and Pattern Recognition, pp. 770-778, 2016.
Kurt Hornik, Maxwell Stinchcombe, and Halbert White. Multilayer feedforward networks are uni-
versal approximators. Neural Networks, 2(5):359-366, 1989.
Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kilian Q Weinberger. Densely connected
convolutional networks. In IEEE Conference on Computer Vision and Pattern Recognition, pp.
4700-4708, 2017.
Yann LeCun, Sumit Chopra, Raia Hadsell, M Ranzato, and F Huang. A tutorial on energy-based
learning. Predicting Structured Data, 1(0), 2006.
Guang-He Lee, David Alvarez-Melis, and Tommi S. Jaakkola. Towards robust, locally linear deep
networks. In International Conference on Learning Representations, 2019.
Andrew L Maas, Awni Y Hannun, and Andrew Y Ng. Rectifier nonlinearities improve neural net-
work acoustic models. In International Conference on Machine Learning, volume 30, pp. 3,
2013.
Bjoern H Menze, B Michael Kelm, Daniel N Splitthoff, Ullrich Koethe, and Fred A Hamprecht.
On oblique random forests. In Joint European Conference on Machine Learning and Knowledge
Discovery in Databases, pp. 453-469. Springer, 2011.
Sreerama K Murthy, Simon Kasif, Steven Salzberg, and Richard Beigel. Oc1: A randomized al-
gorithm for building oblique decision trees. In AAAI Conference on Artificial Intelligence, vol-
ume 93, pp. 322-327. Citeseer, 1993.
Sreerama K Murthy, Simon Kasif, and Steven Salzberg. A system for induction of oblique decision
trees. Journal of Artificial Intelligence Research, 2:1-32, 1994.
11
Published as a conference paper at ICLR 2020
Vinod Nair and Geoffrey E Hinton. Rectified linear units improve restricted boltzmann machines.
In International Conference on Machine Learning, pp. 807-814, 2010.
Mohammad Norouzi, Maxwell Collins, Matthew A Johnson, David J Fleet, and Pushmeet Kohli. Ef-
ficient non-greedy optimization of decision trees. In Advances in Neural Information Processing
Systems, pp. 1729-1737, 2015.
Fabian Pedregosa, Gael Varoquaux, Alexandre Gramfort, Vincent Michel, Bertrand Thirion, Olivier
Grisel, Mathieu Blondel, Peter Prettenhofer, Ron Weiss, Vincent Dubourg, et al. Scikit-learn:
Machine learning in python. Journal of Machine Learning Research, 12(Oct):2825-2830, 2011.
Maithra Raghu, Ben Poole, Jon Kleinberg, Surya Ganguli, and Jascha Sohl Dickstein. On the
expressive power of deep neural networks. In International Conference on Machine Learning,
pp. 2847-2854. JMLR. org, 2017.
Sashank J. Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In
International Conference on Learning Representations, 2018.
David Rogers and Mathew Hahn. Extended-connectivity fingerprints. Journal of Chemical Infor-
mation and Modeling, 50(5):742-754, 2010.
Vlad Sandulescu and Mihai Chiru. Predicting the future relevance of research institutions-the win-
ning solution of the kdd cup 2016. arXiv preprint arXiv:1609.02728, 2016.
Ishwar Krishnan Sethi. Entropy nets: from decision trees to neural networks. IEEE, 78(10):1605-
1613, 1990.
Karen Simonyan, Andrea Vedaldi, and Andrew Zisserman. Deep inside convolutional networks: Vi-
sualising image classification models and saliency maps. arXiv preprint arXiv:1312.6034, 2013.
Daniel Smilkov, Nikhil Thorat, Been Kim, Fernanda Viegas, and Martin Wattenberg. Smoothgrad:
removing noise by adding noise. arXiv preprint arXiv:1706.03825, 2017.
Yang Song and Stefano Ermon. Generative modeling by estimating gradients of the data distribution.
In Advances in Neural Information Processing Systems, pp. 11895-11907, 2019.
Suraj Srinivas and Francois Fleuret. Knowledge transfer with Jacobian matching. In International
Conference on Machine Learning, pp. 4723-4731, 2018.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: a simple way to prevent neural networks from overfitting. Journal of Machine Learning
Research, 15(1):1929-1958, 2014.
V. N. Vapnik and A. Ya. Chervonenkis. On the uniform convergence of relative frequencies of
events to their probabilities. Theory of Probability & Its Applications, 16(2):264-280, 1971. doi:
10.1137/1116025. URL https://doi.org/10.1137/1116025.
Li Wan, Matthew Zeiler, Sixin Zhang, Yann Le Cun, and Rob Fergus. Regularization of neural
networks using dropconnect. In International Conference on Machine Learning, pp. 1058-1066,
2013.
Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Duane Boning, Inderjit S
Dhillon, and Luca Daniel. Towards fast computation of certified robustness for relu networks.
International Conference on Machine Learning, 2018.
DC Wickramarachchi, BL Robertson, Marco Reale, CJ Price, and J Brown. Hhcart: An oblique
decision tree. Computational Statistics & Data Analysis, 96:12-23, 2016.
Zhenqin Wu, Bharath Ramsundar, Evan N Feinberg, Joseph Gomes, Caleb Geniesse, Aneesh S
Pappu, Karl Leswing, and Vijay Pande. Moleculenet: a benchmark for molecular machine learn-
ing. Chemical Science, 9(2):513-530, 2018.
Yongxin Yang, Irene Garcia Morillo, and Timothy M Hospedales. Deep neural decision trees. arXiv
preprint arXiv:1806.06988, 2018.
12
Published as a conference paper at ICLR 2020
Chiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals. Understanding
deep learning requires rethinking generalization. In International Conference on Learning Rep-
resentations, 2017.
13
Published as a conference paper at ICLR 2020
A	Proofs
A.1 Proof of Lemma 6
Proof. We fix j and do induction on i. Without loss of generality, we assume 1 = rj 6= rj0 = 0.
If i = j , since rj0 = 0, we have
(ωrLi = Wi+:D	+ Pk=1	Wi,+D+k	×	rk	×	ωrι-.k-ι,
[ωr1 :i = Wi+1D	+ Pk=1	Wi+D+k	×	rk	×	ωrLkT
Hence, We have 3ri：i - ωr1 ：i = (Wi,++，× ri) × ωr1^-1 = α × ωrij-ι∙
We assume the statement holds for up to some integer i ≥ j :
3ri：i - ωr1 ：i = α × ωrij-l , for some α ∈ R∙
For i + 1, We have
i+1
ωr^i+ι =W1+2D +∑ WiD+k ×rk × ωrik-ι
k=1
j-1
= W；+2d + X WiD+k × rk × ωrLk-ι + WiD+j × rj × ωrij-ι
k=1
i+1
+ E Wi+D2+k Xrk X ωr*ι
k=j+1
j -1
= W：+2D + X Wl+D+k Xrk X ωr1 :k-i + Wl+D+j Xrj X ωrij-l
k=1
i+1
+ E Wι+D+k X rk X (ωr]k-1 + αk X ωrij-ι), for some a® ∈ R
k=j+1
i+1
= W：+2D +Σ Wl+D+k X rk X 3小-1
k=1
i+l
+ (Wl+D+j X r j + X W1,+D+k Xrk X ak) x ωrij-ι
k=j+l
=ωr1 ：i+i + a X ωrij-ι，for some a ∈ R
The proof follows by induction.	□
A.2 Proof of Theorem 8
Proof. We first prove that we can represent any gφ(Jxa M) as g(OM). Note that for any X mapping
to the same activation pattern OM, the Jacobian JxaM is constant. Hence, we may re-write the
standard architecture gφ(JxaM) as gφ( J(OM)), where J(OM) is the Jacobian corresponding to the
activation pattern OM. Then we can set g(∙)，gφ(J(∙)), which concludes the first part of the proof.
To prove the other direction, we first prove that we can also write the activation pattern as a function
of the Jacobian. We prove this by layer-wise induction (note that OM = [oɪ,..., oM] and JxaM =
[▽xa1,..., VxaM ]):
1.	The induction hypothesis (i ≥ 2) is that [ol,..., o：-1] is a function of [Vχɑ1,..., VxaILT].
2.	IfWl = 0 (zero vector), zll, all, and Oll are constant (thus being a function ofVxall). Otherwise,
Vxall = 0 ⇔ Oll = 0 and Vxall = Wl ⇔ Oll = 1, so Oll can be written as a function of Vxall.
14
Published as a conference paper at ICLR 2020
3.	Assume that We are given [Vχa1,..., Vχa1-1] and the corresponding [o1,..., o：-1].
If either oi1 = 0 or oi1 = 1 is infeasible (but not both), by induction hypothesis, [o11, . . . , oi1] can
be Written as a function of [Vxa11, . . . , Vxai1].
If oi1 = 1 for some x0 and oi1 = 0 for some x00, We claim that oi1 = 1 ⇒ Vx ai1 6= 0:
If oi1 = 1 and Vx ai1 = 0, We have oi1 = 1 ⇒ ai1 = z1i ≥ 0 and 0 = Vx ai1 = Vxz1i, Which
implies that the bias (of zi, given [o11, . . . , oi1-1]) z1i- (Vxz1i)>x ≥ 0. Note that both Vxz1i and
z1i- (Vxz1i)>x are constant given [o11, . . . , oi1-1], regardless of oi1. Hence, given [o11, . . . , oi1-1],
we have Zi = Zi —(Vxzi)>x ≥ 0 and o： = 0 is infeasible (⇒^).
Note that, given fixed [o11, . . . , oi1-1], Vxai1 6= 0 has a unique value in Rd. Combining the result
oi1 = 1 ⇒ Vxai1 6= 0 with oi1 = 0 ⇒ Vxai1 = 0, there is a bijection between oi1 and Vx ai1 in
this case, which implies that [o11, . . . , oi1] can be written as a function of [Vxa11, . . . , Vxai1].
The derivation implies that we may re-write the canonical architecture g(OM) as g(O(JxaM)),
where O(JxaM) is the activation pattern corresponding to the Jacobian JxaM. Hence, it suffices
to establish that there exists a feed-forward network gφ such that gφ(JxaM) = g(O(JxaM)) for
at most 2M distinct JxaM, which can be found by the Theorem 2.5 of Hornik et al. (1989) or the
Theorem 1 of Zhang et al. (2017).	口
B	Implementation details
Here we provide the full version of the implementation details.
For the baseline methods:
•	CART, HHCART, and TAO: we tune the tree depth in {2, 3, . . . , 12}.
•	RF: we use the scikit-learn (Pedregosa et al., 2011) implementation of random forest. We
set the number of estimators as 500.
•	GBDT: we use the scikit-learn (Pedregosa et al., 2011) implementation of gradient boost-
ing trees. We tune the number of estimators in {23 , 24 , . . . , 210 }.
For Lcn, Lln, and Alcn, we run the same training procedure. For all the datasets, we tune the
depth in {2, 3, . . . , 12} and the DropConnect probability in {0, 0.25, 0.5, 0.75}. The models are
optimized with mini-batch stochastic gradient descent with batch size set to 64. For all the classifi-
cation tasks, we set the learning rate as 0.1, which is annealed by a factor of 10 for every 10 epochs
(30 epochs in total). For the regression task, we set the learning rate as 0.0001, which is annealed
by a factor of 10 for every 30 epochs (60 epochs in total).
Both LCN and ALCN have an extra fully-connected network gφ, which transforms the derivatives
JxaM to the final outputs. Since regression tasks require precise estimation of prediction values
while classification tasks do not, we tune the number of hidden layers of gφ in {0, 1, 2, 3, 4} (each
with 256 neurons) for the regression dataset, and simply use a linear gφ for the classification datasets.
For ELCN, we fix the depth to 12 and tune the number of base models E ∈ {20, 21, . . . , 26} for the
classification tasks, and E ∈ {20, 21, . . . , 29} for the regression task. We set the DropConnect prob-
ability as 0.75 to encourage strong regularization for the classification tasks, and as 0.25 to impose
mild regularization for the regression task (because regression is hard to fit). We found stochastic
gradient descent does not suffice to incrementally learn the Elcn, so we use the AMSGrad opti-
mizer (Reddi et al., 2018) instead. We set the batch size as 256 and train each partial ensemble for
30 epochs. The learning rate is 0.01 for the classification tasks, and 0.0001 for the regression task.
To train our models, we use the cross entropy loss for the classification tasks, and mean squared
error for the regression task.
15
Published as a conference paper at ICLR 2020
Table 3: Analysis for “unobserved decision patterns” of Lcn in the Bace dataset.
Depth	8	9	10	11	12
# of possible patterns	256	512	1024	2048	4096
# of training patterns	72	58	85	103	86
# of testing patterns	32	31	48	49	40
# of testing patterns - training patterns	5	2	11	8	11
Ratio of testing points w/ unobserved patterns	0.040	0.013	0.072	0.059	0.079
Testing performance - observed patterns	0.8505	0.8184	0.8270	0.8429	0.8390
Testing performance - unobserved patterns	0.8596	0.9145	0.8303	0.7732	0.8894
C S upplementary empirical analysis and visualization
C.1 Supplementary empirical analysis
In this section, we investigate the learning of “unobserved branching / leaves” discussed in §3.6.
The “unobserved branching / leaves” refer to the decision and leaf nodes of the oblique decision tree
converted from Lcn, such that there is no training data that are routed to the nodes. It is impossible
for traditional (oblique) decision tree training algorithms to learn the values of such nodes (e.g.,
the output value of a leaf node in the traditional framework is based on the training data that are
routed to the leaf node). However, the shared parameterization in our oblique decision tree provides
a means to update such unobserved nodes during training (see the discussion in §3.6).
Since the above scenario in general happens more frequently in small datasets than in large datasets,
we evaluate the scenario on the small Bace dataset (binary classification task). Here we empirically
analyze a few things pertaining to the unobserved nodes:
•	# of training patterns: the number of distinct end-to-end activation / decision patterns r1:M en-
countered in the training data.
•	# of testing patterns: the number of distinct end-to-end activation / decision patterns r1:M en-
countered ib the testing data.
•	# of testing patterns - training patterns: the number of distinct end-to-end activation / decision
patterns r1:M that is only encountered in the testing data but not in the training data.
•	Ratio of testing points w/ unobserved patterns: the number of testing points that yield unobserved
patterns divided by the total number of testing points.
•	Testing performance - observed patterns: here we denote the number of testing data as n, the
prediction and label of the ith as yi ∈ [0,1] and yi ∈ {0,1}, respectively. We collect the subset
of indices I of the testing data such that their activation / decision patterns r1:M are observed
in the training data, and then compute the performance of their predictions. Since the original
performance is measured by AUC, here we generalize AUC to measure a subset of points I as:
Pi∈ι Pn=I (I[yi > y] (I[yi > yj] + 0∙5I[yi = yj]) + I[yi < y] (I[yi < yj] + 0.5I[yi = yj]))
Pi∈I Pjn=1 I[yi >yj]+I[yi<yj])
(6)
When I = [n], the above measure recovers AUC.
• Testing performance - unobserved patterns: the same as above, but use I for the testing data such
that their activation / decision patterns r1:M are unobserved in the training data.
The results are in Table 3. There are some interesting findings. For example, there is an exponential
number of possible patterns, but the number of patterns that appear in the dataset is quite small. The
ratio of testing points with unobserved patterns is also small, but these unobserved branching / leaves
seem to be controlled properly. They do not lead to completely different performance compared to
those that are observed during training.
C.2 Visualization
Here we visualize the learned locally constant network on the HIV dataset in the representation of
its equivalent oblique decision tree in Fig. 3. Since the dimension of Morgan fingerprint (Rogers &
16
Published as a conference paper at ICLR 2020
Hahn, 2010) is quite high (2,048), here we only visualize the top-K weights (in terms of the absolute
value) for each decision node. We also normalize each weight such that the `1 norm of each weight
is 1. Since the task is evaluated by ranking (AUC), we visualize the leaf nodes in terms of the
ranking of output probability among the leaf nodes (the higher the more likely).
Note that a complete visualization requires some engineering efforts. Our main contribution here
is the algorithm that transforms an Lcn to an oblique decision tree, rather than the visualization of
oblique decision trees, so we only provide the initial visualization as a proof of concept.
17
PUbHShed as a COnferenCe PaPer at ICLR 2020
O
4
3
W
14
3
2
15
Figure WViSUaHZation OfIeamed locally COIIStant IIetWOrk in the representation Of ObHqUe decision
trees USilIg the PrOOf Of Theorem 3∙ The IlUmben the IeaVeSindiCateS the ranking Of OUtPUt PrOba—
bty among the 16 IeaVeS (the exact VaIUe is IlOtimPOrtantSee the descriptionSiIl APPelldiX C2
18