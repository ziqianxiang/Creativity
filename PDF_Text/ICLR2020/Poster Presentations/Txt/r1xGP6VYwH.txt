Published as a conference paper at ICLR 2020
Optimistic Exploration Even With
A Pessimistic Initialisation
Tabish Rashid, Bei Peng, Wendelin Bohmer, Shimon Whiteson
University of Oxford
Department of Computer Science
{tabish.rashid, bei.peng,
wendelin.boehmer, shimon.whiteson}@cs.ox.ac.uk
Ab stract
Optimistic initialisation is an effective strategy for efficient exploration in reinforce-
ment learning (RL). In the tabular case, all provably efficient model-free algorithms
rely on it. However, model-free deep RL algorithms do not use optimistic initiali-
sation despite taking inspiration from these provably efficient tabular algorithms.
In particular, in scenarios with only positive rewards, Q-values are initialised at
their lowest possible values due to commonly used network initialisation schemes,
a pessimistic initialisation. Merely initialising the network to output optimistic
Q-values is not enough, since we cannot ensure that they remain optimistic for
novel state-action pairs, which is crucial for exploration. We propose a simple
count-based augmentation to pessimistically initialised Q-values that separates
the source of optimism from the neural network. We show that this scheme is
provably efficient in the tabular setting and extend it to the deep RL setting. Our
algorithm, Optimistic Pessimistically Initialised Q-Learning (OPIQ), augments the
Q-value estimates of a DQN-based agent with count-derived bonuses to ensure
optimism during both action selection and bootstrapping. We show that OPIQ
outperforms non-optimistic DQN variants that utilise a pseudocount-based intrinsic
motivation in hard exploration tasks, and that it predicts optimistic estimates for
novel state-action pairs.
1	Introduction
In reinforcement learning (RL), exploration is crucial for gathering sufficient data to infer a good
control policy. As environment complexity grows, exploration becomes more challenging and simple
randomisation strategies become inefficient.
While most provably efficient methods for tabular RL are model-based (Brafman and Tennenholtz,
2002; Strehl and Littman, 2008; Azar et al., 2017), in deep RL, learning models that are useful
for planning is notoriously difficult and often more complex (Hafner et al., 2019) than model-
free methods. Consequently, model-free approaches have shown the best final performance on
large complex tasks (Mnih et al., 2015; 2016; Hessel et al., 2018), especially those requiring hard
exploration (Bellemare et al., 2016; Ostrovski et al., 2017). Therefore, in this paper, we focus on how
to devise model-free RL algorithms for efficient exploration that scale to large complex state spaces
and have strong theoretical underpinnings.
Despite taking inspiration from tabular algorithms, current model-free approaches to exploration in
deep RL do not employ optimistic initialisation, which is crucial to provably efficient exploration in
all model-free tabular algorithms. This is because deep RL algorithms do not pay special attention
to the initialisation of the neural networks and instead use common initialisation schemes that yield
initial Q-values around zero. In the common case of non-negative rewards, this means Q-values are
initialised to their lowest possible values, i.e., a pessimistic initialisation.
While initialising a neural network optimistically would be trivial, e.g., by setting the bias of the final
layer of the network, the uncontrolled generalisation in neural networks changes this initialisation
quickly. Instead, to benefit exploration, we require the Q-values for novel state-action pairs must
remain high until they are explored.
1
Published as a conference paper at ICLR 2020
An empirically successful approach to exploration in deep RL, especially when reward is sparse,
is intrinsic motivation (Oudeyer and Kaplan, 2009). A popular variant is based on pseudocounts
(Bellemare et al., 2016), which derive an intrinsic bonus from approximate visitation counts over
states and is inspired by the tabular MBIE-EB algorithm (Strehl and Littman, 2008). However, adding
a positive intrinsic bonus to the reward yields optimistic Q-values only for state-action pairs that have
already been chosen sufficiently often. Incentives to explore unvisited states rely therefore on the
generalisation of the neural network. Exactly how the network generalises to those novel state-action
pairs is unknown, and thus it is unclear whether those estimates are optimistic when compared to
nearby visited state-action pairs.
Figure 1
Consider the simple example with a single state and two actions shown in Figure
1. The left action yields +0.1 reward and the right action yields +1 reward. An
agent whose Q-value estimates have been zero-initialised must at the first time
step select an action randomly. As both actions are underestimated, this will
increase the estimate of the chosen action. Greedy agents always pick the action
with the largest Q-value estimate and will select the same action forever, failing
to explore the alternative. Whether the agent learns the optimal policy or not is thus decided purely at
random based on the initial Q-value estimates. This effect will only be amplified by intrinsic reward.
To ensure optimism in unvisited, novel state-action pairs, we introduce Optimistic Pessimistically
Initialised Q-Learning (OPIQ). OPIQ does not rely on an optimistic initialisation to ensure efficient
exploration, but instead augments the Q-value estimates with count-based bonuses in the following
manner:	C
Q+(s,a) := Q(s,a)+(N(s,a) + 1)M，	⑴
where N(s, a) is the number of times a state-action pair has been visited and M, C > 0 are
hyperparameters. These Q+-values are then used for both action selection and during bootstrapping,
unlike the above methods which only utilise Q-values during these steps. This allows OPIQ to
maintain optimism when selecting actions and bootstrapping, since the Q+-values can be optimistic
even when the Q-values are not.
In the tabular domain, we base OPIQ on UCB-H (Jin et al., 2018), a simple online Q-learning
algorithm that uses count-based intrinsic rewards and optimistic initialisation. Instead of optimistically
initialising the Q-values, we pessimistically initialise them and use Q+-values during action selection
and bootstrapping. Pessimistic initialisation is used to enable a worst case analysis where all of
our Q-value estimates underestimate Q* and is not a requirement for OPIQ. We show that these
modifications retain the theoretical guarantees of UCB-H.
Furthermore, our algorithm easily extends to the Deep RL setting. The primary difficulty lies in
obtaining appropriate state-action counts in high-dimensional and/or continuous state spaces, which
has been tackled by a variety of approaches (Bellemare et al., 2016; Ostrovski et al., 2017; Tang et al.,
2017; Machado et al., 2018a) and is orthogonal to our contributions.
We demonstrate clear performance improvements in sparse reward tasks over 1) a baseline DQN that
just uses intrinsic motivation derived from the approximate counts, 2) simpler schemes that aim for
an optimistic initialisation when using neural networks, and 3) strong exploration baselines. We show
the importance of optimism during action selection for ensuring efficient exploration. Visualising the
predicted Q+-values shows that they are indeed optimistic for novel state-action pairs.
2 Background
We consider a Markov Decision Process (MDP) defined as a tuple (S, A, P, R), where S is the
state space, A is the discrete action space, P(∙∣s, a) is the state-transition distribution, R(∙∣s, a) is
the distribution over rewards and γ ∈ [0, 1) is the discount factor. The goal of the agent is then to
maximise the expected discounted sum of rewards: E[P∞=o Ytrt∣∖rt 〜R(∙∣st, at)], in the discounted
episodic setting. A policy ∏(∙∣s) is a mapping from states to actions such that it is a valid probability
distribution. Qπ(s,a) := E[P∞=o Ytrt|at 〜∏(∙∣st)] and Q* := max∏ Qπ.
Deep Q-Network (DQN) (Mnih et al., 2015) uses a nonlinear function approximator (a deep neural
network) to estimate the action-value function, Q(s, a; θ) ≈ Q* (s, a), where θ are the parameters
of the network. Exploration based on intrinsic rewards (e.g., Bellemare et al., 2016), which uses a
DQN agent, additionally augments the observed rewards rt with a bonus β/，N(St, at) based on
2
Published as a conference paper at ICLR 2020
Figure 2: A simple regression task to illustrate the effect of an optimistic initialisation in neural
networks. Left: 10 different networks whose final layer biases are initialised at 3 (shown in green),
and the same networks after training on the blue data points (shown in red). Right: One of the trained
networks whose output has been augmented with an optimistic bias as in equation 1. The counts were
obtained by computing a histogram over the input space [-2, 2] with 50 bins.
pseudo-visitation-counts N(st, at). The DQN parameters θ are trained by gradient descent on the
mean squared regression loss L with bootstrapped ‘target’ yt:
L[θ] ：= e[( rt + √N ； at)+ Y mao X Q(st+1, a0 ； θ— )-Q(st ,at ； θ)) ∣ (st ,at ,r ,st+ι)〜0]. (2)
The expectation is estimated with uniform samples from a replay buffer D (Lin, 1992). D stores past
transitions (st, at, rt, st+1), where the state st+1 is observed after taking the action at in state st and
receiving reward rt. To improve stability, DQN uses a target network, parameterised by θ-, which is
periodically copied from the regular network and kept fixed for a number of iterations.
3 OPTIMISTIC PESSIMISTICALLY INITIALISED Q-LEARNING
Our method Optimistic Pessimistically Initialised Q-Learning (OPIQ) ensures optimism in the Q-
value estimates of unvisited, novel state-action pairs in order to drive exploration. This is achieved by
augmenting the Q-value estimates in the following manner:
C
Q (s,a):= Q(S，a)+(N(s,a) + ι)M，
and using these Q+-values during action selection and bootstrapping. In this section, we motivate
OPIQ, analyse it in the tabular setting, and describe a deep RL implementation.
3.1	Motivations
Optimistic initialisation does not work with neural networks. For an optimistic initialisation to
benefit exploration, the Q-values must start sufficiently high. More importantly, the values for unseen
state-action pairs must remain high, until they are updated. When using a deep neural network to
approximate the Q-values, we can initialise the network to output optimistic values, for example, by
adjusting the final bias. However, after a small amount of training, the values for novel state-action
pairs may not remain high. Furthermore, due to the generalisation of neural networks we cannot know
how the values for these unseen state-action pairs compare to the trained state-action pairs. Figure 2
(left), which illustrates this effect for a simple regression task, shows that different initialisations can
lead to dramatically different generalisations. It is therefore prohibitively difficult to use optimistic
initialisation of a deep neural network to drive exploration.
Instead, we augment our Q-value estimates with an optimistic bonus. Our motivation for the
form of the bonus in equation 1, (N(S C+1)M, stems from UCB-H (Jin et al., 2018), where all tabular
Q-values are initialised with H and the first update for a state-action pair completely overwrites that
value because the learning rate for the update (η1) is 1. One can alternatively view these Q-values
as zero-initialised with the additional term Q(s, a) + H ∙ 1{N(s, a) < 1}, where N(s, a) is the
visitation count for the state-action pair (s, a). Our approach approximates the discrete indicator
3
Published as a conference paper at ICLR 2020
Algorithm 1 OPIQ algorithm
Initialise Qt(s, a) - 0, N(s, a, t) - 0, ∀(s, a,t) ∈ S × A×{1,…，H, H +1}
for each episode k = 1, ..., K do
for each timestep t = 1, ..., H do
Take action at J argmax。Q+ (st, a).
Receive r(st, at, t) and st+1.
Increment N(st, at, t).
Qt(st, at) J (1 - ηN)Qt(st, at) + ηN (r(st, at,t)+bTN + min{H, maxa0 Qt++1(st+1, a0)}).
end
end
function 1 as (N(s, a) + I)-M for sufficiently large M. However, since gradient descent cannot
completely overwrite the Q-value estimate for a state-action pair after a single update, it is beneficial
to have a smaller hyperparameter M that governs how quickly the optimism decays.
For a worst case analysis we assume all Q-value estimates are pessimistic. In the common
scenario where all rewards are nonnegative, the lowest possible return for an episode is zero. If we
then zero-initialise our Q-value estimates, as is common for neural networks, we are starting with a
pessimistic initialisation. As shown in Figure 2(left), we cannot predict how a neural network will
generalise, and thus we cannot predict if the Q-value estimates for unvisited state-action pairs will
be optimistic or pessimistic. We thus assume they are pessimistic in order to perform a worst case
analysis. However, this is not a requirement: our method works with any initialisation and rewards.
In order to then approximate an optimistic initialisation, the scaling parameter C in equation 1 can be
chosen to guarantee unseen Q+-values are overestimated, for example, C := H in the undiscounted
finite-horizon tabular setting and C := 1/(1 - γ) in the discounted episodic setting (assuming 1
is the maximum reward obtainable at each timestep). However, in some environments it may be
beneficial to use a smaller parameter C for faster convergence. These Q+-values are then used both
during action selection and during bootstrapping. Note that in the finite horizon setting the counts N,
and thus Q+ , would depend on the timestep t.
Hence, we split the optimistic Q+-values into two parts: a pessimistic Q-value component and
an optimistic component based solely on the counts for a state-action pair. This separates our
source of optimism from the neural network function approximator, yielding Q+-values that remain
high for unvisited state-action pairs, assuming a suitable counting scheme. Figure 2 (right) shows the
effects of adding this optimistic component to a network’s outputs.
Optimistic Q+-values provide an increased incentive to explore. By using optimistic Q+ esti-
mates, especially during action selection and bootstrapping, the agent is incentivised to try and visit
novel state-action pairs. Being optimistic during action selection in particular encourages the agent to
try novel actions that have not yet been visitied. Without an optimistic estimate for novel state-action
pairs the agent would have no incentive to try an action it has never taken before at a given state.
Being optimistic during bootstrapping ensures the agent is incentivised to return to states in which
it has not yet tried every action. This is because the maximum Q+-value will be large due to the
optimism bonus. Both of these effects lead to a strong incentive to explore novel state-action pairs.
3.2	Tabular Reinforcement Learning
In order to ensure that OPIQ has a strong theoretical foundation, we must ensure it is provably
efficient in the tabular domain. We restrict our analysis to the finite horizon tabular setting and only
consider building upon UCB-H (Jin et al., 2018) for simplicity. Achieving a better regret bound using
UCB-B (Jin et al., 2018) and extending the analysis to the infinite horizon discounted setting (Dong
et al., 2019) are steps for future work.
Our algorithm removes the optimistic initialisation of UCB-H, instead using a pessimistic initialisation
(all Q-values start at 0). We then use our Q+-values during action selection and bootstrapping.
Pseudocode is presented in Algorithm 1.
4
Published as a conference paper at ICLR 2020
Theorem 1. For any p ∈ (0, 1) , with probability at least 1 - p the total regret of Q+ is at most
O(PH4SAT log(SAT∕p)) for M ≥ 1 andatmost O(H 1+MSATI-M+pH4SAT log(SAT∕p))
for 0 < M < 1.
The proof is based on that of Theorem 1 from (Jin et al., 2018). Our Q+-values are always greater
than or equal to the Q-values that UCB-H would estimate, thus ensuring that our estimates are also
greater than or equal to Q*. Our overestimation relative to UCB-H is then governed by the quantity
H∕(N (s, a) + 1)M, which when summed over all timesteps does not depend on T for M > 1. As
M → ∞ we exactly recover UCB-H, and match the asymptotic performance of UCB-H for M ≥ 1.
Smaller values of M result in our optimism decaying more slowly, which results in more exploration.
The full proof is included in Appendix I.
We also show that OPIQ without optimistic action selection or the count-based intrinsic motivation
term bTN is not provably efficient by showing it can incur linear regret with high probability on simple
MDPs (see Appendices G and H).
Our primary motivation for considering a tabular algorithm that pessimistically initialises its Q-values,
is to provide a firm theoretical foundation on which to base a deep RL algorithm, which we describe
in the next section.
3.3	Deep Reinforcement Learning
For deep RL, we base OPIQ on DQN (Mnih et al., 2015), which uses a deep neural network with
parameters θ as a function approximator Qθ . During action selection, we use our Q+-values to
determine the greedy action:
at = arg max Qθ (s, a) +
a
Caction
(N (s,a) + 1)M
(3)
where Caction is a hyperparameter governing the scale of the optimistic bias during action selection. In
practice, we use an -greedy policy. After every timestep, we sample a batch of experiences from our
experience replay buffer, and use n-step Q-learning (Mnih et al., 2016). We recompute the counts
for each relevant state-action pair, to avoid using stale pseudo-rewards. The network is trained by
gradient decent on the loss in equation 2 with the target:
yt := Po Y i (r(st+i, at+i)+ √N (st+i,at+i) ) + Yn max{Qθ- (st+n, a0)+(N(StCooaτ+i)M o.(4)
where Cbootstrap is a hyperparameter that governs the scale of the optimistic bias during bootstrapping.
For our final experiments on Montezuma’s Revenge we additionally use the Mixed Monte Carlo
(MMC) target (Bellemare et al., 2016; Ostrovski et al., 2017), which mixes the target with the
environmental monte carlo return for that episode. Further details are included in Appendix D.4.
We use the method of static hashing (Tang et al., 2017) to obtain our pseudocounts on the first
2 of 3 environments we test on. For our experiments on Montezuma’s Revenge we count over a
downsampled image of the current game frame. More details can be found in Appendix B.
A DQN with pseudocount derived intrinsic reward (DQN + PC) (Bellemare et al., 2016) can be seen as
a naive extension of UCB-H to the deep RL setting. However, it does not attempt to ensure optimism
in the Q-values used during action selection and bootstrapping, which is a crucial component of UCB-
H. Furthermore, even if the Q-values were initialised optimistically at the start of training they would
not remain optimistic long enough to drive exploration, due to the use of neural networks. OPIQ,
on the other hand, is designed with these limitations of neural networks in mind. By augmenting
the neural network,s Q-value estimates with optimistic bonuses of the form (N(S C+i)m , OPIQ
ensures that the Q+-values used during action selection and bootstrapping are optimistic. We can thus
consider OPIQ as a deep version of UCB-H. Our results show that optimism during action selection
and bootstrapping is extremely important for ensuring efficient exploration.
4 Related Work
Tabular Domain: There is a wealth of literature related to provably efficient exploration in the
tabular domain. Popular model-based algorithms such as R-MAX (Brafman and Tennenholtz, 2002),
5
Published as a conference paper at ICLR 2020
MBIE (and MBIE-EB) (Strehl and Littman, 2008), UCRL2 (Jaksch et al., 2010) and UCBVI (Azar
et al., 2017) are all based on the principle of optimism in the face of uncertainty. Osband and Van Roy
(2017) adopt a Bayesian viewpoint and argue that posterior sampling (PSRL) (Strens, 2000) is more
practically efficient than approaches that are optimistic in the face of uncertainty, and prove that in
Bayesian expectation PSRL matches the performance of any optimistic algorithm up to constant
factors. Agrawal and Jia (2017) prove that an optimistic variant of PSRL is provably efficient under a
frequentist regret bound.
The only provably efficient model-free algorithms to date are delayed Q-learning (Strehl et al.,
2006) and UCB-H (and UCB-B) (Jin et al., 2018). Delayed Q-learning optimistically initialises the
Q-values that are carefully controlled when they are updated. UCB-H and UCB-B also optimistically
initialise the Q-values, but also utilise a count-based intrinsic motivation term and a special learning
rate to achieve a favourable regret bound compared to model-based algorithms. In contrast, OPIQ
pessimistically initialises the Q-values. Whilst we base our current analysis on UCB-H, the idea of
augmenting pessimistically initialised Q-values can be applied to any model-free algorithm.
Deep RL Setting: A popular approach to improving exploration in deep RL is to utilise intrinsic
motivation (Oudeyer and Kaplan, 2009), which computes a quantity to add to the environmental
reward. Most relevant to our work is that of Bellemare et al. (2016), which takes inspiration from
MBIE-EB (Strehl and Littman, 2008). Bellemare et al. (2016) utilise the number of times a state has
been visited to compute the intrinsic reward. They outline a framework for obtaining approximate
counts, dubbed pseudocounts, through a learned density model over the state space. Ostrovski et al.
(2017) extend the work to utilise a more expressive PixelCNN (van den Oord et al., 2016) as the
density model, whereas Fu et al. (2017) train a neural network as a discriminator to also recover a
density model. Machado et al. (2018a) instead use the successor representation to obtain generalised
counts. Choi et al. (2019) learn a feature space to count that focusses on regions of the state space
the agent can control, and Pathak et al. (2017) learn a similar feature space in order to provide the
error of a learned model as intrinsic reward. A simpler and more generic approach to approximate
counting is static hashing which projects the state into a lower dimensional space before counting
(Tang et al., 2017). None of these approaches attempt to augment or modify the Q-values used for
action-selection or bootstrapping, and hence do not attempt to ensure optimistic values for novel
state-action pairs.
Chen et al. (2017) build upon bootstrapped DQN (Osband et al., 2016) to obtain uncertainty estimates
over the Q-values for a given state in order to act optimistically by choosing the action with the
largest UCB. However, they do not utilise optimistic estimates during bootstrapping. Osband et al.
(2018) also extend bootstrapped DQN to include a prior by extending RLSVI (Osband et al., 2017) to
deep RL. Osband et al. (2017) show that RLSVI achieves provably efficient Bayesian expected regret,
which requires a prior distribution over MDPs, whereas OPIQ achieves provably efficient worse case
regret. Bootstrapped DQN with a prior is thus a model-free algorithm that has strong theoretical
support in the tabular setting. Empirically, however, its performance on sparse reward tasks is worse
than DQN with pseudocounts.
Machado et al. (2015) shift and scale the rewards so that a zero-initialisation is optimistic. When
applied to neural networks this approach does not result in optimistic Q-values due to the generali-
sation of the networks. Bellemare et al. (2016) empirically show that using a pseudocount intrinsic
motivation term performs much better empirically on hard exploration tasks.
Choshen et al. (2018) attempt to generalise the notion of a count to include information about the
counts of future state-actions pairs in a trajectory, which they use to provide bonuses during action
selection. Oh and Iyengar (2018) extend delayed Q-learning to utilise these generalised counts and
prove the scheme is PAC-MDP. The generalised counts are obtained through E-values which are
learnt using SARSA with a constant 0 reward and E-value estimates initialised at 1. When scaling to
the deep RL setting, these E-values are estimated using neural networks that cannot maintain their
initialisation for unvisited state-action pairs, which is crucial for providing an incentive to explore. By
contrast, OPIQ uses a separate source to generate the optimism necessary to explore the environment.
6
Published as a conference paper at ICLR 2020
5	Experimental Setup
We compare OPIQ against baselines and ablations on three sparse reward environments. The first
is a randomized version of the Chain environment proposed by Osband et al. (2016) and used in
(Shyam et al., 2019) with a chain of length 100, which we call Randomised Chain. The second is a
two-dimensional maze in which the agent starts in the top left corner (white dot) and is only rewarded
upon finding the goal (light grey dot). We use an image of the maze as input and randomise the
actions similarly to the chain. The third is Montezuma’s Revenge from Arcade Learning environment
(Bellemare et al., 2013), a notoriously difficult sparse reward environment commonly used as a
benchmark to evaluate the performance and scaling of Deep RL exploration algorithms.
See Appendix D for further details on the environments, baselines and hyperparameters used.1
5.1	Ablations and Baselines
We compare OPIQ against a variety of DQN-based approaches that use pseudocount intrinsic rewards,
the DORA agent (Choshen et al., 2018) (which generates count-like optimism bonuses using a neural
network), and two strong exploration baselines:
-greedy DQN: a standard DQN that uses an -greedy policy to encourage exploration. We anneal
linearly over a fixed number of timesteps from 1 to 0.01.
DQN + PC: We add an intrinsic reward of β//N(s, a) to the environmental reward based on
(Bellemare et al., 2016; Tang et al., 2017).
DQN R-Subtract (+PC): we subtract a constant from all environmental rewards received when
training, so that a zero-initialisation is optimistic, as described for a DQN in (Bellemare et al., 2016)
and based on Machado et al. (2015).
DQN Bias (+PC): we initialise the bias of the final layer of the DQN to a positive value at the start
of training as a simple method for optimistic initialisation with neural networks.
DQN + DORA: we use the generalised counts from (Choshen et al., 2018) as an intrinsic reward.
DQN + DORA OA: we additionally use the generalised counts to provide an optimistic bonus during
action selection.
DQN + RND: we add the RND bonus from (Burda et al., 2018) as an intrinsic reward.
BSP: we use Bootstrapped DQN with randomised prior functions (Osband et al., 2018).
In order to better understand the importance of each component of our method, we also evaluate the
following ablations:
Optimistic Action Selection (OPIQ w/o OB): we only use our Q+-values during action selection,
and use Q during bootstrapping (without Optimistic Bootstrapping). The intrinsic motivation term
remains.
Optimistic Action Selection and Bootstrapping (OPIQ w/o PC): we use our Q+-values during
action selection and bootstrapping, but do not include an intrinsic motivation term (without Pseudo
Counts).
6	Results
6.1	Randomised Chain
We first consider the visually simple domain of the randomised chain and compare the count-based
methods. Figure 3 shows the performance of OPIQ compared to the baselines and ablations. OPIQ
significantly outperforms the baselines, which do not have any explicit mechanism for optimism
during action selection. A DQN with pseudocount derived intrinsic rewards is unable to reliably find
the goal state, but setting the final layer’s bias to one produces much better performance. For the
DQN variant in which a constant is subtracted from all rewards, all of the configurations (including
those with pseudocount derived intrinsic bonuses) were unable to find the goal on the right and thus
the agents learn quickly to latch on the inferior reward of moving left.
Compared to its ablations, OPIQ is more stable in this task. OPIQ without pseudocounts performs
similarly to OPIQ but is more varied across seeds, whereas the lack of optimistic bootstrapping results
in worse performance and significantly more variance across seeds.
1Code is available at: https://github.com/oxwhirl/opiq.
7
Published as a conference paper at ICLR 2020
6.2	Maze
We next consider the harder and more visually complex task of the Maze and compare against all
baselines.
Figure 4 shows that only OPIQ is able to find the goal in the sparse reward maze. This indicates that
explicitly ensuring optimism during action selection and bootstrapping can have a significant positive
impact in sparse reward tasks, and that a naive extension of UCB-H to the deep RL setting (DQN +
PC) results in insufficient exploration.
Figure 4 (right) shows that attempting to ensure optimistic Q-values by adjusting the bias of the final
layer (DQN Bias + PC), or by subtracting a constant from the reward (DQN R-Subtract + PC) has
very little effect.
As expected DQN + RND performs poorly on this domain compared to the pseudocount based
methods. The visual input does not vary much across the state space, resulting in the RND bonus
failing to provide enough intrinsic motivation to ensure efficient exploration. Additionally it does not
feature any explicit mechanism for optimism during action selection, and thus Figure 4 (right) shows
it explores the environment relatively slowly.
Both DQN+DORA and DQN+DORA OA also perform poorly in this domain since their source of
intrinsic motivation disappears quickly. As noted in Figure 2, neural networks do not maintain their
starting initialisations after training. Thus, the intrinsic reward DORA produces goes to 0 quickly
since the network producing its bonuses learns to generalise quickly.
BSP is the only exploration baseline we test that does not add an intrinsic reward to the environmental
reward, and thus it performs poorly compared to the other baselines on this environment.
Figure 5 shows that OPIQ and all its ablations manage to find the goal in the maze. OPIQ also
explores slightly faster than its ablations (right), which shows the benefits of optimism during both
action selection and bootstrapping. In addition, the episodic reward for the the ablation without
optimistic bootstrapping is noticeably more unstable (Figure 5, left). Interestingly, OPIQ without
pseudocounts performs significantly worse than the other ablations. This is surprising since the theory
suggests that the count-based intrinsic motivation is only required when the reward or transitions of
the MDP are stochastic (Jin et al., 2018), which is not the case here. We hypothesise that adding
PC-derived intrinsic bonuses to the reward provides an easier learning problem, especially when
using n-step Q-Learning, which yields the performance gap.
However, our results show that the PC-derived intrinsic bonuses are not enough on their own to
ensure sufficient exploration. The large difference in performance between DQN + PC and OPIQ
w/o OB is important, since they only differ in the use of optimistic action selection. The results in
Figures 4 and 5 show that optimism during action selection is extremely important in exploring the
environment efficiently. Intuitively, this makes sense, since this provides an incentive for the agent to
try actions it has never tried before, which is crucial in exploration.
Figure 6 visualises the values used during action selection for a DQN + PC agent and OPIQ, showing
the count-based augmentation provides optimism for relatively novel state-action pairs, driving the
agent to explore more of the state-action space.
p」EMəɑ IS①J. UE-PBIAI
—OPIQ
—DQN + PC
—DQlΨBiasτrPC
—DQN R-Subtrac
Figure 3: Results for the randomised chain environment. Median across 20 seeds is plotted and the
25%-75% quartile is shown shaded. Left: OPIQ outperforms the baselines. Right: OPIQ is more
stable than its ablations.
8
Published as a conference paper at ICLR 2020
Figure 4: Results for the maze environment comparing OPIQ and baselines. Median across 8 seeds
is plotted and the 25%-75% quartile is shown shaded. Left: The episode reward. Right: Number
of distinct states visited over training. The total number of states in the environment is shown as a
dotted line.
108 6 4 2 O
PJBM ① α ① POs一S-U0P ① ∣Λ∣
2∞k
—OPIQ
-OPIQ w∕o OB
—OPIQ w∕o PC
200k	400k	600k	800k 1000k
T
Figure 6: Values used during action selection for each of the 4 actions. The region in blue indicates
states that have already been visited. Other colours denote Q-values between 0 (black) and 10
(white). Left: The Q-values used by DQN with pseudocounts. Right: Q+-values used by OPIQ
with Caction = 100.
Figure 5: Results for the maze environment comparing OPIQ and ablations. Median across 8 seeds
is plotted and the 25%-75% quartile is shown shaded. Left: The episode reward. Right: Number
of distinct states visited over training. The total number of states in the environment is shown as a
dotted line.
6.3	Montezuma’ s Revenge
Finally, we consider Montezuma’s Revenge, one of the hardest sparse reward games from the ALE
(Bellemare et al., 2013). Note that we only train up to 12.5mil timesteps (50mil frames), a 1/4 of the
usual training time (50mil timesteps, 200mil frames).
Figure 7 shows that OPIQ significantly outperforms the baselines in terms of the episodic reward and
the maximum episodic reward achieved during training. The higher episode reward and much higher
maximum episode reward of OPIQ compared to DQN + PC once again demonstrates the importance
of optimism during action selection and bootstrapping.
9
Published as a conference paper at ICLR 2020
Figure 7: Results for Montezuma’s Revenge. Median across 4 seeds is plotted and the 25%-75%
quartile is shown shaded. Left: The episode reward. Right: The maximum reward achieved during
an episode.
—OPIQ
DQN + PC
DQN + RND
Figure 8: Further Results for Montezuma’s Revenge showing the number of rooms visited over
training comparing OPIQ and baselines. Median across 4 seeds is plotted and the 25%-75% quartile
is shown shaded.
In this environment BSP performs much better than in the Maze, but achieves significantly lower
episodic rewards than OPIQ.
Figure 8 shows the distinct number of rooms visited across the training period. We can see that OPIQ
manages to reliably explore 12 rooms during the 12.5mil timesteps, significantly more than the other
methods, thus demonstrating its improved exploration in this complex environment.
Our results on this challenging environment show that OPIQ can scale to high dimensional complex
environments and continue to provide significant performance improvements over an agent only
using pseudocount based intrinsic rewards.
7	Conclusions and Future Work
This paper presented OPIQ, a model-free algorithm that does not rely on an optimistic initialisation
to ensure efficient exploration. Instead, OPIQ augments the Q-values estimates with a count-based
optimism bonus. We showed that this is provably efficient in the tabular setting by modifying UCB-H
to use a pessimistic initialisation and our augmented Q+-values for action selection and bootstrapping.
Since our method does not rely on a specific initialisation scheme, it easily scales to deep RL when
paired with an appropriate counting scheme. Our results showed the benefits of maintaining optimism
both during action selection and bootstrapping for exploration on a number of hard sparse reward
environments including Montezuma’s Revenge. In future work, we aim to extend OPIQ by integrating
it with more expressive counting schemes.
10
Published as a conference paper at ICLR 2020
8	Acknowledgements
We would like to thank the entire WhiRL lab for their helpful feedback, in particular Gregory Farquhar
and Supratik Paul. We would also like to thank the anonymous reviewers for their constructive com-
ments during the reviewing process. This project has received funding from the European Research
Council (ERC), under the European Union’s Horizon 2020 research and innovation programme
(grant agreement number 637713). It was also supported by an EPSRC grant (EP/M508111/1,
EP/N509711/1). The experiments were made possible by a generous equipment grant from NVIDIA
and the JP Morgan Chase Faculty Research Award.
References
Shipra Agrawal and Randy Jia. Optimistic posterior sampling for reinforcement learning: worst-case
regret bounds. In Advances in NeUral Information Processing Systems, pages 1184-1194, 2017.
Mohammad GheShlaghi Azar, Ian Osband, and Remi Munos. Minimax regret bounds for reinforce-
ment learning. In Proceedings of the 34th International Conference on Machine Learning, pages
263-272, 2017.
Marc Bellemare, Sriram Srinivasan, Georg Ostrovski, Tom Schaul, David Saxton, and Remi Munos.
Unifying count-based exploration and intrinsic motivation. In Advances in Neural Information
Processing Systems, pages 1471-1479, 2016.
Marc G Bellemare, Yavar Naddaf, Joel Veness, and Michael Bowling. The arcade learning environ-
ment: An evaluation platform for general agents. Journal of Artificial Intelligence Research, 47:
253-279, 2013.
Ronen I Brafman and Moshe Tennenholtz. R-MAX - a general polynomial time algorithm for
near-optimal reinforcement learning. Journal of Machine Learning Research, 3(Oct):213-231,
2002.
Yuri Burda, Harrison Edwards, Amos Storkey, and Oleg Klimov. Exploration by random network
distillation. arXiv preprint arXiv:1810.12894, 2018.
Richard Y Chen, John Schulman, Pieter Abbeel, and Szymon Sidor. UCB and infogain exploration
via Q-ensembles. arXiv preprint arXiv:1706.01502, 2017.
Jongwook Choi, Yijie Guo, Marcin Moczulski, Junhyuk Oh, Neal Wu, Mohammad Norouzi, and
Honglak Lee. Contingency-aware exploration in reinforcement learning. In International Confer-
ence on Learning Representations, 2019.
Leshem Choshen, Lior Fox, and Yonatan Loewenstein. Dora the explorer: Directed outreaching
reinforcement action-selection. In International Conference on Learning Representations, 2018.
Kefan Dong, Yuanhao Wang, Xiaoyu Chen, and Liwei Wang. Q-learning with UCB exploration is
sample efficient for infinite-horizon MDP. arXiv preprint arXiv:1901.09311, 2019.
Adrien Ecoffet, Joost Huizinga, Joel Lehman, Kenneth O Stanley, and Jeff Clune. Go-explore: a new
approach for hard-exploration problems. arXiv preprint arXiv:1901.10995, 2019.
Li Fan, Pei Cao, Jussara Almeida, and Andrei Z Broder. Summary cache: a scalable wide-area web
cache sharing protocol. IEEE/ACM Transactions on Networking (TON), 8(3):281-293, 2000.
Justin Fu, John Co-Reyes, and Sergey Levine. EX2: Exploration with exemplar models for deep
reinforcement learning. In Advances in Neural Information Processing Systems, pages 2577-2587,
2017.
Sudhir K Goel and Dennis M Rodriguez. A note on evaluating limits using riemann sums. Mathe-
matics Magazine, 60(4):225-228, 1987.
Danijar Hafner, Timothy Lillicrap, Ian Fischer, Ruben Villegas, David Ha, Honglak Lee, and James
Davidson. Learning latent dynamics for planning from pixels. In Proceedings of the 36th
International Conference on Machine learning, 2019.
11
Published as a conference paper at ICLR 2020
Matteo Hessel, Joseph Modayil, Hado Van Hasselt, Tom Schaul, Georg Ostrovski, Will Dabney, Dan
Horgan, Bilal Piot, Mohammad Azar, and David Silver. Rainbow: Combining improvements in
deep reinforcement learning. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
Thomas Jaksch, Ronald Ortner, and Peter Auer. Near-optimal regret bounds for reinforcement
learning. Journal ofMachine Learning Research, 11(APr):1563-1600, 2010.
Chi Jin, Zeyuan Allen-Zhu, Sebastien Bubeck, and Michael I Jordan. Is Q-learning provably efficient?
In Advances in Neural Information Processing Systems, Pages 4863-4873, 2018.
Long-Ji Lin. Self-imProving reactive agents based on reinforcement learning, Planning and teaching.
Machine learning, 8(3-4):293-321, 1992.
Marlos C Machado, Sriram Srinivasan, and Michael H Bowling. Domain-indePendent oPtimistic
initialization for reinforcement learning. In AAAI Workshop: Learning for General Competency in
Video Games, 2015.
Marlos C Machado, Marc G Bellemare, and Michael Bowling. Count-based exPloration with the
successor rePresentation. arXiv preprint arXiv:1807.11622, 2018a.
Marlos C Machado, Marc G Bellemare, Erik Talvitie, Joel Veness, Matthew Hausknecht, and Michael
Bowling. Revisiting the arcade learning environment: Evaluation Protocols and oPen Problems for
general agents. Journal of Artificial Intelligence Research, 61:523-562, 2018b.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A Rusu, Joel Veness, Marc G Bellemare,
Alex Graves, Martin Riedmiller, Andreas K Fidjeland, Georg Ostrovski, et al. Human-level control
through deeP reinforcement learning. Nature, 518(7540):529, 2015.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy LillicraP, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deeP reinforcement
learning. In Proceedings of the 33rd International Conference on Machine Learning, Pages
1928-1937, 2016.
Min-hwan Oh and Garud Iyengar. Directed exPloration in PAC model-free reinforcement learning.
arXiv preprint arXiv:1808.10552, 2018.
Ian Osband and Benjamin Van Roy. Why is Posterior samPling better than oPtimism for reinforcement
learning? In Proceedings of the 34th International Conference on Machine Learning, Pages 2701-
2710, 2017.
Ian Osband, Charles Blundell, Alexander Pritzel, and Benjamin Van Roy. DeeP exPloration via
bootstraPPed DQN. In Advances in Neural Information Processing Systems, Pages 4026-4034,
2016.
Ian Osband, Daniel Russo, Zheng Wen, and Benjamin Van Roy. DeeP exPloration via randomized
value functions. arXiv preprint arXiv:1703.07608, 2017.
Ian Osband, John Aslanides, and Albin Cassirer. Randomized Prior functions for deeP reinforcement
learning. In Advances in Neural Information Processing Systems, Pages 8617-8629, 2018.
Georg Ostrovski, Marc G Bellemare, Aaron van den Oord, and Remi Munos. Count-based exploration
with neural density models. arXiv preprint arXiv:1703.01310, 2017.
Pierre-Yves Oudeyer and Frederic Kaplan. What is intrinsic motivation? a typology of computational
approaches. Frontiers in neurorobotics, 1:6, 2009.
Deepak Pathak, Pulkit Agrawal, Alexei A. Efros, and Trevor Darrell. Curiosity-driven exploration
by self-supervised prediction. In Proceedings of the 34th International Conference on Machine
Learning, 2017.
Pranav Shyam, Wojciech ja´kowski, and Faustino Gomez. Model-based active exploration. In
Proceedings of the 36th International Conference on Machine Learning, 2019.
Alexander L Strehl and Michael L Littman. An analysis of model-based interval estimation for
markov decision processes. Journal of Computer and System Sciences, 74(8):1309-1331, 2008.
12
Published as a conference paper at ICLR 2020
Alexander L Strehl, Lihong Li, Eric Wiewiora, John Langford, and Michael L Littman. PAC model-
free reinforcement learning. In Proceedings of the 23rd International Conference on Machine
learning, pages 881-888. ACM, 2006.
Malcolm Strens. A bayesian framework for reinforcement learning. In Proceedings of the 17th
International Conference on Machine Learning, pages 943-950, 2000.
Adrien Ali Taiga, Aaron Courville, and Marc G Bellemare. Approximate exploration through state
abstraction. arXiv preprint arXiv:1808.09819, 2018.
Haoran Tang, Rein Houthooft, Davis Foote, Adam Stooke, OpenAI Xi Chen, Yan Duan, John
Schulman, Filip DeTurck, and Pieter Abbeel. #Exploration: A study of count-based exploration
for deep reinforcement learning. In Advances in Neural Information Processing Systems, pages
2753-2762, 2017.
Aaron van den Oord, Nal Kalchbrenner, Lasse Espeholt, Oriol Vinyals, Alex Graves, et al. Conditional
image generation with pixelcnn decoders. In Advances in Neural Information Processing Systems,
pages 4790-4798, 2016.
13
Published as a conference paper at ICLR 2020
A Background
A.1 Tabular Reinforcement Learning
For the tabular setting, we consider a discrete finite-horizon Markov Decision Process (MDP), which
can be defined as a tuple (S, A, {Pt}, {Rt}, H, ρ), where S is the finite state space, A is the finite
action space, Pt(∙∣s, a) is the state-transition distribution for timestep t = 1,…,H, Rt(∙∣s, a) is the
distribution over rewards after taking action a in state s, H is the horizon, and ρ is the distribution
over starting states. Without loss of generality We assume that Rt(∙∣s, a) ∈ [0,1]. We use S and A to
denote the number of states and the number of actions, respectively, and N(s, a,t) as the number of
times a state-action pair (s, a) has been visited at timestep t.
Our goal is to find a set of policies πt : S → A, π := {πt}, that chooses the agent’s actions at time
t such that the expected sum of future reWards is maximised. To this end We define the Q-value at
time t of a given policy π as Qn(s, a) := E [r + Q∏+ι(s0, ∏t+ι(s0)) | r~Rt(∙∣s,a),s0~Pt(∙∣s,a)], where
Qtπ(s, a) = 0, ∀t > H. The agent interacts With the environment for K episodes, T := KH,
yielding a total regret: Regret(K) = PK=I (max∏* Q∏*(sf ,∏j(sf)) - Qnk (Sk ,∏k(sf))). Here Sk
refers to the starting state and πk to the policy at the beginning of episode k . We are interested in
bounding the worst case total regret with probability 1 - p, 0 < p < 1.
UCB-H (Jin et al., 2018) is an online Q-learning algorithm for the finite-horizon setting outlined above
where the worse case total regret is bounded with a probability of 1 -p by O(，H4SAT log(SAT∕p).
All Q-values for timesteps t ≤ H are optimistically initialised at H. The learning rate is defined
as nN = H+N, where N := N(st, at,t) is the number of times state-action pair (st, at) has been
observed at step t and η1 = 1 at the first encounter of any state-action pair. The update rule for a
transition at step t from state st to st+1, after executing action at and receiving reward rt, is:
Qt(st, at) - (1 - nN) Qt(st, at) + nN (Tt + bN + min{H, mqx Qt+ι(st+ι,a0)}),	(5)
0
where bTN := 2RHO蚁NTlPp
is the count-based intrinsic motivation term.2
B Counting in Large, Complex State Spaces
In deep RL, the primary difficulty for exploration based on count-based intrinsic rewards is obtaining
appropriate state-action counts. In this paper we utilise approximate counting schemes (Bellemare
et al., 2016; Ostrovski et al., 2017; Tang et al., 2017) in order to cope with continuous and/or high-
dimensional state spaces. In particular, for the chain and maze environments we use static hashing
(Tang et al., 2017), which projects a state s to a low-dimensional feature vector φ(s) = sign(Af (s)),
where f flattens the state s into a single dimension of length D; A is a k × D matrix whose entries are
initialised i.i.d. from a unit Gaussian: N(0, 1); and k is a hyperparameter controling the granularity
of counting: higher k leads to more distinguishable states at the expense of generalisation.
Given the vector φ(s), we use a counting bloom filter (Fan et al., 2000) to update and retrieve
its counts efficiently. To obtain counts N(s, a) for state-action pairs, we maintain a separate data
structure of counts for each action (the same vector φ(s) is used for all actions). This counting scheme
is tabular and hence the counts for sufficiently different states do not interfere with one another. This
ensures Q+-values for unseen state-action pairs in equation 1 are large.
For our experiments on Montezuma’s Revenge we use the same method of downsampling as in
(Ecoffet et al., 2019), in which the greyscale state representation is resized from (42x42) to (11x8)
and then binned from {0, ..., 255} into 8 categories. We then maintain tabular counts over the new
representation.
C Granularity of the counting model
The granularity of the counting scheme is an important modelling consideration. If it is too granular,
then it will assign an optimistic bias in regions of the state space where the network should be trusted
2 Jin et al. (2018) use ∃c > 0 s.t. bN := C JH3log(NAT/p) in their proof, but we find that C
2 suffices.
14
Published as a conference paper at ICLR 2020
to generalise. On the other hand, if it is too coarse then it could fail to provide enough of an optimistic
bias in parts of the state space where exploration is still required. Figures 9 shows the differences
between 2 levels of granularity. Taiga et al. (2018) provide a much more detailed analysis on the
Figure 9: We consider the counting scheme from Figure 2, but vary the number of bins used. Left: 6
bins are used. Only the data points far from the training data are given an optimistic bias. Right: 50
bins are used. An optimistic bias is given to all data points that are not very close to the training data.
D Experimental Setup
D.1 Environments
D.1.1 Randomised Chain
A randomized version of the Chain environment proposed by Osband et al. (2016) and used in
(Shyam et al., 2019). We use a Chain of length 100. The agent starts the episode in State 2, and
interacts with the MDP for 109 steps, after which the agent is reset. The agent has 2 actions that
can move it Left or Right. At the beginning of training the action which takes the agent left or right
at each state is randomly picked and then fixed. The agent receives a reward of 0.001 for going
Left in State 1, a reward of 1 for going Right in State 100 and no reward otherwise. The optimal
policy is thus to pick the action that takes it Right at each timestep. Figure 10 shows the structure
of the 100 Chain. Similarly to Osband et al. (2016) we use a thermometer encoding for the state:
φ(s) := (l{x ≤ s}) ∈ {0,1}100.
Figure 10: 100 Chain environment.
D.1.2 MAZE
A 2-dimensional gridworld maze with a sparse reward in which the agent can move Up, Down, Left
or Right. The agent starts each episode at a fixed location and must traverse through the maze in
order to find the goal which provides +10 reward and terminates the episode, all other rewards are 0.
The agent interacts with the maze for 250 timesteps before being reset. Empty space is represented
by a 0, walls are 1, the goal is 2 and the player is 3. The state representation is a greyscaled image of
the entire grid where each entry is divided by 3 to lie in [0, 1]. The shape of the state representation
is: (24, 24, 1). Once again the effect of each action is randomised at each state at the beginning of
training. Figure 11 shows the structure of the maze environment.
15
Published as a conference paper at ICLR 2020
Figure 11: Maze environment.
D.1.3 Montezuma’ s Revenge
We follow the suggestions in (Machado et al., 2018b) and use the same environmental setup as used
in (Burda et al., 2018). Specifically, we use stick actions with a probability ofp = 0.25, a frame skip
of 4 and do not show a terminal state on the loss of life.
D.2 Hyperparameters and Network architectures
In all experiments we set γ = 0.99, use RMSProp with a learning rate of 0.0005 and scale the
gradient norms during training to be at most 5.
D.2.1 Randomised Chain
The network used is a MLP with 2 hidden layers of 256 units and ReLU non-linearities. We use 1
step Q-Learning.
Training lasts for 100k timesteps. is fixed at 0.01 for all methods except for -greedy DQN in
which it is linearly decayed from 1 to 0.01 over {100, 50k, 100k} timesteps. We train on a batch
size of 64 after every timestep with a replay buffer of size 10k. The target network is updated every
200 timesteps. The embedding size used for the counts is 32. We set β = 0.1 for the scale of the
count-based intrinsic motivation.
For reward subtraction we consider subtracting {0.1, 1, 10} from the reward. For an optimistic
initialisation bias, we consider setting the final layer’s bias to {0.1, 1, 10}. We consider both of the
methods with and without count-based intrinsic motivation.
For OPIQ and its ablations we consider: M ∈ {0.1, 0.5, 2, 10}, Caction ∈ {0.1, 1, 10}, Cbootstrap ∈
{0.01, 0.1, 1, 10}.
For all methods we run 20 independent runs across the cross-product of all relevant parameters
considered. We then sort them by the median test reward (largest area underneath the line) and report
the median, lower and upper quartiles.
The best hyperparameters we found were:
DQN -greedy: Decay rate: 100 timesteps.
Optimistic Initialisation Bias: Bias: 1, Pseudocount intrinsic motivation: True.
Reward Subtraction: Constant to subtract: 1, Pseudocount intrinsic motivation: False.
OPIQ: M: 0.5, Caction: 1, Cbootstrap: 1.
OPIQ without Optimistic Bootstrapping: M: 2, Caction: 10.
OPIQ without Pseudocounts: M: 2, Caction: 10, Cbootstrap: 10.
For Figure 13 the best hyperparameters for OPIQ with differing values of M are:
M: 0.1: Caction: 10, Cbootstrap: 1.
M: 0.5: Caction : 1, Cbootstrap : 1.
M: 2: Caction: 10,
M: 10: Caction: 10
Cbootstrap : 1.
, Cbootstrap : 10.
16
Published as a conference paper at ICLR 2020
D.2.2 MAZE
The network used is the following feedforward network:
(State input: (24,24,1))
→ (Conv Layer, 3x3 Filter, 16 Channels, Stride 2) → ReLU
→ (Conv Layer, 3x3 Filter, 16 Channels, Stride 2) → ReLU
→ Flatten
→ (FC Layer, 400 Units) → ReLU
→ (FC Layer, 200 Units)
→ A = 4 outputs.
We use 3 step Q-Learning.
Training lasts for 1mil timesteps. is decayed linearly from 1 to 0.01 over 50k timesteps for all
methods except for -greedy DQN in which it is linearly decayed from 1 to 0.01 over {100, 50k, 100k}
timesteps. We train on a batch of 64 after every timestep with a replay buffer of size 250k. The target
network is updated every 1000 timesteps. The embedding dimension for the counts is 128.
For DQN + PC we consider β ∈ {0.01, 0.1, 1, 10, 100}. For all other methods we set β = 0.1 as it
performed best.
For reward subtraction we consider subtracting {0.1, 1, 10} from the reward. For an optimistic
initialisation bias, we consider setting the final layer’s bias to {0.1, 1, 10}. Both methods utilise a
count-based intrinsic motivation.
For OPIQ and its ablations we set M = 2 since it worked best in preliminary experiments. We
consider: Caction ∈ {0.1, 1, 10, 100}, Cbootstrap ∈ {0.01, 0.1, 1, 10}.
For the RND bonus we use the same architecture as the DQN for both the target and predictor
networks, except the output is of size 128 instead of |A|. We scale the squared error by βrnd ∈
{0.001, 0.01, 0.1, 1, 10, 100}:
For DQN + DORA we use the same architecture for the E-network as the DQN. We add a sigmoid
non-linearity to the output and initialise the final layer’s weights and bias to 0 as described in (Choshen
et al., 2018). We sweep across the scale of the intrinsic reward βdora ∈ {}. For DQN + DORA OA
We use Bdora = and sweep across βdora_action ∈ {}.
For BSP we use the following architecture:
Shared conv layers:
(State input: (24,24,1))
→ (Conv Layer, 3x3 Filter, 16 Channels, Stride 2) → ReLU
→ (Conv Layer, 3x3 Filter, 16 Channels, Stride 2) → ReLU
→ Flatten
Q-value Heads:
→ (FC Layer, 400 Units) → ReLU
→ (FC Layer, 200 Units)
→ A = 4 outputs.
We use K = 10 different bootstrapped DQN heads, and sweep over βbsp ∈ {0.1, 1, 3, 10, 30, 100}.
For all methods we run 8 independent runs across the cross-product of all relevant parameters
considered. We then sort them by the median episodic reward (largest area underneath the line) and
report the median, lower and upper quartiles.
The best hyperparameters we found were:
DQN -greedy: Decay rate: 100k timesteps.
DQN + PC: β = 0.1.
Optimistic Initialisation Bias: Bias: 1.
Reward Subtraction: Constant to subtract: 0.1.
DQN + RND: βrnd = 10.
17
Published as a conference paper at ICLR 2020
DQN + DORA: βdora = 0.01.
DQN + DORA OA: βdora = 0.01 and Bdogaction = 0∙1.
BSP: βbsp = 100.
OPIQ: M: 2, Caction: 100, Cbootstrap: 0.01.
OPIQ without Optimistic Bootstrapping: M: 2, Caction: 100.
OPIQ without Pseudocounts: M: 2, Caction: 100, Cbootstrap: 0.1.
D.2.3 Montezuma’ s Revenge
The network used is the standard DQN used for Atari (Mnih et al., 2015; Bellemare et al., 2016).
We use 3 step Q-Learning.
Training lasts for 12.5mil timesteps (50mil frames in Atari). is decayed linearly from 1 to 0.01 over
1mil timesteps. We train on a batch of 32 after every 4th timestep with a replay buffer of size 1mil.
The target network is updated every 8000 timesteps.
For all methods we consider βmmc ∈ {0.005, 0.01, 0.025}.
For DQN + PC we consider β ∈ {0.01, 0.1, 1}.
For OPIQ and its ablations we set M = 2. We consider: Caction ∈ {0.1, 1}, Cbootstrap ∈ {0.01, 0.1},
β ∈ {0.01, 0.1}.
For the RND bonus we use the same architectures as in (Burda et al., 2018) (target network is smaller
than the learned predictor network) except we use ReLU non-linearity. The output is the same of size
512. We scale the squared error by βrnd ∈ {0.001, 0.01, 0.1, 1}:
For BSP we use the same architecture as in (Osband et al., 2018).
We use K = 10 different bootstrapped DQN heads, and sweep over βbsp ∈ {0.1, 1, 10, 100}.
For all methods we run 4 independent runs across the cross-product of all relevant parameters
considered. We then sort them by the median maximum episodic reward (largest area underneath the
line) and report the median, lower and upper quartiles.
The best hyperparameters we found were:
DQN +PC: β = 0.01, βmmc = 0.01.
DQN + RND: βrnd = 0.1, βmmc = 0.01.
BSP: βbsp = 0.1, βmmc = 0.025.
OPIQ: M= 2, Caction = 0.1, Cbootstrap = 0.01, βmmc = 0.01.
OPIQ without Optimistic Bootstrapping: M= 2, Caction = 0.1, βmmc = 0.005.
D.3 Baselines training details
DQN + RND: We do a single gradient descent step on a minibatch of the 32 most recently visited
states. We also recompute the intrinsic rewards when sampling minibatches to train the DQN. The
intrinsic reward used for a state s, is the squared error between the predictor network and the target
network βrnd ||predictor(s) - target(s)||22.
DQN + DORA: We train the E-values network using n-step SARSA (same n as the DQN) with
YE = 0.99. We maintain a replay buffer of size (batch size * 4) and sample batch size elements to
train every timestep. The intrinsic reward We use is / Bdora =.
J	F	√-log E(s,a)
DQN + DORA OA: We train the DQN + DORA agent described above and additionally augment
the Q-values used for action selection with 氏。…"』.
√-log E(s,a)
18
Published as a conference paper at ICLR 2020
BSP: We train each Bootstrapped DQN head on all of the data from the replay buffer (as is done in
(Osband et al., 2016; 2018). We normalise the gradients of the shared part of the network by 1/K,
where K is the number of heads. The output of each head is Qk + βbsp pk, where pk is a randomly
initialised network (of the same architecture as Qk) which is kept fixed throughout training. βbsp is a
hyperparameter governing the scale of the prior regularisation.
D.4 Mixed Monte Carlo Return
For our experiments on Montezuma’s Revenge we additionally mixed the 3 step Q-Learning target
with the environmental rewards monte carlo return for the episode.
That is, the 3 step targets yt become:
∞
ymmc := (1 - βmmc)yt + βmmc(	γ r(st+i, at+i))
i=0
If the episode hasn’t finished yet, we used 0 for the monte carlo return.
Our implementation differs from (Bellemare et al., 2016; Ostrovski et al., 2017) in that we do
not use the intrinsic rewards as part of the monte carlo return. This is because we recompute the
intrinsic rewards whenever we are using them as part of the targets for training, and recomputing
all the intrinsic rewards for an entire episode (which can be over 1000 timesteps) is computationally
prohibitive.
E Further Results
E.1 Randomised Chain
- DQN ε-greedy [20]
-DQN Bias + PC [20]
-DQN + PC [20]
OPIQ [20]
DQN R-Subtract [20]
Figure 12: The number of distinct states visited over training for the chain environment. The median
across 20 seeds is plotted and the 25%-75% quartile is shown shaded.
IOk 20k 30k 40k 50k 60k 70k 80k 90k 100k
T
—OPIQ w∕o PC [20]
—OPIQ w/o OB [20]
—OPIQ [20]
-OPIQ M=0.1 [20]
-OPlQ M=0.5 [20]
-OPIQ M=10.0 [20]
OPIQ M=2,0 [20]

Figure 13: Comparing the performance of M ∈ {0.1, 0.5, 2, 10} on the chain environment. The best
hyperparameter combination for the differing values of M is shown. The median across 20 seeds is
plotted and the 25%-75% quartile is shown shaded.
We can see that OPIQ and ablations explore the environment much more quickly than the count-based
baselines. The ablation without optimistic bootstrapping exhibits significantly more variance than the
other ablations, showing the importance of optimism during bootstrapping. On this simple task the
ablation without count-based intrinsic motivation performs on par with the full OPIQ. This is most
19
Published as a conference paper at ICLR 2020
likely due to the simpler nature of the environment that makes propagating rewards much easier than
the Maze. The importance of directed exploration is made abundantly clear by the -greedy baseline
that fails to explore much of the environment.
Figure 13 compares OPIQ with differing values of M. We can clearly see that a small value of 0.1
results in insufficient exploration, due to the over-exploration of already visited state-action pairs.
Additionally if M is too large then the rate of exploration suffers due to the decreased optimism. On
this task we found that M = 0.5 performed best, but on the harder Maze environment we found that
M = 2 was better in preliminary experiments.
E.2 MAZE
Figure 14: The Q+-values OPIQ used during bootstrapping with Cbootstrap = 0.01.
Figure 14	shows the values used during bootstrapping for OPIQ. These Q-values show optimism near
the novel state-action pairs which provides an incentive for the agent to return to this area of the state
space.
E.3 Montezuma’ s Revenge
P-EΛΛωα əpos-d山 xe∣λ∣ up-pəiai
6000
5000
4000
3000
2000
1000
OPIQ
OPIQ w∕o OB
OPIQ
OPIQ w∕o OB
Figure 15: Results for Montezuma’s Revenge comparing OPIQ and ablation. Median
is plotted and the 25%-75% quartile is shown shaded.
across 4 seeds
20
Published as a conference paper at ICLR 2020
Figure 16:(x+11)M for various values of M, and the indicator function l{x < 1} shown in black.
Higher values of M provide a better approximation at integer values of x (shown as crosses).
Figure 15	shows further results on Montezuma’s Revenge comparing OPIQ and its ablation without
optimistic bootstraping (OPIQ w/o OB). Similarly to the Chain and Maze results, we can see that
OPIQ w/o OB performs similarly to the full OPIQ but has a higher variance across seeds.
F	Motivations
Figure 16	compares various values of M with the indicator function l{x < 1}.
G	Necessity for Optimism During Action Selection
To emphasise the necessity of optimistic Q-value estimates during exploration, we analyse the simple
failure case for pessimistically initialised greedy Q-learning provided in the introduction. We use
Algorithm 1, but use Q instead of Q+ for action selection. We will assume the agent will act greedily
with respect to its Q-value estimates and break ties uniformly:
at J UnifOrm{argmaxQt(St, a)}.
a
Consider the single state MDP in Figure 17 with H = 1. We use this MDP to show that with 0.5
probability pessimistically initialised greedy Q-learning never finds the optimal policy.
Figure 17:	A simple failure case for pessimistically initialised greedy Q-learning. There is 1 state
with 2 actions and H = 1. The agent receives 0.1 reward for the left action and 1 for the right action.
The agent receives a reward of +1 for selecting the right action and 0.1 otherwise. Therefore the
optimal policy is to select the right action. Now consider the first episode: ∀a, Q1 (S, a) = 0. Thus,
the agent selects an action at random with uniform probability. If it selects the left action, it updates:
Q1(S,L) = η1( |0{.z1} +	|r{iznt}	+ |{bz} ) > 0.
MDP reward Intrinsic Reward Bootstrap
Thus, in the second episode it selects the left action again, since Q1 (S, L) > 0 = Q1 (S, R). Our
estimate of Q1 (S, L) never drops below 0.1, and so the right action is never taken. Thus, with
probability of ɪ it never selects the correct action (also a linear regret of 0.9T).
This counterexample applies for any non-negative intrinsic motivation (including no intrinsic motiva-
tion), and is unaffected if we utilise optimistic bootstrapping or not.
H	Necessity for Intrinsic Motivation Bonus
Despite introducing an extra optimism term with a tunable hyperparameter M, OPIQ still requires
the intrinsic motivation term biT to ensure it does not under-explore in stochastic environments.
21
Published as a conference paper at ICLR 2020
We will prove that OPIQ without the intrinsic motivation term biT does not satisfy Theorem 1.
Specifically we will show that there exists a 1 state, 2 action MDP with stochastic reward function
such that for all M > 0 the probability of incurring linear regret is greater than the allowed failure
probability p. We choose to use stochastic rewards as opposed to stochastic transitions for a simpler
proof.
Figure 18: The parametrised MDP.
The MDP we will use is shown in Figure 18, where λ > 1 and a ∈ (0, 1) s.tp < 1 - a. H = 1, S = 1
and A = 2. The reward function for the left action is stochastic, and will return +1 reward with
probability a and 0 otherwise. The reward for the right action is always a∕λ.
Let p > 0, the probability with which we are allowed to incur a total regret not bounded by the
theorem. OPIQ cannot depend on the value of λ or a as they are unknown.
Pick λ s.tM >
iog( λ)
ι°g⅛g⅛ρy
OPIQ will recover the sub-optimal policy of taking the right action if every time we take the left
action we receive a 0 reward. This will happen since our Q+-value estimate for the left action will
eventually drop below the Q-value estimate for the right action which is a∕λ > 0. The sup-optimal
policy will incur a linear regret, which is not bounded by the theorem.
Our probability of failure is at least (1 - a)R, where R is the number of times we select the left
action, which decreases as R increases. This corresponds to receiving a 0 reward for every one of the
R left transitions we take. Note that (1 - a)R is an underestimate of the probability of failure.
For the first 2 episodes we will select both actions, and with probability (1 - a) the left action will
return 0 reward. Our Q-values will then be: Q1 (s, L) = 0, Q1 (s, R) = a∕λ.
It is possible to take the left action as long as
1a
(R + 1)M ≥ λ,
since the optimistic bonus for the right action decays to 0.
This then provides a very loose upper bound for R as (a )1/M, which then leads to a further underes-
timation of the probability of failure.
Assume for a contradiction that (1 - a)R < p:
(1 - a)R < P ^⇒ (1 - a)O/a)1/M < P
^⇒ (λ∕a)'1M log(1 - a) < log(p)
^⇒ (X/a)1/M > log(p)/log(1 - a)
^⇒ (1∕M)log(λ∕a) > log(log(p)/log(1 - a))
^⇒ M < log(λ∕a)/log(log(p)/log(1 - a))
(6)
This provides our contradiction as we choose λ s.t M > log(λ∕a)/log(log(p)/log(1 - a)). We can
always pick such a λ because log(λ∕a) can get arbitrarily close to 0.
So our probability of failure (of which (1 - a)R is a severe underestimate) is greater than the allowed
probability of failure P.
22
Published as a conference paper at ICLR 2020
I Proof of Theorem 1
Theorem 1.	For any p ∈ (0, 1) , with probability at least 1 - p the total regret of Q+ is at most
O(PH4SAT log(SAT∕p)) for M ≥ 1 andatmost O(H 1+MSATI-M+pH4SAT log(SAT∕p))
for 0 < M < 1.
OPIQ is heavily based on UCB-H (Jin et al., 2018), and as such the proof very closely mirrors its
proof except for a few minor differences. For completeness, we reproduce the entirety of the proof
with the minor adjustments required for our scheme.
The proof is concerned with bounding the regret of the algorithm after K episodes. The algorithm
we follow takes as input the value of K, and changes the magnitudes of bTN based on it.
We will make use of a corollary to Azuma’s inequality multiple times during the proof.
Theorem 2.	(Azuma’s Inequality). Let Z0, ..., Zn be a martingale sequence of random variables
such that ∀i∃ci : |Zi - Zi-1 | < ci almost surely, then:
P(Zn-Z0 ≥t) ≤exp
Corollary 1. Let Z0, ..., Zn be a martingale sequence of random variables such that ∀i∃ci : |Zi -
Zi-1 | < ci almost surely, then with probability at least 1 - δ:
-t2
2ρn=τ^F
|Zn - Z0 |
≤
∖
n2
2(X c2)log δ
i=1	δ
Lemma 1. (Jin et al., 2018)
Define ηN0 = QjN=1(1 - ηj), ηNi = ηi QjN=i+1(1 - ηj)
The following properties hold for ηNi :
•	√1n ≤ PN ηN ≤ √N, ∀n ≥1
•	maxi=ι,...,NnN ≤ 2H,PN=ι(ηN)2 ≤ 2H,∀N ≥ 1
•	PN = nN = 1 + H, ∀i ≥ 1
Lemma 2. Adapted slightly from (Jin et al., 2018)
Define Vtk (s) := min{H, maxa0 Qt+,k (s, a0)}, ∀s ∈ S.
For notational convenience, we also define [Ptk Vt+1](stk, atk) := Vt+1 (stk+1), where stk was the state
encountered at episode k at timestep t (similarly for atk),
and [PVt+ι](s,a) := Es，〜Pt(∙∣st=s,at=a) [Vt+ι(s0)]∙
For any (s, a, t) ∈ S × A × [H], episode k ≤ K and N = N(s, a, t). Suppose (s, a) was previously
taken at step t of episodes k1, ..., kN < k. Then:
(Q+,k - Qji)Ga) = -nNQt(s,a)
NH
+	nNi [(Vtk+i1 - Vti+1 )(stk+i 1) + (Pt - Pk )¼+ι(s, a) + bT ]+ (N + I)M
Proof. We have the following recursive formula for Q+ at episode k and timestep t:
N
Qt+,k(s,a)=XnNi [rt(s, a) + Vtk+i1(stk+i 1) + biT] +
i=1
H
(N +1)m
(7)
We can produce a similar formula for Qi :
Qti(s, a) = (rt + Pt(s, a)Vti+1)(s,a)
23
Published as a conference paper at ICLR 2020
From the Bellman Optimality Equation
N
=nN QJiGa) + X nN [rt(s,a) + PtVt+1 Ga)]
i=1
Since PiN=1 nNi = 1 and nN0 = 0 for N ≥ 1 and PiN=1 nNi = 0 and nN0 = 1 for N = 0
N
= nN0 Qti(s,a) + XnNi [rt(s,a) + (Pt - Ptki)Vti+1(s,a) +PtkiVti+1(s,a)]
i=1
±Ptki Vti+1 (s, a) inside the summation.
N
= nN0 Qti(s,a) +XnNi [rt(s,a) + (Pt - Ptki)Vti+1(s,a) +Vti+1(stk+i 1)]	(8)
i=1
By definition of Ptk
Subtracting equation 7 from equation 8 gives the required result.
□
Lemma 3. Adapted slightly from (Jin et al., 2018)
Bounding Q+ - Qi
There exists an absolute constant c > 0 such that, for any δ ∈
(0,1) ,letting bNN = 2 J H3log(NATZl),
2 PN=I nNbτ ≤ 8qH3OoINNAT/) and, With probability at least 1 — δ, the
we have that βNT
following holds simultaneously for all (s, a, t, k) ∈ S × A × [H] × [K]:
NH
0 ≤ (Q+'k — Qi)(s, a) ≤ ∑nN[(¼+ι —匕+ι)(sk+1)]+ βN + (N +1)M
where N = N(s, a, t) and k1, ..., kN < k are the episodes where (s, a) was taken at step t.
Proof. For each fixed (s, a, t) ∈ S × A × [H], let k0 = 0 and
ki = min({k ∈ [K]|k > ki-1,(stk,atk) = (s,a)}∪{K+1})
ki is then the episode at which (s, a) was taken at step t for the ith time, or ki = K + 1 if it has been
taken fewer than i times.
Then the random variable ki is a stopping time. Let Fi be the σ-field generated by all the random
variables until episode ki step t.
Let τ ∈ [K].
Let Xi := nTl[ki ≤ K][(Pki 一Pt)Vt+ι](s, a)). Then Zi = Pj=I Xi is also a martingale sequence
with respect to the filtration (l[ki ≤ K][(Pki — Pt)Vt+ι](s, a))T=ι, Zo = 0, Zn — Zo = PZi Xi
and Zi — Zi-1 = Xi. We also have that |Xi| ≤ nτi H.
Then by Azuma,s Inequality we have that with probability at least 1 — 2δ/(SAHK)
τ
I XnTl[⅛i ≤ K] [(Ptki - Pt)匕+ι](s,a)∣≤
i=1
τ	SAT
2(∑(nT H )2)iog -7-
i=1 τ	δ
∖
Ht
2(Xτ (nτi)2)log
i=1
-A-
δ
24
Published as a conference paper at ICLR 2020
Then by a Union bound over all T ∈ [K], We have that with probability at least 1 - 2δ∕(SAH):
∀τ ∈ [K] | XXηTl[ki ≤ K][(Pki - Pt)Vt+ι](s, a)| ≤ H
i=1
2(XX (ητ )2)iog SAT
i=1
≤2
H3 log SAT∕δ
τ
(9)
∖

Since From Lemma 1 we have that PT=ι(ηN)2 ≤ 2H
Since inequality equation 9 holds for all fixed τ ∈ [K] uniformly, it also holds for a random variable
ττ = N = Nk(s, a,t) ≤ K. Also note that l[ki ≤ K] = 1 for all i ≤ N.
We can then additionally apply a union bound over all s ∈ S, a ∈ A, t ∈ [H] to give:
IXXnN[(Ptki - Pt)Vt+ι](s,a)l≤ 2《H3logSAτ∕δ = bN	(10)
i=1
which holds with probability 1 - 2δ for all (s, a, t, k) ∈ S × A × [H] × [K]. We then rescale δ to
δ∕2.
By Lemma 1 we have that bN = 2，H3 log (SAT∕δ)∕N ≤ βN/2 = PN=I nNbf ≤
4，H3 log(SAT∕δ)∕N = 2bN.
From Lemma 2 we have that:
(Q+,k - Qt)(s,a) = -nNQ；(S,a)
N
+ X nNi [(Vtk+i1 - Vt；+1 )(stk+i 1)+(Pt - Ptki)Vt；+1(s, a) + biT] +
i=1
H
(N +1)M
N
-nN0 Qt；(s, a) + XnNi [(Vtk+i1 - Vt；+1)(stk+i 1)]
i=1
NN
+ XnNi [(Pt - Ptki)Vt；+1(s, a)] + XnNi [biT]+
i=1	i=1
H
(N +1)M
rearranging terms
NH
≤	nNi [(Vtk+i1 - Vt；+1)(
stk+i 1)]+ bN + βN ∕2+ (N +1)m
From Eqn equation 10, defn on βNT and non-negativity of Q；
NH
≤ X nNi [(Vtk+i1 - Vt；+1 )(stk+i 1)]+ βN + (N +1)M
Since bTN ≤ βNT ∕2
which gives the R.H.S.
Eqn equation 10 tells us that PiN=1 nNi [(Pt - Ptki)Vt；+1](s, a) ≥ -bTN, along with bTN ≤ βNT ∕2
PiN=1 nNi biT which then gives:
(Qt+,k - Qt； )(s, a) = -nN0 Qt； (s, a)
NH
+ X nN [(Vt+i1 - Vt+1 )(
stk+i 1)+ (Pt - Pki)Vt+ι(s, a) + bT] + (N + i)m
i=1
NH
≥ -nNQ；(s, a) + XniN[(Vt+ι -匕+1)(sk+1)]+ (N + 1)M
25
Published as a conference paper at ICLR 2020
We can then prove the L.H.S. by induction on t = H,…,1. For t = H(Q+,k - Q↑) ≥ 0. This is
because V^i+i = VH +1 = 0, for N = 0(。二)M = H > QH, and for N > 0 We have that nN = 0.
If we assume the statement true for t + 1, consider t:
NH
(Q+,k - Ql)(s, a) ≥ -nNQ：(s, a) + XnN[(Vt^ - Vt+ι)(sk++1)] + (N + I)M
N
=-nNQJiGa) + XnN[min{H,maxQ++1i(sk+ ι,a0)} - maχQ+i(Sk+ι,a0O)]
i=1	a	a
ι H
+ (N + 1)M
H
≥ -nNQt (S, a) + (N + ι)M
If min{H, maxa0 Qt++,kii (Stk+i i, a0)} = maxa0 Qt++,kii (Stk+i i, a0), by our inductive assumption since
(Qt++,ki - Qti+i)(S, a) ≥0 =⇒ maxa0 Qt++,kii (S, a0) ≥ maxa00 Qti+i(S,a00)
If min{H, maxa0 Qt++,kii (Stk+i i,a0)} = H, We have that maxa00 Qti+i(Stk+i i, a00) ≤ H.
This then proves the L.H.S.
□
Note on stochastic rewards: We have assumed so far that the reward function is deterministic for a
simpler presentation of the proof. If we allowed for a stochastic reward function, the previous lemmas
can be easily adapted to allow for it.
Lemma 2 would give us:
N
(Q + ,k - Qt)(s,a) = -nN Qt(s,a) + X nN [(rki - Er0 〜Rt(∙∣s,a)[r0])
i=i
H
+ (Vtk+1 -匕+1)(sk+1) + (Pt- Ptki )V+l(s, a) + bT ]+ (N +1)M
(rki — Em〜Rt(∙∣s,a) [r0]) can then be bounded in the same way as in Lemma 3. Increasing the constants
for bTN, βNT and rescaling of δ appropriately then completes the necessary changes.
We will now prove that our algorithm is provably efficient. We will do this by showing it has sub-linear
regret, following closely the proof of Theorem 1 from (Jin et al., 2018).
Theorem 1. For any p ∈ (0, 1) , with probability at least 1 - p the total regret of Q+ is at most
O(PH4SATlog(SAT∕p))forM ≥ 1 andatmostO(H 1+MSATI-M+,H4SATlog(SAT∕p))
for 0 < M < 1.
Proof. Let
δk ：= (Vk - Vnk )(sk ),Φk ：= (Vk - Vn(Sk)
Lemma 3 tells us With probability at least 1 - δ that Qt+,k ≥ Qti , Which also implies that Vtk ≥ Vti .
We can then upperbound the regret as folloWs:
KKK
Regret(K) =X(Vii-Viπk)(Sik) ≤ X(Vik - Viπk)(Sik) = X δik
k=i	k=i	k=i
We then aim to bound PkK=i δtk by the next timestep PkK=i δtk+i, Which Will give us a recursive
formula to upperbound the regret. We Will accomplish this by relating PkK=i δtk to PkK=i φtk.
26
Published as a conference paper at ICLR 2020
For any fixed (k, t) ∈ [K] × [H], let Nk = N(stk, atk, t) where (stk, atk) was previously taken at step
t of episodes k1, ..., kN < k. We then have:
δtk=(Vtk-Vtπk)(stk)≤(Qt+,k-Qtπk)(stk,atk)
=(Q+,k - Qt)(sk,ak) + (Qt- Qnk)(sk,ak)
Nk
≤	ηNik[(Vtk+i1 -Vtt+1)(stk+i1)]
i=1
H
+ βNk + (Nk+ 1)M + [Pt(V+ι - V+ι)](sk,ak)
By Lemma 3 for the first term. Bounding (Qtt - Qtπk) is acheived through the Bellman Equation
giving the final term.
Nk	H
=X ηiNk Φk+l + βNk + (Nk + 1)M + [Pt(V+l - V+l)](sk, a)
+[Ptk(Vtt+1-Vtπ+k1)](stk,atk)-[Ptk(Vtt+1-Vtπ+k1)](stk,atk)
±[Ptk(Vtt+1 - Vtπ+k1)](stk,atk) and subbing for φ
Nk	H
=XnNkφk+ι + βNk + (N+ 1)M + [(Pt - Pk)(Vt+ι - V+ι)](sk, ak)
+ (Vtt+1 - Vtπ+k1)(stk+1)
Since[Ptk(Vtt+1-Vtπ+k1)](stk,atk)=(Vtt+1-Vtπ+k1)(stk+1)
Nk	H
=∑nN-k φk+ι + βNk + (Nfe+ 1)M + ξk+1 + δk+1 - Φk+1	(11)
Letting ξtk+1 := [(Pt-Ptk)(Vtt+1-Vtπ+k1)](stk,atk).(Vtt+1-Vtπ+k1)(stk+1)=δtk+1-φtk+1.
We must now bound the summation PkK=1 δtk, which we will do by considering each term of
equation 11 separately.
H
1 (Nk + 1)m :
K
X
k=1
H
(Nk + 1)m
K
≥X
k=1
H
(K + 1)m
HK
(K + 1)m
K
X
k=1
H
(Nk + 1)m
∈ Ω(HKI-M)
The first inequality follows since N ≤ K . This shows that we require M > 0 in order to guarantee a
sublinear regret in K.
K	K∞
X (⅛ = XX MNk= n}
k=1	k=1 n=0
H	∞K	H
(n+iM = n=0 2 1{Nk = n} (n+ιM
∞ H	K1
≤ SA V--- = SAHT F
— 乙(n + 1)m	乙 nM
n=0	n=1
The first equality follows by rewriting (Nfe：]严 as P∞=0 l{Nk = n}(九：严.Only one of the
indicator functions will be true for episode k, giving us the required value. The inequality is a crude
upper bound that suffices for the proof. For a given n, l{Nk = n} can only be true for at most SA
times across all of training. They will contribute ⑺二产 to the final sum.
For M > 1, the sum PK=I nɪ is bounded, which means that PK=I (Nfe：]严 ∈ O(SAH)
27
Published as a conference paper at ICLR 2020
For M = 1, PK=I nM ≤ log(K +1) =⇒ PK=I WHlyM ∈ O(SAHlOg(K))
For 0 < M < 1, PK=I (NkHI)M ∈ O(SAHK 1-m), since PK=I nM 〜K-M (Goel and
Rodriguez, 1987)
PkK=1 PiN=k1 ηNi kφtk+i1:
K Nk	K	∞	K
XXnNkφt+1 ≤ X Φk;1 X ηNk0 ≤ (1 + H)XΦk+1
k=1 i=1	k0 =1	i=Nk0 +1	k=1
The first inequality is achieved by rearranging how we take the sum.
Consider a k0 ∈ [K]. The term φtk+0 1 will appear in the summation for k > k0 provided that
(stk , atk) = (stk0 , atk0 ), e.g. we took the same state-action pair at episodes k and k0.
On the first occasion, the associated learning rate will be ηNNk00+1, on the second ηNNk00+2.
We can then consider all possible counts up to ∞ to achieve an inequality. By considering all k0 ∈ [K]
we will not miss any terms of the original summation.
The second inequality follows by application of Lemma 1 on the sum involving the learning rate.
PkK=1 βNk :
For all t ∈ [H], we have that:
KK
XβNk≤X8
H3 log(SAT∕δ)
Nk (s,a,t)
XX2
s,a n=1
H3 log(SAT∕δ)
n
Nk(S,a,t)= SKA	Γ
≤X	X	2
s,a	n=1
H3 log(SAT /δ)
n
K
SA 1
≤ X 2PH3 log(SAT∕δ) X √
s,a
n=1
rsA
≤ 4SA√H3 log(SAT∕δ)
∈ O(√H3SAKlog(SAT∕δ))
=O(PH 2 S AT log(SAT∕δ))
We transform the sum over the episode’s counts Nk into a sum over all state-action pairs, summing
over all of their respective counts.
The first inequality is due to Nk = K/SA maximising the quantity, this is since 1 /√n grows smaller
asn increases. Thus, we want to spread out the summation across the state-action space as much as
possible.
Then We use the result that Pn=I 1∕λ∕i ≤ 2√n, and that We are taking the sum over SA identical
terms. We then setn = K/SA and are thus taking the sum over Nk (s, a, t) identical terms.
PH PK ξk
t=1	k=1 ξt+1
FolloWing a similar argument as from Lemma 3, We can apply Azuma’s inequality and a union bound
over all (s,a,t) ∈ S X A X [H ].Let Xi = [(Pt - Pt )(V^^ι - VnkI)](sf,ak). Then Zi := Pj=I Xj
is a martingale difference sequence, and We have that |Zi - Zi-1 | = |Xi| ≤ H, and Z0 = 0. Then
With probability at least 1 - 2δ We have that:
H K	K
I XX ξt+ιl ≤ HI X ξt+ι I ≤ H P2KH2 log(SAT∕δ) ∈ O(H3/2 PT log(SAT∕δ))
t=1 k=1	k=1
28
Published as a conference paper at ICLR 2020
Finally, we can utilise these intermediate results when bounding the regret via Equation equation 11:
K
Xδtk
k=1
Nk	H
≤ X ηNk φt+1 + βNk + (Nk + 1)M + ξt+1 + δt+1
—
1
KKKK	K
≤ (1 + H) X Φk+1-X Φk+1 + X δk+ι + X(βNk+ξk+ι) + X
k=1	k=1	k=1	k=1	k=1
H
(Nk + 1)M
From our intermediate result on φ
KK
≤ (1 + H) X δk+ι+ X(βNk+ ξk+ι+
k=1	k=1
H
(Nk + 1)M
)
Since V* ≥ Vπk =⇒ δ^ ≥ φk+ι
Letting At ：= PK=ι(βN工 + ξk+ι + (NkHI)M), We have that Pk=I δ% ≤ Ah since δ*ι = 0. By
induction on t = H,...,1 We then have that PK=I δk ≤ PH=0t(1 + HojAH-j =⇒ PK=I δk ∈
O(PH=1 P"(βNk + ξk+ι + w⅛)) since (1 + 1/H)H ≤ e.
Using our intermediate results for the relevant quantities then gives us With probability at least 1 - 2δ:
K	H K
Xδk ∈ O(P(H4SATlog(SAT∕δ)) + H3/2PTlog(SAT∕δ)) + O(XX
k=1	t=1 k=1
H
(Nk + 1)m
)
,___________________ H K H
O(P(H 4SAT Iog(SAT∕δ))) + O(X X (N + 1)M )
We then consider the 3 cases of M :
For M > 1 we get O(P(H4SAT log(SAT∕δ)) + H2SA).
For M = 1 we get O(P(H4SATlog(SAT∕δ)) + H2SA log(K)).
And for 0 <M < 1 we have O(P(H4SATlog(SAT∕δ)) + H1+MSATI-M).
T ≥ PH4SATlog(SAT∕δ) =⇒ PH4SAT log(SAT∕δ) ≥ H2SA log(K), which means we
can remove the H2SA log(K) or H2SA from the upperbound. If T ≤ PH4SAT log(SAT∕δ)
then that is also a sufficient upper bound since the regret cannot be more than HK = T.
This gives us the required result after rescaling δ to δ∕2.
□
29