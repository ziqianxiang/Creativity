Published as a conference paper at ICLR 2020
Robustness Verification for Transformers
Zhouxing Shi1, Huan Zhang2, Kai-Wei Chang2, Minlie Huang1, Cho-Jui Hsieh2
1Dept. of Computer Science & Technology, Tsinghua University, Beijing 10084, China
2Dept. of Computer Science, University of California, Los Angeles, CA 90095, USA
zhouxingshichn@gmail.com, huan@huan-zhang.com
kw@kwchang.net, aihuang@tsinghua.edu.cn, chohsieh@cs.ucla.edu
Ab stract
Robustness verification that aims to formally certify the prediction behavior of
neural networks has become an important tool for understanding model behav-
ior and obtaining safety guarantees. However, previous methods can usually only
handle neural networks with relatively simple architectures. In this paper, we
consider the robustness verification problem for Transformers. Transformers have
complex self-attention layers that pose many challenges for verification, including
cross-nonlinearity and cross-position dependency, which have not been discussed
in previous works. We resolve these challenges and develop the first robustness
verification algorithm for Transformers. The certified robustness bounds com-
puted by our method are significantly tighter than those by naive Interval Bound
Propagation. These bounds also shed light on interpreting Transformers as they
consistently reflect the importance of different words in sentiment analysis.
1	Introduction
Deep neural networks have been successfully applied to many domains. However, these black-
box models are generally difficult to analyze and their behavior is not guaranteed. Moreover, it
has been shown that the predictions of deep networks become unreliable and unstable when tested
in unseen situations, e.g., in the presence of small adversarial perturbations to the input (Szegedy
et al., 2013; Goodfellow et al., 2014; Lin et al., 2019). Therefore, neural network verification has
become an important tool for analyzing and understanding the behavior of neural networks, with
applications in safety-critical applications (Katz et al., 2017; Julian et al., 2019; Lin et al., 2019),
model explanation (Shih et al., 2018) and robustness analysis (Tjeng et al., 2019; Wang et al., 2018c;
Gehr et al., 2018; Wong & Kolter, 2018; Singh et al., 2018; Weng et al., 2018; Zhang et al., 2018).
Formally, a neural network verification algorithm aims to provably characterize the prediction of a
network within some input space. For example, given a K-way classification model f : Rd → RK,
where fi(x) stands for the predicted score of class i, we can verify some linear specification (defined
by a vector c) as below:
min	cifi(x)	s.t. x ∈ S,	(1)
x
i
where S is a predefined input space. In the robustness verification problem, S = {x | kx - x0 kp ≤
} is defined as some small `p-ball around the original example x0, and setting up c = 1y0 - 1y
enables us to verify whether the logit output of class y0 is always greater than another class y for
any input within S. This is a nonconvex optimization problem which makes computing the exact
solution challenging, and thus several algorithms are recently proposed to find the lower bounds of
Eq. (1) in order to efficiently obtain a safety guarantee (Gehr et al., 2018; Weng et al., 2018; Zhang
et al., 2018; Singh et al., 2019). Moreover, extensions of these algorithms can be used for verifying
properties beyond robustness, such as rotation or shift invariant (Singh et al., 2019), conservation of
energy (Qin et al., 2019) and model correctness (Yang & Rinard, 2019).
However, most of existing verification methods focus on relatively simple neural network architec-
tures, such as feed-forward and recurrent neural networks, while they cannot handle complex struc-
tures. In this paper, we develop the first robustness verification algorithm for Transformers (Vaswani
et al., 2017) with self-attention layers. Transformers have been widely used in natural language pro-
cessing (Devlin et al., 2019; Yang et al., 2019; Liu et al., 2019) and many other domains (Parmar
1
Published as a conference paper at ICLR 2020
et al., 2018; Kang & McAuley, 2018; Li et al., 2019b; Su et al., 2019; Li et al., 2019a). For frames
under perturbation in the input sequence, we aim to compute a lower bound such that when these
frames are perturbed within `p -balls centered at the original frames respectively and with a radius of
, the model prediction is certified to be unchanged. To compute such bounds efficiently, we adopt
the linear-relaxation framework (Weng et al., 2018; Zhang et al., 2018) - We recursively propagate
and compute linear lower and upper bounds for each neuron w.r.t the input within the perturbation
space S.
We resolve several particular challenges in verifying Transformers. First, Transformers with self-
attention layers have a complicated architecture. Unlike simpler networks, they cannot be written
as multiple layers of affine transformations or element-wise activation functions. Therefore, we
need to propagate linear bounds differently for self-attention layers. Second, dot products, softmax,
and weighted summation in self-attention layers involve multiplication or division of two variables
both under perturbation, namely cross-nonlinearity, which is not present in feed-forward networks.
Ko et al. (2019) proposed a gradient descent based approach to find linear bounds, however it is
inefficient and poses a computational challenge for Transformer verification since self-attention is
the core of Transformers. In contrast, we derive closed-form linear bounds that can be computed
in O(1) complexity. Third, in the computation of self-attention, output neurons in each position
depend on all input neurons from different positions (namely cross-position dependency), unlike
the case in recurrent neural networks where outputs depend on only the hidden features from the
previous position and the current input. Previous works (Zhang et al., 2018; Weng et al., 2018; Ko
et al., 2019) have to track all such dependency and thus is costly in time and memory. To tackle this,
we introduce an efficient bound propagating process in a forward manner specially for self-attention
layers, enabling the tighter backward bounding process for other layers to utilize bounds computed
by the forward process. In this way, we avoid cross-position dependency in the backward process
which is relatively slower but produces tighter bounds. Combined with the forward process, the
complexity of the backward process is reduced by O(n) for input length n, while the computed
bounds remain comparably tight. Our contributions are summarized below:
•	We propose an effective and efficient algorithm for verifying the robustness of Transformers
with self-attention layers. To our best knowledge, this is the first method for verifying
Transformers.
•	We resolve key challenges in verifying Transformers, including cross-nonlinearity and
cross-position dependency. Our bounds are significantly tighter than those by adapting
Interval Bound Propagation (IBP) (Mirman et al., 2018; Gowal et al., 2018).
•	We quantitatively and qualitatively show that the certified bounds computed by our al-
gorithm consistently reflect the importance of input words in sentiment analysis, which
justifies that these bounds are meaningful in practice and they shed light on interpreting
Transformers.
2	Related Work
Robustness Verification for Neural Networks. Given an input x0 and a small region
Bp(x0, ) := {x | kx - x0kp ≤ }, the goal of robustness verification is to verify whether the
prediction of the neural network is unchanged within this region. This problem can be mathemat-
ically formulated as Eq. (1). If Eq. (1) can be solved optimally, then we can derive the minimum
adversarial perturbation of x by conducting binary search on . Equivalently, we obtain the maxi-
mum such that any perturbation within Bp(x0, ) cannot change the predicted label.
Several works focus on solving Eq. (1) exactly and optimally, using mixed integer linear program-
ming (MILP) (Tjeng et al., 2019; Dutta et al., 2018), branch and bound (BaB) (Bunel et al., 2018),
and satisfiability modulo theory (SMT) (Ehlers, 2017; Katz et al., 2017). Unfortunately, due to
the nonconvexity of model f, solving Eq. (1) is NP-hard even for a simple ReLU network (Katz
et al., 2017). Therefore, we can only expect to compute a lower bound of Eq. (1) efficiently by using
relaxations. Many algorithms can be seen as using convex relaxations for non-linear activation func-
tions (Salman et al., 2019), including using duality (Wong & Kolter, 2018; Dvijotham et al., 2018),
abstract domains (Gehr et al., 2018; Singh et al., 2018; Mirman et al., 2018; Singh et al., 2019),
layer-by-layer reachability analysis (Wang et al., 2018b; Weng et al., 2018; Zhang et al., 2018;
Gowal et al., 2018) and semi-definite relaxations (Raghunathan et al., 2018; Dvijotham et al., 2019).
2
Published as a conference paper at ICLR 2020
Additionally, robustness verification can rely on analysis on local Lipschitz constants (Hein & An-
driushchenko, 2017; Zhang et al., 2019). However, existing methods are mostly limited to verifying
networks with relatively simple architectures, such as feed-forward networks and RNNs (Wang et al.,
2018a; Akintunde et al., 2019; Ko et al., 2019), while none of them are able to handle Transformers.
Transformers and Self-Attentive Models. Transformers (Vaswani et al., 2017) based on self-
attention mechanism, further with pre-training on large-scale corpora, such as BERT (Devlin et al.,
2019), XLNet (Yang et al., 2019), RoBERTa (Liu et al., 2019), achieved state-of-the-art performance
on many NLP tasks. Self-attentive models are also useful beyond NLP, including VisualBERT on
vision and language applications (Li et al., 2019b; Su et al., 2019), image transformer for image gen-
eration (Parmar et al., 2018), acoustic models for speech recognition (Zhou et al., 2018), sequential
recommendation (Kang & McAuley, 2018) and graph embedding (Li et al., 2019a).
The robustness of NLP models has been studied, especially many methods have been proposed to
generate adversarial examples (Papernot et al., 2016; Jia & Liang, 2017; Zhao et al., 2017; Alzantot
et al., 2018; Cheng et al., 2018; Ebrahimi et al., 2018; Shi et al., 2019). In particular, Hsieh et al.
(2019) showed that Transformers are more robust than LSTMs. However, there is not much work
on robustness verification for NLP models. Ko et al. (2019) verified RNN/LSTM. Jia et al. (2019);
Huang et al. (2019) used Interval Bound Propagation (IBP) for certified robustness training of CNN
and LSTM. In this paper, we propose the first verification method for Transformers.
3	Methodology
We aim to verify the robustness of a Transformer whose input is a sequence of frames X =
[x(1), x(2),…，x(n)]. We take binary text classification as a running example, where x(i) is a word
embedding and the model outputs a score yc(X) for each class c (c ∈ {0, 1}). Nevertheless, our
method for verifying Transformers is general and can also be applied in other applications.
For a clean input sequence X。= [x01), x02),…,x0n)] correctly classified by the model, let P =
{rι, r2,…,rt}(1 ≤ rk ≤ n) be the set of perturbed positions, where t is the number of perturbed
positions. Thus the perturbed input belongs to Se := {X = [x(1), x(2),…，x(n)] : ∣∣x(rk) -
x(0rk) kp ≤ , 1 ≤ k ≤ t, x(i) = x(0i), ∀i ∈/ P}. Assuming that c is the gold class, the goal of
robustness verification is to compute
min yc (X) -
X∈S c
y1-c(X)
δe.
If δe > 0, the output score of the correct class is always larger than the incorrect one for any input
within Se. As mentioned previously, computing the exact values of δe is NP-hard, and thus our goal
is to efficiently compute a lower bound δeL ≤ δe .
3.1	Base Framework
We obtain δeL(X) by computing the bounds of each neuron when X is perturbed within Se (δeL can
be regarded as a final neuron). A Transformer layer can be decomposed into a number of sub-layers,
where each sub-layer contains neurons after some operations. These operations can be categorized
into three categories: 1) linear transformations, 2) unary nonlinear functions, and 3) operations in
self-attention. Each sub-layer contains n positions in the sequence and each position contains a
group of neurons. We assume that the Transformer we verify has m sub-layers in total, and the
value of the j-th neuron at the i-th position in the l-th sub-layer is Φ(jl,i) (X), where Φ(l,i) (X) is a
vector for the specified sub-layer and position. Specially, Φ(0,i) = x(i) taking l = 0. We aim to
compute a global lower bound fj(l,i),L and a global upper bound fj(l,i),U of Φ(jl,i)(X) for X ∈ Se.
We compute bounds from the first sub-layer to the last sub-layer. For neurons in the l-th layer, we
aim to represent their bounds as linear functions of neurons in a previous layer, the l0-th layer:
,i,l0),L
k=1
≤ Φ(jl,i)
(X)≤ XAyal0，k)，UΦ(l0,k)(χ) + ∆(l
k=1
,i,l0),U
(2)
3
Published as a conference paper at ICLR 2020
where Λ(l,i,l ,k),L , ∆(l,i,l ),L and Λ(l,i,l ,k),U , ∆(l,i,l ),U are parameters of linear lower and upper
bounds respectively. Using linear bounds enables us to efficiently compute bounds with a reasonable
tightness. We initially have Λ(l,i,l,i),L = Λ(l,i,l,i),U = I and ∆(l,i,l),L = ∆(l,i,l),U = 0. Thereby
the right-hand-side of Eq. (2) equals to Φj(l,i) (X) when l0 = l. Generally, we use a backward
process to propagate the bounds to previous sub-layers, by substituting Φ(l0,i) with linear functions
of previous neurons. It can be recursively conducted until the input layer l0 = 0. Since Φ(0,k) =
x(k) = x(0k) (∀k ∈/ P) is constant, we can regard the bounds as linear functions of the perturbed
embeddings Φ(0,rk) = x(rk)(1 ≤ k ≤ t), and take the global bounds for x(rk) ∈ Bp(x(0rk), ):
tn
fj(l,i),L = - X k Λ(l,i,0,rk),L kq + X Λjl,i,0,k"XOk) + ∆jl,i,0",	⑶
k=1	k=1
tn
fj('ii,U = eX k Λ(y,0,rQ,U kq + XΛjl,i,0㈤,UXOk) + ∆jl,i,O),U,	(4)
k=1	k=1
where 1/p + 1/q = 1 with p, q ≥ 1. These steps resemble to CROWN (Zhang et al., 2018) which is
proposed to verify feed-forward networks. We further support verifying self-attentive Transformers
which are more complex than feed-forward networks. Moreover, unlike CROWN that conducts a
fully backward process, we combine the backward process with a forward process (see Sec. 3.3) to
reduce the computational complexity of verifying Transformers.
3.2	Linear Transformations and Unary Nonlinear Functions
Linear transformations and unary nonlinear functions are basic operations in neural networks. We
show how bounds Eq. (2) at the l0-th sub-layer are propagated to the (l0 - 1)-th layer.
Linear Transformations If the l0-th sub-layer is connected with the (l0 - 1)-th sub-layer with a
linear transformation Φ(l0,k)(X) = W(l0)Φ(l0-1,k) (X) + b(l0) where W(l0), b(l0) are parameters of
the linear transformation, we propagate the bounds to the (l0 - 1)-th layer by substituting Φ(l0,k)(X):
Λ(l,i,l0-1,k),L∕U = Λ(l,i,l0,k),L∕UW('), ∆(l,i,l0T),L∕U = ^(ki,li),L^U + (X Λ(l,i,l0,fe),L∕U^ Rl0),
where “L/U” means that the equations hold for both lower bounds and upper bounds respectively.
Unary Nonlinear Functions If the l0-th layer is obtained from the (l0 - 1)-th layer with an unary
nonlinear function Φ(jl ,k) (X) = σ(l0) (Φ(jl -1,k) (X)), to propagate linear bounds over the nonlinear
function, we first bound σ(l0) (Φ(jl0-1,k) (X)) with two linear functions of Φ(jl0-1,k) (X):
α(l0,k),LΦ(l0-1,k) (X) + β(l0,k),L ≤ σ(l0) (Φ(l0-1,k) (X)) ≤ α(l0,k),U Φ(l0-1,k)(X) + β(l0,k),U,
where α(jl0,k),L∕U, βj(l0,k),L∕U are parameters such that the inequation holds true for all Φ(jl0-1,k) (X)
within its bounds computed previously. Such linear relaxations can be done for different functions,
respectively. We provide detailed bounds for functions involved in Transformers in Appendix B.
We then back propagate the bounds:
Λ(l,i,l0-1,k),L∕U	(l0,k),L∕U Λ(l,i,l0,k),L∕U	(l0,k),U∕LΛ(l,i,l0,k),L∕U
A,j	= αj	A,j,+	+ αj	A,j,-	，
∆(l,i,l0-1),L∕U = ∆(l,i,l0),L∕U +
β(l0,k),L∕U Λ(l,i,l0,k),L∕U + β(l0,k),U∕LΛ(l,i,l0,k),L∕U
βj	A,j,+	+ βj	'":,j,-
where Λ(l,i+,l0,k),L∕U and Λ(l,i,l0 ,k),L∕U mean to retain positive and negative elements in vector
:,j,+	:,j,-
A(Iji,l,k),L/U respectively and set other elements to 0.
4
Published as a conference paper at ICLR 2020
3.3	Self-Attention Mechanism
Self-attention layers are the most challenging parts for verifying Transformers. We assume that
Φ(l-1,i) (X) is the input to a self-attention layer. We describe our method for computing bounds for
one attention head, and bounds for different heads of the multi-head attention in Transformers can
be easily concatenated. Φ(l-1,i) (X) is first linearly projected to queries q(l,i) (X), keys k(l,i) (X),
and values v(l,i) (X) with different linear projections, and their bounds can be obtained as described
in Sec. 3.2. We also keep their linear bounds that are linear functions of the perturbed embeddings.
For convenience, let x(r) = x(r1) ㊉ x(r2) ㊉•…x(rt), where ㊉ indicates vector concatenation, and
thereby we represent the linear bounds as linear functions of x(r):
(l,i),q/k/v,L
j,:
x(r) + Θ
(l,i),q/k/v,L
j
≤ (q∕k∕v)jl,i)(X) ≤ Qjl,i),q/k/v,Ux(r) + 0jl,i),q/k/v,U,
where q/k/v and q/k/v mean that the inequation holds true for queries, keys and values respec-
tively. We then bound the output of the self-attention layer starting from q(l,i) (X), k(l,i) (X),
v(l,i) (X).
Bounds of Multiplications and Divisions We bound multiplications and divisions in the self-
attention mechanism with linear functions. We aim to bound bivariate function z = xy or z =
X (y > 0) with two linear functions ZL = aLx + βLy + YL and ZU = auX + βUy + YU, where
x ∈ [lx, ux], y ∈ [ly, uy] are bounds of x, y obtained previously. For z = xy, we derive optimal
parameters: αL = ly, αU = uy, βL = βU = lx, YL = -lxly, YU = -lxuy. We provide a proof in
Appendix C. However, directly bounding Z = X is tricky; fortunately, we can bound it indirectly by
first bounding a unary function y = 1 and then bounding the multiplication Z = xy.
A Forward Process For the self-attention mechanism, instead of using the backward process like
CROWN (Zhang et al., 2018), we compute bounds with a forward process which we will show later
that it can reduce the computational complexity. Attention scores are computed from q(l,i) (X) and
k(l,i) (X): Si(,lj) = (q(l,i) (X))Tk(l,j) (X) = Pdkq=k1 q(kl,i) (X)k(kl,j) (X), where dqk is the dimension
of q(l,i)(X) and k(l,j)(X). For each multiplication q(kl,i)(X)k(kl,j)(X), it is bounded by:
q(kl,i)(X)k(kl,j)(X) ≥ αk(l,i,j),Lq(kl,i) (X) + βk(l,i,j),Lk(kl,j)(X) + Yk(l,i,j),L,
q(kl,i)(X)k(kl,j)(X) ≤ α(kl,i,j),U q(kl,i)(X) + βk(l,i,j),U k(kl,j)(X) + Yk(l,i,j),U.
We then obtain the bounds of Si(,lj):
Ω(l,i),s,Lχ(r) + θ(l,i),s,L ≤ S(I) ≤ Ω(l,i),s,uχ(r) + Θ(l,i),s,u
Ω(i,i),s,L∕u = αyG,L∕U( X
，	心⑺山U >o
k
β%,i,j),L∕U(	X
C(l,i),q,L/U ,	X	c(l，i)，q，U/L、_L
"k,:	+	乙	'”,:	)+
a—，L/U <0
k
S(”s,L/U = α(l,i,j),L∕U
β(l,i,j),L∕U
(X
>0
C(l,j),k,L/U , X	c(l，»k，U/L\
'",:	+ 乙 '",:	)，
e(l，i,j)，L/U <o
Θ(l,i),q,L∕U
a(，"/u >0
k
+ X	θ,,i),q,U∕L) +
α(l,i,j),L∕u <0
k
β(l,i,j),L∕U(	X
β(l,i,j),L∕U
θ,,j),k,L∕U +
>0
β (l,i,j),L/U <0
dqk
Θ(l,j ),k,U/L	X (l,i,j),L/U
k	Yk
k=1
Σ
In this way, linear bounds of q(l,i)(X) andk(l,i)(X) are forward propagated to Si(,lj). Attention scores
are normalized into attention probabilities with a softmax, i.e. Silj = exp(S(lj)/(Pn=I exp(S(lk)),
where S(lj is a normalized attention probability. exp(S(lj) is an unary nonlinear function and can
5
Published as a conference paper at ICLR 2020
be bounded by α( j,L/US( j + βi( j,L/U. So We forward propagate bounds of S( j to bound exp(S( j)
with j'，"/UX(r) + Θj*eL∕u, where:	,	,
Ω(l,i),e,L∕U = α(l),L∕U c(l，i)，s，L/U θ(l,i),e,L∕U = α(l),L∕U q(l,i),s,L/U + r ⑴,L/U
j,:	=	αi,j	j,:	j	=	αi,j	j	+ βi,j
Ω(l,i),e,L∕U — rv(l),L∕U c(l,i),s,U∕L q(l,i),e,L∕U — rv(l),L∕U q(l,i),s,U∕L , z√l),L∕U
ωj,:	一	αi,j	"j,：	θj	=	αi,j	θj	+ βi,j
a(j，L/u ≥ 0,
ail)，L/U < 0.
By summing up bounds of each exp(Si(,lk) ), linear bounds can be further propagated to
Pkn=1 exp(Si(,lk) ). With bounds of exp(Si(,lj)) and Pkn=1 exp(Si(,lk) ) ready, we forward propagate
the bounds to S(j with a division similarly to bounding qkl,i)(X)kklj)(X). The output of the
self-attention Φ(l,i)(X) is obtained with a summation of v(l,j)(X) weighted by attention probabil-
ity S(lk: φjl,i)(X) = Pn=ι S(lkVjl,k)(X), which can be regarded as a dot product of S(I) and
Vklj) (X), where Vklj)(X) = Vjlkk(X) whose bounds can be obtained from those of Vjl,k)(X)
with a transposing. Therefore, bounds of SSi(,lk) and VSk(l,j)(X) can be forward propagated to Φ(l,i)(X)
similarly to bounding Si(,lj). In this way, we obtain the output bounds of the self-attention:
Ωjl0,i),φ,Lx(r) + θjl0,i),φ,L ≤ φ(l',i)(X) ≤ Ωj',i),φ,Ux(r) + θjl0,i),φ,U
(5)
Recall that x(r) is a concatenation ofXSI), x(r2),…，X(Tt). We Can split Ωj[,i),φ,L" into t vec-
Ω(l0,i,1),Φ,L∕U Ω(l0,i,2),Φ,L∕U
tors with equal dimensions,
becomes
t
Ωj,W,φLu, such that Eq.(5)
t
X Ωj:,i,k),φ,Lχ(rk) + Θ尸g ≤ φ(l0,i)(X) ≤ X ng,®),®。x(rk)+ θ"),φ,u.	(6)
k=1	k=1
Backward Process to Self-Attention Layers When computing bounds for a later sub-layer, the l-
th sub-layer, using the backward process, we directly propagate the bounds at the the closest previous
self-attention layer assumed to be the l0-th layer, to the input layer, and we skip other previous sub-
layers. The bounds propagated to the l0-th layer are as Eq. (2). We substitute Φ(l0,k)(X) with linear
bounds in Eq. (6):
n
ʌ(l,i,θ,rk ),L∕U _ V^/A(l,i,l0,k0),L/U 0(1，E HP 工 ʌ (l,i,l0,k0),L∕U c(l0,k0,k),Φ,U∕L、门 ^k^Q
'j	=2√Aj,:,+	%：	+ 5,-	%：	)(1 ≤ k ≤ t)，
k0=1
Λ j,i,0,k),L∕u = o (∀k ∈ p),
n
∆(l,i,0),L∕U = ∆(l,i,l0,L∕U) + X Λ(l,i,l0,k),L∕UΘ(l0,k),Φ,L∕U +Λ(l,i,l0,k),L∕UΘ(l0,k),Φ,U∕L
∆j	= ∆j	+	Λj,:,+	Θj	+ Λj,:,-	Θj
k=1
We take global bounds as Eq. (3) and Eq. (4) to obtain the bounds of the l-th layer.
Advantageous of Combining the Backward Process with a Forward Process Introducing a
forward process can significantly reduce the complexity of verifying Transformers. With the back-
ward process only, we need to compute Λ(l,i,l ,k) and ∆(l,i,l ) (l0 ≤ l), where the major cost is on
Λ(l,i,l ,k) and there are O(m2n2) such matrices to compute. The O(n2) factor is from the depen-
dency between all pairs of positions in the input and output respectively, which makes the algorithm
inefficient especially when the input sequence is long. In contrast, the forward process represents
the bounds as linear functions of the perturbed positions only instead of all positions by comput-
ing Ω(l,i) and Θ(l,i). Imperceptible adversarial examples may not have many perturbed positions
(Gao et al., 2018; Ko et al., 2019), and thus we may assume that the number of perturbed positions,
t, is small. The major cost is on Ω(l,i) while there are only O(mn) such matrices and the sizes
of Λ(l,i,l ,k) and Ω(l,i) are relatively comparable for a small t. We combine the backward process
and the forward process. The number of matrices Ω in the forward process is O(mn), and for the
backward process, since we do not propagate bounds over self-attention layers and there is no cross-
position dependency in other sub-layers, we only compute Λ(l,i,l ,k) such that i = k, and thus the
number of matrices Λ is reduced to O(m2n). Therefore, the total number of matrices Λ and Ω we
compute is O(m2n) and is O(n) times smaller than O(m2n2) when only the backward process is
used. Moreover, the backward process makes bounds tighter compared to solely the forward one, as
we explain in Appendix D.
6
Published as a conference paper at ICLR 2020
4 Experiments
To demonstrate the effectiveness of our algorithm, we compute certified bounds for several senti-
ment classification models and perform an ablation study to show the advantage of combining the
backward and forward processes. We also demonstrate the meaningfulness of our certified bounds
with an application on identifying important words.
4.1 Datasets and Models
We use two datasets: Yelp (Zhang et al., 2015) and SST (Socher et al., 2013). Yelp consists of
560,000/38,000 examples in the training/test set and SST consists of 67,349/872/1,821 examples in
the training/development/test set. Each example is a sentence or a sentence segment (for the training
data of SST only) labeled with a binary sentiment polarity.
We verify the robustness of Transformers trained from scratch. For the main experiments, we con-
sider N -layer models (N ≤ 3), with 4 attention heads, hidden sizes of 256 and 512 for self-attention
and feed-forward layers respectively, and we use ReLU activations for feed-forward layers. We re-
move the variance related terms in layer normalization, making Transformers verification bounds
tighter while the clean accuracies remain comparable (see Appendix E for discussions). Although
our method can be in principal applied to Transformers with any number of layers, we do not use
large-scale pre-trained models such as BERT because they are too challenging to be tightly verified
with the current technologies.
4.2 Certified B ounds
Dataset	N	Acc.	'p	Upper	Lower (IBP)	Lower (OurS)	OurS vs Upper
				-Min	Avg-	Min	Avg	-Min	AVg-	Min	AVg-
Yelp	1	91.5	~'Γ '2 '∞	9.085	13.917 0.695	1.005 0.117	0.155	1.4E-4	3.1E-4 1.4E-4	3.1E-4 1.4E-4	3.1E-4	1.423^^1.809 0.384	0.483 0.034	0.043	^T6%	13% 55%	48% 29%	27%
	2	91.5	~'1~ '2 '∞	10.228^^15.452 0.773	1.103 0.122	0.161	1.4E-7	2.2E-7 1.4E-7	2.2E-7 1.4E-7	2.2E-7	0.389^^0.512 0.116	0.149 0.010	0.013	^^%	3%- 15%	14% 9%	8%
	3	91.6	~'1~ '2 '∞	11.137^^15.041 0.826	1.090 0.136	0.187	4.3E-10^^7.1E-10 4.3E-10	7.1E-10 4.3E-10	7.1E-10	0.152^^0.284 0.042	0.072 0.004	0.006	^T%	2%- 5%	7% 3%	3%
SST	1	83.2	'2 '∞	7.418	8.849 0.560	0.658 0.091	0.111	2.4E-4	2.7E-4 2.4E-4	2.7E-4 2.4E-4	2.7E-4	2.503^^2.689 0.418	0.454 0.033	0.036	"34%	30% 75%	69% 36%	32%
	2	83.5	~'Γ~ '2 '∞	6.781	8.367 0.520	0.628 0.085	0.105	3.6E-7	3.8E-7 3.6E-7	3.8E-7 3.6E-7	3.8E-7	1.919^^1.969 0.305	0.315 0.024	0.024	^^8%	24% 59%	50% 28%	23%
	3	83.9	~'1~ '2 '∞	6.475	7.877 0.497	0.590 0.084	0.101	5.7E-10^^6.7E-10 5.7E-10	6.7E-10 5.7E-10	6.7E-10	1.007^^1.031 0.169	0.173 0.013	0.014	^T6%	13% 34%	29% 16%	13%
Table 1: Clean accuracies and computed bounds for 1-position perturbation. Bounds include upper
bounds (obtained by an enumeration based method), certified lower bounds by IBP and our method
respectively. We also report the gap between upper bounds and our lower bounds (represented as the
percentage of lower bounds relative to upper bounds). We compute bounds for each possible option
of perturbed positions and report the minimum (“Min”) and average (“Avg”) among them.
N		Yelp						SST				
	LoWer(IBP)		Lower (Ours)		LoWer(IBP)		Lower (Ours)	
	Min	Avg	Min	AVg	Min	Avg	Min	Avg
1	6.5E-5	1.2E-4	0.242	0.290	1.1E-4	1.1E-4	0.212	0.229
2	6.2E-8	8.6E-8	0.060	0.078	1.5E-7	1.5E-7	0.145	0.149
3	2.8E-10	4.4E-10	0.023	0.035	3.3E-10	4.5E-10	0.081	0.083
Table 2: Bounds by IBP and our method for 2-position perturbation constrained by `2 -norm.
7
Published as a conference paper at ICLR 2020
We compute certified lower bounds for different models on different datasets. We include 1-position
perturbation constrained by '1∕'2∕'∞-norms and 2-position perturbation constrained by '2-norm.
We compare our lower bounds with those computed by the Interval Bound Propagation (IBP) (Gowal
et al., 2018) baseline. For 1-position perturbation, we also compare with upper bounds computed
by enumerating all the words in the vocabulary and finding the word closest to the original one such
that the word substitution alters the predicted label. This method has an exponential complexity with
respect to the vocabulary size and can hardly be extended to perturbations on 2 or more positions;
thus we do not include upper bounds for 2-position perturbation. For each example, we enumerate
possible options of perturbed positions (there are nt options), and we integrate results from different
options by taking the minimum or average respectively. We report the average results on 10 correctly
classified random test examples with sentence lengths no more than 32 for 1-position perturbation
and 16 for 2-position perturbation. Table 1 and Table 2 present the results for 1-position and 2-
position perturbation respectively. Our certified lower bounds are significantly larger and thus tighter
than those by IBP. For 1-position perturbation, the lower bounds are consistently smaller than the
upper bounds, and the gap between the upper bounds and our lower bounds is reasonable compared
with that in previous work on verification of feed-forward networks, e.g., in (Weng et al., 2018;
Zhang et al., 2018) the upper bounds are in the order of 10 times larger than lower bounds. This
demonstrates that our proposed method can compute robustness bounds for Transformers in a similar
quality to the bounds of simpler neural networks.
4.3	Effectiveness of Combining the Backward Process with a Forward Process
Dataset	Acc.	'p	Fully-Forward			Fully-Backward			Backward & Forward		
			Min	Avg	Time	Min	Avg	Time	Min	Avg	Time
		~~eΓ	2.122	2.173	12.6	3.485	3.737	141.4	3.479	3.729	24.0
Yelp	91.3	'2	0.576	0.599	12.4	0.867	0.947	140.4	0.866	0.946	26.0
		'∞	0.081	0.084	12.6	0.123	0.136	143.9	0.123	0.136	26.4
			1.545	1.592	13.7	1.891	1.961	177.6	1.891	1.961	26.5
SST	83.3	'2	0.352	0.366	12.6	0.419	0.439	178.8	0.419	0.439	24.3
		'∞	0.048	0.050	14.6	0.058	0.061	181.3	0.058	0.061	24.3
Table 3: Comparison of certified lower bounds and computation time (sec) by different methods.
In the following, we show the effectiveness of combining the backward process with a forward
process. We compare our proposed method (Backward & Forward) with two variations: 1) Fully-
Forward propagates bounds in a forward manner for all sub-layers besides self-attention layers; 2)
Fully-Backward computes bounds for all sub-layers including self-attention layers using the back-
ward bound propagation and without the forward process. We compare the tightness of bounds and
computation time of the three methods. We use smaller models with the hidden sizes reduced by
75%, and we use 1-position perturbation only, to accommodate Fully-Backward with large computa-
tional cost. Experiments are conducted on an NVIDIA TITAN X GPU. Table 3 presents the results.
Bounds by Fully-Forward are significantly looser while those by Fully-Backward and Backward &
Forward are comparable. Meanwhile, the computation time of Backward & Forward is significantly
shorter than that of Fully-Backward. This demonstrates that our method of combining the backward
and forward processes can compute comparably tight bounds much more efficiently.
4.4	Identifying Words Important to Prediction
The certified lower bounds can reflect how sensitive a model is to the perturbation of each input
word. Intuitively, if a word is more important to the prediction, the model is more sensitive to its
perturbation. Therefore, the certified lower bounds can be used to identify important words. In
the following, we conduct an experiment to verify whether important words can be identified by
our certified lower bounds. We use a 1-layer Transformer classifier under 1-position perturbation
constrained by '2-norm. The certified lower bounds are normalized by the norm of the unperturbed
word embeddings respectively, when they are used for identifying the most/least important words.
We compare our method with two baselines that also estimate local vulnerability: 1) Upper uses
upper bounds; 2) Gradient identifies the word whose embedding has the largest'2-norm of gradients
as the most important and vice versa.
8
Published as a conference paper at ICLR 2020
Method	Importance Score (OnSST)	Words Identified from 10 Examples on the Yelp Dataset (split by "/”)
Most Important Words or Symbols		
Grad	0.47	terrible / great / diner / best / best / food / service / food / perfect / best
Upper	0.45	terrible / We / . / best / best / and / slow / great / this / best
Ours	0.57	terrible / great / diner / best / best / good / slow/ great /perfect /best
Least Important Words or Symbols		
Grad	0.40	./ decadent / . / . / had / and / place / . / ! / .
Upper	0.24	./ . / typical / boba / i / dark / star / atmosphere / & / boba
Ours	0.01	./ . / . / the / . / . / food / . / . / the
Table 4: Average importance scores of the most/least important words identified from 100 examples
respectively on SST by different methods. For the most important words identified, larger important
scores are better, and vice versa. Additionally, we show most/least important words identified from
10 examples on the Yelp dataset. Boldfaced words are considered to have strong sentiment polarities,
and they should appear as most important words rather than least important ones.
Quantitative Analysis on SST SST contains sentiment labels for all phrases on parse trees, where
the labels range from very negative (0) to very positive (4), and 2 for neutral. For each word,
assuming its label is x, we take |x - 2|, i.e., the distance to the neutral label, as the importance
score, since less neutral words tend to be more important for the sentiment polarity of the sentence.
We evaluate on 100 random test input sentences and compute the average importance scores of the
most or least important words identified from the examples. In Table 4, compared to the baselines
(“Upper” and “Grad”), the average importance score of the most important words identified by our
lower bounds are the largest, while the least important words identified by our method have the
smallest average score. This demonstrates that our method identifies the most and least important
words more accurately compared to baseline methods.
Qualitative Analysis on Yelp We further analyze the results on a larger dataset, Yelp. Since Yelp
does not provide per-word sentiment labels, importance scores cannot be computed as on SST. Thus,
we demonstrate a qualitative analysis. We use 10 random test examples and collect the words iden-
tified as the most and least important word in each example. In Table 4, most words identified as the
most important by certified lower bounds are exactly the words reflecting sentiment polarities (bold-
faced words), while those identified as the least important words are mostly stopwords. Baseline
methods mistakenly identify more words containing no sentiment polarity as the most important.
This again demonstrates that our certified lower bounds identify word importance better than base-
lines and our bounds provide meaningful interpretations in practice. While gradients evaluate the
sensitivity of each input word, this evaluation only holds true within a very small neighborhood
(where the classifier can be approximated by a first-order Taylor expansion) around the input sen-
tence. Our certified method gives valid lower bounds that hold true within a large neighborhood
specified by a perturbation set S, and thus it provides more accurate results.
5 Conclusion
We propose the first robustness verification method for Transformers, and tackle key challenges in
verifying Transformers, including cross-nonlinearity and cross-position dependency. Our method
computes certified lower bounds that are significantly tighter than those by IBP. Quantitative and
qualitative analyses further show that our bounds are meaningful and can reflect the importance of
different words in sentiment analysis.
Acknowledgement
This work is jointly supported by Tsinghua Scholarship for Undergraduate Overseas Studies, NSF
IIS1719097 and IIS1927554, and NSFC key project with No. 61936010 and regular project with
No. 61876096.
References
Michael E Akintunde, Andreea Kevorchian, Alessio Lomuscio, and Edoardo Pirovano. Verification
of rnn-based neural agent-environment systems. In Proceedings of the 33th AAAI Conference on
9
Published as a conference paper at ICLR 2020
Artificial Intelligence (AAAI19). Honolulu, HI, USA. AAAI Press., 2019.
Moustafa Alzantot, Yash Sharma, Ahmed Elgohary, Bo-Jhang Ho, Mani Srivastava, and Kai-Wei
Chang. Generating natural language adversarial examples. In EMNLP, pp. 2890-2896, 2018.
Rudy R Bunel, Ilker Turkaslan, Philip Torr, Pushmeet Kohli, and Pawan K Mudigonda. A unified
view of piecewise linear neural network verification. In Advances in Neural Information Process-
ing Systems, pp. 4790-4799, 2018.
Minhao Cheng, Jinfeng Yi, Huan Zhang, Pin-Yu Chen, and Cho-Jui Hsieh. Seq2sick: Evaluat-
ing the robustness of sequence-to-sequence models with adversarial examples. arXiv preprint
arXiv:1803.01128, 2018.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep
bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of
the North American Chapter of the Association for Computational Linguistics: Human Language
Technologies, Volume 1 (Long and Short Papers), pp. 4171-4186, 2019.
Souradeep Dutta, Susmit Jha, Sriram Sankaranarayanan, and Ashish Tiwari. Output range analy-
sis for deep feedforward neural networks. In NASA Formal Methods Symposium, pp. 121-138.
Springer, 2018.
Krishnamurthy Dvijotham, Robert Stanforth, Sven Gowal, Timothy Mann, and Pushmeet Kohli. A
dual approach to scalable verification of deep networks. UAI, 2018.
Krishnamurthy Dj Dvijotham, Robert Stanforth, Sven Gowal, Chongli Qin, Soham De, and Push-
meet Kohli. Efficient neural network verification with exactness characterization. UAI, 2019.
Javid Ebrahimi, Anyi Rao, Daniel Lowd, and Dejing Dou. Hotflip: White-box adversarial exam-
ples for text classification. In Proceedings of the 56th Annual Meeting of the Association for
Computational Linguistics (Volume 2: Short Papers), pp. 31-36, 2018.
Ruediger Ehlers. Formal verification of piece-wise linear feed-forward neural networks. In Interna-
tional Symposium on Automated Technology for Verification and Analysis, pp. 269-286. Springer,
2017.
Ji Gao, Jack Lanchantin, Mary Lou Soffa, and Yanjun Qi. Black-box generation of adversarial
text sequences to evade deep learning classifiers. In 2018 IEEE Security and Privacy Workshops
(SPW), pp. 50-56. IEEE, 2018.
Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Mar-
tin Vechev. Ai2: Safety and robustness certification of neural networks with abstract interpreta-
tion. In 2018 IEEE Symposium on Security and Privacy (SP), pp. 3-18. IEEE, 2018.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. arXiv preprint arXiv:1412.6572, 2014.
Sven Gowal, Krishnamurthy Dvijotham, Robert Stanforth, Rudy Bunel, Chongli Qin, Jonathan Ue-
sato, Timothy Mann, and Pushmeet Kohli. On the effectiveness of interval bound propagation for
training verifiably robust models. arXiv preprint arXiv:1810.12715, 2018.
Matthias Hein and Maksym Andriushchenko. Formal guarantees on the robustness of a classifier
against adversarial manipulation. In Advances in Neural Information Processing Systems (NIPS),
pp. 2266-2276, 2017.
Yu-Lun Hsieh, Minhao Cheng, Da-Cheng Juan, Wei Wei, Wen-Lian Hsu, and Cho-Jui Hsieh. On
the robustness of self-attentive models. In ACL, pp. 1520-1529, 2019.
Po-Sen Huang, Robert Stanforth, Johannes Welbl, Chris Dyer, Dani Yogatama, Sven Gowal, Krish-
namurthy Dvijotham, and Pushmeet Kohli. Achieving verified robustness to symbol substitutions
via interval bound propagation. In Proceedings of the 2019 Conference on Empirical Methods in
Natural Language Processing and the 9th International Joint Conference on Natural Language
Processing (EMNLP-IJCNLP), pp. 4074-4084, 2019.
10
Published as a conference paper at ICLR 2020
Robin Jia and Percy Liang. Adversarial examples for evaluating reading comprehension systems.
arXiv preprint arXiv:1707.07328, 2017.
Robin Jia, Aditi RaghUnathan, Kerem GokseL and Percy Liang. Certified robustness to adversarial
word substitutions. In Proceedings of the 2019 Conference on Empirical Methods in Natural
Language Processing and the 9th International Joint Conference on Natural Language Process-
ing (EMNLP-IJCNLP),pp. 4120-4133, 2019.
Kyle D Julian, Shivam Sharma, Jean-Baptiste Jeannin, and Mykel J Kochenderfer. Verifying aircraft
collision avoidance neural networks through linear approximations of safe regions. arXiv preprint
arXiv:1903.00762, 2019.
Wang-Cheng Kang and Julian McAuley. Self-attentive sequential recommendation. In 2018 IEEE
International Conference on Data Mining (ICDM), pp. 197-206. IEEE, 2018.
Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. Reluplex: An
efficient smt solver for verifying deep neural networks. In International Conference on Computer
Aided Verification, pp. 97-117. Springer, 2017.
Ching-Yun Ko, Zhaoyang Lyu, Lily Weng, Luca Daniel, Ngai Wong, and Dahua Lin. Popqorn:
Quantifying robustness of recurrent neural networks. In International Conference on Machine
Learning, pp. 3468-3477, 2019.
Jia Li, Yu Rong, Hong Cheng, Helen Meng, Wenbing Huang, and Junzhou Huang. Semi-supervised
graph classification: A hierarchical graph perspective. In The World Wide Web Conference, pp.
972-982. ACM, 2019a.
Liunian Harold Li, Mark Yatskar, Da Yin, Cho-Jui Hsieh, and Kai-Wei Chang. Visualbert: A simple
and performant baseline for vision and language. arXiv preprint arXiv:1908.03557, 2019b.
Xuankang Lin, He Zhu, Roopsha Samanta, and Suresh Jagannathan. Art: Abstraction refinement-
guided training for provably correct neural networks. arXiv preprint arXiv:1907.10662, 2019.
Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike
Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining
approach. arXiv preprint arXiv:1907.11692, 2019.
Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for prov-
ably robust neural networks. In International Conference on Machine Learning, pp. 3575-3583,
2018.
Nicolas Papernot, Patrick McDaniel, Ananthram Swami, and Richard Harang. Crafting adversarial
input sequences for recurrent neural networks. In MILCOM 2016-2016 IEEE Military Communi-
cations Conference, pp. 49-54. IEEE, 2016.
Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, Eukasz Kaiser, Noam Shazeer, Alexander Ku, and
Dustin Tran. Image transformer. arXiv preprint arXiv:1802.05751, 2018.
Chongli Qin, Brendan O’Donoghue, Rudy Bunel, Robert Stanforth, Sven Gowal, Jonathan Uesato,
Grzegorz Swirszcz, Pushmeet Kohli, et al. Verification of non-linear specifications for neural
networks. arXiv preprint arXiv:1902.09592, 2019.
Aditi Raghunathan, Jacob Steinhardt, and Percy S Liang. Semidefinite relaxations for certifying
robustness to adversarial examples. In Advances in Neural Information Processing Systems, pp.
10877-10887, 2018.
Hadi Salman, Greg Yang, Huan Zhang, Cho-Jui Hsieh, and Pengchuan Zhang. A convex relaxation
barrier to tight robustness verification of neural networks. In Advances in Neural Information
Processing Systems 32, pp. 9832-9842. 2019.
Zhouxing Shi, Ting Yao, Jingfang Xu, and Minlie Huang. Robustness to modification with shared
words in paraphrase identification. arXiv preprint arXiv:1909.02560, 2019.
11
Published as a conference paper at ICLR 2020
Andy Shih, Arthur Choi, and Adnan Darwiche. A symbolic approach to explaining bayesian net-
work classifiers. In IJCAI, 2018.
GagandeeP Singh, Timon Gehr, Matthew Mirman, Markus PuscheL and Martin Vechev. Fast and
effective robustness certification. In Advances in Neural Information Processing Systems, pp.
10825-10836, 2018.
Gagandeep Singh, Timon Gehr, Markus PuscheL and Martin Vechev. An abstract domain for certi-
fying neural networks. Proceedings of the ACM on Programming Languages, 3(POPL):41, 2019.
Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D Manning, Andrew Ng,
and Christopher Potts. Recursive deep models for semantic compositionality over a sentiment
treebank. In Proceedings of the 2013 conference on empirical methods in natural language pro-
cessing, pp. 1631-1642, 2013.
Weijie Su, Xizhou Zhu, Yue Cao, Bin Li, Lewei Lu, Furu Wei, and Jifeng Dai. Vl-bert: Pre-training
of generic visual-linguistic representations. arXiv preprint arXiv:1908.08530, 2019.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing properties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
Vincent Tjeng, Kai Xiao, and Russ Tedrake. Evaluating robustness of neural networks with mixed
integer programming. ICLR, 2019.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information
processing systems, pp. 5998-6008, 2017.
Qinglong Wang, Kaixuan Zhang, Xue Liu, and C Lee Giles. Verification of recurrent neural net-
works through rule extraction. arXiv preprint arXiv:1811.06029, 2018a.
Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Efficient formal safety
analysis of neural networks. In Advances in Neural Information Processing Systems, pp. 6367-
6377, 2018b.
Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Formal security analysis
of neural networks using symbolic intervals. In 27th {USENIX} Security Symposium ({USENIX}
Security 18), pp. 1599-1614, 2018c.
Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Luca Daniel, Duane Bon-
ing, and Inderjit Dhillon. Towards fast computation of certified robustness for relu networks. In
International Conference on Machine Learning, pp. 5273-5282, 2018.
Eric Wong and Zico Kolter. Provable defenses against adversarial examples via the convex outer
adversarial polytope. In International Conference on Machine Learning, pp. 5283-5292, 2018.
Yichen Yang and Martin Rinard. Correctness verification of neural networks. arXiv preprint
arXiv:1906.01030, 2019.
Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, and Quoc V
Le. Xlnet: Generalized autoregressive pretraining for language understanding. arXiv preprint
arXiv:1906.08237, 2019.
Huan Zhang, Tsui-Wei Weng, Pin-Yu Chen, Cho-Jui Hsieh, and Luca Daniel. Efficient neural net-
work robustness certification with general activation functions. In Advances in neural information
processing systems, pp. 4939-4948, 2018.
Huan Zhang, Pengchuan Zhang, and Cho-Jui Hsieh. Recurjac: An efficient recursive algorithm for
bounding jacobian matrix of neural networks and its applications. In Proceedings of the AAAI
Conference on Artificial Intelligence, volume 33, pp. 5757-5764, 2019.
Xiang Zhang, Junbo Zhao, and Yann LeCun. Character-level convolutional networks for text clas-
sification. In Advances in neural information processing systems, pp. 649-657, 2015.
12
Published as a conference paper at ICLR 2020
Zhengli Zhao, Dheeru Dua, and Sameer Singh. Generating natural adversarial examples. arXiv
preprint arXiv:1710.11342, 2017.
Shiyu Zhou, Linhao Dong, Shuang Xu, and Bo Xu. Syllable-based sequence-to-sequence speech
recognition with the transformer in mandarin chinese. arXiv preprint arXiv:1804.10752, 2018.
13
Published as a conference paper at ICLR 2020
A Illustration of Different Bounding Processes
Figure 1: Illustration of three different bounding processes: Fully-Forward (a), Fully-Backward (b),
and Backward&Forward (c). We show an example ofa 2-layer Transformer, where operations can be
divided into two kinds of blocks, “Feed-forward” and “Self-attention”. “Self-attention” contains op-
erations in the self-attention mechanism starting from queries, keys, and values, and “Feed-forward”
contains all the other operations including linear transformations and unary nonlinear functions. Ar-
rows with solid lines indicate the propagation of linear bounds in a forward manner. Each backward
arrow Ak → Bk with a dashed line for blocks Ak , Bk indicates that there is a backward bound
propagation to block Bk when computing bounds for block Ak . Blocks with blue rectangles have
forward processes inside the blocks, while those with green rounded rectangles have backward pro-
cesses inside.
Figure 1 illustrates a comparison of the Fully-Forward, Fully-Backward and Backward & Forward
processes, for a 2-layer Transformer as an example. For Fully-Forward, there are only forward
processes connecting adjacent layers and blocks. For Fully-Backward, there are only backward
processes, and each layer needs a backward bound propagation to all the previous layers. For our
Backward & Forward algorithm, we use backward processes for the feed-forward parts and forward
processes for self-attention layers, and for layers after self-attention layers, they no longer need
backward bound propagation to layers prior to self-attention layers. In this way, we resolve the
cross-position dependency in verifying Transformers while still keeping bounds comparably tight
as those by using fully backward processes. Empirical comparison of the three frameworks are
presented in Sec. 4.3.
14
Published as a conference paper at ICLR 2020
B Linear Bounds of Unary Nonlinear Functions
We show in Sec. 3.2 that linear bounds can be propagated over unary nonlinear functions as long
as the unary nonlinear functions can be bounded with linear functions. Such bounds are determined
for each neuron respectively, according to the bounds of the input for the function. Specifically, for
a unary nonlinear function σ(x), with the bounds of x obtained previously as x ∈ [l, u], we aim to
derive a linear lower bound αLx + βL and a linear upper bound αUx + βU, such that
αLx + βL ≤ σ(x) ≤ αUx + βU (∀x ∈ [l, u]),
where parameters αL , βL , αU, βU are dependent on l, u and designed for different functions σ(x)
respectively. We introduce how the parameters are determined for different unary nonlinear func-
tions involved in Transformers such that the linear bounds are valid and as tight as possible. Bounds
of ReLU and tanh has been discussed by Zhang et al. (2018), and We further derive bounds of ex,
1, χ2, √χ. x2 and √χ are only used when the layer normalization is not modified for experiments
to study the impact of our modification. For the folloWing description, We define the endpoints of
the function to be bounded within range (l, r) as (l, σ(l)) and (u, σ(u)). We describe how the lines
corresponding to the linear bounds of different functions can be determined, and thereby parameters
αL , βL , αU , βU can be determined accordingly.
ReLU For ReLU activation, σ(x) = max(x, 0). ReLU is inherently linear on segments (-∞, 0]
and [0, ∞) respectively, so we make the linear bounds exactly σ(x) for u ≤ 0 or l ≥ 0; and for
l < 0 < u, we take the line passing the two endpoints as the upper bound; and we take σL (x) = 0
when u < |l| and σL (x) = x when u ≥ |l| as the lower bound, to minimize the gap between the
lower bound and the original function.
-2x
Tanh For tanh activation, σ(x) = l-j-x. tanh is concave for l ≥ 0, and thus we take the line
passing the two endpoints as the lower bound and take a tangent line passing ((l + u)/2, σ((l + u)/2)
as the upper bound. For u ≤ 0, tanh is convex, and thus we take the line passing the two endpoints
as the upper bound and take a tangent line passing ((l + u)/2, σ((l + u)/2) as the lower bound. For
l < 0 < u, we take a tangent line passing the right endpoint and (dL, σ(dL))(dL ≤ 0) as the lower
bound, and take a tangent line passing the left endpoint and (dU, σ(dU))(dU ≥ 0) as the upper
bound. dL and dU can be found with a binary search.
Exp σ(x) = exp(x) = ex is convex, and thus we take the line passing the two endpoints as
the upper bound and take a tangent line passing (d, σ(d)) as the lower bound. Preferably, we take
d = (l + u)/2. However, ex is always positive and used in the softmax for computing normalized
attention probabilities in self-attention layers, i.e., exp(Si(,lj)) and Pkn=1 exp(Si(,lk) ). Pkn=1 exp(Si(,lk) )
appears in the denominator of the softmax, and to make reciprocal function 1 finitely bounded, the
range ofx should not pass 0. Therefore, we impose a constraint to force the lower bound function to
be always positive, i.e., σL (l) > 0, since σL (l) is monotonously increasing. σdL(x) = ed(x-d) +ed
is the tangent line passing (d, σ(d)). So the constraint σdL(l) > 0 yields d < l + 1. Hence we take
d = min((l + u)/2, l + 1 - ∆d) where ∆d is a small real value to ensure that d < l + 1 such as
∆d = 10-2.
Reciprocal For the reciprocal function, σ(x) = 1. It is used in the softmax and layer normaliza-
tion and its input is limited to have l > 0 by the lower bounds of exp(x), and √x. With l > 0, σ(x)
is convex. Therefore, we take the line passing the two endpoints as the upper bound. And we take
the tangent line passing ((l + u)/2, σ((l + u)/2)) as the lower bound.
Square For the square function, σ(x) = x2 . It is convex and we take the line passing the two
endpoints as the upper bound. And we take a tangent line passing (d, σ(d))(d ∈ [l, u]) as the lower
bound. We still prefer to take d = (l + u)/2. x2 appears in the variance term of layer normalization
and is later passed to a square root function to compute a standard derivation. To make the input to
the square root function valid, i.e., non-negative, we impose a constraint σL (x) ≥ 0(∀x ∈ [l, u]).
σdL(x) = 2d(x - d) + d2 is the tangent line passing (d, σ(d)). For u ≤ 0, x2 is monotonously
decreasing, the constraint we impose is equivalent to σL (u) = 2du - d2 ≥ 0, and with d ≤ 0, we
have d ≥ 2u. So we take d = max((l + u)/2, 2u). For l ≥ 0, x2 is monotonously increasing, and
15
Published as a conference paper at ICLR 2020
thus the constraint we impose is equivalent to σL (l) = 2dl - d2 ≥ 0, and with d ≥ 0, we have
d ≤ 2l. So we take d = max((l + u)/2, 2l). And for l < 0 < u, since σdL(0) = -d2 is negative for
d 6= 0 while d = 0 yields a valid lower bound, we take d = 0.
Square root For the square root function, σ(x) = √x. It is used the to compute a standard
derivation in layer normalization and its input is limited to be non-negative by the lower bounds of
x2, and thus l ≥ 0. σ(x) is concave, and thus we take the line passing the two endpoints as the lower
bound and take the tangent line passing ((l + u)/2, σ((l + u)/2)) as the upper bound.
C Linear Bounds of Multiplications and Divisions
We provide a mathematical proof of optimal parameters for linear bounds of multiplications used
in Sec. 3.3. We also show that linear bounds of division can be indirectly obtained from bounds of
multiplications and the reciprocal function.
For each multiplication, we aim to bound z = xy with two linear bounding planes zL = αLx +
βLy+γL and zU = αUx+βUy+γU, where x and y are both variables andx ∈ [lx, ux], y ∈ [ly, uy]
are concrete bounds of x, y obtained from previous layers, such that:
zL = αLx + βLy + γL ≤ z = xy ≤ zU = αUx + βUy + γU ∀(x, y) ∈ [lx , ux] × [ly, uy].
Our goal is to determine optimal parameters of bounding planes, i.e., αL, βL, γL, αU, βU, γU, such
that the bounds are as tight as possible.
C.1 Lower Bound of Multiplications
We define a difference function FL (x, y) which is the difference between the original function
z = xy and the lower bound zL = αLx + βLy + γL:
F L(x, y) = xy - (αLx + βLy + γL).
To make the bound as tight as possible, we aim to minimize the integral of the difference function
FL(x, y) on our concerned area (x, y) ∈ [lx, ux] × [ly, uy], which is equivalent to maximizing
VL= x∈[lx,ux] y∈[ly,uy
αLx + βLy + γL,
]
(7)
while FL (x, y) ≥ 0 (∀(x, y) ∈ [lx, ux] × [ly, uy]). For an optimal bounding plane, there must exist
a point (x0, y0) ∈ [lx, ux] × [ly, uy] such that FL(x0, y0) = 0 (otherwise we can validly increase γL
to make V L larger). To ensure that FL (x, y) ≥ 0 within the concerned area, we need to ensure that
the minimum value of FL (x, y) is non-negative. We show that we only need to check cases when
(x, y) is any of (lx, ly), (lx, uy), (ux, ly), (ux, uy), i.e., points at the corner of the considered area.
The partial derivatives of FL are:
∂FL
∂x
∂FL
∂y
y-αL
x - βL .
If there is (x1,y1) ∈ (lx, ux) × (ly,uy) such that FL(x1, y1) ≤ F(x, y) (∀(x, y) ∈ [lx,ux] ×
[ly,Uy]), dFXL(x1,y1)=喏(xι,yι) = 0 should hold true. Thereby dFL(χ,y),喏(χ,y) <
0 (∀(x, y) ∈ [lx, x1) × [ly, y1)), and thus FL(lx, ly) < FL(x1, y1) and (x1, y1) cannot be the point
with the minimum value of FL (x, y). On the other hand, if there is (x1, y1)(x1 = lx, y1 ∈ (ly, uy)),
i.e., on one border of the concerned area but not on any corner, ∂F- (xι, yι) = 0 should hold true.
Thereby,喏(x,y) = dFL(xι,y) = 0 (∀(x,y),x = xι = lχ), and FL(X1,y1) = FL(xι,ly)=
FL(lx, ly). This property holds true for the other three borders of the concerned area. Therefore,
other points within the concerned area cannot have smaller function value FL (x, y), so we only
16
Published as a conference paper at ICLR 2020
need to check the corners, and the constraints on FL(x, y) become
(FL(χo,yo)	=0
I FL(lχ,ly)	≥ 0
FL(lx, uy)	≥ 0 ,
III FL (ux, ly)	≥ 0
I F L(Uχ,Uy )	≥ 0
which is equivalent to
(IIγL = x0y0 - αLx0 - βLy0
lxly - αL(lx - x0) - βL(ly - y0) - x0y0 ≥ 0
lxUy - αL(lx - x0) - βL (Uy - y0) - x0y0 ≥ 0	.	(8)
Uxly - αL (Ux - x0) - βL(ly - y0) - x0y0 ≥ 0
UxUy - αL (Ux - x0) - βL(Uy - y0) - x0y0 ≥ 0
We substitute γL in Eq. (7) with Eq. (8), yielding
V L = V0 [(lx + Ux - 2x0)αL + (ly + Uy - 2y0)βL + 2x0y0],
where V0 = (UxT2(uyTy).
We have shown that the minimum function value FL (x, y) within the concerned area cannot appear
in (lx, Ux) × (ly, Uy), i.e., it can only appear at the border. When (x0, y0) is a point with a minimum
function value FL(x0, y0) = 0, (x0, y0) can also only be chosen from the border of the concerned
area. At least one of x0 = lx and x0 = Ux holds true.
If we take x0 = lx :
V1L = V0 [(Ux - lx)αL + (ly + Uy - 2y0)βL + 2lxy0].
And from Eq. (8) we obtain
L ≤ uxLy - lxy0 - βL(ly - yO)
α ≤	u - l	,
ux - x
L ≤ UxUy 一 lχyo — βL(uy 一 yo)
α ≤	u 一 l	,
ux 一 x
lx ≤ βL ≤ lx ⇔ βL = lx.
Then
V1L = V0[(ux 一 lx)αL + lx(ly + uy)],
(ux 一	Ix)α	≤	一lxy0	+ min(Uxly	一 β	(Iy	一 yO), uxuy 一 β	(Uy	一 yO))
=一lxy0 + min(Uxly 一 Lx(Ly 一 y0), uxuy 一 Lx(Uy 一 yO))
= (ux 一 lx ) min(ly , uy )
= (ux 一 lx)ly.
Therefore,
αL ≤ ly.
To maximize V-L, since now only αL is unknown in V-L and the coefficient of aL is V0 (Ux 一 lx) ≥ 0,
we take αL = ly, and then
V-L = VO(uxly +lxuy)
is a constant.
For the other case if we take xO = ux :
V2L = VO [(lx 一 ux)αL + (ly + uy 一 2yO)βL + 2uxyO],
L ≥ lxly 一 uxy0 一 βL(ly 一 y0)
α ≥	l 一 u	,
x 一 ux
17
Published as a conference paper at ICLR 2020
L ≥ LXuy - Uχy0 - βL(Uy - Jθ)
α ≥	l - u	,
X - uX
uX ≤ β ≤ uX ⇔ β = uX ,
V2 = V0 [(lX - uX )α + uX (ly + uy )],
(lX - uX )α ≤ -uX y0 + min(lX ly - β (ly - y0 ), lXuy - β (uy - y0 ))
= min(lX ly - uXly, lXuy - uXuy)
= (lX - uX ) max(ly , uy )
= (lX - uX )uy .
Therefore,
αL ≥ uy.
We take αL = uy similarly as in the case when x0 = lX, and then
V2 = V0 (lXuy + uXly).
We notice that V1L = V2L, so we can simply adopt the first one. We also notice that V1L , V2L are
independent of y0, so we may take any y0 within [ly , uy] such as y0 = ly. Thereby, we obtain the a
group of optimal parameters of the lower bounding plane:
f aL =Iy
βL = lX .
(Y L = -LXLy
C.2 Upper Bound of Multiplications
We derive the upper bound similarly. We aim to minimize
V U = V0[(LX + uX - 2x0)αU + (Ly + uy - 2y0)βU + 2x0y0],
where V0 = (UxT2(uyTy).
If we take x0 = LX :
V1U = V0 [(uX - LX)αU + (Ly + uy - 2y0)βU + 2LXy0],
U ≥ uxLy - lxy0 - βU (Iy - yO)
α ―	u - L	,
ux - x
U ≥ uxuy - Lχy0 - βU (uy - Jθ)
α ―	u - L	,
ux - x
Lx ≤ βU ≤ Lx ⇔ βU = Lx.
Then
V1U = V0[(ux - Lx)αU + Lx(Ly + uy)],
(ux - Lx )α ≥ -Lx y0 + max(ux Ly - β (Ly - y0 ), uxuy - β (uy - y0 ))
= max(ux Ly - LxLy , uxuy - Lxuy )
= (ux - Lx ) max(Ly, uy )
= (ux - Lx)uy.
Therefore,
αU ≥ uy.
To minimize V1U, we take αU = uy, and then
V1 = V0(LxLy + uxuy).
18
Published as a conference paper at ICLR 2020
For the other case if we take x0 = ux :
V2U = V0[(lx - ux)αU + (ly + uy - 2y0)βU + 2uxy0],
U ≤ LxLy - uxy0 - βU (Iy - yO)
α ≤	l - U	,
x - ux
U ≤ Lxuy - Uxyo - βU (Uy - Jθ)
α ―	l - u	,
x - Ux
Ux ≤ βU ≤ Ux ⇔ βU = Ux.
Therefore,
V2 = V0 [(Lx - Ux )α + Ux (Ly + Uy )],
(Lx -	Ux )α	≥ -Ux y0 + max(Lx Ly	- β	(Ly	- y0 ),	LxUy	- β	(Uy	- y0 ))
= max(Lx Ly - UxLy , LxUy - UxUy )
= (Lx - Ux ) min(Ly , Uy )
= (Lx - Ux )Ly .
Therefore,
αU ≤ Ly.
To minimize V2U, we take αU = Ly, and then
V2U = V0(LxLy +UxUy).
Since V1U = V2U, we simply adopt the first case. And V1U, V2U are independent of y0, so we may
take any y0 within [Ly, Uy] such as y0 = Ly. Thereby, we obtain a group of optimal parameters of the
upper bounding plane:
{aU = Uy
βU = Lx .
γ = -Lx Uy
C.3 Linear Bounds of Divisions
We have shown that closed-form linear bounds of multiplications can be derived. However, we
find that directly bounding Z = - is relatively more difficult. If We try to derive a lower bound
ZL = ɑLx + βLy + YL for Z = X as shown in Appendix C.1, the difference function is
FL(x,y) = X - (αLx + βLy + γL).
y
Itis possible that a minimum function value of FL (x, y) for (x, y) within the concerned area appears
at a point other than the corners. For example, for Lx = 0.05, Ux = 0.15, Ly = 0.05, Uy = 0.15, α =
10, β= -20, γ=2, the minimum function value of FL (x, y) for (x, y) ∈ [0.05, 0.15] × [0.05, 0.15]
appears at (0.1, 0.1) which is not a corner of [0.05, 0.15] × [0.05, 0.15]. This makes it more difficult
to derive closed-form parameters such that the constraints on FL (x, y) are satisfied. Fortunately,
we can bound Z = X indirectly by utilizing the bounds of multiplications and reciprocal functions.
We bound Z = X by first bounding a unary function y = 1 and then bounding the multiplication
z = xy.
D Tightness of Bounds by the Backward Process and Forward
Process
We have discussed that combining the backward process with a forward process can reduce com-
putational complexity, compared to the method with the backward process only. But we only use
the forward process for self-attention layers and do not fully use the forward process for all sub-
layers, because bounds by the forward process can be looser than those by the backward process.
19
Published as a conference paper at ICLR 2020
We compare the tightness of bounds by the forward process and the backward process respec-
tively. To illustrate the difference, for simplicity, we consider a m-layer feed-forward network
Φ(0) = x, y(l) = W(l) Φ(l-1) (x) + b(l), Φ(l)(x) = σ(y(l) (x))(0 < l ≤ m), where x is the
input vector, W(l) and b(l) are the weight matrix and the bias vector for the l-th layer respectively,
y(l) (x) is the pre-activation vector of the l-th layer, Φ(l)(x) is the vector of neurons in the l-th layer,
and σ(∙) is an activation function. Before taking global bounds, both the backward process and the
forward process bound Φ(jl) (x) with linear functions of x. When taking global bounds as Eq. (3)
and Eq. (4), only the norm of weight matrix is directly related to the in binary search for certified
lower bounds. Therefore, we try to measure the tightness of the computed bounds using the differ-
ence between weight matrices for lower bounds and upper bounds respectively. We show how it is
computed for the forward process and the backward process respectively.
D. 1 The Forward Process
For the forward process, we bound each neuron Φ(jl) (x) with linear functions:
Ωjl),Lx + θjl),L ≤ Φjl)(x) ≤ Ωjl),UX + θjl),U.
To measure the tightness of the bounds, We are interested in Ω(l),L, Ω(l),U, and also Ω(l),U - Ω(l),L.
Initially,
Ω⑼,L/U = i, θ⑼，L/U = 0, Ω⑼，U - Ω⑼，L = 0.
We can forward propagate the bounds of Φ(l-1)(X) to y(l)(X):
,y,LX + Θ(jl),y,L ≤ yj(l)(X) ≤
,y,UX + Θ(l),y,U
where
Ω(i),y,L∕u
j,:
Θ(I),y,L/U
=X Wjli Ω(l-1),L" + X Wj)Ω(J1ML,
Wj(,li) >0	Wj(,li)<0
X WjlieilT)，L/U + X Wjliθilτ),U4 + b(l).
Wj(,li) >0	Wj(,li) <0
With the global bounds of y(l) (X) that can be obtained with Eq. (3) and Eq. (4), we bound the
activation function:
α(jl),Ly(l)(X)+βj(l),L ≤σ(yj(l)(X)) ≤α(jl),Uy(l)(X)+βj(l),U.
And then bounds can be propagated from Φ(l-1)(X) to Φ(l) (X):
「	(l),L∕U c(l),y,L∕U	c(),L∕u	C
,(l),L∕U =	α	αj	%:	αj	≥ 0
j,:	= α α(l),L∕UΩ(l),y,U∕L	ɑ(l),L∕U < 0
αj	j,:	αj	< 0
(l),L∕U Θ(l),y,L∕U + β(l),L∕U
Θ(l),L∕U = αj Θj	+ βj
Θj	= α(l),L∕U Θ(l),y,U∕L + β(l),L∕U
(jl),L∕U ≥ 0
(jl),L∕U < 0
Therefore,
Ωj,),U - Ωjl),L = (Qjl),U - αjl),L)IWjl)∣(Ω(J),U - Ω(J),L)
illustrates how the tightness of the bounds is changed from earlier layers to later layers.
(9)
D.2 The Backward Process and Discussions
For the backward process, we bound the neurons in the l-th layer with linear functions of neurons in
a previous layer, the l0-th layer:
φ(l,l0),L = Λjl,l0),Lφ(lO)(X) + ∆jl,l0),L ≤ φ(l)(x) ≤ Λ(l,l0),uφ(l')(x) + ∆jl,l0),u = Φ(l,l0),U.
We have shown in Sec. 3.1 how such bounds can be propagated to l0 = 0, for the case when the
input is sequential. For the nonsequential case we consider here, it can be regarded as a special
case when the input length is 1. So we can adopt the method in Sec. 3.1 to propagate bounds
20
Published as a conference paper at ICLR 2020
for the feed-forward network we consider here. We are interested in Λ(l,l0),L, Λ(l,l0),U and also
Λ(l,l ),U - Λ(l,l ),L. Weight matrices of linear bounds before taking global bounds are Λ(l,0),L
and Λ(l,0),U which are obtained by propagating the bounds starting from Λ(l,l),L = Λ(l,l),U = I.
According to bound propagation described in Sec. 3.2,
Λ(l,l0-1),U Λ(l,l0-1),L	(l0),U Λ(l,l0),U Λ(l,l0),L	(l0),L Λ(l,l0),L Λ(l,l0),U W(l0) 10
A:,j	- A：,j	=(αj (A,j,+ - A,j,- )-αj (A,j,+ - A,j,- ))W (10)
illustrates how the tightness bounds can be measured during the backward bound propagation until
l0 = 0.
There is a W(l0) in Eq. (10) instead of ∣W(10)∣ in Eq. (9). The norm of (Ωjl),U - Ωjl),L) in Eq.
(9) can quickly grow large as l increases during the forward propagation when kWj(l) k is greater
than 1, while this generally holds true for neural networks to have kWj(l) k greater than 1 in feed-
(l0)
forward layers. While in Eq. (10), Wj can have both positive and negative elements and tends to
allow cancellations for different Wj(,li0), and thus the norm of (A:(,lj,l0-1),U - A:(,lj,l0-1),L) tends to be
smaller. Therefore, the bounds computed by the backward process tend to be tighter than those by
the forward framework, which is consistent with our experiment results in Table 3.
E Impact of Modifying the Layer Normalization
The original Transformers have a layer normalization after the embedding layer, and two layer
normalization before and after the feed-forward part respectively in each Transformer layer. We
modify the layer normalization, f (x) = W(X - μ)∕σ + b, where X is d-dimensional a vector to
be normalized, μ and σ are the mean and standard derivation of {xi} respectively, and W and b are
J(i∕d) Pd=I(Xi-μ)2
gain and bias parameters respectively. σ
+ s where s is a smoothing
constant. It involves (Xi — μ)2 whose linear lower bound is loose and exactly 0 when the range of the
Xi - μ crosses 0. When the 'p-norm of the perturbation is relatively larger, there can be many Xi - μ
with ranges crossing 0, which can cause the lower bound of σ to be small and thereby the upper
bound of fi(X) to be large. This can make the certified bounds loose. To tackle this, we modify the
layer normalization into f (x) = w(x - μ)+ b by removing the standard derivation term. We use an
experiment to study the impact of this modification. We compare the clean accuracies and certified
bounds of the models with modified layer normalization to models with standard layer normalization
and with no layer normalization respectively. Table 5 presents the results. Certified lower bounds
of models with no layer normalization or our modification are significantly tighter than those of
corresponding models with the standard layer normalization. Meanwhile, the clean accuracies of
the models with our modification are comparable with those of the models with the standard layer
normalization (slightly lower on Yelp and slightly higher on SST). This demonstrates that it appears
to be worthwhile to modify the layer normalization in Transformers for easier verification.
21
Published as a conference paper at ICLR 2020
Dataset	N	LayerNorm	Acc.	'p	Upper Min	Avg	Lower Min Avg	Ours vs Upper Min	Avg
Yelp	1	Standard	91.7	~~eΓ '2 '∞	189.934^^199.265 15.125	15.384 2.001	3.066	0.010^^0.022 0.008	0.019 0.002	0.005	5.3E-5	1.1E-4 5.5E-4	1.3E-3 8.7E-4	1.7E-3
		None	91.4	~'Γ~ '2 '∞	8.044	12.948 0.580	0.905 0.086	0.127	1.360^^1.684 0.363	0.447 0.033	0.040	17%	13% 63%	49% 38%	32%
		Ours	91.5	~'Γ '2 '∞	9.085	13.917 0.695	1.005 0.117	0.155	1.423^^1.809 0.384	0.483 0.034	0.043	16%	13% 55%	48% 29%	27%
	2	Standard	92.0	~'Γ~ '2 '∞	190.476^^201.092 15.277	15.507 2.022	2.901	0.002^^0.004 0.001	0.002 0.000	0.000	1.2E-5	1.8E-5 9.0E-5	1.6E-4 9.5E-5	1.3E-4
		None	91.5	~'Γ '2 '∞	8.112	15.225 0.587	1.042 0.081	0.140	0.512^^0.631 0.123	0.154 0.010	0.013	6%	4% 21%	15% 13%	9%
		Ours	91.5	~'Γ~ '2 '∞	10.228	15.452 0.773	1.103 0.122	0.161	0.389^^0.512 0.116	0.149 0.010	0.013	4%	3% 15%	14% 9%	8%
SST	1	Standard	83.0	'2 '∞	190.777^^194.961 15.549	15.630 2.241	2.504	0.008^^0.015 0.006	0.013 0.001	0.003	4.2E-5	7.8E-5 4.1E-4	8.2E-4 5.2E-4	1.2E-3
		None	83.0	~~er '2 '∞	6.921	8.417 0.527	0.628 0.089	0.109	2.480^^2.659 0.411	0.447 0.032	0.035	36%	32% 78%	71% 36%	32%
		Ours	83.2	~'Γ '2 '∞	7.418	8.849 0.560	0.658 0.091	0.111	2.503^^2.689 0.418	0.454 0.033	0.036	34%	30% 75%	69% 36%	32%
	2	Standard	82.5	~'Γ~ '2 '∞	191.742^^196.365 15.554	15.649 2.252	2.513	0.002^^0.004 0.001	0.003 0.000	0.000	9.6E-6	1.9E-5 7.0E-5	1.7E-4 6.6E-5	1.9E-4
		None	83.5	~'Γ '2 '∞	6.742	8.118 0.515	0.610 0.085	0.103	1.821 ~~1.861 0.298	0.306 0.023	0.024	27%	23% 58%	50% 28%	23%
		Ours	83.5	~'Γ~ '2 '∞	6.781	8.367 0.520	0.628 0.085	0.105	1.919^^1.969 0.305	0.315 0.024	0.024	28%	24% 59%	50% 28%	23%
Table 5: Clean accuracies, upper bounds, certified lower bounds by our method of models with
different layer normalization settings.
22