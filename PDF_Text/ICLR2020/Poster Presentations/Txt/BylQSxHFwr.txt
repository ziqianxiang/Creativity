Published as a conference paper at ICLR 2020
AtomNAS:	Fine-Grained End-to-End Neural
Architecture Search
Jieru Mei1*, YingWei Li1*, XiaoChen Lian2, Xiaojie Jin2, Linjie Yang2,
Alan Yuille1 & Jianchao Yang2
1	Johns Hopkins University
2	ByteDance AI Lab
meijieru@gmail.com, yingwei.li@jhu.edu, {xiaochen.lian, jinxiaojie, linjie.yang}@bytedance.com,
alan.l.yuille@gmail.com, yangjianchao@bytedance.com
Ab stract
Search space design is very critical to neural architecture search (NAS) algo-
rithms. We propose a fine-grained search space comprised of atomic blocks, a
minimal search unit that is much smaller than the ones used in recent NAS algo-
rithms. This search space allows a mix of operations by composing different types
of atomic blocks, while the search space in previous methods only allows homo-
geneous operations. Based on this search space, we propose a resource-aware
architecture search framework which automatically assigns the computational re-
sources (e.g., output channel numbers) for each operation by jointly considering
the performance and the computational cost. In addition, to accelerate the search
process, we propose a dynamic network shrinkage technique which prunes the
atomic blocks with negligible influence on outputs on the fly. Instead of a search-
and-retrain two-stage paradigm, our method simultaneously searches and trains
the target architecture. Our method achieves state-of-the-art performance under
several FLOPs configurations on ImageNet with a small searching cost. We open
our entire codebase at: https://github.com/meijieru/AtomNAS.
1	Introduction
Human-designed neural networks are already surpassed by machine-designed ones. Neural Ar-
chitecture Search (NAS) has become the mainstream approach to discover efficient and powerful
network structures (Zoph & Le (2017); Pham et al. (2018); Tan et al. (2019); Liu et al. (2019a)).
Although the tedious searching process is conducted by machines, humans still involve extensively
in the design of the NAS algorithms. Designing of search spaces is critical for NAS algorithms and
different choices have been explored. Cai et al. (2019) and Wu et al. (2019) utilize supernets with
multiple choices in each layer to accommodate a sampled network on the GPU. Chen et al. (2019b)
progressively grow the depth of the supernet and remove unnecessary blocks during the search. Tan
& Le (2019a) propose to search the scaling factor of image resolution, channel multiplier and layer
numbers in scenarios with different computation budgets. Stamoulis et al. (2019a) propose to use
different kernel sizes in each layer of the supernet and reuse the weights of larger kernels for small
kernels. Howard et al. (2019); Tan & Le (2019b) adopts Inverted Residuals with Linear Bottle-
necks (MobileNetV2 block) (Sandler et al., 2018), a building block with light-weighted depth-wise
convolutions for highly efficient networks in mobile scenarios.
However, the proposed search spaces generally have only a small set of choices for each block.
DARTS and related methods (Liu et al., 2019a; Chen et al., 2019b; Liang et al., 2019) use around
10 different operations between two network nodes. Howard et al. (2019); Cai et al. (2019); Wu
et al. (2019); Stamoulis et al. (2019a) search the expansion ratios in the MobileNetV2 block but still
limit them to a few discrete values. We argue that search space of finer granularity is critical to find
* This work was done during the internship program at Bytedance.
1
Published as a conference paper at ICLR 2020
optimal neural architectures. Specifically, the searched building block in a supernet should be as
small as possible to generate the most diversified model structures.
We revisit the architectures of state-of-the-art networks (Howard et al. (2019); Tan & Le (2019b);
He et al. (2016)) and discover a commonly used building structure: convolution - channel-wise
operation - convolution. We reinterpret this building structure as an ensemble of computationally
independent blocks, which we call atomic blocks. As the minimum search unit, the atomic block
constitutes a much larger and more fine-grained search space, within which we are able to search for
mixed operations (e.g., convolutions with different kernel sizes and their channel numbers).
For the efficient exploration of the new search space, we propose a NAS framework named Atom-
NAS which applies network pruning techniques to architecture search. Specifically, we start from an
initial large supernet and rewrite every convolution - channel-wise operation - convolution structure
of it in the form the weighted sum of atomic blocks; the weights reflect the contribution of the atomic
blocks to the network capacity and are called importance factors. For each atomic block, a penalty
term in proportion to its FLOPs is enforced on its importance factor; effectively, the penalty makes
AtomNAS favor atomic blocks with less FLOPs. By minimizing the combination of the original
network loss and the total penalty on the weights, AtomNAS is able to learn both the parameters of
the network and the weights of the atomic blocks. At the end of the learning, atomic blocks with
very small weights (e.g., < 0.001) are removed from the network and we obtain the final network
which has fewer FLOPs. Since the pruned atomic blocks have little contribution to the network
output due to their negligible weights, the final network does not need to be retrained or finetuned.
Training on the large supernet is computationally demanding. We observe that for many pruned
atomic blocks, their weights diminish at the early stage of learning and never “revive” throughout
the rest of learning. We propose a dynamic network shrinkage technique which removes those
atomic blocks on the fly and greatly reduces the run time of AtomNAS.
In our experiment, our method achieves 75.9% top-1 accuracy on ImageNet dataset around 360M
FLOPs, which is 0.9% higher than state-of-the-art model (Stamoulis et al., 2019a). By further in-
corporating additional modules, our method achieves 77.6% top-1 accuracy. It outperforms MixNet
by 0.6% using 363M FLOPs, which is a new state-of-the-art under the mobile scenario.
In summary, the major contributions of our work are:
1.	We design a fine-grained search space which includes the exact number of channels and
mixed operations (e.g., combination of different convolution kernels).
2.	We propose an NAS framework, AtomNAS. Within the framework, an efficient end-to-end
NAS algorithm is proposed which can simultaneously search the network architecture and
train the final model. No finetuning is needed after the algorithm finishes.
3.	With the proposed search space and AtomNAS, we achieve state-of-the-art performance on
ImageNet dataset under mobile setting.
2	Related Work
2.1	Neural Architecture Search
Recently, there is a growing interest in automated neural architecture design. Reinforce learning
based NAS methods (Zoph & Le, 2017; Tan et al., 2019; Tan & Le, 2019b;a) are usually compu-
tational intensive, thus hampering its usage with limited computational budget. To accelerate the
search procedure, ENAS (Pham et al., 2018) represents the search space using a directed acyclic
graph and aims to search the optimal subgraph within the large supergraph. A training strategy of
parameter sharing among subgraphs is proposed to significantly increase the searching efficiency.
The similar idea of optimizing optimal subgraphs within a supergraph is also adopted by Liu et al.
(2019a); Jin et al. (2019); Xu et al. (2020); Wu et al. (2019); Guo et al. (2019); Cai et al. (2019).
Stamoulis et al. (2019a); Yu et al. (2020) further share the parameters of different paths within a
block using super-kernel representation. A prominent disadvantage of the above methods is that
their coarse search spaces only support selecting one out of a set of choices (e.g., selecting one ker-
nel size from {3, 5, 7}). MixNet tries to benefit from mixed operations by using a predefined set of
mixed operations {{3}, {3, 5}, {3, 5, 7}, {3, 5, 7, 9}}, where the channels are equally distributed
2
Published as a conference paper at ICLR 2020
Figure 1: Illustration of the ensemble perspective. Arrow means operators. The structure of two
convolutions joined by a channel-wise operation is mathematically equivalent to the ensemble of
multiple atomic blocks, according to Eq. (2). Colored rectangles represent tensors, with numbers
inside indicating their channel numbers; The shaded path on the right is one example of atomic
block.
among different kernel sizes. Due to this limitation, it is difficult to learn optimal architectures under
computational resource constraints. On the contrary, our method takes advantage of the fine-grained
search space and is able to search for more flexible network architectures satisfying various resource
constraints. The fine-grained search space proposed in this paper is exponentially larger than pre-
vious search space. For reference, the total number of possible structures within the experiment is
around 10162, compared with 1021 for FBNet. Recently, to improve the final performance of the
searched architectures, Yu et al. (2020) utilizes knowledge distillation which is orthogonal to our
method. It could be easily integrated into our method by Eq. (5) thanks to the end-to-end learning
paradigm of our method.
2.2	Network pruning
Assuming that many parameters in the network are unnecessary, network pruning methods start
from a computation-intensive model, identify the unimportant connections and remove them to get a
compact and efficient network. Early method (Han et al., 2016) simultaneously learns the important
connections and weights. However, non-regularly removing connections in these works makes it
hard to achieve theoretical speedup ratio on realistic hardwares due to extra overhead in caching
and indexing. To tackle this problem, structured network pruning methods (He et al., 2017b; Liu
et al., 2017; Luo et al., 2017; Ye et al., 2018; Gordon et al., 2018) are proposed to prune structured
components in networks, e.g. the entire channel and kernel. In this way, empirical acceleration can
be achieved on modern computing devices. Liu et al. (2017); Ye et al. (2018); Gordon et al. (2018)
encourage channel-level sparsity by imposing the L-1 regularizer on the channel dimension, which
is also used by our method. Recently, Liu et al. (2019b) show that in structured network pruning,
the learned weights are unimportant. This suggests structured network pruning is actually a neural
architecture search focusing on channel numbers. Our method jointly searches the channel numbers
and a mix of operations, which is a much larger search space.
3	ATOMNAS
We formulate our neural architecture search method in a fine-grained search space with the atomic
block used as the basic search unit. An atomic block is comprised of two convolutions connected by
a channel-wise operation. By stacking atomic blocks, we obtain larger building blocks (e.g. residual
block and MobileNetV2 block proposed in a variety of state-of-the-art models including ResNet,
MobileNet V2/V3 (He et al., 2016; Howard et al., 2019; Sandler et al., 2018). In Section 3.1, We first
show larger network building blocks (e.g. MobileNetV2 block) can be represented by an ensembles
of atomic blocks. Based on this view, we propose a fine-grained search space using atomic blocks. In
Section 3.2, we propose a resource-aware atomic block selection method for end-to-end architecture
search. Finally, we propose a dynamic network shrinkage technique in Section 3.3, which greatly
reduces the search cost.
3
Published as a conference paper at ICLR 2020
3.1	Fine-Grained Search Space
Under the typical block-wise NAS paradigm (Tan et al., 2019; Tan & Le, 2019b), the search space
of each block in a neural network is represented as the Cartesian product C = Qi=1 Pi , where each
Pi is the set of all choices of the i-th configuration such as kernel size, number of channels and type
of operation. For example, C = {conv, depth-wise conv, dilated conv} × {3, 5} × {24, 32, 64, 128}
represents a search space of three types of convolutions by two kernel sizes and four options of
channel number. A block in the resulting model can only pick one convolution type from the three
and one output channel number from the four values. This paradigm greatly limits the search space
due to the few choices of each configuration. Here we present a more fine-grained search space by
decomposing the network into smaller and more basic building blocks.
We denote fc0,c(X) as a convolution operator, where X is the input tensor and c, c0 are the input and
output channel numbers respectively. A wide range of manually-designed and NAS architectures
share a structure that joins two convolutions by a channel-wise operation:
Y = (fC00,c0 ◦ g ◦ fo0,c) (X)	(1)
where g is a channel-wise operator. For example, in VGG (Simonyan & Zisserman, 2015) and a
Residual Block (He et al., 2016), fo and f1 are convolutions and g is one of Maxpool, ReLU and
BN-ReLU; in a MobileNetV2 block (Sandler et al., 2018), fo and f1 are point-wise convolutions and
g is depth-wise convolution with BN-ReLU in the MobileNetV2 block. Eq. (1) can be reformulated
as follows:
0
c
Y = X (fC”,1[i, ：] ◦ g[i, ：] ◦ f1,ct,i])(x),	⑵
i=1
where fo1,c[:, i] is the i-th convolution kernel of fo, g[i, :] is the operator of the i-th channel of g,
c00 1	0
and {f1c ,1 [i, :]}ic=1 are obtained by splitting the kernel tensor of f1 along the the input channel
dimension. Each term in the summation can be seen as a computationally independent block, which
is called atomic block. Fig. (1) demonstrate this reformulation. By determining whether to keep
each atomic block in the final model individually, the search of channel number c0 is enabled through
channel selection, which greatly enlarges the search space.
This formulation also naturally includes the selection of operators. To gain a better understanding,
we first generalize Eq. (2) as:
c0
Y=X f1ci00,1 ◦ gi ◦ fo1i,c (X).	(3)
i=1
Note the array indices i are moved to subscripts. In this formulation, we can use different types of
operators for foi, f1i and gi ; in other words, fo, f1 and g can each be a combination of different
operators and each atomic block can use different operators such as convolutions with different
kernel sizes.
Formally, the search space is formulated as a supernet which is built based on the structure in Eq. (1);
such structure satisfies Eq. (3) and thus can be represented by atomic blocks; each of fo, f1 and g is
a combination of operators. The new search space includes some state-of-the-art network architec-
tures. For example, by allowing g to be a combination of convolutions with different kernel sizes,
the MixConv block in MixNet (Tan & Le, 2019b) becomes a special case in our search space. In
addition, our search space facilitates discarding any number of channels in g, resulting in a more
fine-grained channel configuration. In comparison, the channel numbers are determined heuristi-
cally in Tan & Le (2019b).
3.2	Resource-aware atomic block Search
In this work, we adopt a differentiable neural architecture search paradigm where the model structure
is discovered in a full pass of model training. With the supernet defined above, the final model can
be produced by discarding part of the atomic blocks during training. Following DARTS (Liu et al.
4
Published as a conference paper at ICLR 2020
(2019a)), we introduce a importance factor α to scale the output of each atomic block in the supernet.
Eq. (3) then becomes
0
c
Y = Xαi f1ci00,1 ◦gi ◦ f01i,c (X).	(4)
i=1
c00 1	1 c
Here, each αi is tied with an atomic block comprised of three operators f1ci ,1,gi and f01i,c. The
importance factors are learned jointly with the network weights. Once the training finishes, the
atomic blocks that have negligible effect (i.e., those with factors smaller than a threshold) on the
network output are discarded.
We still need to address two issues related to the importance factors ɑ∕s. The first issue is where
in the supernet we should put the α? Let’s first consider the case when g only contains linear
operations, e.g., convolution, batch normalization and linear activation like ReLU. If g contains at
least one BN layer, The scaling parameters in the BN layers can be directly used as such importance
factors (Liu et al. (2017)). If g has no BN layers, which is rare, we can place α anywhere between
f0 and f1 ; however, we need to apply regularization terms to the weights of f0 and f1 (e.g., weight
decays) in order to prevent weights in f0 and f1 from getting too large and canceling the effect of α.
When g contains non-linear operations, e.g., Swish activation and Sigmoid activation, we can only
put α behind f1 .
The second issue is how to avoid performance deterioration after discarding some of the atomic
blocks. For example, DARTS discards operations with small scale factors after iterative training
of model parameters and scale factors. Since the scale factors of the discarded operations are not
small enough, the performance of the network will be affected which needs re-training to adjust the
weights again. In order to maintain the performance of the supernet after dropping some atomics
blocks, the importance factors α of those atomic blocks should be sufficiently small. Inspired by
the channel pruning work in Liu et al. (2017), we add L1 norm penalty loss on α, which effectively
pushes many importance factors to near-zero values. At the end of learning, atomic blocks with α
close to zero are removed from the supernet. Note that since the BN scales change more dramatically
during training due to the regularization term, the running statistics of BNs might be inaccurate and
needs to be calculated again using the training set.
With the added regularization term, the training loss is
L = E + λ X Ci∣αi∣,	(5)
i∈S
Ci = ^i/ X Ck	(6)
k∈S
where λ is the coefficient of L1 penalty term, S is the index set of all atomic blocks, and E is
the conventional training loss (e.g., cross-entropy loss combined with the regularization term like
weight decay and distillation loss.). ∣α∕ is weighted by coefficient Ci which is proportional to the
computation cost of i-th atomic block, i.e. Ci. By using computation costs aware regularization, we
encourage the model to learn network structures that strike a good balance between accuracy and
efficiency. In this paper, we use FLOPs as the criteria of computation cost. Other metrics such as
latency and energy consumption can be used similarly. As a result, the whole loss function L trades
off between accuracy and FLOPs.
3.3	Dynamic Network Shrinkage
Usually, the supernet is much larger than the final search result. We observe that many atomic blocks
become “dead” starting from the early stage of the search, i.e., their importance factors α are close to
zero till the end of the search. To utilize computational resources more efficiently and speed up the
search process, we propose a dynamic network shrinkage algorithm which cuts down the network
architecture by removing atomic blocks once they are deemed “dead”.
We adopt a conservative strategy to decide whether an atomic block is “dead”: for importance factors
α, we maintain its momentum α which is updated as
α - βα + (i - β)αt,	(7)
5
Published as a conference paper at ICLR 2020
Figure 2: FLOPs change of the supernet during the searching and training for AtomNAS-C. The
crossed-out region corresponds to the saved computation compared to training the supernet without
the dynamic shrinkage. The region in yellow corresponds to the extra cost compared with training
the final model from scratch, the cost of which is the region below the red dashed line.
Initialize the supernet and the exponential moving average;
while epoch ≤ max_epoch do
Update network weights and importance factors α by minimizing the loss function L ;
Update the a by Eq.(7);
if Total FLOPs of dead blocks ≥ ∆ then
I Remove dead blocks from the supernet;
end
Recalculate BN’s statistics by forwarding some training examples;
Validate the performance of the current supernet;
end
Algorithm 1: Dynamic network shrinkage
where αt is the importance factors at t-th iteration and β is the decay term. An atomic block is
considered “dead” if both a and at are smaller than a threshold, which is set to 0.001 throughout
experiments.
Once the total FLOPs of “dead” blocks reach a predefined threshold, we remove those blocks from
the supernet. As discussed above, we recalculate BN’s running statistics before deploying the net-
work. The whole training process is presented in Algorithm 1.
We show the FLOPs of a sample network during the search process in Fig. 2. We start from a
supernet with 1521M FLOPs and dynamically discard “dead” atomic blocks to reduce search cost.
The overall search and train cost only increases by 17.2% compared to that of training the searched
model from scratch.
4	Experiment
We first describe the implementation details in Section 4.1 and then compare AtomNAS with pre-
vious state-of-the-art methods under various FLOPs constraints in Section 4.2. In Section 4.3, we
provide more detailed analysis about AtomNAS. Finally, in Section 4.4, we demonstrate the trans-
ferability of AtomNAS networks by evaluating them on detection and instance segmentation tasks.
4.1	Implementation Details
The architecture of the supernet we use for the experiments is shown in table on the right of Fig.
3. The supernet contains 21 AtomNAS blocks, the searchable block in our supernet; the picture
on the right of Fig. 3 illustrates the structure of an AtomNAS block, where f0 is a 1 × 1 pointwise
convolutions that expands the input channel number from C to 3 × 6C; g is amix of three depth-wise
6
Published as a conference paper at ICLR 2020
			L_.		Input Shape	Block	f	n stride 		2242 × 3	3x3 conv 32(16)	1	2
					I	××3	× 3	jXj COnV	ON(∙LU)	J.	N I	1122	× 32(16)	3x3 MB	16	1	1
		1x1 pointwise		!	；u	1122 × 16	searchable 24	4 2 得	562	×	24	searchable	40	4	2 自	282	×	40	searchable	80	4	2 I 1	142	×	80	searchable	96	4	1 I ∞	142	×	96	searchable	192	4	2
	3x3 dw	5x5 dw		7x7 dw	
		1x1 pointwise		!	
				—	I	72	× 192	searchable	320	1	1 	1	72	× 320	avgpool	-	1	1 1280	fc	1000	1	-
Figure 3: (Left) The searchable block of the supernet. fo and fι are fixed to 1 X 1 pointwise
convolutions; g here is a mix of three convolutions with kernel sizes of 3 × 3, 5 × 5 and 7 × 7.
fo expands the input channel number from C to 18C and fι projects the channel number to the
output channel number. If the output dimension stays the same as the input dimension, We use a
skip connection to add the input to the output. (Right) Architecture of the supernet. Column-Block
denotes the block type; MB denotes MobileNetV2 block; ”searchable” means a searchable block
shown on the left. Column-f denotes the output channel number of a block. Column-n denotes the
number of blocks. Column-s denotes the stride of the first block in a stage. The output channel
numbers of the first convolution are 16 for AtomNAS-A, 32 for AtomNAS-B and AtomNAS-C.
convolutions with kernel sizes of3 × 3, 5 × 5 and 7× 7, and f1 is another 1 × 1 pointwise convolutions
that projects the channel number to the output channel number. Similar to MobileNetV2 (Sandler
et al., 2018), if the output dimension stays the same as the input dimension, we use a skip connection
to add the input to the output. AtomNAS block is effectively an ensemble of 3 × 6C atomic blocks,
whose underlying search space covers the MobileNetV2 block (Sandler et al., 2018) and its multi-
kernel variant, MixConv (Tan & Le, 2019b). Within AtomNAS block, we are able to optimize the
distribution of computation resources (i.e., channel numbers) among the three types of depth-wise
convolution.
We use the same training configuration (e.g., RMSProp optimizer, EMA on weights and exponential
learning rate decay) as Tan et al. (2019); Stamoulis et al. (2019a) and do not use extra data aug-
mentation such as MixUp (Zhang et al., 2018) and AutoAugment (Cubuk et al., 2018). We find that
using this configuration is sufficient for our method to achieve good performance. Our results are
shown in Table 1 and Table 3. When training the supernet, we use a total batch size of 2048 on 32
Tesla V100 GPUs and train for 350 epochs. For our dynamic network shrinkage algorithm, we set
the momentum factor β in Eq. (7) to 0.9999. At the beginning of the training, all of the weights
are randomly initialized. To avoid removing atomic blocks with high penalties (i.e., FLOPs) pre-
maturely, the weight of the penalty term in Eq. (5) is increased from 0 to the target λ by a linear
scheduler during the first 25 epochs. By setting the weight of the L1 penalty term λ to be 1.8 × 10-4,
1.2 × 10-4 and 1.0 × 10-4 respectively, we obtain networks with three different sizes: AtomNAS-A,
AtomNAS-B, and AtomNAS-C. They have the similar FLOPs as previous state-of-the-art networks
under 400M: MixNet-S (Tan & Le, 2019b), MixNet-M (Tan & Le, 2019b) and SinglePath (Sta-
moulis et al., 2019a). In Appendix A, we visualize the architecture of AtomNAS-C.
4.2	Experiments on ImageNet
We apply AtomNAS to search high performance light-weight model on ImageNet 2012 classifica-
tion task (Deng et al., 2009). Table 1 compares our methods with previous state-of-the-art models,
either manually designed or searched.
With models directly produced by AtomNAS, our method achieves the new state-of-the-art under
all FLOPs constraints. Especially, AtomNAS-C achieves 75.9% top-1 accuracy with only 360M
FLOPs, and surpasses all other models, including models like PDARTS and DenseNAS which have
much higher FLOPs.
7
Published as a conference paper at ICLR 2020
(％WB,Inoov'doɪ 怎 uaBΠII
力 %757473
—AtomNAS
-♦- AtomNAS+t
▼ MobΠeNetV2
“ ShuffleNetV2
• FBNet
■ Proxyless
• DARTS
▲ SinglePath
< MnasNett
► MjxNett
□ EfficientNett

72
200	300	400	500
FLOPs(M)
Figure 4: FLOPs versus accuracy on ImageNet. * means methods use extra techniques like SWish
activation and Squeeze-and-Excitation module.
Techniques like SWish activation function (Ramachandran et al., 2018) and Squeeze-and-Excitation
(SE) module (Hu et al., 2018) consistently improve the accuracy With marginal FLOPs cost. For a
fair comparison With methods that use these techniques, We directly modify the searched netWork by
replacing all ReLU activation With SWish and add SE module With ratio 0.5 to every block and then
retrain the netWork from scratch. Note that unlike other methods, We do not search the configuration
of SWish and SE, and therefore the performance might not be optimal. Extra data augmentations
such as MixUp and AutoAugment are still not used. We train the models from scratch With a total
batch size of 4096 on 32 Tesla V100 GPUs for 250 epochs.
Simply adding these techniques improves the results further. AtomNAS-A+ achieves 76.3% top-
1 accuracy With 260M FLOPs, Which outperforms many heavier models including MnasNet-A2.
Without extra data augmentations, it performs as Well as Efficient-B0 (Tan & Le, 2019a) by using
130M less FLOPs. It also outperforms the previous state-of-the-art MixNet-S by 0.5%. In addition,
AtomNAS-C+ improves the top-1 accuracy on ImageNet to 77.6%, surpassing previous state-of-
the-art MixNet-M by 0.6% and becomes the overall best performing model under 400M FLOPs.
Fig. 4 visualizes the top-1 accuracy on ImageNet for different models. It’s clear that our fine-grained
search space and the end-to-end resource-aWare search method boost the performance significantly.
4.3	Analysis
4.3.1	Resource-Aware Regularization
To demonstrate the effectiveness of the resource-aWare regularization in Section 3.2, We compare
it With a baseline Without FLOPs-related coefficients ci , Which is Widely used in netWork pruning
(Liu et al., 2017; He et al., 2017b). Table 2 shoWs the results. First, by using the same L1 penalty
coefficient λ = 1.0 × 10-4, the baseline achieves a netWork With similar performance but using
much more FLOPs; then by increasing λ to 1.5 × 10-4, the baseline obtain a netWork Which has
similar FLOPs but inferior performance (i.e., about 1.0% loWer). In Fig. 6b We visualized the ratio
of different types of atomic blocks of the baseline netWork obtained by λ = 1.5 × 10-4. The baseline
netWork keeps more atomic blocks in the earlier blocks, Which have higher computation cost due to
higher input resolution. On the contrary, AtomNAS is aWare of the resource constraint, thus keeping
more atomic blocks in the later blocks and achieving much better performance.
4.3.2	BN Recalibration
As the BN’s running statistics might be inaccurate as explained in Section 3.2 and Section 3.3, We
re-calculate the running statistics of BN before inference, by forWarding 131k randomly sampled
training images through the netWork. Table 3 shoWs the impact of the BN recalibration. The top-1
accuracies of AtomNAS-A, AtomNAS-B, and AtomNAS-C on ImageNet improve by 1.4%, 1.7%,
and 1.2% respectively, Which clearly shoWs the benefit of BN recalibration.
8
Published as a conference paper at ICLR 2020
Table 1: Comparision with state-of-the-arts on ImageNet under the mobile setting. * denotes meth-
ods using extra network modules such as SWiSh activation and SqUeeze-and-Excitation module. ^ de-
notes using extra data augmentation such as MixUP and AutoAugment. * denotes models searched
and trained simultaneously.
Model	Parameters	FLOPs	Top-1(%)	Top-5(%)
MobileNetV1 (Howard et al., 2017)	4.2M	575M	70.6	89.5
MobileNetV2 (Sandler et al., 2018)	3.4M	300M	72.0	91.0
MobileNetV2 (our impl.)	3.4M	301M	73.6	91.5
MobileNetV2 (1.4)	6.9M	585M	74.7	92.5
ShuffleNetV2 (Ma et al., 2018)	3.5M	299M	72.6	-
ShuffleNetV2 2×	7.4M	591M	74.9	-
FBNet-A (Wu et al., 2019)	4.3M	249M	73.0	-
FBNet-C	5.5M	375M	74.9	-
Proxyless (mobile) (Cai et al., 2019)	4.1M	320M	74.6	92.2
SinglePath (Stamoulis et al., 2019a)	4.4M	334M	75.0	92.2
NASNet-A (Zoph & Le, 2017)	5.3M	564M	74.0	91.6
DARTS (second order) (Liu et al., 2019a)	4.9M	595M	73.1	-
PDARTS (cifar 10) (Chen et al., 2019b)	4.9M	557M	75.6	92.6
DenseNAS-A (Fang et al., 2019)	7.9M	501M	75.9	92.6
FairNAS-A (Chu et al., 2019b)	4.6M	388M	75.3	92.4
AtomNAS-A*	3.9M	258M	74.6	92.1
AtomNAS-B*	4.4M	326M	75.5	92.6
AtomNAS-C*	4.7M	360M	75.9	92.7
SCARLET-A* (Chu et al., 2019a)	6.7M	365M	76.9	93.4
MnasNet-A1* (Tan et al., 2019)	3.9M	312M	75.2	92.5
MnasNet-A2*	4.8M	340M	75.6	92.7
MixNet-S* (Tan & Le, 2019b)	4.1M	256M	75.8	92.8
MixNet-M*	5.0M	360M	77.0	93.3
EffiCientNet-B0S(Tan & Le, 2019a)	5.3M	390M	76.3	93.2
SE-DARTS+仁(Liang et al., 2019)	6.1M	594M	77.5	93.6
AtomNAS-A+*	4.7M	260M	76.3	93.0
AtomNAS-B+*	5.5M	329M	77.2	93.5
AtomNAS-C+*	5.9M	363M	77.6	93.6
Table 2: Influence of awareness of resource metric. The upper block uses equal penalties for all
atomic blocks. The lower part uses our resource-aware atomic block selection.
λ	FLOPs	Top-1(%)
1.0 × 10-4	445M	76.1
1.5 × 10-4	370M	74.9
1.0 × 10-4	360M	75.9
4.3.3	Cost of Dynamic Network Shrinkage
Our dynamic network shrinkage algorithm speedups the search and train process significantly. For
AtomNAS-C, the total time for search-and-training is 25.5 hours. For reference, training the final
architecture from scratch takes 22 hours. Note that as the supernet shrinks, both the GPU memory
consumption and forward-backward time are significantly reduced. Thus it’s possible to dynamically
change the batch size once having sufficient GPU memory, which would further speed up the whole
procedure.
9
Published as a conference paper at ICLR 2020
Table 3: Influence of BN recalibration.
Model	w/o Recalibration	w/ Recalibration
AtomNAS-A	73.2	74.6 (+1.4)
AtomNAS-B	73.8	75.5 (+1.7)
AtomNAS-C	74.7	75.9 (+1.2)
4.4	Experiments on COCO Detection and Instance Segmentation
In this section, we assess the performance of AtomNAS models as feature extractors for object
detection and instance segmentation on COCO dataset (Lin et al., 2014). We first pretrain AtomNAS
models (without Swish activation function (Ramachandran et al., 2018) and Squeeze-and-Excitation
(SE) module (Hu et al., 2018)) on ImageNet, use them as drop-in replacements for the backbone in
the Mask-RCNN model (He et al., 2017a) by building the detection head on top of the last feature
map, and finetune the model on COCO dataset.
We use the open-source code MMDetection (Chen et al., 2019a). All the models are trained on
COCO train2017 with batch size 16 and evaluated on COCO val2017. Following the schedule used
in the open-source implementation of TPU-trained Mask-RCNN , the learning rate starts at 0.02
and decreases by a scale of 10 at 15-th and 20th epoch respectively. The models are trained for 23
epochs in total.
Table 4 compares the results with other baseline backbone models. The detection results of baseline
models are from Stamoulis et al. (2019b). We can see that all three AtomNAS models outperform the
baselines on object detection task. The results demonstrate that our models have better transferability
than the baselines, which may due to mixed operations, a.k.a multi-scale here, are more important
to object detection and instance segmentation.
Table 4: Comparision with baseline backbones on COCO object detection and instance segmenta-
tion. Cls denotes the ImageNet top-1 accuracy; detect-mAP and seg-mAP denotes mean average
precision for detection and instance segmentation on COCO dataset. The results of baseline models
are from Stamoulis et al. (2019b). SinglePath+ (Stamoulis et al., 2019b) contains SE module.
Model	FLOPs	Cls (%)	detect-mAP (%)	seg-mAP (%)
MobileNetV2 (Sandler et al., 2018)	301M	73.6	30.5	-
Proxyless (mobile) (Cai et al., 2019)	320M	74.6	32.9	-
Proxyless (mobile) (our impl.)	320M	74.9	32.7	30.0
SinglePath+ (Stamoulis et al., 2019b)	353M	75.6	33.0	-
SinglePath (our impl.)	334M	75.0	32.0	29.7
AtomNAS-A	258M	74.6	32.7	30.1
AtomNAS-B	326M	75.5	33.6	30.8
AtomNAS-C	360M	75.9	34.1	31.4
5 Conclusion
In this paper, we revisit the common structure, i.e., two convolutions joined by a channel-wise op-
eration, and reformulate it as an ensemble of atomic blocks. This perspective enables a much larger
and more fine-grained search space. For efficiently exploring the huge fine-grained search space,
we propose an end-to-end framework named AtomNAS, which conducts architecture search and
network training jointly. The searched networks achieve significantly better accuracy than previous
state-of-the-art methods while using small extra cost.
https://github.com/tensorflow/tpu/tree/master/models/official/mask_
rcnn
10
Published as a conference paper at ICLR 2020
References
Han Cai, Ligeng Zhu, and Song Han. Proxylessnas: Direct neural architecture search on target task
and hardware. In ICLR, 2019.
Kai Chen, Jiaqi Wang, Jiangmiao Pang, Yuhang Cao, Yu Xiong, Xiaoxiao Li, Shuyang Sun, Wansen
Feng, Ziwei Liu, Jiarui Xu, Zheng Zhang, Dazhi Cheng, Chenchen Zhu, Tianheng Cheng, Qijie
Zhao, Buyu Li, Xin Lu, Rui Zhu, Yue Wu, Jifeng Dai, Jingdong Wang, Jianping Shi, Wanli
Ouyang, Chen Change Loy, and Dahua Lin. MMDetection: Open mmlab detection toolbox and
benchmark. arXiv preprint arXiv:1906.07155, 2019a.
Xin Chen, Lingxi Xie, Jun Wu, and Qi Tian. Progressive differentiable architecture search: Bridging
the depth gap between search and evaluation. CoRR, abs/1904.12760, 2019b.
Xiangxiang Chu, Bo Zhang, Jixiang Li, Qingyuan Li, and Ruijun Xu. Scarletnas: Bridging the gap
between scalability and fairness in neural architecture search. CoRR, abs/1908.06022, 2019a.
Xiangxiang Chu, Bo Zhang, Ruijun Xu, and Jixiang Li. Fairnas: Rethinking evaluation fairness of
weight sharing neural architecture search. CoRR, abs/1907.01845, 2019b.
Ekin Dogus Cubuk, Barret Zoph, Dandelion Mane, Vijay Vasudevan, and QUoc V. Le. Autoaugment:
Learning augmentation policies from data. CoRR, abs/1805.09501, 2018.
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Fei-Fei Li. Imagenet: A large-scale
hierarchical image database. In CVPR, pp. 248-255, 2009.
Jiemin Fang, Yuzhu Sun, Qian Zhang, Yuan Li, Wenyu Liu, and Xinggang Wang. Densely connected
search space for more flexible neural architecture search. CoRR, abs/1906.09607, 2019.
Ariel Gordon, Elad Eban, Ofir Nachum, Bo Chen, Hao Wu, Tien-Ju Yang, and Edward Choi. Mor-
phnet: Fast & simple resource-constrained structure learning of deep networks. In CVPR, pp.
1586-1595, 2018.
Zichao Guo, Xiangyu Zhang, Haoyuan Mu, Wen Heng, Zechun Liu, Yichen Wei, and Jian Sun.
Single path one-shot neural architecture search with uniform sampling. CoRR, abs/1904.00420,
2019.
Song Han, Huizi Mao, and William J. Dally. Deep compression: Compressing deep neural network
with pruning, trained quantization and huffman coding. In ICLR, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In CVPR, pp. 770-778, 2016.
Kaiming He, Georgia Gkioxari, Piotr Dollar, and Ross B. Girshick. Mask R-CNN. In IEEE In-
ternational Conference on Computer Vision, ICCV 2017, Venice, Italy, October 22-29, 2017, pp.
2980-2988, 2017a.
Yihui He, Xiangyu Zhang, and Jian Sun. Channel pruning for accelerating very deep neural net-
works. In ICCV, pp. 1398-1406, 2017b.
Andrew Howard, Mark Sandler, Grace Chu, Liang-Chieh Chen, Bo Chen, Mingxing Tan, Weijun
Wang, Yukun Zhu, Ruoming Pang, Vijay Vasudevan, et al. Searching for mobilenetv3. Corr,
abs/1905.02244, 2019.
Andrew G. Howard, Menglong Zhu, Bo Chen, Dmitry Kalenichenko, Weijun Wang, Tobias Weyand,
Marco Andreetto, and Hartwig Adam. Mobilenets: Efficient convolutional neural networks for
mobile vision applications. CoRR, abs/1704.04861, 2017.
Jie Hu, Li Shen, and Gang Sun. Squeeze-and-excitation networks. In CVPR, pp. 7132-7141, 2018.
Xiaojie Jin, Jiang Wang, Joshua Slocum, Ming-Hsuan Yang, Shengyang Dai, Shuicheng Yan, and
Jiashi Feng. Rc-darts: Resource constrained differentiable architecture search. arXiv preprint
arXiv:1912.12814, 2019.
11
Published as a conference paper at ICLR 2020
Hanwen Liang, Shifeng Zhang, Jiacheng Sun, Xingqiu He, Weiran Huang, Kechen Zhuang, and
Zhenguo Li. Darts+: Improved differentiable architecture search with early stopping, 2019.
Tsung-Yi Lin, Michael Maire, Serge J. Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr
Dollar, and C. LaWrence Zitnick. Microsoft COCO: common objects in context. In Computer
Vision - ECCV 2014 - 13th European Conference, Zurich, Switzerland, September 6-12, 2014,
Proceedings, Part V, pp. 740-755, 2014.
Hanxiao Liu, Karen Simonyan, and Yiming Yang. DARTS: differentiable architecture search. In
ICLR, 2019a.
Zhuang Liu, Jianguo Li, Zhiqiang Shen, Gao Huang, Shoumeng Yan, and Changshui Zhang. Learn-
ing efficient convolutional netWorks through netWork slimming. In ICCV, pp. 2755-2763, 2017.
Zhuang Liu, Mingjie Sun, Tinghui Zhou, Gao Huang, and Trevor Darrell. Rethinking the value of
netWork pruning. In 7th International Conference on Learning Representations, ICLR 2019, New
Orleans, LA, USA, May 6-9, 2019, 2019b.
Jian-Hao Luo, Jianxin Wu, and Weiyao Lin. Thinet: A filter level pruning method for deep neural
netWork compression. In ICCV, pp. 5068-5076, 2017.
Ningning Ma, Xiangyu Zhang, Hai-Tao Zheng, and Jian Sun. Shufflenet V2: practical guidelines
for efficient CNN architecture design. In ECCV, pp. 122-138, 2018.
Hieu Pham, Melody Y. Guan, Barret Zoph, Quoc V. Le, and Jeff Dean. Efficient neural architecture
search via parameter sharing. In ICML, pp. 4092-4101, 2018.
Prajit Ramachandran, Barret Zoph, and Quoc V. Le. Searching for activation functions. In 6th In-
ternational Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April
30 - May 3, 2018, Workshop Track Proceedings, 2018.
Mark Sandler, AndreW G. HoWard, Menglong Zhu, Andrey Zhmoginov, and Liang-Chieh Chen.
Mobilenetv2: Inverted residuals and linear bottlenecks. In CVPR, pp. 4510-4520, 2018.
Karen Simonyan and AndreW Zisserman. Very deep convolutional netWorks for large-scale image
recognition. In ICLR, 2015.
Dimitrios Stamoulis, Ruizhou Ding, Di Wang, Dimitrios Lymberopoulos, Bodhi Priyantha, Jie Liu,
and Diana Marculescu. Single-path NAS: designing hardWare-efficient convnets in less than 4
hours. CoRR, abs/1904.02877, 2019a.
Dimitrios Stamoulis, Ruizhou Ding, Di Wang, Dimitrios Lymberopoulos, Bodhi Priyantha, Jie Liu,
and Diana Marculescu. Single-path mobile automl: Efficient convnet design and NAS hyperpa-
rameter optimization. CoRR, abs/1907.00959, 2019b.
Mingxing Tan and Quoc V. Le. Efficientnet: Rethinking model scaling for convolutional neural
netWorks. In ICML, pp. 6105-6114, 2019a.
Mingxing Tan and Quoc V. Le. Mixconv: Mixed depthWise convolutional kernels. CoRR,
abs/1907.09595, 2019b.
Mingxing Tan, Bo Chen, Ruoming Pang, Vijay Vasudevan, Mark Sandler, AndreW HoWard, and
Quoc V Le. Mnasnet: Platform-aWare neural architecture search for mobile. In CVPR, pp. 2820-
2828, 2019.
Bichen Wu, Xiaoliang Dai, Peizhao Zhang, Yanghan Wang, Fei Sun, Yiming Wu, Yuandong Tian,
Peter Vajda, Yangqing Jia, and Kurt Keutzer. Fbnet: HardWare-aWare efficient convnet design via
differentiable neural architecture search. In CVPR, pp. 10734-10742, 2019.
Yuhui Xu, Lingxi Xie, Xiaopeng Zhang, Xin Chen, Guo-Jun Qi, Qi Tian, and Hongkai Xiong. PC-
DARTS: Partial channel connections for memory-efficient architecture search. In ICLR, 2020.
Jianbo Ye, Xin Lu, Zhe Lin, and James Z. Wang. Rethinking the smaller-norm-less-informative
assumption in channel pruning of convolution layers. In ICLR, 2018.
12
Published as a conference paper at ICLR 2020
Jiahui Yu, Pengchong Jin, Hanxiao Liu, Gabriel Bender, Pieter-Jan Kindermans, Mingxing Tan,
Thomas Huang, Xiaodan Song, and Quoc Le. Scaling up neural architecture search with big
single-stage models, 2020. URL https://openreview.net/forum?id=HJe7unNFDH.
Hongyi Zhang, Moustapha Cisse, Yann N. Dauphin, and David Lopez-Paz. mixup: Beyond empiri-
cal risk minimization. In ICLR, 2018.
Barret Zoph and Quoc V. Le. Neural architecture search with reinforcement learning. In ICLR,
2017.
A Visualization
寸ZZXbZZXE
≈zx≈7
95XCCX17∖
qcxcj^x,∙∖
■ ■
3X3X96 f
3X3X08
曹
3X3X08 -
3X3X08 -
寸Tx寸TXes
∞"8cxo 寸
∞"∞zx。寸
7
"ZXOZE
"ZXO& T
-X-Xr-b∖.
-X-Xr-b∖.
z,rW
3X3X96
"ZXZ6I



Zy
Figure 5: The architecture of AtomNAS-C. Blue, orange, cyan blocks denote atomic blocks with
kernel size 3, 5 and 7 respectively; the heights of these blocks are proportional to their expand ratios.
We plot the structure of the searched architecture AtomNAS-C in Fig. 5, from which We see more
flexibility of channel number selection, not only among different operators within each block, but
also across the network. In Fig. 6a, we visualize the ratio between atomic blocks with different
kernel sizes in all 21 search blocks. First, we notice that all search blocks have convolutions of all
three kernel sizes, showing that AtomNAS learns the importance of using multiple kernel sizes in
network architecture. Another observation is that AtomNAS tends to keep more atomic blocks at
the later stage of the network. This is because in earlier stage, convolutions of the same kernel size
costs more FLOPs; AtomNAS is aware of this (thanks to its resource-aware regularization) and try
to keep as less as possible computationally costly atomic blocks.
13
Published as a conference paper at ICLR 2020
432
432
432
720
720
3456
1728
1728
3456
3456
720
720
720
1440
1440
1440
1728
1728
1728
3456
3456
3456
(b) Baseline
Figure 6: Ratio of different types of atomic blocks in all 21 searchable blocks. The text above
each pie tells the total number of atomic blocks of the corresponding block in the original supernet.
Grey denotes dead atomic blocks; blue, orange, and cyan represent atomic blocks using depth-wise
convolutions with kernel size 3, 5,7 respectively. Blocks without skip connection are highlighted
by bold text. (a) Visualization for AtomNAS-C. (b) Visualization for baseline (i.e., without FLOPs
related coefficients g).
720
432
432
(a) AtOmNAS-C
432
14