Published as a conference paper at ICLR 2020
Variance Reduction with Sparse Gradients
Melih Elibol, Michael I. Jordan	Lihua Lei
University of California, Berkeley	Stanford University
{elibol,jordan}@cs.berkeley.edu	lihualei@stanford.edu
Ab stract
Variance reduction methods such as SVRG (Johnson & Zhang, 2013) and Spi-
derBoost (Wang et al., 2018) use a mixture of large and small batch gradients
to reduce the variance of stochastic gradients. Compared to SGD (Robbins &
Monro, 1951), these methods require at least double the number of operations per
update to model parameters. To reduce the computational cost of these methods,
we introduce a new sparsity operator: The random-top-k operator. Our opera-
tor reduces computational complexity by estimating gradient sparsity exhibited
in a variety of applications by combining the top-k operator (Stich et al., 2018;
Aji & Heafield, 2017) and the randomized coordinate descent operator. With this
operator, large batch gradients offer an extra benefit beyond variance reduction:
A reliable estimate of gradient sparsity. Theoretically, our algorithm is at least
as good as the best algorithm (SpiderBoost), and further excels in performance
whenever the random-top-k operator captures gradient sparsity. Empirically, our
algorithm consistently outperforms SpiderBoost using various models on various
tasks including image classification, natural language processing, and sparse ma-
trix factorization. We also provide empirical evidence to support the intuition
behind our algorithm via a simple gradient entropy computation, which serves to
quantify gradient sparsity at every iteration.
1 Introduction
Optimization tools for machine learning applications seek to minimize the finite sum objective
1n
mRdf (x), n X fi(x),
i=1
(1)
where x is a vector of parameters, and fi : Rd → R is the loss associated with sample i. Batch
SGD serves as the prototype for modern stochastic gradient methods. It updates the iterate x with
X - ηVfι(x), where η is the learning rate and Vfi(x) is the batch stochastic gradient, i.e.
VfI(X) = ∣I∣ X Vfi(X).
|I| i∈I
The batch size ∣I∣ in batch SGD directly impacts the stochastic variance and gradient query com-
plexity of each iteration of the update rule.
In recent years, variance reduction techniques have been proposed by carefully blending large and
small batch gradients (e.g. Roux et al., 2012; Johnson & Zhang, 2013; Defazio et al., 2014; Xiao &
Zhang, 2014; Allen-Zhu & Yuan, 2016; Allen-Zhu & Hazan, 2016; Reddi et al., 2016a;b; Allen-Zhu,
2017; Lei & Jordan, 2017; Lei et al., 2017; Allen-Zhu, 2018b; Fang et al., 2018; Zhou et al., 2018;
Wang et al., 2018; Pham et al., 2019; Nguyen et al., 2019; Lei & Jordan, 2019). They are alterna-
tives to batch SGD and are provably better than SGD in various settings. While these methods allow
for greater learning rates than batch SGD and have appealing theoretical guarantees, they require a
per-iteration query complexity which is more than double than that of batch SGD. Defazio (2019)
questions the utility of variance reduction techniques in modern machine learning problems, empir-
ically identifying query complexity as one issue. In this paper, we show that gradient sparsity (Aji
& Heafield, 2017) can be used to significantly reduce the query complexity of variance reduction
methods. Our work is motivated by the observation that gradients tend to be ”sparse,” having only
1
Published as a conference paper at ICLR 2020
a small fraction of large coordinates. Specifically, if the indices of large gradient coordinates (mea-
sured in absolute value) are known before updating model parameters, we compute the derivative of
only those coordinates while setting the remaining gradient coordinates to zero. In principle, if spar-
sity is exhibited, using large gradient coordinates will not effect performance and will significantly
reduce the number of operations required to update model parameters. Nevertheless, this heuristic
alone has three issues: (1) bias is introduced by setting other entries to zero; (2) the locations of
large coordinates are typically unknown; (3) accessing a subset of coordinates may not be easily
implemented for some problems like deep neural networks.
We provide solutions for all three issues. First, we introduce a new sparse gradient operator: The
random-top-k operator. The random-top-k operator is a composition of the randomized coordinate
descent operator and the top-k operator. In prior work, the top-k operator has been used to reduce
the communication complexity of distributed optimization (Stich et al., 2018; Aji & Heafield, 2017)
applications. The random-top-k operator has two phases: Given a stochastic gradient and a pair
of integers (k1, k2) that sum to k, the operator retains k1 coordinates which are most ”promising”
in terms of their ”likelihood” to be large on average, then randomly selects k2 of the remaining
coordinates with appropriate rescaling. The first phase captures sparsity patterns while the second
phase eliminates bias. Second, we make use of large batch gradients in variance reduction methods
to estimate sparsity patterns. Inspired by the use of a memory vector in Aji & Heafield (2017),
the algorithm maintains a memory vector initialized with the absolute value of the large batch gra-
dient at the beginning of each outer loop and updated by taking an exponential moving average
over subsequent stochastic gradients. Coordinates with large values in the memory vector are more
”promising,” and the random-top-k operator will pick the top k1 coordinate indices based on the
memory vector. Since larger batch gradients have lower variance, the initial estimate is quite accu-
rate. Finally, for software that supports dynamic computation graphs, we provide a cost-effective
way (sparse back-propagation) to implement the random-top-k operator.
In this work we apply the random-top-k operator to SpiderBoost (Wang et al., 2018), a recent vari-
ance reduction method that achieves optimal query complexity, with a slight modification based on
the ”geometrization” technique introduced by Lei & Jordan (2019). Theoretically, we show that our
algorithm is never worse than SpiderBoost and can strictly outperform it when the random-top-k
operator captures gradient sparsity. Empirically, we demonstrate the improvements in computa-
tion for various tasks including image classification, natural language processing, and sparse matrix
factorization.
The rest of the paper is organized as follows. In Section 2, we define the random-top-k operator,
our optimization algorithm, and a description of sparse backpropagation. The theoretical analyses
are presented in Section 3, followed by experimental results in Section 4. All technical proofs are
relegated to Appendix A, and additional experimental details can be found in Appendix B.
2 Stochastic Variance Reduction with Sparse Gradients
Generally, variance reduction methods reduce the variance of stochastic gradients by taking a snap-
shot Vf (y) of the gradient Vf (x) every m steps of optimization, and use the gradient information
in this snapshot to reduce the variance of subsequent smaller batch gradients VfI(x) (Johnson &
Zhang, 2013; Wang et al., 2018). Methods such as SCSG (Lei & Jordan, 2017) utilize a large batch
gradient, which is typically some multiple in size of the small batch gradient b, which is much more
practical and is what we do in this paper. To reduce the cost of computing additional gradients, we
use sparsity by only computing a subset k of the total gradients d, where y ∈ Rd .
For d, k, k1, k2 ∈ Z+, let k = k1 + k2, where 1 ≤ k ≤ d for a parametric model of dimension
d. In what follows, we define an operator which takes vectors x, y and outputs y0 , where y0 retains
only k of the entries in y, k1 of which are selected according to the coordinates in x which have
the k1 largest absolute values, and the remaining k2 entries are randomly selected from y. The k1
coordinate indices and k2 coordinate indices are disjoint. Formally, the operator rtopk1,k2 : Rd →
Rd is defined for x, y ∈ Rd as
(y'	if kι > 0 and ∣χ∣' ≥ |x|(ki)
(d削 y' if ' ∈ S
otherwise,
0
2
Published as a conference paper at ICLR 2020
1
2
3
4
5
6
7
8
9
10
11
12
13
where |x| denotes a vector of absolute values, |x|(1) ≥ |x|(2) ≥ . . . ≥ |x|(d) denotes the order
statistics of coordinates of x in absolute values, and S denotes a random subset with size k2 that is
uniformly drawn from the set {' : ∣x∣' < ∣x∣(kι)}. For instance, if X = (11,12,13, -14, -15), y =
(-25, -24, 13, 12, 11) and k1 = k2 = 1, then S is a singleton uniformly drawn from {1, 2, 3, 4}.
Suppose S = {2}, then rtop1,1 (x, y) = (0, 4y2, 0, 0, y5) = (0, -96, 0, 0, 11). If k1 + k2 = d,
rtopk1,k2 (x, y) = y. On the other hand, if k1 = 0, rtop0,k2 (x, y) does not depend on x and returns
a rescaled random subset of y. This is the operator used in coordinate descent methods. Finally,
rtopk1,k2 (x, y) is linear in y. The following Lemma shows that rtopk1 ,k2 (x, y) is an unbiased
estimator ofy, which is a crucial property in our later analysis.
Lemma 1. Given any x, y ∈ Rd,
E(rtoPk1,k2(xM) = y,	Var(rtoPk1,k2(xM) = d_k2 k2IltoP-kι(x,y)k2,
where E is taken over the random subset S involved in the rtopk1 ,k2 operator and
(top k (x,y))' = ∫y' if k1 > 0 and lxl'< 皿瓦)
- 1	0 otherwise.
Our algorithm is detailed as below.
Algorithm 1: SPiderBoostWith Sparse Gradients.
Input: Learning rate η, inner loop size m, outer loop size T, large batch size B, small batch size b,
initial iterate x0, memory decay factor α, sparsity parameters k1, k2.
Io 〜Unif({1,...,n}) with |Io| = B
MO := |Vflo (XO)I
for j = 1, ..., T do
x(Oj) := xj-1, MO(j) := Mj-1
Ij 〜Unif({1,...,n}) with ∣∣∙ ∣ = B
VOj)= VfIj (XOj))
Nj := m (for implementation) or Nj 〜 geometric distribution with mean m (for theory)
for t = 0, . . . , Nj - 1 do
(j)	(j)	(j)
Xt+1 := Xt - ηνt
It(j) 〜 Unif([n]) with |It(j)| = b
νt(+j)1 := νt(j) +rtopk1,k2 Mt(j),VfI(j)(X(tj+)1) - VfI(j)(Xt(j))
_ Mt(+1 := αlν(+)ιl + (1 - α)Mt(j)
_ xj := XNj, Mj = MNj
Output: Xout = XT (for implementation) or Xout = XT0 where T0 〜 Unif([T]) (for theory)
The algorithm includes an outer-loop and an inner-loop. In the theoretical analysis, we generate Nj
as Geometric random variables. This trick is called ”geometrization”, proposed by Lei & Jordan
(2017) and dubbed by Lei & Jordan (2019). It greatly simplifies analysis (e.g. Lei et al., 2017;
Allen-Zhu, 2018a). In practice, as observed by Lei et al. (2017), setting Nj to m does not impact
performance in any significant way. We only use ”geometrization” in our theoretical analysis for
clarity. Similarly, for our theoretical analysis, the output of our algorithm is selected uniformly at
random from the set of outer loop iterations. Like the use of average iterates in convex optimization,
this is a common technique for nonconvex optimization proposed by Nemirovski et al. (2009). In
practice, we simply use the last iterate.
Similar to Aji & Heafield (2017), we maintain a memory vector Mt(j) at each iteration of our al-
gorithm. The memory vector is initialized to the large batch gradient computed before every pass
through the inner loop, which provides a relatively accurate gradient sparsity estimate of X(Oj). The
exponential moving average gradually incorporates information from subsequent small batch gra-
dients to account for changes to gradient sparsity. We then use Mt(j ) as an approximation to the
variance of each gradient coordinate in our rtopk1,k2 operator. With Mt(j) as input, the rtopk1,k2
3
Published as a conference paper at ICLR 2020
operator targets k1 high variance gradient coordinates in addition to k2 randomly selected coordi-
nates.
The cost of invoking rtopk1 ,k2 is dominated by the algorithm for selecting the top k coordinates,
which has linear worst case complexity when using the introselect algorithm (Musser, 1997).
2.1	Sparse Back-Propagation
A weakness of our method is the technical difficulty of implementing a sparse backpropagation
algorithm in modern machine learning libraries, such as Tensorflow (Abadi et al., 2015) and Pytorch
(Paszke et al., 2017). Models implemented in these libraries generally assume dense structured
parameters. The optimal implementation of our algorithm makes use of a sparse forward pass and
assumes a sparse computation graph upon which backpropagation is executed. Libraries that support
dynamic computation graphs, such as Pytorch, will construct the sparse computation graph in the
forward pass, which makes the required sparse backpropagation trivial. We therefore expect our
algorithm to perform quite well on libraries which support dynamic computation graphs.
Consider the forward pass of a deep neural network, where φ is a deep composition of parametric
functions,
φ(x; θ) = Φl(Φl-i(...Φo (x; θθ)…；Θl-i); Θl).	(2)
The unconstrained problem of minimizing over the θ` can be rewritten as a constrained optimization
problem as follows:
1n
min - y'ioss(z(L+1),yi)
θn
i=1
s.t. z(L+1) = ΦL(z(L); Θl)
.
..	(3)
('+1)—入 / ('). θ、
Zi	= φ'(zi ; θ')
zi(1) = φ0(xi; θ0).
In this form, zL+1 is the model estimate for data point i. Consider φ'(x; θ`) = σ(xTθ`) for 1 ≤
` < L, φL be the output layer, and σ be some subdifferentiable activation function. If we apply the
rtopk ,k operator per-layer in the forward-pass, with appropriate scaling of k1 and k2 to account
for depth, we see that the number of multiplications in the forward pass is reduced to k1 + k2 :
σ(rtopk1,k2 (v, x)T rtopk1,k2 (v, θ`)). A sparse forward-pass yields a computation graph for a (k1 +
k2)-parameter model, and back-propagation will compute the gradient of the objective with respect
to model parameters in linear time (Chauvin & Rumelhart, 1995).
3 Theoretical Complexity Analysis
3.1	Notation and assumptions
Denote by ∣∣ ∙ ∣∣ the Euclidean norm and by a ∧ b the minimum of a and b. For a random vector
Y ∈ Rd,
d
Var(Y) = XVar(Yi).
i=1
We say a random variable N has a geometric distribution, N 〜Geom(m), if N is supported on the
non-negative integers with
P(N = k) = γk (1 - γ),	∀k = 0, 1, . . . ,
for some γ such that EN = m. Here we allow N to be zero to facilitate the analysis.
4
Published as a conference paper at ICLR 2020
Assumption A1 on the smoothness of individual functions will be made throughout the paper.
A1 fi is differentiable with
l∣Vfi(x) - VfMy)k ≤ Lkx - yk,
for some L < ∞ and for all i ∈ {1, . . . , n}.
As a direct consequence of assumption A1, it holds for any x, y ∈ Rd that
—2∣x 一 yk2 ≤ fi(x) — fi(y) — hVfi(y),x 一 yi ≤ Lkx — yk2.
(4)
To formulate our complexity bounds, we define
f*=inf f(x),	∆f = f(xo) - f*.
x
Further we define σ2 as an upper bound on the expected norm of the stochastic gradients:
1n
σ =SUp — EkVfi(x)k2.	(5)
x n i=1
By Cauchy-Schwarz inequality, it is easy to see that σ2 is also a uniform bound of kVf(x)k2.
Finally, we assume that sampling an index i and accessing the pair Vfi(x) incur a unit of cost and
accessing the truncated version rtopk ,k (m, Vfi(x)) incur (k1 + k2)/d units of cost. Note that
calculating rtopk1,k2 (m, VfI (x)) incurs |I|(k1 + k2)/d units of computational cost. Given our
framework, the theoretical complexity of the algorithm is
T
Ccomp㈤，X (B + 2bNj 纥—2) .	(6)
j=1
3.2	Worst-case guarantee
Theorem 1. Under the following setting of parameters
2σ2
-∧ ∧ n
2
For any T ≥ T () , 4∆f /ηm2,
EkVf(xout)k ≤ .
If we further set
Bd
b(kι + k2),
the complexity to achieve the above condition is
Recall that the complexity of SpiderBoost (Wang et al., 2018) is
O ((三 ∧√n) 3).
Thus as long as b = O(1), k1 = O(k2), our algorithm has the same complexity as SpiderBoost
under appropriate settings. The penalty term O( vzb(k1 + k2)∕k2) is due to the information loss by
sparsification.
5
Published as a conference paper at ICLR 2020
3.3	Data adaptive analysis
Let
and
g(j) = k top-kι(Mt(j), Vf (x(+)ι) - Vf(x")k2,
1n
Gyj = n X k top-kι (Mj Vfi(x(+)ι) - Vfi(Xj)))k2.
i=1
By Cauchy-Schwarz inequality and the linearity of top-k1 , it is easy to see that gt(j) ≤ Gt(j). If our
(j)	(j )
algorithm succeeds in capturing sparsity, both gt and Gt will be small. In this subsection we will
analyze the complexity under this case. Further define Rj as
(7)
where Ej is taken over all randomness in j-th outer loop (line 4-13 of Algorithm 1).
Theorem 2. Under the following setting of parameters
rb∧m
ιm
B = —— ∧ n
2
For any T ≥ T () , 6∆f /ηm2,
EkVf(Xout)k2 ≤ 232 + (d - kk- kk2'mERT,
where
1T
RT = TERj.
j=1
If ERT ≤ e23(d-k1-k2)m, then
EkVf(Xout)k ≤ .
Ifwe further set
Bd
m =----------
b(kι + k2),
the complexity to achieve the above condition is
ECcomp(C)=O ((j ∧ √√n)LJ r k1 +dk2 b ∧∧m!.
In practice, m is usually much larger than b. As a result, the complexity of our algorithm is
O(,(kι + k2)∕d) smaller than that of SPiderBooSt if our algorithm captures gradient sparsity. Al-
though this type of data adaptive analyses is not as clean as the worst-case guarantee (Theorem 1), it
reveals the potentially superior performance of our algorithm. Similar analyses have been done for
various other algorithms, including AdaGrad (Duchi et al., 2011) and Adam (Kingma & Ba, 2014).
4 Experiments
In this section, we present a variety of experiments to illustrate gradient sparsity and demonstrate
the performance of Sparse SpiderBoost. By computing the entropy of the empirical distribution of
the absolute value of stochastic gradient coordinates, we show that certain models exhibit gradient
sparsity during optimization. To evaluate the performance of variance reduction with sparse gradi-
ents, we compute the loss over gradient queries per epoch of Sparse Spiderboost and SpiderBoost
for a number of image classification problems. We also compare Sparse SpiderBoost, SpiderBoost,
and SGD on a natural language processing task and sparse matrix factorization.
For all experiments, unless otherwise specified, we run SpiderBoost and Sparse SpiderBoost with a
learning rate η = 0.1, large-batch size B = 1000, small-batch size b = 100, inner loop length of
m= 10, memory decay factor of α = 0.5, and k1 and k2 both set to 5% of the total number of
model parameters. We call the sum k1 + k2 = k = 10% the sparsity of the optimization algorithm.
6
Published as a conference paper at ICLR 2020
4.1	Gradient Sparsity and Image Classification
Our experiments in this section test a number of image classification tasks for gradient sparsity, and
plot the learning curves of some of these tasks. We test a 2-layer fully connected neural network
with hidden layers of width 100, a simple convolutional neural net which we describe in detail in
Appendix B, and Resnet-18 (He et al., 2015). All models use ReLu activations. For datasets, we use
CIFAR-10 (Krizhevsky et al.), SVHN (Netzer et al., 2011), and MNIST (LeCun & Cortes, 2010).
None of our experiments include Resnet-18 on MNIST as MNIST is an easier dataset; it is included
primarily to provide variety.
Our method relies partially on the assumption that the magnitude of the derivative of some model
parameters are greater than others. To measure this, we compute the entropy of the empirical distri-
bution of the absolute value of stochastic gradient coordinates. In Algorithm 1, the following term
updates our estimate of the variance of each coordinate’s derivative:
Mt(+1 := a|vj1 | + (I- α)Mt(j).
Consider the entropy of the following probability vector pt(j) = Mt(j)/kMt(j) k1. The entropy of p
provides us with a measure of how much structure there is in our gradients. To see this, consider the
hypothetical scenario where pi = 1/d. In this scenario we have no structure; the top k1 component
of our sparsity operator is providing no value and entropy is maximized. On the other hand, if a
single entry pi = 1 and all other entries pj = 0, then the top k1 component of our sparsity operator
is effectively identifying the only relevant model parameter.
To measure the potential of our sparsity operator, we compute the entropy of p while running Spi-
derBoost on a variety of datasets and model architectures. The results of running this experiment
are summarized in the following table.
Table 1: Entropy of Memory Vectors
I	FCNN	I ConVNN ∣	Resnet-18
I MaX Before After ∣ Max Before After ∣ Max Before After
CIFAR-10	18.234	16.41	8.09	15.920	13.38	2.66	23.414	22.59	21.70
SVHN	18.234	15.36	8.05	15.920	13.00	2.97	23.414	22.62	21.31
MNIST	18.234	14.29	9.77	15.920	14.21	2.77	-	-	-
Table 1 proVides the maximum entropy as well as the entropy of the memory Vector before and
after training for 150 epochs, for each dataset and each model. For each model, the entropy at the
beginning of training is almost maximal. This is due to random initialization of model parameters.
After 150 epochs, the entropy of Mt for the conVolutional model drops to approximately 3, which
suggests a substantial amount of gradient structure. Note that for the datasets that we tested, the
gradient structure depends primarily on the model and not the dataset. In particular, for Resnet-18,
the entropy appears to Vary minimally after 150 epochs.
Figure 1: SpiderBoost with 10% sparsity (k = 0.1d) compared to SpiderBoost without sparsity. Left
figure compares the two algorithms using Resnet-18 on Cifar-10. Right figure compares the two
algorithms using a conVolutional neural network trained on MNIST. The x-axis measures gradient
queries oVer N, where N is the size of the respectiVe datasets. Plots are in log-scale.
7
Published as a conference paper at ICLR 2020
Figure 1 compares SpiderBoost alone to SpiderBoost with 10% sparsity (10% of parameter deriva-
tives). All experiments in this section are run for 50 epochs. In our comparison to SpiderBoost,
we measure the number of gradient queries over the size of the dataset N . A single gradient query
is taken to be the cost of computing a gradient for a single data point. If i is the index of a single
sample, then Vfi (x) is a single gradient query. Using the batch gradient to update model parameters
for a dataset of size B has a gradient query cost of B . For a model with d parameters, using a single
sample to update k model parameters has a gradient query cost of k/d, etc.
Our results of fitting the convolutional neural network to MNIST show that sparsity provides a sig-
nificant advantage compared to using SpiderBoost alone. We only show 2 epochs of this experiment
since the MNIST dataset is fairly simple and convergence is rapidly achieved. The results of training
Resnet-18 on CIFAR-10 suggests that our sparsity algorithm works well on large neural networks,
and non-trivial datasets. We believe Resnet-18 on CIFAR-10 does not do as well due to the gradient
density we observe for Resnet-18 in general. Sparsity here not only has the additional benefit of
reducing gradient query complexity, but also provides a dampening effect on variance due to the
additional covariates in SpiderBoost’s update to model parameters. Results for the rest of these
experiments can be found in Appendix B.
4.2	Natural Language Processing
We evaluate Sparse SpiderBoost’s performance on an LSTM-based (Hochreiter & Schmidhuber,
1997) generative language model. We compare Sparse SpiderBoost, SpiderBoost, and SGD. We
train our LSTM model on the Penn Treebank (Marcus et al., 1994) corpus. The natural language
processing model consists of a word embedding of dimension 128 of 1000 tokens, which is jointly
learned with the task. The LSTM has a hidden and cell state dimension of 1024. All three opti-
mization algorithms operate on this model. The variance reduction training algorithm for this type
of model can be found in Appendix B. We run SpiderBoost and Sparse SpiderBoost with a learning
rate η = 0.2, large-batch size B = 40, small-batch size b = 20, inner loop length of m = 2. We run
SGD with learning rate 0.2 and batch size is 20. Figure 2 shows SpiderBoost is slightly worse than
SGD, and sparsity provides a noticeable improvement over SGD.
9× IO0
8× IO0
g7 × IO0
6× IO0
5 × IO0
Figure 2: (a): SGD learning rate is 0.2 and batch size is 20. (b): SGD batch size is 103 and learning
rate schedule is 0.1 for epochs 0 - 10, 0.01 for epochs 10 - 20, and 0.001 for epochs 20 - 40. The
x-axis measures gradient queries over N , where N is the size of the respective datasets. Plots are in
log-scale.
4.3	Sparse Matrix Factorization
For our experiments with sparse matrix factorization, we perform Bayesian Personalized Ranking
(Rendle et al., 2009) on the MovieLens database (Harper & Konstan, 2015) with a latent dimension
of 20. To satisfy m = B/b, we run SpiderBoost and Sparse SpiderBoost with a large-batch size
B = 1030, small-batch size b = 103, inner loop length of m = 10. For this experiment, we run
SpiderBoost with the following learning rate schedule:
η(a, b,t) = b + (a - b) m——-,
m
where a = 1.0 and b = 0.1. The schedule interpolates from a to b as the algorithm progresses
through the inner loop. For instance, within the inner loop, at iteration 0 the learning rate is 1.0, and
at iteration m the learning rate is 0.1. We believe this is a natural way to utilize the low variance
8
Published as a conference paper at ICLR 2020
at the beginning of the inner loop, and is a fair comparison to an exponential decay learning rate
schedule for SGD. Details of the SGD baselines are provided in Figure 2. We see SpiderBoost is
slightly worse than SGD, and sparsity provides a slight improvement over SGD, especially in the
first few epochs.
5 Conclusion
In this paper, we show how sparse gradients with memory can be used to improve the gradient
query complexity of SVRG-type variance reduction algorithms. While we provide a concrete sparse
variance reduction algorithm for SpiderBoost, the techniques developed in this paper can be adapted
to other variance reduction algorithms.
We show that our algorithm provides a way to explicitly control the gradient query complexity of
variance reduction methods, a problem which has thus far not been addressed. Assuming our algo-
rithm captures the sparsity structure of the optimization problem, we also prove that the complexity
of our algorithm is an improvement over SpiderBoost. The results of our comparison to Spider-
Boost validates this assumption, and entropy measures provided in Table 1 empirically support our
hypothesis that gradient sparsity exists.
Table 1 also supports the results in Aji & Heafield (2017), which shows that the top-k operator
generally outperforms the random-k operator. Our random-top-k operator takes advantage of the
superior performance of the top-k operator while eliminating bias via a secondary random-k opera-
tor. Not every problem we tested exhibited sparsity structure. While this is true, our analysis proves
that our algorithm performs no worse than SpiderBoost in these settings. Even when there is no
structure, our algorithm reduces to a random sampling of k1 + k2 coordinates, which is essentially
a randomized coordinate descent analogue of SpiderBoost. Empirically, we see that Sparse Spider-
Boost outperforms SpiderBoost when no sparsity structure is present. We believe this is due to the
variance introduced by additional covariates in the SpiderBoost update, which is mitigated in Sparse
SpiderBoost by our random-top-k operator.
The results of our experiments on natural language processing and matrix factorization demonstrate
that, with additional effort, variance reduction methods are competitive with SGD. While we view
this as progress toward improving the practical viability of variance reduction algorithms, we believe
further improvements can be made, such as better utilization of reduced variance during training, and
better control over increased variance in very high dimensional models such as dense net (Defazio,
2019). We recognize these issues and hope to make progress on them in future work.
References
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S.
Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew
Harp, Geoffrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz Kaiser, Manjunath
Kudlur, Josh Levenberg, Dan Mane, Rajat Monga, Sherry Moore, Derek Murray, Chris Olah,
Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker, Vin-
cent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden, Martin Watten-
berg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. TensorFlow: Large-scale machine learning
on heterogeneous systems, 2015. URL http://tensorflow.org/. Software available from
tensorflow.org.
Alham Fikri Aji and Kenneth Heafield. Sparse communication for distributed gradient descent.
CoRR, abs/1704.05021, 2017. URL http://arxiv.org/abs/1704.05021.
Zeyuan Allen-Zhu. Katyusha: The first direct acceleration of stochastic gradient methods. In Pro-
Ceedings ofthe 49th Annual ACM SIGACT Symposium on Theory ofComputing, pp. 1200-1205.
ACM, 2017.
Zeyuan Allen-Zhu. Katyusha x: Practical momentum method for stochastic sum-of-nonconvex
optimization. arXiv preprint arXiv:1802.03866, 2018a.
Zeyuan Allen-Zhu.	Natasha 2: Faster non-convex optimization than sgd.	In S. Ben-
gio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett
9
Published as a conference paper at ICLR 2020
(eds.), Advances in Neural Information Processing Systems 31, pp. 2675-2686.
Curran Associates, Inc., 2018b. URL http://papers.nips.cc/paper/
7533-natasha-2-faster-non-convex-optimization-than-sgd.pdf.
Zeyuan Allen-Zhu and Elad Hazan. Variance reduction for faster non-convex optimization. ArXiv
e-prints abs/1603.05643, 2016.
Zeyuan Allen-Zhu and Yang Yuan. Improved SVRG for non-strongly-convex or sum-of-non-convex
objectives. In International conference on machine learning, pp. 1080-1089, 2016.
Yves Chauvin and David E. Rumelhart (eds.). Backpropagation: Theory, Architectures, and Appli-
cations. L. Erlbaum Associates Inc., Hillsdale, NJ, USA, 1995. ISBN 0-8058-1259-8.
Aaron Defazio. On the ineffectiveness of variance reduced optimization for deep learning, 2019.
URL https://openreview.net/forum?id=B1MIBs05F7.
Aaron Defazio, Francis Bach, and Simon Lacoste-Julien. SAGA: A fast incremental gradient
method with support for non-strongly convex composite objectives. In Advances in Neural Infor-
mation Processing Systems, pp. 1646-1654, 2014.
John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and
stochastic optimization. Journal of Machine Learning Research, 12(Jul):2121-2159, 2011.
Cong Fang, Chris Junchi Li, Zhouchen Lin, and Tong Zhang. Spider: Near-optimal non-convex op-
timization via stochastic path-integrated differential estimator. In Advances in Neural Information
Processing Systems, pp. 689-699, 2018.
F. Maxwell Harper and Joseph A. Konstan. The movielens datasets: History and context. ACM
Trans. Interact. Intell. Syst., 5(4):19:1-19:19, December 2015. ISSN 2160-6455. doi: 10.1145/
2827872. URL http://doi.acm.org/10.1145/2827872.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. CoRR, abs/1512.03385, 2015. URL http://arxiv.org/abs/1512.03385.
Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 9(8):
1735-1780, 1997.
Rie Johnson and Tong Zhang. Accelerating stochastic gradient descent using predictive variance
reduction. In Proceedings of the 26th International Conference on Neural Information Processing
Systems - Volume 1, NIPS’13, pp. 315-323, USA, 2013. Curran Associates Inc. URL http:
//dl.acm.org/citation.cfm?id=2999611.2999647.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton. Cifar-10 (canadian institute for advanced re-
search). URL http://www.cs.toronto.edu/~kriz/cifar.html.
Yann LeCun and Corinna Cortes. MNIST handwritten digit database. 2010. URL http://yann.
lecun.com/exdb/mnist/.
Lihua Lei and Michael Jordan. Less than a Single Pass: Stochastically Controlled Stochastic Gradi-
ent. In Proceedings of the 20th International Conference on Artificial Intelligence and Statistics,
volume 54, pp. 148-156. PMLR, 2017.
Lihua Lei and Michael I Jordan. On the adaptivity of stochastic gradient-based optimization. arXiv
preprint arXiv:1904.04480, 2019.
Lihua Lei, Cheng Ju, Jianbo Chen, and Michael I Jordan. Non-convex finite-
sum optimization via scsg methods. In Advances in Neural Information Process-
ing Systems 30, pp. 2348-2358. 2017. URL http://papers.nips.cc/paper/
6829- non- convex- finite- sum- optimization- via- scsg- methods.pdf.
10
Published as a conference paper at ICLR 2020
Mitchell Marcus, Grace Kim, Mary Ann Marcinkiewicz, Robert MacIntyre, Ann Bies, Mark Fer-
guson, Karen Katz, and Britta Schasberger. The penn treebank: Annotating predicate argument
structure. In Proceedings of the Workshop on Human Language Technology, HLT ,94, pp. 114-
119, Stroudsburg, PA, USA, 1994. Association for Computational Linguistics. ISBN 1-55860-
357-3. doi: 10.3115/1075812.1075835. URL https://doi.org/10.3115/1075812.
1075835.
David R Musser. Introspective sorting and selection algorithms. Software: Practice and Experience,
27(8):983-993, 1997.
Arkadi Nemirovski, Anatoli Juditsky, Guanghui Lan, and Alexander Shapiro. Robust stochastic
approximation approach to stochastic programming. SIAM Journal on optimization, 19(4):1574-
1609, 2009.
Yuval Netzer, Tao Wang, Adam Coates, Alessandro Bissacco, Bo Wu, and Andrew Y. Ng. Reading
digits in natural images with unsupervised feature learning. In NIPS Workshop on Deep Learning
and Unsupervised Feature Learning 2011, 2011. URL http://ufldl.stanford.edu/
housenumbers/nips2011_housenumbers.pdf.
Lam M Nguyen, Marten van Dijk, Dzung T Phan, Phuong Ha Nguyen, Tsui-Wei Weng, and Jayant R
Kalagnanam. Optimal finite-sum smooth non-convex optimization with sarah. arXiv preprint
arXiv:1901.07648, 2019.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
pytorch. 2017.
Nhan H Pham, Lam M Nguyen, Dzung T Phan, and Quoc Tran-Dinh. Proxsarah: An effi-
cient algorithmic framework for stochastic composite nonconvex optimization. arXiv preprint
arXiv:1902.05679, 2019.
Sashank J Reddi, Ahmed Hefny, Suvrit Sra, Barnabas Poczos, and Alex Smola. Stochastic variance
reduction for nonconvex optimization. arXiv preprint arXiv:1603.06160, 2016a.
Sashank J Reddi, SUvrit Sra, Barnabas Poczos, and Alex Smola. Fast incremental method for non-
convex optimization. arXiv preprint arXiv:1603.06159, 2016b.
Steffen Rendle, Christoph Freudenthaler, Zeno Gantner, and Lars Schmidt-Thieme. Bpr: Bayesian
personalized ranking from implicit feedback. In Proceedings of the twenty-fifth conference on
uncertainty in artificial intelligence, pp. 452-461. AUAI Press, 2009.
H. Robbins and S. Monro. A stochastic approximation method. Annals of Mathematical Statistics,
22:400-407, 1951.
Nicolas Le Roux, Mark Schmidt, and Francis Bach. A stochastic gradient method with an expo-
nential convergence rate for finite training sets. In Advances in Neural Information Processing
Systems, pp. 2663-2671, 2012.
Sebastian U. Stich, Jean-Baptiste Cordonnier, and Martin Jaggi. Sparsified SGD with memory.
CoRR, abs/1809.07599, 2018. URL http://arxiv.org/abs/1809.07599.
Zhe Wang, Kaiyi Ji, Yi Zhou, Yingbin Liang, and Vahid Tarokh. Spiderboost: A class of faster
variance-reduced algorithms for nonconvex optimization. CoRR, abs/1810.10690, 2018. URL
http://arxiv.org/abs/1810.10690.
Lin Xiao and Tong Zhang. A proximal stochastic gradient method with progressive variance reduc-
tion. SIAM Journal on Optimization, 24(4):2057-2075, 2014.
Dongruo Zhou, Pan Xu, and Quanquan Gu. Stochastic nested variance reduction for nonconvex opti-
mization. In Proceedings of the 32nd International Conference on Neural Information Processing
Systems, pp. 3925-3936. Curran Associates Inc., 2018.
11
Published as a conference paper at ICLR 2020
A Technical Proofs
A. 1 Preparatory results
Lemma 2 (Lemma 3.1 of Lei & Jordan (2019)). Let N 〜Geom(m). Then for any Sequence
D0, D1, . . . with E|DN | < ∞,
E(DN — DN+ι) = 一(Do — EDN).
m
Remark 1. The requirement E|DN | < ∞ is essential. A useful sufficient condition if |Dt | =
O(Poly(t)) because a geometric random variable has finite moments of any order.
Lemma 3 (Lemma B.2 of Lei & Jordan (2019)). Let z1, . . . , zM ∈ Rd be an arbitrary population
and J be a uniform random subset of [M] with size m. Then
V" (；1 X zj)≤ I^ ^ ⅛ X I/.
j∈J	j=1
Proof of Lemma 1. WLOG, assume that |x1 | ≥ |x2 | ≥ . . . ≥ |xd|. Let S be a random subset of
{k1 + 1, . . . , d} with size k2 . Then
(rtoPk1,k2(x,y))' = y，(' ≤ kι) + d-k11(' ∈ S)).
As a result,
E h(rtoPk1,k2(x,y))'i = y，(' ≤ kι) + d k2k11(' > kι)P(' ∈ S)) = ye,
and
Var [(rtopk],k2(χ,y))'i = (d--kλ) y21 (' > kι)P(' ∈ S)(I- P(' ∈ S))
=d - k1 — k2 yI('>kι).
k2
Therefore,
Var (rtoPk1,k2(χ,y)) = d_k_k2 X y2 = d_k_k2k top-kι(x,y)k2.
2	'>kι	2
□
A.2 Analysis of a single inner loop
Lemma 4. For any j, t,
Ej,t(ν(+)ι — ν(j)) = Vf (xt+)ι) — Vf (Xtj))
and
Varj,t(νt¾ - Vy)) ≤ 与kν(j)k2 + d - [-k2 (g(j) + j ,
where Ej,t and Varj,t are taken over the randomness of It(j ) and the random subset S involved in
the rtopk1,k2 operator.
Proof. By definition,
νt(+j)1 - νt(j) = rtopk1,k2 Mt(j), VfI(j)(xt(+j)1) - VfI(j)(xt(j)) .
12
Published as a conference paper at ICLR 2020
Let S be the random subset involved in rtopk ,k . Then S is independent of (It(j), Mt(j), x(tj+)1, xt(j)).
By Lemma 1,
ES (ν(+)ι - ν(j)) = VfIy)(Xt+)I)- VfIy)(Xtj))
and
VarS (用-ν(j)) = d-「Mp-瓦(Mj VfIy)(X“) - VfIy)(Xtj)))『.
Since It(j) is independent of (Mt(j), Xt(+j)1, Xt(j)), the tower property of conditional expectation and
variance implies that
Ej,t (νt(+j)1 - νt(j)) = EI(y) (VfI(y)(Xt(+j)1) - VfI(y)(Xt(j))) =Vf(Xt(+j)1)-Vf(Xt(j)),
and
Varj,t (νt(+j)1 - νt(j)) = EI(y) (VarS (νt(+j)1 - νt(j))) + VarI(y) (ES (νt(+j)1 -νt(j))) .	(8)
To bound the first term, we note that top-k1 is linear in y and thus
EI(y) top-k1 (Mt(j), VfI(y) (Xt(+j)1) - VfI(y)(Xt(j)))2
= EI(y) top-k1 (Mt(j), VfI(y) (X(tj+)1) - VfI(y)(Xt(j)))2
+ VarI(y) htop-k1 (Mt(j), VfI(y) (Xt(j+)1) - VfI(y) (Xt(j)))i
=gt(j + VarIy) 1 X top-kι (Mtjj, Vfi(Xj)I)- Vfi(Xj)))
i∈It(y)
(j)
≤ g(j) + Gr,	(9)
b
where the last inequality uses Lemma 3. To bound the second term of (8), by Lemma 3,
VarI(y) (ES (νt(+j)1 - νt(j))) = VarI(y) (VfI(y)(Xt(+j)1) - VfI(y)(Xt(j)))
≤ 11 X kVfi(Xt+)ι) -Vfi(Xj))k2 ≤) Lb21*1 -Xj)k2 (=) η2L2kν(j)k2,
i=1
where (i) uses assumption A1 and (ii) uses the definition that Xt+)ι = X(j) - ην(j).	□
Lemma 5. For any j, t,
Ej,tkν(+)1 - Vf(XtT)k2 ≤ kν(j) - Vf(X(j))k2 + 华kν(j)k2 + d-L (g(j) + Gj!,
where Ej,t and Varj,t are taken over the randomness of It(j) and the random subset S involved in
the rtopk1,k2 operator.
Proof. By Lemma 4, we have
νt(+j)1 - Vf(X(tj+)1) = νt(j) - Vf(Xt(j)) + (νt(+j)1 - νt(j) -Ej,t(νt(+j)1 - νt(j))) .
Since It(j) is independent of (νt(j), X(tj)),
Covj,t (νt(j) - Vf (Xt(j)), νt(+j)1 - νt(j)) = 0.
As a result,
Ej,tkν(+)1 - Vf(Xt+)ι)k2 = llν(j') - Vf(Xj))k2 + Varj,t(V(+)1 - ν(j)).
The proof is then completed by Lemma 4.	□
13
Published as a conference paper at ICLR 2020
Lemma 6. For any j,
EjkνNj) - Vf(XNj))k2 ≤ mηb2L2EjkVNj)k2 + σ2I(B<^) + (d - kk- k2)mRj
where Ej is taken over all randomness in j-th outer loop (line 4-13 of Algorithm 1). 4.
Proof. By definition,
kνt(+j)1 k ≤
≤
≤
≤
≤
≤
≤
kνt(j)k + rtopk1,k2	Mt(j),VfI(j)(xt(+j)1) -VfI(j)(xt(j))
kνt(j)k + VfI(j) (xt(j+)1) - VfI(j) (x(tj))
kν(j)k + b X IIVfi(X(+)i)-Vfi(X"∣∣
i∈l(j)
kν(j)k + b X IIVfi(X(汨-Vfi(X(j))∣∣2
i∈It(j)
kνt(j) k +
t
kνt(j)k + tu
(
b x ∣∣Vfi(X““I2 + χ	∣∣Vfi(Xtj))∣∣2
i∈It(j)	i∈It(j)
2n	nX I∣Vfi(Xt+)1)∣∣2+1X ∣∣Vfi(Xj
∣∣ν(j)k + √2nσ
i=1
i=1
2
As a result,
IlVy)Il ≤ ∣∣νoj)k + t√2nσ,
Thus,
∣Vtoj)-Vf(Xtoj))∣2 ≤2∣Vtoj)∣2+2∣Vf(Xtoj))∣2 = Poly(t).
This implies that we can apply Lemma 2 on the sequence Dt = ∣Vtoj) - Vf(Xtoj))∣2.
Letting j = Nj in Lemma 5 and taking expectation over all randomness in Ej , we have
Ej∣VNojj)+1-Vf(XoNjj)+1)∣2
≤ EjkVNj)- Vf(XNj )∣2 + η2L2 Ej kν(jj)k2 + d-[-k2 Ej ^Nj) + Gj
=EjkVNj)- Vf(XNj)k2 + η2L2Ejkν(jj)k2 + d - kl2- k2Rj.
By Lemma 2,
EjkVNojj)-Vf(XoNjj))k2-EjkVNojj)+1 -Vf(XoNjj)+1)k2
=m (kν0j) -Vf(X0j))k2 - EjkVNj)-Vf(XN))k2)
=m (EjkVOj)- Vf(Xj-1)k2 - EjkVNjj) - Vf(Xj)k2),
where the last line uses the definition that Xj-1 = Xo0j), Xj = XoNj). By Lemma 3,
EjkVOj)-Vf(Xj-1)k2 ≤ σ2I(B<n).
B
The proof is completed by putting (11), (12) and (13) together.
(10)
(11)
(12)
(13)
□
14
Published as a conference paper at ICLR 2020
Lemma 7. For any j, t,
f(χt+)ι) ≤ f(x(j)) + 2kν(j) - Vf(χ"k2 - 2kVf(χ"k2 - 2(1 - ηL)kVj)K
Proof. By (4),
f (xt+)ι) ≤ f(Xj))+DVf(Xj)),x(+)ι -x(j)E+L kx(j) - x(+)ιk2
=f(Xj)) -η DVf(Xj)),ν(j)E + η2Ll∣ν(j)k2
=f(χj)) + 2kν(j) - Vf(Xj))k2 - 2kVf(Xj))k2 - 2kν(j)k2 + η2Lkν(j)k2.
The proof is then completed.	□
Lemma 8. For any j,
EjkVf(Xj)k2 ≤ ɪEj(f(Xj-1) - f(Xj))+ EjkVNj)-Vf(Xj)k2 - (I- ηL)Ejl∣νNjj)k2,
ηm
where Ej is taken over all randomness in j-th outer loop (line 4-13 of Algorithm 1).
Proof. Since kVf (X)k ≤ σ for any X,
|f(Xt(j+)1) - f(Xt(j))| ≤ σkVt(j)k.
This implies that
t
|f(Xt(j))| ≤ σX kVt(j)k + |f(X(0j))|.
k=0
As shown in (10), kVt(j) k = Poly(t) and thus |f(Xt(j))| = Poly(t). This implies that we can apply
Lemma 2 on the sequence Dt = f (Xt(j)).
Letting j = Nj in Lemma 7 and taking expectation over all randomness in Ej , we have
Ejf (XNj+ι) ≤ Ejf(XNj) + 2kν⅛) - Vf(XN))k2 - 2kVf (XNN))k2 - 2(1 - ηL)kν⅞)k2.
By Lemma 2,
Ejf(XNj) - Ejf (xN)+i) = ɪEj(f (Xj)) - f (XN))) = ɪEj(f(Xj-ι) - f(Xj))∙
j	j	m	jm
The proof is then completed.	□
Combining Lemma 6 and Lemma 8, we arrive at the following key result on one inner loop.
Theorem 3. For any j,
EkVf(Xj)k2 ≤ ɪEj(f (Xj-1) - f (Xj)) + O"/" + (d-kk-k2)mRj
ηm	B	k2
-(1- ηL - mηb2L2)Ej kν⅛)k2.
A.3 Complexity analysis
Proof of Theorem 1. By definition (7) of Rj and the smoothness assumption A1,
ERj ≤ 中L2EkXNT -XNjk2 ≤ 2η2L2EkV(Nj)k2.
15
Published as a conference paper at ICLR 2020
By Theorem 3,
EkVf(Xj)k2 ≤ ηmEj(f (Xj-ι) - f(xj)) + σ2I(B<n)
-卜-ηL - mη2L2 - 2(d— k1 - Fm) Ej |脸)||2.
Since ηL =，kz/6dm,
mη 2 L2
ηL+ +
+ 2(d — kι — k2)mη2L2
1	11
≤√6 + 6 + 3 ≤ 1.
As a result,
EkVf(Xj)k2 ≤ ɪEj(f(xj-ι) - f(Xj)) + σ”(BB<n).
ηm	B
Since XoUt = XT0 where T0 〜Unif([T]), We have
EkVf(Xout)k2 ≤ -2-E(f (xo) - f (xt +1)) + σ2I(B<n) ≤ 冬 + σ2I(B<n)
ηmT	B	ηmT	B
The setting of T and B guarantees that
2∆f e2	σ2I(B < n)心
ηmT ≤ 2 ,	B ≤ 2 .
Therefore,
EkVf(Xout)k2 ≤2.
By Cauchy-Schwarz inequality,
EkVf(Xout)k ≤ VZEkVf(Xout)k2 ≤ e.
In this case, the average computation cost is
ECcomp(e) = T(e) (B + 2(k1 + k2) bm) = 3BT⑹
O ( B∆f )=OEbLf 二
ηm2	2	k2
The proof is then proved by the setting of B .
□
Proof of Theorem 2. Under the setting of η,
mη2 L2	1	1
ηL + - ≤√3 + 3 ≤ 1.
By Theorem 3,
EkVf(Xj)k2 ≤ ɪEj(f(Xj-ι) - f(Xj)) + σ2I(B<n) + d-* -k2Rj.
ηm	B	k2
By definition of Xout,
EkVf(Xout)k2 ≤ 容 + σ^n + Id - k1J k2)mERt.
ηmT	B	k2
Under the settings of T and B,
2∆f e2 σ2I(B < n)心
ηmT ≤ -3 ,	B ≤ "3 .
This proves the first result. The second result follows directly. For the computation cost, similar to
the proof of Theorem 1, we have
ECcomp() = O(BT) = O
L∆f	B
昌 pm(b ∧ m)
The proof is then completed by trivial algebra.
□
16
Published as a conference paper at ICLR 2020
Figure 3: SpiderBoost with various values of sparsity, where (sparsity=k/d) corresponds to Spider-
Boost with sparsity k/d. Both figures use MNIST. The x-axis measures gradient queries over N ,
where N is the size of the respective datasets. Plots are in log-scale.
B Experiments
B.1	Description of Simple Convolutional Neural Network
The simple convolutional neural network used in the experiments consists of a convolutional layer
with a kernel size of 5, followed by a max pool layer with kernel size 2, followed by another convo-
lutional layer with kernel size 5, followed by a fully connected layer of input size 16 × side2 × 120
(side is the size of the second dimension of the input), followed by a fully connected layer of size
120 × 84, followed by a final fully connected layer of size 84× the output dimension.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
B.2	Natural Language Processing
The natural language processing model consists of a word embedding of dimension 128 of 1000
tokens, which is jointly learned with the task. The LSTM has a hidden and cell state dimension of
1024.
Algorithm 2: SpiderBoost for Natural Language Processing.
Input: Learning rate η, inner loop size m, number of iterations T, large batch matrix Z2 with `2
batches of size B, small batch matrix Z1 with `1 batches of size b, initial iterate x0 , initial
states s0 and S0 .
fort = 0,..., T - 1 do
i = mod(t, '1)
j = mod(t,'2)
if i = 0 then
Lst = 0
if j = 0 then
ISt = 0
if mod(t, m) = 0 then
Vt ,St+1 ：= Vfz2j (Xt ,St)
st+1 = st
else
gp := VfZ1i (xt-1 , st-1)
gc,st+1 := VfZ1i(xt, st)
νt := νt-1 + (gc - gb)
S St+1 = St
_ χt+1 ：= Xt — ηνt
Output: xT
Before describing Algorithm 2, let us derive the full batch gradient of a generative language model.
We encode the vocabulary of our dataset of length N so that D ∈ NN is a sequence of integers
corresponding to one-hot encodings of each token. We model the transition p(Di+1|Di, si) using
an RNN model M as M(Di, si) = Di+1, si+1, where si is the sequential model state at step i. The
17
Published as a conference paper at ICLR 2020
model M can be thought of as a classifier with cross entropy loss L and additional dependence on
si . The batch gradient objective can therefore be formulated by considering the full sequence of
predictions from i = 0 to i = N - 1, generating for each step i the output Di+1, si+1. Each token
is one-hot encoded as an integer (from 0 to the size of the vocabulary), so the empirical risk is given
by
1 N-1
J(D； X) = NN EL(Di,Di).
N i=0
Thus, the full batch gradient is simply the gradient of J with respect to x.
In Algorithm 2, D is split into b contiguous sequences of length `1 = N/b and stored in a matrix
Zi ∈ Nb×'1. Taking a pass over Zi requires maintaining a state Si ∈ Nb for each entry in a batch,
which is reset before every pass over Z1. To deal with maintaining state for batches at different time
scales, we define a different matrix Z2 ∈ Nb×'2 which maintains a different set of states Si ∈ NB
for each entry of batch size B. We denote by g, st+i = Vfzj (x, St) the gradient of our model with
respect to x, where NfZIj denotes the gradient function corresponding to the jth batch of matrix
Zi. The function fZ1j simply computes the loss of the jth batch of matrix Zi.
18