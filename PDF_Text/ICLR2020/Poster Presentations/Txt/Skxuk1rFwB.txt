Published as a conference paper at ICLR 2020
Towards Stable and Efficient Training of
Verifiably Robust Neural Networks
HuanZhang1* HonggeChen2 Chaowei Xiao3 SvenGowal4 Robert Stanforth4
Bo Li5 Duane Boning2 Cho-Jui Hsieh1
1 UCLA 2MIT 3 University of Michigan 4 DeepMind 5 UIUC
huan@huan-zhang.com, chenhg@mit.edu, xiaocw@umich.edu
sgowal@google.com, stanforth@google.com
lbo@illinois.edu, boning@mtl.mit.edu, chohsieh@cs.ucla.edu
Ab stract
Training neural networks with verifiable robustness guarantees is challenging.
Several existing approaches utilize linear relaxation based neural network output
bounds under perturbation, but they can slow down training by a factor of hundreds
depending on the underlying network architectures. Meanwhile, interval bound
propagation (IBP) based training is efficient and significantly outperforms linear
relaxation based methods on many tasks, yet it may suffer from stability issues
since the bounds are much looser especially at the beginning of training. In this
paper, we propose a new certified adversarial training method, CROWN-IBP,
by combining the fast IBP bounds in a forward bounding pass and a tight linear
relaxation based bound, CROWN, in a backward bounding pass. CROWN-IBP is
computationally efficient and consistently outperforms IBP baselines on training
verifiably robust neural networks. We conduct large scale experiments on MNIST
and CIFAR datasets, and outperform all previous linear relaxation and bound
propagation based certified defenses in '∞ robustness. Notably, We achieve 7.02%
verified test error on MNIST at = 0.3, and 66.94% on CIFAR-10 with = 8/255.
1	Introduction
The success of deep neural netWorks (DNNs) has motivated their deployment in some safety-critical
environments, such as autonomous driving and facial recognition systems. Applications in these
areas make understanding the robustness and security of deep neural netWorks urgently needed,
especially their resilience under malicious, finely crafted inputs. Unfortunately, the performance
of DNNs are often so brittle that even imperceptibly modified inputs, also knoWn as adversarial
examples, are able to completely break the model (GoodfelloW et al., 2015; Szegedy et al., 2013). The
robustness of DNNs under adversarial examples is Well-studied from both attack (crafting poWerful
adversarial examples) and defence (making the model more robust) perspectives (Athalye et al.,
2018; Carlini & Wagner, 2017a;b; GoodfelloW et al., 2015; Madry et al., 2018; Papernot et al., 2016;
Xiao et al., 2019b; 2018b;c; Eykholt et al., 2018; Chen et al., 2018; Xu et al., 2018; Zhang et al.,
2019b). Recently, it has been shoWn that defending against adversarial examples is a very difficult
task, especially under strong and adaptive attacks. Early defenses such as distillation (Papernot et al.,
2016) have been broken by stronger attacks like C&W (Carlini & Wagner, 2017b). Many defense
methods have been proposed recently (Guo et al., 2018; Song et al., 2017; Buckman et al., 2018; Ma
et al., 2018; Samangouei et al., 2018; Xiao et al., 2018a; 2019a), but their robustness improvement
cannot be certified - no provable guarantees can be given to verify their robustness. In fact, most of
these uncertified defenses become vulnerable under stronger attacks (Athalye et al., 2018; He et al.,
2017).
Several recent Works in the literature seeking to give provable guarantees on the robustness perfor-
mance, such as linear relaxations (Wong & Kolter, 2018; Mirman et al., 2018; Wang et al., 2018a;
Dvijotham et al., 2018b; Weng et al., 2018; Zhang et al., 2018), interval bound propagation (Mirman
et al., 2018; GoWal et al., 2018), ReLU stability regularization (Xiao et al., 2019c), and distributionally
* Work partially done during an internship at DeepMind.
1
Published as a conference paper at ICLR 2020
robust optimization (Sinha et al., 2018) and semidefinite relaxations (Raghunathan et al., 2018a;
Dvijotham et al.). Linear relaxations of neural networks, first proposed by Wong & Kolter (2018),
is one of the most popular categories among these certified defences. They use the dual of linear
programming or several similar approaches to provide a linear relaxation of the network (referred to
as a “convex adversarial polytope”) and the resulting bounds are tractable for robust optimization.
However, these methods are both computationally and memory intensive, and can increase model
training time by a factor of hundreds. On the other hand, interval bound propagation (IBP) is a simple
and efficient method for training verifiable neural networks (Gowal et al., 2018), which achieved
state-of-the-art verified error on many datasets. However, since the IBP bounds are very loose during
the initial phase of training, the training procedure can be unstable and sensitive to hyperparameters.
In this paper, we first discuss the strengths and weakness of existing linear relaxation based and
interval bound propagation based certified robust training methods. Then we propose a new certified
robust training method, CROWN-IBP, which marries the efficiency of IBP and the tightness ofa linear
relaxation based verification bound, CROWN (Zhang et al., 2018). CROWN-IBP bound propagation
involves a IBP based fast forward bounding pass, and a tight convex relaxation based backward
bounding pass (CROWN) which scales linearly with the size of neural network output and is very
efficient for problems with low output dimensions. Additional, CROWN-IBP provides flexibility for
exploiting the strengths of both IBP and convex relaxation based verifiable training methods.
The efficiency, tightness and flexibility of CROWN-IBP allow it to outperform state-of-the-art methods
for training verifiable neural networks with '∞ robustness under all E settings on MNIST and CIFAR-
10 datasets. In our experiment, on MNIST dataset we reach 7.02% and 12.06% IBP verified error
under '∞ distortions E = 0.3 and E = 0.4, respectively, outperforming the state-of-the-art baseline
results by IBP (8.55% and 15.01%). On CIFAR-10, at E =短,CROWN-IBP decreases the verified
error from 55.88% (IBP) to 46.03% and matches convex relaxation based methods; at a larger E,
CROWN-IBP outperforms all other methods with a noticeable margin.
2	Related Work and Background
2.1	Robustness Verification and Relaxations of Neural Networks
Neural network robustness verification algorithms seek for upper and lower bounds of an output
neuron for all possible inputs within a set S, typically a norm bounded perturbation. Most importantly,
the margins between the ground-truth class and any other classes determine model robustness.
However, it has already been shown that finding the exact output range is a non-convex problem
and NP-complete (Katz et al., 2017; Weng et al., 2018). Therefore, recent works resorted to giving
relatively tight but computationally tractable bounds of the output range with necessary relaxations of
the original problem. Many of these robustness verification approaches are based on linear relaxations
of non-linear units in neural networks, including CROWN (Zhang et al., 2018), DeepPoly (Singh
et al., 2019), Fast-Lin (Weng et al., 2018), DeepZ (Singh et al., 2018) and Neurify (Wang et al.,
2018b). We refer the readers to (Salman et al., 2019b) for a comprehensive survey on this topic. After
linear relaxation, they bound the output of a neural network fi(∙) by linear upper/lower hyper-planes:
A^∆x + bL ≤ fi(xo + ∆x) ≤ A^∆x + bu	(1)
where a row vector Ai ： = W(L)D(LT)W(LT)…D(I)W(I) is the product of the network weight
matrices W(l) and diagonal matrices D(l) reflecting the ReLU relaxations for output neuron i; bL
and bU are two bias terms unrelated to ∆x. Additionally, Dvijotham et al. (2018c;a); Qin et al. (2019)
solve the Lagrangian dual of verification problem; Raghunathan et al. (2018a;b); Dvijotham et al.
propose semidefinite relaxations which are tighter compared to linear relaxation based methods, but
computationally expensive. Bounds on neural network local Lipschitz constant can also be used
for verification (Zhang et al., 2019c; Hein & Andriushchenko, 2017). Besides these deterministic
verification approaches, randomized smoothing can be used to certify the robustness of any model in
a probabilistic manner (Cohen et al., 2019; Salman et al., 2019a; Lecuyer et al., 2018; Li et al., 2018).
2.2	Robust Optimization and Verifiable Adversarial Defense
To improve the robustness of neural networks against adversarial perturbations, a natural idea is to
generate adversarial examples by attacking the network and then use them to augment the training
set (Kurakin et al., 2017). More recently, Madry et al. (2018) showed that adversarial training can
2
Published as a conference paper at ICLR 2020
be formulated as solving a minimax robust optimization problem as in (2). Given a model with
parameter θ, loss function L, and training data distribution X, the training algorithm aims to minimize
the robust loss, which is defined as the maximum loss within a neighborhood {x + δ∣δ ∈ S} of each
data point x, leading to the following robust optimization problem:
min E
θ (x,y)∈X
max L(x + δ; y; θ)
(2)
Madry et al. (2018) proposed to use projected gradient descent (PGD) to approximately solve the
inner max and then use the loss on the perturbed example x + δ to update the model. Networks
trained by this procedure achieve state-of-the-art test accuracy under strong attacks (Athalye et al.,
2018; Wang et al., 2018a; Zheng et al., 2018). Despite being robust under strong attacks, models
obtained by this PGD-based adversarial training do not have verified error guarantees. Due to the
nonconvexity of neural networks, PGD attack can only compute the lower bound of robust loss (the
inner maximization problem). Minimizing a lower bound of the inner max cannot guarantee (2) is
minimized. In other words, even if PGD-attack cannot find a perturbation with large loss, that does
not mean there exists no such perturbation. This becomes problematic in safety-critical applications
since those models need certified safety.
Verifiable adversarial training methods, on the other hand, aim to obtain a network with good
robustness that can be verified efficiently. This can be done by combining adversarial training
and robustness verification—instead of using PGD to find a lower bound of inner max, certified
adversarial training uses a verification method to find an upper bound of the inner max, and then
update the parameters based on this upper bound of robust loss. Minimizing an upper bound of the
inner max guarantees to minimize the robust loss. There are two certified robust training methods
that are related to our work and we describe them in detail below.
Linear Relaxation Based Verifiable Adversarial Training. One of the most popular verifiable
adversarial training method was proposed in (Wong & Kolter, 2018) using linear relaxations of
neural networks to give an upper bound of the inner max. Other similar approaches include Mirman
et al. (2018); Wang et al. (2018a); Dvijotham et al. (2018b). Since the bound propagation process
of a convex adversarial polytope is too expensive, several methods were proposed to improve its
efficiency, like Cauchy projection (Wong et al., 2018) and dynamic mixed training (Wang et al.,
2018a). However, even with these speed-ups, the training process is still slow. Also, this method
may significantly reduce a model’s standard accuracy (accuracy on natural, unmodified test set). As
we will demonstrate shortly, we find that this method tends to over-regularize the network during
training, which is harmful for obtaining good accuracy.
Interval Bound Propagation (IBP). Interval Bound Propagation (IBP) uses a very simple rule
to compute the pre-activation outer bounds for each layer of the neural network. Unlike linear
relaxation based methods, IBP does not relax ReLU neurons and does not consider the correlations
between neurons of different layers, yielding much looser bounds. Mirman et al. (2018) proposed a
variety of abstract domains to give sound over-approximations for neural networks, including the
“Box/Interval Domain” (referred to as IBP in Gowal et al. (2018)) and showed that it could scale to
much larger networks than other works (Raghunathan et al., 2018a) could at the time. Gowal et al.
(2018) demonstrated that IBP could outperform many state-of-the-art results by a large margin with
more precise approximations for the last linear layer and better training schemes. However, IBP can
be unstable to use and hard to tune in practice, since the bounds can be very loose especially during
the initial phase of training, posing a challenge to the optimizer. To mitigate instability, Gowal et al.
(2018) use a mixture of regular and minimax robust cross-entropy loss as the model’s training loss.
3	Methodology
Notation. We define an L-layer feed-forward neural network recursively as:
f(x) = z(L)	z(l) = W(l) h(l-1) + b(l)	W(l) ∈ Rnl×nl-1	b(l) ∈ Rnl
h(l) = σ(l) (z(l)),	∀l ∈ {1, . . . ,L - 1},
where h(0) (x) = x, n0 represents input dimension and nL is the number of classes, σ is an element-
wise activation function. We use z to represent pre-activation neuron values and h to represent
3
Published as a conference paper at ICLR 2020
Dataset	e ('∞ norm)	CAP verified error	CROWN verified error	IBP verified error
	0∏	890%	7.05%	583%
MNIST	0.2	45.37%	24.17%	7.37%
	0.3	97.77%	65.26%	10.68%
	0.4	99.98%	99.57%	16.76%
Fashion-MNIST	071	44.64%	36.85%	23.49%
CIFAR-10	2/255	62.94%	60.83%	58.75%
	8/255	91.44%	82.68%	73.34%
Table 1: IBP trained models have low IBP verified errors but when verified with a typically much
tighter bound, including convex adversarial polytope (CAP) (Wong et al., 2018) and CROWN (Zhang
et al., 2018), the verified errors increase significantly. CROWN is generally tighter than convex
adversarial polytope however the gap between CROWN and IBP is still large, especially at large .
We used a 4-layer CNN network for all datasets to compute these bounds.1
post-activation neuron values. Consider an input example xk with ground-truth label yk, we define
a set of S(xk, ) = {x|kx - xkk∞ ≤ } and we desire a robust network to have the property
yk = argmaxj [f (x)]j for all x ∈ S. We define element-wise upper and lower bounds for z(l) and
h(l) as z(l) ≤ Z(I) ≤ z(l) and h(l) ≤ h(l) ≤ h(l).
Verification Specifications. Neural network verification literature typically defines a specification
vector c ∈ RnL, that gives a linear combination for neural network output: c> f (x). In robustness
verification, typically we set ci = 1 where i is the ground truth class label, cj = -1 where j is the
attack target label and	other elements in c are 0. This represents the margin between	class i	and	class
j. For an	nL class classifier and a given label y, we define a specification matrix C	∈ RnL	×nL	as:
{1, if j = y, i = y (output of ground truth class)
-1, if i = j, i 6= y (output of other classes, negated)	(3)
0,	otherwise (note that the y-th row contains all 0)
Importantly, each element in vector m := Cf (x) ∈ RnL gives us margins between class y and all
other classes. We define the lower bound of Cf (x) for all X ∈ S(xk, e) as m(xk, e), which is a very
important quantity: when all elements of m(xk, e) > 0, Xk is verifiably robust for any perturbation
with '∞ norm less than e. m(xk, e) can be obtained by a neural network verification algorithm, such
as convex adversarial polytope, IBP, or CROWN. Additionally, Wong & Kolter (2018) showed that
for cross-entropy (CE) loss:
max、L(f(x)； y； θ) ≤ L(-m(xk,e); y; θ).	(4)
x∈S (xk,)
(4)	gives us the opportunity to solve the robust optimization problem (2) via minimizing this tractable
upper bound of inner-max. This guarantees that maxx∈S(xk ,)L(f(X), y) is also minimized.
3.1	Analysis of IBP and Linear Relaxation based Verifiable Training Methods
Interval Bound Propagation (IBP) Interval Bound Propagation (IBP) uses a simple bound propa-
gation rule. For the input layer we set XL ≤ X ≤ XU element-wise. For affine layers we have:
h(l-1) + h(i-i)	h(l-1) - h(i-i)
Z(I) = W(I)--------+h——+ IW(I)I-----------------h——+	b(I)	(5)
h(l-1) + h(i-i)	h(IT) _ h(i-i)
ZI) = W(I)--------+=------------|W(l)|----------h——+	b(I)	(6)
where |W(l)| takes element-wise absolute value. Note that =( = XU and =(O) = xl2. And for
element-wise monotonic increasing activation functions σ,
=(I) = σ(Z(I))	=(I) = σ(z(l)).	(7)
1We implemented CROWN with efficient CNN support on GPUs: https://github.com/huanzhang12/CROWN-IBP
2For inputs bounded with general norms, IBP can be applied as long as this norm can be converted to per-neuron
intervals after the first affine layer. For example, for 'p norms (1 ≤ P ≤ ∞) Holder,s inequality can be applied
at the first affine layer to obtain h(1) and h(1), and IBP rule for later layers do not change.
4
Published as a conference paper at ICLR 2020
We found that IBP can be viewed as training a simple augmented ReLU network which is friendly to
optimizers (see Appendix A for more discussions). We also found that a network trained using IBP
can obtain good verified errors when verified using IBP, but it can get much worse verified errors
using linear relaxation based verification methods, including convex adversarial polytope (CAP)
by Wong & Kolter (2018) (equivalently, Fast-Lin by Weng et al. (2018)) and CROWN (Zhang et al.,
2018). Table 1 demonstrates that this gap can be very large on large .
However, IBP is a very loose bound during the initial phase of training, which makes training unstable
and hard to tune; purely using IBP frequently leads to divergence. Gowal et al. (2018) proposed to
use a schedule where is gradually increased during training, and a mixture of robust cross-entropy
loss with natural cross-entropy loss as the objective to stabilize training:
min
θ
E	κL(x; y; θ) + (1 - κ)L(-miBp(x, e); y;
(χ,y)∈x
θ) ,
(8)
Issues with linear relaxation based training. Since IBP hugely outperforms linear relaxation
based methods in the recent work (Gowal et al., 2018) in many settings, we want to under-
stand what is going wrong with linear relaxation based methods. We found that, empirically, the
norm of the weights in the models produced by linear relaxation based methods such as (Wong
& Kolter, 2018) and (Wong et al., 2018) does not change or even decreases during training.
In Figure 1 we train a small 4-layer MNIST model and
we linearly increase e from 0 to 0.3 in 60 epochs. We plot
the '∞ induced norm of the 2nd CNN layer during the
training process of CROWN-IBP and (Wong et al., 2018).
The norm of weight matrix using (Wong et al., 2018)
does not increase. When e becomes larger (roughly at e =
0.2, epoch 40), the norm even starts to decrease slightly,
indicating that the model is forced to learn smaller norm
weights. Meanwhile, the verified error also starts to ramp
up possibly due to the lack of capacity. We conjecture
that linear relaxation based training over-regularizes the
model, especially at a larger e. However, in CROWN-IBP,
the norm of weight matrices keep increasing during the
training process, and verifiable error does not significantly
increase when e reaches 0.3.
Another issue with current linear relaxation based training
or verification methods is their high computational and
memory cost, and poor scalability. For the small network
Figure 1: Verified error and 2nd CNN
layer's '∞ induced norm for a model
trained using (Wong et al., 2018) and
CROWN-IBP. e is increased from 0 to
0.3 in 60 epochs.
in Figure 1, convex adversarial polytope (with 50 random Cauchy projections) is 8 times slower
and takes 4 times more memory than CROWN-IBP (without using random projections). Convex
adversarial polytope scales even worse for larger networks; see Appendix J for a comparison.
3.2	The proposed algorithm: CROWN-IBP
Overview. We have reviewed IBP and linear relaxation based methods above. As shown in Gowal
et al. (2018), IBP performs well at large e with much smaller verified error, and also efficiently scales
to large networks; however, it can be sensitive to hyperparameters due to its very imprecise bound at
the beginning phase of training. On the other hand, linear relaxation based methods can give tighter
lower bounds at the cost of high computational expenses, but it over-regularizes the network at large
e and forbids us to achieve good standard and verified accuracy. We propose CROWN-IBP, a new
certified defense where we optimize the following problem (θ represents the network parameters):
IBP bound
min
θ
E
(x,y)∈X
IK L(x;y; θ)+(
1	{z	,
natural loss
}|
CROWN-IBP bound
r	、	，
1 - K) L( - ((1 - β)mIBP(x, e) + (βmC
X------------------------------------
robust loss
ROWN-IBP(x,e)); y; θ)],
(9)
where our lower bound of margin m(x, e) is a combination of two bounds with different natures:
IBP, and a CROWN-style bound (which will be detailed below); L is the cross-entropy loss. Note
that the combination is inside the loss function and is thus still a valid lower bound; thus (4) still
holds and we are within the minimax robust optimization theoretical framework. Similar to IBP and
z
z
5
Published as a conference paper at ICLR 2020
TRADES (Zhang et al., 2019a), we use a mixture of natural and robust training loss with parameter
κ, allowing us to explicitly trade-off between clean accuracy and verified accuracy.
In a high level, the computation of the lower bounds of CROWN-IBP (mcR0WN-iBp(x, E)) consists
of IBP bound propagation in a forward bounding pass and CROWN-style bound propagation in a
backward bounding pass. We discuss the details of CROWN-IBP algorithm below.
Forward Bound Propagation in CROWN-IBP. In CROWN-IBP, We first obtain z(l) and z(l) for
all layers by applying (5), (6) and (7). Then we will obtain mIBP(x, E) = Z(L) (assuming C is merged
into W(L)). The time complexity is comparable to two forward propagation passes of the network.
Linear Relaxation of ReLU neurons Given z(l) and Z(l) computed in the previous step, we first
check if some neurons are always active (Zkl) > 0) or always inactive (Zkl) < 0), since they are
effectively linear and no relaxations are needed. For the remaining unstable neurons, Zhang et al.
(2018); Wong & Kolter (2018) give a linear relaxation for ReLU activation function:
αkZkl) ≤ σ(zkl)) ≤ Mk 2⑷ Zkl)—三ZkZk(I), fora∏ k ∈ [nl] andZkl) < 0 <zkl), (IO)
where 0 ≤ αk ≤ 1; Zhang et al. (2018) propose to adaptively select ak = 1 when Zkl) > IZkl)I
and 0 otherwise, which minimizes the relaxation error. Following (10), for an input vector Z(l), we
effectively replace the ReLU layer with a linear layer, giving upper or lower bounds of the output:
D(I)Z(I) ≤ σ(Z⑴)≤ D(I)Z(I) + Cdl)	(11)
where D(I) and D(I) are two diagonal matrices representing the “weights” of the relaxed ReLU
layer. Other general activation functions can be supported similarly. In the following we focus on
conceptually presenting the algorithm, while more details of each term can be found in the Appendix.
Backward Bound Propagation in CROWN-IBP. Unlike IBP, CROWN-style bounds start bound-
ing from the last layer, so we refer to it as backward bound propagation (not to be confused with
the back-propagation algorithm to obtain gradients). Suppose we want to obtain the lower bound
[mCROWN-IBP(x，E)]i ：= Z(L) (we assume the specification matrix C has been merged into W(L)).
The input to layer W(L) is σ(Z(L-1)), which can be bounded linearly by Eq. (11). CROWN-style
bounds choose the lower bound of σ(Zk(L-1)) (LHS of (11)) when Wi(,Lk) is positive, and choose the
upper bound otherwise.We then merge W(L) and the linearized ReLU layer together and define:
A(LT)= W(L)Di,(L-I)	where Di，(LT) = JDk,k 1J if Wi,k > 0	(⑵
Ai，:	= Wi，: D , WhereDk,k = (DkLkT), if W(Lk) ≤ 0	(12)
,	i,k
Now we have a lower bound Z(L) = AiLT)Z(LT) + b(LT) ≤ ZiL) where 丛LT)=
Pk w(l)<o WiL)Ckl) + b(L) collects all terms not related to Z(LT). Note that the diagonal matrix
， i,k <	，
Di，(L-1) implicitly depends on i. Then, we merge Ai(，L: -1) with the next linear layer, which is straight
forward by plugging in Z(L-1) = W(L-1)σ(Z(L-2)) + b(L-1):
ZiL) ≥ A(LT)W(LT)σ(Z(L-2)) + A(,L-1)b(LT) + 丛LT).
Then we continue to unfold the next ReLU layer σ(Z(L-2)) using its linear relaxations, and compute
a new A(L-2) ∈ RnL ×nL-2 matrix, with Ai(，L: -2) = Ai(，L: -1)W(L-1)Di，(L-2) in a similar manner
as in (12). Along with the bound propagation process, we need to compute a series of matrices,
A(LT),…, A(0), where Aɪl) = Ail+1)W(l+1)Di,(l) ∈ RnL×n(i), and A(O) = A(I)W(I)
WiL)Di,(L-I)W(L-2)Di,(L-2)A(L-2)…Di,(i)W(i). At this point, we merged all layers ofthe
network into a linear layer: ZiL) ≥ A(O)X + b, where b collects all terms not related to x. A lower
bound for Zi(L) with xL ≤ x ≤ xU can then be easily given as
mC
(L)
ROWN-IBP] i ≡ Zi
A(O)X + b ≥ Xk,Ai0k<o A(Ok)xU,k + Xk,Ai0k>o AiOk)XL,k + b
(13)
6
Published as a conference paper at ICLR 2020
For ReLU networks, convex adversarial polytope (Wong & Kolter, 2018) uses a very similar bound
propagation procedure. CROWN-style bounds allow an adaptive selection of αi in (10), thus often
gives better bounds (e.g., see Table 1). We give details on each term in Appendix L.
Computational Cost. Ordinary CROWN (Zhang et al., 2018) and convex adversarial poly-
tope (Wong & Kolter, 2018) use (13) to compute all intermediate layer's z(m) and Zim) (m ∈ [L]),
by considering W(m) as the final layer of the network. For each layer m, we need a different set of
m A matrices, defined as Am,(l), l ∈ {m 一 1,…，0}. This causes three computational issues:
•	Unlike the last layer W(L), an intermediate layer W(m) typically has a much larger output
dimension nm》ul thus all Am,(I) ∈ {Am,(m-1),…,Am,(0)} have large dimensions Rnm×nl.
•	Computation of all Am,(l) matrices is expensive. Suppose the network has n neurons for all L 一 1
intermediate and input layers and nL n neurons for the output layer (assuming L ≥ 2), the time
complexity of ordinary CROWN or convex adversarial polytope is O(PlL=-12 ln3 + (L 一 1)nLn2) =
O((L 一 1)2n3 + (L 一 1)nLn2) = O(Ln2(Ln + nL)). A ordinary forward propagation only takes
O(Ln2) time per example, thus ordinary CROWN does not scale up to large networks for training,
due to its quadratic dependency in L and extra Ln times overhead.
•	When both W(l) and W(l-1) represent convolutional layers with small kernel tensors K(l) and
K(l-1), there are no efficient GPU operations to form the matrix W(l)D(l-1)W(l-1) using K(l)
and K(l-1). Existing implementations either unfold at least one of the convolutional kernels to fully
connected weights, or use sparse matrices to represent W(l) and W(l-1). They suffer from poor
hardware efficiency on GPUs.
In CROWN-IBP, we use IBP to obtain bounds of intermediate layers, which takes only twice the
regular forward propagate time (O(Ln2)), thus we do not have the first and second issues. The time
complexity of the backward bound propagation in CROWN-IBP is O((L 一 1)nLn2), only nL times
slower than forward propagation and significantly more scalable than ordinary CROWN (which is Ln
times slower than forward propagation, where typically n nL). The third convolution issue is also
not a concern, since we start from the last specification layer W(L) which is a small fully connected
layer. Suppose we need to compute W(L)D(L-1)W(L-1) and W(L-1) is a convolutional layer
with kernel K(L-1), we can efficiently compute (W(L-1)>(D(L-1)W(L)>))> on GPUs using the
transposed convolution operator with kernel K(L-1), without unfolding any convoluational layers.
Conceptually, the backward pass of CROWN-IBP propagates a small specification matrix W(L)
backwards, replacing affine layers with their transposed operators, and activation function layers with
a diagonal matrix product. This allows efficient implementation and better scalability.
Benefits of CROWN-IBP. Tightness, efficiency and flexibility are unique benefits of CROWN-IBP:
•	CROWN-IBP is based on CROWN, a tight linear relaxation based lower bound which can greatly
improve the quality of bounds obtained by IBP to guide verifiable training and improve stabability;
•	CROWN-IBP avoids the high computational cost of convex relaxation based methods : the time
complexity is reduced from O(Ln2 (Ln + nL)) to O(Ln2nL), well suited to problems where the
output size nL is much smaller than input and intermediate layers’ sizes; also, there is no quadratic
dependency on L. Thus, CROWN-IBP is efficient on relatively large networks;
•	The objective (9) is strictly more general than IBP and allows the flexibility to exploit the strength
from both IBP (good for large ) and convex relaxation based methods (good for small ). We can
slowly decrease β to 0 during training to avoid the over-regularization problem, yet keeping the initial
training of IBP more stable by providing a much tighter bound; we can also keep β = 1 which helps
to outperform convex relaxation based methods in small regime (e.g., = 2/255 on CIFAR-10).
4 Experiments
Models and training schedules. We evaluate CROWN-IBP on three models that are similar to the
models used in (Gowal et al., 2018) on MNIST and CIFAR-10 datasets with different '∞ perturbation
norms. Here we denote the small, medium and large models in Gowal et al. (2018) as DM-small,
DM-medium and DM-large. During training, we first warm up (regular training without robust loss)
7
Published as a conference paper at ICLR 2020
for a fixed number of epochs and then increase from 0 to train using a ramp-up schedule of R epochs.
Similar techniques are also used in many other works (Wong et al., 2018; Wang et al., 2018a; Gowal
et al., 2018). For both IBP and CROWN-IBP, a natural cross-entropy (CE) loss with weight κ (as in
Eq (9)) may be added, and κ is scheduled to linearly decrease from κstart to κend within R ramp-up
epochs. Gowal et al. (2018) used κstart = 1 and κend = 0.5. To understand the trade-off between
verified accuracy and standard (clean) accuracy, we explore two more settings: κstart = κend = 0
(without natural CE loss) and κstart = 1, κend = 0. For β, a linear schedule during the ramp-up period
is used, but we always set βstart = 1 and βend = 0, except that we set βstart = βend = 1 for CIFAR-10
at e = 255. Detailed model structures and hyperparameters are in Appendix C. Our training code for
IBP and CROWN-IBP, and pre-trained models are publicly available 3.
Metrics. Verified error is the percentage of test examples where at least one element in the lower
bounds m(xk, e) is < 0. It is an guaranteed upper bound of test error under any '∞ perturbations.
We obtain m(xk, e) using IBP or CROWN-IBP (Eq. 13). We also report standard (clean) errors and
errors under 200-step PGD attack. PGD errors are lower bounds of test errors under '∞ perturbations.
Comparison to IBP. Table 2 represents the standard, verified and PGD errors under different e
for each dataset with different κ settings. We test CROWN-IBP on the same model structures in
Table 1 of Gowal et al. (2018). These three models’ architectures are presented in Table A in the
Appendix. Here we only report the DM-large model structure in as it performs best under all setttings;
small and medium models are deferred to Table C in the Appendix. When both κstart = κend = 0,
no natural CE loss is added and the model focuses on minimizing verified error, but the lack of
natural CE loss may lead to unstable training, especially for IBP; the κstart = 1, κend = 0.5 setting
emphasizes on minimizing standard error, usually at the cost of slightly higher verified error rates.
κstart = 1, κend = 0 typically achieves the best balance. We can observe that under the same κ settings,
CROWN-IBP outperforms IBP in both standard error and verified error. The benefits of CROWN-IBP
is significant especially when model is large and e is large. We highlight that CROWN-IBP reduces
the verified error rate obtained by IBP from 8.21% to 7.02% on MNIST at e = 0.3 and from 55.88%
to 46.03% on CIFAR-10 at e = 2/255 (it is the first time that an IBP based method outperforms
results from (Wong et al., 2018), and our model also has better standard error). We also note that we
are the first to obtain verifiable bound on CIFAR-10 at e = 16/255.
Trade-off Between Standard Accuracy and Verified Ac-
curacy. To show the trade-off between standard and ver-
ified accuracy, we evaluate DM-large CIFAR-10 model with
etest = 8/255 under different κ settings, while keeping
all other hyperparameters unchanged. For each κend =
{0.5, 0.25, 0}, we uniformly choose 11 κstart ∈ [1, κend]
while keeping all other hyper-parameters unchanged. A
larger κstart or κend tends to produce better standard errors,
and we can explicitly control the trade-off between standard
accuracy and verified accuracy. In Figure 2 we plot the stan-
dard and verified errors of IBP and CROWN-IBP trained
models with different κ settings. Each cluster on the figure
has 11 points, representing 11 different κstart values. Models
with lower verified errors tend to have higher standard er-
rors. However, CROWN-IBP clearly outperforms IBP with
improvement on both standard and verified accuracy, and
Figure 2: Standard and verified errors
of IBP and CROWN-IBP with differ-
ent κstart and κend values.
pushes the Pareto front towards the lower left corner, indicating overall better performance. To reach
the same verified error of 70%, CROWN-IBP can reduce standard error from roughly 55% to 45%.
Training Stability. To discourage hand-tuning on a small set of models and demonstrate the
stability of CROWN-IBP over a broader range of models, we evaluate IBP and CROWN-IBP on
a variety of small and medium sized model architectures (18 for MNIST and 17 for CIFAR-10),
detailed in Appendix D. To evaluate training stability, we compare verified errors under different e
ramp-up schedule length (R = {30, 60, 90, 120} on CIFAR-10 and R = {10, 15, 30, 60} on MNIST)
3 TensorFlow implementation and pre-trained models: https://github.com/deepmind/interval-bound-propagation/
PyTorch implementation and pre-trained models: https://github.com/huanzhang12/CROWN-IBP
8
Published as a conference paper at ICLR 2020
Table 2: The verified, standard (clean) and PGD attack errors for models trained using IBP and
CROWN-IBP on MNIST and CIFAR-10. We only present performance on model DM-large here
due to limited space (see Table C for a full comparison). CROWN-IBP outperforms IBP under all κ
settings, and achieves state-of-the-art performance on both MNIST and CIFAR datasets for all .
Dataset	C ('∞ norm)	Training Method	K schedules κstart I κend		Model errors (% Standard ∣ Verified		) PGD		Best errors reported in literature (%) Source	∣ Standard Verified		
MNIST	—=0.1 Ctrain = 0∙2	IBP	0 1 1	0 0.5 0	1.13 1.08 1.14	2.89 2.75 2.81 2.36 2.38 2.24	2.24 2.02 2.11		Gowaletal. (2018) Dvijotham et al. (2018b) Xiaoetal. (2019c) Wongetal. (2018) Mirman et al. (2018)	1.06 1.2 1.05 1.08 1.0	2.92* 4.44 4.4 3.67 3.4
		CROWN-IBP	-0- 1 1	-0- 0.5 0	W- 0.95 1.17		1.91 1.77 1.81				
	Ctest = 0.2 c train = °∙4	IBP	0 1 1	0 0.5 0	-345~ 2.12 2.74	~6.46- 4.75 5.46 5.15 4.13 4.31	6.00 4.24 4.89		Gowaletal. (2018) Xiaoetal. (2019c)	1.66 1.9	4.53* 10.21
		CROWN-IBP	-0- 1 1	-0- 0.5 0	-284- 1.82 2.17		4.90 3.81 3.99				
	CteSt = 0.3 c train = °∙4	IBP	0 1 1	0 0.50 0	-345- 2.12 2.74	9.76 8.47 8.73 7.65 7.02 7.03	8.42 6.78 7.37		Gowaletal. (2018) Wongetal. (2018) Xiaoetal. (2019c)	~1766- 14.87 2.67	8.21* 43.1 19.32
		CROWN-IBP	-0- 1 1	-0- 0.5 0	-2:84- 1.82 2.17		6.90 6.05 6.12				
	ctest = 0.4 c train = °∙4	IBP	0 1 1	0 0.5 0	-345~ 2.12 2.74	16.19 15.37 14.80 12.74 12.59 12.06	12.73 11.05 11.14		Gowaletal. (2018)	~1766-	15.01*
		CROWN-IBP	-0- 1 1	-0- 0.5 0	-284- 1.82 2.17		10.39 9.58 9.47				
CIFAR-10	c. , - ɪ § CteSt = 255 U	— 22 * Ctrain = 255	IBP	0 1 1	0 0.5 0	38.54 33.77 39.22	55.21 — 58.48 55.19 46.03 50.53 46.43	49.72 50.54 50.40		Gowaletal. (2018) Mirman et al. (2018) Wongetal. (2018) Xiaoetal. (2019c)	29.84 38.0 31.72 38.88	55.88* 47.8 46.11 54.07
		CROWN-IBP	-0- 1 1	-0- 0.5 0	-28.48- 26.19 28.91		40.28 40.24 40.27				
	U.一上 CteSt = 255 C, . = 8.8 * Ctram = 255	IBP	0 1 1	0 0.5 0	59.41 49.01 58.43	71.22 72.68 70.81 66.94 69.55 67.76	68.96 68.14 68.73		Gowaletal. (2018) Dvijotham et al. (2018b) Xiaoetal. (2019c) Wongetal. (2018) Mirman et al. (2019)	50.51 — 51.36 59.55 71.33 59.8	(68.44)+ 73.33 79.73 78.22 76.8
		CROWN-IBP	-0- 1 1	o~0~ 0.5 0	-54.02- 45.47 55.27		65.42 65.74 65.71				
	U	- J6 CteSt = 255 U	_ 17.6 * Ctrain = 255	IBP	0 1 1	0 0.5 0	68.97 59.46 68.88	78.12 80.85 78.91 77.27 78.20 76.80	76.66 76.97 76.95		None, but our best verified test error (76.80%) and standard test error (66.06%) are both better than Wong et al. (2018) at C = 2∣5, despite our c being twice larger.		
		CROWN-IBP	-0- 1 1	-0- 0.5 0	-67717- 56.73 66.06		75.76 74.87 75.23				
*	Verified errors reported in Table 4 of Gowal et al. (2018) are evaluated using mixed integer programming (MIP) and linear programming (LP), which are
strictly smaller than IBP verified errors but computationally expensive. For a fair comparison, we use the IBP verified errors reported in their Table 3.
t According to direct communications with GoWal et al. (2018), achieving the 68.44% IBP verified error requires to adding an extra PGD adversarial
training loss. Without adding PGD, the verified error is 72.91% (LP/MIP verified) or 73.52% (IBP verified). Our result should be compared to 73.52%.
*	Although not explicitly mentioned, the CIFAR-10 models in (GoWal et al., 2018) are trained using etrain = Lktest. WethUS follow their settings.
§	We use βstart = βend = 1 for this setting, and thus CROWN-IBP bound (β = 1) is used to evaluate the verified error.
and different κ settings. Instead of reporting just the best model, we compare the best, worst and
median verified errors over all models. Our results are presented in Figure 3: (a) is for MNIST
with = 0.3; (c),(d) are for CIFAR with = 8/255. We can observe that CROWN-IBP achieves
better performance consistently under different schedule length. In addition, IBP with κ = 0 cannot
stably converge on all models when schedule is short; under other κ settings, CROWN-IBP always
performs better. We conduct additional training stability experiments on MNIST and CIFAR-10
dataset under other model and settings and the observations are similar (see Appendix H).
5 Conclusions
We propose a new certified defense method, CROWN-IBP, by combining the fast interval bound
propagation (IBP) bound and a tight linear relaxation based bound, CROWN. Our method enjoys
high computational efficiency provided by IBP while facilitating the tight CROWN bound to stabilize
training under the robust optimization framework, and provides the flexibility to trade-off between the
two. Our experiments show that CROWN-IBP consistently outperforms other IBP baselines in both
standard errors and verified errors and achieves state-of-the-art verified test errors for '∞ robustness.
9
Published as a conference paper at ICLR 2020
05
缶P①一M—μ①>
0 5 0
2 11
10	15	30	60
Schedule Length
⅛tω P @M-μ ① >
0.800
0.775
0.750
0.725
0.700
5 0 5 0 5
6 6 5 5 4
6 6 6 6s
⅛tω P @M-μ ① >
(a) MNIST, e = 0.3, best 7.46%	(b) CIFAR, e = 285, best 70.51% (C) CIFAR, e = 225, best 49.28%
Figure 3: Verified error vs. schedule length on 8 medium MNIST models and 8 medium CIFAR-10
models. The solid bars show median values of verified errors. κstart = 1.0 exCept for the κ = 0
setting. The upper and lower ends of an error bar are the worst and best verified error, respeCtively.
For eaCh sChedule length, three Color groups represent three different κ settings.
References
Anish Athalye, NiCholas Carlini, and David Wagner. ObfusCated gradients give a false sense of
seCurity: CirCumventing defenses to adversarial examples. International Conference on Machine
Learning (ICML), 2018.
JaCob BuCkman, Aurko Roy, Colin Raffel, and Ian Goodfellow. Thermometer enCoding: One hot
way to resist adversarial examples. International Conference on Learning Representations, 2018.
NiCholas Carlini and David Wagner. Adversarial examples are not easily deteCted: Bypassing ten
deteCtion methods. In Proceedings of the 10th ACM Workshop on Artificial Intelligence and
Security, pp. 3-14. ACM, 2017a.
NiCholas Carlini and David Wagner. Towards evaluating the robustness of neural networks. In 2017
38th IEEE Symposium on Security and Privacy (SP), pp. 39-57. IEEE, 2017b.
Hongge Chen, Huan Zhang, Pin-Yu Chen, Jinfeng Yi, and Cho-Jui Hsieh. AttaCking visual language
grounding with adversarial examples: A Case study on neural image Captioning. In Proceedings
of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long
Papers), pp. 2587-2597, 2018.
Jeremy M Cohen, Elan Rosenfeld, and J ZiCo Kolter. Certified adversarial robustness via randomized
smoothing. arXiv preprint arXiv:1902.02918, 2019.
Krishnamurthy Dvijotham, Marta Garnelo, Alhussein Fawzi, and Pushmeet Kohli. VerifiCation of
deep probabilistiC models. CoRR, abs/1812.02795, 2018a. URL http://arxiv.org/abs/1812.02795.
Krishnamurthy Dvijotham, Sven Gowal, Robert Stanforth, Relja ArandjeloviC, Brendan O’Donoghue,
Jonathan Uesato, and Pushmeet Kohli. Training verified learners with learned verifiers. arXiv
preprint arXiv:1805.10265, 2018b.
Krishnamurthy Dvijotham, Robert Stanforth, Sven Gowal, Timothy Mann, and Pushmeet Kohli. A
dual approaCh to sCalable verifiCation of deep networks. UAI, 2018C.
Krishnamurthy Dj Dvijotham, Robert Stanforth, Sven Gowal, Chongli Qin, Soham De, and Pushmeet
Kohli. EffiCient neural network verifiCation with exaCtness CharaCterization.
Kevin Eykholt, Ivan Evtimov, EarlenCe Fernandes, Bo Li, Amir Rahmati, Chaowei Xiao, Atul
Prakash, Tadayoshi Kohno, and Dawn Song. Robust physiCal-world attaCks on deep learning
visual ClassifiCation. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, pp. 1625-1634, 2018.
Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy. Explaining and harnessing adversarial
examples. ICLR, 2015.
Sven Gowal, Krishnamurthy Dvijotham, Robert Stanforth, Rudy Bunel, Chongli Qin, Jonathan
Uesato, Timothy Mann, and Pushmeet Kohli. On the effeCtiveness of interval bound propagation
for training verifiably robust models. arXiv preprint arXiv:1810.12715, 2018.
10
Published as a conference paper at ICLR 2020
Chuan Guo, Mayank Rana, Moustapha Cisse, and Laurens van der Maaten. Countering adversarial
images using input transformations. In ICLR, 2018.
Warren He, James Wei, Xinyun Chen, Nicholas Carlini, and Dawn Song. Adversarial example
defenses: ensembles of weak defenses are not strong. In Proceedings of the 11th USENIX
Conference on Offensive Technologies,pp.15-15. USENIX Association, 2017.
Matthias Hein and Maksym Andriushchenko. Formal guarantees on the robustness of a classifier
against adversarial manipulation. In Advances in Neural Information Processing Systems (NIPS),
pp. 2266-2276, 2017.
Guy Katz, Clark Barrett, David L Dill, Kyle Julian, and Mykel J Kochenderfer. Reluplex: An efficient
SMT solver for verifying deep neural networks. In International Conference on Computer Aided
Verification, pp. 97-117. Springer, 2017.
Alexey Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial machine learning at scale. In
International Conference on Learning Representations, 2017.
Mathias Lecuyer, Vaggelis Atlidakis, Roxana Geambasu, Daniel Hsu, and Suman Jana. Certified
robustness to adversarial examples with differential privacy. arXiv preprint arXiv:1802.03471,
2018.
Bai Li, Changyou Chen, Wenlin Wang, and Lawrence Carin. Second-order adversarial attack and
certifiable robustness. arXiv preprint arXiv:1809.03113, 2018.
Xingjun Ma, Bo Li, Yisen Wang, Sarah M Erfani, Sudanthi Wijewickrema, Michael E Houle, Grant
Schoenebeck, Dawn Song, and James Bailey. Characterizing adversarial subspaces using local
intrinsic dimensionality. In International Conference on Learning Representations (ICLR), 2018.
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and Adrian Vladu.
Towards deep learning models resistant to adversarial attacks. In International Conference on
Learning Representations, 2018.
Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for provably
robust neural networks. In International Conference on Machine Learning, pp. 3575-3583, 2018.
Matthew Mirman, Gagandeep Singh, and Martin Vechev. A provable defense for deep residual
networks. arXiv preprint arXiv:1903.12519, 2019.
Nicolas Papernot, Patrick McDaniel, Xi Wu, Somesh Jha, and Ananthram Swami. Distillation as a
defense to adversarial perturbations against deep neural networks. In 2016 IEEE Symposium on
Security and Privacy (SP), pp. 582-597. IEEE, 2016.
Chongli Qin, Krishnamurthy Dj Dvijotham, Brendan O’Donoghue, Rudy Bunel, Robert Stanforth,
Sven Gowal, Jonathan Uesato, Grzegorz Swirszcz, and Pushmeet Kohli. Verification of non-linear
specifications for neural networks. ICLR, 2019.
Aditi Raghunathan, Jacob Steinhardt, and Percy Liang. Certified defenses against adversar-
ial examples. International Conference on Learning Representations (ICLR), arXiv preprint
arXiv:1801.09344, 2018a.
Aditi Raghunathan, Jacob Steinhardt, and Percy S Liang. Semidefinite relaxations for certifying
robustness to adversarial examples. In Advances in Neural Information Processing Systems, pp.
10900-10910, 2018b.
Hadi Salman, Greg Yang, Jerry Li, Pengchuan Zhang, Huan Zhang, Ilya Razenshteyn, and Sebastien
Bubeck. Provably robust deep learning via adversarially trained smoothed classifiers. arXiv
preprint arXiv:1906.04584, 2019a.
Hadi Salman, Greg Yang, Huan Zhang, Cho-Jui Hsieh, and Pengchuan Zhang. A convex relaxation
barrier to tight robust verification of neural networks. arXiv preprint arXiv:1902.08722, 2019b.
Pouya Samangouei, Maya Kabkab, and Rama Chellappa. Defense-GAN: Protecting classifiers
against adversarial attacks using generative models. arXiv preprint arXiv:1805.06605, 2018.
11
Published as a conference paper at ICLR 2020
GagandeeP Singh, Timon Gehr, Matthew Mirman, Markus Puschel, and Martin Vechev. Fast and
effective robustness certification. In Advances in Neural Information Processing Systems, pp.
10825-10836, 2018.
GagandeeP Singh, Timon Gehr, Markus Puschel, and Martin Vechev. Robustness certification with
refinement. ICLR, 2019.
Aman Sinha, Hongseok Namkoong, and John Duchi. Certifying some distributional robustness with
PrinciPled adversarial training. In ICLR, 2018.
Yang Song, TaesuP Kim, Sebastian Nowozin, Stefano Ermon, and Nate Kushman. Pixeldefend:
Leveraging generative models to understand and defend against adversarial examPles. arXiv
preprint arXiv:1710.10766, 2017.
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow,
and Rob Fergus. Intriguing ProPerties of neural networks. arXiv preprint arXiv:1312.6199, 2013.
Shiqi Wang, Yizheng Chen, Ahmed Abdou, and Suman Jana. Mixtrain: Scalable training of formally
robust neural networks. arXiv preprint arXiv:1811.02625, 2018a.
Shiqi Wang, Kexin Pei, Justin Whitehouse, Junfeng Yang, and Suman Jana. Efficient formal safety
analysis of neural networks. In Advances in Neural Information Processing Systems, PP. 6369-
6379, 2018b.
Tsui-Wei Weng, Huan Zhang, Hongge Chen, Zhao Song, Cho-Jui Hsieh, Duane Boning, Inderjit S
Dhillon, and Luca Daniel. Towards fast comPutation of certified robustness for ReLU networks. In
International Conference on Machine Learning, 2018.
Eric Wong and Zico Kolter. Provable defenses against adversarial examPles via the convex outer
adversarial PolytoPe. In International Conference on Machine Learning, PP. 5283-5292, 2018.
Eric Wong, Frank Schmidt, Jan Hendrik Metzen, and J Zico Kolter. Scaling Provable adversarial
defenses. Advances in Neural Information Processing Systems (NIPS), 2018.
Chaowei Xiao, Ruizhi Deng, Bo Li, Fisher Yu, Mingyan Liu, and Dawn Song. Characterizing
adversarial examPles based on sPatial consistency information for semantic segmentation. In
Proceedings of the European Conference on Computer Vision (ECCV), PP. 217-234, 2018a.
Chaowei Xiao, Bo Li, Jun-Yan Zhu, Warren He, Mingyan Liu, and Dawn Song. Generating adversarial
examPles with adversarial networks. IJCAI18, 2018b.
Chaowei Xiao, Jun-Yan Zhu, Bo Li, Warren He, Mingyan Liu, and Dawn Song. SPatially transformed
adversarial examPles. ICLR18, 2018c.
Chaowei Xiao, Ruizhi Deng, Bo Li, Taesung Lee, Benjamin Edwards, Jinfeng Yi, Dawn Song,
Mingyan Liu, and Ian Molloy. Advit: Adversarial frames identifier based on temPoral consistency
in videos. In Proceedings of the IEEE International Conference on Computer Vision, PP. 3968-
3977, 2019a.
Chaowei Xiao, Dawei Yang, Bo Li, Jia Deng, and Mingyan Liu. Meshadv: Adversarial meshes
for visual recognition. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition, PP. 6898-6907, 2019b.
Kai Y Xiao, Vincent Tjeng, Nur Muhammad Shafiullah, and Aleksander Madry. Training for faster
adversarial robustness verification via inducing relu stability. ICLR, 2019c.
Kaidi Xu, Sijia Liu, Pu Zhao, Pin-Yu Chen, Huan Zhang, Quanfu Fan, Deniz Erdogmus, Yanzhi
Wang, and Xue Lin. Structured adversarial attack: Towards general imPlementation and better
interPretability. arXiv preprint arXiv:1808.01664, 2018.
Hongyang Zhang, Yaodong Yu, Jiantao Jiao, Eric Xing, Laurent El Ghaoui, and Michael Jordan.
Theoretically PrinciPled trade-off between robustness and accuracy. In Kamalika Chaudhuri
and Ruslan Salakhutdinov (eds.), Proceedings of the 36th International Conference on Machine
Learning, volume 97 of Proceedings of Machine Learning Research, PP. 7472-7482, Long Beach,
California, USA, 09-15 Jun 2019a. PMLR. URL httP://Proceedings.mlr.Press/v97/zhang19P.html.
12
Published as a conference paper at ICLR 2020
Huan Zhang, Tsui-Wei Weng, Pin-Yu Chen, Cho-Jui Hsieh, and Luca Daniel. Efficient neural network
robustness certification with general activation functions. In Advances in Neural Information
Processing Systems (NIPS), 2018.
Huan Zhang, Hongge Chen, Zhao Song, Duane Boning, Inderjit S Dhillon, and Cho-Jui Hsieh. The
limitations of adversarial training and the blind-spot attack. ICLR, 2019b.
Huan Zhang, Pengchuan Zhang, and Cho-Jui Hsieh. Recurjac: An efficient recursive algorithm for
bounding jacobian matrix of neural networks and its applications. AAAI Conference on Artificial
Intelligence, 2019c.
Tianhang Zheng, Changyou Chen, and Kui Ren. Distributionally adversarial attack. arXiv preprint
arXiv:1808.05537, 2018.
13
Published as a conference paper at ICLR 2020
A IBP as a S imple Augmented Network
Despite achieving great success, it is still an open question why IBP based methods significantly
outperform convex relaxation based methods, despite the fact that convex relaxations usually provide
significantly tighter bounds. We conjecture that IBP performs better because the bound propagation
process can be viewed as a ReLU network with the same depth as the original network, and the IBP
training process is effectively training this equivalent network for standard accuracy, as explained
below.
Given a fixed neural network (NN) f (x), IBP gives a very loose estimation of the output range of
f (x). However, during training, since the weights of this NN can be updated, we can equivalently
view IBP as an augmented neural network, which we denote as an IBP-NN (Figure A). Unlike a
usual network which takes an input xk with label yk, IBP-NN takes two points xL = xk - and
xU = xk + as inputs (where xL ≤ x ≤ xU , element-wisely). The bound propagation process can
be equivalently seen as forward propagation in a specially structured neural network, as shown in
Figure A. After the last specification layer C (typically merged into W(L)), We can obtain m(xk, e).
Then, -m(xk, e) is sent to SoftmaX layer for prediction. Importantly, since [m(xk, e)]yk = 0 (as the
yk -th roW in C is alWays 0), the top-1 prediction of the augmented IBP netWork is yk if and only if
all other elements of m(xk, e) are positive, i.e., the original network will predict correctly for all
xL ≤ x ≤ xU. When We train the augmented IBP netWork With ordinary cross-entropy loss and
desire it to predict correctly on an input xk, we are implicitly doing robust optimization (Eq. (2)).
Figure A: Interval Bound Propagation viewed as training an augmented neural network (IBP-NN).
The inputs of IBP-NN are two images xk + e and xk - e. The output of IBP-NN is a vector of
lower bounds of margins (denoted as m) between ground-truth class and all classes (including the
ground-truth class itself) for all Xk - e ≤ X ≤ Xk + e. This vector m is negated and sent into a
regular softmaX function to get model prediction. The top-1 prediction of softmaX is correct if and
only if all margins between the ground-truth class and other classes (eXcept the ground truth class)
are positive, i.e., the model is verifiably robust. Thus, an IBP-NN with low standard error guarantees
low verified error on the original network.
The simplicity of IBP-NN may help a gradient based optimizer to find better solutions. On the other
hand, while the computation of conveX relaXation based bounds can also be cast as an equivalent
network (e.g., the “dual network” in Wong & Kolter (2018)), its construction is significantly more
compleX, and sometimes requires non-differentiable indicator functions (the sets I+, I- and I
in Wong & Kolter (2018)). As a consequence, it can be challenging for the optimizer to find a good
solution, and the optimizer tends to making the bounds tighter naively by reducing the norm of weight
matrices and over-regularizing the network, as demonstrated in Figure 1.
B	Tightnes s comparis on between IBP and CROWN-IBP
Both IBP and CROWN-IBP produce lower bounds m(x, e), and a larger lower bound has better
quality. To measure the relative tightness of the two bounds, we take the average of all bounds of
training eXamples:
, E M ——1>(mCROWN-IBP(x, e) - mIBP(x, e))
(x,y)∈X nL
14
Published as a conference paper at ICLR 2020
A positive value indicates that CROWN-IBP is tighter than IBP. In Figure B we plot this averaged
bound differences during schedule for one MNIST model and one CIFAR-10 model. We can
observe that during the early phase of training when the schedule just starts, CROWN-IBP produces
significantly better bounds than IBP A tighter lower bound m(x, e) gives a tighter upper bound
for maxδ∈S L(x + δ; y; θ), making the minimax optimization problem (2) more effective to solve.
When the training schedule proceeds, the model gradually learns how to make IBP bounds tighter
and eventually the difference between the two bounds become close to 0.
MNIST	CIFAR
Epoch
Epoch
Figure B: Bound differences between IBP and CROWN-IBP for DM-large models during training.
The bound difference is only computed during the e schedule (epoch 10 to 60 for MNIST, and 320
to 1920 for CIFAR-10), as we don’t compute CROWN-IBP bounds in warmup period and after e
schedule.
Why CROWN-IBP stabilizes IBP training? When taking a randomly initialized network or a
naturally trained network, IBP bounds are very loose. But in Table 1, we show that a network trained
using IBP can eventually obtain quite tight IBP bounds and high verified accuracy; the network can
adapt to IBP bounds and learn a specific set of weights to make IBP tight and also correctly classify
examples. However, since the training has to start from weights that produce loose bounds for IBP,
the beginning phase of IBP training can be challenging and is vitally important.
We observe that IBP training can have a large performance variance across models and initializations.
Also IBP is more sensitive to hyper-parameter like κ or schedule length; in Figure 3, many IBP
models converge sub-optimally (large worst/median verified error). The reason for instability is that
during the beginning phase of training, the loose bounds produced by IBP make the robust loss (9)
ineffective, and it is challenging for the optimizer to reduce this loss and find a set of good weights
that produce tight IBP verified bounds in the end.
Conversely, if our bounds are much tighter at the beginning, the robust loss (9) always remains in a
reasonable range during training, and the network can gradually learn to find a good set of weights
that make IBP bounds increasingly tighter (this is obvious in Figure B). Initially, tighter bounds can
be provided by a convex relaxation based method like CROWN, and they are gradually replaced by
IBP bounds (using βstart = 1, βend = 0), eventually leading to a model with learned tight IBP bounds
in the end.
C Models and Hyperparameters for comparison to IBP
The goal of these experiments is to reproduce the performance reported in (Gowal et al., 2018) and
demonstrate the advantage of CROWN-IBP under the same experimental settings. Specifically, to
reproduce the IBP results, for CIFAR-10 we train using a large batch size and long training schedule
on TPUs (we can also replicate these results on multi-GPUs using a reasonable amount of training
time; see Section F). Also, for this set of experiments we use the same code base as in Gowal et al.
(2018). For model performance on a comprehensive set of small and medium sized models trained
on a single GPU, please see Table D in Section F, as well as the training stability experiments in
Section 4 and Section H.
15
Published as a conference paper at ICLR 2020
The models structures (DM-small, DM-medium and DM-large) used in Table C and Table 2 are
listed in Table A. These three model structures are the same as in Gowal et al. (2018). Training
hyperparameters are detailed below:
•	For MNIST IBP baseline results, we follow exact the same set of hyperparameters as
in (Gowal et al., 2018). We train 100 epochs (60K steps) with a batch size of 100, and use
a warm-up and ramp-up duration of 2K and 10K steps. Learning rate for Adam optimizer
is set to 1 × 10-3 and decayed by 10X at steps 15K and 25K. Our IBP results match their
reported numbers. Note that we always use IBP verified errors rather than MIP verified
errors. We use the same schedule for CROWN-IBP with train = 0.2 (test = 0.1) in Table C
and Table 2. For train = 0.4, this schedule can obtain verified error rates 4.22%, 7.01% and
12.84% at test = {0.2, 0.3, 0.4} using the DM-Large model, respectively.
•	For MNIST CROWN-IBP with train = 0.4 in Table C and Table 2, we train 200 epochs with
a batch size of 256. We use Adam optimizer and set learning rate to 5 × 10-4. We warm
up with 10 epochs’ regular training, and gradually ramp up from 0 to train in 50 epochs.
We reduce the learning rate by 10X at epoch 130 and 190. Using this schedule, IBP’s
performance becomes worse (by about 1-2% in all settings), but this schedule improves
verified error for CROWN-IBP at test = 0.4 from 12.84% to to 12.06% and does do affect
verified errors at other test levels.
•	For CIFAR-10, we follow the setting in Gowal et al. (2018) and train 3200 epochs on 32
TPU cores. We use a batch size of 1024, and a learning rate of 5 × 10-4 . We warm up
for 320 epochs, and ramp-up for 1600 epochs. Learning rate is reduced by 10X at epoch
2600 and 3040. We use random horizontal flips and random crops as data augmentation,
and normalize images according to per-channel statistics. Note that this schedule is slightly
different from the schedule used in (Gowal et al., 2018); we use a smaller batch size due to
TPU memory constraints (we used TPUv2 which has half memory capacity as TPUv3 used
in (Gowal et al., 2018)), and also we decay learning rates later. We found that this schedule
improves both IBP baseline performance and CROWN-IBP performance by around 1%; for
example, at = 8/255, this improved schedule can reduce verified error from 73.52% to
72.68% for IBP baseline (κstart = 1.0, κend = 0.5) using the DM-Large model.
Hyperparameter κ and β. We use a linear schedule for both hyperparameters, decreasing κ from
κstart to κend while increasing β from βstart to βend. The schedule length is set to the same length as
the schedule.
In both IBP and CROWN-IBP, a hyperparameter κ is used to trade-off between clean accuracy and
verified accuracy. Figure 2 shows that κend can significantly affect the trade-off, while κstart has minor
impacts compared to κend. In general, we recommend κstart = 1 and κend = 0 as a safe starting
point, and we can adjust κend to a larger value if a better standard accuracy is desired. The setting
κstart = κend = 0 (pure minimax optimization) can be challenging for IBP as there is no natural loss
as a stabilizer; under this setting CROWN-IBP usually produces a model with good (sometimes best)
verified accuracy but noticeably worse standard accuracy (on CIFAR-10 E =蔡 the difference can
be as large as 10%), so this setting is only recommended when a model with best verified accuracy is
desired at a cost of noticeably reduced standard accuracy.
Compared to IBP, CROWN-IBP adds one additional hyperparameter, β . β has a clear meaning:
balancing between the convex relaxation based bounds and the IBP bounds. βstart is always set to
1 as we want to use CROWN-IBP to obtain tighter bounds to stabilize the early phase of training
when IBP bounds are very loose; βend determines if we want to use a convex relaxation based bound
(βend = 1) or IBP based bound (βend = 0) after the E schedule. Thus, we set βend = 1 for the case
where convex relaxation based method (Wong et al., 2018) can outperform IBP (e.g., CIFAR-10
E = 2/255, and βend = 0 for the case where IBP outperforms convex relaxation based bounds. We
do not tune or grid-search this hyperparameter.
16
Published as a conference paper at ICLR 2020
DM-Small	DM-Medium	DM-Large
CONV 16 4×4+2 CONV 32 4×4+1 FC 100	CONV 32 3×3+1 CONV 32 4×4+2 CONV 64 3×3+1 CONV 64 4×4+2 FC 512 FC 512	CONV 64 3×3+1 CONV 64 3×3+1 CONV 128 3×3+2 CONV 128 3×3+1 CONV 128 3×3+1 FC 512
Table A: Model structures from GoWal et al. (2018). “CONV k wxh+s"represents a 2D convolutional
layer with k filters of size w×h using a stride of s in both dimensions. “FC n” = fully connected layer
With n outputs. Last fully connected layer is omitted. All netWorks use ReLU activation functions.
D Hyperparameters and Model Structures for Training Stability
Experiments
In all our training stability experiments, We use a large number of relatively small models and train
them on a single GPU. These small models cannot achieve state-of-the-art performance but they can
be trained quickly and cheaply, alloWing us to explore training stability over a variety of settings, and
report min, median and max statistics. We use the folloWing hyperparameters:
•	For MNIST, We train 100 epochs With batch size 256. We use Adam optimizer and the
learning rate is 5 × 10-4. The first epoch is standard training for Warming up. We gradually
increase linearly per batch in our training process With a schedule length of 60. We reduce
the learning rate by 50% every 10 epochs after schedule ends. No data augmentation
technique is used and the Whole 28 × 28 images are used (normalized to 0 - 1 range).
•	For CIFAR, We train 200 epoch With batch size 128. We use Adam optimizer and the learning
rate is 0.1%. The first 10 epochs are standard training for Warming up. We gradually increase
linearly per batch in our training process With a schedule length of 120. We reduce the
learning rate by 50% every 10 epochs after schedule ends. We use random horizontal
flips and random crops as data augmentation. The three channels are normalized With mean
(0.4914, 0.4822, 0.4465) and standard deviation (0.2023, 0.1914, 0.2010). These numbers
are per-channel statistics from the training set used in (GoWal et al., 2018).
All verified error numbers are evaluated on the test set using IBP, since the netWorks are trained
using IBP (β = 0 after E reaches the target Etrain), except for CIFAR E =嬴 where we set β = 1 to
compute the CROWN-IBP verified error.
Table B gives the 18 model structures used in our training stability experiments. These model
structures are designed by us and are not used in Gowal et al. (2018). Most CIFAR-10 models share
the same structures as MNIST models (unless noted on the table) except that their input dimensions
are different. Model A is too small for CIFAR-10 thus we remove it for CIFAR-10 experiments.
Models A - J are the “small models” reported in Figure 3. Models K - T are the “medium models”
reported in Figure 3. For results in Table 1, we use a small model (model structure B) for all three
datasets. These MNIST, CIFAR-10 models can be trained on a single NVIDIA RTX 2080 Ti GPU
within a few hours each.
E Omitted Results on DM-Small and DM-Medium Models
In Table 2 we report results from the best DM-Large model. Table C presents the verified, standard
(clean) and PGD attack errors for all three model structures used in (Gowal et al., 2018) (DM-Small,
DM-Medium and DM-Large) trained on MNIST and CIFAR-10 datasets. We evaluate IBP and
CROWN-IBP under the same three κ settings as in Table 2. We use hyperparameters detailed in
Section C to train these models. We can see that given any model structure and any κ setting,
CROWN-IBP consistently outperforms IBP.
17
Published as a conference paper at ICLR 2020
Name	Model Structure (all models have a last FC 10 layer, which are omitted)
A (MNIST Only) B C D E F G H I J	Conv 4 4 × 4+2, Conv 8 4 × 4+2, FC 128 Conv 8 4 × 4+2, Conv 16 4 × 4+2, FC 256 Conv4 3 × 3+1,Conv 8 3 × 3+1, Conv 8 4 × 4+4, FC 64 Conv 8 3 × 3+1,Conv 16 3 × 3+1,Conv 16 4 × 4+4, FC 128 Conv 4 5 × 5+1, Conv 8 5 × 5+1, Conv 8 5 × 5+4, FC 64 Conv 8 5 × 5+1,Conv 16 5 × 5+1,Conv 16 5 × 5+4, FC 128 Conv 4 3 × 3+1, Conv 4	4	× 4+2, Conv	8 3 × 3+1, Conv 8 4 ×	4+2, FC 256, FC 256 Conv 8 3 × 3+1,Conv 8	4	× 4+2, Conv	16 3 × 3+1, Conv 16 4	× 4+2, FC 256, FC 256 Conv4 3 × 3+1,Conv4	4	× 4+2, Conv	8 3 × 3+1,Conv 8 4 ×	4+2, FC 512, FC 512 Conv 8 3 × 3+1,Conv 8	4	× 4+2, Conv	16 3 × 3+1, Conv 16 4	× 4+2, FC 512, FC 512
K L M N O(MNIST Only) P(MNIST Only) Q R S(CIFAR-10 Only) T(CIFAR-10 Only)	Conv 16 3 × 3+1,	Conv 16 4	×	4+2,	Conv 32 3	× 3+1,Conv 32 4	×	4+2, FC 256, FC 256- Conv16 3 × 3+1,Conv16 4	×	4+2,	Conv 32 3	× 3+1,Conv32 4	×	4+2,FC512,FC512 Conv 32 3 × 3+1,	Conv 32 4	×	4+2,	Conv 64	3	× 3+1,Conv 64 4	×	4+2, FC 512, FC 512 Conv 64 3 × 3+1,	Conv 64 4	×	4+2,	Conv 128 3 × 3+1, Conv 128	4	× 4+2, FC 512, FC 512 Conv 64 5 × 5+1,Conv 128 5 × 5+1,Conv 128 4 × 4+4,FC512 Conv 32 5 × 5+1,	Conv 64 5	×	5+1,	Conv 64	4	× 4+4, FC 512 Conv 16 5 × 5+1,	Conv 32 5	×	5+1,	Conv 32	5	× 5+4, FC 512 Conv 32 3 × 3+1,	Conv 64 3	×	3+1,	Conv 64	3	× 3+4, FC 512 Conv 32 4 × 4+2,	Conv 64 4	×	4+2,	FC 128 Conv 64 4 × 4+2, Conv 128 4 × 4+2, FC 256
Table B: Model structures used in our training stability experiments. We use ReLU activations for
all models. We omit the last fully connected layer as its output dimension is always 10. In the table,
“Conv k w × w + s” represents to a 2D convolutional layer with k filters of size w × w and a stride
of s. Model A - J are referred to as “small models” and model K to T are referred to as “medium
models”.
F Additional experiments on smaller models using a single GPU
In this section we present additional experiments on a variety of smaller MNIST and CIFAR-10
models which can be trained on a single GPU. The purpose of this experiment is to compare model
performance statistics (min, median and max) on a wide range of models, rather than a few hand
selected models. The model structures used in these experiments are detailed in Table B. In Table D,
we present the best, median and worst verified and standard (clean) test errors for models trained on
MNIST and CIFAR-10 using IBP and CROWN-IBP. Although these small models cannot achieve
state-of-the-art performance, CROWN-IBP’s best, median and worst verified errors among all model
structures consistently outperform those of IBP. Especially, in many situations the worst case verified
error improves significantly using CROWN-IBP, because IBP training is not stable on some of the
models.
It is worth noting that in this set of experiments we explore a different setting: train = test. We
found that both IBP and CROWN-IBP tend to overfit to training dataset on MNIST with small , thus
verified errors are not as good as presented in Table C. This overfitting issue can be alleviated by
using train > test (as used in Table 2 and Table C), or using an explicit `1 regularization, which will
be discussed in detail in Section I.
18
Published as a conference paper at ICLR 2020
Table C: The verified, standard (clean) and PGD attack errors for 3 models (DM-small, DM-medium,
DM-large) trained on MNIST and CIFAR test sets. We evaluate IBP and CROWN-IBP under
different κ schedules. CROWN-IBP outperforms IBP under the same κ setting, and also achieves
state-of-the-art results for '∞ robustness on both MNIST and CIFAR datasets for all e.
Dataset	e ('∞ norm)	Training Method	K schedules		DM-Sman model,s err. (%)			DM-medium model,s err. (%)			DM-large model,s err. (%)		
			KStar：	κend	Standard	Verified	PGD	Standard	Verified	PGD	Standard	Verified	PGD
			0	0	1.92	4.16	3.88	1.53	3.26	2.82	1.13	2.89	2.24
		IBP	1	0.5	1.68	3.60	3.34	1.46	3.20	2.57	1.08	2.75	2.02
	etest = 0.1		1	0	2.14	4.24	3.94	1.48	3.21	2.77	1.14	2.81	2.11
	etrain = 0.2		-0-	-0-	-190-	3.50	3.21	144	2.77	2.37	-∏7	2.36	1.91
		CROWN-IBP	1	0.5	1.60	3.51	3.19	1.14	2.64	2.23	0.95	2.38	1.77
			1	0	1.67	3.44	3.09	1.34	2.76	2.39	1.17	2.24	1.81
			^^0-	0	~5.08—	^^980―	9.36	3.68	-738~	6.77	-345-	6.46	6.00
		IBP	1	0.5	3.83	8.64	8.06	2.55	5.84	5.33	2.12	4.75	4.24
	etest = 0.2		1	0	6.25	11.32	10.84	3.89	7.21	6.68	2.74	5.46	4.89
	etrain = 0.4		-0-	-0-	-378	6.61	6.40	3.84	6.65	6.42	-284	5.15	4.90
		CROWN-IBP	1	0.5	2.96	6.11	5.74	2.37	5.35	4.90	1.82	4.13	3.81
MNIST			1	0	3.55	6.29	6.13	3.16	5.82	5.44	2.17	4.31	3.99
			0	0	5.08	14.42	13.30	3.68	10.97	9.66	-345-	9.76	8.42
		IBP	1	0.50	3.83	13.99	12.25	2.55	9.51	7.87	2.12	8.47	6.78
	etest = 0.3		1	0	6.25	16.51	15.07	3.89	10.4	9.17	2.74	8.73	7.37
	etrain = °∙4		-0-	-0-	-378	9.60	8.90	3.84	9.25	8.57	-284	7.65	6.90
		CROWN-IBP	1	0.5	2.96	9.44	8.26	2.37	8.54	7.74	1.82	7.02	6.05
			1	0	3.55	9.40	8.50	3.16	8.62	7.65	2.17	7.03	6.12
			^^0-	0	-508-	23.40	20.15	3.68	~18.34—	14.75	-345-	~16.19—	12.73
		IBP	1	0.5	3.83	24.16	19.97	2.55	16.82	12.83	2.12	15.37	11.05
	etest = 0.4		1	0	6.25	26.81	22.78	3.89	16.99	13.81	2.74	14.80	11.14
	etrain = 0.4		-0-	-0-	-378	15.21	13.34	3.84	14.58	12.69	-284	12.74	10.39
		CROWN-IBP	1	0.5	2.96	16.04	12.91	2.37	14.97	12.47	1.82	12.59	9.58
			1	0	3.55	15.55	13.11	3.16	14.19	11.31	2.17	12.06	9.47
			0	0	44.66	56.38	54.15	39.12	53.86	49.77	38.54	55.21 ~	49.72
	,	—2 4	IBP	1	0.5	38.90	57.94	53.64	34.19	56.24	49.63	33.77	58.48	50.54
	etest = 255		1	0	44.08	56.32	54.16	39.30	53.68	49.74	39.22	55.19	50.40
	22 3		-0-	-0-	-39.43-	53.93	49.16	3278	49.57	44.22	-28.48-	46.03	40.28
	e"ain = 255	CROWN-IBP	1	0.5	34.08	54.28	51.17	28.63	51.39	42.43	26.19	50.53	40.24
			1	0	38.15	52.57	50.35	33.17	49.82	44.64	28.91	46.43	40.27
			^^0-	0	―6191—	73.12—	71.75	61.46	71.98—	70.07	~59.41 —	71.22—	68.96
	,	8	IBP	1	0.5	54.01	73.04	70.54	50.33	73.58	69.57	49.01	72.68	68.14
CIFAR-10	etest = 255		1	0	62.66	72.25	70.98	61.61	72.60	70.57	58.43	70.81	68.73
	e ∙ = 88 3		-0-	-0-	-59.94-	70.76	69.65	59:17	69.00	67.60	-5402-	66.94	65.42
	etrain	255	CROWN-IBP	1	0.5	53.12	73.51	70.61	48.51	71.55	67.67	45.47	69.55	65.74
			1	0	60.84	72.47	71.18	58.19	68.94	67.72	55.27	67.76	65.71
			^^0-	0	~70.02—	78.86—	77.67	~67:55	78.65—	76.92	~68.97—	78.12—	76.66
	,	16	IBP	1	0.5	63.43	81.58	78.81	60.07	81.01	77.32	59.46	80.85	76.97
	etest = 255		1	0	67.73	78.71	77.52	70.28	79.26	77.43	68.88	78.91	76.95
	e 一	= 176 3		-0-	-0-	-67.42-	78.41	76.86	68:06	77.92	76.89	-67.17-	77.27	75.76
	etrain	255	CROWN-IBP	1	0.5	61.47	79.62	77.13	59.56	79.30	76.43	56.73	78.20	74.87
			1	0	68.75	78.71	77.91	67.94	78.46	77.21	66.06	76.80	75.23
1	Verified errors reported in Table 4 of Gowal et al. (2018) are evaluated using mixed integer programming (MIP).
For a fair comparison, we use the IBP verified errors reported in Table 3 of Gowal et al. (2018).
2	According to direct communication with the authors of Gowal et al. (2018), achieving 68.44% IBP verified error
requires to adding an extra PGD adversarial training loss. Without adding PGD, the achievable verified error is
72.91% (LP/MIP verified) or 73.52% (IBP verified).
3	Although not explicitly mentioned, the best CIFAR-10 models in (Gowal et al., 2018) also use train = 1.1test.
4	We use βstart = βend = 1 for this setting, the same as in Table 2, and thus CROWN-IBP bound is used to evaluate
the verified error.
19
Published as a conference paper at ICLR 2020
Table D: Verified and standard (clean) test errors for a large number of models trained on MNIST
and CIFAR-10 datasets using IBP and CROWN-IBP. The purpose of this experiment is to compare
model performance statistics (min, median and max) on a wide range of models, rather than a few
hand selected models. For each setting we report 3 representative models: the models with smallest,
median, and largest verified error. We also report the standard error of these three selected models.
Note that in this table we set train = test and observe overfitting on small for MNIST. See Section I
for detailed discussions.
DataSet e ('∞ norm) Model Family Training Method K schedule	Verified Test Error (%)	Standard Test Error(%)
Kstart I Kend	best ∣ median ∣ worst	best ∣ median ∣ worst
				0	0	4.79	5.74	7.32	1.48	1.59	2.50
			IBP	1	0	4.87	5.72	7.24	1.51	1.34	2.46
		10 small models		1	0.5	5.24	5.95	7.36	1.41	1.88	1.87
				-0-	-0-	4.21	5.18	6.80	1.41	-TΓ83-	^38
			CROWN-IBP	1	0	4.14	5.24	6.82	1.39	2.06	2.46
train	=0.1			1	0.5	4.62	5.94	6.88	1.26	1.88	1.97
test	=0.1			-0-	-0-	5.9	6.25	7.82	1.14	-TΓ12-	~T3T
			IBP	1	0	5.77	6.30	7.50	1.21	1.13	1.34
		8 medium models		1	0.5	6.05	6.40	7.70	1.19	1.33	1.24
				-0-	-0-	5.22	5.63	6.34	1.19	1.05-	1.03
			CROWN-IBP	1	0	5.43	5.90	6.02	1.30	1.03	1.09
				1	0.5	5.44	5.89	6.09	1.11	1.16	1.01
					0	0	6.90	8.24	12.67	1.93	2.76	4.14
				IBP	1	0	6.84	8.16	12.92	2.01	2.56	3.93
			10 small models		1	0.5	7.31	8.71	13.54	1.62	2.36	3.22
					-0-	-0-	6.11	7.29	11.97	1.93	-2.3-	^86
				CROWN-IBP	1	0	6.27	7.66	12.11	2.01	2.92	4.06
	Strain	=0.2			1	0.5	6.53	8.14	12.56	1.61	1.61	3.27
	《test	=0.2			-0-	-0-	7.56	8.60	9.80	1.96	-ɪ:ɪp-	^139
				IBP	1	0	8.26	8.72	9.84	1.45	1.73	1.31
			8 medium models		1	0.5	8.42	8.90	10.09	1.76	1.42	1.53
					-0-	-0-	6.06	6.42	7.64	1.09	-TΓ33-	
				CROWN-IBP	1	0	6.39	7.09	7.84	1.11	1.04	1.25
MNIST					1	0.5	6.63	7.51	7.96	1.08	1.25	1.19
				0	0	10.54	12.02	20.47	2.78	3.31	6.07
			IBP	1	0	9.96	12.09	21.0	2.7	3.48	6.68
		10 small models		1	0.5	10.37	12.78	21.99	2.11	3.44	5.19
				-0-	-0-	8.87	11.29	16.83	2.43	-3.62-	~7^2^
			CROWN-IBP	1	0	9.69	11.33	15.23	2.78	3.41	5.90
《train	=0.3			1	0.5	9.90	11.98	19.56	2.20	2.72	4.83
《test	=0.3			-0-	-0-	10.43	10.83	11.99	2.01	^3S	^29
			IBP	1	0	10.74	11.73	12.16	2.17	2.46	1.60
		8 medium models		1	0.5	11.23	11.71	12.4	1.72	2.09	1.63
				-0-	-0-	7.46	8.47	8.57	1.48	~^Γ52-	^T99
			CROWN-IBP	1	0	7.96	8.53	8.99	1.45	1.56	1.85
				1	0.5	8.19	9.20	9.51	1.27	1.46	1.62
											
		10 small models	IBP	0 1 1	0 0 0.5	16.72 16.10 16.54	18.89 18.75 19.14	37.42 35.3 35.42	4.2 3.8 3.40	5.4 4.93 3.65	9.63 11.32 7.54
	《train = 0∙4		CROWN-IBP	-0- 1 1	-0- 0 0.5	15.38 16.22 15.97	18.57 18.20 19.18	24.56 24.80 24.76	3.61 4.23 3.48	^83 5.15 3.97	8.46 8.54 6.64
	《test = 0.4	8 medium models	IBP	-0- 1 1	-0- 0 0.5	15.17 15.63 15.74	16.54 16.06 16.42	18.98 17.11 17.98	2.83 2.93 2.35	-3.79- 3.4 2.31	4.91 3.75 3.15
			CROWN-IBP	-0- 1 1	-0- 0 0.5	12.96 12.90 13.02	13.43 13.47 13.69	14.25 14.06 14.52	2.76 2.42 1.89	-ɪ:ɛʒ- 2.86 2.40	3.36 3.11 2.35
		9 small models	IBP	^^0- 1 1	0 0 0.5	54.69 54.56 56.89	57.84 58.42 60.66	60.58 60.69 63.58	40.59 40.32 34.28	45.51 47.42 39.28	51.38 50.73 48.03
	《train = 2/2551 2 3		CROWN-IBP	-0- 1 1	-0- 0 0.5	48.87 49.45 52.14	54.68 55.09 57.49	58.82 59.00 60.12	32.20 32.22 28.03	40.08 40.45 35.76	46.98 47.05 43.40
	《test = 2/255	8 medium models	IBP	-0- 1 1	-0- 0 0.5	55.47 55.51 57.05	56.41 56.74 59.70	58.54 57.85 60.25	41.59 42.41 34.77	44.33 43.71 35.80	46.54 44.74 38.95
CIFAR-10			CROWN-IBP	-0- 1 1	-0- 0 0.5	49.57 49.28 52.05	50.83 51.59 53.56	52.59 53.45 55.23	32.64 32.31 27.80	34.20 34.23 29.49	37.06 38.11 32.42
											
		9 small models	IBP	""0" 1 1	0 0 0.5	72.07 72.42 73.88	73.34 72.57 75.16	73.88 73.49 76.93	61.11 62.26 55.66	61.01 60.98 52.53	64.0 63.5 53.79
	《train = 8/255		CROWN-IBP	-0- 1 1	-0- 0 0.5	71.28 70.77 72.59	72.15 72.24 74.71	73.66 73.10 76.11	59.40 58.65 49.86	60.80 60.49 52.95	63.10 61.86 55.58
	《test = 8/255	8 medium models	IBP	-0- 1 1	-0- 0 0.5	72.75 72.18 74.84	73.23 72.83 75.59	73.82 74.38 97.93	59.23 62.54 51.71	65.96 59.6 54.41	66.35 61.99 54.12
			CROWN-IBP	-0- 1 1	-0- 0 0.5	70.79 70.51 73.48	71.61 71.96 74.69	72.29 72.82 76.66	57.90 57.87 49.40	60.10 59.98 53.56	59.70 59.16 52.05
1 Verified errors reported in Table 4 of Gowal et al. (2018) are evaluated using mixed integer pro-
gramming (MIP) and linear programming (LP), which are strictly smaller than IBP verified errors
but computationally expensive. For a fair comparison, we use the IBP verified errors reported in
their Table 3.
3 We use βstart = βend = 1 for this setting, the same as in Table 2, and thus CROWN-IBP bound is
used to evaluate the verified error.
20
Published as a conference paper at ICLR 2020
山P①≡J①>
CROWN-IBP (k = 0)
IBP (K = O)
■ CROWN-IBP (Kend = O)
IBP(Kend = O)
■ CROWN-IBP(Kend = O.5)
IBP (LnJ= 0.5∣
0.65
0.60
0.55
0.50
0.45
(a) small models, = 2/255, best 48.87%
0.775
CROWn-IBP(K = O)
IBP(K = O)
■ CROWN-IBP (Kend = O)
∣BP (Kend = O)
Ml CROWN-IBP (Kend = 0.5)
IBP (κe∏d = θ∙5)
0.750
0.725
0.700
30	60	90	120
Schedule Length
(b) small models, = 8/255, best 70.61%
山
P①≡J①>
1
Figure C: Verified error vs. schedule length (30, 60, 90, 120) on 9 small models on CIFAR-10. The
solid boxes show median values of verified errors. κstart = 1.0 except for the κ = 0 setting. The
upper and lower bound of an error bar are worst and best verified error, respectively.
G Reproducibility
To further test the training stability of CROWN-IBP, we run each MNIST experiment (using selected
models in Table B) 5 times to get the mean and standard deviation of the verified and standard errors
on test set. Results are presented in Table E. Standard deviations of verified errors are very small,
giving us further evidence of good stability and reproduciblity.
error ∣ model A ∣ model B ∣ model C ∣ model D ∣ model E ∣ model F ∣ model G ∣ model H ∣ model I ∣ model J
0.1	std. err. (%) verified err. (%)	2.57 ± .04 6.85 ± .04	1.45 ± .05 4.88 ± .04	3.02 ± .04 6.67 ± .1	1.77 ± .04 5.10 ± .1	2.13 ± .08 4.82 ± .2	1.35 ± .05 4.18 ± .008	2.03 ± .08 5.23 ± .2	1.32 ± .08 4.59 ± .08	1.77 ± .04 5.92 ± .09	1.45 ± .05 5.40 ± .09
0.2	std. err. (%)	3.87 ± .04	2.43 ± .04	4.40 ± .2	2.32 ± .04	3.45 ± .3	-1.90 ± 0-	2.67 ± .1	2.00 ± .07	2.22 ± .04	1.65 ± .05
	verified err. (%)	12.0 ± .03	6.99 ± .04	10.3 ± .2	7.37 ± .06	9.01 ± .9	6.05 ± .03	7.50 ± .1	6.45 ± .06	7.50 ± .3	6.31 ± .08
0.3	std. err. (%)	5.97 ± .08	3.20 ± 0	6.78 ± .1	3.70 ± .1	3.85 ± .2	3.10 ± .1	4.20 ± .3	2.85 ± .05	3.67 ± .08	2.35 ± .09
	verified err. (%)	15.4 ± .08	10.6 ± .06	16.1 ± .3	11.3 ± .1	11.7 ± .2	9.96 ± .09	12.2 ± .6	9.90 ± .2	11.2 ± .09	9.21 ± .3
0.4	std. err. (%)	8.43 ± .04	4.93 ± .1	8.53 ± .2	5.83 ± .2	5.48 ± .2	4.65 ± .09	6.80 ± .2	4.28 ± .1	5.60 ± .1	3.60 ± .07
	verified err. (%)	24.6 ± .1	18.5 ± .2	24.6 ± .7	19.2 ± .2	18.8 ± .2	17.3 ± .04	20.4 ± .3	16.3 ± .2	18.5 ± .07	15.2 ± .3
Table E: Means and standard deviations of verified and standard errors of 10 MNIST models trained
using CROWN-IBP. The architectures of these models are presented in Table B. We run each model
5 times to compute its mean and standard deviation.
H	TRAINING STABILITY EXPERIMENTS ON OTHER
Similar to our experiments in Section 4, we compare the verified errors obtained by CROWN-IBP and
IBP under different schedule lengths (10, 15, 30, 60) on MNIST and (30,60,90,120) on CIFAR-10.
We present the best, worst and median verified errors over all 18 models for MNIST in Figure D, E
at ∈ {0.1, 0.2, 0.3} and 9 small models for CIFAR-10 in Figure C. The upper and lower ends of
an error bar are the worst and best verified error, respectively, and the solid boxes represent median
values. CROWN-IBP can improve training stability, and consistently outperform IBP under different
schedule length and κ settings.
I OVERFITTING ISSUE WITH SMALL
We found that on MNIST for a small , the verified error obtained by IBP based methods are
not as good as linear relaxation based methods (Wong et al., 2018; Mirman et al., 2018). Gowal
et al. (2018) thus propose to train models using a larger and evaluate them under a smaller , for
example train = 0.4 and eval = 0.3. Instead, we investigated this issue further and found that many
CROWN-IBP trained models achieve very small verified errors (close to 0 and sometimes exactly 0)
on training set (see Table F). This indicates possible overfitting during training. As we discussed in
Section 3, linear relaxation based methods implicitly regularize the weight matrices so the network
does not overfit when is small. Inspired by this finding, we want to see if adding an explicit `1
21
Published as a conference paper at ICLR 2020
CROWN-IBP (κ = 0)
IBP (K = O)
8 6 4 3
Q.0Q.O
0.60,0.
山P①一M-μ二>
」0」」山Pow-J①>
0.11
0.09
0.06
0.04
Schedule Length
(a)	= 0.1, best 3.55%
■ CROWN-IBp (k = 0)
IBP (κ = 0)
CROWN-IBP (Kend = O)
旧 P(Kend = θ)
CROWN-IBP (κend = 0.5}
IBP (KeM = O.5)
Ii1I H1Iiiiiil
10	15	30	60
Schedule Length
(b)	= 0.2, best 4.98%
Figure D: Verified error vs. schedule length (10, 15, 30, 60) on 8 medium MNIST models. The
upper and lower ends of a vertical bar represent the worst and best verified error, respectively. The
solid boxes represent the median values of the verified error. For a small , using a shorter schedule
length improves verified error due to early stopping, which prevents overfitting. All best verified
errors are achieved by CROWN-IBP regardless of schedule length.
⅛tω P @M-μ ① >
10	15	30	60
Schedule Length
(a) = 0.1, best 3.84%
10	15	30	60
Schedule Length
10	15	30	60
Schedule Length
(b) = 0.2, best 6.11%
(c) = 0.3, best 8.87%
Figure E: Verified error vs. schedule length (10, 15, 30, 60) on 10 small MNIST models. The upper
and lower ends of a vertical bar represent the worst and best verified error, respectively. All best
verified errors are achieved by CROWN-IBP regardless of schedule length.
regularization term in CROWN-IBP training helps when train = 0.1 or 0.2. The verified and standard
errors on the training and test sets with and without regularization can be found in Table F. We can
see that with a small `1 regularization added (λ = 5 × 10-5) we can reduce verified errors on test
set significantly. This makes CROWN-IBP results comparable to the numbers reported in convex
adversarial polytope (Wong et al., 2018); at = 0.1, the best model using convex adversarial polytope
training can achieve 3.67% verified error, while CROWN-IBP achieves 3.60% best certified error
on the models presented in Table F. The overfitting is likely caused by IBP’s strong learning power
without over-regularization, which also explains why IBP based methods significantly outperform
linear relaxation based methods at larger values. Using early stopping can also improve verified
error on test set; see Figure D.
J	Training Time
In Table G we present the training time of CROWN-IBP, IBP and convex adversarial polytope (Wong
et al., 2018) on several representative models. All experiments are measured on a single RTX 2080
Ti GPU with 11 GB RAM except for 2 DM-Large models where we use 4 RTX 2080 Ti GPUs to
speed up training. We can observe that CROWN-IBP is practically 1.5 to 3.5 times slower than IBP.
Theoretically, CROWN-IBP is up to nL = 10 times slower4 than IBP; however usually the total
training time is less than 10 times since the CROWN-IBP bound is only computed during the ramp-up
phase, and CROWN-IBP has higher GPU computation intensity and thus better GPU utilization than
IBP. convex adversarial polytope (Wong et al., 2018), as a representative linear relaxation based
4More precisely, nL - 1 = 9 times slower as we can omit the all-zero row in specification matrix Eq. (3).
22
Published as a conference paper at ICLR 2020
	Model Name	λ: 'ι regularization	Training		Test	
	(See Appendix D)		standard error	verified error	standard error	verified error
	P	0	0.01%	0.01%	1.05%	5.63%
0.1	P	5 × 10-5	0.32%	0.98%	1.30%	3.60%
	O	0	0.02%	0.05%	0.82%	6.02%
	O	5 × 10-5	0.38%	1.34%	1.43%	4.02%
	P	0	0.35%	140%	109%	606%
0.2	P	5 × 10-5	1.02%	3.73%	1.48%	5.48%
	O	0	0.31%	1.54%	1.22%	6.64%
	O	5 × 10-5	1.09%	4.08%	1.69%	5.72%
Table F: `1 regularized and unregularized models’ standard and verified errors on training and test set.
At a small , CROWN-IBP may overfit and adding regularization helps robust generalization; on the
other hand, convex relaxation based methods (Wong et al., 2018) provides implicitly regularization
which helps generalization under small but deteriorate model performance at larger .
method, can be over hundreds times slower than IBP especially on deeper networks. Note that
we use 50 random Cauchy projections for (Wong et al., 2018). Using random projections alone is
not sufficient to scale purely linear relaxation based methods to larger datasets, thus we advocate a
combination of IBP bounds with linear relaxation based methods as in CROWN-IBP, which offers
good scalability and stability. We also note that the random projection based acceleration can also be
applied to the backward bound propagation (CROWN-style bound) in CROWN-IBP to further speed
up CROWN-IBP.
Table G: IBP and CROWN-IBP’s training time on different models in seconds. For IBP and CROWN-
IBP, we use a batchsize of 256 for MNIST and 128 for CIFAR-10. For convex adversarial polytope,
we use 50 random Cauchy projections, and reduce batch size if necessary to fit into GPU memory.
Data	MNIST						CIFAR-10					
Model Name	A	C	G	L	O	DM-large (etrain = 0.4)	B	D	H	S	M	DM-large
IBP (s)	245	264	290	364	1032	37691	734	908	1048	691	1407	404961
CROWN-IBP (s)	371	564	590	954	3649	55841	1148	1853	1859	1491	4137	912881
CAP (Wong et al., 2018)2(s)	1708	9263	12649	35518	160794	—-	2372	12688	18691	6961	51145	—-
1 We use 4 GPUs to train this model.
2 Convex adversarial polytopes (CAP) are computed with 50 random projections. Without random
projections it will not scale to most models except for the smallest ones.
K Reproducing CIFAR- 1 0 Results on Multi- GPUs
The use of 32 TPUs for our CIFAR-10 experiments is not necessary. We use TPUs mainly for
obtaining a completely fair comparison to IBP (Gowal et al., 2018), as their implementation was
TPU-based. Since TPUs are not widely available, we additionally implemented CROWN-IBP using
multi-GPUs. We train the best models in Table 2 on 4 RTX 2080Ti GPUs. As shown in Table H,
we can achieve comparable verified errors using GPUs, and the differences between GPU and TPU
training are around ±0.5%. Training time is reported in Table G.
L	Exact Forms of the CROWN-IBP Backward Bound
CROWN (Zhang et al., 2018) is a general framework that replaces non-linear functions in a neural
network with linear upper and lower hyperplanes with respect to pre-activation variables, such that
the entire neural network function can be bounded by a linear upper hyperplane and linear lower
hyperplane for all x ∈ S (S is typically a norm bounded ball, or a box region):
Ax + b ≤ f(x) ≤ Ax + b
CROWN achieves such linear bounds by replacing non-linear functions with linear bounds, and
utilizing the fact that the linear combinations of linear bounds are still linear, thus these linear bounds
23
Published as a conference paper at ICLR 2020
Table H: Comparison of verified and standard errors for CROWN-IBP models trained on TPUs and
GPUs (CIFAR-10, DM-Large model).
Dataset	e ('∞ norm)	Training Device	K schedules κstart I κend		Model errors (%) Standard ∣ Verified	
CIFAR-10	-U	— 2 1 - 6test = 255 U	— 2.2 etɪain = 255	GPU	0	0	29.18	45.50 46.03
		TPU	-Q~~	o~Q~~	-2848-	
	:test=2⅛ etrain = 255	GPU	0	0	54.60	67.11 66.94
		TPU	~~Q~~	o~Q~~	-54.02-	
1 We use βstart = βend = 1 for this setting, the same as in Table 2, and thus CROWN-IBP
bound is used to evaluate the verified error.
can propagate through layers. Suppose we have a non-linear vector function σ, applying to an input
(pre-activation) vector z, CROWN requires the following bounds in a general form:
AσZ + bσ ≤ σ(z) ≤ AσZ + bσ
In general the specific bounds A。, bσ, Aσ, bσ for different σ needs to be given in a case-by-case
basis, depending on the characteristics of σ and the preactivation range Z ≤ Z ≤ Z. In neural network
common σ can be ReLU, tanh, sigmoid, maxpool, etc. Convex adversarial polytope (Wong et al.,
2018) is also a linear relaxation based techniques that is closely related to CrOWN, but only for
ReLU layers. For ReLU such bounds are simple, where A。, A。are diagonal matrices, b。= 0:
Dz ≤ σ(z) ≤ Dz + C
(14)
where D and D are two diagonal matrices:
Dk,k =卜,
I	Zk
Zk -Zk
∫0,
Ck =	0,
I Zk Zk
{1,	if Zk > 0, i.e., this neuron is always active
0,	if Zk < 0, i.e., this neuron is always inactive	(15)
α, otherwise, any 0 ≤ α ≤ 1
if Zk >	0,	i.e., this neuron	is always active
if Zk <	0,	i.e., this neuron	is always inactive	(16)
otherwise
if Zk >	0,	i.e., this neuron	is always active
if Zk <	0,	i.e., this neuron	is always inactive	(17)
,otherwise
-zk
Note that CROWN-style bounds require to know all pre-activation bounds Z(I) and Z(l). We assume
these bounds are valid for x ∈ S. In CROWN-IBP, these bounds are obtained by interval bound
propagation (IBP). With pre-activation bounds Z(I) and Z(I) given (for X ∈ S), we rewrite the
CROWN lower bound for the special case of ReLU neurons:
Theorem L.1 (CROWN Lower Bound). For a L-layer neural network function f(x) : Rn0 → RnL,
∀j ∈ [nL], ∀x ∈ S, we have fj (x) ≤ fj (x), where
L
fj (x) = Aj?X + X Ajl) (b(I) + bj, (I)),	(18)
l=1
ej>	if l = L;
Ajl+I)W(I+1)Dj,(I)	if l ∈ {0,…，L - 1}.
24
Published as a conference paper at ICLR 2020
and ∀i ∈ [nk], we define diagonal matrices Dj,(I), bias vector b(l):
Dj,⑼=I, bj,(L) = 0
fl	if Ajl+1)W(∣i+1)	≥0,zkl) > Izkl) |, l	∈{1,…，L	- 1};
Djk"	J 0	if Ajl+1)W(∣+1)	≥ 0,zkl) < Izkl) ∣, l	∈ {1,…，L	- 1};
，	[Z^ if Ajk+1)W(,k+1) < 0, l ∈{1,∙∙∙,L - 1}.
_	J0	if Ajl+1)W(∣+1)	≥ 0; l ∈{1,…，L	- 1}
bk	=	[ ζzk⅛ if Ajl+1)W(∣+1)	< 0 l ∈{1,一，L - 1}.
ej ∈ RnL is a standard unit vector with j-th coordinate set to 1.
Note that unlike the ordinary CROWN (Zhang et al., 2018), in CROWN-IBP we only need the lower
bound to compute m and do not need to compute the A matrices for the upper bound. This save
half of the computation cost in ordinary CROWN. Also, W represents any affine layers in a neural
network, including convolutional layers in CNNs. In Section 3.2, we discussed how to use transposed
convolution operators to efficiently implement CROWN-IBP on GPUs.
Although in this paper we focus on the common case of ReLU activation function, other general
activation functions (sigmoid, max-pooling, etc) can be used in the network as CROWN is a general
framework to deal with non-linearity. For a more general derivation we refer the readers to (Zhang
et al., 2018) and (Salman et al., 2019b).
25