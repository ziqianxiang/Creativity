Published as a conference paper at ICLR 2020
Q-learning with UCB Exploration is Sample
Efficient for Infinite-Horizon MDP
Kefan Dong*, Yuanhao Wang*
Institute for Interdisciplinary Information Sciences,
Tsinghua University
{dkf16,yuanhao-16}@mails.tsinghua.edu.cn
Xiaoyu Chen
Key Laboratory of Machine Perception, MOE, School of EECS,
Peking University
cxy30@pku.edu.cn
Liwei Wang
Key Laboratory of Machine Perception, MOE, School of EECS
Center for Data Science, Peking University
wanglw@cis.pku.edu.cn
Ab stract
A fundamental question in reinforcement learning is whether model-free algo-
rithms are sample efficient. Recently, Jin et al. (2018) proposed a Q-learning
algorithm with UCB exploration policy, and proved it has nearly optimal regret
bound for finite-horizon episodic MDP. In this paper, we adapt Q-learning with
UCB-exploration bonus to infinite-horizon MDP with discounted rewards without
accessing a generative model. We show that the sample complexity of exploration
of our algorithm is bounded by O(迎：'7). This improves the previously best
known result of O(四:二卢)in this setting achieved by delayed Q-learning (StrehI
et al., 2006), and matches the lower bound in terms of as well as S and A up to
logarithmic factors.
1	Introduction
The goal of reinforcement learning (RL) is to construct efficient algorithms that learn and plan in
sequential decision making tasks when the underlying system dynamics are unknown. A typical
model in RL is Markov Decision Process (MDP). At each time step, the environment is in a state
s. The agent takes an action a, obtain a reward r, and then the environment transits to another state.
In reinforcement learning, the transition probability distribution is unknown. The algorithm needs
to learn the transition dynamics of MDP, while aiming to maximize the cumulative reward. This
poses the exploration-exploitation dilemma: whether to act to gain new information (explore) or to
act consistently with past experience to maximize reward (exploit).
Theoretical analyses of reinforcement learning fall into two broad categories: those assuming a
simulator (a.k.a. generative model), and those without a simulator. In the first category, the algorithm
is allowed to query the outcome of any state action pair from an oracle. The emphasis is on the
number of calls needed to estimate the Q value or to output a near-optimal policy. There has been
extensive research in literature following this line of research, the majority of which focuses on
discounted infinite horizon MDPs (Azar et al., 2011; Even-Dar & Mansour, 2003; Sidford et al.,
2018b). The current results have achieved near-optimal time and sample complexities (Sidford et al.,
2018b;a).
* These two authors contributed equally.
1
Published as a conference paper at ICLR 2020
Without a simulator, there is a dichotomy between finite-horizon and infinite-horizon settings. In
finite-horizon settings, there are straightforward definitions for both regret and sample complexity;
the latter is defined as the number of samples needed before the policy becomes near optimal. In this
setting, extensive research in the past decade (Jin et al., 2018; Azar et al., 2017; Jaksch et al., 2010;
Dann et al., 2017) has achieved great progress, and established nearly-tight bounds for both regret
and sample complexity.
The infinite-horizon setting is a very different matter. First of all, the performance measure cannot be
a straightforward extension of the sample complexity defined above (See Strehl & Littman (2008)
for detailed discussion). Instead, the measure of sample efficiency we adopt is the so-called sample
complexity of exploration (Kakade et al., 2003), which is also a widely-accepted definition. This
measure counts the number of times that the algorithm “makes mistakes” along the whole trajectory.
See also (Strehl & Littman, 2008) for further discussions regarding this issue.
Several model based algorithms have been proposed for infinite horizon MDP, for example R-
max (Brafman & Tennenholtz, 2003), MoRmaX (Szita & SzePesv虹i, 2010) and UCRL-Y (Lattimore
& Hutter, 2012). It is noteworthy that there still exists a considerable gap between the state-of-the-art
algorithm and the theoretical lower bound (Lattimore & Hutter, 2012) regarding 1/(1 - γ) factor.
Though model-based algorithms have been Proved to be samPle efficient in various MDP settings,
most state-of-the-art RL algorithms are develoPed in the model-free Paradigm (Schulman et al., 2015;
Mnih et al., 2013; 2016). Model-free algorithms are more flexible and require less sPace, which have
achieved remarkable Performance on benchmarks such as Atari games and simulated robot control
Problems.
For infinite horizon MDPs without access to simulator, the best model-free algorithm has a samPle
complexity of exploration O(巴：-4^), achieved by delayed Q-Iearning (Strehl et al., 2006). The
authors Provide a novel strategy of argument when Proving the uPPer bound for the samPle comPlexity
of exploration, namely identifying a sufficient condition for optimality, and then bound the number of
times that this condition is violated.
However, the results of Delayed Q-learning still leave a quadratic gap in 1/ from the best-known
lower bound. This is partly because the updates in Q-value are made in an over-conservative way. In
fact, the loose sample complexity bound is a result of delayed Q-learning algorithm itself, as well as
the mathematical artifact in their analysis. To illustrate this, we construct a hard instance showing
that Delayed Q-learning incurs Ω(1∕e3) sample complexity. This observation, as well as the success
of the Q-learning with UCB algorithm (Jin et al., 2018) in proving a regret bound in finite-horizon
settings, motivates us to incorporate a UCB-like exploration term into our algorithm.
In this work, we propose a Q-learning algorithm with UCB exploration policy. We show the sample
complexity of exploration bound of our algorithm is O( ^(:士产).This strictly improves the previous
best known result due to Delayed Q-learning. It also matches the lower bound in the dependence on
, S and A up to logarithmic factors.
We point out here that the infinite-horizon setting cannot be solved by reducing to finite-horizon
setting. There are key technical differences between these two settings: the definition of sample
complexity of exploration, time-invariant policies and the error propagation structure in Q-learning.
In particular, the analysis techniques developed in (Jin et al., 2018) do not directly apply here. We
refer the readers to Section 3.2 for detailed explanations and a concrete example.
The rest of the paper is organized as follows. After introducing the notation used in the paper in
Section 2, we describe our infinite Q-learning with UCB algorithm in Section 3. We then state our
main theoretical results, which are in the form of PAC sample complexity bounds. In Section 4 we
present some interesting properties beyond sample complexity bound. Finally, we conclude the paper
in Section 5.
2	Preliminary
We consider a Markov Decision Process defined by a five tuple hS, A, p, r, γi, where S is the state
space, A is the action space, p(s0|s, a) is the transition function, r : S ×A → [0, 1] is the deterministic
2
Published as a conference paper at ICLR 2020
reward function, and 0 ≤ γ < 1 is the discount factor for rewards. Let S = |S | and A = |A| denote
the number of states and the number of actions respectively.
Starting from a state s1, the agent interacts with the environment for infinite number of time steps.
At each time step, the agent observes state st ∈ S, picks action at ∈ A, and receives reward rt ; the
system then transits to next state st+1.
Using the notations in Strehl et al. (2006), a policy πt refers to the non-stationary control policy
of the algorithm since step t. We use V πt (s) to denote the value function under policy πt, which
is defined as Vπt(s) = e[P∞=i YiTr(si, ∏t+i-ι(si))∣sι = s]. We also use V*(s) = sup∏ Vπ(s)
to denote the value function of the optimal policy. Accordingly, we define Qπt (s, a) = r(s, a) +
E[P∞=2 Yi-1r(si, ∏t+i-ι(si))∣sι = s, aι = a] as the Q function under policy ∏t; Q*(s, a) is the Q
function under optimal policy π*.
We use the sample complexity of exploration defined in Kakade et al. (2003) to measure the learning
efficiency of our algorithm. This sample complexity definition has been widely used in previous
works Strehl et al. (2006); Lattimore & Hutter (2012); Strehl & Littman (2008).
Definition 1. Sample complexity of Exploration of an algorithm ALG is defined as the number
of time steps t such that the non-stationary policy πt at time t is not -optimal for current state st, i.e.
Vπt (St) < V*(st)-c∙
Roughly speaking, this measure counts the number of mistakes along the whole trajectory. We use
the following definition of PAC-MDP Strehl et al. (2006).
Definition 2. An algorithm ALG is said to be PAC-MDP (Probably Approximately Correct in
Markov Decision Processes) if, for any and δ, the sample complexity of ALG is less than some
polynomial in the relevant quantities (S, A, 1/e, 1∕δ, 1/(1 — Y)), with probability at least 1 一 δ.
Finally, recall that Bellman equation is defined as the following:
J Vπt (S)= Qnt (s,∏t(s))	J V * (S) = Q*(s,∏*(s))
[Qπt(s, a)：=(rt + γPVπt+1 )(s,a),	[ Q*(s,a) := (rt + YPV*)(s,a),
which is frequently used in our analysis. Here we denote [PVπt](s, a) := Es，〜p(∙∣s,α) Vπt+1 (s0).
3 Main Results
In this section, we present the UCB Q-learning algorithm and the sample complexity bound.
3.1	Algorithm
Algorithm 1 Infinite Q-learning with UCB
5:
10:
Parameters: , Y , δ
Initialize Q(s, a), Q(s, a) J- 1-Y, N(s, a) J- 0, 6ι J-
Define ι(k) = ln(SA(k + 1)(k + 2)∕δ),ak = HH+1.
for t = 1, 2, ... do
Take action at — arg max。，Q(St, a0)
Receive reward rt and transit to St+1
N(St, at) J N(St, at) + 1
kJ N (St, at), bkJ ι-γ q Htkkk
^ , ʌ , .
24RM ln T-Y
H j ln 1/((I-Y)eI)
,H j	iΞ17Y
.c2 is a constant and can be set to 4√2
V(st+1) — maXa∈A Q(st+1, a)
Q(St, at) J (1 一 αk)Q(st, at) + αk [r(st, at) + bk + YV(St+1)]
Q(St, at) J min(Q(St, at), Q(St, at))
end for
e
Here c? = 4√2 is a constant. R =「ln ^I-Y)/(1 — y)] , while the choice of M can be found in
Section. 3.3. (M = O (ln 1/((1 一 Y)))). The learning rate is defined as αk = (H + 1)/(H + k).
H is chosen as ln1/((I-Y)S), which satisfies H ≤ ln1/(I(I-Y)'1).
ln 1/Y	1-Y
3
Published as a conference paper at ICLR 2020
Our UCB Q-learning algorithm (Algorithm 1) maintains an optimistic estimation of action value
function Q(s, a) and its historical minimum value Q(s, a). Nt(s, a) denotes the number of times that
(s, a) is experienced before time step t; τ(s, a, k) denotes the time step t at which (st, at) = (s, a)
for the k-th time; if this state-action pair is not visited that many times, τ(s, a, k) = ∞. Qt (s, a)
and Qt(s, a) denotes the Q and Q value of (s, a) that the algorithm maintains when arriving at st
respectively.
3.2	Sample Complexity of Exploration
Our main result is the following sample complexity of exploration bound.
Theorem 1. For any > 0, δ > 0, 1/2 < γ < 1, with probability 1 - δ, the sample complexity of
exploration (i.e., the number of time steps t such that πt is not -optimal at st) of Algorithm 1 is at
most
O( SA ln1∕δ∖
V2 (i-γ)7J
where O suppresses logarithmic factors of 1/, 1/(1 - γ) and SA.
We first point out the obstacles for proving the theorem and reasons why the techniques in Jin et al.
(2018) do not directly apply here. We then give a high level description of the ideas of our approach.
One important issue is caused by the difference in the definition of sample complexity for finite and
infinite horizon MDP. In finite horizon settings, sample complexity (and regret) is determined in the
first T timesteps, and only measures the performance at the initial state si (i.e. (V* - Vπ)(sι)).
However, in the infinite horizon setting, the agent may enter under-explored regions at any time
period, and sample complexity of exploration characterizes the performance at all states the agent
enters.
The following example clearly illustrates the key difference between infinite-horizon and finite-
horizon. Consider an MDP with a starting state s1 where the probability of leaving s1 is o(T-1). In
this case, with high probability, it would take more than T timesteps to leave s1. Hence, guarantees
about the learning in the first T timesteps or about the performance at s1 imply almost nothing about
the number of mistakes the algorithm would make in the rest of the MDP (i.e. the sample complexity
of exploration of the algorithm). As a result, the analysis for finite horizon MDPs cannot be directly
applied to infinite horizon setting.
This calls for techniques for counting mistakes along the entire trajectory, such as those employed
by Strehl et al. (2006). In particular, we need to establish convenient sufficient conditions for being
-optimal at timestep t and state st, i.e. V* (st) - Vπt (st) ≤ . Then, bounding the number of
violations of such conditions gives a bound on sample complexity.
Another technical reason why the proof in Jin et al. (2018) cannot be directly applied to our problem
is the following: In finite horizon settings, Jin et al. (2018) decomposed the learning error at episode
k and time h as errors from a set of consecutive episodes before k at time h + 1 using a clever design
of learning rate. However, in the infinite horizon setting, this property does not hold. Suppose at
time t the agent is at state st and takes action at. Then the learning error at t only depends on those
previous time steps such that the agent encountered the same state as st and took the same action as
at . Thus the learning error at time t cannot be decomposed as errors from a set of consecutive time
steps before t, but errors from a set of non-consecutive time steps without any structure. Therefore,
we have to control the sum of learning errors over an unstructured set of time steps. This makes the
analysis more challenging.
Now we give a brief road map of the proof of Theorem 1. Our first goal is to establish a sufficient
condition so that πt learned at step t is -optimal for state st. As an intermediate step we show that a
sufficient condition for V*(st) - Vπt (st) ≤ is that V*(st0) - Q* (st0, at0) is small for a few time
steps t0 within an interval [t, t + R] for a carefully chosen R (Condition 1). Then we show the desired
sufficient condition (Condition 2) implies Condition 1. We then bound the total number of bad time
steps on which V* (st) - Q*(st, at) is large for the whole MDP; this implies a bound on the number
of violations of Condition 2. This in turn relies on a key technical lemma (Lemma 2).
4
Published as a conference paper at ICLR 2020
The remaining part of this section is organized as follows. We establish the sufficient condition for
-optimality in Section 3.3. The key lemma is presented in Section 3.4. Finally we prove Theorem 1
in Section 3.5.
3.3	SUFFICIENT CONDITION FOR -OPTIMALITY
In this section, we establish a sufficient condition (Condition 2) for -optimality at time step t.
For a fixed st , let TRAJ(R) be the set of length-R trajectories starting from st . Our goal is to give
a sufficient condition so that πt , the policy learned at step t, is -optimal. For any 2 > 0, define
R ：= dln e2(i-γ)/(1 - Y)]. Denote V*(St) - Q*(st, at) by ∆t. Wehave
V*(St)- Vπt(St)
=V*(st)-Q*(st,at)+Q*(st,at)-Vπt(st)
=V*(St)-Q*(St,at)+γP(V* - Vπt) (St, πt(St))
=V * (St)- Q*(st, at) + Y ^X P (st+1|st, πt (St)) ∙ [V *(st+l) - Q*(st+1, at+1)] +
st+1
Y E P (St+2|st+1,nt+1(St+1)) ∙ P (st+1lst,πt(st)) [V*(St+2) - Q*(St+2,at+2)]
st+1,st+2
R-1
≤b + E p(traj) ∙ EYj∆t+j
traj ∈	j=0
TRAJ(R)
(1)
γR
where the last inequality holds because ɪ-γ
≤ 2 , which follows from the definition of R.
For any fixed trajectory of length R starting from st, consider the sequence (∆t0)t≤t0<t+R. Let Xt(i)
be the i-th largest item of (∆t0)t≤t0 <t+R. Rearranging Eq. (1), we obtain
R
V*(st) - Vπt(st) ≤ 2 + Etraj	XYi-1Xt(i) .	(2)
i=1
We first prove that Condition 1 implies -optimality at time step t when 2 = /3.
Condition 1.	Let ξi := 2+2 e2 (ln ɪ-^)	. For all 0 ≤ i ≤ [log2 Rc,
E[Xt(2i)] ≤ ξi.	(3)
Claim 1. If Condition 1 is satisfied at time step t, the policy πt is -optimal at state st, i.e. V* (st) -
Vπt(st) ≤ .
Proof. Note that Xt(i) is monotonically decreasing with respect to i. Therefore, E[Xt(i)] ≤
E[Xt(2b og2 ic )]. Eq. (3) implies that for 1/2 < Y < 1,
R
R
E	XYi-1Xt(i) = XYi-1
i=1
R
i=1
R
E[Xt(i)] ≤	X Yi-1E[Xt(2b og2 ic)]
≤	Yi-12-blog2ic-22
i=1
i=1
ln±)	≤ X Fe2 (ln±)	≤ 2e2,
where the last inequality follows from the fact that P∞=ι γ-1 = Y ln ɪ-ʒ; andY>1/2.
Combining with Eq. 2, We have, V*(st) 一 Vπt (St) ≤ ⑦ + E [pR=ι YiTX("] ≤ 362 = e. 口
5
Published as a conference paper at ICLR 2020
Next we show that given i, t, Condition 2 implies Eq. (3).
Condition 2.	Define L = [log? Rc. Let M = max { ∣^2log2 ξ^(1-7)], 1。} , and η = M ∙ 2j-1.
Forall 2 ≤ j ≤ M, / Pr[X(2 ) > ηj-ι] ≤ 鲁
Claim 2. Given i, t, Eq. (3) holds if Condition 2 is satisfied.
Proof. The reason behind the choice of M is to ensure that ηM > 1/(1 - γ) 1. It follows that,
assuming Condition 2 holds, for 1 ≤ j ≤ M,
E [X(2i)i = ZO 1/(1 Y) Pr [X(2i) > Xi
M
dx ≤ η1 + X ηj Pr[Xt(2i)
j=2
> ηj-1] ≤ ξi.
□
Therefore, if a time step t is not 2-optimal, there exists 0 ≤ i < blog2 Rc and 2 ≤ j ≤ M such that
η Pr[x(2i) > ηj-ι] > MM.	(4)
Now, the sample complexity can be bounded by the number of (t, i, j) pairs that Eq. (4) is violated.
Following the approach of Strehl et al. (2006), for a fixed (i, j)-pair, instead of directly counting the
number of time steps t such that Pr[X(2 ) > %-ι] > Mn-, We count the number of time steps that
(2i)
Xt	> ηj-1. Lemma 1 provides an upper bound of the number of such t.
3.4 Key Lemmas
In this section, We present tWo key lemmas. Lemma 1 bounds the number of sub-optimal actions,
Which in turn, bounds the sample complexity of our algorithm. Lemma 2 bounds the Weighted sum
of learning error, i.e. (Qt - Q*)(s, a), with the sum and maximum of weights. Then, we show that
Lemma 1 folloWs from Lemma 2.
Lemma 1. Forfixed t and η > 0, let Bnt) be the event that V*(st) 一 Q*(st, at) > I-Y in step t. If
η > 26ι, then with probability at least 1 — δ∕2,
tI IhBnt)i≤ SA^ ∙ polylog (ɪ,士)，	(5)
where I [∙] is the indicator function.
Before presenting Lemma 2, we define a class of sequence that occurs in the proof.
Definition 3. A sequence (wt)t≥1 is said to be a (C, w)-sequence for C, w > 0, if 0 ≤ wt ≤ w for
all t ≥ 1, and t≥1 wt ≤ C.
Lemma 2. For every (C, w)-sequence (Wt) t≥ι, With probability 1 — δ∕2, the following holds:
L /右	一"	」√WSAC<Cy	WSA ln C1	1 ʌ
XWt(Qt-Q*)(st, at) ≤ L + O ( V—5	+ T-IF ln (T-IR)
where '(C) = ι(C) ln (1-；)口 is a log-factor.
Proof of Lemma 2 is quite technical, and is therefore deferred to supplementary materials.
1 ηM > 1/(1 — Y) can be verified by combining inequalities ξi ∙ 2M/2 ≥ 1/(1 — Y) and 2M/2-1 > (M +1)
for large enough M.
6
Published as a conference paper at ICLR 2020
Now, we briefly explain how to prove Lemma 1 with Lemma 2. (Full proof can be found in
supplementary materials.) Note that since Qt ≥ Q* and at = argmax。Qt(st, a),
__ , ,	_ , ,	、	O	、	_ ,,	、
V (St)- Q (st, at) ≤ Qt(st,at) - Q (st, at).
We now consider a set J = {t : V* (st) - Q*(st, at) > η(1 - γ)-1}, and consider the (|J |, 1)-
weight sequence defined by wt = I [t ∈ J]. We can now apply Lemma 2 to weighted sum
Pt≥ι wt [V*(St) - Q*(st, at)]. On the one hand, this quantity is obviously at least | J∣η(1 - γ)-1.
On the other hand, by lemma 2, it is upper bounded by the weighted sum of (Q - Q*)(st, at). Thus
we get
⑺门 LY "工 C ( PSA∣ J∣'(∣J∣)工 WSA ln |J ∣1	1 ʌ
1J|n(I-Y)	≤L + o( (i-γ)2.5	+lɪ-ɪln(Γ-^¼)-
Now focus on the dependence on |J |. The left-hand-side has linear dependence on |J |, whereas the
left-hand-side has a O (∙pJ^) dependence. This allows US to solve out an upper bound on | J| with
quadratic dependence on 1∕η.
3.5 Proof for Theorem 1
We prove the theorem by stitching Lemma 1 and Condition 2.
Proof. (Proof for Theorem 1)
By lemma 1, for any 2 ≤ j ≤ M, Pt∞=1 I [V* (St) - Q* (St, at) > ηj-1] ≤ C, where
SA ln SA ln1∕δ D
=ηj-ι(i - γ)5 ∙.
Here P is a shorthand for polylog (-1, ɪ^).
(6)
(2i)
Let At = I[Xt ≥ ηj-1] be a Bernoulli random variable, and {Ft}t≥1 be the filtration generated
by random variables {(Sτ, aτ) : 1 ≤ τ ≤ t}. Since At is Ft+R-measurable, for any 0 ≤ k < R,
{Ak+tR - E[Ak+tR | Fk+tR]}t≥0 is a martingale difference sequence. For now, consider a fixed
0 ≤ k < R. By Azuma-Hoeffiding inequality, after T = O (C ∙ Mξηj ln(RML)) time steps (if it
happens that many times) with
Pr [x(+)R ≥ η^-l] = E[Ak+tR] > Mi-,
Mηj
we have Pt Ak+tR ≥ C∕2i with probability at least 1 - δ∕(2M RL).
(7)
On the other hand, if Ak+tR happens, within [k + tR, k + tR + R - 1], there must be at least
2i time steps at which V* (St) - Q* (St, at) > ηj-1. The latter event happens at most C times,
and [k + tR, k + tR + R - 1] are disjoint. Therefore, Pt∞=0 Ak+tR ≤ C∕2i. This suggests that
the event described by (7) happens at most T times for fixed i and j . Via a union bound on
0 ≤ k < R, we can show that with probability 1 - δ∕(2ML), there are at most RT time steps where
Pr Xt(2i) ≥ ηj-1 > ξi∕(Mηj). Thus, the number of sub-optimal steps is bounded by,
∞
XI[V*(St)-Vπt(St)>]
t=1
∞LM	LM ∞
≤ X X X 小 PM)"片 L X X X1W
LM
Xi=0Xj=2
SAMR ln 1∕δ ln SA D X SA ∙ 2i+4 ln SA ln1∕δ D
ηjξi ∙ 2i(1- Y)5	' i=0	e2(1- Y)6
SAR ln SA ln1∕δ D	SA ln SA ln1∕δ D
≤ e2(1-Y )6	≤	e2(1-Y )7
(By definition of ξi and ηj)
(By definition of R)
≤
7
Published as a conference paper at ICLR 2020
It should be stressed that throughout the lines, P is a shorthand for an asymptotic expression, instead
of an exact value. Our final choice of ∈2 and 6ι are	= ∣, and s = o. dλ∕1——L. It is not hard
3	24RMi ln T 
1-γ
to see that lnl/s = poly(ln ɪ, ln ɪ--Y). This immediately implies that with probability 1 - δ, the
number of time steps such that (V* - Vπ) (St) > e is
O SSA ln1∕δλ
晨2(1-γ)7J ,
where hidden factors are poly(ln ɪ, ln y-1γ, ln SA).
□
4	Discussion
In this section, we discuss the implication of our results, and present some interesting properties of
our algorithm beyond its sample complexity bound.
4.1	Comparison with previous results
Lower bound To the best of our knowledge, the current best lower bound for worst-case sample
complexity is Ω Q(SAγ)3 ln1∕δ) due to Lattimore & Hutter (2012). The gap between our results
and this lower bound lies only in the dependence on 1/(1 -γ) and logarithmic terms of SA, 1/(1 -γ)
and 1∕.
Model-free algorithms Previously, the best sample complexity bound for a model-free algorithm
is O (i4(Say)8)(suppressing all logarithmic terms), achieved by Delayed Q-learning Strehl et al.
(2006). Our results improve this upper bound by a factor of m卷)), and closes the quadratic gap in
1∕ between Delayed Q-learning’s result and the lower bound. In fact, the following theorem shows
that UCB Q-learning can indeed outperform Delayed Q-learning.
Theorem 2. There exists a family of MDPs with constant S and A, in which with probability
1 一 δ, Delayed Q-learning incurs sample complexity of exploration of Ω Qn(Jδ))，assuming that
ln(1∕δ) < -2.
The construction of this hard MDP family is given in the supplementary material.
Model-based algorithms For model-based algorithms, better sample complexity results in infinite
horizon settings have been claimed Szita & Szepesvari (2010). To the best of our knowledge, the best
published result without further restrictions on MDPS is O Q(SAy”) claimed by Szita & Szepesvari
(2010), which is (1 - γ) smaller than our upper bound. From the space complexity point of view,
our algorithm is much more memory-efficient. Our algorithm stores O(SA) values, whereas the
algorithm in Szita & SZePeSVari (2010) needs Ω(S2A) memory to store the transition model.
4.2	Extension to other settings
Due to length limits, detailed discussion in this section is deferred to supplementary materials.
Finite horizon MDP The sample complexity of exploration bounds of UCB Q-learning implies
O (e-2) PAC sample complexity and a O (T1/2) regret bound in finite horizon MDPs. That is, our
algorithm implies a PAC algorithm for finite horizon MDPs. We are not aware of reductions of the
opposite direction (from finite horizon sample complexity to infinite horizon sample complexity of
exploration).
Regret The reason why our results can imply an O(√T) regret is that, after choosing s,it follows
from the argument of Theorem 1 that with probability 1 - δ, for all 2 > O(1∕(1 - γ)), the number
of 2-suboptimal steps is bounded by
O
(SA ln SA ln1∕δ
(e2(1-γ)7

polylog
8
Published as a conference paper at ICLR 2020
In contrast, Delayed Q-learning Strehl et al. (2006) can only give an upper bound on 1-suboptimal
steps after setting parameter 1.
5	Conclusion
Infinite-horizon MDP with discounted reward is a setting that is arguably more difficult than other
popular settings, such as finite-horizon MDP. Previously, the best sample complexity bound achieved
by model-free reinforcement learning algorithms in this setting is O(臼：-^^), due to Delayed
Q-learning Strehl et al. (2006). In this paper, we propose a variant of Q-learning that incorporates
upper confidence bound, and show that it has a sample complexity of O(迎：：)7). This matches the
best lower bound except in dependence on 1/(1 - γ) and logarithmic factors.
6	acknowledgements
The authors thank Chi Jin and Chongjie Zhang for helpful discussions. This work is supported
by National Basic Research Program of China (973 Program) (grant no. 2015CB352502), NSFC
(61573026), BJNSF (L172037) and Beijing Acedemy of Artificial Intelligence.
References
Mohammad Gheshlaghi Azar, Remi Munos, Mohammad Ghavamzadeh, and Hilbert Kappen. Speedy
q-learning. In Advances in neural information processing systems, 2011.
Mohammad Gheshlaghi Azar, Ian Osband, and Remi Munos. Minimax regret bounds for reinforce-
ment learning. arXiv preprint arXiv:1703.05449, 2017.
Ronen I. Brafman and Moshe Tennenholtz. R-max - a general polynomial time algorithm for
near-optimal reinforcement learning. J. Mach. Learn. Res., 3:213-231, March 2003. ISSN
1532-4435. doi: 10.1162/153244303765208377. URL https://doi.org/10.1162/
153244303765208377.
Christoph Dann, Tor Lattimore, and Emma Brunskill. Unifying pac and regret: Uniform pac bounds
for episodic reinforcement learning. In Advances in Neural Information Processing Systems, pp.
5713-5723, 2017.
Eyal Even-Dar and Yishay Mansour. Learning rates for q-learning. Journal of Machine Learning
Research, 5(Dec):1-25, 2003.
Thomas Jaksch, Ronald Ortner, and Peter Auer. Near-optimal regret bounds for reinforcement
learning. Journal of Machine Learning Research, 11(Apr):1563-1600, 2010.
Chi Jin, Zeyuan Allen-Zhu, Sebastien Bubeck, and Michael I Jordan. Is q-learning provably efficient?
In Advances in Neural Information Processing Systems, pp. 4864-4874, 2018.
Sham Machandranath Kakade et al. On the sample complexity of reinforcement learning. PhD thesis,
University of London London, England, 2003.
Tor Lattimore and Marcus Hutter. Pac bounds for discounted mdps. In International Conference on
Algorithmic Learning Theory, pp. 320-334. Springer, 2012.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan
Wierstra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.
Volodymyr Mnih, Adria Puigdomenech Badia, Mehdi Mirza, Alex Graves, Timothy Lillicrap, Tim
Harley, David Silver, and Koray Kavukcuoglu. Asynchronous methods for deep reinforcement
learning. In International conference on machine learning, pp. 1928-1937, 2016.
John Schulman, Sergey Levine, Pieter Abbeel, Michael Jordan, and Philipp Moritz. Trust region
policy optimization. In International Conference on Machine Learning, pp. 1889-1897, 2015.
9
Published as a conference paper at ICLR 2020
Aaron Sidford, Mengdi Wang, Xian Wu, Lin Yang, and Yinyu Ye. Near-optimal time and sample
complexities for solving markov decision processes with a generative model. In Advances in
Neural Information Processing Systems,pp. 5186-5196, 2018a.
Aaron Sidford, Mengdi Wang, Xian Wu, and Yinyu Ye. Variance reduced value iteration and faster
algorithms for solving markov decision processes. In Proceedings of the Twenty-Ninth Annual
ACM-SIAM Symposium on Discrete Algorithms, pp. 770-787. Society for Industrial and Applied
Mathematics, 2018b.
Alexander L Strehl and Michael L Littman. An analysis of model-based interval estimation for
markov decision processes. Journal of Computer and System Sciences, 74(8):1309-1331, 2008.
Alexander L Strehl, Lihong Li, Eric Wiewiora, John Langford, and Michael L Littman. Pac model-
free reinforcement learning. In Proceedings of the 23rd international conference on Machine
learning, pp. 881-888. ACM, 2006.
Istvan Szita and Csaba Szepesvari. Model-based reinforcement learning with nearly tight exploration
complexity bounds. In Proceedings of the 27th International Conference on Machine Learning
(ICML-10), pp. 1031-1038, 2010.
A	Proof of Lemma 1
Lemma 1. Forfixed t and η > 0, let Bnt be the event that V*(s∕ — Q*(st, at) > ILY in step t. If
η > 26ι, then with probability at least 1 — δ∕2,
t=∞ τ rπ(t)l	SA ln SA ln1∕δ	,,(11、	C
X I[Bn t] ≤	η2(i-γ)3	∙polylog J, L),	⑻
where I [∙] is the indicator function.
Proof. When η > 1 the lemma holds trivially. Now consider the case that η ≤ 1.
Let I = {t : V*(st) — Q*(st, at) > ι-nγ}. By lemma 2, with probability 1 — δ,
n|I|
1 - Y
≤ ^X (V*(St)- Q*(St, at)) ≤ ^X h(Qt — Q*) (St, at)i
t∈I	t∈I
JZK
1 - Y
≤
/	1	,~..... SA	1
+ O GT-^ pSA7≡ +Lln|I|ln -
141
1 - Y
≤
+ O /ln	1	( JSA|I|ln SAII + SA ln |I|
+	1	ei(1—Y) 1	(1—Y)5/2	+ (1 — γ)3
≤
|IH
1 - Y
+ O "ln 士 ^ O码 + S≡⅛))
Suppose that |I| =标；坐：)3 ln SA, for some k > 1. Then it follows that for some constant C1,
η∣I∣ = k2SAlnSA ≤ ?(n - E1)∣I∣
1 — Y (1 — Y)4η -	1 — Y
≤ eijlnɪln-ɪ- (pSA≡≡ + S!
δ 1(1 — Y)	(1 — Y)5/2	(1 — Y)3
≤ Ci rinɪln ∩1 ʌ (	Pln SA ∙ (ln SA + ln |I|) + SAn).
δ 1(1 — Y) η(1 — Y)4	(1 — Y)3
10
Published as a conference paper at ICLR 2020
Therefore
k2 ln(SA) ≤ Cι∖∕ln1ln-1 ~~7 (k (lnSA + ln |I|) + η(1 - γ)ln |I|)
δ 1(1 - γ)
≤ kC1
1
S(I - Y)
(lnSA+2ln|I|)
≤ kC1
1
S(I - Y)
3 ln SA + 4ln k + 6ln —ɑ--J
≤ 6kC1
-----------(ln SA + ln ek).
1(1 - Y)
Let C0 = max{2, 6C1 Jln 1 ln2	(；-Y)}. Then
k ≤ C0(2 + ln k).
(9)
Ifk ≥ 10C0 ln C0, then
k-C0(2+lnk) ≥ 8C0 ln C0 - (2 + ln 10)C0
≥ 4C0(2lnC0 -4) ≥ 0,
which means violation of (9). Therefore, since C0 ≥ 2
k ≤ 10C0lnC0 ≤ 360C2 max{ln4 ―--------, 20ln2}.
1	1(1 - Y)
It immediately follows that
|I|
SAk2
≤
η2(1 - Y)3
SA ln SA
η2(i 一 γ)5
lnSA
∙ln 1 ∙O(ln8 士).
(10)
(11)
(12)
□
B Proof of Lemma 2
Lemma 2. For every (C, w)-sequence (wt)t≥1, with probability 1 一 δ∕2, the following holds:
Ewt(Qt - Q*)(st,at) ≤
t≥1
Cei	W WSAA(JCC)	WSA ln C 1
1 一 γ+	∖ (1 一 γ)2.5	+ (1 一 Y)3 n (1 一 γ)eι
where '(C) = ι(C) ln(]_；)口 is a log-factor.
Fact 1. (1) The following statement holds throughout the algorithm,
ZA / 一 一、 /八 (一 一、
Qp+1 (s, a) ≤ Qp+1 (s, a).
(2)	For any p, there exists p0 ≤ p such that
Qp+1 (s, a) ≥ Qp0+1 (s, a).
Proof. Both properties are results of the update rule at line 11 of Algorithm 1.
□
Before proving lemma 2, we will prove two auxiliary lemmas.
Lemma 3. The following properties hold for αit :
11
Published as a conference paper at ICLR 2020
L ↑β ≤ Pt=I αi ↑∕l ≤ 2 ʌ/f for every t ≥ 1,c> 0.
2.	maxi∈[t] αi ≤ 2H and Pi=ι(α"2 ≤ 2H for every t ≥ 1.
3.	Pt∞=i αit = 1 + 1/H, for every i ≥ 1.
4.	ʌ/ɪ(ttɪ ≤ Pt=I atʌ/ɪ(i) ≤ 2ʌ/ɪ(tɪ where ∣(t) = ln(c(t+1)(t + 2)),for every t ≥ 1,c ≥ 1.
Proof. Recall that
αt=H+t, α0=Y(I-αj),
H+t	j=1
t
αti = αi	(1 - αj).
j=i+1
Properties 1-3 are proven by Jin et al. (2018). Now we prove the last property.
On the one hand,
Xat" ≤ XOtrf ≤ 2耳,
i=1	i=1
where the last inequality follows from property 1.
The left-hand side is proven by induction on t. For the base case, when t = 1, att = 1. For t ≥ 2, we
have ait = (1 一 at)ait-1 for 1 ≤ i ≤ t 一 1. It follows that
X 国产=以耳+(1 - at) £ a；-" ≥ at	+(1 - at)/^-1.
i=1	i=1
Since function f(t) = ι(t)∕t is monotonically decreasing for t ≥ 1, c ≥ 1, we have
at∖曜+(1-at)∖= ≥ at户+(1- at)∖曜 ≥ 户.
t∖l t 1 tj∖ t -1 — tV t 1 t'V t _ V t
□
Lemma 4. With probability at least 1 一 δ/i2,for allP ≥ 0 and (s, a)-pair,
α0	t
0 ≤ (Qp 一 Q)(s, a) ≤ J 一 Y + EYat(Vti — V*)(sti+ι) + βt,
0 ≤ (Qp - Q*)(s,a),
where t = Np(s, a), ti, = T(s, a, i) and βt = c3 ,Hι(t)∕((1 - γ)2t).
(13)
(14)
Proof. Recall that
at0 =	(1 一 aj ),	ait
j=1
t
ai	(1 一 aj).
j=i+1
t
From the update rule, it can be seen that our algorithm maintains the following Q(s, a):
1t
Qp(S,a) = a0J—— + Xai [r(s,a) + bi + γVV⅛(sti+ι)].
Bellman optimality equation gives:
Subtracting the two equations gives
(Qp-Q…=a0(上
—
t
Q*(s, a)) + X at [bi + γ (Vti- V*)(s*ι) + Y (V*(s*ι) — PV*(s, a))].
i=1
12
Published as a conference paper at ICLR 2020
The identity above holds for arbitrary p, s and a. Now fix s ∈ S, a ∈ A and p ∈ N. Let t = Np (s, a),
ti = τ(s, a, i). The t = 0 case is trivial; we assume t ≥ 1 below. Now consider an arbitrary fixed k.
Define
△i = (αk ∙ I[ti < ∞] ∙ (PV* - Pti V*) (s, a))
Let Fi be the σ-Field generated by random variables (s1, a1, ..., sti, ati). It can be seen that
E [∆i|Fi] = 0, while △ is measurable in Fi+ι. Also, since 0 ≤ V*(s, a) ≤ y-1γ, ∣∆i∣ ≤ ɪ-2Y.
Therefore, △i is a martingale difference sequence; by the Azuma-Hoeffding inequality,
Pr X ∆i >η ≤ 2 exp  -----------------η-τ---------∖ .	(15)
[⅛1	「 I 8(1-Y 厂2 Pk=ι(αk)2J
By choosing η, we can show that with probability 1 - δ/ [SA(k + 1)(k + 2)],
k
X ∆i
i=1
1-γ
k
X(αki)2
i=1
2(k +1)(k + 2)SA
n	δ
c2	Hι(k)
1 - γ V k
(16)
Here c2 = 4√2, ι(k) = ln (k+1)(：+2)SA. By a union bound for all k, this holds for arbitrary k > 0,
arbitrary s ∈ S , a ∈ A simultaneously with probability
∞
1- X X
s0 ∈S,a0 ∈A k=1
2SA(k + 1)(k + 2)
Therefore, we conclude that (16) holds for the random variable t = Np(s, a) and for all p, with
probability 1 - δ∕2 as well.
Proof of the right hand side of (13): We also know that (bk
2c2	Hι(k)
1 - γ V k
tt
It is implied by (16) that
(Qp - Q*)(s, a) ≤
≤
1-γ
θ0
1 - Y
+ Y X∆il+ Xαt WVti- V*)(xti+ι) + bi]
i=1	i=1
+ 乎rHtt + X Yat(Vti - V*)(xti+ι)
Y	i=1
(Property 4 of lemma 3)
≤ 1aγ + X Yai(Vti - V*)(xti+ι) + βt.
Note that βt = c3(1 — Y)-IpHι(t)∕t; c3 = 3c2 = 12√2.
Proof of the left hand side of (13): Now, we assume that event that (16) holds. We assert that
Qp ≥ Q* for all (s, a) and p ≤ p0. This assertion is obviously true when p0 = 0. Then
lt	l t
(Qp- Q*)(s,a) ≥ -y X △i + X at [Y(Vti - V*)(xti + l)+ bJ
l i=1	l	i=1
t	lt	l
≥ X ai bi - Y X ∆i ≥0.
i=1	l i=1	l
Therefore the assertion holds for p0 + 1 as well. By induction, it holds for all p.
We now see that (13) holds for probability 1 - δ∕2 for all p, s, a. Since Qp(s, a) is always greater
than Qpo(s, a) for someρ0 ≤ p, we know that Qp(s, a) ≥ Qpo (s, a) ≥ Q*(s, a), thus proving (14).
□
∖
≤
δ
1 - 2
13
Published as a conference paper at ICLR 2020
We now give a proof for lemma 2. Recall the definition for a (C, w)-sequence. A sequence (wt)t≥1
is said to be a (C, w)-sequence for C, w > 0, if 0 ≤ wt ≤ w for all t ≥ 1, and Pt≥1 wt ≤ C.
Proof. Let nt = Nt(st, at) for simplicity; we have
Ewtgt- Q*)(st,at)
≥1
≤ Xwt(Qt- Q")(st,at)
t≥1
≤	wt
t≥1
α0	nt
1 -	+ Bnt + Y X ant V^T(S(St,at,i) - V*) (ST(st,at,i) +1)
1 - γ	i=1
(17)
The last inequality is due to lemma 4. Note that α0nt
be bounded by,
I[nt = 0], the first term in the summation can
X wt三
t≥1	Y
SAw
≤----
—1 - Y
(18)
For the second term, define u(s, a) = supt Nt(s, a).2 It follows that,
u(s,a)
wtβnt = wT (s,a,i) βi
≤ 2 X(1 - Y)-1C3 JI(C)HCs,aw
≤ 2c3(1 - Y)TpwSAHCI(C).
(19)
(20)
(21)
Where Cs,a =	t≥1,(s	,a )=(s,a)wt. Inequality (19) follows from rearrangement inequality, since
I(x)/x is monotonically decreasing. Inequality (21) follows from Jensen’s inequality.
For the third term of the summation, we have
nt
X WX Ont (VT(St,at,i) - V I(ST (st,at,i) + l)
t≥1 i=1
/	\
∞
≤ X (%- V *) (st，+i)	X	αnnt0 Wt
t0≥1	t=t0+1
(St,at)=(St,at)
(22)
(23)
Define
( \
∞
wt0 + 1 =	αnt0 wt
t=t0+10 0
(St,at)=(St,at)
We claim that w0+ι is a (C, (1 + H)w)-SeqUence. We now prove this claim. By lemma 3, for any
t0 ≥ 0,
∞
wt00+1 ≤w	X αjnt0 = (1 + 1/H)w.
j=nt0
2u(s, a) coUld be infinity when (s, a) is visited for infinite nUmber of times.
14
Published as a conference paper at ICLR 2020
By Pij=0 αij = 1, we have Pt0≥1 wt00+1 ≤ Pt≥1 wt ≤ C. This proves the assertion. It follows from
(22) that
X wt+1 (Vt - V*)(st+ι)
t≥1
≤
Xwt+1 (Vt+1 - V*) (St+1) + X w0+ι (Vt - Vt+1)(St+1)
t≥1	t≥1
≤ X wt+1 (Vt+1 - V*) (st+1) + O (WSAH ln C)
t≥1	1 - γ
≤ ^X wt+1 (Qt+1 - Q*) (st+1,at+1) + O --------------ln C
t≥1	1 - γ
(24)
(25)
(26)
(27)
Inequality (25) comes from the update rule of our algorithm. Inequality (26) comes from the
fact that αt = (H + 1)/(H + t) ≤ H/t and Jensen’s Inequality. More specifically, let Cs0,a =
Pt≥1,(st,at=s,a wt0+1, w0 = w(1 + 1/H). Then
Cs0 ,a/w0	H
X w0+1 αnt+1 ≤ XX w0 — ≤ X Hw0 In(Cs,a∕W) ≤ 2SAHw ln C.
t≥1	s,a n=1	s,a
Putting (18), (21) and (27) together, we have,
Ewt(Qt - Q*)(st,at)
t≥1
≤ 2c3PwSAHC≡ + O (wSAH ln C) + Y X wt+1 (Qt+1 -Q*) (st+1,at+1).	(28)
Observe that the third term is another weighted sum with the same form as (17). Therefore, we
can unroll this term repetitively with changing weight sequences.Suppose that our original weight
sequence is also denoted by {wt(0)}t≥1, while {wt(k)}t≥1 denotes the weight sequence after unrolling
for k times. Let w(k) be w ∙ (1 + 1/H)k. Then We can see that {w(k)}t≥1 is a (C, w(k))-sequence.
Suppose that we unroll for H times. Then
^Xwt(Qt- q*)(st, at)
t≥1
≤ 2c3
，w(H)SAHCI(C)
(Γ-^)2
w(H)SAH
+ O( (i-γ)2
lnC
+ IH X w(H) (Qt-Q*) (St, at)
t≥1
≤ 2c3
，w(H)SAHCI(C)
(1-^)2
w(H)SAH
+ O( (i-γ)2
lnC
+γH
C
1 - Y
We set H = ln U/" ≤ ln 1/((I-Y)'1). It follows that W(H) = (1 + 1/H)HW(O) ≤ ew(0), and
ln 1∕γ -	1—γ	、	' I )	一	,
that YH 1Cγ ≤ C61. Also, let '(C) = ∣(C) ln((1 - Y)TE-1). Therefore,
^X wt(Qt- Q*)(st, at) ≤
t≥1
CeI + O(PwSAC'(C) + wSA ln C ln 1
1 - Y ( (1 - Y)2.5	(1 - γ)3	(1 - Y)e1
(29)
□
15
Published as a conference paper at ICLR 2020
C Extension to other settings
First we define a mapping from a finite horizon MDP to an infinite horizon MDP so that our algorithm
can be applied. For an arbitrary finite horizon MDP M = (S, A, H, rh(s, a),ph(s0 | s, a)) where H
is the length of episode, the corresponding infinite horizon MDP M = (S, A, γ, r(s, a),ιp(s0 | s, a))
is defined as,
•	S = S X H, A = A;
•	γ = (1 - 1/H);
•	for a state S at step h, let s$,h be the corresponding state. For any action a and next state
s0, define r(Ss,h,a) = YH-h+1rh(s,a) and p(Ss0,h+ι | Ss,h, a) = ph(s0 | s,h). And for
h = H, set r(Ss,h, a) = 0 andp(%,ι | Ss,h, a) = I[s0 = si] for a fixed starting state si.
Let Vt be the value function in MS at time t and Vk the value function in M at episode k, step h. It
follows that V*(r§i,i) = I-YH%*(sι). And the policy mapping is defined as ∏h(s) = ∏(Ss,h) for
policy πS in MS . Value functions in MDP M and MS are closely related in a sense that, any -optimal
policy πS of MS corresponding to an (/γH)-optimal policy π in M (see section C.1 for proof). Note
that here γH = (1 - 1/H)H = O(1) is a constant.
For any e > 0, by running our algorithm on MM for O(3SAH9) time steps, the starting state si is
visited at least O (3SAH8) times, and at most 1/3 of them are not E-OPtimaL If we select the policy
uniformly randomly from the policy πtH+i for 0 ≤ t < T/H, with probability at least 2/3 we can
get an E-OPtimaI policy. Therefore the PAC sample complexity is O (e-2) after hiding S, A, H terms.
On the other hand, we want to show that for any K episodes,
T/H
Regret(T) = X [V*(s0 - %k(si)] (X T1/2.
k=i
The reason why our algorithm can have a better reduction from regret to PAC is that, after choosing
Ei, it follows from the argument of theorem 1 that for all E2 > O(Ei/(1 - γ)), the number of
E2-suboptimal steps is bounded by
O
(SA ln SA ln1∕δ
I E2(1-Y)7
polylog
with probability 1 - δ. In contrast, delayed Q-learning can only give an upper bound on Ei -suboptimal
steps after setting parameter Ei .
Formally, let Xk = V * (Si) - Vk (Si) be the regret of k-th episode. For any T, set E =，SA/T and
E2 = O(Ei/(1 - γ)). Let M = dlog2 Hi1-))e. It follows that,
M
Regret(T) ≤ Te? + X (Ik : {Xfc ≥c ∙ 2i-i}∣) E ∙ 2i
i=i
〜
≤ O
M
TE2 + X
i=i
SA ln1∕δ
E2 ∙ 2i-2
≤ O (√SAT ln1∕δ)
with probability 1 - δ. Note that the O notation hides the poly (1/(1 - γ), log 1/Ei) which is, by our
reduction, poly (H, log T, log S, log A).
C.1 Connection between value functions
Recall that our MDP mapping from M = (S, A, H, rh (s, a), ph (s0 | s, a)) to MS
(SS, AS, γ, rS(sS, aS), pS(sS0 | sS, aS)) is defined as,
16
Published as a conference paper at ICLR 2020
•	S = S × H, A = A;
•	γ = (1 - 1/H);
•	for a state S at step h, let ss,h be the corresponding state. For any action a and next state SI
define r(Ss,h,a) = γH-h+1rh(s, a) and p(%,h+ι | Ss,h, a) = Ph(s, h). And for h = H,
set r(Ss,h a) = 0 andp(%,ι | ssh, a) = I[s0 = si] for a fixed starting state si.
For a trajectory {(r§i ,i, r，(rs2,2,电)，…} in Mr, let {(si, ai), (s2, a2),…} be the corresponding
trajectory in M. Note that M has a unique fixed starting state si, which means that stH+i = si for
all t ≥ 0. Denote the corresponding policy of πr t as πt (may be non-stationary), then we have
VZ πt (ssι,i) = E [r(rsι,1,r1) + Yr(SS2,2, a2) + …+ YH Tr(SSH-ι,H-1,aH-i) + YH 尸'钟-1 (rsH+ι ,1)]
=YHE [rι(sι,aι) + r2(s2, a2) +--------------+ TH-i(sH-i,aH-1) + Vπt+H (Ssh+i,i)]
= YHV πt(si) +YHVrπt+H(srs1,i).
Then for a stationary policy ∏, We can conclude V元(ss1 ,i) = I-HHVπ(si). Since the optimal policy
∏* is stationary, we have V*(r§i,i) = I-HHV*(si).
By definition, πr is -optimal at time step t means that
t
Vπ (rsι,i) ≥ V*(rsι,i)-e.
It follows that
YHVπt(si) + γHVπt+H(ssι,i) = Vπ(ssι,i) ≥ V*(rsι,i) - e,
hence
YH V πt (si) ≥ (I-YH )V*(rsι,i)+ γH (V *(rsι,i) - Vπt+H (^揖))-e ≥ (1 - γH )V *(rsι,i)-e.
Therefore we have
Vπt(si) ≥ 1-HHV*(rsι,i) - e/YH = V*(si) - e/YH
which means that πt is an (e/Y H)-optimal policy.
D A hard instance for Delayed Q-learning
In this section, we prove Theorem 2 regarding the performance of Delayed Q-learning.
Theorem 2. There exists a family of MDPs with constant S and A, in which with probability
1 一 δ, Delayed Q-learning incurs sample complexity of exploration of Ω (ɪn(ɪ/^)，assuming that
ln(1∕δ) < e-2.
Figure 1: The MDP family. Actions are denoted by arrows. Actions with red color have reward 1,
and reward 0 otherwise.
Proof. For each 0 < e < iθ, consider the following MDP (see also Fig. 1): state space is S =
{a, b, c} while action set is A = {x, y}; transition probabilities are P (b|a, y) = 1 - 10e, P (c|a, y) =
10e, P(b|a, x) = 1, P(a|b, ∙) = P(a|c, ∙) = 1. Rewards are all 1, except R(c, ∙) = 0.
17
Published as a conference paper at ICLR 2020
Assume that Delayed Q-learning is called for this MDP starting from state a, with discount γ > 2
and precision set as . Denote the Q value maintained by the algorithm by Q. Without loss
of generality, assume that the initial tie-breaking favors action y when comparing Q(a, x) and
Q(a, y). In that case, unless Q(a, y) is updated, the agent will always choose y in state a. Since
Q(a, x) - Q(a, y) = 10γ > for any policy, choosing y at state a implies that the timestep is not
-optimal. In other words, sample complexity for exploration is at least the number of times the agent
visits a before the first update of Q(a, y).
In the Delayed Q-learning algorithm, Q(∙, ∙) are initialized to 1/(1 - γ). Therefore, Q(a, y) could
only be updated if max Q(c, ∙) is updated (and becomes smaller than 1/(1 - Y)). According to the
algorithm, this can only happen if C is visited m = Ω C) times.
However, each time the agent visits a, there is less than 10 probability of transiting to c. Let
to = m∕(10eC), where C = 3ln δ + 1. δ is chosen such that C ≤ m. In the first 2to timesteps,
a will be visited t0 times. By Chernoff’s bound, with probability 1 - δ, state c will be visited less
than m times. In that case, Q(a, y) will not be updated in the first 2t0 timesteps. Therefore, with
probability 1 - δ, sample complexity of exploration is at least
to = Ω

When ln(1∕δ) < e-2, it can be seen that C = 3ln δ + 1 < ∣2 <m.
□
18