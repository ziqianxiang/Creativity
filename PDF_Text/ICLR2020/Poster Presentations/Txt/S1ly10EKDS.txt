Published as a conference paper at ICLR 2020
Reanalysis of Variance Reduced Temporal Dif-
ference Learning
Tengyu Xu^, Zhe Wangt, Yi Zhou§, Yingbin Liangt
t Department of ECE, The Ohio State University ,Columbus,OH 43210, USA
§ Department of ECE, The University of Utah, Salt Lake City, UT 84112, USA
xu.3260@osu.edu,wang.10982@osu.edu,yi.zhou@utah.edu,liang.889@osu.edu
Ab stract
Temporal difference (TD) learning is a popular algorithm for policy evaluation in
reinforcement learning, but the vanilla TD can substantially suffer from the inherent
optimization variance. A variance reduced TD (VRTD) algorithm was proposed by
Korda and La (2015), which applies the variance reduction technique directly to
the online TD learning with Markovian samples. In this work, we first point out the
technical errors in the analysis of VRTD in Korda and La (2015), and then provide
a mathematically solid analysis of the non-asymptotic convergence of VRTD and
its variance reduction performance. We show that VRTD is guaranteed to converge
to a neighborhood of the fixed-point solution of TD at a linear convergence rate.
Furthermore, the variance error (for both i.i.d. and Markovian sampling) and the
bias error (for Markovian sampling) of VRTD are significantly reduced by the
batch size of variance reduction in comparison to those of vanilla TD. As a result,
the overall computational complexity of VRTD to attain a given accurate solution
outperforms that of TD under Markov sampling and outperforms that of TD under
i.i.d. sampling for a sufficiently small conditional number.
1	Introduction
In reinforcement learning (RL), policy evaluation aims to obtain the expected long-term reward of a
given policy and plays an important role in identifying the optimal policy that achieves the maximal
cumulative reward over time Bertsekas and Tsitsiklis (1995); Dayan and Watkins (1992); Rummery
and Niranjan (1994). The temporal difference (TD) learning algorithm, originally proposed by Sutton
(1988), is one of the most widely used policy evaluation methods, which uses the Bellman equation to
iteratively bootstrap the estimation process and continually update the value function in an incremental
way. In practice, if the state space is large or infinite, function approximation is often used to find
an approximate value function efficiently. Theoretically, TD with linear function approximation has
been shown to converge to the fixed point solution with i.i.d. samples and Markovian samples in
Sutton (1988); Tsitsiklis and Van Roy (1997). The finite sample analysis of TD has also been studied
in Bhandari et al. (2018); Dalal et al. (2018a); Cai et al. (2019); Srikant and Ying (2019).
Since each iteration of TD uses one or a mini-batch of samples to estimate the mean of the pseudo-
gradient 1, TD learning usually suffers from the inherent variance, which substantially degrades the
convergence accuracy. Although a diminishing stepsize or very small constant stepsize can reduce
the variance Bhandari et al. (2018); Srikant and Ying (2019), they also slow down the convergence
significantly.
Two approaches have been proposed to reduce the variance. The first approach is the so-called batch
TD, which takes a fixed sample set and transforms the empirical mean square projected Bellman
error (MSPBE) into an equivalent convex-concave saddle-point problem Du et al. (2017). Due to the
finite-sample nature of such a problem, stochastic variance reduction techniques for conventional
optimization can be directly applied here to reduce the variance. In particular, Du et al. (2017) showed
that SVRG Johnson and Zhang (2013) and SAGA Defazio et al. (2014) can be applied to improve
1We call the increment in each iteration of TD as "pseudo-gradient" because such a quantity is not a gradient
of any objective function, but the role that it serves in the TD algorithm is analogous to the role of the gradient in
the gradient descent algorithm.
1
Published as a conference paper at ICLR 2020
the performance of batch TD algorithms, and Peng et al. (2019) proposed two variants of SVRG to
further save the computation cost. However, the analysis of batch TD does not take into account the
statistical nature of the training samples, which are generated by a MDP. Hence, there is no guarantee
of such obtained solutions to be close to the fixed point of TD learning.
The second approach is the so-called TD with centering (CTD) algorithm proposed in Korda and
La (2015), which introduces the variance reduction idea to the original TD learning algorithm. For
the sake of better reflecting its major feature, we refer to CTD as Variance Reduced TD (VRTD)
throughout this paper. Similarly to the SVRG in Johnson and Zhang (2013), VRTD has outer and
inner loops. The beginning of each inner-loop (i.e. each epoch) computes a batch of sample pseudo-
gradients so that each subsequent inner loop iteration modifies only one sample pseudo-gradient in
the batch pseudo-gradients to reduce the variance. The main difference between VRTD and batch
TD is that VRTD applies the variance reduction directly to TD learning rather than to a transformed
optimization problem in batch TD. Though Korda and La (2015) empirically verified that VRTD
has better convergence accuracy than vanilla TD learning, some technical errors in the analysis in
Korda and La (2015) have been pointed out in follow up studies Dalal et al. (2018a); Narayanan
and SzePesvdri (2017). Furthermore, as We discuss in Section 3, the technical proof in Korda and
La (2015) regarding the convergence of VRTD also has technical errors so that their results do not
correctly characterize the impact of variance reduction on TD learning. Given the recent surge of
interest in the finite time analysis of the vanilla TD Dalal et al. (2018a); Bhandari et al. (2018); Dalal
et al. (2018b); Srikant and Ying (2019), it becomes imperative to reanalyze the VRTD and accurately
understand Whether and hoW variance reduction can help to improve the convergence accuracy over
vanilla TD. ToWards this end, this paper specifically addresses the folloWing central questions.
•	For i.i.d. sampling, it has been shoWn in Dalal et al. (2018a); Bhandari et al. (2018) that vanilla
TD converges only to a neighborhood of the fixed point for a constant stepsize and suffers from
a constant error term caused by the variance of the stochastic pseudo-gradient at each iteration.
For VRTD, does the variance reduction help to reduce such an error and improve the accuracy of
convergence? HoW does the error depend on the variance reduction parameter, i.e., the batch size
for variance reduction?
•	For Markovian sampling, it has been shoWn in Bhandari et al. (2018) that the convergence of
vanilla TD further suffers from a bias error due to the correlation among samples in addition to the
variance error as in i.i.d. sampling. Does VRTD, Which Was designed to have reduced variance,
also enjoy reduced bias error? If so, hoW does the bias error depend on the batch size for variance
reduction?
•	For both i.i.d. and Markovian sampling, to attain an -accurate solution, What is the overall
computational complexity (the total number of computations of pseudo-gradients) of VRTD, and
does VRTD have a reduced overall computational complexity compared to TD?
1.1	Our Contributions
Our main contributions are summarized in Table 1 and are described as folloWs.
For i.i.d. sampling, We shoW that a slightly modified version of VRTD (for avoiding bias error)
converges linearly to a neighborhood of the fixed point solution for a constant stepsize α, With the
variance error at the order of O(α∕M), where M is the batch size for variance reduction. To attain an
-accurate solution, the overall computational complexity (i.e., the total number of pseudo-gradient
computations) of VRTD outperforms the vanilla TD algorithm Bhandari et al. (2018) if the condition
number is small.
For Markovian sampling, we show that VRTD has the same linear convergence and the same variance
error reduction over the vanilla TD Dalal et al. (2018a); Bhandari et al. (2018) as i.i.d. sampling.
More importantly, the variance reduction in VRTD also attains a substantially reduced bias error at
the order of O(1/M) over the vanilla TD Bhandari et al. (2018), where the bias error is at the order
of O(α). As a result, VRTD outperforms vanilla TD in terms of the total computational complexity
by a factor of log ɪ.
At the technical level, our analysis of bias error for Markovian sampling takes a different path from
how the existing analysis ofTD handles Markovian samples in Bhandari et al. (2018); Wang et al.
(2017); Srikant and Ying (2019). Due to the batch average of stochastic pseudo-gradients adopted by
VRTD to reduce the variance, the correlation among samples in different epochs is eliminated. Such
an analysis explicitly explains why the variance reduction step helps to further reduce the bias error.
2
Published as a conference paper at ICLR 2020
Table 1: Comparison of performance of TD and VRTD algorithms.
I Algorithm		Variance Error	Bias Error	Overall Complexity
i.i.d. sample	TD	O(α)	NA	θ ( J1A log (I))
	VRTD	O(α∕M)	NA	O (maχ{!:4} log(5))
Markovian sample	TD	O(α)	O(α)	O (∣⅜ iog2,(I ))~~
	VRTD	O(α∕M)	O(1∕M)	O (maχ {I, ∣⅜ }log(i))
Note: The results on the performance of TD are due to Bhandari et al. (2018) and the results on the performance of VRTD
(which are highlighted by the red color) are characterized by this work.
1.2	Related Work
On-policy TD learning and variance reduction. On-policy TD learning aims to minimize the
Mean Squared Bellman Error (MSBE) Sutton (1988) when samples are drawn independently from
the stationary distribution of the corresponding MDP. The non-asymptotic convergence under i.i.d.
sampling has been established in Dalal et al. (2018a) for TD with linear function approximation and
for TD with overparameterized neural network approximation Cai et al. (2019). The convergence
of averaged linear SA with constant stepsize has been studied in Lakshminarayanan and Szepesvari
(2018). In the Markovian setting, the non-asymptotic convergence has been studied for on-policy
TD in Bhandari et al. (2018); Karmakar and Bhatnagar (2016); Wang et al. (2019); Srikant and Ying
(2019). Korda and La (2015) proposed a variance reduced CTD algorithm (called VRTD in this
paper), which directly applies variance reduction technique to the TD algorithm. The analysis of
VRTD provided in Korda and La (2015) has technical errors. The aim of this paper is to provide a
technically solid analysis for VRTD to characterize the advantage of variance reduction.
Variance reduced batch TD learning. Batch TD Lange et al. (2012) algorithms are generally
designed for policy evaluation by solving an optimization problem on a fixed dataset. In Du et al.
(2017), the empirical MSPBE is first transformed into a quadratic convex-concave saddle-point
optimization problem and variance reduction methods of SVRG Johnson and Zhang (2013) and
SAGA Defazio et al. (2014) were then incorporated into a primal-dual batch gradient method.
Furthermore, Peng et al. (2019) applied two variants of variance reduction methods to solve the same
saddle point problems, and showed that those two methods can save pseudo-gradient computation
cost.
We note that due to the extensive research in TD learning, we include here only studies that are
highly related to our work, and cannot cover many other interesting topics on TD learning such as
asymptotic convergence of TD learning Tadic (2001); HU and Syed (2019), off-policy TD learning
Sutton et al. (2008; 2009); Liu et al. (2015); Wang et al. (2017); Karmakar and Bhatnagar (2017), two
time-scale TD algorithms XU et al. (2019); Dalal et al. (2018b); YU (2017), fitted TD algorithms Lee
and He (2019), SARSA ZoU et al. (2019) etc. The idea of the variance redUction algorithm proposed
in Korda and La (2015) as well as the analysis techniqUes that we develop in this paper can potentially
be UsefUl for these algorithms.
2	Problem Formulation and Preliminaries
2.1	On-policy Value Function Evaluation
We describe the problem of valUe fUnction evalUation over a Markov decision process (MDP)
(S , A, P, r, γ), where each component is explained in the seqUel. SUppose S ⊂ Rd is a compact
state space, and A is a finite action set. Consider a stationary policy π, which maps a state s ∈ S to
the actions in A via a probability distribution ∏(∙∣s). At time-step t, suppose the process is in some
state St ∈ S, and an action at ∈ A is taken based on the policy ∏(∙∣st). Then the transition kernel
P = P(st+1 |st, at) determines the probability of being at state st+1 ∈ S in the next time-step, and
the reward rt = r(st, at, st+1) is received, which is assumed to be bounded by rmax. We denote the
associated Markov chain by P(Sls) = Pa∈∕p(s0∣s, a)π(a∣s), and assume that it is ergodic. Let μ∏
be the induced stationary distribution, i.e., Ps p(s0∣s)μ∏(s) = μ∏(s'). We define the value function
for a policy π as vπ (S) = E[Pt∞=0 γtr(St, at, St+1)|S0 = S, π], where γ ∈ (0, 1) is the discount
3
Published as a conference paper at ICLR 2020
factor. Define the Bellman operator Tπ for any function ξ(s) as Tπξ(s) := rπ(S) + γEso∣sξ(s0),
where rπ(s) = Ea,s0|sr(s, a, s0) is the expected reward of the Markov chain induced by the policy π.
It is known that vπ(s) is the unique fixed point of the Bellman operator Tπ, i.e., vπ(s) = Tπvπ(s).
In practice, since the MDP is unknown, the value function vπ (s) cannot be directly obtained. The
goal of policy evaluation is to find the value function vπ (s) via sampling the MDP.
2.2	TD Learning with Linear Function Approximation
In order to find the value function efficiently particularly for large or infinite state space S, we
take the standard linear function approximation v(s, θ) = φ(s)>θ of the value function, where
Φ(s)> = [Φι(s),…，Φd(s)] with φi(S) for i = 1, 2,…d denoting the fixed basis feature functions
of state s, and θ ∈ Rd is a parameter vector. Let Φ be the |S| × d feature matrix (with rows indexed
by the state and columns corresponding to components of θ). The linear function approximation can
be written in the vector form as v(θ) = Φθ. Our goal is to find the fixed-point parameter θ* ∈ Rd
that satisfies Eμπv(s, θ*) = EμπTπv(s, θ*). The TD learning algorithm performs the following
fixed-point iterative update to find such θ*.
θt+1 = θt + αtgxt (θt) = θt + αt(Axtθt + bxt),
(1)
where αt > 0 is the stepsize, and Axt and bxt are specified below. For i.i.d. samples generated
from the distribution μ∏, We denote the sample as Xt = (st, rt, st), and Axt = φ(st)(γφ(st)-
φ(St))> and bxt = r(St)φ(St). For Markovian samples generated sequentially from a trajectory,
we denote the sample as xt = (st, rt, st+1), and in this case Axt = φ(st)(γφ(st+1) - φ(st))>
and bxt = r(st)φ(st). We further define the mean pseudo-gradient g(θ) = Aθ + b where A =
Eμπ [Φ(s)(γΦ(s0) -φ(s))>] and b = Eμπ [r(s)φ(s)]. We call g(θ) as pseudo-gradient for convenience
due to its analogous role as in the gradient descent algorithm. It has been shown that the iteration in
eq. (1) converges to the fix point θ* = -A-Ib at a sublinear rate O(1∕t) with diminishing stepsize
αt = O(1/t) using both Markovian and i.i.d. samples Bhandari et al. (2018); Dalal et al. (2018a).
Throughout the paper, we make the following standard assumptions Wang et al. (2017); Korda and
La (2015); Tsitsiklis and Van Roy (1997); Bhandari et al. (2018).
Assumption 1 (Problem solvability). The matrix A is non-singular.
Assumption 2 (Bounded feature). kφ(s)k2 ≤ 1 for all s ∈ S.
Assumption 3 (Geometric ergodicity). The considered MDP is irreducible and aperiodic, and there
exist constants κ > 0 and ρ ∈ (0, 1) such that
supdτv(P(St ∈ ∙∣S0 = s),μ∏(s)) ≤ κρt, ∀t ≥ 0,
s∈S
where dTV(P, Q) denotes the total-variation distance between the probability measures P and Q.
Assumption 1 requires the matrix A to be non-singular so that the optimal parameter θ* = -A-Ib is
well defined. Assumption 2 can be ensured by normalizing the basis functions {φi}id=1. Assumption
3 holds for any time-homogeneous Markov chain with finite state-space and any uniformly ergodic
Markov chains with general state space.
3	The Variance Reduced TD Algorithm
In this section, we first introduce the variance-reduced TD (VRTD) algorithm proposed in Korda and
La (2015) for Markovian sampling and then discuss the technical errors in the analysis of VRTD in
Korda and La (2015).
3.1	VRTD Algorithm Korda and La (2015)
Since the standard TD learning takes only one sample in each update as can be seen in eq. (1), it
typically suffers from a large variance. This motivates the development of the VRTD algorithm in
Korda and La (2015) (named as CTD in Korda and La (2015)). VRTD is formally presented in
Algorithm 2, and we briefly introduce the idea below. The algorithm runs in a nested fashion with
each inner-loop (i.e., each epoch) consists of M updates. At the beginning of the m-th epoch, a
batch of M samples are acquired and a batch pseudo-gradient gm(θm-1) is computed based on these
samples as an estimator of the mean pseudo-gradient. Then, each inner-loop update randomly takes
4
Published as a conference paper at ICLR 2020
Algorithm 1 Variance Reduced TD with iid sam- Algorithm 2 Variance Reduced TD with Marko-
PleS	vian samples Korda and La (2015)
Input: batch size M , learning rate α and initialization
θo
1:	for m = 1, 2, ..., S do
2:	θm,0 = θm-1
3:	Sample a set Bm with M samples indepedently
from the distribution μ∏
4:	gm(θm-1) = -M Pχi∈Bm gxi (θm-1)
5:	for t = 0, 1, ..., M - 1 do
6:	Sample xjm,t indepedently from the distribu-
tion μ∏
7:	θm,t + 1 = θm,t + α(gxjmt (θm,t)
8:	-gxjm,t (θ
m-1 ) + gm (θ
m-1)
9:	end for
10:	set Qm = θmt for randomly chosen t ∈
{1,2,...,M}
11:	end for
Output: θQS
Input: batch size M, learning rate α and initialization
θQ0
1:	for m = 1, 2, ..., S do
2:	θm,0 = θm-1
3:	gm(θm-l) = mM Pm=(m-i)M gxi(θm-l)
4:	for t = 0, 1, ..., M - 1 do
5:	Sample jm,t uniformly at random in {(m -
1)M, ..., mM - 1} from trajetory
6:	θm,t+1 = πRθ (θm,t + α(gxjm,t (θm,t)
7:	-gxjm,t (θQm-1) + gm (θQm-1)
8:	end for
9:	set θQm = θm,t for randomly chosen t ∈
{1, 2,..., M}
10:	end for
Output: θQS
one sample from the batch, and updates the corresponding component in gm(θm-1). Here, ΠRθ in
Algorithm 2 denotes the projection operator onto a norm ball with the radius Rθ . The idea is similar
to the SVRG algorithm proposed in Johnson and Zhang (2013) for conventional optimization. Since
a batch pseudo-gradient is used at each inner-loop update, the variance of the pseudo-gradient is
expected to be reduced.
3.2	Technical Errors in Korda and La (2015)
In this subsection, we point out the technical errors in the analysis of VRTD in Korda and La (2015),
which thus fails to provide the correct variance reduction performance for VRTD.
At the high level, the batch pseudo-gradient gm(θm-1) computed at the beginning of each epoch m
should necessarily introduce a non-vanishing variance error for a fixed stepsize, because it cannot
exactly equal the mean (i.e. population) pseudo-gradient g (θm-1). Furthermore, due to the correlation
among samples, the pseudo-gradient estimator in expectation (with regard to the randomness of
the sample trajectory) does not equal to the mean pseudo-gradient, which should further cause a
non-vanishing bias error in the convergence bound. Unfortunately, the convergence bound in Korda
and La (2015) indicates an exact convergence to the fixed point, which contradicts the aforementioned
general understanding. More specifically, if the batch size M = 1 (with properly chosen λA defined
as λA := 2∣λmaχ(A + A>)|), VRTD reduces to the vanilla TD. However, the exact convergence
result in Theorem 3 in Korda and La (2015) does not agree with that of vanilla TD characterized in
the recent studies Bhandari et al. (2018), which has variance and bias errors.
In Appendix B, we further provide a counter-example to show that one major technical step for
characterizing the convergence bound in Korda and La (2015) does not hold. The goal of this paper
is to provide a rigorous analysis of VRTD to characterize its variance reduction performance.
4	Main Results
As aforementioned, the convergence of VRTD consists of two types of errors: the variance error due
to inexact estimation of the mean pseudo-gradient and the bias error due to Markovian sampling. In
this section, we first focus on the first type of error and study the convergence of VRTD under i.i.d.
sampling. We then study the Markovian case to further analyze the bias. In both cases, we compare
the performance of VRTD to that of the vanilla TD described in eq. (1) to demonstrate its advantage.
5
Published as a conference paper at ICLR 2020
4.1	Convergence Analysis of VRTD with i.i.d. Samples
For i.i.d. samples, it is expected that the bias error due to the time correlation among samples does not
exist. However, if we directly apply VRTD (Algorithm 2) originally designed for Markovian samples,
there would be a bias term due to the correlation between the batch pseudo-gradient estimate and
every inner-loop updates. Thus, we slightly modify Algorithm 2 to Algorithm 1 to avoid the bias
error in the convergence analysis with i.i.d. samples. Namely, at each inner-loop iteration, we draw a
new sample from the stationary distribution μ∏ for the update rather than randomly selecting one
from the batch of samples drawn at the beginning of the epoch as in Algorithm 2. In this way, the new
independent samples avoid the correlation with the batch pseudo-gradient evaluated at the beginning
of the epoch. Hence, Algorithm 1 does not suffer from an extra bias error.
To understand the convergence of Algorithm 1 at the high level, we first note that the sample batch
pseudo-gradient cannot estimate the mean pseudo-gradient g(θm-1) exactly due to its population
nature. Then, we define em(θm) = gm(θm-1) - g(θm-1) as such a pseudo-gradient estimation error,
our analysis (see Appendix D) shows that after each epoch update, we have
E Wm - θ* H2 IFm,0
≤ 1/M + 4α2(1 + γ)2 M _ H2 +	2° F
一αλA — 4α2(1 + γ)2 H m 1 H2 λA — 4α(1 + γ)2
八/2 ʌ
em (θm-1)
IIFm,0
(2)
2
2
where Fm,0 denotes the σ-field that includes all the randomness in sampling and updates before
the m-th epoch. The first term in the right-hand side of eq. (2) captures the contraction property of
Algorithm 1 and the second term corresponds to the variance of the pseudo-gradient estimation error.
It can be seen that due to such an error term, Algorithm 1 is expected to have guaranteed convergence
only to a neighborhood of θ*, when applying eq. (2) iteratively. Our further analysis shows that such
an error term can still be well controlled (to be small) by choosing an appropriate value for the batch
size M, which captures the advantage of the variance reduction. The following theorem precisely
characterizes the non-asymptotic convergence of Algorithm 1.
Theorem 1. Consider the VRTD algorithm in Algorithm 1. Suppose Assumptions 1-3 hold. Set a
constant stepsize α < 8(λAγ)2 and the batch Size M > α思―焉；：)2] ∙ Then, for all m ∈ N,
E
≤ cm ∣∣^0 — θ*∣∣2 +
2D2α
(1 — Cι)(λA — 4α(1 + γ)2)M
(3)
where Ci :=(4a(1 + Y)2 + 4(1+αMa +1)入从一4c1(i+γ)2 (With Ci < 1 due to the choices of a and
M), and D2 = 4((1 + γ)2Rθ2 + rm2 ax).
We note that the convergence rate in eq. (3) can be written in a simpler form as F[∣Bm, — θ*∣∣2] ≤
cml& — θ*∣∣2 + O(α∕M).
Theorem 1 shows that Algorithm 1 converges linearly (under a properly chosen constant stepsize) to
a neighborhood of the fixed point solution, and the size of the neighborhood (i.e., the error term) has
the order of O(M), which can be made as small as possible by properly increasing the batch size M.
This is in contrast to the convergence result of the vanilla TD, which suffers from the constant error
term with order O(α) Bhandari et al. (2018) for a fixed stepsize. Thus, a small stepsize α is required
in vanilla TD to reduce the variance error, which, however, slows down the practical convergence
significantly. In contrast, this is not a problem for VRTD, which can attain a high accuracy solution
while still maintaining fast convergence at a desirable stepsize.
We further note that if we have access to the mean pseudo-gradient g(θm-i) in each epoch m, then
the error term ∣∣θm, — θ*∣∣2 becomes zero, and Algorithm 1 converges linearly to the exact fixed point
solution, as the iteration number m goes to infinity with respect to the conditional number Ci , which
is a positive constant and less than 1. This is similar to the conventional convergence of SVRG for
strongly convex optimization Johnson and Zhang (2013). However, the proof here is very different.
In Johnson and Zhang (2013), the convergence proof relies on the relationship between the gradient
and the value of the objective function, but there is not such an objective function in the TD learning
problem. Thus, the convergence of the parameter θ needs to be developed by exploiting the structure
of the Bellman operator.
6
Published as a conference paper at ICLR 2020
Based on the convergence rate of VRTD characterized in Theorem 1 under i.i.d. sampling, we obtain
the following bound on the overall computational complexity.
Corollary 1. Suppose Assumptions 1-3 hold. Let α = ^(:二丁产,M = dmax{ 3.DCl)ɪ, 33(；+Y) }].
Then, for any e > 0, an E-accuracy solution (i.e., E|Rm — θ* ||2 ≤ E) can be attained with at most
m = dlog 2恤-k2 / log C∙ e iterations. Correspondingly, the total number of pseudo-gradient
computations required by VRTD (i.e., Algorithm 1) under i.i.d. sampling to attain such an E-accuracy
solution is at most
O
Proof. Given the values of α and M in the theorem, it can be easily checked that E|Rm — θ*∣∣2 ≤ E
for m = dlog 2kθ0 - k2 / log Ck ]. Then the total number of pseudo-gradient computations is given
by 2mM that yields the desired order given in the theorem.	□
As a comparison, consider the vanilla TD algorithm studied in Bhandari et al. (2018) with the constant
stepsize α = O(E). If the samples are i.i.d. generated, it can be shown (see Appendix F.1) that the
vanilla TD requires O (等-log (ɪ)) pseudo-gradient computations in total to obtain an E-accuracy
solution. Clearly, VRTD has lower computational complexity than vanilla TD if λA is small. Such a
comparison is similar in nature to the comparison between SVRG Johnson and Zhang (2013) and
SGD in traditional optimization, where SVRG achieves better computational complexity than SGD
for strongly convex objectives if the conditional number of the loss is small.
4.2	Convergence Analysis of VRTD with Makovian Samples
In this section, we study the VRTD algorithm (i.e., Algorithm 2) with Markovian samples, in which
samples are generated from one single MDP path. In such a case, we expect that the convergence of
VRTD to have both the variance error due to the pseudo-gradient estimation (similar to the case with
i.i.d. samples) and the bias error due to the correlation among samples. To understand this at the high
level, We define the bias at each iteration as ξm(θ) = (θ — θ*)>(gm(θ) — g(θ)). Then our analysis
(see Appendix E) shows that after the update of each epoch, we have
≤ 1/M + 3α2(1+ γ)2
一αλA — 3α2(1 + γ)2
以-I -啡 + Xa- 3：：1+ γ)2 E hkgm(θ*)k2km,0i
2	M-1
+ [Xa - 3α(1+ γ)2]M X E [ξm(θm,i)IFm,0]
(4)
The first term on the right-hand side of eq. (4) captures the epochWise contraction property of
Algorithm 2. The second term is due to the variance of the pseudo-gradient estimation, Which
captures how well the batch pseudo-gradient gm(θ*) approximates the mean pseudo-gradient g(θ*)
(note that g(θ*) = 0). Such a variance term can be shown to decay to zero as the batch size gets
large similarly to the i.i.d. case. The third term captures the bias introduced by the correlation among
samples in the m-th epoch. To quantitatively understand this error term, we provide the following
lemma that characterizes how the bias error is controlled by the batch size M .
Lemma 1. For any m > 0 and any θ ∈ Bθ, which is a ball with the radius Rθ, we have
E[ξm(θ)] ≤ λAE[kθ — θ*k2 ∣Fn,o] + 8[1 + (K - 1)ρ] [R2(1 + Y)2 + rmaχ],
4	λA (1 — ρ)M
where the expectation is over the random trajectory, θ is treated as a fixed variable, and0 < C0 < ∞
is a constant depending only on the MDP.
7
Published as a conference paper at ICLR 2020
Lemma 1 shows that the bias error diminishes as the batch size M increases and the algorithm
approaches to the fixed point θ*. To explain Why this happens, the definition of ξm(θ) immediately
yields the following bound:
ξm(θ) ≤ + kgn(θ) — g(θ)k2 + λ4A kθ — θ*∣∣2 .	(5)
The first term on the right-hand-side of eq. (5) can be bounded by the concentration property for the
ergodic process as gm(θ)= 吉 PmMm-II)M gxi(θ) °→→ g(θ). As M increases, the randomness due
to the pseudo-gradient estimation is essentially averaged out due to the variance reduction step in
VRTD, Which implicitly eliminates its correlation from samples in the previous epochs.
As a comparison, the bias error in vanilla TD has been shoWn to be bounded by E[ξn(θ)] =
O(α log(1∕α)) Bhandari et al. (2018). In order to reduce the bias and achieve a high convergence
accuracy, the stepsize α is required to be small, Which causes the algorithm to run very sloWly. The
advantage of VRTD is that the bias can be reduced by choosing a sufficiently large batch size M so
that the stepsize can still be kept at a desirable constant to guarantee fast convergence.
Theorem 2. Consider the VRTD algorithm in Algorithm 2. Suppose Assumptions 1-3 hold. Set the
constant StePSize α < 12(λ+γ)2 and the batch Size M >。5仪工人一1α2(i+γ)2 ∙ Then, we have
E
≤ CmM0-θ*∣∣2 +
3C4α + C2∕λA
(1 — C1)[0.5λA - 3α(1+ γ)2]M
(6)
where Ci = 0 5/MM+一之仪2；++；)2 (With Ci < 1 due to the choices for a and M), C2
16[1+(K一1%成(1+7)2+?\] and c4=[(1 +)出 + 5*产 + ZMGK\pRHrmaX].
We note that the convergence rate in eq. (6) can be written in a simpler form as E[∣∣^m 一 θ* ||2] ≤
cm∣∣θo - θ*∣∣2 + O(1∕M).
Theorem 2 shows that VRTD (i.e., Algorithm 2) with Markovian samples converges to a neighborhood
of θ* at a linear rate, and the size of the neighborhood (i.e., the convergence error) decays sublinearly
with the batch size M . More specifically, the first term in the right-hand side of eq. (6) captures the
linear convergence of the algorithm, the second term corresponds to the sum of the cumulative pseudo-
gradient estimation error and the cumulative bias error. For the fixed stepsize, the total convergence
error is dominated by the sum of those two error terms with the order O(1∕M). Therefore, the
variance reduction in Algorithm 2 reduces both the variance and the bias of the pseudo-gradient
estimator.
Based on the convergence rate of VRTD characterized in Theorem 2 under Markovian sampling, we
obtain the following bound on the corresponding computational complexity.
Corollary 2. Suppose Assumptions 1-3 hold. Let α = 24j+γ)2 and M = d(第一+43 + 100(1 +
Y )2 )max{ ɪ, ∙^2~}]. Then, for any e > 0, an E-accuracy solution (i.e., E∣∣^m — θ*∣∣2 ≤ E) can be
L	2| 历0-θ*k2 , -l r
attained with at most m =「log ——-—— / log C ] iterations. Correspondingly, the total number of
pseudo-gradient computations required by VRTD (i.e., Algorithm 2) under Markovian sampling to
attain such an E-accuracy solution is at most
Proof. Given the values of α and M in the theorem, it can be easily checked that E∣∣^m — θ*∣∣2 ≤ E
2∣Uθ*k2
for m =「log ——--近 / log *].Then the total number of pseudo-gradient computations is given
by 2mM that yields the desired order given in the theorem.	□
As a comparison, consider the vanilla TD algorithm studied in Bhandari et al. (2018) with the constant
stepsize α = O(E/ log(1/E)). Under Markovian sampling, it can be shown (see Appendix F.2) that
(⅛ log2 C))
vanilla TD requires O
pseudo-gradient computations in total to obtain an E-accuracy
8
Published as a conference paper at ICLR 2020
solution. Hence, in the Markovian setting, VRTD outperforms vanilla TD in terms of the total
computational complexity by a factor of log ɪ. To intuitively explain, We first note that the correlation
among data samples in the Markovian case also causes a bias error in addition to the variance error.
For VRTD, due to the variance reduction scheme, the bias and variance errors are kept at the same
level (With respect to the batch size) so that the bias error does not cause order-level increase in
the computational complexity for VRTD. HoWever, for vanilla TD, the bias error dominates the
variance error, Which turns out to require more iterations to attain an -accurate solution, and yields
an additional log ɪ factor in the total complexity compared to VRTD.
5	Experiments
In this section, We provide numerical results to verify our theoretical results. Note that in Appendix
A, We provide further experiments on tWo problems in OpenAI Gym Brockman et al. (2016) and one
experiment to demonstrate that VRTD is more sample-efficient than vanilla TD.
We consider an MDP With γ = 0.95 and |S| = 50. Each transition probability are randomly sampled
from [0,1] and the transitions Were normalized to one. The expected reWard for each transition is
also generated randomly in [0,1] and the reWard on each transition Was sampled Without noise. Each
component of the feature matrix Φ ∈ R50×4
is randomly and uniformly sampled betWeen 0 and 1.
The baseline for comparison is the vanilla TD algorithm, Which corresponds to the case With M = 1
in our figure. We conduct tWo experiments to investigate hoW the batch size M for variance reduction
affects the performance of VRTD With i.i.d. and Markovian samples. In the Markovian setting, We
sample the data from a MDP trajectory. In the i.i.d. setting, We sample the data independently from
the corresponding stationary distribution. In both experiments, We set the constant stepsize to be
α = 0.1 and We run the experiments for five different batch sizes: M = 1, 50, 500, 1000, 2000. Our
results are reported in Figure 1 and 2. All the plots report the square error over 1000 independent runs.
In each case, the left figure illustrates the convergence process over the number of pseudo-gradient
computations and the right figure shoWs the convergence errors averaged over the last 10000 iterations
for different batch size values. It can be seen that in both i.i.d. and Markovian settings, the averaged
error decreases as the batch size increases, Which corroborates both Theorem 1 and Theorem 2. We
also observe that increased batch size substantially reduces the error Without much sloWing doWn the
convergence, demonstrating the desired advantage of variance reduction. Moreover, We observe that
the error of VRTD With i.i.d samples is smaller than that of VRTD With Markovian samples under
all batch size settings, Which indicates that the correlation among Markovian samples introduces
additional errors.
Batch SiZe (M)
(a) left: iteration process; right: averaged convergence error
Figure 1: Error decay of VRTD With i.i.d. sample
6 Conclusion
In this paper, We provided the convergence analysis for VRTD With both i.i.d. and Markovian samples.
We developed a novel technique to bound the bias of the VRTD pseudo-gradient estimator. Our result
demonstrate the advantage of VRTD over vanilla TD on the reduced variance and bias errors by
the batch size. We anticipate that such a variance reduction technique and our analysis tools can be
further applied to other RL algorithms.
9
Published as a conference paper at ICLR 2020
3.5-1--1---1----1-1——
IIIll
1	50	500	1000	2000
Batch SiZe (M)
(a)	left: iteration process; right: averaged convergence error
Figure 2:	Error decay of VRTD with Markovian sample
Acknowledgments
The work was supported in part by US National Science Foundation under the grants CCF-1801855,
ECCS-1818904, and CCF-1909291. The authors would like to thank Bowen Weng at the Ohio State
University for the helpful discussions on the experiments. The authors would also like to thank a few
anonymous reviewers for their suggestions on the analysis of the overall computational complexity
as well as additional experiments, which significantly help to improve the quality of the paper.
References
Bertsekas, D. P. and Tsitsiklis, J. N. (1995). Neuro-dynamic programming: An overview. In
Proceedings of 34th IEEE Conference on Decision and Control, volume 1, pages 560-564.
Bhandari, J., Russo, D., and Singal, R. (2018). A finite time analysis of temporal difference learning
with linear function approximation. In Proc. Conference on Learning Theory (COLT), pages
1691-1692.
Brockman, G., Cheung, V., Pettersson, L., Schneider, J., Schulman, J., Tang, J., and Zaremba, W.
(2016). OpenAI Gym.
Cai, Q., Yang, Z., Lee, J. D., and Wang, Z. (2019). Neural temporal-difference learning converges to
global optima. arXiv preprint arXiv:1905.10027.
Dalal, G., Szorenyi, B., Thoppe, G., and Mannor, S. (2018a). Finite sample analyses for TD (0) with
function approximation. In Proc. AAAI Conference on Artificial Intelligence (AAAI).
Dalal, G., Szorenyi, B., Thoppe, G., and Mannor, S. (2018b). Finite sample analysis of two-timescale
stochastic approximation with applications to reinforcement learning. In Proc. Conference on
Learning Theory (COLT).
Dayan, P. and Watkins, C. (1992). Q-learning. Machine Learning, 8(3):279-292.
Dedecker, J. and Gouezel, S. (2015). Subgaussian concentration inequalities for geometrically ergodic
Markov chains. Electronic Communications in Probability, 20.
Defazio, A., Bach, F., and Lacoste-Julien, S. (2014). SAGA: A fast incremental gradient method
with support for non-strongly convex composite objectives. In Advances in Neural Information
Processing Systems (NIPS), pages 1646-1654.
Du, S. S., Chen, J., Li, L., Xiao, L., and Zhou, D. (2017). Stochastic variance reduction methods
for policy evaluation. In Proceedings of the 34th International Conference on Machine Learning
(ICML), pages 1049-1058.
Hu, B. and Syed, U. A. (2019). Characterizing the exact behaviors of temporal difference learning
algorithms using Markov jump linear system theory. arXiv preprint arXiv:1906.06781.
10
Published as a conference paper at ICLR 2020
Johnson, R. and Zhang, T. (2013). Accelerating stochastic gradient descent using predictive variance
reduction. In Proc. Advances in Neural Information Processing Systems (NIPS), pages 315-323.
Karmakar, P. and Bhatnagar, S. (2016). Dynamics of stochastic approximation with Markov iterate-
dependent noise with the stability of the iterates not ensured. arXiv preprint arXiv:1601.02217.
Karmakar, P. and Bhatnagar, S. (2017). Two time-scale stochastic approximation with controlled
Markov noise and off-policy temporal-difference learning. Mathematics of Operations Research,
43(1):130-151.
Korda, N. and La, P. (2015). On TD (0) with function approximation: Concentration bounds and
a centered variant with exponential convergence. In Proc. International Conference on Machine
Learning (ICML), pages 626-634.
Lakshminarayanan, C. and Szepesvari, C. (2018). Linear stochastic approximation: How far does
constant step-size and iterate averaging go? In International Conference on Artificial Intelligence
and Statistics, pages 1347-1355.
Lange, S., Gabel, T., and Riedmiller, M. (2012). Batch reinforcement learning. In Reinforcement
learning, pages 45-73. Springer.
Lee, D. and He, N. (2019). Target-based temporal difference learning. In International Conference
on Machine Learning (ICML).
Liu, B., Liu, J., Ghavamzadeh, M., Mahadevan, S., and Petrik, M. (2015). Finite-sample analysis
of proximal gradient td algorithms. In Proc. Uncertainty in Artificial Intelligence (UAI), pages
504-513. AUAI Press.
Maei, H. R. (2011). Gradient temporal-difference learning algorithms. PhD thesis, University of
Alberta.
Narayanan, C. and Szepesvdri, C. (2017). Finite time bounds for temporal difference learning with
function approximation: Problems with some “state-of-the-art” results. Technical report.
Peng, Z., Touati, A., Vincent, P., and Precup, D. (2019). SVRG for policy evaluation with fewer
gradient evaluations. arXiv preprint arXiv:1906.03704.
Rummery, G. A. and Niranjan, M. (1994). On-line Q-learning Using Connectionist Systems, vol-
ume 37. University of Cambridge, Department of Engineering Cambridge, England.
Srikant, R. and Ying, L. (2019). Finite-time error bounds for linear stochastic approximation and TD
learning. In Proc. Conference on Learning Theory (COLT).
Sutton, R. S. (1988). Learning to predict by the methods of temporal differences. Machine Learning,
3(1):9-44.
Sutton, R. S., Maei, H. R., Precup, D., Bhatnagar, S., Silver, D., Szepesvdri, C., and Wiewiora,
E. (2009). Fast gradient-descent methods for temporal-difference learning with linear function
approximation. In Proc. International Conference on Machine Learning (ICML), pages 993-1000.
Sutton, R. S., Szepesvdri, C., and Maei, H. R. (2008). A convergent o(n) algorithm for off-policy
temporal-difference learning with linear function approximation. Advances in Neural Information
Processing Systems (NIPS), 21(21):1609-1616.
Tadic, V. (2001). On the convergence of temporal-difference learning with linear function approxima-
tion. Machine Learning, 42(3):241-267.
Tsitsiklis, J. N. and Van Roy, B. (1997). Analysis of temporal-diffference learning with function
approximation. In Proc. Advances in Neural Information Processing Systems (NIPS), pages
1075-1081.
Wang, G., Li, B., and Giannakis, G. B. (2019). A multistep Lyapunov approach for finite-time
analysis of biased stochastic approximation. arXiv preprint arXiv:1909.04299.
11
Published as a conference paper at ICLR 2020
Wang, Y., Chen, W., Liu, Y., Ma, Z.-M., and Liu, T.-Y. (2017). Finite sample analysis of the
GTD policy evaluation algorithms in Markov setting. In Proc. Advances in Neural Information
Processing Systems (NIPS), pages 5504-5513.
Xu, T., Zou, S., and Liang, Y. (2019). Two time-scale off-policy td learning: Non-asymptotic analysis
over markovian samples. In Proc. Advances in Neural Information Processing Systems (NIPS),
pages 10633-10643.
Yu, H. (2017). On convergence of some gradient-based temporal-differences algorithms for off-policy
learning. arXiv preprint arXiv:1712.09652.
Zou, S., Xu, T., and Liang, Y. (2019). Finite-sample analysis for sarsa with linear function approxi-
mation. In Proc. Advances in Neural Information Processing Systems (NIPS), pages 8665-8675.
12
Published as a conference paper at ICLR 2020
Supplementary Materials
A Additional Experiments
In this section, we assess the practical performance of VRTD (Algorithm 2) on two problems in
OpenAI Gym Brockman et al. (2016), which are Frozen Lake (4 × 4) and Mountain Car. We also
provide an additional experiment to demonstrate that VRTD is more sample-efficient than vanilla TD.
A.1 Frozen Lake
Frozen Lake is a game in OpenAI Gym, which is designed by an MDP with a finite state and action
space. An agent starts from the starting point at t = 0 and can only transport to the neighbor blocks.
It returns to the start-point every time it reaches a "hole" or the "goal". The agent receives a reward 1
only when it reaches the goal and 0 otherwise. Each transition probability is randomly sampled from
[0, 1] and normalized to one, and each component of the feature matrix Φ ∈ R16×4 is also randomly
sampled from [0, 1]. Given the feature matrix and the transition probability, the ground truth value of
θ* Can be calculated, which is Used to evaluate the error in the experiments. We set the stepsize to
be α = 0.1 and run vanilla TD (M = 1) and VRTD with the batch sizes M = 50, 500, 1000, 2000.
Note that M = 1 corresponds to the base line vanilla TD. We compute the squared error over 1000
independent runs. The left plot in Figure 3 shows the convergence process over the number of
pseudo-gradient computations and the right plot in Figure 3 shows the convergence error averaged
over the last 10000 iterations. It can be observed that VRTD achieves much smaller error than TD,
and increasing the batch size for VRTD substantially reduces the error without much slowing down
the convergence.
Batch SiZe (M)
(a) left: iteration process; right: averaged convergence error
Figure 3:	Error decay of VRTD in Frozen Lake problem
A.2 Mountain Car
Mountain Car is a game in OpenAI Gym, which is driven by an MDP with an infinite state
space and a finite action space. At each time step, an agent randomly chooses an action
∈ {push left, push right, no push}. In this problem, the ground truth value of θ* is not known.
In order to quantify the performance of VRTD, we apply the error metric known as the norm of
the expected TD update given by NEU= kE[δφ]k22 , where δ is the temporal difference Sutton et al.
(2009); Maei (2011). The state sample is transformed into a feature vector with the dimension 20
using an approximation of a RBF kernel. The agent follows a random policy in our experiment and
we initialize θ0 = 0. At t = 0, the agent starts from the lowest point, receives a reward of -1 at
each time step, and returns to the starting point every time it reaches the goal. We set the stepsize to
be α = 0.2 and run vanilla TD (M = 1) and VRTD with batch size M = 1000. After every 10000
pseudo-gradient computations, learning is paused and the NEU is computed by averaging over 1000
test samples. We conduct 1000 independent runs and the results are reported by averaging over these
13
Published as a conference paper at ICLR 2020
runs. Figure 4 shows the convergence process of the NEU versus the number of pseudo-gradient
computations. It can been seen that VRTD achieves smaller NEU than vanilla TD.
Figure 4: NEU decay of VRTD in Mountain Car problem
A.3 Comparison between VRTD and TD with a Changing Stepsize
In this subsection, we provide an additional experiment to compare the performance of VRTD given in
Algorithm 2 (under constant stepsize) with the TD algorithm (under a changing stepsize as suggested
by the reviewer). We adopt the same setting of Frozen Lake as in Appendix A.1. Let VRTD take
a batch size M = 5000 and stepsize α = 0.1. For a fair comparison, we start TD with the same
constant stepsize α = 0.1 and then reduce the stepsize by half whenever the error stops decrease. The
comparison is reported in Figure 5, where both curves are averaged over 1000 independent runs. The
two algorithms are compared in terms of the squared error versus the total number of pseudo-gradient
computations (equivalently, the total number of samples being used). It can be seen that VRTD
reaches the required accuracy much faster than TD.
Figure 5: Comparison of error decay of VRTD and TD with changing stepsize in Frozen Lake
problem
B A Counter Example
In this section, we use a counter-example to show that one major technical step for characterizing the
convergence bound in Korda and La (2015) does not hold. Consider Step 4 in the proof of Theorem 3
in Korda and La (2015). For the following defined (θ)
e(θ) = (θ - θ*)>[E(v>v|Fn) - Eψ,θn(v>v)](θ - θ*),
(7)
14
Published as a conference paper at ICLR 2020
where Ψ denotes the stationary distribution of the corresponding Markov chain, Korda and La (2015)
claimed that the following inequality holds
k(θ)k2 ≤ 2H kE(v|Fn) - EΨ,θn (v)k2.	(8)
This is not correct. Consider the following counter-example. Let the batch size M = 3 and the
dimension of the feature vector be one, i.e., Φ ∈ RlSl×1. Hence, all variables in eq. (8) and eq. (7) are
scalars. Since the steps for proving eq. (8) in Korda and La (2015) do not have specific requirements
for the transition kernel, eq. (8) should hold for any distribution of v. Thus, suppose v follows the
uniform distribution over [-3, 3]. Further assume that in the n-th epoch, the samples of v are given
by {1,2, -3}. Recall that E(∙∣Fn) is the average over the batch samples in the n-th epoch. We have:
Eψ,θn (V) = 0,	Eψ,θn (v2) = 3,	E(v∣Fn) = 0,	E(v2∣Fn) = ɪ
Substituting the above values into eq. (8) yields
ke(θ)k2 = (134 — 3)(。- θ*)2 ≤ 2H × 0 = 0,	(9)
which obviously does not hold in general when θ = θ*. Consequently the second statement in
Theorem 3 of Korda and La (2015), which is critically based on the above erroneous steps, does not
hold. Hence, the first statement in the same theorem whose proof is based on the second statement
cannot hold either.
C Useful Lemmas
In the rest of the paper, for any matrix W ∈ Rd×d, we denote kW k2 as the spectral norm of W and
kW kF as the Frobenius norm of W .
Lemma 2. For any xi = (si, ri, s0i) (i.i.d. sample) or xi = (si, ri, si+1) (Markovian sample), we
have kAxi k2 ≤ 1 + γ and kbxi k2 ≤ rmax.
Proof. First consider the case when samples are i.i.d. Due to the definition of Axi, we have
kAxi k2 = φ(si)(γφ(s0i) - φ(si))>2
≤ φ(si)(γφ(s0i) - φ(si))>F
≤ γ φ(si)φ(s0i)>F + φ(si)φ(si)>F
≤ 1 + γ.
Then, consider bxi:
kbxi k2 = krxi φ(si)k2 ≤ rmax kφ(si)k2 ≤ rmax.
Following similar steps, we can obtain the same upper bounds for the case with Markovian samples.
□
Lemma 3. Let G = (1 + γ)Rθ + rmax. Consider Algorithm 2. For any m > 0 and 0 ≤ t ≤ M - 1,
we have gxjm,t (θm,t)2 , gxjm,t (θm-1)2 , gm(θm-1)2 ≤ G.
Proof. First, we bound lgxj ,t (θm,t)l2 as follows.
llgxjm,t (θm,t)ll2 = llAxjm,tθm,t + bθm,t ll2
≤ llAxjm,t ll2 kθm,tk2 + llbθm,t ll2
≤ (1 + γ)Rθ + rm
ax.
Following the steps similar to the above, we have Ilgxjm,t(θm-ι)∣L ≤ G. Finally for
l∣gxjm,t (^m-1) Il2,we have
l	l l 1 mM-1
∣lgxjm,t (θmT)l∣2 = ll M X	gxi (θm-1)
l i=(m-1)M
2
15
Published as a conference paper at ICLR 2020
mM-1
≤ M X	Ilgxi(θm-ι)l∣2
i=(m-1)M
≤ G,	(10)
where eq. (10) follows from the last fact ∣∣gxjm,t (θm-1 )∣l2 ≤ G.	□
Lemma 4. Define D1 = 2(1 + γ)2 and D2 = 4((1 + γ)2Rθ2 + rm2 ax). For any θ ∈ Rd, we have
kgxi(θ)k2 ≤ Dl kθ -θ*k2 + D2.
Proof. Recalling the definition of gxi , and applying Lemma 2, we have
kgxi (θ)k22 = kAxiθ + bxi k22
=kAxi(θ -θ*) + (Axiθ*+ bxi)k2
≤ 2 kAxi(θ -θ*)k2 +2 kAxiθ*+ bxik2
≤ 2 kAxi k2 kθ-θ*k2+4(kAxik2 kθ*k2 + kbxik2)
≤ 2(1 + γ)2 kθ - θ*k2 + 4((1 + γ)2Rθ + rLx)
=Di kθ — θ*k2 + D2.
□
Lemma 5. Considering Algorithm 2 with Markovian samples. We have kE[Aj |Pi] - AkF ≤
(1 + γ)κρj-i and kE[bj |Pi] - bk2 ≤ rmaxκρj-i for0 < i < j.
Proof. We first derive
kE[Aj |Pi ] — AkF = / Axi dP (xi∣Pj) — / Axi dμ∏
F
≤ / kAxidP(XiIPj) — Axidμ∏ kF
≤ / kAxikF |dP(XiIPj) — dμ∏I
≤ (I + Y) IIP(XiIPj), μ∏ kTV
≤ (1 + γ)κρj-i.
Following the steps similar to the above, We can derive ∣∣E[bj ∣Pi] 一 b∣b ≤ 2rmaχκρj-i.	□
D Proof of Theorem 1: Convergence of VRTD with i.i.d. samples
Recall that Bm is the sample batch drawn at the beginning of each m-th epoch and Xi,j denotes the
sample picked at the j-th iteration in the i-th epoch in Algorithm 1. We denote σ(θ0) as a trivial
σ-field when 仄 is a deterministic vector. Let σ(A ∪ B) indicate the smallest σ-field that contains
both A and B . Then, we construct a set of σ-fields in the following incremental way.
F1,0 = σ(θ0), F1,1 = σ(F1,0 ∪ σ(B1) ∪ σ(X1,1)), ..., F1,M = σ(F1,(M-1) ∪ σ(X1,M)),
F2,0 = σ(Fι,M ∪ σ(θι)), F21 = σ(F2,0 ∪ σ(B2) ∪ σ(x2,1)),..., F2,m = σ(F2,(M—i)∪ σ(x2,M)),
Fm,0 = σ(F(m-1),M ∪ σ(θm-1 )), Fm1 = σ (Fm,0 ∪ σ (Bm ) ∪ σ(Xm,1 )), ..., Fm,M = σ(Fm,(M -1) ∪ σ(Xm,M )).
The proof of Theorem 1 proceeds along the following steps.
Step 1: Iteration within the m-th epoch
16
Published as a conference paper at ICLR 2020
For the m-th epoch, We consider the last update (i.e., the M-th iteration in the epoch), and decompose
its error into the following form.
kθm,M -叫2
二∣∣θm,M —1 + α
(θm,M-1)-gXjm,M (θm— 1)+ 9m(θm—1
-θ*∣∣2
(gxjm,M
kθm,M —1 - θ*∣∣2 + 2α(θm,M —1 - θ*)> (gXjm)M (θm,MT)- gXjm,M
〜
〜
(θ
m—1 ) + gm(θm-1
+ α2 llgXjm,M (θm,M — 1) - gXjm,M (%―1) + gm(θm.1) ( ∙	(II)
First, consider the third term in the right-hand side of eq. (11), we have
〜
〜
gXm,M (θm,M —1) - gXm,M (^m—1) + 9m(^m—1)
2
2
2
2
〜
〜
〜
〜
V 2
M (θm,MT)- gXjm , M (θm—1)+ 9(θm—1)L +2 ∣∣9m(θm—1)-g(θm.1) ∣ ∣ 2
2
M (θm,M —1) - gXjr
(θm-1) - 9Xjm,M
〜
〜
,m,M (θ*) - [(%jm,M
2
〜
2
2
+ 2 ∣∣gm(θm. 1) - g(θm. 1) L
≤ 4 llgXm,M (θm,MT)- 9Xj.
，m,M C) I 2 +4 || (9Xjm,M (服-1)- 9Xjm,M 一 (.9(葭―1) - 9^))
2
+ 2 ∣∣gm(θm. 1) - g(θm. 1) L ∙
Then, by taking the expectation conditioned on Fm,M—1 on both sides of eq. (12), we have
(12)
E HgXjm,M (θm,M — 1) - gXjm,M (^m—1) + gm (^m—1)^ |Fm,M — 1
≤ 4E ∣∣gXjm,M (θm,MT)- gXjm,M	|Fm,M-1
+ 4E ∣∣(gXjm,M (Om-I)- gXjm,M ( θ * ) ) - E Ej m,M (Om-I)- ^^^ (^)]Fm,M —1I^ |Fm,M —1
+ 2E ∣∣9m(0m. 1 ) - g(Om-1) ( | Fm,M —1
≤ 4(1 + Y)2E[kθm,M —1 - θ* ∣∣2 IFm,M —1] +4(I + γ)2E ^m—1 - θ*	∣Fm,M —1
+ 2E Hgm(Om-1 )- g(Om-1) ( |Fm,M —1
where (i) follows from the fact that E[(gXjm,M (Om—1)- 9Xjm,M (θ*))∣Fm,M —1] = g(°m—1) - g(θ*),
and (ii) follows from the inequality E[(X — EX)2] ≤ EX2 and Lemma 2. Then, taking the
expectation conditioned on Fm,M—1 on both sides of eq. (11) yields
E [∣∣θm,M - θ*∣∣2 IFm,M -1 ]
=llθm,M-1 - θ*∣∣2 + 2α(θm,M-1 - θ*)>E [gXjm,M (θm,MT)- gXjm,M
(θm.1) + gm(θm. 1) |Fm,M —1
+ α2E
gXm,M (θm,MT)- gXm,M (θm-1) + 9m(θm
(i)	2	丁
≤ ∣∣θm,M-1 - θ*∣∣2 +2α(θm,M-1 - θ*) 9(θm,M—1)
+ 2α(θm,M-1 - θ*)> (E [gm(0m-1) |Fm,M-1] - g(0m-1))
+ 4α2(I + Y)2 ∣∣θm,M-1 - θ*∣∣2 + 4a2(l + γ)2
θm.1 - θ* L
〜
〜
〜
〜
〜
〜
〜
2
2
2
]
17
Published as a conference paper at ICLR 2020
+ 2α2E ∣∣gm(^m-1) - g(^m-1)∣l2 |Fm,M-1
≤ ∣∣θm,M-1 - θ* k2 — αλA ∣∣θm,M-1 - θ* ∣∣2 + 2aE ξζm(θm-1) J Fm,M-1
+ 4ɑ2(l + Y)2 ∣∣θm,M-1 - θ*∣2 + 4ɑ2(l + γ)2 Rm-1 — θ*(
+ 2ɑ2E ∣∣gm(θ*m-1) — g(θ*m-1) U2 |Fm,M-1
iii)	C	u	∣ ∣ ~	∣ ∣2
≤ ∣∣θm,M-1	— θ*∣2	— IαλA —	4a(1 + 7)2] ∣θm,M-1	— θ* ∣2 + 4a“l	+ Y产	∣∣θm-1	— θ* (
+ 2αE [ξm(θm-1) IFm,M-1]+ 2a2E Ugm(Bm-1 ) — g(Bm-I) ( | Fm,M-1 ,	(13)
where (i) follows from the fact that E ggxjm m (Bm-I)∣Fm,m-1] = g(Bm-1). In (ii) We define
Λa as the absolute value of the largest eigenvalue of matrix (AT + A), which is negative definite
according to Tsitsiklis and Van Roy (1997). In (iii) we define ξm(θ) = (θ 一 θ*)τ(gm(θ) 一 g(θ))
for θ ∈ Rd. Then, by applying eq. (13) iteratively, we have
E [∣θm,1 — θ*k2∣Fm,0]
M-1	2
≤ ∣∣θm,0 — θ* ∣2 一 [αλA — 4a2(1 + Y)2] ^X E [∣θm,i — θ* ∣2 IFm,°] + 4Mα2(1 + Y)2 ∣Bm-I — θ* (
i=0
+ 2aME [ξm(Bm-I)IFm,0] ÷ 2Mα2E Ugm(Bm-I) - g(Bm-1)H2 |Fm,0 ∙	(14)
For all 1 ≤ i ≤ M, we have
E [ξm(θm-1) ∣ Fm,0] = E [gm (θm-1 ) | Fm,。] 一 g(θm-1 )
1
=M ∕J ElAXi θm ÷ bxJFm,0] -(Aθm ÷ b)
i∈Bm
=[(M∙ Σ E[Aχi∣Fm,0]) - A] Bm ÷ [(MM E E%∣Fm,0]) - b]
i∈Bm	i∈Bm
=0.
Then, arranging terms in eq. (14) and using the above fact yield
M-1
[aλA - 4α2(1 ÷ Y)2] E E b∣θm,i - θ* ∣∣2 IFm,0]
i=0
≤ [1÷4Ma2(1÷ Y)2] UBm-I- θ*∣L ÷ 2Ma2 E Ugm(Bm-I) - g(Bm-I)U ? | Fm,0 ∙	(15)
Finally, dividing eq. (15) by [aλA 一 4α2(1 ÷ Y)2]M on both sides yields
1/M÷4α2(1÷Y)2 ∣∣b -θ≠∣∣2 ,	2a F Γ∣l	(B ∖n(θ )U2|F 一
≤ αλA — 4α2(1÷ Y)2 ∣∣θm-1 — θ ∣∣2 ÷ λA — 4α(1÷ Y)2E [∣∣gm(θmT)- g(θm-I)U?1Fm,0
(16)
Step 2: Bounding the variance error
For any 0 ≤ k ≤ m 一 1, we have
E
2
~
~
gm (θ
m-1)- g(θm-1) ∣ ∣ 2 I Fm,0
(17)
18
Published as a conference paper at ICLR 2020
E I Il M X gXi (θm-1) - g(θθm-1)
i∈Bm
Mp E I Il X gXi (θm-1) - g(θm-1)
Ii∈Bm
X gXi (θm-1) - g(θm-1 )	X gXj (θ
m-1) - g (θm-1 )Fm,0
i∈Bm	j ∈Bm
M2 ^X ^X EhDgXi (θθm-1) - g(θm-1), gXj(京m-1)— g(^m-1) ) [ Fm,θ]
i∈Bm j∈Bm
=M2 X E IIgXi (Bm-I) - g(Bm-I) IL IFm,0
i=j
=M2 X E [ (gXi (Bm-I)- E[gXi (Bm-I)IFm,θ] ( IFm，。]
i=j
≤ M2 XE Ugg(BmT^L ∣Fm,0
i=j
where eq. (18) follows from Lemma 4.
(18)
Step 3: Iteration over m epoches
First, we substitute eq. (18) into eq. (16) to obtain
≤ CIMm-I-HI +7τ4 ；： M ” ,
2	(λA - 4α(1 + γ )2 )M
(19)
where we define C1 =
(4α(1+ Y)2 + 2DɑM+1) λA-4∕1+γ)
Taking the expectation of eq. (19) conditioned on Fm-1,0 and following the steps similar to those in
step 1 to upper bound E 八Bm-I - θ*h ∣Fm-1,0 , we obtain
E IIBm - θ*II2∣Fm-1,0
≤ ClE IIBm-I- θ*IIj∣Fm-1,0
ι	2D2α
+ (λA - 4α(1 + γ)2)M
M E
E
≤ C2 Mm-2 - "I +(λA-4；D2+ γ)2)M X Ck .
Then, by following the above steps for (m - 1) times, we have
m-1
E UBm - θl] ≤ Cm M-HL+ (λA- 4α(12+ γ)2)M X Ck
≤ Cm M-HI2 +(1 - Cl)(λA2D4αα + γ)2)M ,
which yields the desirable result.
E Proof of Theorem 2: Convergence of VRTD with Markovian
SAMPLES
We define σ(Si) to be the σ-field of all samples up to the i-th epoch and recall that jm,t is the index
of the sample picked at the t-th iteration in the m-th epoch in Algorithm 2. Then we define a set of
σ-fields in the following incremental way:
F1,0 = σ(S0), F1,1 = σ(F1,0 ∪ σ(j1,1)), ..., F1,M = σ(F1,(M-1) ∪ σ (j1,M)),
F2,0 = σ(σ(S1) ∪ F1,M ∪ σ(θB1)), F21 = σ(F2,0 ∪ σ(j2,1)), ..., F2,m = σ(F2,(M -1) ∪ σ (j2,M)),
Fm,0 = σ(σ(Sm-1 ) ∪ F(m-1),M ∪ σ(θm-1 )), Fm,1 = σ(Fm,0 ∪ σ(jm,1 )), ..., Fm,M = σ (Fm,(M -1) ∪ σ(jm,M)).
19
Published as a conference paper at ICLR 2020
E.1 Proof of Lemma 1
We first prove Lemma 1, which is useful for step 4 in the main proof in Theorem 2 provided in
Section E.2.
Proof. Recall the definition of the bias term: ξn(θ) = (θ - θ*)τ(gn(θ) - g(θ)). We have
E[ξn(θ)∣Fn,0]
=E [(θ - θ*)τ(gn(θ) - g(θ))∣Fn,0]
nM-1	nM-1
E	(θ	- θ*)τ[ (m X	Axi-A)θ +	(M	X hi -	b)]	Fn,0
i=(n-1)M	i=(n-1)M
λ	1 U 1	nM-1
≤ *["θ-θ*k2∣Fn,0] + λA El卜M i=(X1)M A
xi
—
2
nM-1
X	b≈⅛ - b)
i=(n-1)M
2	-
Fn,0
2
≤ λAE[∣∣θ -θ*∣∣2 ∣Fn,0] + λ∣E
nM-1
(M X	Axi
i=(n-1)M
Fn,0
+梳El]M X	bxi-
A Il	i=(n-1)M
2
≤
(i)
≤
Fn,0
Ax. - A
xi
Ax. - A
xi
Fn,0
Fn,0
(20)
b
—
θ
2
2
2
2
2
F
where (i) follows from the fact that ∣∣ W∣∣2 ≤ IlWIlF for all matrices W ∈ Rd×d. We define the
interproduct between two matices W, V ∈ Rd×d as (W, V)= Pij Pij WijVij. Consider the second
term in eq. (20): E ∣∣ 焉 PnMn-ŋM Axi- AIIFIFn,0] , We have
II 1	nM-1
EIIIM	X	Axi-A
II	i=(n-1)M
2
Fn,0
F
1	nM-1	nM-1
M2 X X	EKAxi- A, Axj- AiIFn,0]
i=(n-1)M j=(n-1)M
击[X E[∣ Axi - AkF IFn,0] + XEKAxi- A, Axj- AiIFn,0]]
i=j	i=j
20
Published as a conference paper at ICLR 2020
≤ 击[XE[(MxJf + MkF)2∣Fn,0] + XEKAxi- A, Axj- A>∣Fn,0]]
i=j	i=j
≤ M2 [4(I + γ)2M + X EKAxi- A, Axj- AiIFn,0]∙]	QI)
i=j
Now consider upper bound the term EKAxi - A, Axj - AiIFn,0] in eq. (21). Without loss of
generality, we consider the case when i > j as follows:
EKAxi- A, Axj- AiIFn,0]
=E[E[(Axi - A,Axj - A〉氏UFn,0]
=E[(E[Axi∣叼]-A,Axj - AiFn,0]
≤ E[∣∣E[Axi∣叼]-AllFllAxj- AllFyn,0]
≤ E[llE[Axi∣叼]-A∣∣f (HAx3llF + kA∣∣F )∣Fn,0]
≤ 2(1+ Y)E[llE[Ax」叼]-AllF∣Fn,0]
≤ 2κ(1 + γ)2ρi-j.
We can further obtain
M-1 k
X EKAxi- A, Axj- Ai∣Fn,0] ≤ 2κ(1 + Y)2 Xp|i-j| ≤ 2κ(1 + γ)2
XXd
M-1
≤ 2K(I + Y)2ɪ- X (1 - Pk)
—P k=1
(22)
Then substituting eq. (22) into eq. (21) yields
nM-1
Axi
i=(n-1)M
-A
Fn,0
≤ MF [4(1 + y)2 +
4(1 + γ)2κρ∙
1 - P
E
2
F
Then consider the third term in eq. (20): E l 吉 PnM-II)M bxi — b^ ∣Fn,0
similarly we have
nM-1
i=(n-1)M
E
—b
2∣
∣Fn,0
2
nM-1	nM-1
M2	X X	E[(bxi - b)τ(bxj-b)∣Fn,0]
i=(n-1)M j=(n-1)M
m2 [X E[kbxi- bk2IFn,0] + X E[(bxi- b)T(bxj- b)1Fn,0]]
i=j	i=j
≤ M2 [X E[(kbxi k2 + /"2)[Fn,0] + X E[(bxi - b)T(bxj - b)[Fn,0]]
i=j	i=j
≤ m2 [4rMaXM + X E[(bxi - b)T(bxj - b)1Fn,。]
i=j
(23)
Now to upper-bound the term E[(bxi - b)τ(bx∙ - b)∣Fn,0], without loss of generality, we assume
i>j
E[(bxi - b)τ(bxj - b)∣Fn,0]
21
Published as a conference paper at ICLR 2020
=e[e[% - b)T(% - b)∖xj] Fn,0]
=E h(E[bxi ∖χj] - b)>(bχj - b) Fn,o]
≤ EjIIE[bXi∖Xj]-b∣∣2 Ilbxj- b^2 IFn,0]
≤ E[∣∣E[bxi∖xj] -b∣∣2 (∣∣bxj∣∣2-∣∣b∣∣2 )∣Fn,0]
≤ 2rmaχEj ∣∣E[bx. ∖xj] - b12 ∣Fn,o]
≤ 2κrmιaxρi-j.
Thus, We have
M-1 k
X E[(bxi - b)>(bxj - b)∖Fn,0] ≤ 2κrmax XPli-jl ≤ 2κ*aχXX PI
i=j	i=j	k = 1 l=1
M-1
≤ 2κrmax^---- X (1 - ρk) ≤
1 - P k=1
4riLax MKP
1 - P
(24)
Combing all of the above pieces together yields the following final bound
E[ξn(θ)∖Fn,0] ≤ λA E[∣∣θ - θ*∣∣2 ∖Fn,0 ]+ ^^ ^^ - ^^ [R^(1 + Y )2 + rmaχ].
4	Aa(1 — P)M
(25)
E.2 PROOF OF THEOREM 2
Step 1: Iteration within the m-th inner loop
For the m-th inner loop, we consider the last update (i.e., the M-th iteration in the epoch), and
decompose its error into the following form.
kθm,M -叫2 = H∏Rθ
(θm,M-I)- gXjm,M
/2
(θm-1
(θm,M-1 + α"jm,M
≤ ∣∣θm,M-1
□
啡
+ Mgxjm,M (θm,M-I)- gXjm,M (Bm-I) + gm(θm-Iy)- θ"(
llθm,M-1 - θ*∣∣2 + 2α(θm,M-1 - θ*)> (gxjm)M (θm,M-I)- gxjm,M
〜
〜
(θm-1) + gm(θm-1
+ a ||gxjm,M (θm,M-I)- gXjm,M (θm-1 ) + gm(θm-1) ( .	(26)
First, consider the third term in the right-hand side of eq. (26).
|gxjm,M (Om,M T)- gxjm,M (^m-1) + gm(^m-1)||2
=||gxjm,M (θm,M-1) - gxjm,M (" ) - [ ^x °m,M (Om-1) - gxjm,M (")) Tgm (Bm- 1 ) - Sm ( ^ ) )] + 5^(^)(
≤ 3 Igxjm,M (θm,M-I)-gxjm,M (θ * ) | ] 2 + 3 ] ] (gx jm,M (Om-I)- ∂xjm,M θ) - (gm(θm-I)- gm(θ*))l2
+ 3 kgm(θ*)k2.	(27)
Then, by taking the expectation conditioned on Fm,(M-1) on both sides of eq. (27), we have
E I∣gxjm,M (Om,M-I)- gxjm,M (θm-1) + gm(θm-1) 11? |Fm,M-1
≤ 3E IIgxjm,M (θm,M-1) -gxjm,M (^)( ।Fm,M-1
+ 3E 卜gxjm,M (OmT)- gxjm,M θ) -E[gxm,M (OmT)- gxjm,M (0)Fm,M-1] ( ।Fm,M-1
22
Published as a conference paper at ICLR 2020
÷ 3E IjIgm(θ*)l∣2 ∣Fm,M-1]
≤ 3E
限m,M (θm,M-1) - gxjm,M (Qi |Fm,M-1
+ 3E I 除 m,M (服-1) -gXm,M (8)( |Fm,M-1
(ii)	r	i-)	ι 1
≤ 3E 卜∣Am,M∣∣2 Ilθm,M-1 - θ*∣∣2 ]Fm,M-1
÷3E b∣gm(θ*)∣2 ∣F1,0]
]÷ 3E IlAm,M k2 II'm-1 - θ* II2 IFm,M-1
(Z) 3(1 ÷ γ)2 ∣θm,M-1 - 叫2 ÷ 3(1 ÷ Y)2 Mm-I- θ* ∣∣ j ÷3E [∣∣gm(θ*)∣∣2 ∣F1,0]
(28)
where (i) follows from the fact that E[(gXjm,M (石m-1) - gxjm,M (θ*))∣Fm,M-1] = gm(θm-1) -
9m(θ*), (ii) follows from the inequality E[(X - EX)2] ≤ EX2, and (iii) follows from Lemma 2.
We further consider the last term in eq. (28):
mM-1	mM-1
(M X Ai)θ* ÷ (M	X	bi)
i=(m-1)M	i=(m-1)M
Then, taking the expectation conditioned on Fm,M-1 on both sides of eq. (26) yields
2
2
E [∣θm,M - ∏2∣Fm,M-1 ]
≤ ∣∣θm,M-1 - θ*∣∣2 ÷ 2α(θm,M-1
- θ")TE gXjm,M (θm,M-I)- gXjm,M (θm-1) ÷ gm(θm-1)
Fm,M-1]
÷ α2E
Hgxjm,M (θm,M-I)- gxjm,M (^m-1) + Om1 ।Fm,M-1
≤ ∣∣θm,M-1 - θ*∣∣2 ÷ 2α(θm,M-1 - θ*)>E [gxjm M (θm,M-1)|Fm,M-1] ÷ 3α2(1 ÷ Y)2 ∣∣θm,M-1 - θ*∣∣2
÷ 3α2(1 ÷ Y)2 Mm-I- “J： ÷ 3α2E [∣∣gm(θ*)∣∣2 ∣F1,0]
J, ∣∣θm,M-1 - θ*∣∣2 ÷ 2α(θm,M-1 - θ")>g(θm,M-1) ÷ 2αE [ξm(θm,M-1) IFm,M-1]
÷ 3α2(1 ÷ Y)2 ∣∣θm,M-1 - θ*∣∣2 ÷ 3α2(1 ÷ Y)2 H0m-1 - θ*IL ÷ 3α2E [∣∣gm(θ*)∣∣2 ∣f1,o]
≤ ∣∣θm,M-1 - θ*∣∣2 - [αλA - 3α2(1 ÷ Y)2] ∣θm,M-1 - θ*∣∣2 ÷ 3α2(1 ÷ Y)2 H0m-1 - θ*]
÷ 2αE [ξm(θm,M-1)∣Fm,M-1] ÷ 3a2E [∣gm(θ*)∣2 ∣F1,0] ,	(29)
where (i) follows by plugging eq. (28) into its preceding step and from the fact that
E [gxjm,M (媒-1)- gm(0m-1)∣Frn,M-1] = 0. In (ii) wedefineξm(θ) = (θ-θ*)τ(gm(θ) -g(θ))
for θ ∈ Rd. Then, by applying eq. (29) iteratively, We have
E [∣∣θm,1-θ*∣∣2∣Fm,0]
M-1	2
≤ I∣θm,0 - θ* ∣∣2 - [αλA - 3α2(1 ÷ Y)2] ^X E [∣∣θm,i - θ* ∣∣2 IFm,0] ÷ 3Ma2(1 ÷ Y)2 H0m-1 - θ* (
i=0	2
M-1
÷ 2α X E [ξm(θm,i) IFm,0] ÷ 3Ma2E [∣∣9m(θ*) ∣∣2 IF1,。] .	(30)
i=0
Arranging the terms in eq. (30) yields
M-1
[αλA - 3α2(1 ÷ Y)2] X E [∣∣θm,i - θ*∣∣2 ∣ Fm,0]
i=0
23
Published as a conference paper at ICLR 2020
2	M-1
≤ [1 + 3Ma2(1 + γ)2] Mm-I- θ*∣∣ +2a E E [ξm(θm,i)∣Fm,0] + 3Mα2E 卜|即(®*)k2 ∣F1,0] ∙
2	i=0
(31)
Then, substituting eq. (25) into eq. (31), We obtain
M-1
[αλA - 3α2(l + Y)2] ^X E [kθm,i - θ*k2 I Fm,0^|
i=0
2	ʌ M-1
≤ [1 + 3Mα2(l + Y)2] Mm-I- θ* Il +---2- ^X E b∣θm,i - θ*∣∣2 IFm,0]
2	i=0
+ 16[；+:K- 1)p]a [R2(1 + γ)2 + rLχ] + 3Mo2E [k9m(θ*)k2 ∣F1,0i ∙
λA(1 - P)	LI」
Subtracting 0.5λaα PM-I E[∣∣θm,i - θ*∣∣2 IFm,0] on both sides of eq. (32) yields
M-1
[0.5αλa - 3α2(1 + γ)2] X E b∣θm,i-叫2∣Fm,0]
i=0
≤ [1 + 3Mα2(1 + Y)2] Mm-1 - θ* ∣∣2 + 16[1； (K- 1)P]a [R2(1 + Y)2 + Eax：
Il	l∣2	Λa(1 — ρ)
+ 3Ma2E Ugm(θ*)∣∣2 ∣F1,0] ∙
(32)
(33)

Then, dividing eq. (31) by [0.5ɑλa - 3α2(1 + Y)2]M on both sides, we obtain
E Mm - θ*Il2∣Fm,0]
≤ 1/M + 3ɑ2(I + Y)2 11 万	* 112 + 16[1 + (K - I)PnR2(I + Y)2 + Max]。
—0.5αλa — 3α2(1 + Y)2 Il m 1 l∣2 λa(1 — ρ)[0∙5αλa — 3α2(1 + y)2]M
+ 0.3：(1+ Y)2 E Wm(θ*)k2∣F1,0]∙	(34)
For SimPIicity, let CI = 0.5/M+3α0⅜t⅞2, C2
0.5λA-3α(1+γ)2 .Then we rewrite eq.(34):
16[1+(κ-1)ρ][Rθ(1+γ)2+r21aχ] and CQ
1 一 P	3
E ]底-θ*∣∣2 km,0] ≤ CI Mm-I- θ*ll2 + [0∙5λA- 30C2 + Y)2]λAM + C3E Wm(θ*)k2 ∣Fd
(35)
Step 2: Iteration over m epochs
Taking the expectation of eq. (35) conditioned on Fm_1,0 and upper-bounding E Mm-I - θ*∣∣
by following similar steps in the previous steps, we obtained
E ""m - θ* H2 ∣Fm-1,0
≤ CI	Mm-i*H2 +	[0∙5λA- 30C2 + Y)2]λAM + C3E	IF
≤ C2	Mm-2 - θ* H： +	[0∙5λA- 30C2 + Y)2]λAM X Ck + C3 X CkE	hkgm-k ®)k2	IFK。]	∙
By following the above steps for (m - 1) times, we have
E [∣Mm -θ*∣∣2∣F1,0
24
Published as a conference paper at ICLR 2020
2	m-1	m-1
≤ Cm M - θl + [0.5λA- 3α(l2 + γ)2]λAM X Ck +C3 X CkE hkgm-kSk2 回0i .
(36)
Then taking the expectation of σ(S) (which contains the randomness of the entire sample trajectory)
on both sides of eq. (36) yields
E Wm -啡
2	m-1	m-1
≤ Cm M- θ1L + [0.5λA- 3a(： + γ)2]λAM X Ck + C3 X CkE hkgm-kC)k2i，
k=0	k=0
(37)
where the second term in the right hand side of eq. (37) corresponds to the bias error and the third
term corresponds to the variance error.
Step 3: Bounding the variance error
For any 0 ≤ k ≤ m - 1, we have
(m-k)M -1
kgm-k (θ* )k2 =1 M X	gχ1θ*)
i=(m-k-1)M	2
(m-k)M -1	(m-k)M -1
=M ( X	g>i (θ*))(	X	gxj (θ*))
i=(m-k-1)M	j=(m-k-1)M
(m-k)M -1	(m-k)M -1
=M X	X	gXi (θ*)gχj (θ*)
i=(m-k-1)M j=(m-k-1)M
=M2 X kgXi (θ*)k2 + M2 X gXi (θ*)gXj (θ*)
i=j	i6=j
(i) G2	1
≤ M + M2 X gXi (θ*)gXj (θ*)	(38)
i6=j
where (i) follows from Lemma 3. Consider the expectation of the second term in eq. (38), which is
given by
M2 XE 以(θ*)gχj (θ*)].	(39)
i	6=j
Without loss of generality, we consider the case when j > i as follows:
E[gXi (θ*)gχj (θ*)] = E[E[gχj (θ*)∣Pi]>gχi (θ*)]
≤	E[∣∣E[gχj (θ*)∣Pi]∣∣2 kgXi (θ*)k2]
≤	GE[∣∣E[gχj(θ*)间∣2]
=GE[kE[(Aj θ* + bj )因也]
≤	GE[kE[Aj∣Pi]θ* + E[bj|Pi]k2]
=	GE[k(E[Aj|Pi] - A)θ* + (E[bj|Pi] - b)k2]
≤	GE[k(E[Aj|Pi] - A)θ*k2 + kE[bj|Pi] - bk2]
≤	GE[kE[Aj∣Pi] - Ak2 kθ*k2 + kE[bj∣Pi] - bk2]
≤	κG[(1 + γ)Rθ + rmax]ρj -i.	(40)
Substituting eq. (40) into eq. (39), we obtain
击 X E[g>i aXj (θ*)] ≤ κG[(1+MRθ+rmax] X Pf
i6=j	i6=j
25
Published as a conference paper at ICLR 2020
≤
κG[(1 + Y )Rθ + rmax]
M2
d萼]
(2M X ρk)
k=1
2ρκG[(1 + γ)Rθ + rmax]
(1 - P)M
(41)
Then substituting eq. (41) into eq. (38) yields
E[kgm-k(θ*)k2] ≤ M(G2 + 2ρκG[(1 + -)R)θ+ rmax]) ≤ C4,	(42)
where C4 = G2 + 2pKG[(1+Y)Rθ+rmax]
variance term in eq. (37), we have
. Finally, substituting eq. (42) into the accumulated residual
m-1	m-1
C3 X CkE [kgm-k(θ*)k2i ≤ C3M4 X Ck ≤
k=0	k=0
C3C4
(1 - Cι)M
(43)
Step 4: Combining all error terms
Finally, substituting eq. (43) and substituting the values of C2 and C3 into eq. (37), we have
E
≤ CmMo-θ*∣∣2 +
3C4α + C2∕λA
(1 - C1)[0.5λA - 3α(1+ γ)2]M
which yields the desired result.
F	Sample Complexity of TD
The finite-time convergence rate of vanilla TD under i.i.d. and Markovian sampling has been
characterized in Bhandari et al. (2018); Srikant and Ying (2019). However, these studies did not
provide the overall computational complexity, i.e., the total number of pseudo-gradient computations
to achieve an -accuracy solution. This section provides such an analysis based on their convergence
results for completeness.
F.1 TD with i.i.d. samples
Consider the vanilla TD update in Bhandari et al. (2018). Following the steps similar to those in Bhan-
dari et al. (2018) for proving Theorem 2, and letting the constant stepsize α ≤ min{ 4(3)2,看},
we have
Ekθt-θ*k2 ≤ (1 - 2λAα)t kθ0-θ*k2 + 2C5α
≤ e-2λAαt kθo-θ*k2 + 2C5α,
where 0 < C5 < ∞ is a constant. Let ɑ = min{4(工产,看,ICA}. It Can be checked easily that
with the total number of iterations at most
t = d^log(2>-⅛ )e = d2max{『,1,器}log(⅛^)]
λAα	λA	λA
(44)
an e-accurate solution can be attained, i.e., E ∣∣θt 一 θ*∣∣2 ≤ e. Since each iteration requires one
pseudo-gradient computation, the total number of pseudo-gradient computations is also given by
eq. (44).
26
Published as a conference paper at ICLR 2020
F.2 TD with Markovian samples
Consider the vanilla TD update in Bhandari et al. (2018). Following the steps similar to those in
Bhandari et al. (2018) for proving Theorem 3, and letting the constant stepsize α ≤ =, we have
Ekθt - θ*k2 ≤ (1 - λAα)t kθo - θ*k2 + C6α + C7α；og( 1)
λA	λA
≤ €-羽。力 kθo - θ*∣∣2 + 粤 + C7αlog(1)
λA	λA
where 0 < C6 < ∞ and 0 < C7 < ∞ are constants. Now let a = min{加"工祠,λ⅛} where
C8 = λA min{卷,6cφ }, it can be checked easily that with the total number of iterations at most
t = d^iog(3Jfc⅛ )e
λAα
=dmax{ . 1 1212 ,2} log (ɪ) ιog(3 kθ0 - θ k2 )e
min{C, 6C7}λAe	'CgeJ	e
= O(( e⅛)log2( e))，	(45)
an e-accurate solution can be attained, i.e., E ∣∣θt - θ*∣∣2 ≤ e. Since each iteration requires one
pseudo-gradient computation, the total number of pseudo-gradient computations is also given by
eq. (45).
27