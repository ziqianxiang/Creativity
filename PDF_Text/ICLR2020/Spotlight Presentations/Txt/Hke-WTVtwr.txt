Published as a conference paper at ICLR 2020
Encoding word order in complex embeddings
Benyou Wang * University of Padua wang@dei.unipd.it	Donghao Zhao * Tianjin University zhaodh@tju.edu.cn	Christina Lioma University of Copenhagen chrh@di.ku.dk
Qiuchi Li	Peng Zhang t	Jakob Grue Simonsen
University of Padua	Tianjin University	University of Copenhagen
qiuchili@dei.unipd.it	pzhang@tju.edu.cn	simonsen@di.ku.dk
Ab stract
Sequential word order is important when processing text. Currently, neural net-
works (NNs) address this by modeling word position using position embeddings.
The problem is that position embeddings capture the position of individual words,
but not the ordered relationship (e.g., adjacency or precedence) between individ-
ual word positions. We present a novel and principled solution for modeling both
the global absolute positions of words and their order relationships. Our solu-
tion generalizes word embeddings, previously defined as independent vectors, to
continuous word functions over a variable (position). The benefit of continuous
functions over variable positions is that word representations shift smoothly with
increasing positions. Hence, word representations in different positions can cor-
relate with each other in a continuous function. The general solution of these
functions is extended to complex-valued domain due to richer representations.
We extend CNN, RNN and Transformer NNs to complex-valued versions to in-
corporate our complex embedding (we make all code available). Experiments * 1
on text classification, machine translation and language modeling show gains over
both classical word embeddings and position-enriched word embeddings. To our
knowledge, this is the first work in NLP to link imaginary numbers in complex-
valued representations to concrete meanings (i.e., word order).
1 Introduction
When processing text, the sequential structure of language is important, but can be computationally
costly to model with neural networks (NNs) (Socher et al., 2011) due to the difficulty in paralleliza-
tion. This has been alleviated by modeling word sequence not on the NN architecture level, but
by adding position embeddings on the feature level. This has been done by the convolutional se-
quence model (ConvSeq) (Gehring et al., 2017) and the Transformer model (Vaswani et al., 2017)
that replaces recurrent and convolution operations with purely attention mechanisms. More gener-
ally, vanilla position embeddings (Gehring et al., 2017) assume that individual word positions are
independent and do not consider relations between neighbouring word positions. We posit that both
the global absolute positions of words and their inner sequential and adjacent relationships are cru-
cial in language. This is supported by recent empirical findings by Shaw et al. (2018) and Dai et al.
(2019) who show the importance of modeling distance between sequential elements, and explicitly
use extra relative position encodings to capture the relative-distance relationship of words.
We present a novel and principled approach to model both the global absolute positions of words
and their inner sequential and adjacent relationships as follows: we extend each word embedding,
previously defined as an independent vector, as a continuous function over an independent variable
i.e., position. The benefit of continuous functions over variable positions is that word represen-
tations shift smoothly with increasing positions. Hence, word representations in different positions
* First two authors contributed equally.
,Corresponding author: pzhang@tju.edu.cn
1The code is on https://github.com/iclr-complex-order/complex-order
1
Published as a conference paper at ICLR 2020
Figure 1: 3-dimensional complex embedding for
a single word in different positions. The three
wave functions (setting the initial phases as zero)
show the real part of the embedding; the imagi-
nary part has a 2 phase difference and shows the
same curves with its real-valued counterpart. The
x-axis denotes the absolute position of a word and
the y-axis denotes the value of each element in its
word vector. Colours mark different dimensions
of the embedding. The three cross points between
the functions and each vertical line (correspond-
ing to a specific position Pos) represent the em-
bedding for this word in the pos-th position.
can correlate with each other in a continuous function. Fig. 1 illustrates this type of word representa-
tion with a three-dimensional complex-valued embedding, where the amplitudes {r1,r2,r3} denote
semantic aspects corresponding to classical word vectors, and periods {p1,p2,p3} denote how sen-
sitive the word is to positional information. We further discuss the necessary properties of these
functions to model sequential information and obtain a general solution in the form of a complex-
valued embedding. Interestingly, there is a direct connection between a specific case of our general
embedding and the well-known positional encoding in Vaswani et al. (2017) (see App. A).
We contribute (i) a novel paradigm that extends word vectors as continuous functions over chang-
ing variables like word position, and (ii) a general word embedding that models word order in
a mathematically-sound manner. We integrate our complex word embeddings in state-of-the-art
(SOTA) NN architectures (CNN, RNN, Transformer and experimentally find that it yields gains
over both classical word embeddings and position-enriched word embeddings in text classification,
machine translation and language modeling. Note that this is the first work in NLP to link imaginary
numbers in complex-valued representation to concrete meanings (i.e., word order).
2	Modelling Word Order in Embedding Space
A Word Embedding (WE) generally defines a map fwe : N → RD from a discrete word index to
a D-dimensional real-valued vector and N = {0, 1, 2, . . .}. Similarly, a Position Embedding (PE)
(Gehring et al., 2017; Vaswani et al., 2017) defines another map fpe : N → RD from a discrete
position index to a vector. The final embedding for word wj (wj ∈ W with index j in a given
vocabulary W) in the pos-th position in a sentence is usually constructed by the sum
f (j, pos) = fwe(j) + fpe(pos),	(1)
and f (j, pos) ∈ RD . Since both the word embedding map fw and the position embedding map
fp only take integer values as word indexes or position indexes, embedding vectors for individ-
ual words or positions are trained independently. The independent training for each word vector
is reasonable, since a word index is based on the order of a given arbitrary vocabulary and does
not capture any specific sequential relationship with its neighboring words. However, the position
index captures an ordered relationship, for instance adjacency or precedence, leading to the prob-
lem that position embeddings in individual positions (Gehring et al., 2017) are independent of each
other; the ordered relationship between positions is not modelled. We refer to this as the position
independence problem. This problem becomes more crucial when position embeddings are used in
position-insensitive NNs, e.g., FastText (Mikolov et al., 2013b), ConvSeq (Gehring et al., 2017) and
Transformer (Vaswani et al., 2017), because it is hard for such position-insensitive NNs with vanilla
position embeddings (Gehring et al., 2017) to infer that wj1 in the pos-th position is close to wj2
in the pos + 1-th position, or that wj1 precedes wj2 ; instead, it is only inferred that wj1 and wj2
are in different positions, while the relative distance between them is almost unknown. Thus vanilla
position embeddings (Gehring et al., 2017) cannot fully capture the sequential aspect of language.
Next, we first introduce the necessary properties to model word order in embeddings, and then give
a unique solution to meet such properties.
2
Published as a conference paper at ICLR 2020
2.1	Extending vectors to functions
In the general definition in Eq. 1, each dimension of the position embedding is obtained based
on the discrete position indexes {0, 1, 2, ..., pos, ...}. This makes it difficult to model the ordered
relationship between the positions. One solution to this problem is to build continuous functions over
a variable (i.e., position index) to represent a specific word in an individual dimension. Formally,
we define a general embedding as
f (j, pos) = gj (pos) ∈ RD ,	(2)
where gj is short for gwe(j) ∈ (F)D, indicating D functions over position index pos, and gwe(∙):
N → (F)D is a mapping from a word index to D functions. By expanding the D dimension ofgj,
a word wj in the pos-th position can be represented as a D-dimensional vector as shown in
[gj,1(pos),gj,2(pos), ...,gj,D(pos)] ∈ RD,	(3)
in which ∀gj,d(∙) ∈ F : N → R,d ∈ {1, 2,…，D} is a function over the position indexpos. To move
the word wj from the current position pos to another onepos0, it needs only replace the variable pos
to pos0 without changing gj .
Functions for words, especially continuous functions, are expected to capture smooth transformation
from a position to its adjacent position therefore modeling word order. The position-independent
position embedding (Gehring et al., 2017) can be considered as a special case of our definition when
it only takes independent values for individual positions in the embedding function.
2.2	Properties for the Functions to capture word order
Relative distance is hard to compute because position indices are not visible in NNs after vector
embedding (discrete position indices are necessarily embedded as vectors like words to be back-
propagated with the gradient). Hence, we claim that the modeling of relative distance in NNs should
be position-free: absolute position indices cannot be directly accessed in intermediate layers. Instead
of processing position-free operations in NNs to capture relative distance between words, prior work
(Shaw et al., 2018; Dai et al., 2019) first calculates the relative distance between words, and then
feeds the relative distance as an additional feature or as embeddings/weights to NNs, instead of
directly feeding with the raw position indices.
Assume that words are embedded into RD, and let, for 1 ≤ d ≤ D, the function gj,d : N → R be the
embedding function giving the d-th coordinate of the representation of word wj (i.e., gj,d(pos) is the
d-th coordinate of the embedding ofwj if it occurs at position pos. In the following, we simply write
g instead of gj,d when there is no risk of confusion. Ideally, one would like there to exist a function
Transformn : R → R that transforms the embedding of any word at some position pos to the
embedding of a word at position pos + n such that Transformn is only dependent on the embedded
value itself, but independent of the position pos, that is ∀pos : g(pos + n) = Transformn (g(pos)).
Prior work in NLP (Li et al., 2019), Information Retrieval (Van Rijsbergen, 2004) and Machine
Learning (Trabelsi et al., 2017) has shown the usefulness of complex numbers as richer representa-
tions. Complex word embeddings (Wang et al., 2019; Li et al., 2019; Li et al., 2018) have been used
to model language. To investigate the potential of complex-valued representation, we extend the
target domains of g(∙) from RD to CD without losing generality, since real-valued numbers are spe-
cific complex numbers with their imaginary part being zero. This property regarding “position-free
offset transformation” in complex-valued domains is formally defined in Property 1 below.
Property 1. Position-free offset transformation: An embedding function g : N → C is said to
be a position-free offset transformation if there exists a function Transform : N X C → C (called
the witness) such that for all n ≥ 1, the function Transformn (∙) = TranSform(n, ∙) satisfies ∀pos ∈
N : g(pos + n) = Transformn (g(pos)). A position-free offset transformation g is said to be linearly
witnessed if there is a function w : N → C such that g has a witness Transform satisfying, for all n,
Transform(n, pos) = Transformn(pos) = w(n) (i.e., each Transformn is a linear function).
Additionally, a boundedness property is necessary to ensure that the position embedding can deal
with text of any length (pos could be large in a long document).
Property 2. Boundedness: The function over the variable position should be bounded, i.e. ∃δ ∈
R+,∀pos ∈ N, ∣g(pos)∣ ≤ δ.
3
Published as a conference paper at ICLR 2020
Formally, we prove the following claim that there is a unique solution that meets Properties 1 and
2 under the condition that the embedding function is linearly witnessed. We use linear functions
because they are well-understood and simple with a single floating-point operation in NNs.
Claim 1. A function g : N → C is a bounded and linearly witnessed position-free offset transfor-
mation iff it is on the form g(pos) = z2 z1pos for z1, z2 ∈ C with |z1 | ≤ 1.
Proof. Assume that g is a bounded and linearly witnessed position-free offset transformation. Then,
by linear witnessing, we have for all pos, n1, n2 ∈ N:
w(n1)w(n2)g(pos) = w(n2)g(pos + n1) = g(pos + n1 + n2)
= Transformn1+n2 (g(pos)) = w(n1 + n2)g(pos)
whence w(n1 +n2) = w(n1)w(n2). Write w(1) = z1 andg(0) = z2. As n1, n2 ∈ N were arbitrary,
we have w(n) = (w(1))n = z1n for all n ∈ N. But then g(pos + n) = w(n)g(pos) = z1ng(pos).
Furthermore, observe that for pos ≥ 1, we have g(pos) = g(1 +pos - 1) = w(pos)g(0) = z1posz2 =
z2z1pos. For pos = 0, g(0) = z2 = z2z10, whence g(pos) = z2z1pos, as desired. Observe that if
|z1| > 1, then g(pos) is unbounded, whence we have |z1 | ≤ 1. Conversely, assume that g is on
the form g(pos) = z2z1pos with |z1 | ≤ 1. Then, |g(pos)| ≤ |z2z1pos| ≤ |z2||z1pos| ≤ |z2|, whence g
is bounded. Define, for each n ∈ N, w(n) = z1n and Transformn(pos) = w(n)pos. Then, for all
pos, n ∈ N,
g(pos + n) = z2z1pos+n = z2z1posz1n = g(pos)z1n = Transformn(g(pos))
showing that g is a linearly witnessed position-free offset transformation.	□
For any z ∈ C, we may write z = reiθ = r(cos θ + i sin θ). Thus, for the general form of the
embedding g from Theorem 1, we have:
g(pos) = z2z1pos =r2eiθ2(r1eiθ1)pos = r2r1posei(θ2+θ1pos) subject to |r1| ≤ 1	(4)
In implementations, the above definition of g will lead to an optimization problem due to the con-
straint |r1 | ≤ 1. A natural and simple way to avoid this is to fix r1 = 1; note that |eix| ≡ 1, thus
automatically satisfying the constraint, in contrast to a real-valued embedding where one would need
to explicitly devise functions satisfying the constraint. Finally, Eq. 4 can be written in the simplified
form: g(pos) = rei(ωpos+θ). Thus, one can think of g as embedding positions counterclockwise on
a complex circle of radius r with a fixed period (r is the amplitude term, θ is the initial phase term,
2∏ is the frequency, and 2∏ is the period term).
2.3	Complex-valued word Embedding
We now define our complex-valued word embedding g as a map taking a word index j and position
word index pos to CD . For a word wj in position pos, our general complex-valued embedding is
defined as f(j, pos) = gj(pos) = rj ei(ωj pos+θj). Therefore, f(j, pos) is defined as:
[r. ιei(ωj,ιPos+θj,ι),…,rj 2eiQj,2Pos+θj,2), ∙∙∙ ,rj Dei(ωj,DPos+θj,D)]
(5)
Note that each coordinate d (1 ≤ d ≤ D) has a separate amplitude rj,d, period pj,d = ω∏, and ini-
tial phase θj,d. In Fig. 1 each dimension is represented as a wave which is parameterized by an am-
plitude, a period/frequency, and an initial phase. The trainable parameters of the embedding are the
amplitudes vector rj = [rj,1, ..., rj,D], the period/frequency related weights ωj = [ωj,1, ..., ωj,D],
and the initial phase vector θj = [θj,ι,…，θj,D]. Note that the mean values of f (j, ∙) over all posi-
tions are linearly dependent on the amplitude. Observe that the period/frequency determines to what
degree the word is sensitive to the position. With an extremely long period (i.e., ωj very small),
the complex-valued embedding is approximately constant for all possible values of pos, and hence
approximates a standard word embedding. Conversely, if the period is short, the embedding will be
highly sensitive to the position argument.
In our embedding, the mean vectors of f (j, ∙) taken over all positions are linearly correlated to the
amplitude embedding rj- = [r j, 1,…,r j,K] with a coefficient ∏. The amplitude rj,d of our embedding
depends only on the word wj (and coordinate d), not on the position of the word, whence one can
4
Published as a conference paper at ICLR 2020
Dataset	train	test	vocab.	task	Classes
CR (Hu & Liu, 2014)	^4K~~	CV	6K	product reviews	2
MPQA (Wiebe et al., 2005)	11k	CV	6K	opinion polarity	2
SUBJ (Pang & Lee, 2005)	10k	CV	21k	subjectivity	2
MR (Pang & Lee, 2005)	11.9k	CV	20k	movie reviews	2
SST (Socher et al., 2013)	67k	2.2k	18k	movie reviews	2
TREC (Li & Roth, 2002)	5.4k	0.5k	10k	Question	6
Table 1: Dataset Statistics. CV means 10-fold cross validation. The last 2 datasets come with
train/dev/test splits.
think of the vector gpe(j, pos) = [ei(ωj,1 pos+θj,I),…,eiQj,Dpos+θj,D)] as a “purely” positional em-
bedding. Consequently, our complex embedding can be considered an element-wise multiplication
between the word embedding gwe(j) = [rj,1, ..., rj,K] and position embedding gpe.
f(j, pos) = gwe(j)	gpe(j, pos)	(6)
Prior work (Gehring et al., 2017; Vaswani et al., 2017) uses mean-weight addition between word
embeddings fwe and position embeddings fpe (all words share the weights). In our work, word em-
beddings and position embeddings are decoupled to some extent by element-wise multiplication and
therefore the frequency/period terms (related to ωj,d) can adaptively adjust the importance between
semantic and position information for each word and each dimension. In particular, with higher
frequency (i.e., large ωj,d), the final embedding will change dramatically with the changing posi-
tions, while it can be fixed for any positions with an extremely-small frequency (i.e., small ωj,d).
Interestingly, the well-known position embedding in Transformer (Vaswani et al., 2017) can be seen
as a degraded version of one of our specific complex word embeddings (see the Appendix A).
3	Experimental Evaluation
We evaluate our embeddings in text classification, machine translation and language modeling.
3.1	Text Classification
Experimental Setup. We use six popular text classification datasets: CR, MPQA, SUBJ, MR,
SST, and TREC (see Tab. 1). We use accuracy as evaluation measure based on fixed train/dev/test
splits or cross validation, as per prior work. We use Fasttext (Joulin et al., 2016), CNN (Kim, 2014),
LSTM and Transformer (Vaswani et al., 2017) as NN baselines2. We use each of them: (1) with-
out positional information; (2) with Vanilla Position Embeddings (PE) (randomly initialized and
updated during training using the sum between word and position vectors (Gehring et al., 2017);
(3) with Trigonometric Position Embeddings (TPE) (defining position embeddings as trigono-
metric functions as per Eq. 7); (4) with Complex-vanilla word embeddings (where the amplitude
embedding is initialized by the pre-trained word vectors, and the phrase embedding is randomly ini-
tialized in a range from -π to π without considering word order (Wang et al., 2019)); and (5) with
our order-aware complex-valued word embeddings, Complex-order (which encode position in the
phase parts, train the periods, and where the amplitude embedding is also initialized by pretrained
word vectors). For more details on the complex-valued extensions of NNs, see App. B and App. C.
Our embedding generally has 3 × D × |W| parameters with D-dimensional word vectors and |W|
words, while previous work (Mikolov et al., 2013b; Pennington et al., 2014) usually employs only
D × |W| parameters for embedding lookup tables. To increase efficiency and facilitate fair com-
parison with previous work we set initial phases θj = [θj,1, ..., θj,D] to a shared constant value
(such as zero). Furthermore, the period vectors ωj,d depend on word index j with length |W| and
the coordinate index d with length D . To decrease the number of parameters, one can either use a
Word-Sharing scheme (i.e., ωj,d = ω.,d), or a dimension-sharing scheme (ωj,d = ωj,∙), leading to
|W| * D + |W| and |W| * D + D parameters in total for the embedding layer.
2Graph convolutional networks (GCNs) (Beck et al., 2018; Sahu et al., 2019) also encode positional infor-
mation. We do not compare against them because they encode positional information inherently as part of the
model, which makes redundant any additional encoding of positional information at the embedding level.
5
Published as a conference paper at ICLR 2020
Table 2: Text classification accuracy without position embeddings, with random position embed-
dings (PE), with trigonometric position embeddings (TPE), with complex-valued NNs without po-
sition embeddings (complex-vanilla), and with our complex-order embeddings. Superscripts §, f, ∣
and * mean a significant improvement over a baseline without position embeddings §, PE±, TPE^
and Complex-vanilla * using Wilcoxon,s signed-rank test p<0.05.
Method	MR	SUBJ	CR	MPQA	SST	TREC
Fasttext	0.765	0.916	0.789	0.874	0.788	0.874
Fasttext-PE	0.774	0.922	0.789	0.882	0.791	0.874
Fasttext-TPE	0.776	0.921	0.796	0.884	0.792	0.88
Fasttext-Complex-vanilla	0.773	0.918	0.79	0.867	0.803	0.872
Fasttext-Complex-order	0.787§t"	0.929§t"	0.800§叁*	0.889§t"	0.809§t"	0.892§叁*
LSTM	0.775	0.896	0.813	0.887	0.807	0.858
LSTM-PE	0.778	0.915	0.822	0.889	0.811	0.858
LSTM-TPE	0.776	0.912	0.814	0.888	0.813	0.865
LSTM-Complex-vanilla	0.765	0.907	0.810	0.823	0.784	0.784
LSTM-Complex-order	0.790§t"	0.926§计*	0.828§叁*	0.897§曲	0.819§t"	0.869§^^*
CNN	0.809	0.928	0.830	0.894	0.856	0.898
CNN-PE	0.816	0.938	0.831	0.897	0.856	0.890
CNN-TPE	0.815	0.938	0.836	0.896	0.838	0.918
CNN-Complex-vanilla	0.811	0.937	0.825	0.878	0.823	0.900
CNN-Complex-order	0.825§t"	0.951§t"	0.852§叁*	0.906§曲	0.864§t"	0.939§叁*
Transformer w/o position embedding	0.669	0.847	0.735	0.716	0.736	0.802
Transformer-PE	0.737	0.859	0.751	0.722	0.753	0.820
Transformer-TPE (Vaswani et al., 2017)	0.731	0.863	0.762	0.723	0.761	0.834
Transformer-Complex-vanilla	0.715	0.848	0.753	0.786	0.742	0.856
Transformer-Complex-order	0.746§t"	0.895§t"	0.806§叁*	0.863§t"	0.813§t"	0.896§叁*
Table 3: Text classification accuracy. ? means that scores are reported from other papers.
Method	MR	SUBJ	CR	MPQA	SST	TREC
Word2vec Bow (Conneau et al., 2017) ?	0.777	0.909	0.798	0.883	0.797	0.836
Sent2Vec (Pagliardini et al., 2017) ?	0.763	0.912	0.791	0.872	0.802	0.858
QuickThoughts (Logeswaran & Lee, 2018) ?	0.824	0.948	0.860	0.902	-	0.928
InferSent (Conneau et al., 2017) ?	0.811	0.924	0.863	0.902	0.846	0.882
QPDN (Wang et al., 2019) ?	0.801	0.927	0.810	0.870	0.839	0.882
We search the hyper parameters from a parameter pool, with batch size in {32, 64, 128}, learning
rate in {0.001, 0.0001, 0.00001}, L2-regularization rate in {0, 0.001, 0.0001}, and number of hid-
den layer units in {120, 128}. We use pre-trained 300-dimensional vectors from word2vec (Mikolov
et al., 2013a) in all models except for Transformers. The models with trainable trigonometric posi-
tion embedding produce nearly identical results compared to the non-trainable version, therefore we
report the result of fixed position embeddings as per Vaswani et al. (2017). We adopt narrow convo-
lution and max pooling in CNN, with number of filters in {64, 128}, and size of filters in {3, 4, 5}.
In all Transformer models, we only use the encoder layer to extract feature information, where the
layer is 1, dimension of word and inner hidden are 256 and 512 respectively, and head number is 8.
Results. The results are shown in Tab. 2. Our complex-order embeddings outperform all other
variations at all times. This gain in effectiveness comes at a negligible (or non-existent) cost in
efficiency (it varies per NN architecture - see Fig. 2). CNNs are the best performing NN as expected
following Bai et al. (2018). Tranformer NNs benefit the most from our complex-order embeddings,
most likely because they are our weakest baseline. To contextualise these results, Tab. 3 shows
classification accuracy of five typical approaches on the same datasets (as reported in the original
papers). Our complex-order embeddings outperform all methods, except for the CR dataset, where
InferSent is marginally better. Overall, our approach is on apar with the SOTA in embeddings.
We perform an ablation test (Tab. 4) on Transformer because it is the most common NN to be used
with position embeddings. The two period-sharing schemas (dimension-sharing and word-sharing)
6
Published as a conference paper at ICLR 2020
Figure 2: Computation time (seconds) per epoch in Tensorflow on TITAN X GPU.
Table 4: Ablation test for Transformer, showing the effect of (i) the definition of embedding
layer(fd(j, pos)), and (ii) whether the real-part and imaginary transition share the weights, i.e.,
<(W Q/K/V) = =(W Q/K/V).
Method	Setting		Params	Accuracy	∆
	fd j POs)	share in W Q/K/V			
Transformer-complex-order	门,d ei(ωj,d POs)	×	8.33M	0.813	-
adding initial phases	rj d ei(ωj,d Pos + θj	,d)	×	11.89M	0.785	-0.028
dimension-sharing period schema	rj,d eijj,∙ pos^^	×	5.82M	0.797	-0.016
word-sharing period schema	j eiω∙,d pos	×	5.81M	0.805	-0.008
dimension-sharing amplitude schema	rj eiωj,∙ Pos	×	5.82M	0.798	-0.015
word-sharing amplitude schema	r；d eiω∙,d pos	×	5.81M	0.804	-0.009
w/t encoding positions (complex-vanilla)	rj,d eiωj,d	×	9.38M	0.764	-0.049
dimension-sharing period schema	j eiωj,∙ Pos^^	X	4.77M	0.794	-0.019
word-sharing period schema	j eiω∙,d Pos	X	4.76M	0.797	-0.016
dimension-sharing amplitude schema	r3, eiωj,∙ Pos	X	4.77M	0.792	-0.021
word-sharing amplitude schema	r∙,d eiω∙,d Pos	X	4.76M	0.801	-0.012
w/t encoding positions (complex-vanilla)	r3,d eiωj,d	X	8.33M	0.743	-0.07
vanilla Transformer (Vaswani et al., 2017)	Wj + PEd	-	4.1M	0.761	-0.052
slightly drop performance, because fewer parameters limit the representative power. Adding ini-
tial phases also hurts performance, although we observed that the loss could decrease faster in early
epochs compared to the setting without offset. The negative effect of initial phases may be due to pe-
riodicity, and ω cannot be directly regularized with L2-norm penalties. The sharing schemes slightly
decrease the performance with less parameters. More details of the learned periods/frequencies (e.g.
the distributions of periods/frequencies and case studies) are shown in App. D.
Note that the word-sharing schema outperform the Vanilla Transformer, (both have a comparable
number of parameters). Ifwe choose <(W Q/K/V ) = =(W Q/K/V ), the additional parameters in the
embedding layers will affect much less the whole parameter scale in the multiple-layer Transformer,
since a embedding layer is only used in the first layer instead of the following Transformer layers.
3.2	Machine Translation
Experimental Setup. We use the standard WMT 2016 English-German dataset (Sennrich et al.,
2016), whose training set consists of 29,000 sentence pairs. We use four baselines: basic Attentional
encoder-decoder (AED) (Bahdanau et al., 2014); AED with Byte-pair encoding (BPE) subword
segmentation for open-vocabulary translation (Sennrich et al., 2016); AED with extra linguistic
features (morphological, part-of-speech, and syntactic dependency labels) (Sennrich & Haddow,
2016); and a 6-layer Transformer. Our approach (Transformer Complex-order) uses a batch size of
64, a head of 8, 6 layers, the rate of dropout is 0.1, and the dimension of the word embedding is
512. The embedding layer does not use initial phases, i.e., following f (j, pos) = rj ei(ωj pos) . We
evaluate MT performance with the Bilingual Evaluation Understudy (BLEU) measure.
7
Published as a conference paper at ICLR 2020
Table 5: Machine translation results. ? marks scores reported from other papers.		Table 6:	Language modeling results. ? marks scores reported from other papers.	
Method	BLEU	Method	BPC
AED (Bahdanau et al., 2014) ? AED+Linguistic (Sennrich & Haddow, 2016) ? AED+BPE (Sennrich et al., 2016) ? Transformer (Ma et al., 2019) ? Transformer complex vanilla Transformer Complex-order	26.8 28.4 34.2 34.5 34.7 35.8	BN-LSTM (Cooijmans et al., 2016) ? LN HM-LSTM (Chung et al., 2016) ? RHN (Zilly et al., 2017) ? Large mLSTM (Krause et al., 2016) ? Transformer XL 6L (Dai et al., 2019) Transformer complex vanilla Transformer XL Complex-order 6L	1.36 1.29 1.27 1.27 1.29 1.30 1.26
Results Tab. 5 shows the MT results. Our approach outperforms all baselines. Two things are
worth noting: (1) Both the vanilla Transformer and our Transformer Complex-order outperform the
three Attentional encoder-decoder baselines which are based on an LSTM encoder and decoder, even
when AED uses additional features. (2) Our Transformer Complex-Order outperforms the Vanilla
Transformer and complex-vanilla Transformer by 1.3 and 1.1 in absolute BLEU score respectively.
3.3	Language Modeling
Experimental Setup. We use the text8 (Mahoney, 2011) dataset, consisting of English Wikipedia
articles. The text is lowercased from a to z, and space. The dataset contains 100M characters (90M
for training, 5M for dev, and 5M for testing, as per Mikolov et al. (2012)). We use as baselines
BN-LSTM, LN HM-LSTM RHN and Large mLSTM, which are typical recurrent NNs for language
modeling in this dataset. We evaluate performance with the Bits Per Character (BPC) measure,
(the lower, the better). We run the coder in Dai et al. (2019) with 6 layers for Transformer XL 6L;
our model, named Transformer XL complex-order, directly replaces the word embedding with our
proposed embedding under the same setting. We choose 6 layers due to limitations in computing
resources. For Transformer XL Complex-order, all other parameter settings are as for Transformer
XL (Dai et al., 2019). Our complex-order model does not use initial phases.
Results. We see in Tab. 6 that our method outperforms all baselines. The first four baselines (BN-
LSTM, LN HM-LSTM, RHN and Large mLSTM) are based on recurrent NNs and rely on different
regulation methods to become applicable in multiple-layer recurrent architectures. Transformer-
based architectures can easily be stacked with multiple layers due to their advantages in paralleliza-
tion, however the vanilla Transformer does not outperform the multiple-layer recurrent baselines,
most likely due to its limitation of 6 layers. Our Transformer XL Complex-order outperforms its
vanilla counterpart under the 6-layer setting (and also strong recurrent network baselines), demon-
strating that our embedding also generalizes well in tasks with long-term dependency. With limited
resources, slightly increasing the parameters in the feature layer like our proposed embedding could
be more beneficial than stacking more layers with linearly increasing parameters.
4	Related Work
Complex-valued NNs are not new (Georgiou & KoUtsoUgeras, 1992; Kim & Adali, 2003; Hirose,
2003). Complex-valued weights have been used in NNs, motivated by biology (Reichert & Serre,
2013), and also as signal processing in speech recognition (Shi et al., 2006). More recently, Ar-
jovsky et al. (2016) shifted RNNs into the complex domain and Wolter & Yao (2018) proposed a
novel complex gated recurrent cell. Trabelsi et al. (2017) also developped a complex-valued NN for
computer vision and audio processing.
Complex numbers have also been applied to text processing like (Van Rijsbergen, 2004; Melucci,
2015; Blacoe et al., 2013). Trouillon et al. (2016) adopt complex embedding for entities in Knowl-
edge Graph Completion to represent antisymmetric relations with Hermitian dot product. Li et al.
(2019); Wang et al. (2019) extend word embeddings to complex-valued fashion in quantum prob-
ability driven NNs, seeing the overview in Wang et al. (2019). However, the physical meaning of
both the complex-valued entity and word embeddings is unknown, since a complex number was
considered as two real numbers in a black-box learning paradigm. Our work first links the phase in
complex numbers to word position to define concrete physical meaning in document representations.
8
Published as a conference paper at ICLR 2020
5	Conclusions
We extended word vectors to word functions with a variable i.e. position, to model the smooth shift
among sequential word positions and therefore implicitly capture relative distances between words.
These functions are well-defined to model the relative distances, therefore we derive a general solu-
tion in complex-valued fashion. Interestingly, the position embedding in Vaswani et al. (2017) can
be considered a simplified version of our approach. We extend CNN, RNN and Transformer NNs
to complex-valued versions to incorporate our complex embedding. Experiments on text classifica-
tion, machine translation and language modeling show that our embeddings are more effective than
vanilla position embeddings (Vaswani et al., 2017).
Acknowledgments
We thank Massimo Melucci and Emanuele Di Buccio for their helpful comments, Xindian Ma for
his detailed experimental suggestions.
This work is supported by the Quantum Access and Retrieval Theory (QUARTZ) project, which
has received funding from the European Union‘s Horizon 2020 research and innovation programme
under the Marie SklodoWska-CUrie grant agreement No. 721321. Peng Zhang and Donghao Zhang
are supported in part by Natural Science Foundation of China (grant No. 61772363, U1636203)
References
Martin Arjovsky, Amar Shah, and Yoshua Bengio. Unitary evolution recurrent neural netWorks. In
International Conference on International Conference on Machine Learning, 2016.
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.
Shaojie Bai, J. Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional
and recurrent netWorks for sequence modeling. CoRR, abs/1803.01271, 2018. URL http:
//arxiv.org/abs/1803.01271.
Daniel Beck, Gholamreza Haffari, and Trevor Cohn. Graph-to-sequence learning using gated graph
neural netWorks. arXiv preprint arXiv:1806.09835, 2018.
William Blacoe, Elham Kashefi, and Mirella Lapata. A quantum-theoretic approach to distributional
semantics. In NAACL,pp. 847-857, 2013.
Junyoung Chung, Sungjin Ahn, and Yoshua Bengio. Hierarchical multiscale recurrent neural net-
Works. arXiv preprint arXiv:1609.01704, 2016.
Alexis Conneau, DouWe Kiela, Holger SchWenk, Loic Barrault, and Antoine Bordes. Super-
vised learning of universal sentence representations from natural language inference data. arXiv
preprint arXiv:1705.02364, 2017.
Tim Cooijmans, Nicolas Ballas, Cesar Laurent, Caglar GUlcehre, and Aaron Courville. Recurrent
batch normalization. arXiv preprint arXiv:1603.09025, 2016.
Zihang Dai, Zhilin Yang, Yiming Yang, William W Cohen, Jaime Carbonell, Quoc V Le, and Ruslan
Salakhutdinov. Transformer-xl: Attentive language models beyond a fixed-length context. arXiv
preprint arXiv:1901.02860, 2019.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep
bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.
Jonas Gehring, Michael Auli, David Grangier, Denis Yarats, and Yann N Dauphin. Convolutional
sequence to sequence learning. In Proceedings of the 34th International Conference on Machine
Learning-Volume 70, pp. 1243-1252. JMLR. org, 2017.
George M Georgiou and Cris Koutsougeras. Complex domain backpropagation. IEEE transactions
on Circuits and systems II: analog and digital signal processing, 39(5):330-334, 1992.
9
Published as a conference paper at ICLR 2020
Akira Hirose. Complex-valued neural networks: theories and applications, volume 5. World Sci-
entific, 2003.
Minqing Hu and Bing Liu. Mining and Summarizing Customer Reviews. pp. 10, 2014.
Armand Joulin, Edouard Grave, Piotr Bojanowski, and Tomas Mikolov. Bag of tricks for efficient
text classification. arXiv preprint arXiv:1607.01759, 2016.
TaehWan Kim and Tulay Adali. Approximation by fully complex multilayer perceptrons. Neural
computation,15(7):1641-1666, 2003.
Yoon Kim. Convolutional neural netWorks for sentence classification. arXiv preprint
arXiv:1408.5882, 2014.
Ben Krause, Liang Lu, Iain Murray, and Steve Renals. Multiplicative lstm for sequence modelling.
arXiv preprint arXiv:1609.07959, 2016.
Qiuchi Li, Sagar Uprety, Benyou Wang, and DaWei Song. Quantum-inspired complex Word embed-
ding. In Proceedings of The Third Workshop on Representation Learning for NLP, pp. 50-57,
2018.
Qiuchi Li, Benyou Wang, and Massimo Melucci. Cnm: An interpretable complex-valued netWork
for matching. In NAACL-HLT (1), pp. 4139-4148, 2019.
Xin Li and Dan Roth. Learning Question Classifiers. In COLING. Association for Computational
Linguistics, 2002.
Lajanugen LogesWaran and Honglak Lee. An efficient frameWork for learning sentence representa-
tions. arXiv preprint arXiv:1803.02893, 2018.
Xindian Ma, Peng Zhang, Shuai Zhang, Nan Duan, Yuexian Hou, DaWei Song, and Ming Zhou. A
tensorized transformer for language modeling. arXiv preprint arXiv:1906.09777, 2019.
Matt Mahoney. Large text compression benchmark. URL: http://www. mattmahoney. net/text/text.
html, 2011.
Massimo Melucci. Introduction to information retrieval and quantum mechanics, volume 35.
Springer, 2015.
T. Mikolov, I. Sutskever, K. Chen, G. Corrado, and J. Dean. Distributed representations ofWords
and phrases and their compositionality. Advances in Neural Information Processing Systems, 26:
3111-3119, 2013a.
Tomas Mikolov, Ilya Sutskever, AnooP Deoras, Hai-Son Le, Stefan Kombrink, and Jan Cer-
nocky. SubWord language modeling With neural netWorks. preprint (http://www. fit. vutbr.
cz/imikolov/rnnlm/char. pdf), 8, 2012.
Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient estimation of Word represen-
tations in vector space. arXiv preprint arXiv:1301.3781, 2013b.
Matteo Pagliardini, Prakhar Gupta, and Martin Jaggi. Unsupervised learning of sentence embed-
dings using compositional n-gram features. arXiv preprint arXiv:1703.02507, 2017.
Bo Pang and Lillian Lee. Seeing stars: exploiting class relationships for sentiment categoriza-
tion With respect to rating scales. pp. 115-124. Association for Computational Linguistics,
2005. doi: 10.3115/1219840.1219855. URL http://portal.acm.org/citation.
cfm?doid=1219840.1219855.
Jeffrey Pennington, Richard Socher, and Christopher D Manning. Glove: Global vectors for Word
representation. In EMNLP, volume 14, pp. 1532-1543, 2014.
David P Reichert and Thomas Serre. Neuronal synchrony in complex-valued deep netWorks. arXiv
preprint arXiv:1312.6115, 2013.
10
Published as a conference paper at ICLR 2020
Sunil Kumar Sahu, Fenia Christopoulou, Makoto Miwa, and Sophia Ananiadou. Inter-sentence
relation extraction with document-level graph convolutional neural network. arXiv preprint
arXiv:1906.04684, 2019.
Rico Sennrich and Barry Haddow. Linguistic input features improve neural machine translation.
arXiv preprint arXiv:1606.02892, 2016.
Rico Sennrich, Barry Haddow, and Alexandra Birch. Edinburgh neural machine translation systems
for wmt 16. arXiv preprint arXiv:1606.02891, 2016.
Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani. Self-attention with relative position representa-
tions. arXiv preprint arXiv:1803.02155, 2018.
Guangji Shi, Maryam Modir Shanechi, and Parham Aarabi. On the importance of phase in human
speech recognition. IEEE transactions on audio, speech, and language processing, 14(5):1867-
1874, 2006.
Richard Socher, Cliff C Lin, Chris Manning, and Andrew Y Ng. Parsing natural scenes and natural
language with recursive neural networks. In Proceedings of the 28th international conference on
machine learning (ICML-11), pp. 129-136, 2011.
Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D. Manning, Andrew Ng,
and Christopher Potts. Recursive Deep Models for Semantic Compositionality Over a Sentiment
Treebank. EMNLP, pp. 1631-1642, 2013.
Chiheb Trabelsi, Olexa Bilaniuk, Ying Zhang, Dmitriy Serdyuk, SandeeP Subramanian, Joao Fe-
lipe Santos, Soroush Mehri, Negar Rostamzadeh, Yoshua Bengio, and Christopher J Pal. Deep
complex networks. arXiv preprint arXiv:1705.09792, 2017.
Theo Trouillon, Johannes Welbl, Sebastian Riedel, Enc GaUssier, and Guillaume Bouchard. Com-
plex embeddings for simple link prediction. In International Conference on Machine Learning,
pp. 2071-2080, 2016.
Cornelis Joost Van Rijsbergen. The geometry of information retrieval. Cambridge University Press,
2004.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in Neural Infor-
mation Processing Systems, pp. 5998-6008, 2017.
Benyou Wang, Emanuele Di Buccio, and Massimo Melucci. Representing words in vector space and
beyond. In Quantum-Like Models for Information Retrieval and Decision-Making, pp. 83-113.
Springer, 2019.
Benyou Wang, Qiuchi Li, Massimo Melucci, and Dawei Song. Semantic hilbert space for text
representation learning. In The World Wide Web Conference on, pp. 3293-3299, 2019.
Janyce Wiebe, Theresa Wilson, and Claire Cardie. Annotating Expressions of Opinions and Emo-
tions in Language. Language Resources and Evaluation, 39(2-3):165-210, May 2005. ISSN
1574-020X, 1572-8412. doi: 10.1007/s10579-005-7880-9. URL http://link.springer.
com/10.1007/s10579-005-7880-9.
Moritz Wolter and Angela Yao. Gated complex recurrent neural networks. arXiv preprint
arXiv:1806.08267, 2018.
Julian Georg Zilly, Rupesh Kumar Srivastava, Jan Koutnlk, and Jurgen Schmidhuber. Recurrent
highway networks. In Proceedings of the 34th International Conference on Machine Learning-
Volume 70, pp. 4189-4198. JMLR. org, 2017.
11
Published as a conference paper at ICLR 2020
A Linking to the position embeddings in (Vaswani et al., 2017)
Vaswani et al. (2017) proposed a new initialization for position embedding, resulting in compara-
ble performance with previous one (Gehring et al., 2017) even without fine-tuning. The position
embedding is empirically selected as
PE2k (∙,pos) = Sin(Pos/100002k∕dmodel)
PE2k+1(∙,pos) = Cos(Pos/100002k/dmodel)
(7)
Where pos is the position index, 2k and 2k + 1 is the dimension index and dmodel is the dimension
size of embedding. The reason for choosing this position embedding was not well-explained and its
general extension is unknown, leading to some difficulties to improve it.
We claim that the proposed position embedding in (Vaswani et al., 2017) is a degraded version of one
of our specific complex word embedding in word-sharing schema (i.e., ωj,d = ω.,d), in which pj,k =
2π × 100002k/dmodel and the initial phases are set as zero. In our complex-valued position embed-
ding, let fpe,k(∙,pos) = ei×100002k∕dmodel = cos(100002k/dmodelPos) + i sin(100002k/dmodelpos).
Note that there exists abi-jeCtion between PE(∙,pos) and fpe,k (∙,pos):
PE2k (∙,Pos) = =(fpe,k 3Pos)),	(8)
PE2k+l(∙,pos) = <(fpe,k (∙,Pos))
where < and = are the operations to take the real and imaginary part of a complex-valued number.
Its inverse transformation is
fpe,k(∙,Pos) = PE2k+1 (∙,Pos) + iPE2k(∙,Pos)
(9)
In our overall embedding, each dimension fk(j,pos) = fwe,k(j) Θ fpe,k(∙,Pos) in our approaches,
while it is Ek(j,Pos) = WEk(j) + PEk(∙,Pos) in (Gehring et al., 2017; Vaswani et al., 2017).
Hence the position embedding in (Vaswani et al., 2017) is equivalent, albeit not identical, to our
complex-valued position embedding with Pj,k = 2π × 100002k/dmodel . It is therefore a particular
case of our complex-valued position embedding, the word-sharing schema in which all words share
the same period at a certain dimension, i.e, Pj,k = P∙,k is irrelevant to the choice of j.
B Integrating complex-valued embedding to general neural
NETWORKS
Neural networks are typically given real numbers as inputs and return real numbers as outputs. To
accommodate complex numbers as in- and output, we devise a complex-valued version of various
neural network layers i.e. complex-valued FastText with dense layer, CNN, and RNN. Unlike exist-
ing complex-valued neural networks (Trabelsi et al., 2017; Wolter & Yao, 2018), our feature layers
are also converted into complex-valued layers.
Complex-valued FastText FastTest (Joulin et al., 2016) is a simple and efficient neural network
architecture using a dense layer over the sum of all word embeddings for general text classification.
For a linear dense layer, i.e., z = dense(x + iy), where x + iy and z denote the complex-valued
in- and output, respectively. Let W = A + iB and b = c + id be complex-valued linear weights
and bias, respectively. Then, the complex-valued dense layer is given by:
z = σ (Ax - By + c) + iσ(Bx + Ay + d)	(10)
where σ is a real-valued activation function such as the sigmoid function. By rewriting (10) in matrix
form (Trabelsi et al., 2017), we obtain:
<(z)	σ(Ax - By + c)
=(z) = σ(Bx + Ay + d)
(11)
where, for z = x + iy, <(z) = x and =(z) = y. To save parameters and fairly compare with
our real-valued baselines, the weights for real-part and imaginary-part input can be shared, i.e.,
A = B, c = d.
12
Published as a conference paper at ICLR 2020
Complex-valued CNN For the complex-valued version of the convolution operation Trabelsi et al.
(2017), we similarly define a complex-valued convolution with separate real and imaginary kernels
A and B, to compute convolutions on the real and imaginary parts of the input in Eq. 10. A
complex-valued CNN network is constructed by stacking the operations based on a complex-valued
convolution kernel, adding a complex dense layer in (10), and taking their norm as the final predic-
tion in the last layer.
Complex-valued RNN The basic complex RNN formulation is:
hC = f (Whht-1 + WZZt + b)	(12)
where zt and ht represent the complex-valued input and complex-value hidden state vectors at time
t, b is a complex-valued bias, Wh and WZ are complex-valued weight transitions for hidden state
and input state, and f (z) = σ (< (z)) + iσ (= (z)) is the activation function. The multiplication
Whht-1 and WZztis computed as defined in (10) above. Similarly, the complex-valued gates are
used in LSTM via operations as in (12). In the final layer, a l2-norm operation is adopted to obtain
a real-valued loss for backpropagation.
Complex-valued Transformer The main components in the Transformer are self-attention sub-
layers and position-wise feed-forward (FFN) sublayers. A self-attention sublayer employs h atten-
tion heads and the concatenation of all heads is used as the output followed by a parameterized linear
transformation. For a sequence embedded as complex-valued vector input = {w1, w2, ..., wn}, the
output of each head is computed as a weighted sum of a linear transformation of the input sequence
itself, namely
outputi =	ai,jwjWV,	(13)
j
where wj is a complex-valued vector and WV is a complex linear transformation; therefore
outputi is also complex. Hence, output is a sequence of complex-valued vectors with the same
shape as input. The weight coefficient, ai,j, which is defined as in real-valued domain, is cal-
culated as the softmax of the product between complex-valued query vectors and key vectors:
aij = SoftmaX v^Jei,j——,and
i,j	in=1 ei,j
ei,j = r<(z)2 + =(z)2 ,Z = (WiWQ)(WjWK)t,	(14)
z is a complex number since wi and wj are complex-valued vectors and WQ , WK are complex-
valued transformation. To extend another variant of Transformer called Transformer XL, we keep its
original relative position embedding and additionally replace its word embedding with our proposed
embedding.
Correspondingly, the FFN sublayer can easily be extended to a complex-valued version by replacing
the real-valued layers with complex-valued ones. We use batch-normalization separately for the real
and imaginary parts.
C Implementation of the proposed embedding
Words functions are implemented in neural networks by storing the function parameters {r, ω, θ}
and then construct the values based on the arguments. Based on the definition, the implementation
of the proposed embedding can easily be implemented with only modifying the embedding layer.
We list the basic code to construct our general embedding as below:
import torch
import math
class ComplexNN ( torch . nn . Module ) :
def __init__( self , opt):
super (ComPlexNN , self ). __init__ ()
self . word_emb = torch .nn. Embedding (opt.n_ token, opt. d_model)
self . frequency_emb = torch .nn. Embedding ( opt. n_token , opt. d.model)
self . initial_phase_emb = torch . nn . Embedding (opt. n_token , opt. d_model)
13
Published as a conference paper at ICLR 2020
0.060 0.065 0.070 0.075 0.080 0.085 0.090 0.095
mean of absolute frequency values
Figure 3: The distribution of the δj . Higher values mean that the word representations are more
sensitive to the word positions.
def get_embedding ( self , x):
amplitude = self . Word_emb(x)
frequency = self . frequency_emb (x)
self. initial_phase_emb. weight = torch . nn . Parameter ( self . initiaLPhase_emb . weight
% (2 * math . pi))
sent_len=x . size (— 1)
PoS-Seq = torch . arange (1 , Sentjen + 1, 1.0 , device = amplitude . device )
PoS-Seq = PoS-Seq . unsqueeze (0). unsqueeze(- 1)
PoS-Seq = pos_seq . repeat ([x. size (0) ,1 , amplitude . size ( - 1)])
dimension_bais = self . initial_phase_emb (x)
enc_output_PhaSe = torch .mul(pos_Seq , frequency )+ dimension_bais
enc-output_real = amplitude * torch . cos (enc_output .phase)
enc_output_image = amplitude * torch . sin(enc-output_phase)
# return torch . cat([ enc_output_real , enc_output_image], — 1)
return enc_output_real , enc,output_image
def forward ( self , x) :
return self. get_embedding (x)
...
Note that both the frequency vectors ω and initial-phase vectors θ can be shared between words
or dimensions, to save parameters. The proposed embedding can be also used in real-valued neural
networks if one directly concatenates the real-part numbers and imaginary-part numbers as a double-
size real-valued vector; therefore it could easily be extended in any existing networks without any
complex-valued components. For instance, it could be a good extension for Transformer based
pretrained models like (Devlin et al., 2018) by enriching the feature layer.
D Visualization of frequencies/periods
After training, we obtain the frequency vector ω for each word. For each word, the mean value of the
absolute frequency values, i.e., δj =寄 PD=ι ∣ωj,d∣ is considered as a metric to test the positional
sensitivities of the word, since a period value could be negative during training. The density of the
δj is shown in Fig. 3.
Words with the 50 greatest, and the 50 smallest, frequencies in the SST dataset are shown in Tab.
7. For the words with greatest frequencies, most of them are strong sentiment words like “worst”
14
Published as a conference paper at ICLR 2020
,“stupid” and “powerful”; a reason for this may be that such words appear in many positions in many
documents during training, and thus they are more sensitive to the positions. Conversely, there are
fewer words expressing strong sentiment among words with smaller frequencies, as shown in the
second row.
	words
greatest frequencies in descending order	worst solid stupid powerful mess wonderful remarkable suffers intoxicating thoughtful rare captures portrait gem frontal terrific unique wannabe witty lousy pointless contrived none worse refreshingly charming inventive amazing junk incoherent refreshing mediocre unfunny thinks enjoyed heartbreaking delightfully crisp brilliant heart spirit perfectly nowhere mistake engrossing fashioned excellent unexpected wonderfully means
smallest frequencies in ascending order	slowly proposal schemes roiling juliette titles fabric superstar ah WoW choreographed tastelessness beg fabulous muccino jacobi legendary jae rate example code sensation counter deaths hall eun drug mctiernan storylines cellophane wild motion ups trick comedy entertained mission frightening witnesses snoots liners african groan satisfaction calm saturday estranged holm refuses inquisitive
Table 7: Words with greatest frequencies and frequencies periods (based on δj ) in SST (a sentiment
classification task), all words are converted to lower-case. The strong sentiment words are bold
based on manual labeling.
15