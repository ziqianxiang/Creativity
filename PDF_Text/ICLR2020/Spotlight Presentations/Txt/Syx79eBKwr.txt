Published as a conference paper at ICLR 2020
A Mutual Information Maximization Perspec-
tive of Language Representation Learning
Lingpeng Kong*, Cyprien de Masson d'Autume*, Wang Ling*, Lei Yu*, Zihang Dai0*
Dani Yogatama*
DeePMind*, Carnegie Mellon University匚 Google Brain*
London, United Kingdom
{lingpenk,cyprien,lingwang,leiyu,zihangd,dyogatama}@google.com
Ab stract
We show state-of-the-art word rePresentation learning methods maximize an ob-
jective function that is a lower bound on the mutual information between different
Parts of a word sequence (i.e., a sentence). Our formulation Provides an alternative
PersPective that unifies classical word embedding models (e.g., SkiP-gram) and
modern contextual embeddings (e.g., BERT, XLNet). In addition to enhancing our
theoretical understanding of these methods, our derivation leads to a PrinciPled
framework that can be used to construct new self-suPervised tasks. We Provide an
examPle by drawing insPirations from related methods based on mutual informa-
tion maximization that have been successful in comPuter vision, and introduce a
simPle self-suPervised objective that maximizes the mutual information between a
global sentence rePresentation and n-grams in the sentence. Our analysis offers a
holistic view of rePresentation learning methods to transfer knowledge and trans-
late Progress across multiPle domains (e.g., natural language Processing, comPuter
vision, audio Processing).
1	Introduction
Advances in rePresentation learning have driven Progress in natural language Processing. Performance
on many downstream tasks have imProved considerably, achieving Parity with human baselines in
benchmark leaderboards such as SQuAD (RajPurkar et al., 2016; 2018) and GLUE (Wang et al.,
2019). The main ingredient is the “Pretrain and fine-tune” aPProach, where a large text encoder
is trained on an unlabeled corPus with self-suPervised training objectives and used to initialize a
task-sPecific model. Such an aPProach has also been shown to reduce the number of training examPles
that is needed to achieve good Performance on the task of interest (Yogatama et al., 2019).
In contrast to first-generation models that learn word tyPe embeddings (Mikolov et al., 2013; Pen-
nington et al., 2014), recent methods have focused on contextual token rePresentations—i.e., learning
an encoder to rePresent words in context. Many of these encoders are trained with a language
modeling objective, where the rePresentation of a context is trained to be Predictive of a target token
by maximizing the log likelihood of Predicting this token (Dai & Le, 2015; Howard & Ruder, 2018;
Radford et al., 2018; 2019). In a vanilla language modeling objective, the target token is always
the next token that follows the context. Peters et al. (2018) ProPose an imProvement by adding a
reverse objective that also Predicts the word token that Precedes the context. Following this trend,
current state-of-the-art encoders such as BERT (Devlin et al., 2018) and XLNet (Yang et al., 2019)
are also trained with variants of the language modeling objective: masked language modeling and
Permutation language modeling.
In this PaPer, we Provide an alternative view and show that these methods also maximize a lower
bound on the mutual information between different Parts of a word sequence. Such a framework
is insPired by the InfoMax PrinciPle (Linsker, 1988) and has been the main driver of Progress in
self-suPervised rePresentation learning in other domains such as comPuter vision, audio Processing,
and reinforcement learning (Belghazi et al., 2018; van den Oord et al., 2019; Hjelm et al., 2019;
1
Published as a conference paper at ICLR 2020
Bachman et al., 2019; O’Connor & Veeling, 2019). Many of these methods are trained to maximize
a particular lower bound called InfoNCE (van den Oord et al., 2019)—also known as contrastive
learning (Arora et al., 2019). The main idea behind contrastive learning is to divide an input data
into multiple (possibly overlapping) views and maximize the mutual information between encoded
representations of these views, using views derived from other inputs as negative samples. In §2, we
provide an overview of representation learning with mutual information maximization. We then show
how the skip-gram objective (§3.1; Mikolov et al. 2013), masked language modeling (§3.2; Devlin
et al. 2018), and permutation language modeling (§3.3; Yang et al. 2019), fit in this framework.
In addition to providing a principled theoretical understanding that bridges progress in multiple areas,
our proposed framework also gives rise to a general class of word representation learning models
which serves as a basis for designing and combining self-supervised training objectives to create better
language representations. As an example, we show how to use this framework to construct a simple
self-supervised objective that maximizes the mutual information between a sentence and n-grams in
the sentence (§4). We combine it with a variant of the masked language modeling objective and show
that the resulting representation performs better, particularly on tasks such as question answering and
linguistics acceptability (§5).
2	Mutual Information Maximization
Mutual information measures dependencies between random variables. Given two random variables
A and B , it can be understood as how much knowing A reduces the uncertainty in B or vice versa.
Formally, the mutual information between A and B is:
I(A, B) = H(A) - H(A | B) = H(B) - H(B | A).
Consider A and B to be different views of an input data (e.g., a word and its context, two different
partitions of a sentence). Consider a function f that takes A = a and B = b as its input. The goal of
training is to learn parameters of the function f that maximizes I (A, B).
Maximizing mutual information directly is generally intractable when the function f consists of
modern encoders such as neural networks (Paninski, 2003), so we need to resort to a lower bound
on I(A, B). One particular lower bound that has been shown to work well in practice is InfoNCE
(Logeswaran & Lee, 2018; van den Oord et al., 2019),1 which is based on Noise Contrastive
Estimation (NCE; Gutmann & Hyvarinen, 2012).2 InfoNCE is defined as:
I (A, B) ≥ Ep(A,B) fθ (a,b)-Eq(B) log X exp fθ (a, b) +log | B |,	(1)
一	L b∈B	」」
where a and b are different views of an input sequence, fθ ∈ R is a function parameterized by θ
(e.g., a dot product between encoded representations of a word and its context, a dot product between
encoded representations of two partitions of a sentence), and B is a set of samples drawn from a
proposal distribution q(B). The set B contains the positive sample b and |B| - 1 negative samples.
Learning representations based on this objective is also known as contrastive learning. Arora et al.
(2019) show representations learned by such a method have provable performance guarantees and
reduce sample complexity on downstream tasks.
We note that InfoNCE is related to cross-entropy. When B always includes all possible values of
the random variable B (i.e., B = B) and they are uniformly distributed, maximizing InfoNCE is
analogous to maximizing the standard cross-entropy loss:
Ep(A,B) fθ(a, b) — log £ exp fθ(a, b).	⑵
L	b∈B
1Alternative bounds include Donsker-Vardhan representation (Donsker & Varadhan, 1983) and Jensen-
Shannon estimator (Nowozin et al., 2016), but we focus on InfoNCE here.
2 See van den Oord et al. (2019); Poole et al. (2019) for detailed derivations of InfoNCE as a bound on
mutual information.
2
Published as a conference paper at ICLR 2020
Eq. 2 above shows that InfoNCE is related to maximizing pθ (b | a), and it approximates the
summation over elements in B (i.e., the partition function) by negative sampling. As a function of the
negative samples, the InfoNCE bound is tighter when B contains more samples (as can be seen in
Eq. 1 above by inspecting the log |B| term). Approximating a softmax over a large vocabulary with
negative samples is a popular technique that has been widely used in natural language processing in
the past. We discuss it here to make the connection under this framework clear.
3	Models
We describe how Skip-gram, BERT, and XLNet fit into the mutual information maximization
framework as instances of InfoNCE. In the following, we assume that fθ (a, b) = gψ (b)>gω(a),
where θ = {ω, ψ}. Denote the vocabulary set by V and the size of the vocabulary by V . For word
representation learning, we seek to learn an encoder parameterized by ω to represent each word in a
sequence x = {x1, x1, . . . , xT} in d dimensions. For each of the models we consider in this paper, a
and b are formed by taking different parts of x (e.g., a := x0 and b := xT ).
3.1	Skip-gram
We first start with a simple word representation learning model Skip-gram (Mikolov et al., 2013).
Skip-gram is a method for learning word representations that relies on the assumption that a good
representation of a word should be predictive of its context. The objective function that is maximized
in Skip-gram is: Ep(xi,xi) p(xij | xi) , where xi is a word token and xij is a context word of xi.
Let b be the context word to be predicted xij and a be the input word xi . Recall that fθ (a, b) is
gψ(b)>gω(a). The skip-gram objective function can be written as an instance of InfoNCE (Eq. 1)
where gψ (b) and gω (a) are embedding lookup functions that map each word type to Rd. (i.e.,
gψ (b), gω (a) : V → Rd).
p(xij | xi) can either be computed using a standard softmax over the entire vocabulary or with
negative sampling (when the vocabulary is very large). These two approaches correspond to different
choices of B. In the softmax approach, B is the full vocabulary set V and each word in V is
uniformly distributed. In negative sampling, B is a set of negative samples drawn from e.g., a unigram
distribution.
While Skip-gram has been widely accepted as an instance contrastive learning (Mikolov et al., 2013;
Mnih & Kavukcuoglu, 2013), we include it here to illustrate its connection with modern approaches
such as BERT and XLNet described subsequently. We can see that the two views of an input sentence
that are considered in Skip-gram are two words that appear in the same sentence, and they are encoded
using simple lookup functions.
3.2	BERT
Devlin et al. (2018) introduce two self-supervised tasks for learning contextual word representations:
masked language modeling and next sentence prediction. Previous work suggests that the next
sentence prediction objective is not necessary to train a high quality BERT encoder and the masked
language modeling appears to be the key to learn good representations (Liu et al., 2019; Joshi et al.,
2019; Lample & Conneau, 2019), so we focus on masked language modeling here. However, we also
show how next sentence prediction fits into our framework in Appendix A.
In masked language modeling, given a sequence of word tokens of length T, x = {x1, . . . , xT },
BERT replaces 15% of the tokens in the sequence with (i) a mask symbol 80% of the time, (ii) a
random word 10% of the time, or (iii) its original word. For each replaced token, it introduces a term
in the masked language modeling training objective to predict the original word given the perturbed
sequence Xi = {χι,...,Xi,..., XT} (i.e., the sequence X masked at χ/ This training objective can
be written as: Ep(χτ^τ)[p(χi | Xi)].
3
Published as a conference paper at ICLR 2020
X log p(Xtz | Xz<t)	.
Following our notation in §2, we have fθ (a, b) = gψ (b)>gω (a). Let b be a masked word xi and
a be the masked sequence X%. Consider a Transformer encoder parameterized by ω and denote
gω (Xi) ∈ Rd as a function that returns the final hidden state corresponding to the i-th token (i.e., the
masked token) after running Xi through the Transformer. Let gψ : V → Rd be a lookup function that
maps each word type into a vector and B = B be the full vocabulary set V. Under this formulation, the
masked language modeling objective maximizes Eq. 1 and different choices of masking probabilities
can be understood as manipulating the joint distributions p(a, b). In BERT, the two views of a
sentence correspond to a masked word in the sentence and its masked context.
Contextual vs. non-contextual. It is generally understood that the main difference between Skip-
gram and BERT is that Skip-gram learns representations of word types (i.e., the representation for a
word is always the same regardless of the context it appears in) and BERT learns representations of
word tokens. We note that under our formulation for either Skip-gram or BERT, the encoder that we
want to learn appears in gω, and gψ is not used after training. We show that Skip-gram and BERT
maximizes a similar objective, and the main difference is in the choice of the encoder that forms
gω —a context dependent Transformer encoder that takes a sequence as its input for BERT and a
simple word embedding lookup for Skip-gram.
3.3	XLNet
Yang et al. (2019) propose a permutation language modeling objective to learn contextual word repre-
sentations. This objective considers all possible factorization permutations of a joint distribution of a
sentence. Given a sentence X = {x1, . . . , xT}, there are T! ways to factorize its joint distribution.3
Given a sentence X, denote a permutation by z ∈ Z. XLNet optimizes the objective function:
Ep(x) Ep(z)
As a running example, consider a permutation order 3,1,5,2,4 for a sentence x1, x2, x3, x4, x5.
Given the order, XLNet is only trained to predict the last S tokens in practice. For S = 1, the context
sequence used for training is x1, x2, x3, _, x5, with x4 being the target word.
In addition to replacing the Transformer encoder with Transformer XL (Dai et al., 2019), a key
architectural innovation of XLNet is the two-stream self-attention. In two-stream self attention, a
shared encoder is used to compute two sets of hidden representations from one original sequence.
They are called the query stream and the content stream. In the query stream, the input sequence is
masked at the target position, whereas the content stream sees the word at the target position. Words
at future positions for the permutation order under consideration are also masked in both streams.
These masks are implemented as two attention mask matrices. During training, the final hidden
representation for a target position from the query stream is used to predict the target word.
Since there is only one set of encoder parameters for both streams, we show that we can arrive at
the permutation language modeling objective from the masked language modeling objective with
an architectural change in the encoder. Denote a hidden representation by htk, where t indexes
the position and k indexes the layer, and consider the training sequence x1 , x2, x3, _, x5 and the
permutation order 3,1,5,2,4. In BERT, we compute attention scores to obtain htk from htk-1 for
every t (i.e., t = 1, . . . , T), where h04 is the embedding for the mask symbol. In XLNet, the attention
scores for future words in the permutation order are masked to 0. For example, when we compute h1k,
only the attention score from h3k-1 is considered (since the permutation order is 3,1,5,2,4). For
h5k, we use h1k-1 and h3k-1. XLNet does not require a mask symbol embedding since the attention
score from a masked token is always zeroed out with an attention mask (implemented as a matrix).
As a result, we can consider XLNet training as masked language modeling with stochastic attention
masks in the encoder.
It is now straightforward to see that the permutation language modeling objective is an instance of
Eq.1, where b is a target token Xi and a is a masked sequence Xi = {χι,...,Xi,..., XT}. Similar to
3For example, we can factorize p(x) = p(x1)p(x2 | x1) . . . , p(xT | x1, . . . , xT-1) = p(xT)p(xT-1 |
xT ) . . . , p(x1 | xT , . . . , x2), and many others.
4
Published as a conference paper at ICLR 2020
Table 1: Summary of methods as instances of contrastive learning. See text for details.
Objective	a	b	p(a,b)	gω	gψ
Skip-gram	word	word	word and its context	lookup	lookup
MLM	context	masked word	masked tokens probability	Transformer	lookup
NSP	sentence	sentence	(non-)consecutive sentences	Transformer	lookup
XLNet	context	masked word	factorization permutation	TXL++	lookup
DIM	context	masked n-grams	sentence and its n-grams	Transformer	not used
BERT, we have a Transformer encoder parameterized by ω and denote gω(Xi) ∈ Rd as a function
that returns the final hidden state corresponding to the i-th token (i.e., the masked token) after running
Xi through the Transformer. Let gψ : V → Rd be a lookup function that maps each word type into
a vector and B = B be the full vocabulary set V. The main difference between BERT and XLNet
is that the encoder that forms gω used in XLNet implements attention masking based on a sampled
permutation order when building its representations. In addition, XLNet and BERT also differ in the
choice of p(a, b) since each of them has its own masking procedure. However, we can see that both
XLNet and BERT maximize the same objective.
4	InfoWord
Our analysis on Skip-Gram, BERT, and XLNet shows that their objective functions are different
instances of InfoNCE in Eq.1, although they are typically trained using the entire vocabulary set for
B instead of negative sampling. These methods differ in how they choose which views of a sentence
they use as a and b, the data distribution p(a, b), and the architecture of the encoder for computing gω,
which we summarize in Table 1. Seen under this unifying framework, we can observe that progress
in the field has largely been driven by using a more powerful encoder to represent gω . While we
only provide derivations for Skip-gram, BERT, and XLNet, it is straightforward to show that other
language-modeling-based pretraining-objectives such as those used in ELMo (Peters et al., 2018) and
GPT-2 (Radford et al., 2019) can be formulated under this framework.
Our framework also allows us to draw connections to other mutual information maximization
representation learning methods that have been successful in other domains (e.g., computer vision,
audio processing, reinforcement learning). In this section, we discuss an example derive insights to
design a simple self-supervised objective for learning better language representations.
Deep InfoMax (DIM; Hjelm et al., 2019) is a mutual information maximization based representation
learning method for images. DIM shows that maximizing the mutual information between an image
representation and local regions of the image improves the quality of the representation. The complete
objective function that DIM maximizes consists of multiple terms. Here, we focus on a term in the
objective that maximizes the mutual information between local features and global features. We
describe the main idea of this objective for learning representations from a one-dimensional sequence,
although it is originally proposed to learn from a two-dimensional object.
Given a sequence X = {x1, x2, . . . , xT}, we consider the “global” representation of the sequence
to be the hidden state of the first token (assumed to be a special start of sentence symbol) after
contextually encoding the sequence gω(X),4 and the local representations to be the encoded repre-
sentations of each word in the sequence gψ(xt). We can use the contrastive learning framework to
design a task that maximizes the mutual information between this global representation vector and
its corresponding “local” representations using local representations from other sequences gψ (Xt)
as negative samples. This is analogous to training the global representation vector of a sentence to
choose which words appear in the sentence and which words are from other sentences.5 However, if
we feed the original sequence X to the encoder and take the hidden state of the first token as the global
4Alternatively, the global representation can be the averaged representations of words in the sequence
although we do not explore this in our experiments.
5 We can see that this self-supervised task is related to the next sentence prediction objective in BERT.
However, instead of learning a global representation (assumed to be the representation of the first token in BERT)
5
Published as a conference paper at ICLR 2020
representation, the task becomes trivial since the global representation is built using all the words in
the sequence. We instead use a masked sequence a := Xt = {xι,...,Xt,..., XT} and b := xt.
State-of-the-art methods based on language modeling objectives consider all negative samples since
the second view of the input data (i.e., the part denoted by b in Eq. 1) that are used is simple and it
consists of only a target word—hence the size of the negative set is still manageable. A major benefit
of the contrastive learning framework is that we only need to be able to take negative samples for
training. Instead of individual words, we can use n-grams as the local representations.6 Denote an
n-gram by Xij and a masked sequence masked at position i to j by Xij We define IDIM as:
IDIM = Ep(Xi：j,Xi：j) gω (Xij ) gω (Xij ) - log〉: exp(gω (Xij ) gω (Xij )) ,
L	Xij ∈S	_l
where Xij is a sentence masked at position i to j, Xij is an n-gram spanning from i to j, and Xij
is an n-gram from a set S that consists of the positive sample Xi:j and negative n-grams from other
sentences in the corpus. We use one Transformer to encode both views, so we do not need gψ here.
Since the main goal of representation learning is to train an encoder parameterized by ω, it is possible
to combine multiple self-supervised tasks into an objective function in the contrastive learning
framework. Our model, which we denote InfoWord, combines the above objective—which is
designed to improve sentence and span representations—with a masked language modeling objective
IMLM for learning word representations. The only difference between our masked language modeling
objective and the standard masked language modeling objective is that we use negative sampling to
construct V by sampling from the unigram distribution. We have:
IMLM = Ep(Xi,Xi) gω (Xi) gψ (Xi) - log〉: exp(gω (Xi) gψ (Xi)),
L	a ∈v	」
where Xi a sentence masked at position i and Xi is the i-th token in the sentence.
Our overall objective function is a weighted combination of the two terms above:
IINFOWORD = λMLMIMLM + λDIMIDIM ,
where λMLM and λDIM are hyperparameters that balance the contribution of each term.
5	Experiments
In this section, we evaluate the effects of training masked language modeling with negative sampling
and adding IDIM to the quality of learned representations.
5.1	Setup
We largely follow the same experimental setup as the original BERT model (Devlin et al., 2018). We
have two Transformer architectures similar to BERTBASE and BERTLARGE . BERTBASE has 12 hidden
layers, 768 hidden dimensions, and 12 attention heads (110 million parameters); whereas BERTLARGE
has 24 hidden layers, 1024 hidden dimensions, and 16 attention heads (340 million parameters).
For each of the Transformer variant above, we compare three models in our experiments:
•	BERT: The original BERT model publicly available in https://github.com/
google-research/bert.
•	BERT-NCE: Our reimplementation of BERT. It differs from the original implementation in
several ways: (1) we only use the masked language modeling objective and remove next
sentence prediction, (2) we use negative sampling instead of softmax, and (3) we only use
one sentence for each training example in a batch.
to be predictive of whether two sentences are consecutive sentences, it learns its global representation to be
predictive of words in the original sentence.
6Local image patches used in DIM are analogous to n-grams in a sentence.
6
Published as a conference paper at ICLR 2020
•	INFOWORD: Our model described in §4. The main difference between INFOWORD and
BERT-NCE is the addition of IDIM to the objective function. We discuss how we mask the
data for IDIM in §5.2.
5.2	Pretraining
We use the same training corpora and apply the same preprocessing and tokenization as BERT. We
create masked sequences for training with IDIM as follows. We iteratively sample n-grams from a
sequence until the masking budget (15% of the sequence length) has been spent. At each sampling
iteration, we first sample the length of the n-gram (i.e., n in n-grams) from a Gaussian distribution
N(5, 1) clipped at 1 (minimum length) and 10 (maximum length). Since BERT tokenizes words into
subwords, we measure the n-gram length at the word level and compute the masking budget at the
subword level. This procedure is inspired by the masking approach in Joshi et al. (2019).
For negative sampling, we use words and n-grams from other sequences in the same batch as negative
samples (for MLM and DIM respectively). There are approximately 70,000 subwords and 10,000
n-grams (words and phrases) in a batch. We discuss hyperparameter details in Appendix B.
5.3	Fine-tuning
We evaluate on two benchmarks: GLUE (Wang et al., 2019) and SQuAD(Rajpurkar et al., 2016). We
train a task-specific decoder and fine-tune pretrained models for each dataset that we consider. We
describe hyperparameter details in Appendix B.
GLUE is a set of natural language understanding tasks that includes sentiment analysis, linguistic
acceptability, paraphrasing, and natural language inference. Each task is formulated as a classification
task. The tasks in GLUE are either a single-sentence classification task or a sentence pair classification
task. We follow the same setup as the original BERT model and add a start of sentence symbol (i.e.,
the CLS symbol) to every example and use a separator symbol (i.e., the SEP symbol) to separate two
concatenated sentences (for sentence pair classification tasks). We add a linear transformation and
a softmax layer to predict the correct label (class) from the representation of the first token of the
sequence.
SQuAD is a reading comprehension dataset constructed from Wikipedia articles. We report results
on SQuAD 1.1. Here, we also follow the same setup as the original BERT model and predict an
answer span—the start and end indices of the correct answer in the context. We use a standard span
predictor as the decoder, which we describe in details in Appendix C.
5.4	Results
We show our main results in Table 2 and Table 3. Our BERT reimplementation with negative sampling
underperforms the original BERT model on GLUE but is significantly better on SQuAD. However, we
think that the main reasons for this performance discrepancy are the different masking procedures (we
use span-based masking instead of whole-word masking) and the different ways training examples
are presented to the model (we use one consecutive sequence instead of two sequences separated by
the separator symbol). Comparing BERT-NCE and InfoWord, we observe the benefit of the new
self-supervised objective IDIM (better overall GLUE and SQuAD results), particularly on tasks such as
question answering and linguistics acceptability that seem to require understanding of longer phrases.
In order to better understand our model, we investigate its performance with varying numbers of
training examples and different values of λDIM on the SQuAD development set and show the results
in Figure 1 (for models with the Base configuration). We can see that InfoWord consistently
outperforms BERT-NCE and the performance gap is biggest when the dataset is smallest, suggesting
the benefit of having better pretrained representations when there are fewer training examples.
7
Published as a conference paper at ICLR 2020
Table 2: Summary of results on GLUE.
Model		COLA	SST-2	MRPC	QQP	MNLI (m/mm)	QNLI	RTE	GLUE AVG
	BERT	52.1	93.5	88.9	71.2	84.6/83.4	90.5	66.4	78.8
	BERT-NCE	50.8	93.0	88.6	70.5	83.2/83.0	90.9	65.9	78.2
	InfoWord	53.3	92.5	88.7	71.0	83.7/82.4	91.4	68.3	78.9
	BERT	60.5	94.9	89.3	72.1	86.7/85.9	92.7	70.1	81.5
	BERT-NCE	54.7	93.1	89.5	71.2	85.8/85.0	92.7	72.5	80.6
	InfoWord	57.5	94.2	90.2	71.3	85.8/84.8	92.6	72.0	81.1
Table 3: Summary of results on SQuAD 1.1.
Model	DEV		Test	
	F1	EM	Fi	EM
BERT	88.5	80.8	-	-
BERT-NCE	90.2	83.3	90.9	84.4
InfoWord	90.7	84.0	91.4	84.7
BERT	90.9	84.1	91.3	84.3
BERT-NCE	92.0	85.9	92.7	86.6
InfoWord	92.6	86.6	93.1	87.3
5.5	Discussion
Span-based models. We show how to design a simple self-supervised task in the InfoNCE frame-
work that improves downstream performance on several datasets. Learning language representations
to predict contiguous masked tokens has been explored in other context, and the objective introduced
in IDIM is related to these span-based models such as SpanBERT (Joshi et al., 2019) and MASS (Song
et al., 2019). While our experimental goal is to demonstrate the benefit of contrastive learning for
constructing self-supervised tasks, we note that InfoWord is simpler to train and exhibits similar
trends to SpanBERT that outperforms baseline models. We leave exhaustive comparisons to these
methods to future work.
Mutual information maximization. A recent study has questioned whether the success of In-
foNCE as an objective function is due to its property as a lower bound on mutual information and
provides an alternative hypothesis based on metric learning (Tschannen et al., 2019). Regardless of
the prevailing perspective, InfoNCE is widely accepted as a good representation learning objective,
and formulating state-of-the-art language representation learning methods under this framework
offers valuable insights that unifies many popular representation learning methods.
Regularization. Image representation learning methods often incorporate a regularization term in
its objective function to encourage learned representations to look like a prior distribution (Hjelm
et al., 2019; Bachman et al., 2019). This is useful for incorporating prior knowledge into a repre-
sentation learning model. For example, the DeepInfoMax model has a term in its objective that
encourages the learned representation from the encoder to match a uniform prior. Regularization is
not commonly used when learning language representations. Our analysis and the connection we
draw to representation learning methods used in other domains provide an insight into possible ways
to incorporate prior knowledge into language representation learning models.
Future directions. The InfoNCE framework provides a holistic way to view progress in language
representation learning. The framework is very flexible and suggests several directions that can be
explored to improve existing methods. We show that progress in the field has been largely driven by
innovations in the encoder which forms gω . InfoNCE is based on maximizing the mutual information
between different views of an input data, and it facilitates training on structured views as long as
we can perform negative sampling (van den Oord et al., 2019; Bachman et al., 2019). Our analysis
demonstrates that existing methods based on language modeling objectives only consider a single
target word as one of the views. We think that incorporating more complex views (e.g., higher-order
or skip n-grams, syntactic and semantic parses, etc.) and designing appropriate self-supervised tasks
8
Published as a conference paper at ICLR 2020
Figure 1: The left plot shows F1 scores of BERT-NCE and INFOWORD as we increase the percentage
of training examples on SQuAD (dev). The right plot shows F1 scores of INFOWORD on SQuAD
(dev) as a function of λDIM.
is a promising future direction. A related area that is also underexplored is designing methods to
obtain better negative samples.
6	Conclusion
We analyzed state-of-the-art language representation learning methods from the perspective of
mutual information maximization. We provided a unifying view of classical and modern word
embedding models and showed how they relate to popular representation learning methods used in
other domains. We used this framework to construct a new self-supervised task based on maximizing
the mutual information between the global representation and local representations of a sentence. We
demonstrated the benefit of this new task via experiments on GLUE and SQuAD.
References
Sanjeev Arora, Hrishikesh Khandeparkar, Mikhail Khodak, Orestis Plevrakis, and Nikunj Saunshi. A
theoretical analysis of contrastive unsupervised representation learning. In Proc. of ICML, 2019.
Philip Bachman, R Devon Hjelm, and William Buchwalter. Learning representations by maximizing
mutual information across views. arXiv preprint 1906.00910, 2019.
Mohamed Ishmael Belghazi, Aristide Baratin, Sai Rajeswar, Sherjil Ozair, Yoshua Bengio, Aaron
Courville, and R Devon Hjelm. Mine: Mutual information neural estimation. In Proc. of ICML,
2018.
Andrew M. Dai and Quoc V. Le. Semi-supervised sequence learning. In Proc. of NIPS, 2015.
Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc V. Le, and Ruslan Salakhutdinov.
Transformer-XL: Attentive language models beyond a fixed-length context. In Proc. of ACL, 2019.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep
bidirectional transformers for language understanding. In Proc. of NAACL, 2018.
M. D. Donsker and S. R. S. Varadhan. Asymptotic evaluation of certain markov process expectations
for large time. iv. Communications on Pure and Applied Mathematics, 36(2):183—212, 1983.
Michael U. Gutmann and Aapo Hyvarinen. Noise-contrastive estimation of unnormalized statistical
models, with applications to natural image statistics. Journal of Machine Learning Research, 13:
307—361,2012.
R Devon Hjelm, Alex Fedorov, Samuel Lavoie-Marchildon, Karan Grewal, Phil Bachman, Adam
Trischler, and Yoshua Bengio. Learning deep representations by mutual information estimation
and maximization. In Proc. of ICLR, 2019.
Jeremy Howard and Sebastian Ruder. Universal language model fine-tuning for text classification. In
Proc. of ACL, 2018.
9
Published as a conference paper at ICLR 2020
Mandar Joshi, Danqi Chen, Yinhan Liu, Daniel S. Weld, Luke Zettlemoyer, and Omer Levy. Span-
BERT: Improving pre-training by representing and predicting spans. arXiv preprint 1907.10529,
2019.
Diederik P. Kingma and Jimmy Lei Ba. Adam: a method for stochastic optimization. In Proc. of
ICLR, 2015.
Guillaume Lample and Alexis Conneau. Cross-lingual language model pretraining. arXiv preprint
1901.07291, 2019.
Ralph Linsker. Self-organization in a perceptual network. Computer,21(3):105-117, 1988.
Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike
Lewis, Luke Zettlemoyer, and Veselin Stoyanov. RoBERTa: A robustly optimized bert pretraining
approach. arXiv preprint 1907.11692, 2019.
Lajanugen Logeswaran and Honglak Lee. An efficient framework for learning sentence representa-
tions. In Proc. of ICLR, 2018.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. Distributed representa-
tions of words and phrases and their compositionality. In Proc. of NIPS, 2013.
Andriy Mnih and Koray Kavukcuoglu. Learning word embeddings efficiently with noise-contrastive
estimation. In Proc. of NIPS, 2013.
Sebastian Nowozin, Botond Cseke, , and Ryota Tomioka. f-gan: Training generative neural samplers
using variational divergence minimization. In Proc. of NIPS, 2016.
Sindy Lowe Peter O’Connor and Bastiaan S. Veeling. Greedy infomax for biologically plausible
self-supervised representation learning. In Proc. of NeurIPS, 2019.
Liam Paninski. Estimation of entropy and mutual information. Neural computation, 15(6):1191—-
1253, 2003.
Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word
representation. In Proc. of EMNLP, 2014.
Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and
Luke Zettlemoyer. Deep contextualized word representations. In Proc. of NAACL, 2018.
Ben Poole, Sherjil Ozair, Aaron van den Oord, Alexander A. Alemi, and George Tucker. On
variational lower bounds of mutual information. In Proc. of ICML, 2019.
Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving language under-
standing by generative pre-training. Technical report, OpenAI, 2018.
Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language
models are unsupervised multitask learners. Technical report, OpenAI, 2019.
Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and Percy Liang. SQuAD: 100,000+ questions
for machine comprehension of text. In Proc. of EMNLP, 2016.
Pranav Rajpurkar, Robin Jia, and Percy Liang. Know what you don’t know: Unanswerable questions
for squad. In Proc. of ACL, 2018.
Kaitao Song, Xu Tan, Tao Qin, Jianfeng Lu, and Tie-Yan Liu. MASS: Masked sequence to sequence
pre-training for language generation. In Proc. of ICML, 2019.
Michael Tschannen, Josip Djolonga, Paul K. Rubenstein, and Sylvain Gelly. On mutual information
maximization for representation learning. arXiv preprint 1907.13625, 2019.
Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive
coding. arXiv preprint 1807.03748, 2019.
10
Published as a conference paper at ICLR 2020
Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman.
GLUE: A multi-task benchmark and analysis platform for natural language understainding. In
Proc. of ICLR, 2019.
Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, and Quoc V.
Le. XLNet: Generalized autoregressive pretraining for language understanding. arXiv preprint
1906.08237, 2019.
Dani Yogatama, Cyprien de Masson d’Autume, Jerome Connor, Tomas Kocisky, Mike Chrzanowski,
Lingpeng Kong, Angeliki Lazaridou, Wang Ling, Lei Yu, Chris Dyer, and Phil Blunsom. Learning
and evaluating general linguistic intelligence. arXiv preprint 1901.11373, 2019.
A	Next Sentence Prediction
We show that the next sentence prediction objective used in BERT is an instance of contrastive
learning in this section. In next sentence prediction, given two sentences x1 and x2, the task is to
predict whether these are two consecutive sentences or not. Training data for this task is created by
sampling a random second sentence X2 from the corpus to be used as a negative example 50% of the
time.
Consider a discriminator (i.e., a classifier with parameters φ) that takes encoded representations of
concatenated x1 and x2 and returns a score. We denote this discriminator by dφ(x1, x2). The next
sentence prediction objective function is:
Ep(χi,χ2) [log dφ(gω ([x1, X2)])+lθg(1- dφ(gω ([x1, X2])))].
This objective function—which is used for training BERT—is known in the literature as “local” Noise
Contrastive Estimation (Gutmann & Hyvarinen, 2012). Since summing over all possible negative
sentences is intractable, BERT approximates this by using a binary classifier to distinguish real
samples and noisy samples.
An alternative approximation to using a binary classifier is to use “global NCE”, which is what
InfoNCE is based on. Here, we have:
Ep(χi,χ2) ψ>gω ([X1, X2)]) — log £ exp(ψ>(gω ([x1, X2]))),
_	x2∈X2	_
where we sample negative sentences from the corpus and combine it with the positive sentence to
construct X2. To make the connection of this objective function with InfoNCE in Eq. 1 explicit, let
a and b be two consecutive sentences X1 and X2. Let fθ(a, b) be ψ>gω ([a, b]), where ψ ∈ Rd is
a trainable parameter, [a, b] denotes a concatenation of a and b. Consider a Transformer encoder
parameterized by ω, and let gω([a, b]) ∈ Rd be a function that returns the final hidden state of the
first token after running the concatenated sequence to the Transformer. Note that the encoder that
we want to learn only depends on gω, so both of these approximations can be used for training next
sentence prediction.
B Hyperparameters
Pretraining. We use Adam (Kingma & Ba, 2015) with β1 = 0.9, β2 = 0.98 and = 1e - 6. The
batch size for training is 1024 with a maximum sequence length of 512. We train for 400,000 steps
(including 18,000 warmup steps) with a weight decay rate of 0.01. We set the learning rate to 4e-4
for all variants of the BASE models and 1e-4 for the LARGE models. We set λMLM to 1.0 and tune
λDIM ∈ {0.4, 0.6, 0.8, 1.0}.
GLUE. We set the maximum sequence length to 128. For each GLUE task, we use the respective
development set to choose the learning rate from {5e-6, 1e-5, 2e-5, 3e-5, 5e-5}, and the batch size
from {16, 32}. The number of training epochs is set to 4 for CoLA and 10 for other tasks, following
Joshi et al. (2019). We run each hyperparameter configuration 5 times and evaluate the best model on
the test set (once).
11
Published as a conference paper at ICLR 2020
SQuAD. We set the maximum sequence length to 512 and train for 4 epochs. We use the develop-
ment set to choose the learning rate from {5e-6, 1e-5, 2e-5, 3e-5, 5e-5} and the batch size from
{16, 32}.
C Question Answering Decoder
We use a standard span predictor as follows. Denote the length of the context paragraph by M,
and xcontext = {xc1ontext, . . . , xcMontext}. Denote the encoded representation of the m-th token in
the context by xtc,omntext. The question answering decoder introduces two sets of parameters: wstart
and wend. The probability of each context token being the start of the answer is computed as:
exp(wstartxtθmxt)
PM=0 exp(w>txt,next).
p(start = xtc,omntext | xt)
The probability of the end index of the answer is
computed analogously using wend. The predicted answer is the span with the highest probability after
multiplying the start and end probabilities.
12