Published as a conference paper at ICLR 2020
AN EXPONENTIAL LEARNING RATE S CHEDULE FOR
DEEP LEARNING
Zhiyuan Li
Princeton University
Sanjeev Arora
Princeton University and Institute for Advanced Study
Zhiyuanli@cs.princeton.edu arora@cs.princeton.edu
ABSTRACT
Intriguing empirical evidence exists that deep learning can work well with exotic
schedules for varying the learning rate. This paper suggests that the phenomenon
may be due to Batch Normalization or BN(Ioffe & Szegedy, 2015), which is ubiq-
uitous and provides benefits in optimization and generalization across all standard
architectures. The following new results are shown about BN with weight decay
and momentum (in other words, the typical use case which was not considered in
earlier theoretical analyses of stand-alone BN (Ioffe & Szegedy, 2015; Santurkar
et al., 2018; Arora et al., 2018)
•	Training can be done using SGD with momentum and an exponentially in-
creasing learning rate schedule, i.e., learning rate increases by some (1 + α)
factor in every epoch for some α > 0. (Precise statement in the paper.) To
the best of our knowledge this is the first time such a rate schedule has been
successfully used, let alone for highly successful architectures. As expected,
such training rapidly blows up network weights, but the network stays well-
behaved due to normalization.
•	Mathematical explanation of the success of the above rate schedule: a rigor-
ous proof that it is equivalent to the standard setting of BN + SGD + Standard
Rate Tuning + Weight Decay + Momentum. This equivalence holds for other
normalization layers as well, Group Normalization(Wu & He, 2018), Layer
Normalization(Ba et al., 2016), Instance Norm(Ulyanov et al., 2016), etc.
•	A worked-out toy example illustrating the above linkage of hyper-
parameters. Using either weight decay or BN alone reaches global minimum,
but convergence fails when both are used.
1	INTRODUCTION
Batch Normalization (BN) offers significant benefits in optimization and generalization across archi-
tectures, and has become ubiquitous. Usually best performance is attained by adding weight decay
and momentum in addition to BN.
Usually weight decay is thought to improve generalization by controlling the norm of the parameters.
However, it is fallacious to try to separately think of optimization and generalization because we are
dealing with a nonconvex objective with multiple optima. Even slight changes to the training surely
lead to a different trajectory in the loss landscape, potentially ending up at a different solution! One
needs trajectory analysis to have a hope of reasoning about the effects of such changes.
In the presence of BN and other normalization schemes, including GroupNorm, LayerNorm, and
InstanceNorm, the optimization objective is scale invariant to the parameters, which means rescaling
parameters would not change the prediction, except the parameters that compute the output which
do not have BN. However, Hoffer et al. (2018b) shows that fixing the output layer randomly doesn't
harm the performance of the network. So the trainable parameters satisfy scale invariance.(See
more in Appendix E) The current paper introduces new modes of analysis for such settings. This
rigorous analysis yields the surprising conclusion that the original learning rate (LR) schedule and
weight decay(WD) can be folded into a new exponential schedule for learning rate: in each iteration
multiplying it by (1 + α) for some α > 0 that depends upon the momentum and weight decay rate.
1
Published as a conference paper at ICLR 2020
Theorem 1.1 (Main, Informal). SGD on a scale-invariant objective with initial learning rate η,
weight decay factor λ, and momentum factor Y is equivalent to SGD with momentum factor Y
where at iteration t, the learning rate % in the new exponential learning rate schedule is defined as
ηt = α-2t-1η without weight decay(λ = 0) where α is a non-zero root of equation
x2 — (1 + γ — λη)x + γ = 0,	(1)
Specifically, when momentum Y = 0, the above schedule can be simplified as % = (1 - λη)-2t-1 η.
The above theorem requires that the product of learning rate and weight decay factor, λr∣, is small
than (1 — √Y)2, which is almost always satisfied in practice. The rigorous and most general version
of above theorem is Theorem 2.12, which deals with multi-phase LR schedule, momentum and
weight decay.
There are other recently discovered exotic LR schedules, e.g. Triangular LR schedule(Smith, 2017)
and Cosine LR schedule(Loshchilov & Hutter, 2016), and our exponential LR schedule is an extreme
example of LR schedules that become possible in presence of BN. Such an exponential increase in
learning rate seems absurd at first sight and to the best of our knowledge, no deep learning success
has been reported using such an idea before. It does highlight the above-mentioned viewpoint that
in deep learning, optimization and regularization are not easily separated. Of course, the exponent
trumps the effect of initial lr very fast (See Figure 4), which explains why training with BN and
WD is not sensitive to the scale of initialization, since with BN, tuning the scale of initialization is
equivalent to tuning the initial LR r while fixing the product of LR and WD, rλ (See Lemma 2.7).
Note that it is customary in BN to switch to a lower LR upon reaching a plateau in the validation
loss. According to the analysis in the above theorem, this corresponds to an exponential growth
with a smaller exponent, except for a transient effect when a correction term is needed for the two
processes to be equivalent (see discussion around Theorem 2.12).
Thus the final training algorithm is roughly as follows: Start from a convenient LR like 0.1, and
grow it at an exponential rate with a suitable exponent. When validation loss plateaus, Switch to
an exponential growth of LR with a lower exponent. Repeat the procedure until the training loss
saturates.
In Section 3, we demonstrate on a toy example how weight decay and normalization are inseparably
involved in the optimization process. With either weight decay or normalization alone, SGD will
achieve zero training error. But with both turned on, SGD fails to converge to global minimum.
In Section 4, we experimentally verify our theoretical findings on CNNs and ResNets. We also
construct better exponential LR schedules by incorporating the Cosine LR schedule on CIFAR10,
which opens the possibility of even more general theory of rate schedule tuning towards better
performance.
1.1	Related Work
There have been other theoretical analyses of training models with scale-invariance. (Cho & Lee,
2017) proposed to run Riemanian gradient descent on Grassmann manifold G(1,n) since the weight
matrix is scaling invariant to the loss function. observed that the effective stepsize is proportional to
虚2.(Arora et al., 2019) show the gradient is always perpendicular to the current parameter vector
which has the effect that norm of each scale invariant parameter group increases monotonically,
which has an auto-tuning effect. (WU et al., 2018) proposes a new adaptive learning rate schedule
motivated by scale-invariance property of Weight Normalization.
Previous work for understanding Batch Normalization. (Santurkar et al., 2018) suggested that
the success of BNhas does not derive from reduction in Internal Covariate Shift, but by making
landscape smoother. (Kohler et al., 2018) essentially shows linear model with BN could achieve
exponential convergence rate assuming gaussian inputs, but their analysis is for a variant of GD
with an inner optimization loop rather than GD itself. (Bjorck et al., 2018) observe that the higher
learning rates enabled by BN empirically improves generalization. (Arora et al., 2019) prove that
with certain mild assumption, (S)GD with BN finds approximate first order stationary point with any
fixed learning rate. None of the above analyses incorporated weight decay, but (Zhang et al., 2019;
Hoffer et al., 2018a; van Laarhoven, 2017) argued qualitatively that weight decay makes parameters
2
Published as a conference paper at ICLR 2020
have smaller norms, and thus the effective learning rate, IWwP is larger. They described experiments
showing this effect but didn't have a closed form theoretical analysis like ours. None of the above
analyses deals with momentum rigorously.
1.2	Preliminaries and Notations
For batch B = {xi}B=ι, network parameter θ, We denote the network by fθ and the loss function at
iteration t by Lt(fθ) = L(fθ, Bt) . When there's no ambiguity, We also use Lt(θ) for convenience.
We say a loss function L(θ) is scale invariant to its parameter θ is for any C ∈ R+, L(θ) =
L(cθ). In practice, the source of scale invariance is usually different types of normalization layers,
including Batch Normalization (Ioffe & Szegedy, 2015), Group Normalization (WU & He, 2018),
Layer Normalization (Ba et al., 2016), Instance Norm (Ulyanov et al., 2016), etc.
Implementations of SGD with MOmentUm/Nesterov comes with subtle variations in literature. We
adopt the variant from Sutskever et al. (2013), also the default in PyTorch (Paszke et al., 2017). L2
regularization (a.k.a. Weight Decay) is another common trick used in deep learning. Combining
them together, we get the one of the mostly used optimization algorithms below.
Definition 1.2. [SGD with Momentum and Weight Decay] At iteration t, with randomly sampled
batch Bt, update the parameters θt and momentum Vt as following:
θt =θt-ι - ηt-ιvt
Vt =γvt-ι + Vθ ^Lt(θt-ι) + ^-1 ∣∣θt-ι∣∣2),
⑵
⑶
where η is the learning rate at epoch t, Y is the momentum coefficient, and λ is the factor of weight
decay. Usually, v° is initialized to be 0.
For ease of analysis, we will use the following equivalent of Definition 1.2.
「= Y θʒtɪ-2-J "θt-1) + " ∣”2),
where η-ι and θ-ι must be chosen in a way such that v0 = θ0-θ-1 is satisfied, e.g. when v0
θ-ι = θo and η-ι could be arbitrary.
(4)
0,
A key source of intuition is the following simple lemma about scale-invariant networks Arora
et al. (2019). The first property ensures GD (with momentum) always increases the norm of the
weight.(See Lemma C.1 in Appendix C) and the second property says that the gradients are smaller
for parameteres with larger norm, thus stabilizing the trajectory from diverging to infinity.
Lemma 1.3 (Scale Invariance). Iffor any C ∈ R+, L(θ) = L(cθ), then
(1)	. (VθL, θ = 0;	一
(2)	. VeLlθ=θ0 = cvθLlθ=cθ0,forany c>0
2 DERIVING Exponential Learning RATE Schedule
As a warm-up in Section 2.1 we show that if momentum is turned off then Fixed LR + Fixed WD
can be translated to an equivalent ExponentiaI LR. In Section 2.2 we give a more general analysis
on the equivalence between Fixed LR + Fixed WD + Fixed Momentum Factor and Exponential
LR + Fixed Momentum Factor. While interesting, this still does completely apply to real-life deep
learning where reaching full accuracy usually requires multiple phases in training where LR is fixed
within a phase and reduced by some factor from one phase to the next. Section 2.3 shows how to
interpret such a multi-phase LR schedule + WD + Momentum as a certain multi-phase exponential
LR schedule with Momentum.
2.1	Replacing WD by Exponential LR in Momentum-Free SGD
We use notation of Section 1.2 and assume LR is fixed over iterations, i.e. ηt = η0, and Y (momen-
tum factor) is set as 0. We also use λ to denote WD factor and θ° to denote the initial parameters.
3
Published as a conference paper at ICLR 2020
The intuition should be clear from Lemma 1.3, which Says that shrinking parameter weights by factor
P (where P < 1) amounts to making the gradient ρ-1 times larger without changing its direction.
Thus in order to restore the ratio between original parameter and its update (LR× Gradient), the
easiest way would be scaling LR by ρ2. This suggests that scaling the parameter θ by P at each step
is equivalent to scaling the LR η by ρ-2.
To prove this formally we use the following formalism. We’ll refer to the vector (θ, η) the state of
a training algorithm and study how this evolves under various combinations of parameter changes.
We will think of each step in training as a mapping from one state to another. Since mappings can be
composed, any finite number of steps also correspond to a mapping. The following are some basic
mappings used in the proof.
1.	Run GD with WD for a step:
2.	Scale the parameter θ:
3.	Scale the LR η:
GDp(θ, η) = (ρθ - ηVLt(θ), η);
∏1(θ, η) = (cθ, η);
∏2(θ, η) = (θ,cη).
For example, when P = 1, GD1 is vanilla GD update without WD, also abbreviated as GDt. When
ρ = 1 — λη0, GD1-λn0 is GD update with WD λ and LR η0. Here LtiS the loss function at iteration
t, which is decided by the batch of the training samples Bt in tth iteration. Below is the main result
of this subsection, showing our claim that GD + WD ⇔ GD+ ExP LR (when Momentum is zero).
It will be proved after a series of lemmas.
Theorem 2.1 (WD ⇔ Exp LR). For every P < 1 and positive integer t following holds:
一2
GDp-ι ◦…◦ GDp = [∏p ◦ Πp ] ◦ Πp	◦ GDt-i ◦ Πp
-	-J.
◦…◦ GDi ◦ Πp ◦ GDo ◦ Πp .
-1
With WD being λ, P is set as 1 — ληo and thus the scaling factor of LR per iteration is ρ-2 =
(1 — ληo)-2, except for the first iteration it's ρ-i = (1 — ληo)-i.
We first show how to write GD update with WD as a composition of above defined basic maps.
Lemma 2.2. GDP = Πp ◦ Πp ◦ GDt ◦ Πp .
Below we will define the proper notion of equivalence such that (1). Πp 〜Πp , which implies
GDp 〜Πp	◦ GDt ◦ Πp ; (2) the equivalence is preserved under future GD updates.
We first extend the equivalence between weights (same direction) to that between states, with addi-
tional requirement that the ratio between the size of GD update and that of parameter are the same
among all equivalent states, which yields the notion of Equivalent Scaling.
Definition 2.3 (Equivalent States).	(θ, η) is equivalent to	(θ',	η')	iff	∃c	>	0,	(θ, η)	=	[∏1	◦
2	c	2
∏2 ](θ,η) = (cθ,c2η), which is also denoted by (θ,η)〜(θ,η). Πf ◦ ∏2 is called Equiva-
lent Scaling for all C > 0.
The following lemma shows that equivalent scaling commutes with GD update with WD, implying
that equivalence is preserved under GD update (Lemma 2.4). This anchors the notion of equiv-
alence —we could insert equivalent scaling anywhere in a sequence of basic maps(GD update,
LR/parameter scaling), without changing the final network.
Lemma 2.4. For any constant c, ρ > 0 and t ≥ 0, GDP ◦ [∏1 ◦ ∏22] = [∏1 ◦ ∏22] ◦ GDP.
In other words, (θ, η)〜(θ', η') =⇒ GDp(θ, η)〜GDp(θ', η').
Now we formally define equivalence relationship between maps using equivalent scalings.
Definition 2.5 (Equivalent Maps). Two maps F, G are equivalent iff ∃c > 0, F = ∏C ◦ ∏22 ◦ G,
which is also denoted by F 〜G.
:◦ GDt ◦ Πp . By Lemma 2.4, GD update
'〜GDp ◦ G, ∀c, ρ > 0. Thus,
Proof of Theorem 2.1. By Lemma 2.2,, GDp 〜 Πp
preserves map equivalence, i.e. F 〜G ⇒ GDP ◦ F
GDp-1 ◦…◦ GDp 〜 ∏p-1 ◦ GDt-1 ◦ ∏p-2
c-2	--I
◦…◦ GDi ◦ Πp	◦ GDo ◦ Πp	.
□
4
Figure 1: Taking PreReSNet32 with standard hyperparameters and replacing WD during first phase (Fixed LR)
by exponential LR according to Theorem 2.9 to the schedule ηt = 0.1 X 1.481t, momentum 0.9. Plot on
right shows weight norm W of the first convolutional layer in the second residual block grows exponentially,
satisfying HwtH = constant. Reason being that according to the proof it is essentially the norm square of
the weights when trained with Fixed LR + WD + Momentum, and published hyperparameters kept this norm
roughly constant during training.
2.2	REPLACING WD BY EXPONENTIAL LR: CASE OF CONSTANT LR WITH MOMENTUM
In this subsection the setting is the same to that in Subsection 2.1 except that the momentum fac-
tor is Y instead of 0. Suppose the initial momentum is v0, We set θ-1 = θ0 - v0η. Presence
of momentum requires representing the state of the algorithm with four coordinates, (θ, η, θ’, η'),
which stand respectively for the current Parameters/LR and the buffered parameters/LR (from last
iteration) respectively. Similarly, we define the following basic maps and equivalence relationships.
1.	Run GD with WD for a step:
2.	Scale Current parameter θ
3.	Scale Current LR η:
4.	Scale Buffered parameter θ':
5.	Scale Buffered parameter η':
GDP(θ, η, θ', η') = (ρθ + η (γθ-θ - NL(θ)), η, θ, η);
π1 (θ, η, θ', η') = (Cθ, η, θ', η');
∏2 (θ, η, θ', η') = (θ,cη, θ', η');
π3(θ, η, θ', η') = (θ, η ,cθ', η');
π4(θ, η, θ', η') = (θ, η, θ' ,cη').
Definition 2.6 (Equivalent States). (θ, η, θ', η') is equivalent to (θ, η, θ', η) iff ∃c >
[2	2
∏ι ◦ ∏2 ◦ ∏3 ◦ ∏4 I (θ, η, θ', η') = (cθ, c1 2η, cθ', c2η'), which is also denoted
by (θ, η, θ', η') 工(θ, η, θ', ηf). We call ∏1 ◦ ∏22 ◦ ∏3 ◦ ∏42 Equivalent Scalings for all c > 0.
Again by expanding the definition, we show equivalent scalings commute with GD update.
Lemma 2.7. ∀c, P > 0 and t ≥ 0, GDP ◦ [∏f ◦ ∏22 ◦ ∏3 ◦ ∏42] = [∏f ◦ ∏22 ◦ ∏3 ◦ ∏42] ◦ GDP.
Similarly, we can rewrite GDP as a composition of vanilla GD update and other scalings by expand-
ing the definition, when the current and buffered LR are the same in the input of GDP.
Lemma 2.8. For any input (θ, η, θ', η), if a > 0 is a root of α + γα-1 = P + γ, then
GD P (θ, η, θ', η) = [∏? ◦ ∏ɑ ◦ ∏ι ◦ GD t ◦ ∏a 1 ◦ ∏ɑ ◦ ∏α] (θ, η, θ', η). In other words,
Gd P (θ, η, θ ', η) 工[∏α-1 ◦ ∏α-1 ◦ ∏α-1 ◦ GD t ◦ ∏α-1 ◦ ∏α ◦ ∏α ] (θ, η, θ ', η).	⑸
Though looking complicated, the RHS of Equation 5 is actually the desired Ta 1 ◦ GDt ◦ ∏α 1
-1	-1 .
conjugated with some scaling on momentum part ∏α ◦ ∏a, and ∏α ◦ ∏a in the current update
cancels with the ∏α ◦ ∏a in the next update. Now we are ready to show the equivalence between
WD and Exp LR schedule when momentum is turned on for both.
Theorem 2.9 (GD + WD ⇔ GD+ Exp LR; With Momentum). The following defined two sequences
of parameters ,{θt }∞=0 and {θt }∞=0, satisfy θt = αtθt, thus they correspond to the same networks
in function space, i.e. fθt = f^, ∀t ∈ N, given θ0 = θ0, θ-1 = θ-1 α, and ηt = η0α 2t 1.
1. θt-θ-1 = γ(θt-n-θt-2) - Vθ(L(θt-1) + 2I∣θt-11∣2)
≈	≈	Z ≈	CT	、	一.
2. θt-θt-1 = γ(θt-t-θt-2) - VθL(θt-ι)
5
Figure 2: PreReSNet32 trained with standard Step Decay and its corresponding TaPered-EXPonential LR sched-
ule. AS predicted by Theorem 2.12, they have similar trajectories and performances.
where α is a positive root of equation x2 - (1 + Y - λη0)x + Y = 0, which is always smaller than
1(See Appendix B.1). When γ = 0, α = 1 — λη0 is the unique non-zero solution.
Remark 2.10. Above We implicitly assume that λη0 ≤ (1 — √γ)2 such that the roots are real and
this is always true in practice. For instance of standard hyper-parameters where Y = 0.9, η0 二
0.1, λ = 0.0005, (1-λ√0γ)2 ≈ 0.019 ≪ 1.
Proof. Note that (θ0, ηj0, θ-1, ηj-1) = [∏α 1 ◦ ∏ɑ ◦ ∏" (θ0, η0, θ0, η0), it suffices to show that
InaTO ∏α-1 ◦ ∏α-1 ◦ GDt-1 ◦ ∏α-2 ◦…◦ GD1 ◦ ∏α-2 ◦ GD0 ◦ ∏α-1 ◦ ∏α ◦ ∏j (θ0, η0, θ0, η0)
火 GD1-λη0 ◦…◦ GD1-λη0 (θo, no, θo, no), Vt ≥ 0.
which follows immediately from Lemma 2.7 and Lemma 2.8 by induction.
□
2.3	REPLACING WD BY EXPONENTIAL LR: CASE OF MULTIPLE LR PHASES
Usual practice in deep learning shows that reaching full training accuracy requires reducing the
learning rate a few times.
Definition 2.11. Step Decay is the (standard) learning rate schedule, where training has K phases
I = 0,1,..., K — 1, where phase I starts at iteration TI (T0 = 0), and all iterations in phase I use
a fixed learning rate of nI.
The algorithm state in Section 2.2, consists of 4 components including buffered and current LR.
When LR changes, the buffered and current LR are not equal, and thus Lemma 2.8 cannot be applied
any more. In this section we show how to fix this issue by adding extra momentum correction.
In detail, we show the below defined Exp LR schedule leads the same trajectory of networks in
function space, with one-time momentum correction at the start of each phase. We empirically find
on CIFAR10 that ignoring the correction term does not change performance much.
Theorem 2.12 (Tapered-Exponential LR Schedule). There exists a way to correct the momentum
only at the first iteration of each phase, such that the following Tapered-Exponential LR schedule
(TEXP) {ηt} with momentum factor Y and no WD, leads the same sequence networks in function
space as that of Step Decay LR schedule(Definition 2.11) with momentum factor Y and WD λ.
n	× nt-1	×	(αj-ι )-2	if TI-1 + 1 ≤ t ≤ TI —	1,I ≥ 1;
Th =	W-I	×	匹 × (αI)-1 (αj-ι)-1	if t = TI,I ≥ 1,
(6)
where αI = 1+γληI+"；+，-M) -", % = n ∙ (α^)-1 =隔∙ (α0)-1.
The analysis in previous subsection give the equivalence within each phase, where the same LR
is used throughout the phase. To deal with the difference between buffered LR and current LR
when entering new phases, the idea is to pretend nt-1 = nt and θt-1 becomes whatever it needs
to maintain θt-θt-1 such that we can again apply Lemma 2.8, which requires the current LR of
the input state is equal to its buffered LR. Because scaling α in RHS of Equation 5 is different
in different phases, so unlike what happens within each phase, they don,t cancel with each other
at phase transitions, thus remaining as a correction of the momentum. The proofs are delayed to
Appendix B, where we proves a more general statement allowing phase-dependent WD, {λI}K=-01.
6
Published as a conference paper at ICLR 2020
Alternative interpretation of Step Decay to exponential LR schedule:Below We present a new
LR schedule, TEXP++, which is exactly equivalent to Step Decay without the need of one-time
correction of momentum when entering each phase. We further show in Appendix B.1 that when
translating from Step Decay, the TEXP++ we get is very close to the original TEXP(Equation 9),
η',
i	.e. the ratio between the LR growth per round, ¾+1 / -t+1 converges to 1 exponentially each phase.
For example, with WD 0.0005, max LR 0.1, momentum factor 0.9, the ratio is within 1 ± 0.0015 *
0.9t-τI, meaning TEXP and TEXP++ are very close for Step Decay with standard hyperparameters.
Theorem 2.13. The following two sequences of parameters ,{θt}∞=0 and {θt}∞=o, define the same
sequence of network functions, i.e. fθt = fg , ∀t ∈ N, given the initial conditions, θ0 = P0θo,
θ-ι = P-1θ-1.
1.	θη-- = Y θt-tθ2- - Vθ ((L(θt-ι) + λt2-1 I∣θt-1112), for t = 1,2,...;
不不	不 K.
2.	θt---1 = Yθt--θ	- VθL(θt-ι), for t = 1,2,...,
t
where 加 = PtPt+ιnt, Pt = ∏ α-1, ∀t ≥ —1 and αt recursively defined as
i=-1
αt = -ηt-ιλt-ι + 1 + -t γY(I - at-1),∀t ≥ 1.	⑺
ηt-2
The LR schedule {η⅛}∞=o is called Tapered Exponential ++, or TEXP++.
3 Example illustrating interplay of WD and BN
The paper so far has shown that effects of different hyperparameters in training are not easily sep-
arated, since their combined effect on the trajectory is complicated. We give a simple example
to illustrate this, where convergence is guaranteed if we use either BatchNorm or weight decay in
isolation, but convergence fails if both are used. (Momentum is turned off for clarity of presentation)
Setting: Suppose we are fine-tuning the last linear layer of the network, where the input of the last
layer is assumed to follow a standard Gaussian distribution N(0, Im), and m is the input dimension
of last layer. We also assume this is a binary classification task with logistic loss, l(u, y) = ln(1 +
exp(-uy)), where label y ∈ {-1,1} and U ∈ R is the output of the neural network. The training
algorithm is SGD with constant LR and WD, and without momentum. For simplicity we assume
the batch size B is very large so we could assume the covariance of each batch Bt concentrates and
is approximately equal to identity, namely B £3 xt,bxjb ≈ Im. We also assume the the input of
the last layer are already separable, and w.l.o.g. we assume the label is equal to the sign of the first
coordinate of X ∈ Rm, namely sign (xι). Thus the training loss and training error are simply
L(W) =	E	[ln(1 + exp(-xτwy))]
XZN(0,Im),y=sign(xι) L
Pr	[xτwy ≤ 0]
XZN(0,Im),y=sign(xι) L
ɪ arccos w1
π UwU
Case 1:	WD alone: Since both the above objective with L2 regularization is strongly convex and
smooth in w, vanilla GD with suitably small learning rate could get arbitrarily close to the global
minimum for this regularized objective. In our case, large batch SGD behaves similarly to GD and
can achieve O(∖ %) test error following the standard analysis of convex optimization.
Case 2:	BN alone: Add a BN layer after the linear layer, and fix scalar and bias term to 1 and 0. The
objective becomes
LBN (W)= XZN (0,ImEy=sign(χι) [LbN (W, X)] = XZN (0/,^=sign(χ	In(I + exp(TT 得 y))
From Appendix B.6, there's some constant C, such that ∀w ∈ Rm with constant prob-
ability, ∣∣VwLBN(W,X)U ≥ 高.By Pythagorean Theorem, Uwt+ιU4 = (UwtU2 +
η2 UVwLbn (wt, x)U2)2 ≥ UWtU4 + 2η2UwtU2UVw LBN (wt, x)U2. As a result, for any fixed
learning rate, U Wt+ι U4 ≥ 2 £；=1 η2 U w U2 U NWLBN(Wi, x) U2 grows at least linearly with high
probability. Following the analysis of Arora et al. (2019), this is like reducing the effective learning
7
Published as a conference paper at ICLR 2020
rate, and When IlWtll is large enough, the effective learning rate is small enough, and thus SGD can
find the local minimum, which is the unique global minimum.
Case 3:	Both BN and WD: Suppose WD factor is λ, LR is η, we have the following theorem:
Theorem 3.1. [Nonconvergence] Starting from iteration any T0, with probability 1 一 δ over the
randomness of samples, the training error will be larger than ε at least once for the following
consecutive » J 2、ln 64'wT0' ε√B + 9ln 1 iterations.
2(ηλ-2ε2)	η √m-2	δ
Sketch. (See full proof in Appendix B.) The high level idea of this proof is that if the test error is
low, the weight is restricted in a small cone around the global minimum, and thus the amount of the
gradient update is bounded by the size of the cone. In this case, the growth of the norm of the weight
by Pythagorean Theorem is not large enough to cancel the shrinkage brought by weight decay. As a
result, the norm of the weight converges to 0 geometrically. Again we need to use the lower bound
for size of the gradient, that ∣Vw LtIl = Θ( nWm) holds with constant probability. Thus the size of
the gradient will grow along with the shrinkage OfIlWtIl until they're comparable, forcing the weight
to leave the cone in next iteration.	口
4	Experiments
The translation to exponential LR schedule is exact except for one-time momentum correction term
entering new phases. The experiments explore the effect of this correction term. The Tapered
Exponential(TEXP) LR schedule contains two parts when entering a new phase I: an instant LR
decay (nnI-^) and an adjustment of the growth factor (α}-ι → a；). The first part is relative small
compared to the huge exponential growing. Thus a natural question arises: Can we simplify TEXP
LR schedule by dropping the part of instant LR decay ?
Also, previously we have only verified our equivalence theorem in Step Decay LR schedules. But it's
not sure how would the Exponential LR schedule behave on more rapid time-varying LR schedules
such as Cosine LR schedule.
Settings: We train PreResNet32 on CIFAR10. The initial learning rate is 0.1 and the momentum
is 0.9 in all settings. We fix all the scalar and bias of BN, because otherwise they together with the
following conv layer grow exponentially, sometimes exceeding the range of Float32 when trained
with large growth rate for a long time. We fix the parameters in the last fully connected layer for
scale invariance of the objective.
4.1	THE BENEFIT OF INSTANT LR DECAY
We tried the following LR schedule (we call it TEXP--). Interestingly, up to correction of momentum
when entering a new phase, this schedule is equivalent to a constant LR schedule, but with the weight
decay coefficient reduced correspondingly at the start of each phase. (See TheoremB.2 and Figure 6)
texp .	-	_/加×(a；-i)-2	if T1-1 + 1 ≤ t ≤ TI-LI ≥ 1；
TEXP--:	ηt+1 = ⅛t× (M)T(M-JTift = Ti,I ≥ 1,
⑻
where a； = 1+γ-λnI+"；+…”I) -4γ, % =加∙ (a；)-1 =隔∙ (a；)-1.
4.2	Better Exponential LR Schedule with Cosine LR
We applied the TEXP LR schedule (Theorem 2.12) on the Cosine LR schedule (Loshchilov &
Hutter, 2016), where the learning rate changes every epoch, and thus correction terms cannot be
ignored. The LR at epoch t ≤ T is defined as: η = η0 1+co∣( Tπ). OUr experiments show this
hybrid schedule with Cosine LR performs better on CIFAR10 than Step Decay, but this finding
needs to be verified on other datasets.
5	Conclusions
The paper shows rigorously how BN allows a host of very exotic learning rate schedules in deep
learning, and verifies these effects in experiments. The lr increases exponentially in almost every
8
Published as a conference paper at ICLR 2020
Figure 3: Instant LR decay is crucial when LR growth ηt/ηt-ι -1 is very small. The original LR of Step Decay
is decayed by 10 at epoch 80,120 respectively. In the third phase, LR growth ηt/ηt-ι - 1 is approximately 100
times smaller than that in the third phase, it would take TEXP-- hundreds of epochs to reach its equilibrium. As
a result, TEXP achieves better test accuracy than TEXP--. As a comparison, in the second phase, ηt/ηt-ι — 1
is only 10 times smaller than that in the first phase and it only takes 70 epochs to return to equilibrium.
Figure 4: Instant LR decay has only temporary effect when LR growth ηt/ηt-ι — 1 is large. The blue line uses
an exponential LR schedule with constant exponent. The orange line multiplies its LR by the same constant
each iteration, but also divide LR by 10 at the start of epoch 80 and 120. The instant LR decay only allows the
parameter to stay at good local minimum for 1 epoch and then diverges, behaving similarly to the trajectories
without no instant LR decay.
Figure 5: Both Cosine and Step Decay schedule behaves almost the same as their exponential counterpart, as
predicted by our equivalence theorem. The (exponential) Cosine LR schedule achieves better test accuracy,
with a entirely different trajectory.
9
Published as a conference paper at ICLR 2020
iteration during training. The exponential increase derives from use of weight decay, but the precise
expression involves momentum as well. We suggest that the efficacy of this rule may be hard to
explain with canonical frameworks in optimization.
Our analyses of BN is a substantial improvement over earlier theoretical analyses, since it accounts
for weight decay and momentum, which are always combined in practice.
Our tantalising experiments with a hybrid of exponential and cosine rates suggest that more surprises
may lie out there. Our theoretical analysis of interrelatedness of hyperparameters could also lead to
faster hyperparameter search.
REFERENCES
Sanjeev Arora, Nadav Cohen, and Elad Hazan. On the optimization of deep networks: Implicit
acceleration by overparameterization. In International Conference on Machine Learning, pp.
244-253,2018.
Sanjeev Arora, Zhiyuan Li, and Kaifeng Lyu. Theoretical analysis of auto rate-tuning by batch
normalization. In International Conference on Learning Representations, 2019. URL https :
/ / openreview. net/ forum?id=rkxQ-nA9FX.
Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton. Layer normalization. arXiv preprint
arXiv:1607.06450, 2016.
Nils Bjorck, Carla P Gomes, Bart Selman, and Kilian Q Weinberger. Understanding batch normal-
ization. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett
(eds.), Advances in Neural Information Processing Systems 31, pp. 7705-7716. Curran Asso-
ciates, Inc., 2018.
Minhyung Cho and Jaehyung Lee. Riemannian approach to batch normalization. In I. Guyon, U. V.
Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in
Neural Information Processing Systems 30, pp. 5225-5235. Curran Associates, Inc., 2017.
Sanjoy Dasgupta and Anupam Gupta. An elementary proof of a theorem of johnson and linden-
strauss. Random Structures & Algorithms, 22(1):60-65, 2003.
Robert Mansel Gower, Nicolas Loizou, Xun Qian, Alibek Sailanbayev, Egor Shulgin, and Peter
Richtarik. Sgd: General analysis and improved rates. arXiv preprint arXiv:1901.09401, 2019.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778,2016a.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. In European conference on computer vision, pp. 630-645. Springer, 2016b.
Elad Hoffer, Ron Banner, Itay Golan, and Daniel Soudry. Norm matters: efficient and accurate
normalization schemes in deep networks. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman,
N. Cesa-Bianchi, and R. Garnett (eds.), Advances in Neural Information Processing Systems 31,
pp. 2164-2174. Curran Associates, Inc., 2018a.
Elad Hoffer, Itay Hubara, and Daniel Soudry. Fix your classifier: the marginal value of training
the last weight layer. In International Conference on Learning Representations, 2018b. URL
https ://openreview. net/forum?id=S1Dh8Tg0-.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. In International Conference on Machine Learning, pp. 448U56,
2015.
Jonas Kohler, Hadi Daneshmand, Aurelien Lucchi, Ming Zhou, Klaus Neymeyr, and Thomas Hof-
mann. Exponential convergence rates for batch normalization: The power of length-direction
decoupling in non-convex optimization. arXiv preprint arXiv:1805.10694, 2018.
10
Published as a conference paper at ICLR 2020
Ilya LoshchiloV and Frank Hutter. SGDR: Stochastic Gradient Descent with Warm Restarts. arXiv
e-prints, art. arXiv: 1608.03983, Aug 2016.
David Page. HoW to train your resnet 6: Weight decay? URL https://myrtle.ai/
how-to-train-your-resnet-6-weight-decay/.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
pytorch. 2017.
Shibani Santurkar, Dimitris Tsipras, Andrew Ilyas, and Aleksander Madry. How does batch nor-
malization help optimization? In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-
Bianchi, and R. Garnett (eds.), Advances in Neural Information Processing Systems 31, pp. 2488-
2498. Curran Associates, Inc., 2018.
Leslie N Smith. Cyclical learning rates for training neural networks. In 2017 IEEE Winter Confer-
ence on Applications of Computer Vision (WACV), pp. 464T72. IEEE, 2017.
Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of ini-
tialization and momentum in deep learning. In Proceedings of the 30th International Confer-
ence on International Conference on Machine Learning - Volume 28, ICML’13, pp. III-1139-
III-1147. JMLR.org, 2013. URL http ://dl. acm. org/citation. cfm?id=3042 817 .
3043064.
Dmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky. Instance normalization: The missing in-
gredient for fast stylization. arXiv preprint arXiv:1607.08022, 2016.
Twan van Laarhoven. L2 regularization versus batch and weight normalization. arXiv preprint
arXiv:1706.05350, 2017.
Xiaoxia Wu, Rachel Ward, and Leon Bottou. WNGrad: Learn the Learning Rate in Gradient De-
scent. arXiv preprint arXiv:1803.02865, 2018.
Yuxin Wu and Kaiming He. Group normalization. In The European Conference on Computer Vision
(ECCV), September 2018.
Yang You, Igor Gitman, and Boris Ginsburg. Large Batch Training of Convolutional Networks.
arXiv e-prints, art. arXiv: 1708.03888, Aug 2017.
Guodong Zhang, Chaoqi Wang, Bowen Xu, and Roger Grosse. Three mechanisms of weight decay
regularization. In International Conference on Learning Representations, 2019. URL https :
/ / openreview. net/ forum?id=B1lz-3Rct7.
11
Published as a conference paper at ICLR 2020
A VIEWING EXP LR VIA CANONICAL OPTIMIZATION FRAMEWORK
This section tries to explain Why the efficacy of exponential LR in deep learning is mysterious to us,
at least as viewed in the canonical framework of optimization theory.
Canonical framework for analysing 1st order methods This focuses on proving that each -^or
most-steps of GD noticeably reduce the objective, by relying on some assumption about the spec-
trum norm of the hessian of the loss, and most frequently, the smoothness, denoted by β. Specifically,
for GD update θt+ι = θt - ηVL(θt), we have
L(θt+ι) - L(θt) ≤ (θt+ι - θt)τVL(θt) + 2∣∣θt+ι - θt∣∣2 = -η(1 -整)∣∣VL(θt)∣∣2.
When β < 2, the first order term is larger than the second order one, guaranteeing the loss value
decreases. Since the analysis framework treats the loss as a black box (apart from the assumed
bounds on the derivative norms), and the loss is non-convex, the best one can hope for is to prove
speedy convergence to a stationary point (where gradient is close to 0). An increasing body of work
proves such results.
Now we turn to difficulties in understanding the exponential LR in context of the above framework
and with scale-invariance in the network.
1.	Since loss is same for θ and C ∙ θ for all c > 0 a simple calculation shows that along any
straight line through the origin, smoothness is a decreasing function of c, and is very high
close to origin. (Note: it is also possible to one can show the following related fact: In any
ball containing the origin, the loss is nonconvex.)
Thus if one were trying to apply the canonical framework to argue convergence to a sta-
tionary point, the natural idea would be to try to grow the norm of the parameters until
smoothness drops enough that the above-mentioned Canonical FrameWork starts to ap-
ply. Arora et al. (2019) showed this happens in GD with fixed LR (WD turned off), and
furthermore the resulting convergence rate to stationary point is asymptotically similar to
analyses of nonconvex optimization with learning rate set as in the Canonical framework.
Santurkar et al. (2018) observed similar phenomenon in experiments, which they described
as a smoothening of the objective due to BN.
2.	The Canonical Framework can be thought of as a discretization of continuous gradient
descent (i.e., gradient flow): in principle it is possible to use arbitrarily small learning rate,
but one uses finite learning rate merely to keep the number of iterations small. The discrete
process approximates the continuous process due to smoothness being small.
In case of gradient flow with weight decay (equivalently, with exponential LR schedule) the
discrete process cannot track the continuous process for very long, which suggests that any
explanation of the benefits of exponential LR may need to rely on discrete process being
somehow better. The reason being that for gradient flow one can decouple the speed of the
θt into the tangential and the radial components, where the former one has no effect on
the norm and the latter one has no effect on the objective but scales the tangential gradient
exponentially. Thus the Gradient Flow with WD gives exactly the same trajectory as vanilla
Gradient Flow does, excepting a exponential reparametrization with respect to time t.
3.	It can be shown that if the local smoothness is upperbounded by 2 (as stipulated in Canon-
ical Framework) during a sequence θt (t = 1, 2,...) of GD updates with WD and constant
LR then such sequence satisfies θt → 0. This contrasts with the usual experimental obser-
vation that θt stays bounded away from 0. One should thus conclude that in practice, with
constant LR and WD, smoothness doesn't always stay small (unlike the above analyses
where WD is turned off).
B	Omitted Proofs
B.1 Omitted Proof in Section 2
Lemma B.1 (Some Facts about Equation 1). Suppose z1,z2(z1 ≥ z2) are the two real roots of the
the following equation, we have
X2 — (1 + Y — λη)x + Y = o
12
Published as a conference paper at ICLR 2020
1.
Z1
ι+γ - λη+√ (i—γ)2-2(1+γ)λη+λ2η2
,Z2
ι+γ - λη - √ (i—γ)2-2(1+γ)λη+λ2η2
2
2
2.	z1,z2 are real 一⇒ λη ≤ (1 - √Y)2；
3.	z1z2 = γ,z1 + z2 = (1 + Y — λη);
4.	Y ≤ z2 ≤ z1 ≤ 1;
≥
1 -1
5.
Lett =法，we have z1 ≥ 1+t
λη
1-γ
6. if we view z1(λη), z2(λη) as functions of λη, then z1(λη) is monotone decreasing, z2(η)
is monotone increasing.
Proof.
4. Let f (x) = x2 — (1 + Y — λη)x + γ, We have f (1) = f (Y) = λη ≥ 0. Note the minimum
of f is taken at X = ι+γ-λη ∈
[0,1], the both roots of f (x) = 0 must lie between 0 and 1,
if exists.
5
1 z = 1 - γ + λη - v∕(1 - Y)2 - 2(1 + γ)λη + λ2η2
1 +t -	1 - 1-γt + t2
=(I - Y)
2
2t + 2 MY t
=(1 - Y)-----------/	Y+	=
2(1 + t + J-罟 t + t2)
ɪ t
≤ (1 - Y)4(⅛)
_ t
= (1 +1)
6.	Note that (z1 — z2)2 = (z1 + z2)2 — 4z1z2 = (1 + Y — λη)2 — 4y is monotone decreasing,
since z1(λη) + z2(λη) is constant, z1(λη) ≥ z2(λη), z1(λη) must be decreasing and
z2(λη) must be increasing.
□
B.2 Omitted proofs in Section 2.1
Proof of Lemma 2.2. For any (θ, η), we have
GDp(θ, η) = (ρθ - ηVLt (θ), η) = [∏ρ ◦ πρ ◦ GDt](θ,η) = [∏ρ ◦ πρ ◦ GDt ◦ Πp-1 ](θ, η).
P
Proof of Lemma 2.4. For any (θ, η), we have
[GDt ◦ ∏1 ◦ ∏22] (θ,η) = GDt(cθ,c2η) = (cθ - c2θVLt(cθ),c2η) = (c(θ -VLt(θ)),c2η)
=[∏1 ◦ ∏2 ◦ GDt] (θ, η).	( =: Scale Invariance, Lemma 1.3)	□
13
Published as a conference paper at ICLR 2020
B.3 Omitted proofs in Section 2.2
Proof of Lemma 2.7. For any input (θ, η, θ', r「), it's easy to check both composed maps have the
same outputs on the 2,3,4th coordinates, namely (c2r, cθ,c2r'). For the first coordinate, We have
θ — θ'	__
[GDρ(cθ, c2r, cθ , c2r)]1 = ρcθ + C2r (Y —‘	— NLt
=c [GDρ(θ, r, θ', r)]1 .	=: Scale Invariance, Lemma 1.3
θ + r(γθ-θ - W)))
□
Proof of Lemma 2.8. For any input (θ, r, θ', r'), it’s easy to check both composed maps have the
same outputs on the 2,3,4th coordinates, namely (r, θ, r). For the first coordinate, we have
[[∏α ◦ ∏α ◦ ∏α ◦ GDt ◦ ∏α-1 ◦ ∏α ◦ ∏α] (θ, r, θ, r)] ι = α 卬的,α-1r, αθ, 0则 1
=α (θ + α-1r (Yθ r θ - VLt(θ)))
θ'
=(α + Ya 1) θ — rVLt(θ) — rY
=(ρ + γ) θ — rVLt(θ) — γθ'	= [GDp(θ, r, θ, r)]1
□
B.4 Omitted proofs of Theorem 2.12
In this subsection we will prove a stronger version of Theorem 2.12(restated below), allowing the
WD,λι changing each phase.
Theorem B.2 (A stronger version of Theorem 2.12). There exists a way to correct the momentum
only at the first iteration of each phase, such that the following Tapered-Exponential LR schedule
(TEXP) {r⅛ } with momentum factor Y and no WD, leads the same sequence networks in function
space compared to that of Step Decay LR schedule(Definition 2.11) with momentum factor Y and
phase-dependent WD λ} in phase I, where phase I lasts from iteration TI to iteration TI+1, T0 = 0.
〜Jnt × (αI-1)-2	if TI-1 + 1 ≤ t ≤ TI — 1, I ≥ 1
rt+1 = nt × ηηL × (aI)-1(aI-1)-1	ift = TI,I ≥ 1
η I — 1
⑼
where aI = 1+γ-"♦「；<-4γ,前=r0(嗝)-1 =宿5)-1.
Towards proving Theorem 2.12, we need the following lemma which holds by expanding the defi-
nition, and we omit its proof.
Lemma B.3 (Canonicalization). We define the Canonicalization map as N(θ, r, θ', r') = (θ, r, θ 一
3(θ — θ'), r), and it holds that
1.	GD P ◦ N = GD P, ∀ρ > 0,t ≥ 0.
2.	N ◦ [∏c ◦ ∏22 ◦ ∏3 ◦ ∏42 ] = [∏c ◦ ∏22 ◦ ∏3 ◦ ∏42 ] ◦ N, ∀c > 0.
Similar to the case of momentum-free SGD, we define the notion of equivalent map below
Definition B.4 (Equivalent Maps). For two maps F and G, we say F is equivalent to G iff ∃c > 0,
F = [∏1 ◦ ∏22 ◦ ∏3 ◦ ∏42] ◦ G, which is also denoted by F W G.
Note that for any (θ, r, θ', r'), [N(θ, r, θ', r')]2 = [N(θ, r, θ', r')]4. Thus as a direct consequence
of Lemma 2.8, the following lemma holds.
Lemma B.5. ∀ρ, α > 0, GDP ◦ N W ∏α 1 ◦ Πj 1 ◦ ∏α 1 ◦ GDt ◦ ∏α 1 ◦ ∏α ◦ ∏α ◦ N.
Proof of Theorem2.12. Starting with initial state (θ0, ro, θ-1, r-1) where r-1 = ro and a given LR
schedule {rt}t≥o, the parameters generated by GD with WD and momentum satisfies the following
relationship:
14
Published as a conference paper at ICLR 2020
-ηt+ι	'
(Θt+1, ηt+1, θt, ηt)= Π产 O GDIfλt (θt, ηt, θ-1, ηt-i).
b
Define Q Ft = Fb o Fb_1 o ... o Fa, for a ≤ b. By Lemma B.3 and Lemma B.5, letting α be the
t=a
root of x2 — (Y + 1 — ηt-ιλt-1)X + Y = 0, we have
T-1 Γ nt+ι	1	∖ 一
Q	∏2nt	o GD1-nt N
t=0
T-1 Γ nt+1	1	∖	-
Q	∏2 nt	o GD1-nt λt o N
t=0
T-1
n ai τ-1
‘1Q
t=o
'∕t+1	-1	-1	-1	-1
∏ 产 o ∏αt+1 o ∏αt+1 o ∏αt+1 o GDt o ∏αt+1 o ∏αt+1 o ∏αt+1 o N
nT	-1	-1	-1
=∏2,t-1 o ∏αT-1 o ∏αT-1 o ∏αT o GDT-1 o
/T-1
(tQ1
-+11α-1
o Ht o GDt-1 ) o ∏ɑ1 o ∏α1 o
(10)
1 o N,
T-1
∏ %
i = 0
where ,—-is because of Lemma B.5, and Ht is defined as
nt-1	-1	-1	-1
Ht=∏αt	o ∏2 nt	o	∏αt+1 o	∏αt+1 o N o ∏αt	。∏αt	。∏αt	。∏2nt-1.
Since the canonicalization map N only changes the momentum part of the state, it,s easy to check
that Ht doesn,t touch the current parameter θ and the current LR η. Thus Ht only changes the
momentum part of the input state. Now we claim that Ht o GDt-1 = GDt-1 whenever ηt = ηt-1.
This is because when ηt = ηt-1, αt = αt+1 , thus Ht o GDt-1 = GDt-1. In detail,
Ht o GDt-1
=∏αt o ∏αt o ∏αt o N o ∏α-1 o ∏α-1 o ∏α-1 o GDt-1
=∏αt o ∏αt o ∏αt o ∏α-1 o ∏α-1 o ∏α-1 o GDt-1
=GDt-1,
where = is because GD update GDt sets ηf the same as η, and thus ensures the input of N has the
same momentum factor in buffer as its current momentum factor, which makes N an identity map.
Thus we could rewrite Equation 10 with a “sloppy“version of Ht, H[
JHt ηt = ηt-1;.
IId o.w. ^
T-1「	nt±1	1	、
Q	∏2nt	o GD1-ntλt
t=0
nτ
IT-1
—1	— 1	- 1
o ∏3τ-1 o ∏4τ-1 o ∏ατ o GDT-1 o
-1α-1
(tQ1 |∏2t+1
o Hlt o GDt-1
o ∏α-1
o ∏α≈1 o ∏71
nτ
IT-1
ɑτ-
α
o ∏4
-1
T -
a-1
o ∏ατ o
/T-1
(tQ1
GDt o ∏αt+14 1 o H't ) o GD0 o ∏α-1 o ∏α≈1 o ∏j o N,
一	(11)
o ∏
3
1
1
α―1
D
o N
Now we construct the desired sequence of parameters achieved by using the Tapered Exp LR
schedule 9 and the additional one-time momentum correction per phase. Let (θ0, M θ-1,亓-1)=
(θ0, η0, θ-1, η0), and
15
Published as a conference paper at ICLR 2020
(瓦,η1, θ0, η0) = [gDq O ∏α-1。∏αι。∏αι。N] (θ0, η0,心防-1)
=[gdo o ∏α-1 o ∏αι o ∏ɑι ](瓦,祇, θ-h)；
(Θt+1, ηt+ι, θt, ηt) = [GDt O ∏α-+ια-1 O H'∖ (θt, ηt, θt-ι,加-1).
We claim {θi}i=Q is the desired sequence of parameters. We,ve already shown that θt 〜θt, ∀t.
Clearly {θt }t=o is generated using only vanilla GD, scaling LR and modifying the momentum part
of the state. When t = TI for any I, ηt = ηt-ι and thus Ht = Id. Thus the modification
on the momentum could only happen at TI(I ≥ 0). Also it,s easy to check that α = α∣, if
TI + 1 ≤ t ≤ Ti+ι.	口
B.5 Omitted proofs of Theorem 2.13
rη∏l - - - . . . . TΓ* / r-rτ1 011，，	C'	.	f Zl ^1 Γv--,	1 f /V ^1 Γv--, IC .1
Theorem B.6. The following two sequences of parameters ,{θt}∞=0 and {θt}∞=°, define the same
sequence of network functions, i.e. fet = fgt, ∀t ∈ N, given the initial conditions, θɔ = pɔθɔ,
θ-1 = P-1θ-1.
1.	⅛⅛i = Y θtTθ--2 - Ve ((L(θt-1) + 号 I∣θt-11。，for t = 1,2,...;
不不	不 K.
2.	¾=i = Y θt-⅜-θt-θ - Vθ L(θt-ι), for t =1,2,...,
t
where ηjt = PtPt+ιηt, Pt = ∏ a-1, Vt ≥ —1 and at recursively defined as
i=-1
αt = -ηt-ιλt-ι + 1 + -t 1 Y(I - at-1), Vt ≥ 1.
(12)
needs to be always positive. Here aɔ, a-ι are free parameters. Different choice of aɔ, a-ι would
〜
〜
lead to different trajectory for {θt}, but the equality that θt = Ptθt is always satisfied. If the initial
condition is given via vɔ, then it,s also free to choose η-ι, θ-ι, as long as θ0-θ-1 = V0.
Proofof Theorem 2.13. We will prove by induction. By assumption S(t) : Ptθt = θt for t = —1, 0.
Now we will show that S(t) =⇒ S(t + 1), Vt ≥ 0.
θt - θt-1
ηt-ι
Take gradient θt - θt-1
⇒-----------------------
ηt-ι
Scale Invariance θt - θt-1
=⇒------------------------
ηt-ι
Y	^t-1^^t-~^- - vθ ((L(θt-I) + ^-l∣θt-1∣∣2)
ηt-2	2	)
Y	θt-1 - θt-2 - VθL(θt-ι) + λt-1θt-1
ηt-2
Y	---^^-1~2^ - Pt-1VθL(θt-1) + λt-ιθt-ι
ηt-2
ReSCaIing Pt(θt - θt-1)
PtPt-1ηt-1
Pt-2(θt-1 — θt-2)
Y	Pt-1 Pt-2ηt-2
-vθL(θt-1) - λt-1 Et 1
Pt-1
SimPIfyin⇒
Ptθt- α-1θt-1
ηt-1
SimPIfyin⇒
Ptθt- α-1θt-1
αt-1θt-1 — θt-2
ηt-2
at-1θt-1 — θt-2
-vθL(θt-1) - ηt-1λt-1
Ptθt-1
ηt-1Pt-1Pt
ηt-1
-vθL(θt-1) - ηt-1λt-1
-1彳
αt θt-1
ηt-1
SimPIfyin⇒
Ptθt - αt1 (I - ηt-1λt-1)θt-1
at-1θt-1 — θt-2
〜
ηt-1
-Vθ L(θt-1)
16
Published as a conference paper at ICLR 2020
To conclude that Ptθt = θt, it suffices to show that the coefficients before θt-ι is the same to that
in (2). In other words, We need to show
-1 + αtI(I - ηt-ιλt-ι) _ Y(I - at-1)
,
ηt-ι	ηt-2
which is equivalent to the definition of α1, Equation 12.
□
Lemma B.7 (Sufficient Conditions for positivity of α). Let λmaχ = max, λt, ηmaχ = maxt η.
Define Zmlin is the larger root of the equation X2 — (1 + Y — λmaχηmaχ)x + Y = 0. To guarantee
the existence Ofzmax we also assume ηmaχλmaχ ≤ (1 — √γ)2. Then we have
∀α-ι, αo = 1 =⇒ zmin ≤ at ≤ 1,∀t ≥ 0
(13)
Proof. We will prove the above theorem with a strengthened induction —
S(t):
∀0 ≤ t' ≤ t, zmin ≤ αt' ≤ 1 ʌ
α- 1 - 1 ≤ zmin - 1
ηt — 1	ηmax
Since a0 = 1, S(0) is obviously true. Now suppose S(t) is true for some t ∈ N, we will prove
S (t +1).
First, since 0 < a, ≤ 1, a,+ι = -η,λ, + 1 + ^-γ(1 - a―1) ≤ 1.
Again by Equation 12, we have
1 - αt+ι = ηtλt +
αt--1 ηtγ = ηtλt + zmin~1 ηtγ ≤ η"t + (Zmin - I)Y = 1 - zmin
ηt-1	ηmax
which shows a,+ι ≥ zmin. Here the last step is by definition of zmin.
Because of at+ι ≥ zmin, we have at+L1 - 1 ≤	z-1	1 -	at+1	≤	z-1	(λ + at	1 - 1 M ≤	z-1	(λ	+ zmin - 1 )=之一1 1 - zmin 二 —zmin	— zmin (λt+	Y) — zmin (λmax+	Y)	zmin '∣t	'∣t	∙∕t-1	∙∣max	∙∣max	_ zmιin	1 ∣max
□
Now we are ready to give the formal statement about the closeness of Equation 9 and the reduced
LR schedule by Theorem 2.13.
Theorem B.8. Given a Step Decay LR schedule with {TI}K=-11, {η∕}K=-)1, {λj}K=-)1, the TEXP++
LR schedule in Theorem 2.13 is the following(α0 = a-1 = 1, T0 = 0):
J-η/λ∕ + 1 + Y(I - a——LI), ∀ti + 2 ≤ t ≤ TI +1,I ≥ 0;
Ca = 1 -ηIλI + 1 + 卢Y(1 - a—1ι),∀t = Ti + 1,I ≥ 0;
I — 1
t
Pt = 口 a—1;
i=-1
ηt = PtPt+ιηt.
It,s the same as the TEXP LR SChedUle({α }) in Theorem 2.12 throughout each phase I, in the sense
that
< 3 λmax ηmax ( Y ʌ	≤ 3 λmax ηmax
1 - Y	Izmin)	—	1 - Y
λmaxηmax ʌ 2
y(1 +	1 - Y )
(t-Ti — 1)
∀TI+1 ≤ t ≤ Ti+1 .
17
Published as a conference paper at ICLR 2020
where Zmin is the larger root of x2 — (1 + Y — λmaxηmax)x + Y = 0. In Appendix B, we show
that Zmin ≤ 1 + ηmι)max . When Xmaxnmax is small compared to 1 — γ, which is usually the
case in practice, one could approximate Zmin by 1. For example, when Y = 0.9, Xmax = 0.0005,
ηmaχ = 0.1, the above upper bound becomes
l⅛i / ⅜i—1l≤0.0015 × 0∙9009fτ
Proofof Theorem B.8. Assuming ZI and z∣(z∣ ≥ ZI) are the roots of Equation 1 with η = η and
X = XI, we have Y ≤ ZI' ≤ √γ ≤ Zmin ≤ ZI ≤ 1, VI, If ∈ [K — 1] by Lemma B.1.
We can rewrite the recursion in Theorem 2.13 as the following:
Cat = —ηI XI + 1 + γ(1 — %Tι) = — (z； + ZI) + ZIZIaiTi.	(14)
In other words, we have
ZI
αt — zI = -(at —1 — zI ), t ≥ 1.
αt-i
(15)
By Lemma B.7, we have at ≥ Zmin, Vt ≥ 0. Thus I 学—1∣ = ；-i ∣。；-1 — 1∣ ≤	∖。；-1 — 1∣ =
-^L-1αtι1 — 1∣ ≤ γ(1 + ^~η~)I∣αtι11, which means at geometrically converges to its stable fixed
Zmin ' ZI	' - ' '	ITY ZI
n	&Tr
point z；. and z⅛-1 = (ZI)I. Since that Zmin ≤ at ≤ 1, Zmin ≤ z； ≤ 1, we have ∣寸—1∣ ≤
ITZmin = 飞？… ≤ 1, and thus ∣学—1∣ ≤ '%工…(PL)tTTIT ≤ 1, VTf + 1 ≤ t ≤ TI+ι.
Note that aI = ZI, ηη-1 = αtαt+ι By definition OfTEXP and TEXP++, we have
ηtτ
ηt
η⅛τ _ ∫(ZITI)I
<n*
ηt	[ɪ ZIZIT
----αt+1αt
ηt
if TIT + 1 ≤ t ≤ TI — 1
if t = TI,I ≥ 1
(αt+1 αt
ηI-ι	八
aTi + 1aTι
if TIT + 1 ≤ t ≤ TI - 1
if t = TI,I ≥ 1
(16)
(17)
Thus we have when t = TI,
≤ ατι+ι aτι
一ZI	Z；T1
/ Q XmaX ηmax
≤3	；	.
1 - Y
-Ti
I —1
-Ti + 1
zI
( aTι + 1 1
≤ ʒr-1
+
a
Z
i

1 +
a
—1
肾-1
When TI + 1 ≤ t ≤ TI+i, we have
—1
≤ 肾 T + ⅛7 -1	+匿-1	3-1
t_Ti t1
XmaXηmax
1 - Y
(ZI-)
min
Thus we conclude VI ∈ [K — 1], TI + 1 ≤ t ≤ TI+i, we have
—1
, C XmaX ηmax ( Y ∖	/ c XmaX ηmax	：
≤ 3-i------ ——	≤ 3-i-------Y
1 - Y	IZmin	1 - Y
t—Ti — 1(1+ XmaX'ηmax)I(t—Ti — 1)
1 - Y
□
18
Published as a conference paper at ICLR 2020
B.6 Omitted Proofs in Section 3
We will use Iw to denote IwwJ and ∠uw to arccos(UTW). Note that training error ≤ ∏ is equivalent
to ∠eιWt < ε.
Case 1: WD alone Since the objective is strongly convex, it has unique argmin w*. By symmetry,
w* = βeι, for some β > 0. By KKT condition, We have
λβ = E
X1~N (0,1)
|x1|
1 + exp(β∣Xι∣)
≤ E [∣xι∣]
—X1~N (0,1)
which implies ∣∣w*∣∣ = O(ɪ).
By Theorem 3.1 of Gower et al. (2019), for sufficiently large t, we have E IlWt - w* ∣∣2 = O(&).
Note that ∠eιWt = ∠w*Wt ≤ 2 sin ∠w*Wt ≤ 2 岬W-W 1, we have E (∠eιwj2 = O(哈),so the
expected error = E (∠e∖Wt)/π ≤ ʌ/E (∠ejWt)2/π = O(∖Z-ηB).
Case 3: Both BN and WD We will need the following lemma when lower bounding the norm of
the stochastic gradient.
Lemma B.9 (Concentration of Chi-Square). Suppose Xi,..., Xk '阿N N(0,1), then
-k	-
Pr E Xi2 <kβ
_i=1	一
k
≤ (βe1-β)2 .
(18)
Proof. This Chernoff-bound based proof is a special case of Dasgupta & Gupta (2003).
-k	-
Pr E X2 <kβ
_i=1	一
k
≤ (βe1-β)2 = Pr
exp
(ktβ —
tE Xi2)
i=1	)
≤ E exp
U-1E T]
(Markov Inequality)
(19)
≥ 1
ektβ (1 + 2t)-2.
The last equality uses the fact that E [tX2] = √ι∖t for t < 2. The proof is completed by taking
t = 1-β
t = 2β .
Setting for Theorem B.6: Suppose WD factor is λ, LR is η, the width of the last layer is m ≥ 3,
Now the SGD updates have the form
wt+i
Wt - B E ▽ (In(I+ exP(-xt,bT∣w^yt,b)) + λ ∣wt∣2)
=(1 - λη)wt -
B	⊥
η IE∙________yt,b________口一、xt,b
B b=11 + eχp(Xt,bτ∣¾yt,b)	IlWtIl
where Xt,b i.到 N(0, Im),yt,b = sign ([xt,b]ι), and ∏Wt
WtWl
.
I -
Proof of Theorem B.6.
19
Published as a conference paper at ICLR 2020
Step 1: Let T1 = 2加入-2£2)ln “白；!—2^, and T2 = 9ln 1. Thus if We assume the training
error is smaller than ε from iteration T0 to T0 + Tl + T2, then by spherical triangle inequality,
∠WtWt' ≤ ∠eιWt' + ∠eιwt = 2ε, for T0 ≤ t,t' ≤ T0 + Ti + T2.
Now let's define Wt = (1 - ηλ)wt and for any vector w, and we have the following two relation-
ships:
1"wR = (1- ηλ)^w^.
2"wt+ι∣∣ ≤ 翦ε.
The second property is because by Lemma 1.3, (wt+i — Wt) ⊥ Wt and by assumption of small
error, ∠Wt+ιwt ≤ 2ε.
Therefore
I∣wτ1+T0H ≤ (1 - ηλ YTI
I∣wτ0 Il2	— (cos23
≤ (1-ηλ YT1 ≤ (1 - (ηλ - 2ε2))2T1 ≤ e-2Tι(ηλ-2ε2) = η
一11- 2ε2) T U η 6	64∣wτo ∣∣2ε
(20)
In other word, ∣∣WT0+T112 ≤ 於ʌ/m-2∙ Since ∣wτ0+t∣ is monotone decreasing, ∣wτcj +t∣2 ≤
6⅛ ʌ/m-2 holds for anyt = Ti ,...,Ti + T2.
Step 2: We show that the norm of the stochastic gradient is lower bounded with constant probability.
In other words, we want to show the norm of ξt
bounded with high probability.
_________yt,b  ____nWtxt,b
1 1+eχp(χt,bTJw^ yt,b)	Ilwtll
is lower
Let ∏Wt eɪ be the projection matrix for the orthogonal space spanned by Wt and e> W.L.O.G, we
can assume the rank of ∏Wt eι is 2. In case Wt = ei, we just exclude a random direction to make
∏Wt eι rank 2. Now we have ∏Wt eι xt,b are still i.i.d. multivariate gaussian random variables, for
b = 1,...,B, and moreover, Π^t eɪ xt,b is independent to
can lower bound ∣∣ξt∣ by dealing with Ilnwt,eιξt∣.
-----7-ytT Wt -----ʌ. When m ≥ 3, we
i+eχp(χt,b1 jwtj yt,b)
It,s not hard to show that conditioned on {xtj IwtI, [xt,b]i }b=i,
B
鼻 1 + eχp(Xt,bτ 号 yt,b) nwt xt,b = ∖
士(
b=i
________yt,b________
1 + eχp(χt,bτ∣⅛ yt,b)
2
∏⊥	X
wt,eι x,
(21)
)
where X 〜N(0,Im). We further note that ∣Πwt® x∣2 〜χ2(m — 2). By Lemma B.9,
Pr llnwt,eιxt∣2 ≥ —7^- ≥ 1 - (~T)^― ≥ 1 - (~T)2 ≥ 彳.	(22)
_	8	」	8e8	8e8	3
Now we will give a high probability lower bound for
XT 曲〜N(Oj),we have
EB=I ( i+exp(xt0j¾诉).Note that
1
≥ 2,
Pr
Wt
llWtI
l< 1
(23)
which implies the following, where At,b is defined as 1
[XTb∣w⅛ | < 1 ≥ ⅛]:
20
Published as a conference paper at ICLR 2020
E At,b = PrU —~T Wt、ll≥ ɪ ≥ 1.	(24)
1 + eχp(Xtlb IwI yt)	1 + eJ 2
Note that EB=I At,b ≤ B, and E EB=I At,b ≥ B, We have Pr [e3 At,b < B] ≤ 2. Thus,
Pr 一宫(1 + 9(XytbbrIwlUn)) ≥ 4(I + e)2_ ≥ * _NAt,b ≥ 牙_ ≥ 3.	(25)
Thus w.p. at least 9, equation 25 and equation 22 happen together, which implies
B	B
Ii B E ▽In(I+exp(-x[b Uw^ yt,b))u = Ii B E
B b=1	1 11	B b=1
________yt2b________nWt xt,b
1 + eχp(Xrb M yt)	IlwtIl
η ʌ/m — 2 η	/m — 2
1 + e 8∣IwtIl ^ 32∣IwtllV B
(26)
Step 3. To stay in the cone {w∣∠weι ≤ ε}, the SGD update ∣∣wt+ι — w' I = ∣∣ B EB=I V ln(1 +
exp(—xJb ∣Wt∣ yt,b))I has to be smaller than IlwtIl Sin 2ε for any t = T0 + Ti, ...,T0 + Tl + T2.
However, step 1 and 2 together show that ∣∣Vln(1 + exp(—xj JwJyt))I ≥ 2∣∣wt∣∣ε w.p. ɪ per
iteration. Thus the probability that Wt always stays in the cone for every t = T + Tl, ...,T0 +
Tl + T2 is less than (9)T2 ≤ δ.	口
Remark B.10. It's interesting that the only property of the global minimum we use is that the ifboth
wt, wt+ι are E optimal, then the angle between Wt and wt+ι is at most 2e. Thus we indeed have
proved a stronger statement: At least once in every 2,λ-2ε2)]“6甸吃；!—+ 9ln δ iterations, the
angle between Wt and Wt+1 Will be larger than 2e. In other words, if the the amount of the update
stablizes in terms of angle, then this angle must be larger than √2ηλ for this simple model.
B.7 Omitted Proofs in Section A
Lemma B.11. Suppose loss L is scale invariant, then L is non-convex in the following two sense:
1.	The domain is non-convex: scale invariant loss can ’ be defined at origin;
2.	There exists no ball containing origin such that the loss is locally convex, unless the loss is
constant function.
Proof. Suppose L(θ*) = supθ∈B L(θ). W.L.O.G, we assume ∣∣θ*∣∣ < 1. By convexity, every line
segment passing θ* must have constant loss, which implies the loss is constant over set B - {c j1^ |
—1 ≤ C ≤ 0}. Applying the above argument on any other maximum point θ/ implies the loss is
constant over B — {0}.	口
Theorem B.12. Suppose the momentum factor Y = 0, LR η = η is constant, and the loss function
L is lower bounded. If ∃c > 0 and T ≥ 0 such that Vt ≥ T, f (θt+ι) — f(θt) ≤ —cη∣∣ VL(θt) ∣∣2,
then limt→∞ ∣∣θt∣∣ = 0.
Proofin Item 3. By Lemma 1.3 and the update rule of GD with WD, we have
∣∣θt∣∣2 = Il(I- λη)∣∣θ∣∣t-ι + ηVL(θ~ι)∣∣2 = (1 - λη)2∣∣θt-ι∣∣2 + η2∣∣VL(θt-ι)∣∣2,
which implies
t-l
IθtI2 = E(1 — λη)2(t-i-1)η2IVL(θt-ι)I2 + (1 - λη)2(t-T)啊产
i=T
21
Published as a conference paper at ICLR 2020
Thus for any T, > T,
τ'
E同『≤
t=τ
1
1 — (1 — λη)2
T '-1
E RL(θt)∣ι2 + ∣6τιι2
t=τ
≤ 七(EINL(θt)∣∣2 + ∣∣θτ『
Note that by assumption We have ET=T1 ∣∣ VL(θt) ^2 =/ f (θτ) — f(θτ').
As a conclusion, We have E∞τ 11 θt ∣2 ≤ f'θτ )-；2丁 '⑻ +1％" , which implies lim ∣θt∣2 =
0.	→∞	□
C Other Results
Now we rigorously analyze norm growth in this algorithm. This greatly extends previous analyses
of effect of normalization schemes (WU et al., 2018; Arora et al., 2018) for vanilla SGD.
Theorem C.1. Under the update rule 1.2 with λt = 0, the norm of scale invariant parameter θt
satisfies the following property:
•	Almost Monotone Increasing: ∣θt+ι∣2 — ∣θt∣2 ≥ —γt+1 ηt (∣ θ012 — ∣∣θ-ι∣2).
•	Assuming ηt = η is a constant, then
1	7t-i+1	1	7t+1
∣θt+ι∣2 = ∑ʒγ(M — θi+1∣2 + γ∣θi-1 —41|2)—γ —(∣θoI2—∣θ-1∣2)
i=0	1 — Y	1 — Y
Proof. Let,s use Rt, Dt, Ct to denote ∣∣θt ∣2, ∣θt+1 — θt ∣2, θj(θt+1 — θt) respectively.
The only property we will use about loss is VθLJθt = 0.
Expanding the square of ∣θt+11∣2 = ∣∣ (θt+1 — θt) + θt ∣2, we have
Vt ≥ —1 S(t) : Rt+1 — Rt = Dt + 2Ct.
We also have
C
ηt
θj θt+1 - θt = θj (γ θt - θt-1
ηt
ηt-1
—λtθt) =	7 (Dt + Ct-I) — λtRt,
ηt-1
namely,
Vt ≥ 0 P(t):
Ct	YDt _ Y r,
	=----------Ct-I
ηt	ηt-1-ηt-1
—λtRt∙
Simplify
S(t)
nt
C-I) + P(t), we have
ηt
When λt
0, we have
Rt+1 - Rt
ηt
Rt+1 - Rt Rt
---Z-----Y—
,t+1R0 - RT
η-1
-Rt-1 =	Dt	ɪ	Dt-1 + Y	
		
ηt-1	ηt	ηt-1
t + E Yt-i	(D	l	Di-1 ■ + Y	
i=0	η	ηi-1
—2λtRt∙
)≥ Yt+1 R0 - RT
一	ηo
(27)

Y
Further if ηt = η is a constant, we have
±v 1 — Yt-i+1	1 — Yt+1
Rt+1 = R0 + ∕J  ：-----(Di + YDi-I ) - Y-：--(R0 - R-1),
£ 1 - Y 1 - Y
22
Published as a conference paper at ICLR 2020
Figure 6: The orange line corresponds to PreReSNet32 trained with constant LR and WD divided by 10 at
epoch 80 and 120. The blue line is TEXP-- corresponding to Step Decay schedule which divides LR by 10 at
epoch 80 and 120. They have similar trajectories and performances by a similar argument to Theorem 2.12.(See
Theorem B.2 and its proof in Appendix B)
which covers the result without momentum in (Arora et al., 2019) as a special case:
t
Rt+ι = Ro + 工 Di.
i=0
□
For general deep nets, We have the following result, suggesting that the mean square of the update
are constant compared to the mean square of the norm. The constant is mainly determined by ηλ,
explaining why the usage of weight decay prevents the parameters to converge in direction. 1
Theorem C.2. For SGD with constant LR η, weight decay λ and momentum Y, when the limits
R∞ = limτ→∞ T ∑t=01 Ilwt∣∣2, D∞ = limτ→∞ TET-I l∣wt+ι - Wt∣∣2 exist, we have
D∞
T R
∞.
Proof of Theorem C.2. Take average of Equation 27 over t, when the limits R∞
IimT→∞ T ET-I ∣∣wt∣∣2, D∞ = limτ→∞ TTET-)1 ∣∣wt+ι — wt ∣∣2 exists, we have
1 + YC 、…
D∞ = 2λR∞.
η
D ADDITIONAL EXPERIMENTAL FIGURES
E	SCALE INVARIANCE IN MODERN NETWORK ARCHITECTURES
In this section, we will discuss how Normalization layers make the output of the network scale-
invariant to its parameters. Viewing a neural network as a DAG, we give a sufficient condition for
the scale invariance which could be checked easily by topological order, and apply this on sev-
eral standard network architectures such as Fully Connected(FC) Networks, Plain CNN, ResNet(He
et al., 2016a), and PreResNet(He et al., 2016b). For simplicity, we restrict our discussions among
networks with ReLU activation only. Throughout this section, we assume the linear layers and
the bias after last normalization layer are fixed to its random initialization, which doesn,t harm the
performance of the network empirically(Hoffer et al., 2018b).
1 (Page) had a similar argument for this phenomenon by connecting this to the LARS(You et al., 2017),
though it,s not rigorous in the way it deals with momentum and equilibrium of norm.
23
Published as a conference paper at ICLR 2020
E.1 Notations
Definition E.1 (Degree of Homogeneity). Suppose k is an integer and θ is all the parameters of the
network, then f is said to be homogeneous of degree k, or k-homogeneous, if ∀c > 0, f (cθ) =
Ckf (θ). The output of f can be multi-dimensional. Specifically, scale invariance means degree of
homogeneity is 0.
Suppose the network only contains following modules, and We list the degree of homogeneity of
these basic modules, given the degree of homogeneity of its input.
(I) Input
(L) Linear Layer, e.g. Convolutional Layer or Fully Connected Layer
(B) Bias Layer(Adding Trainable Bias to the output of the previous layer)
(十) Addition Layer (adding the outputs of two layers with the same dimension2.)
(N) Normalization Layer without affine transformation(including BN, GN, LN, IN etc.)
(NA) Normalization Layer with affine transformation
Module	I	L	B	十	N	NA
Input	-	X	丁	(x,x)	x	x
Output	ɪ	~^+T	丁	x	ɪ	~τ~
Table 1: Table showing how degree of homogeneity of the output of basic modules depends on the degree of
homogeneity of the input. For the row of the Input, entry '-' means the input of the network (I) doesn,t have
any extra input, entry '1’ OfBiaS Layer means if the input is 1-homogeneous then the output is 1- homogeneous.
’(x, x)' for ‘+' means if the inputs of Addition Layer have the same degree of homogeneity, the output has the
same degree of homogeneity. ReLU, Pooling( and other fixed linear maps) are ignored because they keep the
degree of homogeneity and can be omitted when creating the DAG in Theorem E.3.
Remark E.2. For the purpose of deciding the degree of homogeneity of a network, there,s no
difference among convolutional layers, fully connected layer and the diagonal linear layer in the
affine transformation of Normalization layer, since they're all linear and the degree of homogeneity
is increased by 1 after applying them.
On the other hand, BN and IN has some benefit which GN and LN doesn't have, namely the bias
term (per channel) immediately before BN or IN has zero effect on the network output and thus can
be removed. (See Figure 15)
We also demonstrate the homogeneity of the output of the modules via the following figures, which
will be reused to later to define network architectures.
Theorem E.3. For a network only consisting of modules defined above and ReLU activation, we
can view it as a Directed acyclic graph and check its scale invariance by the following algorithm.
Input : DAG G = (V,E) translated from a neural network; the module type of each node
Vi ∈ V.
ι for v in topological order of G do
2	Compute the degree of homogeneity of V using Table 1;
3	if v is not homogeneous then
4	I return False;
5	if Vouptut is 0-homogeneous then
6	I return True;
7	else
8	I return False.
2 Addition Layer(+) is mainly used in ResNet and other similar architectures. In this section, we also use it
as an alternative definition of Bias Layer(B). See Figure 7
24
Published as a conference paper at ICLR 2020
(h) Definition of Normalization with Affine(NA)
(g) Normalization with
Affine(NA)
Figure 7:	Degree of homogeneity of the output of basic modules given degree of homogeneity of the input.
25
Published as a conference paper at ICLR 2020
E.2 NETWORKS WITHOUT AFFINE TRANSFORMATION AND BIAS
We start with the simple cases where all bias term(including that of linear layer and normalization
layer) and the scaling term of normalization layer are fixed to be 0 and 1 element-wise respectively,
which means the bias and the scaling could be dropped from the network structure. We empirically
find this doesn,t affect the performance of network in a noticeable way. We will discuss the full case
in the next subsection.
Plain CNN/FC networks: See Figure 8.
Figure 8:	Degree of homogeneity for all modules in vanilla CNNs/FC networks.
S
x
x
x
X
D-Block
Block
Block
D-Block
X
X
N
0
Figure 9:	An example of the full network structure of ResNet/PreResNet represented by composite modules de-
fined in Figure 10,11,13,14, where 'S' denotes the starting part of the network, 'Block' denotes a normal block
with residual link, 'D-Block' denotes the block with downsampling, and 'N' denotes the normalization layer
defined previously. Integer X ∈ {0,1, 2} depends on the type of network. See details in Figure 10,11,13,14.
ResNet: See Figure 10. To ensure the scaling invariance, We add an additional normalizaiton layer
in the shortcut after downsampling. This implementation is sometimes used in practice and doesn't
affect the performance in a noticeable way.
(a) The starting part of ResNet
rOH!HBwι°
0
(b)	A block of ResNet
O2IOn0
X
(c) A block of ResNet with downsampling
Figure 10: Degree of homogeneity for all modules in ResNet without affine transformation in normalization
layer. The last normalization layer is omitted.
26
Published as a conference paper at ICLR 2020
Preactivation ResNet: See Figure 11. PreaCtivation means to change the order between convolu-
tional layer and normalization layer. For similar reason, We add an additional normalizaiton layer in
the shortcut before downsampling.
(a) The starting part of PreResNet
(b) A block of PreResNet
(c) A block of PreResNet with downsampling
Figure 11: Degree of homogeneity for all modules in ResNet without affine transformation in normalization
layer. The last normalization layer is omitted.
27
Published as a conference paper at ICLR 2020
E.3 NETWORKS WITH AFFINE TRANSFORMATION
Now We discuss the full case where the affine transformation part of normalization layer is trainable.
Due to the reason that the bias of linear layer (before BN) has 0 gradient as we mentioned in E.2,
the bias term is usually dropped from network architecture in practice to save memory and accel-
erate training( even with other normalization methods)(See PyTorch Implementation (PaSzke et al.,
2017)). However, when LN or GN is used, and the bias term of linear layer is trainable, the network
could be scale variant (See Figure 15).
Plain CNN/FC networks: See Figure 12.
Figure 12: Degree of homogeneity for all modules in vanilla CNNs/FC networks.
ResNet: See Figure 13. To ensure the scaling invariance, we add an additional normalizaiton layer
in the shortcut after downsampling. This implementation is sometimes used in practice and doesn't
affect the performance in a noticeable way.
(a) The starting part of ResNet
(b) A block of ResNet
(c) A block of ResNet with downsampling
Figure 13: Degree of homogeneity for all modules in ResNet with trainable affine transformation. The last
normalization layer is omitted.
Preactivation ResNet: See Figure 14. Preactivation means to change the order between convolu-
tional layer and normalization layer. For similar reason, we add an additional normalizaiton layer in
the shortcut before downsampling.
28
Published as a conference paper at ICLR 2020
(a) The starting part of PreReSNet

2
(b) A block of PreResNet
(c)	A block of PreResNet with downsampling
Figure 14: Degree of homogeneity for all modules in PreResNet with trainable affine transformation. The last
normalization layer is omitted.
Figure 15: The network can be not scale variant if the GN or IN is used and the bias of linear layer is trainable.
The red 'F' means the Algorithm 1 will return False here.
29