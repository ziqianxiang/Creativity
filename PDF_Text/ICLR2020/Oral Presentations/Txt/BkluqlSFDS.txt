Published as a conference paper at ICLR 2020
Federated learning with matched averaging
Hongyi Wang *
Department of Computer Sciences
University of Wisconsin-Madison
hongyiwang@cs.wisc.edu
Mikhail Yurochkin
IBM Research
MIT-IBM Watson AI Lab
mikhail.yurochkin@ibm.com
Yuekai Sun
Department of Statistics
University of Michigan
yuekai@umich.edu
Dimitris Papailiopoulos
Department of Electrical and Computer Engineering
University of Wisconsin-Madison
dimitris@papail.io
Yasaman Khazaeni
IBM Research
yasaman.khazaeni@us.ibm.com
Ab stract
Federated learning allows edge devices to collaboratively learn a shared model
while keeping the training data on device, decoupling the ability to do model
training from the need to store the data in the cloud. We propose the Federated
matched averaging (FedMA) algorithm designed for federated learning of mod-
ern neural network architectures e.g. convolutional neural networks (CNNs) and
LSTMs. FedMA constructs the shared global model in a layer-wise manner by
matching and averaging hidden elements (i.e. channels for convolution layers;
hidden states for LSTM; neurons for fully connected layers) with similar feature
extraction signatures. Our experiments indicate that FedMA not only outperforms
popular state-of-the-art federated learning algorithms on deep CNN and LSTM
architectures trained on real world datasets, but also reduces the overall commu-
nication burden.* 1
1	Introduction
Edge devices such as mobile phones, sensors in a sensor network, or vehicles have access to a
wealth of data. However, due to data privacy concerns, network bandwidth limitation, and device
availability, it’s impractical to gather all the data from the edge devices at the data center and conduct
centralized training. To address these concerns, federated learning is emerging (McMahan et al.,
2017; Li et al., 2019; Smith et al., 2017; Caldas et al., 2018; Bonawitz et al., 2019; Kairouz et al.,
2019) as a paradigm that allows local clients to collaboratively train a shared global model.
The typical federated learning paradigm involves two stages: (i) clients train models with their
local datasets independently, and (ii) the data center gathers the locally trained models and aggre-
gates them to obtain a shared global model. One of the standard aggregation methods is FedAvg
(McMahan et al., 2017) where parameters of local models are averaged element-wise with weights
proportional to sizes of the client datasets. FedProx (Sahu et al., 2018) adds a proximal term to
the client cost functions, thereby limiting the impact of local updates by keeping them close to
the global model. Agnostic Federated Learning (AFL) (Mohri et al., 2019), as another variant of
FedAvg, optimizes a centralized distribution that is a mixture of the client distributions.
One shortcoming of FedAvg is coordinate-wise averaging of weights may have drastic detrimental
effects on the performance of the averaged model and adds significantly to the communication bur-
den. This issue arises due to the permutation invariance of neural network (NN) parameters, i.e. for
* Work performed while doing an internship at IBM Research.
1Code is available at https://github.com/IBM/FedMA
1
Published as a conference paper at ICLR 2020
Figure 1: Comparison among various federated learning methods with limited number of communications on
LeNet trained on MNIST; VGG-9 trained on CIFAR-10 dataset; LSTM trained on Shakespeare dataset over:
(a) homogeneous data partition (b) heterogeneous data partition.
any given NN, there are many variants of it that only differ in the ordering of parameters. Prob-
abilistic Federated Neural Matching (PFNM) (Yurochkin et al., 2019b) addresses this problem by
matching the neurons of client NNs before averaging them. PFNM further utilizes Bayesian non-
parametric methods to adapt to global model size and to heterogeneity in the data. As a result, PFNM
has better performance and communication efficiency than FedAvg. Unfortunately, the method only
works with simple architectures (e.g. fully connected feedforward networks).
Our contribution In this work, we demonstrate how PFNM can be applied to CNNs and LSTMs,
but we find that it only gives very minor improvements over weight averaging. To address this
issue, we propose Federated Matched Averaging (FedMA), a new layers-wise federated learning
algorithm for modern CNNs and LSTMs that appeal to Bayesian nonparametric methods to adapt
to heterogeniety in the data. We show empirically that FedMA not only reduces the communcations
burden, but also outperforms state-of-the-art federated learning algorithms.
2	Federated Matched Averaging of neural networks
In this section we will discuss permutation invariance classes of prominent neural network archi-
tectures and establish the appropriate notion of averaging in the parameter space of NNs. We will
begin with the simplest case of a single hidden layer fully connected network, moving on to deep
architectures and, finally, convolutional and recurrent architectures.
Permutation invariance of fully connected architectures A basic fully connected (FC) NN can
be formulated as y = σ(xW1)W2 (without loss of generality, biases are omitted to simplify no-
tation), where σ is the non-linearity (applied entry-wise). Expanding the preceding expression
y = PL=ι W2,i∙σ(hx,W1,∙ii), where i∙ and ∙i denote ith row and column correspondingly and
L is the number of hidden units. Summation is a permutation invariant operation, hence for any
{W1 , W2 } there are L! practically equivalent parametrizations if this basic NN. It is then more ap-
propriate to write
y = σ(xWι∏)ΠτW2, where Π is any L X L permutation matrix.	(1)
Recall that permutation matrix is an orthogonal matrix that acts on rows when applied on the
left and on columns when applied on the right. Suppose {W1, W2} are optimal weights, then
weights obtained from training on two homogeneous datasets Xj, Xj0 are {W1Πj, ΠjTW2} and
{W1Πj0, ΠjT0 W2}. It is now easy to see why naive averaging in the parameter space is not ap-
propriate: with high probability Πj = Πj, and (WInj + Wι∏jo)∕2 = Wι∏ for any Π. To
meaningfully average neural networks in the weight space we should first undo the permutation
(W1ΠjΠjT+W1Πj0ΠjT0)∕2= W1.
2.1	Matched averaging formulation
In this section we formulate practical notion of parameter averaging under the permutation invari-
ance. Let wjl be lth neuron learned on dataset j (i.e. lth column ofW(1)Πj in the previous example),
2
Published as a conference paper at ICLR 2020
θi denote the ith neuron in the global model, and c(∙, ∙) bean appropriate similarity function between
a pair of neurons. Solution to the following optimization problem are the required permutations:
L
min XX
minπljic(wjl, θi) s.t. X πlji = 1∀j,l; X πlji = 1∀i,j.	(2)
{πlji} i=1 j,l θi	i	l
Then ΠjTli = πlji and given weights {Wj,1, Wj,2}jJ=1 provided by J clients, we compute the fed-
erated neural network weights Wi = JJ Pj Wj,ι∏τ and W2 = JJ PjnjWj,2. We refer to this
approach as matched averaging due to relation of equation 2 to the maximum bipartite matching
problem. We note that if c(∙, ∙) is squared Euclidean distance, We recover objective function similar
to k-means clustering, however it has additional constraints on the “cluster assignments” πlji neces-
sary to ensure that they form permutation matrices. In a special case where all local neural networks
and the global model are assumed to have same number of hidden neurons, solving equation 2 is
equivalent to finding a Wasserstein barycenter (Agueh & Carlier, 2011) of the empirical distributions
over the weights of local neural networks. Concurrent work of Singh & Jaggi (2019) explores the
Wasserstein barycenter variant of equation 2.
Solving matched averaging Objective function in equation 2 can be optimized using an iterative
j0
procedure: applying the Hungarian matching algorithm (Kuhn, 1955) to find permutation {πlji }l,i
corresponding to dataset j0, holding other permutations {πlji }l,i,j 6=j0 fixed and iterating over the
datasets. Important aspect of Federated Learning that we should consider here is the data hetero-
geneity. Every client will learn a collection of feature extractors, i.e. neural network weights, rep-
resenting their individual data modality. As a consequence, feature extractors learned across clients
may overlap only partially. To account for this we allow the size of the global model L to be an un-
known variable satisfying maxj Lj ≤ L ≤ Pj Lj where Lj is the number of neurons learned from
dataset j. That is, global model is at least as big as the largest of the local models and at most as big
as the concatenation of all the local models. Next we show that matched averaging with adaptive
global model size remains amendable to iterative Hungarian algorithm with a special cost.
At each iteration, given current estimates of {πlji}l,i,j6=j0, we find a corresponding global model
{θi = arg minθi Pj6=j0,l πljic(wjl, θi)}iL=1 (this is typically a closed-form expression or a simple
optimization sub-problem, e.g. a mean if c(∙, ∙) is Euclidean) and then We will use Hungarian al-
gorithm to match this global model to neurons {wj0l }lL=j10 of the dataset j0 to obtain a new global
model with L ≤ L0 ≤ L + Lj 0 neurons. Due to data heterogeneity, local model j0 may have neurons
not present in the global model built from other local models, therefore we want to avoid “poor”
matches by saying that if the optimal match has cost larger than some threshold value , instead of
matching we create a new global neuron from the corresponding local one. We also want a modest
size global model and therefore penalize its size with some increasing function f(L0). This intuition
is formalized in the following extended maximum bipartite matching formulation:
L+Lj0 Lj0
mj0in	X X πlji Clji s.t. X πlji = 1∀l; X πlji ∈ {0, 1} ∀ i, where
{πli }l,i i=1 j=1	i	l
Cj0 =	c(wj0l, θi), i ≤ L
li + f (i), L < i ≤ L + Lj0.
(3)
The size of the new global model is then L0 = max{i : πlji0 = 1, l = 1, . . . , Lj0 }. We note some
technical details: after the optimization is done, each corresponding ΠjT is of size Lj × L and is not
a permutation matrix in a classical sense when Lj 6= L. Its functionality is however similar: taking
matrix product with a weight matrix Wj(1)ΠjT implies permuting the weights to align with weights
learned on the other datasets and padding with “dummy” neurons having zero weights (alternatively
we can pad weights Wj(1) first and complete ΠjT with missing rows to recover a proper permutation
matrix). This “dummy” neurons should also be discounted when taking average. Without loss of
generality, in the subsequent presentation we will ignore these technicalities to simplify the notation.
To complete the matched averaging optimization procedure it remains to specify similarity c(∙, ∙),
threshold E and model size penalty f (∙). Yurochkin et al. (2019a;b;C) studied fusion, i.e. aggregation,
3
Published as a conference paper at ICLR 2020
of model parameters in a range of applications. The most relevant to our setting is Probabilistic
Federated Neural Matching (PFNM) (Yurochkin et al., 2019b). They arrived at a special case of
equation 3 to compute maximum a posteriori estimate (MAP) of their Bayesian nonparametric model
based on the Beta-Bernoulli process (BBP) (Thibaux & Jordan, 2007), where similarity c(wjl , θi)
is the corresponding posterior probability of jth client neuron l generated from a Gaussian with
mean θ%, and E and f (∙) are guided by the Indian Buffet Process prior (Ghahramani & Griffiths,
2005). Instead of making heuristic choices, this formulation provides a model-based specification
of equation 3. We refer to a procedure for solving equation 2 with the setup from Yurochkin et al.
(2019b) as BBP-MAP. We note that their PFNM is only applicable to fully connected architectures
limiting its practicality. Our matched averaging perspective allows to formulate averaging of widely
used architectures such as CNNs and LSTMs as instances of equation 2 and utilize the BBP-MAP
as a solver.
2.2	Permutation invariance of key architectures
Before moving onto the convolutional and recurrent architectures, we discuss permutation invariance
in deep fully connected networks and corresponding matched averaging approach. We will utilize
this as a building block for handling LSTMs and CNN architectures such as VGG (Simonyan &
Zisserman, 2014) widely used in practice.
Permutation invariance of deep FCs We extend equation 1 to recursively define deep FC net-
work:
xn = σ(xn-1ΠTn-1WnΠn),	(4)
where n = 1, . . . , N is the layer index, Π0 is identity indicating non-ambiguity in the ordering of
input features X = xo and ∏n is identity for the same in output classes. Conventionally σ(∙) is any
non-linearity except for y = XN where it is the identity function (or softmax if We want probabilities
instead of logits). When N = 2, we recover a single hidden layer variant from equation 1. To
perform matched averaging of deep FCs obtained from J clients we need to find permutations for
every layer of every client. Unfortunately, permutations within any consecutive pair of intermediate
layers are coupled leading to a NP-hard combinatorial optimization problem. Instead we consider
recursive (in layers) matched averaging formulation. Suppose we have {Πj,n-1}, then plugging
{ΠjT,n-1Wj,n} into equation 2 we find {Πj,n} and move onto next layer. The recursion base for this
procedure is {Πj,0}, which we know is an identity permutation for any j.
Permutation invariance of CNNs The key observation in understanding permutation invariance
of CNNs is that instead of neurons, channels define the invariance. To be more concrete, let
Conv(X, W) define convolutional operation on input X with weights W ∈ RCin×w×h×Cout, where
Cin, Cout are the numbers of input/output channels and w, h are the width and height of the filters.
Applying any permutation to the output dimension of the weights and then same permutation to the
input channel dimension of the subsequent layer will not change the corresponding CNN’s forward
pass. Analogous to equation 4 we can write:
Xn = σ(Conv(Xn-1 , ΠTn-1WnΠn)).	(5)
Note that this formulation permits pooling operations as those act within channels. To apply matched
out
averaging for the nth CNN layer we form inputs to equation 2 as {wjl ∈ RD }l=n1 , j = 1, . . . , J,
where D is the flattened Cnin × w × h dimension of ΠjT,n-1Wj,n. This result can be alternatively
derived taking the im2col perspective. Similar to FCs, we can recursively perform matched averag-
ing on deep CNNs. The immediate consequence of our result is the extension of PFNM (Yurochkin
et al., 2019b) to CNNs. Empirically, see Figure 1, we found that this extension performs well on
MNIST with a simpler CNN architecture such as LeNet (LeCun et al., 1998) (4 layers) and signif-
icantly outperforms coordinate-wise weight averaging (1 round FedAvg). However, it breaks down
for more complex architecture, e.g. VGG-9 (Simonyan & Zisserman, 2014) (9 layers), needed to
obtain good quality prediction on a more challenging CIFAR-10.
Permutation invariance of LSTMs Permutation invariance in the recurrent architectures is as-
sociated with the ordering of the hidden states. At a first glance it appears similar to fully con-
nected architecture, however the important difference is associated with the permutation invariance
4
Published as a conference paper at ICLR 2020
of the hidden-to-hidden weights H ∈ RL×L, where L is the number of hidden states. In particu-
lar, permutation of the hidden states affects both rows and columns of H . Consider a basic RNN
ht = σ(ht-1H + xtW), where W are the input-to-hidden weights. To account for the permutation
invariance of the hidden states, we notice that dimensions of ht should be permuted in the same way
for any t, hence
ht = σ(ht-1ΠTHΠ + xtWΠ).	(6)
To match RNNs, the basic sub-problem is to align hidden-to-hidden weights of two clients with
Euclidean similarity, which requires minimizing kΠTHjΠ - Hj0 k22 over permutations Π. This
is a quadratic assignment problem known to be NP-hard (Loiola et al., 2007). Fortunately, the
same permutation appears in an already familiar context of input-to-hidden matching of WΠ. Our
matched averaging RNN solution is to utilize equation 2 plugging-in input-to-hidden weights {Wj }
to find {Πj}. Then federated hidden-to-hidden weights are computed as H = J Pj ΠjHhnT
and input-to-hidden weights are computed as before. We note that Gromov-Wasserstein distance
(Gromov, 2007) from the optimal transport literature corresponds to a similar quadratic assignment
problem. It may be possible to incorporate hidden-to-hidden weights H into the matching algorithm
by exploring connections to approximate algorithms for computing Gromov-Wasserstein barycenter
(Peyre et al., 2016). We leave this possibility for future work.
To finalize matched averaging of LSTMs, we discuss several specifics of the architecture. LSTMs
have multiple cell states, each having its individual hidden-to-hidden and input-to-hidden weights.
In out matched averaging we stack input-to-hidden weights into SD × L weight matrix (S is the
number of cell states; D is input dimension and L is the number of hidden states) when computing
the permutation matrices and then average all weights as described previously. LSTMs also often
have an embedding layer, which we handle like a fully connected layer. Finally, we process deep
LSTMs in the recursive manner similar to deep FCs.
2.3	Federated Matched Averaging (FedMA) algorithm
Defining the permutation invariance classes of CNNs and LSTMs allows us to extend PFNM
(Yurochkin et al., 2019b) to these architectures, however our empirical study in Figure 1 demon-
strates that such extension fails on deep architectures necessary to solve more complex tasks. Our
results suggest that recursive handling of layers with matched averaging may entail poor overall
solution. To alleviate this problem and utilize the strength of matched averaging on “shallow” archi-
tectures, we propose the following layer-wise matching scheme. First, data center gathers only the
weights of the first layers from the clients and performs one-layer matching described previously
to obtain the first layer weights of the federated model. Data center then broadcasts these weights
to the clients, which proceed to train all consecutive layers on their datasets, keeping the matched
federated layers frozen. This procedure is then repeated up to the last layer for which we conduct
a weighted averaging based on the class proportions of data points per client. We summarize our
Federated Matched Averaging (FedMA) in Algorithm 1. The FedMA approach requires communi-
cation rounds equal to the number of layers in a network. In Figure 1 we show that with layer-wise
matching FedMA performs well on the deeper VGG-9 CNN as well as LSTMs. In the more chal-
lenging heterogeneous setting, FedMA outperforms FedAvg, FedProx trained with same number of
communication rounds (4 for LeNet and LSTM and 9 for VGG-9) and other baselines, i.e. client
individual CNNs and their ensemble.
FedMA with communication We’ve shown that in the heterogeneous data scenario FedMA out-
performs other federated learning approaches, however it still lags in performance behind the entire
data training. Of course the entire data training is not possible under the federated learning con-
straints, but it serves as performance upper bound we should strive to achieve. To further improve
the performance of our method, we propose FedMA with communication, where local clients receive
the matched global model at the beginning of a new round and reconstruct their local models with
the size equal to the original local models (e.g. size of a VGG-9) based on the matching results of
the previous round. This procedure allows to keep the size of the global model small in contrast
to a naive strategy of utilizing full matched global model as a starting point across clients on every
round.
5
Published as a conference paper at ICLR 2020
Algorithm 1: Federated Matched Averaging (FedMA)
Input : local weights of N -layer architectures {Wj,1, . . . , Wj,N}jJ=1 from J clients
Output: global weights {W1, . . . , WN}
n = 1;
while n ≤ N do
if n < N then
{Πj}J=ι =BBP-MAP({Wj,n}J=J ;	// call BBP-MAP to solve Eq. 2
Wn = J Pj Wj,nπT;
else
I Wn = PK=I Pj Pjk Wjin where Pk is fraction of data points with label k on worker j;
end
for j ∈ {1, . . . , J} do
Wj,n+ι J ΠjWj,n+ι ;	// permutate the next-layer weights
Train {Wj,n+ι,..., W7-,l} with Wn frozen;
end
n=n+1;
end
3 Experiments
We present an empirical study of FedMA with communication and compare it with state-of-the-art
methods i.e. FedAvg (McMahan et al., 2017) and FedProx (Sahu et al., 2018); analyze the perfor-
mance under the growing number of clients and visualize the matching behavior of FedMA to study
its interpretability. Our experimental studies are conducted over three real world datasets. Summary
information about the datasets and associated models can be found in supplement Table 3.
Experimental Setup We implemented FedMA and the considered baseline methods in PyTorch
(Paszke et al., 2017). We deploy our empirical study under a simulated federated learning environ-
ment where we treat one centralized node in the distributed cluster as the data center and the other
nodes as local clients. All nodes in our experiments are deployed on p3.2xlarge instances on Ama-
zon EC2. We assume the data center samples all the clients to join the training process for every
communication round for simplicity.
For the CIFAR-10 dataset, we use data augmentation (random crops, and flips) and normalize each
individual image (details provided in the Supplement). We note that we ignore all batch normaliza-
tion (Ioffe & Szegedy, 2015) layers in the VGG architecture and leave it for future work.
For CIFAR-10, we considered two data partition strategies to simulate federated learning scenario:
(i) homogeneous partition where each local client has approximately equal proportion of each of
the classes; (ii) heterogeneous partition for which number of data points and class proportions are
unbalanced. We simulated a heterogeneous partition into J clients by sampling Pk 〜 DirJ(0.5)
and allocating a pk,j proportion of the training instances of class k to local client j. We use the
original test set in CIFAR-10 as our global test set for comparing performance of all methods. For
the Shakespeare dataset, we treat each speaking role as a client (Caldas et al., 2018) resulting in a
natural heterogeneous partition. We preprocess the Shakespeare dataset by filtering out the clients
with less than 10k datapoints and sampling a random subset of J = 66 clients. We allocate 80% of
the data for training and amalgamate the remaining data into a global test set.
Communication Efficiency and Convergence Rate In this experiment we study performance of
FedMA with communication. Our goal is to compare our method to FedAvg and FedProx in terms
of the total message size exchanged between data center and clients (in Gigabytes) and the number
of communication rounds (recall that completing one FedMA pass requires number of rounds equal
to the number of layers in the local models) needed for the global model to achieve good perfor-
mance on the test data. We also compare to the performance of an ensemble method. We evaluate
all methods under the heterogeneous federated learning scenario on CIFAR-10 with J = 16 clients
with VGG-9 local models and on Shakespeare dataset with J = 66 clients with 1-layer LSTM net-
6
Published as a conference paper at ICLR 2020
Amount of Comm. (GB)
Round of Comm.
(a) LSTM, Shakespeare; message size
Amount of Comm. (GB)
(c) VGG-9, CIFAR-10; message size
Figure 2: Convergence rates of various methods in two federated learning scenarios: training VGG-9 on
CIFAR-10 with J = 16 clients and training LSTM on Shakespeare dataset with J = 66 clients.
(b) LSTM, Shakespeare; rounds
Round of Comm.
(d) VGG-9, CIFAR-10; rounds
work. We fix the total rounds of communication allowed for FedMA, FedAvg, and FedProx i.e. 11
rounds for FedMA and 99/33 rounds for FedAvg and FedProx for the VGG-9/LSTM experiments
respectively. We notice that number of local training epochs is a common parameter shared by the
three considered methods, we thus tune this parameter (denoted E; comprehensive analysis will be
presented in the next experiment) and report the convergence rate under E that yields the best final
model accuracy over the global test set. We also notice that there is another hyper-parameter in
FedProx i.e. the coefficient μ associated with the proxy term, We also tune the parameter using grid
search and report the best μ we found (0.001) for both VGG-9 and LSTM experiments. FedMA out-
performs FedAvg and FedProx in all scenarios (Figure 2) with its advantage especially pronounced
when we evaluate convergence as a function of the message size in Figures 2(a) and 2(c). Final
performance of all trained models is summarized in Tables 1 and 2.
Effect of local training epochs As studied in previous
work (McMahan et al., 2017; Caldas et al., 2018; Sahu et al.,
2018), the number of local training epochs E can affect
the performance of FedAvg and sometimes lead to diver-
gence. We conduct an experimental study on the effect of
E over FedAvg, FedProx, and FedMA on VGG-9 trained on
CIFAR-10 under heterogeneous setup. The candidate local
epochs we consider are E ∈ {10, 20, 50, 70, 100, 150}. For
each of the candidate E, we run FedMA for 6 rounds while
FedAvg and FedProx for 54 rounds and report the final ac-
curacy that each methods achieves. The result is shown in
Figure 3. We observe that training longer benefits FedMA,
supporting our assumption that FedMA performs best on lo-
Figure 3: The effect of number of local
training epochs on various methods.
cal models with higher quality. For FedAvg, longer local training leads to deterioration of the final
accuracy, which matches the observations made in the previous literature (McMahan et al., 2017;
Caldas et al., 2018; Sahu et al., 2018). FedProx only partially alleviates this problem. The result
7
Published as a conference paper at ICLR 2020
of this experiment suggests that FedMA is the only method that local clients can use to train their
model as long as they want.
Table 1: Trained models summary for VGG-9 trained on CIFAR-10 as shown in Figure 2
Method	FedAvg	FedProx	Ensemble	FedMA
Final Accuracy(%)	86.29	85.32	75.29	87.53
Best local epoch(E)	20	20	N/A	150
Model growth rate	1×	1×	16×	1.11×
Table 2: Trained models summary for LSTM trained on Shakespeare as shown in Figure 2
Method	FedAvg	FedProx	Ensemble	FedMA
Final Accuracy(%)	46.63	45.83	46.06	49.07
Best local epoch(E)	2	5	N/A	5
Model growth rate	1×	1×	66×	1.06×
Handling data bias Real world data often exhibit multimodality within each class, e.g. geo-
diversity. It has been shown that an observable amerocentric and eurocentric bias is present in the
widely used ImageNet dataset (Shankar et al., 2017; Russakovsky et al., 2015). Classifiers trained
on such data “learn” these biases and perform poorly on the under-represented domains (modalities)
since correlation between the corresponding dominating domain and class can prevent the classifier
from learning meaningful relations between features and classes. For example, classifier trained
on amerocentric and eurocentric data may learn to associate white color dress with a “bride” class,
therefore underperforming on the wedding images taken in countries where wedding traditions are
different (Doshi, 2018).
The data bias scenario is an important aspect of federated
learning, however it received little to no attention in the prior
federated learning works. In this study we argue that FedMA
can handle this type of problem. If we view each domain,
e.g. geographic region, as one client, local models will not
be affected by the aggregate data biases and learn meaning-
ful relations between features and classes. FedMA can then
be used to learn a good global model without biases. We
have already demonstrated strong performance of FedMA on
federated learning problems with heterogeneous data across
clients and this scenario is very similar. To verify this con-
jecture we conduct the following experiment.
Methods
Figure 4: Performance on skewed
CIFAR-10 dataset.
We simulate the skewed domain problem with CIFAR-10 dataset by randomly selecting 5 classes
and making 95% training images in those classes to be grayscale. For the remaining 5 we turn
only 5% of the corresponding images into grayscale. By doing so, we create 5 grayscale images
dominated classes and 5 colored images dominated classes. In the test set, there is half grayscale and
half colored images for each class. We anticipate entire data training to pick up the uninformative
correlations between greyscale and certain classes, leading to poor test performance without these
correlations. In Figure 4 we see that entire data training performs poorly in comparison to the regular
(i.e. No Bias) training and testing on CIFAR-10 dataset without any grayscaling. This experiment
was motivated by Olga Russakovsky’s talk at ICML 2019.
Next we compare the federated learning based approaches. We split the images from color domi-
nated classes and grayscale dominated classes into 2 clients. We then conduct FedMA with com-
munication, FedAvg, and FedProx with these 2 clients. FedMA noticeably outperforms the entire
8
Published as a conference paper at ICLR 2020
O-
10-
IS-
20-
25-
0	5	10	15	20	25	30
(a) Raw input1
0
5
10
IS
20
25
30
0
5
10
15
20
25
30
0	5	10	15	20	25	30
(C) Client1, filter。
0
0
5
10
15
20
25
0-
5
ιo∙ l>
15
20
25
0	5	10	15	20	25	30
(e) FedAvg filter 0
0
5
10
(f) Raw input2
5
10
15
20
25
30
(b) FedMA filter 0
0
(g) FedMA filter 0
5
10
15
20
25
30
(h) Client 1, filter0
5
10
15
20
25
30
0	5	10	15	20	25	30
(d) Client2, filter 23
0
30
0	5	10	15	20	25	30
(i) Client 2, filter23
5
10
15
20
25
30
0	5	10	15	20	25	30
(j) FedAvg filter。
Figure 5: Representations generated by the first convolution layers of locally trained models, FedMA global
model and the FedAvg global model.
data training and other federated learning approaCh as shown in Figure 4. This result suggests that
FedMA may be of interest beyond learning under the federated learning Constraints, where entire
data training is the performanCe upper bound, but also to eliminate data biases and outperform entire
data training.
We Consider two additional approaChes to eliminate data bias without the federated learning Con-
straints. One way to alleviate data bias is to seleCtively ColleCt more data to debias the dataset. In the
Context of our experiment, this means getting more Colored images for graysCale dominated Classes
and more graysCale images for Color dominated Classes. We simulate this sCenario by simply doing
a full data training where eaCh Class in both train and test images has equal amount of graysCale and
Color images. This proCedure, Color BalanCed, performs well, but seleCtive ColleCtion of new data
in praCtiCe may be expensive or even not possible. Instead of ColleCting new data, one may Consider
oversampling from the available data to debias. In Oversampling, we sample the underrepresented
domain (via sampling with replaCement) to make the proportion of Color and graysCale images to be
equal for eaCh Class (oversampled images are also passed through the data augmentation pipeline,
e.g. random flipping and Cropping, to further enforCe the data diversity). SuCh proCedure may be
prone to overfitting the oversampled images and we see that this approaCh only provides marginal
improvement of the model aCCuraCy Compared to Centralized training over the skewed dataset and
performs notiCeably worse than FedMA.
Data efficiency It is known that deep learning models per-
form better when more training data is available. However,
under the federated learning Constraints, data effiCienCy has
not been studied to the best of our knowledge. The Challenge
here is that when new Clients join the federated system, they
eaCh bring their own version of the data distribution, whiCh,
if not handled properly, may deteriorate the performanCe de-
spite the growing data size aCross the Clients. To simulate
this sCenario we first partition the entire training CIFAR-1。
dataset into 5 homogeneous pieCes. We then partition eaCh
homogeneous data pieCe further into 5 sub-pieCes hetero-
geneously. Using this strategy, we partition the CIFAR-1。
training set into 25 heterogeneous small sub-datasets Con-
Number of Clients
Figure 6: Data effiCienCy under the in-
Creasing number of Clients.
taining approximately 2k points eaCh. We ConduCt a 5-step experimental study: starting from a
randomly seleCted homogeneous pieCe Consisting of 5 assoCiated heterogeneous sub-pieCes, we
simulate a 5-Client federated learning heterogeneous problem. For eaCh ConseCutive step, we add
one of the remaining homogeneous data pieCes Consisting of 5 new Clients with heterogeneous sub-
datasets. Results are presented in Figure 6. PerformanCe of FedMA (with a single pass) improves
9
Published as a conference paper at ICLR 2020
when new clients are added to the federated learning system, while FedAvg with 9 communication
rounds deteriorates.
Interpretability One of the strengths of FedMA is that it utilizes communication rounds more ef-
ficiently than FedAvg. Instead of directly averaging weights element-wise, FedMA identifies match-
ing groups of convolutional filters and then averages them into the global convolutional filters. It’s
natural to ask “How does the matched filters look like?”. In Figure 5 we visualize the represen-
tations generated by a pair of matched local filters, aggregated global filter, and the filter returned
by the FedAvg method over the same input image. Matched filters and the global filter found with
FedMA are extracting the same feature of the input image, i.e. filter 0 of client 1 and filter 23 of
client 2 are extracting the position of the legs of the horse, and the corresponding matched global
filter 0 does the same. For the FedAvg, global filter 0 is the average of filter 0 of client 1 and filter 0
of client 2, which clearly tampers the leg extraction functionality of filter 0 of client 1.
4 Conclusion
We presented Federated Matched Averaging (FedMA), a layer-wise federated learning algorithm
designed for modern CNNs and LSTMs architectures that accounts for permutation invariance of
the neurons and permits global model size adaptation. Our method significantly outperforms prior
federated learning algorithms in terms of its convergence when measured by the size of messages
exchanged between server and the clients during training. We demonstrated that FedMA can effi-
ciently utilize well-trained local modals, a property desired in many federated learning applications,
but lacking in the prior approaches. We have also presented an example where FedMA can help to
resolve some of the data biases and outperform aggregate data training.
In the future work we want to extend FedMA to improve federated learning of LSTMs using approxi-
mate quadratic assignment solutions from the optimal transport literature, and enable additional deep
learning building blocks, e.g. residual connections and batch normalization layers. We also believe
it is important to explore fault tolerance of FedMA and study its performance on the larger datasets,
particularly ones with biases preventing efficient training even when the data can be aggregated, e.g.
Inclusive Images (Doshi, 2018).
References
Martial Agueh and Guillaume Carlier. Barycenters in the wasserstein space. SIAM Journal on
Mathematical Analysis, 43(2):904-924, 2011.
Keith Bonawitz, Hubert Eichner, Wolfgang Grieskamp, Dzmitry Huba, Alex Ingerman, Vladimir
Ivanov, Chloe Kiddon, Jakub Konecny, Stefano Mazzocchi, H Brendan McMahan, et al. Towards
federated learning at scale: System design. arXiv preprint arXiv:1902.01046, 2019.
Sebastian Caldas, Peter Wu, Tian Li, Jakub Konecny, H Brendan McMahan, Virginia Smith, and
Ameet Talwalkar. Leaf: A benchmark for federated settings. arXiv preprint arXiv:1812.01097,
2018.
Tulsee Doshi. Introducing the inclusive images competition, 2018.
Zoubin Ghahramani and Thomas L Griffiths. Infinite latent feature models and the Indian buffet
process. In Advances in Neural Information Processing Systems, pp. 475-482, 2005.
Mikhail Gromov. Metric structures for Riemannian and non-Riemannian spaces. Springer Science
& Business Media, 2007.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by
reducing internal covariate shift. arXiv preprint arXiv:1502.03167, 2015.
Peter Kairouz, H Brendan McMahan, Brendan Avent, Aurelien Bellet, Mehdi Bennis, Arjun Nitin
Bhagoji, Keith Bonawitz, Zachary Charles, Graham Cormode, Rachel Cummings, et al. Advances
and open problems in federated learning. arXiv preprint arXiv:1912.04977, 2019.
10
Published as a conference paper at ICLR 2020
Harold W Kuhn. The Hungarian method for the assignment problem. Naval Research Logistics
(NRL), 2(1-2):83-97,1955.
Yann LeCun, Leon Bottou, Yoshua Bengio, Patrick Haffner, et al. Gradient-based learning applied
to document recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.
Tian Li, Anit Kumar Sahu, Ameet Talwalkar, and Virginia Smith. Federated learning: Challenges,
methods, and future directions. arXiv preprint arXiv:1908.07873, 2019.
Eliane Maria Loiola, Nair Maria Maia de Abreu, Paulo Oswaldo Boaventura-Netto, Peter Hahn, and
Tania Querido. A survey for the quadratic assignment problem. European journal of operational
research, 176(2):657-690, 2007.
Brendan McMahan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Aguera y Arcas.
Communication-efficient learning of deep networks from decentralized data. In Artificial Intelli-
gence and Statistics, pp. 1273-1282, 2017.
Mehryar Mohri, Gary Sivek, and Ananda Theertha Suresh. Agnostic federated learning. In Interna-
tional Conference on Machine Learning, pp. 4615-4625, 2019.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
pytorch. In NIPS-W, 2017.
Gabriel Peyre, Marco Cuturi, and Justin Solomon. Gromov-Wasserstein averaging of kernel and
distance matrices. In International Conference on Machine Learning, pp. 2664-2672, 2016.
Sashank J. Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. In
International Conference on Learning Representations, 2018. URL https://openreview.
net/forum?id=ryQu7f-RZ.
Olga Russakovsky. Strategies for mitigating social bias in deep learning systems. Invited talk at
Identifying and Understanding Deep Learning Phenomena Workshop, ICML 2019.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, et al. Imagenet large scale visual
recognition challenge. International journal of computer vision, 115(3):211-252, 2015.
Anit Kumar Sahu, Tian Li, Maziar Sanjabi, Manzil Zaheer, Ameet TalWalkar, and Virginia Smith.
On the convergence of federated optimization in heterogeneous netWorks. arXiv preprint
arXiv:1812.06127, 2018.
Shreya Shankar, Yoni Halpern, Eric Breck, James AtWood, Jimbo Wilson, and D Sculley. No classi-
fication Without representation: Assessing geodiversity issues in open data sets for the developing
World. arXiv preprint arXiv:1711.08536, 2017.
Karen Simonyan and AndreW Zisserman. Very deep convolutional netWorks for large-scale image
recognition. arXiv preprint arXiv:1409.1556, 2014.
Sidak Pal Singh and Martin Jaggi. Model fusion via optimal transport. arXiv preprint
arXiv:1910.05653, 2019.
Virginia Smith, Chao-Kai Chiang, Maziar Sanjabi, and Ameet S TalWalkar. Federated multi-task
learning. In Advances in Neural Information Processing Systems, pp. 4424-4434, 2017.
Romain Thibaux and Michael I Jordan. Hierarchical Beta processes and the Indian buffet process.
In Artificial Intelligence and Statistics, pp. 564-571, 2007.
Mikhail Yurochkin, Mayank AgarWal, Soumya Ghosh, Kristjan GreeneWald, and Nghia Hoang. Sta-
tistical model aggregation via parameter matching. In Advances in Neural Information Processing
Systems, pp. 10954-10964, 2019a.
Mikhail Yurochkin, Mayank AgarWal, Soumya Ghosh, Kristjan GreeneWald, Nghia Hoang, and
Yasaman Khazaeni. Bayesian nonparametric federated learning of neural netWorks. In Interna-
tional Conference on Machine Learning, pp. 7252-7261, 2019b.
11
Published as a conference paper at ICLR 2020
Mikhail Yurochkin, Zhiwei Fan, Aritra Guha, Paraschos Koutris, and XuanLong Nguyen. Scalable
inference of topic evolution via models for latent geometric structures. In Advances in Neural
Information Processing Systems,pp. 5949-5959, 2019c.
12
Published as a conference paper at ICLR 2020
A Summary of the datasets used in the experiments
The details of the datasets and hyper-parameters used in our experiments are summarized in Table
3. In conducting the “freezing and retraining” process of FedMA, we notice when retraining the last
FC layer while keeping all previous layers frozen, the initial learning rate we use for SGD doesn’t
lead to a good convergence (this is only for the VGG-9 architecture). To fix this issue, we divide
the initial learning rate by 10 i.e. using 10-4 for the last FC layer retraining and allow the clients to
retrain for 3 times more epochs. We also switch off the `2 weight decay during the “freezing and
retraining” process of FedMA except for the last FC layer where we use a `2 weight decay of 10-4 .
For language task, we observe SGD with a constant learning rate works well for all considered
methods.
In our experiments, we use FedAvg and FedProx variants without the shared initialization since
those would likely be more realistic when trying to aggregate locally pre-trained models. And
FedMA still performs well in practical scenarios where local clients won’t be able to share the
random initialization.
Table 3: The datasets used and their associated learning models and hyper-parameters.
Method	MNIST	CIFAR-10	Shakespeare (McMahan et al., 2017)
# Data points	60, 000	50, 000	1, 017, 981
Model	LeNet	VGG-9	LSTM
# Classes	10	10	80
# Parameters	431k	3, 491k	293k
Optimizer		SGD	SGD
Hyper-params.	Init lr: 0.01, 0.001 (last layer)		lr: 0.8(const)
		momentum: 0.9, `2 weight decay: 10-4	
B Details of Model Architectures and Hyper-parameters
The details of the model architectures we used in the experiments are summarized in this section.
Specifically, details of the VGG-9 model architecture we used can be found in Table 4 and details of
the 1-layer LSTM model used in our experimental study can be found in Table 5.
C Data augmentation and normalization details
In preprocessing the images in CIFAR-10 dataset, we follow the standard data augmentation
and normalization process. For data augmentation, random cropping and horizontal random
flipping are used. Each color channels are normalized with mean and standard deviation by
μr = 0.491372549,μg = 0.482352941,μb = 0.446666667, σr = 0.247058824,σg =
0.243529412, σb = 0.261568627. Each channel pixel is normalized by subtracting the mean value
in this color channel and then divided by the standard deviation of this color channel.
D Extra Experimental Details
D.1 Shapes of Final Global Model
Here we report the shapes of final global VGG and LSTM models returned by FedMA with com-
munication.
13
Published as a conference paper at ICLR 2020
Table 4: Detailed information of the VGG-9 architecture used in our experiments, all non-linear activation
function in this architecture is ReLU; the shapes for convolution layers follows (Cin , Cout , c, c)
Parameter	Shape	Layer hyper-parameter
layer1.conv1.weight	3 × 32 × 3 × 3	stride:1;padding:1
layer1.conv1.bias	32	N/A
layer2.conv2.weight	32 × 64 × 3 × 3	stride:1;padding:1
layer2.conv2.bias	64	N/A
pooling.max	N/A	kernel size:2;stride:2
layer3.conv3.weight	64× 128 × 3 × 3	stride:1;padding:1
layer3.conv3.bias	128	N/A
layer4.conv4.weight	128× 128×3×3	stride:1;padding:1
layer4.conv4.bias	128	N/A
pooling.max	N/A	kernel size:2;stride:2
dropout	N/A	p = 5%
layer5.conv5.weight	128 ×256 ×3×3	stride:1;padding:1
layer5.conv5.bias	256	N/A
layer6.conv6.weight	256 × 256 × 3 × 3	stride:1;padding:1
layer6.conv6.bias	256	N/A
pooling.max	N/A	kernel size:2;stride:2
dropout	N/A	p= 10%
layer7.fc7.weight	4096 × 512	N/A
layer7.fc7.bias	512	N/A
layer8.fc8.weight	512× 512	N/A
layer8.fc8.bias	512	N/A
dropout	N/A	p= 10%
layer9.fc9.weight	512 × 10	N/A
layer9.fc9.bias	10	N/A
Table 5: Detailed information of the LSTM architecture in our experiment
Parameter	Shape
encoder.weight	80 × 8
lstm.weight.ih.l0	1024 × 8
lstm.weight.hh.l0	1024 × 256
lstm.bias.ih.l0	1024
lstm.bias.hh.l0	1024
decoder.weight	80 × 256
decoder.bias	80
14
Published as a conference paper at ICLR 2020
Table 6: Detailed information of the LSTM architecture in our experiment
Parameter	Shape	Growth rate (#global / #original params)
encoder.weight	80 X 21	2.63 × (1, 680/640)
lstm.weight.ih.l0	1028 × 21	2.64 × (21, 588/8, 192)
lstm.weight.hh.l0	1028 × 257	1.01 × (264, 196/262, 144)
lstm.bias.ih.l0	1028	1.004 × (1, 028/1, 024)
lstm.bias.hh.l0	1028	1.004 × (1, 028/1, 024)
decoder.weight	80 × 257	1.004 × (20, 560/20, 480)
decoder.bias	80	1×
Total Number of Parameters	310,160	1.06× (310, 160/293, 584)
Table 7: Detailed information of the final global VGG-9 model returned by FRB; the shapes for convolution
layers follows (Cin , Cout , c, c)
Parameter	Shape	Growth rate (#global / #original params)
layer1.conv1.weight	3 × 47 × 3 × 3	1.47 × (1, 269/864)
layer1.conv1.bias	47	1.47 × (47/32)
layer2.conv2.weight	47 × 79 × 3 × 3	1.81 × (33, 417/18, 432)
layer2.conv2.bias	79	1.23 × (79/64)
layer3.conv3.weight	79 × 143 × 3 × 3	1.38 × (101, 673/73, 728)
layer3.conv3.bias	143	1.12 × (143/128)
layer4.conv4.weight	143 × 143 × 3 × 3	1.24 × (184, 041/147, 456)
layer4.conv4.bias	143	1.12 × (143/128)
layer5.conv5.weight	143 × 271 × 3 × 3	1.18 × (348, 777/294, 912)
layer5.conv5.bias	271	1.06 × (271/256)
layer6.conv6.weight	271 × 271 × 3 × 3	1.12 × (660, 969/589, 824)
layer6.conv6.bias	271	1.06 × (271/256)
layer7.fc7.weight	4336 × 527	1.09 × (2, 285, 072/2, 097, 152)
layer7.fc7.bias	527	1.02 × (527/512)
layer8.fc8.weight	527 × 527	1.05×, (277, 729/262, 144)
layer8.fc8.bias	527	1.02 × (527/512)
layer9.fc9.weight	527 × 10	1.02 × (5, 270/5, 120)
layer9.fc9.bias	10	1×
Total Number of Parameters	3, 900, 235	1.11× (3, 900, 235/3, 491, 530)
D.2 Hyper-parameters for BBP-MAP
We follow FPNM (Yurochkin et al., 2019b) to choose the hyper-parameters of BBP-MAP, which
controls the choices of θi, e, and the f (∙) as discussed in Section 2. More specifically, there are three
parameters to choose i.e. 1) σ02, the prior variance of weights of the global neural network; 2) γ0,
which controls discovery of new hidden states. Increasing γ0 leads to a larger final global model; 3)
σ2 is the variance of the local neural network weights around corresponding global network weights.
We empirically analyze the different choices of the three hyper-parameters and find the choice of
15
Published as a conference paper at ICLR 2020
γ0 = 7, σ02 = 1,σ2 = 1 for VGG-9 on CIFAR-10 dataset and γ0 = 10-3,σ02 = 1,σ2 = 1 for
LSTM on Shakespeare dataset lead to good performance in our experimental studies.
E Practical Considerations
Following from the discussion in PFNM, here we briefly discuss the time complexity of FedMA.
For simplicity, we focus on a single-layer matching and assume all participating clients train the
same model architecture. The complexity for matching the entire model follows trivially from this
discussion. The worst case complexity is achieved when no hidden states are matched and is equal
to O(D ∙ (JL)2) for building the cost matrix and O((JL)3) for running the Hungarian algorithm
where the definitions of D, J, and L follow the discussion in Section 2. The best complexity per
layer is (achieved when all hidden states are matched) O(D ∙ L2 + L3). Practically, when the number
of participating clients i.e. J is large and each client trains a big model, the speed of our algorithm
can be relatively slow.
To seed up the Hungarian algorithm. Although there isn’t any algorithm that achieves lower com-
plexity, better implementation improves the constant significantly. In our experiments, we used an
implementation based on shortest path augmentation i.e. lapsolver 2. Empirically, we observed
that this implementation of the Hungarian algorithm leads to orders of magnitude speed ups over the
vanilla implementation.
F Hyper-parameters for the Handling Data Bias Experiments
In conducting the “handling data bias” experiments. We re-tune the local epoch E for both FedAvg
and FedProx. The considered candidates of E are {5, 10, 20, 30}. We observe that a relatively
large choice of E can easily lead to poor convergence of FedAvg. While FedProx tolerates larger
choices of E better, a smaller E can always lead to good convergence. We use E = 5 for both
FedAvg and FedProx in our experiments. For FedMA, we choose E = 50 since it leads to a
good convergence. For the “oversampling” baseline, we found that using SGD to train VGG-9 over
oversampled dataset doesn’t lead to a good convergence. Moreover, when using constant learning
rate, SGD can lead to model divergence. Thus we use AMSGrad (Reddi et al., 2018) method
for the “oversampling” baseline and train for 800 epochs. To make the comparison fair, we use
AMS Grad for all other centralized baselines to get the reported results in our experiments. Most
of them converges when training for 200 epochs. We also test the performance of the “Entire Data
Training”, “Color Balanced”, and “No Bias” baselines over SGD. We use learning rate 0.01 and `2
weight decay at 10-4 and train for 200 epochs for those three baselines. It seems the “Entire Data
Training” and ”No Bias” baselines converges to a slightly better accuracy i.e. 78.71% and 91.23%
respectively (compared to 75.91% and 88.5% for AMS GRAD). But the “Color Balanced” doesn’t
seem to converge better accuracy (we get 87.79% accuracy for SGD and 87.81% for AMSGRAD).
2https://github.com/cheind/py-lapsolver
16