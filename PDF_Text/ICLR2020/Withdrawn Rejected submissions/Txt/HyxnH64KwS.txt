Under review as a conference paper at ICLR 2020
The problem with DDPG: understanding fail-
URES IN DETERMINISTIC ENVIRONMENTS WITH
SPARSE REWARDS
Anonymous authors
Paper under double-blind review
Ab stract
In environments with continuous state and action spaces, state-of-the-art actor-critic
reinforcement learning algorithms can solve very complex problems, yet can also
fail in environments that seem trivial, but the reason for such failures is still poorly
understood. In this paper, we contribute a formal explanation of these failures in
the particular case of sparse reward and deterministic environments. First, using
a very elementary control problem, we illustrate that the learning process can get
stuck into a fixed point corresponding to a poor solution. Then, generalizing from
the studied example, we provide a detailed analysis of the underlying mechanisms
which results in a new understanding of one of the convergence regimes of these
algorithms. The resulting perspective casts a new light on already existing solutions
to the issues we have highlighted, and suggests other potential approaches.
1	Introduction
The Deep Deterministic Policy Gradient (ddpg) algorithm (Lillicrap et al. (2015)) is one of the
earliest deep Reinforcement Learning (rl) algorithms designed to operate on potentially large
continuous state and action spaces with a deterministic policy, and it is still one of the most widely
used. However, it is often reported that ddpg suffers from instability in the form of sensitivity
to hyper-parameters and propensity to converge to very poor solutions or even diverge. Various
algorithms have improved stability by addressing well identified issues, such as the over-estimation
bias in td3 (Fujimoto et al., 2018b) but, because a fundamental understanding of the phenomena
underlying these instabilities is still missing, it is unclear whether these ad hoc remedies truly address
the source of the problem. Thus, better understanding why these algorithms can fail even in very
simple environments is a pressing question.
To investigate this question, we introduce in Section 4 a very simple one-dimensional environment
with a sparse reward function where ddpg sometimes fails. Analyzing this example allows us to
provide a detailed account of these failures. We then reveal the existence of a cycle of mechanisms
operating in the sparse reward and deterministic case, leading to the quick convergence to a poor
policy. In particular, we show that, when the reward is not discovered early enough, these mechanisms
can lead to a deadlock situation where neither the actor nor the critic can evolve anymore. Critically,
this deadlock persists even when the agent is subsequently trained with rewarded samples.
The study of these mechanisms is backed-up with formal proofs in a simplified context where
the effects of function approximation is ignored. Nevertheless, the resulting understanding helps
analyzing the practical phenomena encountered when using actors and critics represented as neural
networks. From this new light, we revisit in Section 5 a few existing algorithms whose components
provide an alternative to the building blocks involved in the undesirable cyclic convergence process,
and we suggest alternative solutions to these issues.
2	Related work
Issues when combining rl with function approximation have been studied for a long time (Baird &
Klopf, 1993; Boyan & Moore, 1995; Tsitsiklis & Van Roy, 1997). In particular, it is well known that
1
Under review as a conference paper at ICLR 2020
deep rl algorithms can diverge when they meet three conditions coined as the ”deadly triad” (Sutton
& Barto, 2018), that is when they use (1) function approximation, (2) bootstrapping updates and (3)
off-policy learning. However, these questions are mostly studied in the continuous state, discrete
action case. For instance, several recent papers have studied the mechanism of this instability using
dqn (Mnih et al., 2013). In this context, four failure modes have been identified from a theoretical
point of view by considering the effect of a linear approximation of the deep-Q updates and by
identifying conditions under which the approximate updates of the critic are contraction maps for
some distance over Q-functions (Achiam et al., 2019). Meanwhile, van Hasselt et al. (2018) shows
that, due to its stabilizing heuristics, dqn does not diverge much in practice when applied to the
atari domain.
In contrast to these papers, here we study a failure mode specific to continuous action actor-critic
algorithms. It hinges on the fact that one cannot take the maximum over actions, and must rely on the
actor as a proxy for providing the optimal action instead. Therefore, the failure mode identified in
this paper cannot be reduced to any of the ones that affect dqn. Besides, the theoretical derivations
provided in the appendices show that the failure mode we are investigating does not depend on
function approximation errors, thus it cannot be directly related to the deadly triad.
More related to our work, several papers have studied failure to gather rewarded experience from
the environment due to poor exploration (Colas et al., 2018; Fortunato et al., 2017; Plappert et al.,
2017), but we go beyond this issue by studying a case where the reward is actually found but not
properly exploited. Finally, like us the authors of Fujimoto et al. (2018a) study a failure mode which
is specific to ddpg-like algorithms, but the studied failure mode is different. They show under a
batch learning regime that DDPG suffers from an extrapolation error phenomenon, whereas we are in
the more standard incremental learning setting and focus on a deadlock resulting from the shape of
the Q-function in the sparse reward case.
3	Background: Deep Deterministic Policy Gradient
The ddpg algorithm (Lillicrap et al., 2015) is a deep rl algorithm based on the Deterministic Policy
Gradient theorem (Silver et al., 2014). It borrows the use of a replay buffer and target networks
from dqn (Mnih et al., 2015). ddpg is an instance of the Actor-Critic model. It learns both an
actor function πψ (also called policy) and a critic function Qθ , represented as neural networks whose
parameters are respectively noted ψ and θ.
The deterministic actor takes a state s ∈ S as input and outputs an action a ∈ A. The critic maps
each state-action pair (s, a) to a value in R. The reward r : S × A → R, the termination function
t : S × A → {0, 1} and the discount factor γ < 1 are also specified as part of the environment.
The actor and critic are updated using stochastic gradient descent on two losses Lψ and Lθ . These
losses are computed from mini-batches of samples (si, ai, ri, ti, si+1), where each sample corre-
sponds to a transition si → si+1 resulting from performing action ai in state si , with subsequent
reward ri = r(si , ai) and termination index ti = t(si , ai).
Two target networks πψ0 and Qθ0 are also used in DDPG. Their parameters ψ0 and θ0 respectively track
ψ and θ using exponential smoothing. They are mostly useful to stabilize function approximation
when learning the critic and actor networks. Since they do not play a significant role in the phenomena
studied in this paper, we ignore them in the formal proofs given in appendices.
Equations (1) and (2) define Lψ and Lθ :
Lψ = - Qθ (si,πψ (si))	(1)
i
∀i, yi = ri + γ(1 - ti)Qθ0 (si+1, πψ0 (si+1))
Lθ = X hQθ (si, ai) - yii .
i
(2)
Training for the loss given in (1) yields the parameter update in (3), with α the learning rate:
2
Under review as a conference paper at ICLR 2020
ψ J ψ + α XX 加∂ψs)vaQθ (Si，叫。=∏ψ (Si).	⑶
As DDPG uses a replay buffer, the mini-batch samples are acquired using a behaviour policy β which
may be different from the actor π . Usually, β is defined as π plus a noise distribution, which in the
case of ddpg is either a Gaussian function or the more sophisticated Ornstein-Uhlenbeck noise.
Importantly for this paper, the behaviour of ddpg can be characterized as an intermediate between
two extreme regimes:
•	When the actor is updated much faster than the critic, the policy becomes greedy with
respect to this critic, resulting into a behaviour closely resembling that of the q-learning
algorithm. When it is close to this regime, ddpg can be characterized as off-policy.
•	When the critic is updated much faster than the actor, the critic tends towards Qπ (S， a). The
problems studied in this paper directly come from this second regime.
A more detailed characterization of these two regimes in given in Appendix A.
4 A new failure mode
In this section, we introduce a simplistic environment which we call 1D-toy. It is a one-dimensional,
discrete-time, continuous state and action problem, depicted in Figure 1.
,0 a = —0.1 a = 0.1
D / C C I
S = O -<------- -----------> s = l
left right
S= [0， 1]	(4a)
A = [-0.1， 0.1]	(4b)
S0 = 0	(4c)
St+1 = min (1， max (0， St + at))	(4d)
rt = tt = 1st+at<0	(4e)
Figure 1:	The 1 D-toy environment
Despite its simplicity, DDPG can fail on 1 D-TOY. We first show that DDPG fails to reach 100%
success. We then show that if learning a policy does not succeed soon enough, the learning process
can get stuck. Besides, we show that the initial actor can be significantly modified in the initial
stages before finding the first reward. We explain how the combination of these phenomena can
result into a deadlock situation. We generalize this explanation to any deterministic and sparse reward
environment by revealing and formally studying a undesirable cyclic process which arises in such
cases. Finally, we explore the consequences of getting into this cyclic process.
4.1	Empirical study
In all experiments, we set the maximum episode length N to 50, but the observed phenomena persist
with other values.
Residual failure to converge using different noise processes We start by running DDPG on the
1 D-toy environment. This environment is trivial as one infinitesimal step to the left is enough to
obtain the reward, end the episode and succeed, thus we might expect a quick 100% success. However,
the first attempt using an Ornstein-Uhlenbeck (OU) noise process shows that ddpg succeeds in only
94% of cases, see Figure 2a.
These failures might come from an exploration problem. Indeed, at the start of each episode the
OU noise process is reset to zero and gives little noise in the first steps of the episode. In order to
remove this potential source of failure, we replace the OU noise process with an exploration strategy
similar to -greedy which we call ”probabilistic noise”. For some 0 < p < 1, with probability p, the
action is randomly sampled (and the actor is ignored), and with probability 1 - p no noise is used
3
Under review as a conference paper at ICLR 2020
Simulation steps
(a) Success rate of ddpg with Ornstein-Uhlenbeck (b) Comparison between ddpg with probabilistic noise
(OU) and probabilistic noise. Even with probabilis- and a variant in which the behaviour policy is set to the
tic noise, DDPG fails on about 1%of the seeds.	optimal policy π* after 20k steps.
Figure 2:	Success rate of variants of ddpg on 1D-toy over learning steps, averaged over 10k seeds.
More details on learning algorithm and success evaluation are given in Appendix E.
and the raw action is returned. In our tests, we used p = 0.1. This guarantees at least a 5% chance of
success at the first step of each episode, for any policy. Nevertheless, Figure 2a shows that even with
probabilistic noise, about 1% of seeds still fail to converge to a successful policy in 1D-TOY, even
after 100k training steps. All the following tests are performed using probabilistic noise.
We now focus on these failures. On all failing seeds, we observe that the actor has converged to a
saturated policy that always goes to the right (∀s, π(s) = 0.1). However, some mini-batch samples
have non-zero rewards because the agent still occasionally moves to the left, due to the probabilistic
noise applied during rollouts. The expected fraction of non-zero rewards is slightly more than 0.1%1.
Figure 3a shows the occurrence of rewards in minibatches taken from the replay buffer when training
DDPG on 1 D-TOY. After each rollout (episode) of n steps, the critic and actor networks are trained n
times on minibatches of size 100. So for instance, a failed episode of size 50 is followed by a training
on a total of 5000 samples, out of which we expect more than 5 in average are rewarded transitions.
More details about the implementation are available in Appendix E.
The constant presence of rewarded transitions in the minibatches suggests that the failures of ddpg
on this environment are not due to insufficient exploration by the behaviour policy.
Correlation between finding the reward early and finding the optimal policy We have shown
that ddpg can get stuck in 1 D-toy despite finding the reward regularly. Now we show that when
ddpg finds the reward early in the training session, it is also more successful in converging to the
optimal policy. On the other hand, when the first reward is found late, the learning process more
often gets stuck with a sub-optimal policy.
From Figure 3b, the early steps appear to have a high influence on whether the training will be
successful or not. For instance, if the reward is found in the first 50 steps by the actor noise (which
happens in 63% of cases), then the success rate of ddpg is 100%. However, if the reward is first
found after more than 50 steps, then the success rate drops to 96%. Figure 3b shows that finding
the reward later results in lower success rates, down to 87% for runs in which the reward was not
found in the first 1600 steps. Therefore, we claim that there exists a critical time frame for finding the
reward in the very early stages of training.
Spontaneous actor drift At the beginning of each training session, the actor and critic of DDPG
are initialized to represent respectively close-to-zero state-action values and close-to-zero actions.
Besides, as long as the agent does not find a reward, it does not benefit from any utility gradient. Thus
we might expect that the actor and critic remain constant until the first reward is found. Actually, we
110% of steps are governed by probabilistic noise, of which at least 2% are the first episode step, of which
50% are steps going to the left and leading to the reward.
4
Under review as a conference paper at ICLR 2020
① 4d」① UUa.UnUUO paN-EE.ION
5 O
61|三一£ U- pωsn sω-dluπls p-πlMωD;
10-2 -:
10-3 -
IO-4 -
10-5 -
-15%
-10%
-5%
-0%
IO2 IO3
Step of earliest reward found
s⅞s ~00I」超d SUru Pa=BtO /
(a)	(b)
Figure 3:	(a) Number of rewards found in mini-batches during training. After a rollout of n steps, the
actor and critic are both trained on n minibatches of size 100. The red dotted line indicates an average
of 6.03 rewarded transitions present in these n minibatches. (b) In red, normalized probability of
finding the earliest reward at this step. In blue, for each earliest reward bin, fraction of these episodes
that fail to converge to a good actor after 100k steps. Note that when the reward is found after one or
two episodes, the convergence to a successful actor is certain.
show that even in the absence of reward, training the actor and critic triggers non-negligible updates
that cause the actor to reach a saturated state very quickly.
To investigate this, we use a variant of 1 D-toy called Drift where the only difference is that no
rewarded or terminal transitions are present in the environment. We also use a stripped-down version
of ddpg, removing rollouts and using random sampling of states and actions as minibatches for
training.
(a)	(b)
Figure 4:	Drift of max |Q| and max ∣π∣ in the DRIFT environment, for 10 different seeds. In the
absence of reward, the critic oscillates briefly before stabilizing. However, the actor very quickly
reaches a saturated state, at either ∀s, π(s) = 0.1 or -0.1.
Figure 4b shows that even in the absence of reward, the actor function drifts rapidly (notice the
horizontal scale in steps) to a saturated policy, in a number of steps comparable to the ”critical time
frame” identified above. The critic also has a transitive phase before stabilizing.
In Figure 4a, the fact that maxs,a |Q(s, a)| can increase in the absence of reward can seem counter-
intuitive, since in the loss function presented in Equation (2), |yi | can never be greater than
maxs,a |Q(s, a)|. However, it should be noted that the changes made to Q are not local to the
minibatch points, and increasing the value of Q for one input (s, a) may cause its value to increase
for other inputs too, which may cause an increase in the global maximum of Q. This phenomenon is
at the heart of the over-estimation bias when learning a critic (Fujimoto et al., 2018b), but this bias
does not play a key role here.
5
Under review as a conference paper at ICLR 2020
(a) Critic values in the deadlock configuration. The
critic is non-zero only in the region that immedi-
ately leads to a reward (s + a < 0)
(b) Two snapshots of the critic for different states
in a failed run. The high Q values in the s + a < 0
region are not propagated.
Figure 5:	Visualization of the critic in a failing run, in which the actor is stuck to ∀s, π(s) = 0.1.
Figure 6: Deadlock observed in 1 D -toy, represented as the cycle of red arrows.
4.2	Explaining the deadlock situation for ddpg on 1 D-toy
Up to now, we have shown that DDPG fails about 1% of times on 1 D-TOY, despite the simplicity of
this environment. We have now collected the necessary elements to explain the mechanisms of this
deadlock in 1D-toy.
Figure 5 shows the value of the critic in a failed run of ddpg on 1D-toy. We see that the value
of the reward is not propagated correctly outside of the region in which the reward is found in
a single step {(s, a) | s + a < 0}. The key of the deadlock is that once the actor has drifted to
∀s, π(s) = 0.1, it is updated according to VaQθ(s, a) ∖a=∏^(S) (Equation (3)). Figure 5b shows that
for a = π(s) = 0.1, this gradient is zero therefore the actor is not updated. Besides, the critic is
updated using yi = r(si, ai) + γQ(s0i, π(s0i)) as a target. Since Q(s0i, 0.1) is zero, the critic only
needs to be non-zero for directly rewarded actions, and for all other samples the target value remains
zero. In this state the critic loss given in Equation (2) is minimal, so there is no further update of the
critic and no further propagation of the state-action values. The combination of the above two facts
clearly results in a deadlock.
Importantly, the constitutive elements of this deadlock do not depend on the batches used to perform
the update, and therefore do not depend on the experience selection method. We tested this experi-
mentally by substituting the behaviour policy for the optimal policy after 20k training steps. Results
are presented in Figure 2b and show that, once stuck, even when it is given ideal samples, ddpg stays
stuck in the deadlock configuration. This also explains why finding the reward early results in better
performance. When the reward is found early enough, π(s0) has not drifted too far, and the gradient
of Q(s0, a) at a = π(s0) drives the actor back into the correct direction.
Note however that even when the actor drifts to the right, ddpg does not always fail. Indeed, because
of function approximators the shape of the critic when finding the reward for the first time varies, and
sometimes converges slowly enough for the actor to be updated before the convergence of the critic.
Figure 6 summarizes the above process. The entry point is represented using a green dot. First,
the actor drifts to ∀s, π(s) = 0.1, then the critic converges to Qπ which is a piecewise-constant
function (Experiment in Figure 5, proof in Theorem 1 in Appendix B), which in turn means that the
critic provides no gradient, therefore the actor is not updated (as seen in Equation 3, more details in
Theorem 2) 2 .
4.3	Generalization
Our study of 1 D-toy revealed how ddpg can get stuck in this simplistic environment. We now
generalize to the broader context of more general continuous action actor critic algorithms, including
2Note that Figure 5 shows a critic state which is slightly different from the one presented in Figure 6, due to
the limitations of function approximators.
6
Under review as a conference paper at ICLR 2020
Figure 7: A cyclic view of the undesirable convergence process in continuous action actor-critic
algorithms, in the deterministic and sparse reward case.
at least ddpg and td3, and acting in any deterministic and sparse reward environment. The
generalized deadlock mechanism is illustrated in Figure 7 and explained hereafter in the idealized
context of perfect approximators, with formal proofs rejected in appendices.
Entry point: As shown in the previous section, before the behaviour policy finds any reward,
training the actor and critic can still trigger non-negligible updates that may cause the actor to quickly
reach a poor state and stabilize. This defines our entry point in the process.
Q tends towards Qπ: A first step into the cycle is that, if the critic is updated faster than the policy,
the update rule of the critic Q given in Equation (2) makes Q converge to Qπ . This is presented in
detail in Appendix C.
Qπ is piecewise-constant: In Appendix D, we then show that, in a deterministic environment with
sparse terminal rewards, Qπ is piecewise-constant because V π (s0) only depends on two things: the
(integer) number of steps required to reach a rewarded state from s0 , and the value of this reward state,
which is itself piecewise-constant. Note that we can reach the same conclusion with non-terminal
rewards, by making the stronger hypothesis on the actor that ∀s, r(s, π(s)) = 0. Notably, this is the
case for the actor ∀s, π(s) = 0.1 on 1 D-TOY.
Q is approximately piecewise-constant and VaQ(s, a) 1=冗缶)≈ 0: Quite obviously, from Qπ
is piecewise-constant and Q tends towards Qπ, we can infer that Q progressively becomes almost
piecewise-constant as the cyclic process unfolds. Actually, the Q function is estimated by a function
approximator which is never truly discontinuous. The impact of this fact is studied in Section 4.5.
However, we can expect Q to have mostly flat gradients since it is trained to match a piecewise-
constant function. We can thus infer that, globally, VaQ(s, a)∣ɑ=∏(s) ≈ 0. And critically, the
gradients in the flat regions far from the discontinuities give little information as to how to reach
regions of higher values.
π barely changes: DDPG uses the deterministic policy gradient update, as seen in Equation (3).
This is an analytical gradient that does not incorporate any stochasticity, because Q is always
differentiated exactly at (s, π(s)). Thus the actor update is stalled, even when the reward is regularly
found by the behaviour policy. This closes the loop of our process.
4.4	Consequences of the convergence cycle
As illustrated with the red arrows in Figure 7, the more loops performed in the convergence process,
the more the critic tends to be piecewise-constant and the less the actor tends to change. Importantly,
this cyclic convergence process is triggered as soon as the changes on the policy drastically slow
down or stop. What matters for the final performance is the quality of the policy reached before
7
Under review as a conference paper at ICLR 2020
(a)
(b)
Figure 8: (a) Example of a monotonous function approximator. (b) Simply changing the vertical scale
of the graphs presented in Figure 5b reveals that the function approximator is not perfectly flat, and
has many unwanted local extrema. Specifically, continuously moving from π(0) = 0.1 to π(0) < 0
requires crossing a significant valley in Q(0, a), while π(0) = 0.1 is a strong local maximum.
this convergence loop is triggered. Quite obviously, if the loop is triggered before the policy gets
consistently rewarded, the final performance is deemed to be poor.
The key of this undesirable convergence cycle lies in the use of the deterministic policy gradient
update given in Equation (3). Actually, rewarded samples found by the exploratory behaviour policy
β tend to be ignored by the conjunction of two reasons. First, the critic is updated using Q(s0, π(s0))
and not Q(s, β(s)), thus if π differs too much from β, the values brought by β are not properly
propagated. Second, the actor being updated through (3), i.e. using the analytical gradient of the
critic with respect to the actions of π, there is no room for considering other actions than that of π.
Besides, the actor update involves only the state s of the sample taken from the replay buffer, and
not the reward found from this sample r(s, a) or the action performed. For each sample state s, the
actor update is intended to make π(s) converge to argmaxa π(s, a) but the experience of different
actions performed for identical or similar states is only available through Q(s, ∙), and in DDPG it
is only exploited through the gradient of Q(s, ∙) at ∏(s), so the process can easily get stuck in a
local optimum, especially if the critic tends towards a piecewise-constant function, which as we have
shown happens when the reward is sparse. Besides, since td3 also updates the actor according to (3)
and the critic according to (2), it is susceptible to the same failures as ddpg.
4.5	Impact of function approximation
We have just explained that when the actor has drifted to an incorrect policy before finding the reward,
an undesirable convergence process should result in ddpg getting stuck to this policy. However, in
1 D-TOY, we measured that the actor drifts to a policy moving to the right in 50% of cases, but the
learning process only fails 1% of times. More generally, despite the issues discussed in this paper,
ddpg has been shown to be efficient in many problems. This better-than-predicted success can be
attributed to the impact of function approximation.
Figure 8a shows a case in which the critic approximates Qπ while keeping a monotonous slope
between the current policy value and the reward. In this case, the actor is correctly updated towards
the reward (if it is close enough to the discontinuity). This is the most often observed case, and
naturally we expect approximators to smooth out discontinuities in target functions in a monotonous
way, which facilitates gradient ascent. However, the critic is updated not only in state-action pairs
where Qπ(s, a) is positive, but also at points where Qπ(s, a) = 0, which means that the bottom part
of the curve also tends to flatten. As this happens, we can imagine phenomena that are common when
trying to approximate discontinuous functions, such as the overshoot observed in Figure 8b. In this
case, the gradient prevents the actor from improving.
5	Potential solutions
In the previous section, we have shown that actor-critic algorithms such as ddpg and td3 could
not recover from early convergence to a poor policy due to the combination of three factors whose
8
Under review as a conference paper at ICLR 2020
sun“ In-ssoons-。s
ΓZ		Probabilistic noise OU noise		
∣/				
				
				
				
L					
0	20k	40k	60k	80k	100k
Simulation steps
80
60
40
20
0
SAC (Stable-baselines)
0	100	200	300	400	500
Simulation steps
u“ns“ epos-de e">seAV
(a)	(b)	(c)	(d)
Figure 9: (a) Applying ddpg-argmax to 1 D-toy. (b) Applying sac to 1 D-toy. In both cases,
the success rate reaches 100% quickly. (c) Applying ddpg and ddpg-argmax to a sparse-reward
variant of the Reacher-v2 environment. (d) Applying ddpg and ddpg-argmax to a sparse-reward
variant of the HalfCheetah-v2 environment. Details on the changes made to Reacher-v2 and
HalfCheetah-v2 are available in Appendix F.2.
dependence is highlighted in Figure 7: the use of the deterministic policy gradient update, the
use of Q(s0 , π(s0)) in the critic update, and the attempt to address sparse reward in deterministic
environments. In this section, we categorize existing or potential solutions to the above issue in terms
of which of the above factor they remove.
Avoiding sparse rewards: Transforming a sparse reward problem into a dense one can solve the
above issue as the critic should not converge to a piecewise-constant function anymore. This can
be achieved for instance by using various forms of shaping (Konidaris & Barto, 2006) or by adding
auxiliary tasks (Jaderberg et al., 2016; Riedmiller et al., 2018). We do not further investigate these
solutions here, as they are mainly problem-dependent and may introduce bias when the reward
transformation results in deceptive gradient or modifies the corresponding optimal policy.
Replacing the policy-based critic update: As explained above, if some transition (s, a, s0) leading
to a reward is found in the replay buffer, the critic update corresponding to this transition uses
Q(s0, π(s0)), therefore not propagating the next state value that the behaviour policy may have found.
Of course, when using the gradient from the critic, the actor update should tend to update π to reflect
the better policy such that π(s0) → a0, but the critic does not always provide an adequate gradient as
shown before.
If performing a maximum over a continuous action space was possible, using maxa Q(s0, a) instead
of Q(s0 , π(s0)) would solve the issue. Several works start from this insight. Some methods directly
sample the action space and look for such an approximate maximum (Kalashnikov et al., 2018;
Simmons-Edler et al., 2019). To show that this approach can fix the above issue, we applied it to the
1D-toy environment. We take a straightforward implementation where the policy gradient update
in ddpg is replaced by sampling 100 different actions, finding the argmax over these actions of
Q(s, a), and regressing the actor towards the best action we found. We call the resulting algorithm
ddpg-argmax, and more details are available in Appendix F.1. Results are shown in Figure 9a, in
which we see that the success rate quickly reaches 100%.
Quite obviously, even if sampling can provide a good enough baseline for simple enough benchmarks,
these methods do not scale well to large actions spaces. Many improvements to this can be imagined
by changing the way the action space is sampled, such as including π(s) in the samples, to prevent
picking a worse action than the one provided by the actor, sampling preferentially around π(s), or
around π(s + ), or just using actions taken from the replay buffer.
Interestingly, using a stochastic actor such as in the Soft Actor Critic (sac) algorithm (Haarnoja
et al., 2018a;b) can be considered as sampling preferentially around π(s + ) where is driven by the
entropy regularization term. In Figure 9b, we show that sac also immediately solves 1 D-toy.
Another approach relies on representing the critic as the V function rather than the Q function. The
same way π(s) tends to approximate argmaxa Q(s, a), V tends to approximate maxa Q(s, a), and
is updated when finding a transition that raises the value of a state. Using V , performing a maximum
in the critic update is not necessary anymore. The prototypical actor-critic algorithm using a model
of V as a critic is CACLA (Van Hasselt & Wiering, 2007). However, approximating V with neural
9
Under review as a conference paper at ICLR 2020
networks can prove more unstable than approximating Q, as function approximation can be sensitive
to the discontinuities resulting form the implicit maximization over Q values.
Replacing the deterministic policy gradient update: Instead of relying on the deterministic
policy gradient update, one can rely on a stochastic policy to perform a different actor update. This is
the case of SAC, as mentioned just above. Because SAC does not use Q(s0, π(s0)) in its update rule, it
does not suffer from the undesirable convergence process described here.
Another solution consists in completely replacing the actor update mechanism, using regression to
update π(s) towards any action better than the current one. This could be achieved by updating the
actor and the critic simultaneously: when sampling a higher-than-expected critic value yi > Q(si , ai),
one may update π(si ) towards ai using:
Lψ =	δyi>Q(si,π(si)) (π(si) - ai) .	(5)
i
This is similar to the behaviour of cacla, as analyzed in Zimmer & Weng (2019).
Larger benchmarks Whether the deadlock situation investigated so far occurs more in more
complex environments is an important question. To investigate this, we performed additional
experiments based on more complex environments, namely sparse versions of Reacher-v2 and
HalfCheetah-v2. Results are depicted in Figure 9c and 9d and more details are presented in
Appendix F.2. One can see that ddpg-argmax outperforms ddpg, which seems to indicate that the
failure mode we are studying is also at play. However, with higher-dimensional and more complex
environments, the analysis becomes more difficult and other failures modes such as the ones related
to the deadly triad, the extrapolation error or the over-estimation bias might come into play, so it
becomes harder to quantitatively analyze the impact of the phenomenon we are focusing on. On one
hand, this point showcases the importance of using very elementary benchmarks in order to study the
different failure modes in isolation. On the other hand, trying to sort out and quantify the impact of
the different failure modes in more complex environments is our main objective for future work.
6	Conclusion and future work
In rl, continuous action and sparse reward environments are challenging. In these environments,
the fact that a good policy cannot be learned if exploration is not efficient enough to find the reward
is well-known and trivial. In this paper, we have established the less trivial fact that, if exploration
does find the reward consistently but not early enough, an actor-critic algorithm can get stuck into a
configuration from which rewarded samples are just ignored. We have formally characterized the
reasons for this situation and we have outlined existing and potential solutions. Beyond this, we
believe our work sheds new light on the convergence regime of actor-critic algorithms.
Our study was mainly built on a simplistic benchmark which made it possible to study the revealed
deadlock situation in isolation from other potential failure modes such as exploration issues, the
over-estimation bias, extrapolation error or the deadly triad. The impact of this deadlock situation
in more complex environments is a pressing question. For this, we need to sort out and quantify
the impact of these different failure modes. Using new tools such as the ones provided in Ahmed
et al. (2019), recent analyses of the deadly triad such as Achiam et al. (2019) as well as simple,
easily visualized benchmarks and our own tools, for future work we aim to conduct deeper and more
exhaustive analysis of all the instability factors of ddpg-like algorithms, with the hope to contribute
in fixing them.
7	Acknowledgements
Anonymized for submission.
References
Joshua Achiam, Ethan Knight, and Pieter Abbeel. Towards Characterizing Divergence in Deep
Q-Learning. arXiv:1903.08894 [cs], March 2019. URL http://arxiv.org/abs/1903.
08894. arXiv: 1903.08894.
10
Under review as a conference paper at ICLR 2020
Zafarali Ahmed, Nicolas Le Roux, Mohammad Norouzi, and Dale Schuurmans. Understanding the
impact of entropy on policy optimization. In International Conference on Machine Learning, pp.
151-160, 2019.
L.	C. Baird and A. H. Klopf. Reinforcement learning with high-dimensional, continuous actions.
Technical report, Wright-Patterson Air Force Base Ohio: Wright Laboratory. (Available from the
Defense Technical Information Center, Cameron Station, Alexandria, VA 22304-6145), 1993.
Justin A. Boyan and Andrew W. Moore. Generalization in reinforcement learning: Safely approxi-
mating the value function. In Advances in neural information processing systems, pp. 369-376,
1995.
Cedric Colas, Olivier Sigaud, and Pierre-Yves Oudeyer. GEP-PG: Decoupling Exploration and
Exploitation in Deep Reinforcement Learning Algorithms. In International Conference in Machine
Learning (ICML), February 2018. URL https://arxiv.org/abs/1802.05054.
Meire Fortunato, Mohammad Gheshlaghi Azar, Bilal Piot, Jacob Menick, Ian Osband, Alex Graves,
Vlad Mnih, Remi Munos, Demis Hassabis, Olivier Pietquin, Charles Blundell, and Shane Legg.
Noisy Networks for Exploration. arXiv:1706.10295 [cs, stat], June 2017. URL http://arxiv.
org/abs/1706.10295. arXiv: 1706.10295.
Scott Fujimoto, David Meger, and Doina Precup. Off-Policy Deep Reinforcement Learning without
Exploration. arXiv:1812.02900 [cs, stat], December 2018a. URL http://arxiv.org/abs/
1812.02900. arXiv: 1812.02900.
Scott Fujimoto, Herke van Hoof, and David Meger. Addressing Function Approximation Error in
Actor-Critic Methods. https://arxiv.org/abs/1802.09477, February 2018b.
M.	Geist and O. Pietquin. Parametric value function approximation: A unified view. In 2011 IEEE
Symposium on Adaptive Dynamic Programming and Reinforcement Learning (ADPRL), pp. 9-16,
April 2011. doi: 10.1109/ADPRL.2011.5967355.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft Actor-Critic: Off-Policy
Maximum Entropy Deep Reinforcement Learning with a Stochastic Actor. arXiv:1801.01290 [cs,
stat], January 2018a. URL http://arxiv.org/abs/1801.01290. arXiv: 1801.01290.
Tuomas Haarnoja, Aurick Zhou, Kristian Hartikainen, George Tucker, Sehoon Ha, Jie Tan, Vikash
Kumar, Henry Zhu, Abhishek Gupta, Pieter Abbeel, et al. Soft actor-critic algorithms and
applications. arXiv preprint arXiv:1812.05905, 2018b.
Max Jaderberg, Volodymyr Mnih, Wojciech Marian Czarnecki, Tom Schaul, Joel Z Leibo, David
Silver, and Koray Kavukcuoglu. Reinforcement learning with unsupervised auxiliary tasks. arXiv
preprint arXiv:1611.05397, 2016.
Dmitry Kalashnikov, Alex Irpan, Peter Pastor, Julian Ibarz, Alexander Herzog, Eric Jang, Deirdre
Quillen, Ethan Holly, Mrinal Kalakrishnan, Vincent Vanhoucke, et al. Qt-Opt: Scalable deep
reinforcement learning for vision-based robotic manipulation. arXiv preprint arXiv:1806.10293,
2018.
George Konidaris and Andrew Barto. Autonomous shaping: Knowledge transfer in reinforcement
learning. In Proceedings of the 23rd international conference on Machine learning, pp. 489-496.
ACM, 2006.
Timothy P. Lillicrap, Jonathan J. Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval
Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learn-
ing. arXiv:1509.02971 [cs, stat], September 2015. URL http://arxiv.org/abs/1509.
02971. arXiv: 1509.02971.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wier-
stra, and Martin Riedmiller. Playing Atari with Deep Reinforcement Learning. arXiv:1312.5602
[cs], December 2013. URL http://arxiv.org/abs/1312.5602. arXiv: 1312.5602.
11
Under review as a conference paper at ICLR 2020
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G. Belle-
mare, Alex Graves, Martin Riedmiller, Andreas K. Fidjeland, Georg Ostrovski, Stig Petersen,
Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran, Daan Wierstra,
Shane Legg, and Demis Hassabis. Human-level control through deep reinforcement learning.
Nature, 518(7540):529-533, February 2015. ISSN 1476-4687. doi: 10.1038∕nature14236. URL
https://www.nature.com/articles/nature14236.
Matthias Plappert, Rein Houthooft, Prafulla Dhariwal, Szymon Sidor, Richard Y. Chen, Xi Chen,
Tamim Asfour, Pieter Abbeel, and Marcin Andrychowicz. Parameter space noise for exploration.
arXiv preprint arXiv:1706.01905, 2017.
Martin Riedmiller, Roland Hafner, Thomas Lampe, Michael Neunert, Jonas Degrave, Tom Van de
Wiele, Volodymyr Mnih, Nicolas Heess, and Jost Tobias Springenberg. Learning by Playing -
Solving Sparse Reward Tasks from Scratch. arXiv:1802.10567 [cs, stat], February 2018. URL
http://arxiv.org/abs/1802.10567. arXiv: 1802.10567.
David Silver, Guy Lever, Nicolas Heess, Thomas Degris, Daan Wierstra, and Martin Riedmiller.
Deterministic Policy Gradient Algorithms. In International Conference on Machine Learning,
pp. 387-395, January 2014. URL http://proceedings.mlr.press/v32/silver14.
html.
Riley Simmons-Edler, Ben Eisner, Eric Mitchell, Sebastian Seung, and Daniel Lee. Q-learning for
continuous actions with cross-entropy guided policies. arXiv preprint arXiv:1903.10605, 2019.
Richard S. Sutton and Andrew G. Barto. Reinforcement Learning: An Introduction. MIT Press,
November 2018. ISBN 978-0-262-03924-6. Google-Books-ID: 6DKPtQEACAAJ.
John N. Tsitsiklis and Benjamin Van Roy. Analysis of temporal-diffference learning with function
approximation. In Advances in neural information processing systems, pp. 1075-1081, 1997.
Hado Van Hasselt and Marco A. Wiering. Reinforcement learning in continuous action spaces.
In IEEE International Symposium on Approximate Dynamic Programming and Reinforcement
Learning (ADPRL), pp. 272-279, 2007.
Hado van Hasselt, Yotam Doron, Florian Strub, Matteo Hessel, Nicolas Sonnerat, and Joseph Modayil.
Deep Reinforcement Learning and the Deadly Triad. arXiv:1812.02648 [cs], December 2018.
URL http://arxiv.org/abs/1812.02648. arXiv: 1812.02648.
Christopher J. C. H. Watkins. Learning with Delayed Rewards. PhD thesis, Psychology Department,
University of Cambridge, England, 1989.
Matthieu Zimmer and Paul Weng. Exploiting the sign of the advantage function to learn deterministic
policies in continuous domains. arXiv preprint arXiv:1906.04556, 2019.
12
Under review as a conference paper at ICLR 2020
A Two regimes of DDPG
In this section, we characterize the behavior of ddpg as an intermediate between two extremes, that
we respectively call the critic-centric view, where the actor is updated faster, resulting in an algorithm
close to Q-LEARNING, and the actor-centric view, where the critic is updated faster, resulting in a
behaviour more similar to Policy Gradient.
A. 1 Actor update: the critic-centric view
The q-learning algorithm (Watkins, 1989) and its continuous state counterpart dqn (Mnih et al.,
2013) rely on the computation of a policy which is greedy with respect to the current critic at every
time step, as they simply take the maximum of the Q-values over a set of discrete actions. In
continuous action settings, this amounts to an intractable optimization problem if the action space is
large and nontrivial.
We get a simplified vision of ddpg by considering an extreme regime where the actor updates are
both fast enough and good enough so that ∀s, π(s) ≈ argmaxa Q(s, a). We call this the critic-centric
vision of ddpg, since the actor updates are assumed to be ideal and the only remaining training is
performed on the critic.
In this regime, by replacing π(s) with argmaxa Q(s, a) in Equation (2), we get yi = ri + γ(1 -
ti) maxa Q(si, a), which corresponds to the update of the critic in Q-LEARNING and DQN. A key
property of this regime is that, since the update in based on a maximum over actions, the resulting
algorithm is truly off-policy. We can thus infer that most of the off-policiness property of ddpg
comes from keeping it close to this regime.
A.2 Critic update: the actor-centric view
Symmetrically to the previous case, if the critic is updated well and faster than the actor, it tends to
represent the critic of the current policy, Qπ. Furthermore, if the actor tends to change slowly enough,
critic updates can be both fast and good enough so that it reaches the fixed point of the Bellman
equation, that is ∀(s, a, r, t, s0), Q(s, a) = r + γ(1 - t)Q(s0, π(s0)).
In this case, the optimization performed in (1) mostly consists in updating the actor so that it exploits
the corresponding critic by applying the deterministic policy gradient on the actor. This gives rise to
a actor-centric vision of DDPG.
B Deadlock in 1 D-toy
In this section, we prove that there exists a state of ddpg that is a deadlock in the 1 D-toy environment.
This proof directly references Figure 6. Let us define two functions Q and πψ such that:
∀(s, a), Q(s, a) = 1s+a<0	(6)
∀s ∈ S, πψ (s) = 0.1	(7)
From now on, we will use notation π := πψ .
Theorem 1.	(Q,πψ) is a fixed point for the critic update.
Proof. The critic update is governed by Equation 2.
Let (si , ai , ri , ti , s0i) be a sample from the replay buffer. The environment dictates that ri = ti =
1si+ai<0.
yi = ri + γ(1 - ti)Q (s0i,πψ(s0i))
yi = ri + γ(1 - ti)Q (s0i,0.1)	by (7)
yi = ri	by (6)
yi = 1si+ai<0
yi = Q(si, ai)
by (6)
13
Under review as a conference paper at ICLR 2020
Therefore, for each sample yi = Q(si , ai), and L is null and minimal. Therefore θ will not be
updated during the critic update.	□
Theorem 2.	(Q,πψ) is a fixed point for the actor update.
Proof. The actor update is governed by Equation 3.
Let {(si, ai, ri, ti, s0i)} be a set of samples from the replay buffer. The environment dictates that
∀i, ri = ti = 1si+ai <0 .
ψ J ψ + α XX d”∂ψsi VaQ(Si,a<=∏ψ(Si)
Since Q(si, a) = 1si+a<o, VaQ(Si, a) = 0, so ψ will not be updated during the actor update. □
In this section, we assume that Q is any function, however in implementations Q is often a parametric
neural network Qθ, which cannot be discontinuous. Effects of this approximation are discussed in
Section 4.5.
C CONVERGENCE OF THE CRITIC TO Qπ
Notation For a state-action pair S, a, we define S1 as the result of applying action a at state S in the
deterministic environment. For a given policy π, we define a1 as π(S1). Recursively, for any i ≥ 1,
we define Si+1 as the result of applying action aito state Si, and aias π(Si).
Definition 1. Let (S, a) ∈ S × A. If (S, a) is terminal, then we set N = 0. Otherwise, we set N to
the number of subsequent transitions with policy π to reach a terminal state. Therefore, the transition
(SN , aN ) is always terminal. We generalize by setting N = ∞ when no terminal transition is ever
reached.
We define the state-action value function of policy π as:
N
Qπ(S,a) := r(S, a) +	γ ir(Si, ai)
i=1
Note that when N = ∞, the sum converges under the hypothesis that rewards are bounded and γ < 1.
If π is fixed, Q is updated regularly via approximate dynamic programming with the Bellman operator
for the policy π. Under strong assumptions, or assuming exact dynamic programming, it is possible
to prove (Geist & Pietquin (2011)) that the iterated application of this operator converges towards a
unique function Qπ , which corresponds to the state-action value function of π as defined above. It
is usually done by proving that the Bellman operator is a contraction mapping, and also applies in
deterministic cases.
However, when using approximators such as neural nets, no theroretical results of convergence exists,
to the best of our knowledge. In this paper we assume that this convergence is true, and in the
experimental results we did not observe any failures to converge towards Qπ . On the contrary, we
observe that this converge occurs, and can be what starts the deadlock cycle studied in Section 4.3.
D	PROOF THAT Qπ IS PIECEWISE-CONSTANT
In this section, we show that in deterministic environments with terminal sparse rewards, Qπ is
piecewise-constant.
Definition 2. In this article, for I ⊂ Rn, we say a function f : I → R is piecewise-constant if
∀x0 ∈ I, either Vx f (u)|x=x = 0, or f has no gradient at x0.
14
Under review as a conference paper at ICLR 2020
Figure 10: Example of anon-continuous function f with values in {(2)n | n ∈ N}, approximating
the identity function. However, this function is not differentiable because the difference quotient does
not converge but instead oscillates between two values.
Theorem 3.	In a deterministic environment with terminal sparse rewards, for any π, Qπ is piecewise-
constant.
Proof. Note that this proof can be trivialized by assuming that around any point where the gradient
is defined, there exists a neighbourhood in which the function is continuous. In this case, the
intermediate value theorem yields an uncountable set of values of the function in this neighbourhood,
which contradicts the countable number of possible discounted rewards.
The crux of the following proof is that even when no such neighbourhood exists, the gradient is either
null of non-existent. This behavior is shown in Figure 10.
Using the notations of Definition 1 and the theorem hypothesis that rewarded transitions are also
terminal, we can write Qπ (s, a) as:
r(s, a)	if N = 0
Qπ(s, a) =	γNr(sN, aN)	if N is finite
10	otherwise.
We promote N to a function S × A → N ∪ {+∞}, and we define a function u : S × A → R as given
in Equation (8).
r(s, a)	ifN = 0
u(s,a) =	r(sN(s,a),αN(s,a))	if N > 0 finite	(8)
10	otherwise.
Now we have ∀(s, a) ∈ S × A, Qπ (s, a) = γN(s,a)u(s, a).
Let R be the finite set of possible reward values.
Therefore values of Qn are in a set M = {γnr | n ∈ N,r ∈ R}. Let M+ = M ∩ R+* be the set
of positive values of M. Since R ⊂ R is finite, we order all non-zero positive possible rewards in
increasing order r1,r2, •一rk.
Let Mj = {γnr | n ∈ N,r ∈ Rk} where Rk = {rι,…，rk}.
We prove the following by recurrence over the number of possible non-zero rewards:
H(k) : ∃νk > 0, ∀δ > 0, ∃ consecutive b, a ∈ Mk+, δνk < a - b and b < a < δ
15
Under review as a conference paper at ICLR 2020
2
Initialization When k = 1, M+ = {rιγn | n ∈ N}. Let V = ɪ-^. Let δ > 0. Let n
[logγ V C +1. We have:
logγ---1 < n - 1 ≤ logγ —
r1	r1
logγ r1 < n < logγ ri + logγ(1 - γ) + 2 - logγ(1 - Y)
logγ — < n < logγ (1-Y) + logγ v
r1	r1
logγ — <n < logγ δv(1Y
γ r1	γ	r1
δν(1 - Y)	n δ
------------< γn<一
r1------r1
δν(1 - Y)2 < r1Yn(1 - Y) < δ(1 - Y)
δν < r1Yn - r1Yn+1 and r1Yn < δ
Let a = r1Yn ∈ M+ and b = r1Yn+1 ∈ M+. δν < a - b and b < a < δ therefore H(1) is verified.
Recurrence Let k ≥ 1, and assume H(k) is true. Let Vk be the V chosen for H(k). Let Vk+i = Vk.
Let δ > 0. Let bk, ak a consecutive pair chosen in Mk+ such that δVk < ak - bk and bk < ak < δ.
Since Rk+1 contains only one more element than Rk, which is larger than all elements in Rk, we
know that there is either one or zero elements c ∈ Mk++1 that are strictly between ak and bk. If
ak - c < c - bk then let ak+1 = c and bk+1 = bk, otherwise ak+1 = ak and bk+1 = c. If ak and bk
are still consecutive in Mk++1, then ak+1 = ak and bk+1 = bk.
This guarantees that [bk+i, ak+i] as at least half as big as [bk,ak]. Therefore, 11 ® - bk) <
ak+1 - bk+1, which means that δVk+1 < ak+1 - bk+1 and bk < ak < δ.
Therefore H(k + 1) is verified.
2 |R|
This also gives the general expression of V, valid for all k: V = ( ɪ-^)
Main proof Using the result above, we prove that Qπ(s, a) cannot have any non-null derivatives.
Trivially, Qπ cannot have a non-null derivative at a point (s, a) where Qπ (s, a) = q0 6= 0. Indeed,
there exists a neighbourhood of q0 ∈ M in which there is a single value.
Let x0 = (s, a) such that Q(s, a) = 0. Let v be a vector of the space S × A. Let f : R → R be
defined as f (h) = Qn(x0 + hv). In the following, We show that f(h∣) cannot converge to a non-null
value when h → 0.
We use the (, δ ) definition of limit. If f had a non-null derivative l at 0, we owould have ∀ >
0, ∃δ> 0,∀h,∣h∣ <δ =⇒ I 帘-l∣ <e.
Instead, we will show the opposite: ∃e > 0, ∀δ > 0, ∃h, |h| < δ and ∣ f(h∣) - l∣ ≥ e.
Using the candidate derivative l and the V value computed above that only depends on Y and |R|, we
set E = l1V.
Let δ > 0.
There exists consecutive b, a in M such that δlV ≤ a - b and b < a < δl.
We set h = a+b. Note that a+b < δl therefore h < δ.
f(h) is in M, but hl is the center of the segment [b, a] of consecutive points of M. Therefore, the
distance between f (h) and hl is at least a-b.
16
Under review as a conference paper at ICLR 2020
Since h < δ, 1 > δ.
If(h)- hl| ≥
a — b ≥ δlν
2
2
华-1
h
lν
≥ "2 = e∙
□
E	Implementation details
Here is the complete rollout and training algorithm, taken from the Spinup implementation of ddpg.
Result: Policy πψ, number of steps before success
∏ψ ,Qθ J Xavier uniform initializer
env_steps J 0
for t J 1 to 10000 do
a J πψ(s)
if rand() < 0.1 then
I a J rand(-0.1,0.1)
end
Step the environment using action a, get a transition (s, a, r, t, s0)
Store (s, a, r, t, s0) in the replay buffer
env_steps J env_steps + 1
if t = 1 or envsteps > N then
Reset the environment
for k J 1 to envsteps do
Sample a mini-batch of size 100 from the replay buffer
Train ∏ψ and Qθ on this replay buffer with losses (1) and (2).
end
env_steps J 0
end
if t mod 1000 = 0 then
if last 20 episodes were successes then
I Terminate the algorithm, and return SUcceSS_after_steps= t.
end
end
end
F	Proposed solution to the deadlock problem
F.1 Description of ddpg-argmax
In this paper, we identified a deadlock problem and tracked its origin to the actor update described
in Equation (1). In Section 5, we proposed a new actor update mechanism in an algorithm called
ddpg-argmax, which we describe in more details here.
Instead of relying on the differentiation of Qθ (si, πψ (si)) to update ψ in order to maximize
Q(s, π(s)), we begin by selecting a set of N potential actions (bj)0≤j<N. Then, we compute
Qθ (si, bj) for each sample si and each potential action bj, and for each sample si we find the best
potential action ci = bargmax Qθ (si ,bj) . Finally, we regress πψ (si) towards the goal ci. This process
is summarized in Equation (9), where U nif (A) stands for uniform sampling in A.
17
Under review as a conference paper at ICLR 2020
Figure 11: Performance of ddpg and ddpg-argmax on a sparse variant of HalfCheetah-v2. To
ensure exploration of the state space is not a problem, the policy is replaced with a good pre-trained
policy in one episode over 20.
(bj)0≤j<N 〜Unif(A)
ci = bargmaxj Qθ(si,bj)
minimize	(πψ (si) - ci)2 w.r.t.	ψ
i
(9)
F.2 Experiments on larger benchmarks
In order to test the relevance of using ddpg-argmax on larger benchmarks, we constructed sparse
reward versions of Reacher-v2 and HalfCheetah-v2.
Reacher-v2 was modified by generating a step reward of 1 when the distance between the arm
and the target is less than 0.06, and 0 otherwise. The distance to the target was removed from the
observations, and the target was fixed to a position of [0.19, 0], instead of changing at each episode.
We also removed the control penalty.
HalfCheetah-v2 was modified by generating a step reward of 2 when the x component of the
speed of the cheetah is more than 2. We also removed the control penalty. Since the maximum
episode duration is 1000, the maximum possible reward in this modified environment is 2000.
In both cases, the actor noise uses the default implementation of the Spinup implementation of ddpg,
which is an added uniform noise with an amplitude of 0.1.
Running ddpg and ddpg-argmax on these environments yields the results shown in Figures 9c and
9d. Experiments on HalfCheetah-v2 have been conducted using six different seeds. In Figure 9d,
the main curves are smoothed using a moving average covering 10 episodes (10k steps), and the
shaded area represents the average plus or minus one standard deviation.
On HalfCheetah-v2, both ddpg and ddpg-argmax are able to find rewards despite its sparsity.
However, ddpg-argmax outperforms ddpg in this environment. Since the only difference between
these algorithms is the actor update, we conclude that even in complex environments, the actor update
is the main weakness of ddpg. We have shown that replacing it with a brute-force update improves
performance dramatically, and further research aiming to improve the performance of deterministic
actor-critic algorithms in environments with sparse rewards should concentrate on improving the
actor update rule.
Figure 9d shows that ddpg is able to find the reward without the help of any exploration except
the uniform noise built in the algorithm itself. However, to prove that state-space exploration is not
the issue here, we constructed a variant in which the current actor is backed up and replaced with
a pre-trained good actor every 20 episodes. This variant achieves episode returns above 1950 (as a
18
Under review as a conference paper at ICLR 2020
reminder, the maximum episode return is 2000). In the next episode, the backed up policy is restored.
This guarantees that the replay buffer always contains all the transitions necessary to learn a good
policy. We call this technique priming.
Results of this variant are presented in Figure 11. Notice that ddpg performs much better than
without priming, but the performance of ddpg-argmax is unchanged. However, ddpg still fails to
completely solve the environment, proving that even when state-space exploration is made trivial,
ddpg underperforms on sparse-reward environments due to its poor actor update.
19