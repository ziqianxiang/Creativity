Under review as a conference paper at ICLR 2020
Dual Sequential Monte Carlo: Tunneling
Filtering and Planning in Continuous POMDPs
Anonymous authors
Paper under double-blind review
Ab stract
We present the DualSMC network that solves continuous POMDPs by learning
belief representations and then leveraging them for planning. It is based on the
fact that filtering, i.e. state estimation, and planning can be viewed as two related
sequential Monte Carlo processes, with one in the belief space and the other in the
future planning trajectory space. In particular, we first introduce a novel particle
filter network that makes better use of the adversarial relationship between the
proposer model and the observation model. We then introduce a new planning
algorithm over the belief representations, which learns uncertainty-dependent
policies. We allow these two parts to be trained jointly with each other. We testify
the effectiveness of our approach on three continuous control and planning tasks:
the floor positioning, the 3D light-dark navigation, and a modified Reacher task.
1	Introduction
Partially observable Markov Decision Processes (POMDPs) formulate reinforcement learning prob-
lems where the robot’s instant observation is insufficient for optimal decision making (Kaelbling
et al., 1998). POMDPs can easily become intractable in moderately large discrete space, let alone in
continuous domains (Papadimitriou & Tsitsiklis, 1987). As a result, sampling-based methods are
typically employed. For example, Monte Carlo tree search (MCTS) methods have shown success in
relatively large POMDPs by constructing a search tree of history based on rollout simulations (Sil-
ver & Veness, 2010; Seiler et al., 2015; Sunberg & Kochenderfer, 2018). Cross-entropy methods
(CEM) (De Boer et al., 2005) update a distribution over policies based on sampled trajectories and
have achieved promising results in Decentralized POMDPs (Oliehoek et al., 2008; Omidshafiei et al.,
2016). Despite their effectiveness, MCTS methods often require a black-box simulator to generate
planning trajectory and thus limiting their success to environments with known dynamics. CEM
usually assumes all distributions are Gaussian and therefore is restricted to unimodal planning.
On the other hand, in the context of deep reinforcement learning, approximate solutions for solving
POMDPs often directly encode past history with a recurrent neural network (RNN) and performs
model-free planning on the latent representations of the RNN (Hausknecht & Stone, 2015; Zhu et al.,
2018). Recent work further reduces the burden on the RNN by training an internal generative model
for approximate inference of a latent belief (Igl et al., 2018). By doing end-to-end training on the
neural architecture, the resulting models can solve complex POMDPs with visual inputs. Despite
being simple and generic, these methods lose the ability to incorporate useful prior knowledge like
the state formulation as both the planning is completely based on the latent states of RNN. Moreover,
whenever these methods fail to perform well, it is difficult to analyze which part causes the failure.
In this work, we present the dual sequential Monte Carlo (DualSMC) model that aims to solve
continuous POMDPs with complex unknown dynamics and high dimensional observations, while
preserving the interpretability. In particular, DualSMC consists of two coupled inference processes:
one for belief estimation over states, and the other for multi-modal density estimation over the optimal
future trajectories. To connect the two parts, we feed top particles and the weighted mean estimate
from the first SMC, i.e. an adversarial particle filter, as the belief representation to the second one.
From there, the second SMC explicitly takes uncertainty into consideration and does multi-modal
planning. Note that the learned dynamics is efficiently shared between these two parts. The overall
pipeline of our algorithm is summarized in Figure 1.
We evaluate our model on three continuous POMDP tasks: the floor-positioning task for explanatory
purpose, the 3D light-dark navigation task simulated by DeepMind Lab (Beattie et al., 2016) with
rich visual inputs, and a control task in a modified Mujoco (Todorov et al., 2012) environment. Our
method consistently outperforms the baseline methods.
1
Under review as a conference paper at ICLR 2020
Figure 1: The pipeline of DualSMC. The planner and filter are linked via belief representatives.
2	Preliminaries
In this section, we provide a brief review of the key concepts for the background of this work.
Continuous POMDPs. A continuous POMDP can be specified as a 7-tuple (S, A, T, R, Ω, Z, γ),
where S, A and Ω are underlying continuous state, action and observation spaces. We denote
st ∈ S as the underlying state at time t. When the robot takes an action at ∈ A according to a
policy π(at∣o≤t, a<t), the state changes to st+ι with probability T(st+ι∣st, a.. The robot will
then receive a new observation ot+ι 〜Z(ot+ι∣st+ι) and a reward r 〜R(st, at). Assuming the
episodes are of fixed length L, the robot’s objective is then to maximize the expected cumulative
future reward G = ETZn [PL=ι γt-1rt], where T = (si, aι,..., aL, sl+i) are trajectories induced
by π, and 0 ≤ γ < 1 is the discount factor. In general, the optimal policy has to take the entire
history into consideration, which can grow exponentially in time steps. Instead of remembering
the entire history, classical methods often maintain a belief over possible states and gradually
filter out the true state. Denote bel(st)，p(st∣o≤t, a<t), then the belief is updated according to
bel(st+1) = η bel(st)Z(ot+1|st+1)T(st+1 |st, at)dst, where η is a normalization factor.
Particle filter (PF). A particle filter uses a set of particles {(st(k), wt(k))}kK=1 with PkK=1 wt(k) = 1,
to approximate the belief distribution bel(st). With this approximation scheme, belief update reduces
to updating individual particles, s(+∖ 〜 T(∙∣s(k),at) and w(k)i H Z(ot+ι∣s(+)ι)w(k). Particle filter
benefits from its flexibility to approximate any distribution. In practice, when the true dynamics T
and Z are not known a priori, we can use parametrized functions Tψ (∙) and Zθ(∙) to approximate
their corresponding counterparts. Despite its simplicity and efficiency, particle filter can suffer from
the particle degeneracy problem that most of the probability mass concentrates on a few particles. A
well-known solution is particle resampling, which bootstraps new particles of equal weights from
the old ones. Recent advances in particle filters (Karkus et al., 2018b; Jonschkowski et al., 2018)
adopt neural networks as the parametrized transition and observation functions and make the filtering
process differentiable. By doing so, particle filters can be more easily applied to problems that have
complex and high-dimensional observations like images. While previous work focuses on belief
space filtering, we take one step further and propose a planning method.
Sequential Monte Carlo planning (SMCP). The task of planning can also be regarded as an
inference problem, provided that the likelihood of any future trajectory is proportional to its expected
cumulative rewards. This idea is connected to the control as inference framework (Todorov, 2008;
Toussaint, 2009; Kappen et al., 2012), where control problems are solved by forming a probabilistic
graphical model. Specifically, if we denote Ot as the optimality variable and define p(Ot = 1) H
exp(R(st, at)) as the probability of time step t being optimal, the optimal plan then corresponds to
the maximum a posterior estimate conditioned on the optimality of all future steps. We can solve
this inference problem again with an SMC. For a complete derivation, please refer to Levine (2018)
and Piche et al. (2018). Notably, Piche et al. (2018) first uses the sequential Monte Carlo for planning
(SMCP) in Markov decision processes. We extend the idea to partially observable domains.
3	Method
In this section, we present DualSMC, which consists of two interrelated sequential Monte Carlo
processes. We first introduce a more sampling-efficient adversarial particle filter for learning the
belief representation, then an uncertainty-aware planning algorithm based on these representations.
2
Under review as a conference paper at ICLR 2020
3.1	Adversarial Particle Filtering
Similar to the architecture in Jonschkowski et al. (2018), our differentiable PF contains three neural
modules, an observation model Zq(ot∣s(k)) that weights each particle given the current observation,
a proposer Pφ(s(nkew) |ot, P) for suggesting new probable particles, and a stochastic transition model
Tψ (St ∣st-ι, at-ι, eτ) that mimics the environment dynamics. Here, ep and eτ are Gaussian noise for
stochasticity. At time t, we re-sample K0 particles ({s(okld)}kK=0 1) transited from the previous step based
on the updated weight and combine them with (K - K0) newly proposed particles ({slkW}3k，+i)*.
Naturally, Pφ is trained by regressing the proposed state to the true state.
For successful POMDPs planning, the state estimation particle filter had better be really sampling
efficient and provide a belief representation based on the most plausible states for the downstream
planner. We observe that Pφ and Zθ are opposite yet dependent on each other. Following the intuition
that leveraging this adversarial relationship would enhance both parts and thus help to narrow down
the belief space of interest, we propose the adversarial particle filter. In particular, we train Zθ to
differentiate the true state from all particle states and train Pφ to fool Zθ . Formally, denote preal as
the real joint distribution over s, o, Zθ and Pφ play the following two-player minimax game with
function F (Zθ, Pφ):
minmax F (Zθ ,Pφ)=旧,4〜以对⑺[log Z (o∣s) + Es~s(k 宜2(1 - zθ(o∣s))
+ Eep~N(0,I) Iog(I- Zθ(olPφ(o, eP))) ] .
3.2	DualSMC Planning with Belief Representations
A straightforward solution to POMDP planning is to train the planning module separately from the
filtering module. At inference time, plans are made based on sampled individual particles from the
state filter. We call this planning algorithm particle-independent SMC planning (PI-SMCP) and use
it as a baseline method. More details about PI-SMCP can be found in Appendix A. Nevertheless,
PI-SMCP does not perceive the state uncertainty. By contrast, the proposed DualSMC explicitly
considers the belief distribution by planning directly on an approximated belief representation, i.e. a
combination of the top candidates from the state filter as well as the weighted mean estimate.
Algorithm 1 Overall DualSMC filtering and planning method
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
{s1k) 〜PriOri(sι)}3ι, {w(k) = 1}3ι	> Define initial filtering particles
for t = 1 : L do	. At each control time step
{w(k) H w(-)ι ∙ Zq(s(k), ot)}K=ι	. Update particle weights
belt = Pk w(k)stk)	. Compute mean belief state
{3tm),w(m)}M=ι = TOP-M({s(k),w(k)}3i), wj∙t{w(k)}3ι	. TaketOP-M PartiCleS
at = DualSMC-P(belt, {3(m), W(m)}M=i； ∏ρ, Qω)	. Perform planning (Alg 2)
0t+1,rt 〜penv(at)	. Update the environment
{s(k)}K= ι ~ MUltinomial({s(k)}3ι), w.r.t.{w(k)}3ι	. Resample particle states
{stk) ~ Pφ(ot)}K=κo+ι, {w(k) = 1}K=1	. Propose new particles
{st+)1 〜Tψ (s(k), αt)}K=1	. Predict next-step particles
Add (st, st+ι, at, rt, ot, b¾, {E(m), W(m)}M=ι) to a training buffer
Sample a batch from the buffer and update parameters (ρ, ω, θ, ψ, φ)	. Train all modules
end for
We present the details of DualSMC in Algorithm 1. At time step t, when a new observation comes,
we first use Zq to update the particle weights (line 3 Alg 1), and then perform the planning algorithm
in Algorithm 2. We duplicate the top-M particles and the mean belief state N times as the root
states of N planning trajectories (line 1-2 Alg 2). Different from the previous SMCP (Piche et al.,
2018) method under full observations, the policy network πρ perceives the belief representations
and predicts an action based on the top-M particle states as well as the mean belief state (line 4 Alg
* Depending on the task, we can keep K0 constant or make (K — K0) follow an exponential decay.
3
Under review as a conference paper at ICLR 2020
Algorithm 2 DualSMC planning with filtered belief representations
Input: mean belief state belt, top-M filtering particles {s(m),W(m)}M=i, policy network 不P,
value network Qω , planning start time t, planning horizon H
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
{W(m)}M=ι = Normalize({W(m)}M=ι)	. Normalize top-M filtering particle weights
{{^tm)S) = 3(m)}M=ι,W(-1 = 1, beltn) = belt}N= 1 . Duplicate initial states set N times
for i = t : t + H do	. At each planning time step
{a(n) 〜行({y)(")}落=1屈("))}>1	. SamPle N actions
{W(m)(n),r(mXn)〜Tψ(^(m'n),ain))}M=N n=1	. Predict next-step states and rewards
{bel(1)1 〜Tψ (bel(n), a(n)) }N=1	. Predict next-step mean belief state
{W(n) H W(n1 ∙ exp (Pm W(m)A(m)(n))}N=1	. Update weights with Equation 2
{x(n) = ({^(m)(n),^(m)(n)}M=1, bel(++)1,a(n))}n=1	. Assemble planning trajectories
{χ(n)}N=1 〜MUltinomial({xtn)}N=1), w.r.t.{W(n)}N=1	. Resample trajectories
{w((n) = i}N=1
end for
Select at = first action of xi(n)+H, where n 〜Uniform(1,...,Ν)	. Return an action
2). We then perform N actions to M × N states and use Tψ to predict the next states and rewards
(line 5 Alg 2). Since future observations o>t are not available at current time step, we approximate
bel(>t by re-using Tψ * (line 6 Alg 2). We update the planning weight of each planning trajectory by
summarizing the advantages of each state using the initial M belief weights (line 7 Alg 2). Here, we
introduce an alternative advantage formulation that is equivalent to the one used in Piche et al. (2018)
A(m)(n) = TD(m)(n) - lognp(a(n)|{^(m)(n)}M=1,bel(n)),	⑵
where TD(m)(n) = Qω(^(m)(n),ain)) - Qω(^(m)(n),ai-)1)+ r(m)(n). Attime t, Qω(鸿叫闾)
and ri(-m1)(n) are set to 0. We emphasize that our formulation is much simpler. Because our formulation
only requires a learned Q function and more importantly, it prevents us from estimating the expectation
of the value function V . We leave the full derivation in Appendix B.2.
At the end of each planning time step, we apply the sequential importance resampling (SIR) over
N planning trajectories (line 9-10 Alg 2). When the planning horizon is reached, where i = t + H,
we sample one planning trajectory and feed its first action to the environment (line 7 Alg 1). We
then go back to the filtering part and update the belief representations by resampling, proposing, and
predicting the next-step particle states (line 8-10 Alg 1). Lastly, we train all modules of DualSMC,
including the policy network, the critic network as well as the adversarial particle filtering networks
(line 11-12 Alg 1). We add details of each network component to Appendix C.
4	Experiment
4.1	Floor Positioning
A robot localizes itself and approaches a target region on a 2D plane. It knows the distances to the
nearest walls: ot = (dx- , dx+ , dy- , dy+ )t, but does not know the world coordinates (sx, sy). It
starts from a random location and is headed to different regions according to different floors. To reach
the correct target, the robot has to learn to reduce the uncertainty about sy . The action is defined as
a = (∆sx, ∆sy) with a maximum magnitude of 0.05. Only at training time, a reward of 100 is given
at the end of each episode if the robot reaches the correct target region. Implementations details of
DualSMC can be found in Appendix D.1.
Qualitative results. Figure 2(a) and 2(b) are results by applying the standard SMCP (Piche et al.,
2018) to the top-1 particle state. We use different particle filters (PF) for these two baseline models.
^Like QMDP (Littman et al., 1995), DualSMC assumes the uncertainty disappears on the next time step and
performs model-based planning.
4
Under review as a conference paper at ICLR 2020
G Goal (unobservable)
R ReSamPled particle states M
Trajectories
• Robot’s initial states (unobservable)
• True states (unobservable)
Proposed particle states ∙ Mean belief state — Planning trajectory
(a) Regressive particle filter + SMCP
t=12
(c) DualSMC planner with adversarial particle filter
Figure 2: The left column shows the actual trajectories of the robot, and other columns are its planning
trajectories at different times. The robot can better localize itself stepping across dashed blue lines.
(b) Adversarial particle filter + SMCP
Table 1: Floor positioning results averaged over 1,000 test episodes, including the success rate, the
mean value and the standard deviation of numbers of steps.
Method	Success rate	# Steps	Std
LSTM filter + SMCP	23.5%	149.1	81.2
DVRL (Igl et al., 2018)	38.3%	162.4	19.9
Regressive PF (top-1) + SMCP	25.0%	107.9	69.8
Adversarial PF (top-1) + SMCP	95.0%	73.3	44.0
DualSMC w/o proposer	78.9%	64.9	62.2
DualSMC with regressive PF (MSE loss)	45.7%	121.6	69.2
DualSMC with regressive PF (density loss)	54.0%	109.2	81.8
DualSMC with adversarial PF	99.4%	36.8	15.1
We use a regressive PF ^ for the first one and an adversarial PF for the second one. As shown by
the blue crosses in Figure 2(a), training the proposer with the mean squared loss is equivalent to
regressing the proposed particles to the mean values of the multi-modal state distributions under
partial observations. Thus, the robot cannot make reasonable decisions. By contrast, as shown
in Figure 2(b), training the PF adversarially leads the proposed particles more akin to plausible
states. The robot learns an interesting policy: moving right wherever the starting point is, and then
bouncing back at the right wall. However, this policy is clearly not optimal, as it does not consider
the uncertainty of the belief state. Figure 2(c) shows the results by DualSMC. We have three findings.
First, the robot learns a policy to localize itself quickly and then approach the target area with
converged belief states, so that the robot can finish the task successfully with fewer steps. Second,
the robot learns the multi-modal distributions of the planning trajectories and can move up or down
with different probabilities and advantage values. Third, the observation model works well. Once the
robot steps across the blue line, the belief states quickly converge to the actual values.
^The term regressive here indicates that the proposer of the particle filter takes the mean square error between
the proposed states and the true states as the training objective function. We may also use the kernel density
estimation as an alternative objective function.
5
Under review as a conference paper at ICLR 2020
Quantitative comparisons. Table 1 shows that, first, the DualSMC planning algorithm achieves
the highest success rate using the least number of steps. Second, the adversarial PF outperforms
other forms of PFs, as well as a deterministic LSTM model (LSTMs are previously used as strong
baselines by Karkus et al. (2018b) and Jonschkowski et al. (2018)). DualSMC models with regressive
proposers are even worse than one without any proposers, illustrating that the quality of the belief
representations is important; erroneous state estimations will harm the final planning results.
Is the DualSMC filter better than the traditional PF? Given partial observations, an ideal filter
should derive a complete distribution of possible states instead of point estimation. Figure 3(a)
compares the averaged RMSE between the filtered results of different models and the true states. The
adversarial PF performs best, while the PF with the regressive proposer performs even worse than
that without a proposer. A natural question arises: as the filtering error is also related to different
moving trajectories of different models, can We eliminate this interference? For Figure 3(b), We train
different filters without a planner. All filters follow the same expert trajectories. We can see that
the adversarial PF still achieves the best performance. Figure 3(c) explores the effect of different
numbers of filtering particles. Using too few particles will deteriorate the filtering performance.
(a) Using different models
(b) Tracking an expert robot
(c) Changing number of particles
Figure 3: Averaged filtering error as a function of the number of robot steps for floor positioning.
Is the DualSMC planner aware of state uncertainty? In fully observable scenarios, we suppress
the filtering part of DualSMC and assume DualSMC plans upon a converged belief on the true state
(sχ,sy). The DualSMC planner makes different decisions to walk straight to the target region (see
Figure 4). It performs equally well to the standard SMCP, with an average of 21.3 steps (v.s. 20.7
steps for SMCP) and a 1θ0.0% success rate. We may conclude that DualSMC does not provide
policies by remembering them, but by perceiving the distribution of the belief state. We may also
conclude that DualSMC trained under POMDPS generalizes well to similar tasks with less uncertainty.
(a) DualSMC with partial observations	(b) DualSMC with full observations
Figure 4: The DualSMC planner trained under POMDPs generates different polices according to the
uncertainty of belief state. For (b), we assign true state values to the top-M particles before planning.
4.2	3D Light-Dark Navigation
We extend the 2D light-dark navigation task (Platt Jr et al., 2010) to a visually rich environment
simulated by DeepMind Lab (Beattie et al., 2016). At each episode, the robot is placed randomly and
uniformly on one of the 4 platforms at the bottom. Then, the robot’s goal is to navigate toward the
central cave (marked in orange) while avoiding any of the 4 traps (marked by crosses). The maze is
divided into upper and lower parts. Within the lower part, the robot travels in darkness, receives noisy
visual input of a limited range (up to a fixed depth), and therefore suffers from high state uncertainty.
When the robot gets to the upper part (the blue area), it has a clear view of the entire maze. We place
decals as visual hints on the top walls of the maze to help the robot figure out its location. However,
it has to be very close to the upper walls to see clearly what these decals are. The robot receives a
positive reward of 100 when it reaches the goal and a negative reward of -100 when in a trap. At
each time step, the robot’s observation includes a 64 × 64 RGB image, its current velocity, and its
orientation. Since the moving command in DeepMind Lab is binary (forward/backward), we force
the robot to move forward and only let it control its orientation, which we make continuous.
6
Under review as a conference paper at ICLR 2020
• Initial state (unknown)
一 Planning trajectory
End state (unknown)
Area w/ true observation
• Current state (unknown)
X Resampled particles
■ Goal
XTrap
Figure 5: DualSMC learns to go up to the wall of decals first before turning back to the goal. Note
that the robot figures out its location at t = 30 and where to start turning back at t = 60.
The experiment results are summarized in Table 2. By considering the uncertainty, DualSMC methods
outperform other baselines and are the only methods that learned to go up and figure out its location
first before going directly towards the goal (see Figure 5). However, we notice that DualSMC with
the adversarial proposer performs slightly worse than with a proposer trained with density loss.
This might be caused by the unstability of the adversarial training. For simplicity, We use the naive
adversarial training method as in the original generative adversarial networks (Goodfellow et al.,
2014), Which may easily suffer from mode collapse, leading to particle degeneracy in our case. One
may potentially improve DualSMC With modern techniques, i.e. Wasserstein distance (Arjovsky
et al., 2017), the gradient penalty (Gulrajani et al., 2017), and the spectral normalization (Miyato
et al., 2018), to stabilize training or guarantee the existence of a unique Nash equilibrium.
Table 2: Experimental results on the 3D navigation task. Results are averaged over 100 episodes after
2,000 episodes of training. Methods With a filter are trained (tested) With 100 (400) particles.
LSTM + SMCP	59%	85.40
Adversarial PF (top-1) + SMCP	58%	56.11
Adversarial PF (top-3) + PI-SMCP	64%	64.37
DualSMC with regressive PF (MSE loss)	93%	64.32
DualSMC With regressive PF (density loss)	97%	73.86
DualSMC with adversarial PF	95%	65.13
4.3	Modified Reacher
We further validate our model on a continuous control task With partial observation, i.e. a modified
Reacher environment from OpenAI Gym (Brockman et al., 2016). The original observation of
Reacher is a 11-D vector including (cos θ1, cos θ2, sin θ1 sin θ2, gx, gy, ω1, ω2, rx, ry, rz), Where the
first 4 dimensions are cos/sin values of the tWo joint angles θ1, θ2, gx, gy the goal position, ω1, ω2 the
angular velocities and rx , ry , rz the relative distance from the end-effector to the goal. We remove
gx, gy ,rx ,ry, rz from the original observation and include a single scalar r = || (rx ,ry ,rz) ||2 + Cr,
• Goal position X Proposed particles XReSamPIed particles
t = 0	t = 6	t = 16	t = 48
Figure 6: The modified Reacher environment and the goal estimation of DualSMC v.s. time.
7
Under review as a conference paper at ICLR 2020
where e/ 〜N(0,0.01) is a small noise (notice that r is usually on the scale of 0.1). The resulting
observation is therefore a 7-D vector. The robot has to simultaneously locate the goal and reach it.
We provide a visualization of one sample run
under DualSMC with the adversarial filter in Fig-
ure 6. As expected, initially the proposed parti-
cles roughly are in a half-cycle and as time goes
on, the particles gradually concentrate around
the true goal. Since the final performance of vari-
ous methods is similar after long enough time of
training, we provide the smoothed training curve
of these methods in Figure 7 to showcase the
advantage of DualSMC. We truncate the results
up to 5,000 episodes since no obvious change
in performance is observed from thereon. As
we can see, DualSMC methods not only achieve
similar asymptotic performance as the SMCP
method with full observation but also learn faster
to solve the task than baseline methods.
-10
E -15
<0
I
U
« -20
-25
-3°
0	1000	2000	3000	4000	5000
Training episode
Figure 7: Smoothed training curves on modified
Reacher. See experiment details in Appendix D.3.
5	Related Work
Embedding useful algorithmic prior to a reinforcement learning model has been a recent trend because
pure model-free approaches can suffer from unstable training and long convergence issues, which
are exaggerated in partially observable domains. QMDP-Net (Karkus et al., 2017) extends the idea
from value iteration network (VIN) (Tamar et al., 2016) by representing the bellman update in value
iteration as convolution and pooling operations in a neural network. A similar idea has been extended
to more visually rich domain (Karkus et al., 2018a; Shankar et al., 2016). However, the underlying
state and action space still remain simple because of the explicit value iteration procedure during the
planning step. The idea of connecting a particle filter with a policy has been addressed in Coquelin
et al. (2009). The performance of their policy is only evaluated on the mean particle state and they
use finite-difference method to update the policy. Igl et al. (2018) introduced a variational lower
bound to improve the original black-box learning of RNN while maintaining a set of particles to
address uncertainty. But in their work, the latent particle states are not interpretable and known
prior knowledge could not apply. Recently, Karkus et al. (2018b) and Jonschkowski et al. (2018)
independently discovered methods to make the conventional particle filter differentiable in terms of
neural networks, both showing that end-to-end training improves the filtering performance. Our work
extends this idea to planning under uncertainty and we introduce an alternative adversarial proposing
strategy to further improve the differentiable filter.
Control as inference methods (Toussaint & Storkey, 2006; Rawlik et al., 2010; Ziebart, 2010; Levine
& Koltun, 2013) regard policy search as a probabilistic inference problem by interpreting rewards as
the log-likelihood of task fulfillment. It is, therefore, possible to adopt useful statistical tools to solve
the control and planning problem by maximizing the likelihood of high reward future trajectory, or
estimating the posterior distribution of actions conditioned on the optimality of future trajectories.
Levine (2018) provided a comprehensive review of these methods. While previous work mainly
focuses on simplified dynamics and simple state/action space, Piche et al. (2018) extended the idea to
more complicated task domains by adopting the sequential Monte Carlo approach to select trajectories
based on how promising they are, and learning the model-based knowledge necessary for planning in
the meantime. All of the above algorithms assume perfect observability and plan in the state space,
while our work generalizes the idea to belief space planning.
6	Conclusion
In this paper, we provided a new method named DualSMC to solve continuous POMDPs, which
has three advantages. First, it learns plausible belief representations for high-dimensional POMDPs
with an adversarial particle filter. Second, it plans future actions by considering the distributions of
the learned belief representations. The filter module and the planning module are inter-dependent
and jointly trained. Third, DualSMC combines the richness of neural networks as well as the inter-
pretability of classical sequential Monte Carlo methods. We empirically validated the effectiveness
of DualSMC on different tasks including visual navigation and control.
8
Under review as a conference paper at ICLR 2020
References
Martin Arjovsky, Soumith Chintala, and Leon Bottou. Wasserstein generative adversarial networks.
In ICML, 2017. 7
C. Beattie, J. Z. Leibo, D. Teplyashin, T. Ward, M. Wainwright, H. Kuttler, A. Lefrancq, S. Green,
V. Valdes, A. Sadik, J. Schrittwieser, K. Anderson, S. York, M. Cant, A. Cain, A. Bolton, S. Gaffney,
H. King, D. Hassabis, S. Legg, and S. Petersen. Deepmind lab. arXiv:1612.03801, 2016. 1, 6
Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and
Wojciech Zaremba. Openai gym. arXiv:1606.01540, 2016. 7
Pierre-Arnaud Coquelin, Romain Deguest, and Remi Munos. Particle filter-based policy gradient in
pomdps. In NeurIPS, 2009. 8
Dan Crisan and Arnaud Doucet. A survey of convergence results on particle filtering methods for
practitioners. IEEE TSP, 50(3):736-746, 2002. 11
Pieter-Tjerk De Boer, Dirk P Kroese, Shie Mannor, and Reuven Y Rubinstein. A tutorial on the
cross-entropy method. Annals of operations research, 134(1):19-67, 2005. 1
Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In NeurIPS, 2014. 7
Ishaan Gulrajani, Faruk Ahmed, Martin Arjovsky, Vincent Dumoulin, and Aaron Courville. Improved
training of wasserstein gans. In NeurIPS, 2017. 7
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy
maximum entropy deep reinforcement learning with a stochastic actor. In ICML, 2018. 11
Matthew Hausknecht and Peter Stone. Deep recurrent q-learning for partially observable mdps. In
2015 AAAI Fall Symposium Series, 2015. 1
Maximilian Igl, Luisa Zintgraf, Tuan Anh Le, Frank Wood, and Shimon Whiteson. Deep variational
reinforcement learning for pomdps. arXiv preprint arXiv:1806.02426, 2018. 1, 5, 8
Rico Jonschkowski, Divyam Rastogi, and Oliver Brock. Differentiable particle filters: End-to-end
learning with algorithmic priors. In RSS, 2018. 2, 3, 6, 8
Leslie Pack Kaelbling, Michael L Littman, and Anthony R Cassandra. Planning and acting in partially
observable stochastic domains. Artificial intelligence, 101(1-2):99-134, 1998. 1
Hilbert J Kappen, ViCenC Gomez, and Manfred Opper. Optimal control as a graphical model inference
problem. Machine learning, 87(2):159-182, 2012. 2
Peter Karkus, David Hsu, and Wee Sun Lee. Qmdp-net: Deep learning for planning under partial
observability. In NeurIPS, 2017. 8
Peter Karkus, David Hsu, and Wee Sun Lee. Integrating algorithmic planning and deep learning for
partially observable navigation. arXiv preprint arXiv:1807.06696, 2018a. 8
Peter Karkus, David Hsu, and Wee Sun Lee. Particle filter networks: End-to-end probabilistic
localization from visual observations. arXiv preprint arXiv:1805.08975, 2018b. 2, 6, 8
Sergey Levine. Reinforcement learning and control as probabilistic inference: Tutorial and review.
arXiv:1805.00909, 2018. 2, 8
Sergey Levine and Vladlen Koltun. Variational policy search via trajectory optimization. In NeurIPS,
2013. 8
Michael L Littman, Anthony R Cassandra, and Leslie Pack Kaelbling. Learning policies for partially
observable environments: Scaling up. In ICML, 1995. 4
Takeru Miyato, Toshiki Kataoka, Masanori Koyama, and Yuichi Yoshida. Spectral normalization for
generative adversarial networks. In ICLR, 2018. 7
9
Under review as a conference paper at ICLR 2020
Frans A Oliehoek, Julian FP Kooij, and Nikos Vlassis. The cross-entropy method for policy search in
decentralizedpomdps. Informatica, 32(4):341-357, 2008. 1
Shayegan Omidshafiei, Ali-Akbar Agha-Mohammadi, Christopher Amato, Shih-Yuan Liu, Jonathan P
How, and John Vian. Graph-based cross entropy method for solving multi-robot decentralized
pomdps. In ICRA, 2016. 1
Christos H Papadimitriou and John N Tsitsiklis. The complexity of markov decision processes.
Mathematics of operations research, 12(3):441-450, 1987. 1
Alexandre Piche, Valentin Thomas, Cyril Ibrahim, Yoshua Bengio, and Chris Pal. Probabilistic
planning with sequential monte carlo methods. In ICLR, 2018. 2, 3, 4, 8, 11, 12
Robert Platt Jr, Russ Tedrake, Leslie Kaelbling, and Tomas Lozano-Perez. Belief space planning
assuming maximum likelihood observations. In RSS, 2010. 6
Konrad Rawlik, Marc Toussaint, and Sethu Vijayakumar. An approximate inference approach to
temporal optimization in optimal control. In NeurIPS, 2010. 8
Konstantin M Seiler, Hanna Kurniawati, and Surya PN Singh. An online and approximate solver for
pomdps with continuous action space. In ICRA, 2015. 1
Tanmay Shankar, Santosha K Dwivedy, and Prithwijit Guha. Reinforcement learning via recurrent
convolutional neural networks. In ICPR, 2016. 8
David Silver and Joel Veness. Monte-carlo planning in large pomdps. In NeurIPS, 2010. 1
Zachary N Sunberg and Mykel J Kochenderfer. Online algorithms for pomdps with continuous state,
action, and observation spaces. In ICASP, 2018. 1
Aviv Tamar, Yi Wu, Garrett Thomas, Sergey Levine, and Pieter Abbeel. Value iteration networks. In
NeurIPS, 2016. 8
Emanuel Todorov. General duality between optimal control and estimation. In CDC, 2008. 2
Emanuel Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control.
In IROS, 2012. 1
Marc Toussaint. Robot trajectory optimization using approximate inference. In ICML, 2009. 2
Marc Toussaint and Amos Storkey. Probabilistic inference for solving discrete and continuous state
markov decision processes. In ICML, 2006. 8
Pengfei Zhu, Xin Li, Pascal Poupart, and Guanghui Miao. On improving deep reinforcement learning
for pomdps. arXiv preprint arXiv:1804.06309, 2018. 1
Brian D Ziebart. Modeling Purposeful Adaptive Behavior with the Principle of Maximum Causal
Entropy. PhD thesis, University of Washington, 2010. 8
10
Under review as a conference paper at ICLR 2020
A Particle-Independent Sequential Monte Carlo Planning
A straightforward baseline method of our planning approach is to compute the future policies of each
particle state independently. Similar to DualSMC planning, we initially sample M filtering particles
according to their particle weights. Differently, we roll out N future action/state trajectories for each
particle independently, following the probabilistic SMCP method (Piche et al., 2018). In the end,
there are M × N future planning trajectories, and we sample one of them according to the importance
weights. It is equivalent to the standard SMCP when M = 1. We refer this planning algorithm
as particle-independent SMC planning (PI-SMCP) and use it as an alternative of Algorithm 2 in
line 6 Algorithm 1. Details of PI-SMCP are shown in Algorithm 3. We train the PI-SMCP module
separately from the filtering network. For the policy network πρ , we perform the standard soft
actor-critic (SAC) (Haarnoja et al., 2018) on true states. Therefore, one disadvantage of PI-SMCP is
that the SAC policy network cannot perceive the uncertainty of the belief representations.
Algorithm 3 Particle-independent SMC planning with filtered belief representations
Input: top-M filtering particles {s(m),tυ(m)}M=ι, policy network ∏ρ, value network Qω
1:	{^(m×n) = g(m),w(m×n) = W(m)}M=N,n=ι	. Define M × N initial states for planning
2:	{W(n)}M1N = Normalize({W(n)}M=1N)	. Normalize weights of planning trajectories
3:	for i = t : t + H do	. At each planning time step
4:	{a(n) 〜∏ρ(^(n) )}M1N	. Sample N actions
5:	{^(+ι,r(n) 〜Tψ (^(n),a(n) )}M=1N	. Predict next-step states and rewards
6:	{W}n1 H W((U) ∙ exp(A(^(n),a(n), ^(+1))}M=1N	. Update weights, see Eq 2 for A(∙)
7:	{x(n) = (^(+)ι,a(n), ^in))}M=1N	. Assemble planning trajectories
8:	{x'}MlN 〜MUItinomial({x(U)}M×LN), w.r.t.{W(+1}M=1N	. Resample trajectories
9:	{w(ni = i}M×N
10:	end for
11:	Select at = first action of x(：+h, where n 〜UnifOrm(1,...,M × N)	. Return an action
B	Theoretical Justifications
In this section we provide theoretical justifications for our algorithms.
B.1 Analysis of the POMDPs Filtering S tep.
In the following, we use Xn -a-.→s X to denote the sequence of random variables Xn converge to
X almost surely. We show if we do not use Top-M selection step, the particle filtering estimator
is asymptotically consistent. We remark that Top-M is used for reducing the variance and it may
increase the biased and thus M is a hyper-parameter to balance the bias-variance trade-off.
Theorem 1. Assuming the transition kernel T is Feller and the the likelihood function Z is bounded,
continuous and strictly positive, then we have
lim belt -→ belt.
K→∞
Proof of Theorem 1. Consider the sequence {s(tk)}tL=,K1,k=1. Note the evolution of {s(tk)}tL=,K1,k=1
(induced by T and Z) forms a particle filtering sequence with resampling. Therefore, we can just
apply the Theorem 1 of Crisan & Doucet (2002) to finish the proof.	□
11
Under review as a conference paper at ICLR 2020
B.2 Alternative SMCP Update Formula
We provide the probabilistic graphical model of planning in Figure 8. Similar to the derivation in
Appendix A.4 of Piche et al. (2018), we have
wt
P(Xl：t|Ol：T)
q(xi：t)
P(Xl：t-l|Ol：T) P(Xt|xi：t-1, Ol:T)
q(xi：t-i)	q(xt|xi：t-i)
P(Xt|xi：t-1, Ol:T)
WtT	q(xt|xi：t-i)
wt-1	p(xi：t|Ol：T)
q(xt|xi：t-l) p(xi：t-l|Ol：T)
wt-1	p(Ol:T |xi：t)p(xi：t)
q(xt|xi：t-l) p(Ol:T |xi：t-l)p(xi：t-1)
wt-1_______p(Ol：t-l|xi：t-l)p(xi：t)p(Ot：T |xt)
q(xt|xi：t—l) p(Oi：t-2|xi：t-2)p(xi：t-i)p(Ot-i：T∣Xt-l)
/ wt-1~~∖p(xt∣xt-i)p(Ot-i∣xt-i)exp(Q(st, at) - Q(st-i,at-i))
q(xt|x1:t-1)
p(χt∣χt-1)
wt-1 q(χt∣χt-1)
exp Q(st, at) - Q(st-1, at-1) + rt-1
penv(st|st-1, at-1)
Wt-1-------Γ~ι-----------T exp
pmodel(st|st-1, at-1)
(Q(St, at) - Q(St-1, at-1) + rt-1 - log πθ(at|st)
Figure 8: Ot is the observed optimality variable that depends on the latent state st and action at .
C Network Details
Network details of the DualSMC model for the two planning tasks are summarized in Table 3.
D	Implementation Details
D.1 Floor Positioning
We use 100 particles to train the filtering module of DualSMC. Based on the top-3 particles, we roll
out 10 steps with 30 planning trajectories. We use Adam optimizer with a 10-3 learning rate. At test
time, we increase the planning horizon to 20 and the number of filtering particles to 300. All models
are trained for 10,000 episodes with a 64 batch size. All results are averaged over 1,000 episodes.
The maximum number of steps is 200.
D.2 3D Light-Dark
We use 100 particles to train the filtering module of DualSMC. Based on the top-3 particles, we roll
out 5 steps with 10 planning trajectories. We use Adam optimizer with a 0.0003 learning rate. At test
12
Under review as a conference paper at ICLR 2020
Table 3: Architecture details of the learnable models.
Module	Floor positioning	3D light-dark navigation
Z	3× fc: 256, 256, 16 2× lstm: 128, 128 3× fc: 256, 256, 1	Conv2d: (3,3), 16,2,1, ReLU Conv2d: (3, 3), 32, 2, 1, ReLU, MaxPool(2) Conv2d: (3, 3), 64, 2, 1, ReLU, Dropout(0.2) fc: 128, ReLU (*) concat: velocity and orientation 5× fc: 128, 128, 128, 128, 1
P	3× fc: 256, 256, 64 Concat: z(64)〜Norm(0,1) 4× fc: 256, 256, 256, 2	same as Z up to (*); fc: 64 concat: orientation, z(64)〜Norm(0,1) 3× fc: 128, 128, 2
T	4× fc: 256, 256, 256, 4	action noise: z(1)〜Norm(0,1) e = 3× fc(z): 128, 128, 1 concat: (state, action + e) 3×fc: 128, 128, 128, 5; add to state
Q	3× fc: 256, 256, 1	3× fc: 128, 128, 1
π	3× fc: 256, 256, 4	fc (on top-M): 64; fc (on mean belief): 64; concat; 2 × fc: 128, 1
time, we increase the planning horizon to 15 and the number of filtering particles to 400. All models
are trained for 2,000 episodes with a 128 batch size. All results are averaged over 100 episodes. The
maximum number of steps is 200.
D.3 Modified Reacher
We use 100 particles to train the filtering module of DualSMC. Based on the top-3 particles, we roll
out 1 step (since no multi-modal planning is necessary here) with 10 planning trajectories. We use
Adam optimizer with a 0.0003 learning rate. All models are trained for 20,000 episodes with a 256
batch size. As in the original Reacher environment, the maximum number of steps is 50.
13