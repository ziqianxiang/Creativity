Under review as a conference paper at ICLR 2020
Affine Self Convolution
Anonymous authors
Paper under double-blind review
Ab stract
Attention mechanisms, and most prominently self-attention, are a powerful build-
ing block for processing not only text but also images. These provide a parameter
efficient method for aggregating inputs. We focus on self-attention in vision mod-
els, and we combine it with convolution, which as far as we know, are the first to
do. What emerges is a convolution with data dependent filters. We call this an
Affine Self Convolution. While this is applied differently at each spatial location,
we show that it is translation equivariant. We also modify the Squeeze and Excita-
tion variant of attention, extending both variants of attention to the roto-translation
group. We evaluate these new models on CIFAR10 and CIFAR100 and show an
improvement in the number of parameters, while reaching comparable or higher
accuracy at test time against self-trained baselines.
1	Introduction
Computer vision has seen great success thanks to the use of the convolution operation in Convolu-
tional Neural Networks (CNNs) (LeCun et al., 1989; Krizhevsky et al., 2012; He et al., 2017; Mnih
et al., 2013). This operation takes advantage of the translational symmetry in visual perception
tasks such as image classification. Meanwhile, in tasks that require sequence processing, atten-
tion (Chorowski et al., 2015; Bahdanau et al., 2014) and self-attention (Vaswani et al., 2017) have
emerged as a powerful technique.
One of the peculiarities of CNNs is that filters are defined independently of the data. At the same
time, self-attention is data dependent, but does not provide a template matching scheme, as does the
convolution operation, since it merely reweights neighborhoods. While there is work towards using
attention in CNNs, the current models use them independently, sequentially, or in parallel.
We unify convolution and self-attention, taking the best of both worlds. Our method provides a
translationally equivariant convolution, where the filters are also dependent on the input. These
data dependent filters more efficiently describe the relations present in the input. Moreover, by
formulating it as a special convolution, it can be extended to be equivariant to other groups of
transformations. As a result, we apply the rich literature on group equivariant neural networks
(Cohen & Welling, 2016) and develop the roto-translation equivariant counterpart. This module can
be used as a replacement for standard convolutional layers and we call it an Affine Self Convolution.
Another variant of attention in computer vision is Squeeze and Excitation (Hu et al., 2018). This
provides global attention and we extend it to the roto-translation variant in order to compare it to our
module. We plan to release code for all the experiments soon.
The contributions of this work are:
•	We introduce the Affine Self Convolution (ASC), merging convolution and self-attention.
•	We prove ASC is translation equivariant.
•	We extend ASC to roto-translation equivariant ASC.
•	We develop group Squeeze and Excitation.
•	We evaluate these modules on CIFAR10 and CIFAR100.
1
Under review as a conference paper at ICLR 2020
2	Background
In order to combine convolution and self-attention we first look at the group convolutions (Cohen
et al., 2018a) and then at the self-attention mechanism (Vaswani et al., 2017; Parmar et al., 2018).
2.1	Group convolution
Group equivariant convolutional neural networks extend the operation of convolution. Cohen &
Welling (2016) show that we can consider the convolution operation to be defined on a group and
that this allows for a natural generalization to other objects that have a group structure.
Translation equivariant convolution The set of points in Z2 with the operation of vector addition
forms a group. For each value x in this group, the translation operator L(x) translates the domain ofa
function: L(x) [f](y) = f(-x + y). Therefore, given two functions f, ψ : Z2 → R, the convolution
between the image f and the filter ψ can be written in terms of translations by elements of the group
(Z2 , +) (we depict the convolution in Figure 1):
[f ?Z2 ψ](x) = X f (y)L(x)[ψ](y)	(1)
y∈Z2
Where the convolution operation ?Z2 is indexed by the domain of the input and the filter. Most
importantly, the convolution is equivariant to translations: L(z) [f] ?Z2 ψ = L(z) [f ?Z2 ψ]. This
property connects a transformation of the input image L(z) [f] with a precise transformation of the
activations L(z) [f ?Z2 ψ]. This is desirable because a model that implements such an operation can
also be invariant to translations by taking a max over spatial positions at the end.
Roto-translation equivariant convolution A natural extension of the group of translations is the
group of planar rotations and translations (Weiler et al., 2018b; Diaconu & Worrall, 2019). The
elements of this group have 2 components, a (proper) rotation R and a translation y:
SE(2) = {(R, y) ∈ (R∈R2×2,y ∈ R2)|R>R= RR> = I,det(R) = 1)}	(2)
Where I is the identity matrix of order 2 and (I, 0) is the identity element of SE(2). Through-
out this work we will use P, R, S to denote rotation elements and x, y, z translation elements of
the group SE(2). From here, we denote the G = SE(2). Similarly to Diaconu & Worrall
(2019), the operator L(P,x) inversely transforms the coordinates of a function f with domain R2
by L(P,x) [f](y) = f(P-1(y - x)). As a result, we can evaluate the planar convolution at points on
G, [f ?R2 ψ](P, x). This operation is called a lifting layer and outputs activations with domain G.
The operator L(P,x) transforms such functions by L(P,x) [f](R, y) = f (P -1R, P -1(y-x)). We can
preserve G equivariance of these functions by replacing the planar convolution with G convolutions
between f, ψ : G → R:
[f ?G ψ](P, x) = X f(R, y)L(P,x) [ψ](R, y)	(3)
(R,y)∈G
In practice we are limited by the sampling grid, as real world images are functions on Z2 . This has
as symmetries translations by integer values, which form the group Z2 and rotations by multiples of
90°, which form the group C4. By replacing the groups R2 and SO(2) in the definition of SE(2)
with Z2 and C4 we get the group p4. This is a subgroup of SE(2), and all the relations in this work
hold for both.
2.2	Self-attention in Computer vision
Simplified form We start with a simplified form of local self-attention to highlight each part and to
make notation clearer. For an input image f : Z2 → R, self-attention is defined by 2 parts: 1) a
score function between center pixel f(x) and a neighbor pixel f(y). This is usually the dot product,
score(f (x), f(y)) = f(x)f(y). Moreover, such that the score values in a neighborhood sum to 1,
the scores are normalized with softmax, α(x, y) = softmaxy (score(f (x), f (y)), 2) an aggregation
of the neighbors y based on the score function:
Attention[f](x) = X α(x, y)f(y)	(4)
y∈Z2
2
Under review as a conference paper at ICLR 2020
Figure 1: Convolution between an input f and a
3×3 filter ψ evaluated at x. We denote with (∙)
all the positions y in the neighborhood of x. This
begins by cropping the 3×3 neighborhood in f
centered at x. The filter is colored brown for clar-
ity, but it can have different values. The filter is
centered in the same neighborhood by translating
it L(X) [ψ](∙). The two quantities are then mul-
tiplied at each spatial position y, independently.
Finally, the sum over the spatial positions aggre-
gates the response of the convolution, concluding
how similar the input neighborhood around x is
to the filter.
Figure 2: Simple self-attention with extent 3×3
for an input f evaluated at x. Similarly to
the convolution (∙) denotes the neighborhood of
x. The 3×3 region around x is cropped. The
score function then compares the center with
each neighbor. The normalized score is α(x, y).
The scores and the input image neighborhood are
then multiplied at each spatial position. This is
shown over α(x, ∙)f (∙) by sharpening the color
on the building and whitening or removing the
color from the sky or trees. By summing over
the spatial dimension, we aggregate the neigh-
borhood scaled by how similar the center is to its
neighbors.
This operation defines a neighborhood dependent weighting. We depict this in Figure 2. The dot
product score function, and therefore Equation 4, does not take account of the relative position
between x and y. Simply, this encodes no spatial information. To take advantage of the regular grid
in images, recent methods use positional embeddings β : Z2 → R. These can be added to neighbors
at y , prior to computing the score, and is parametrized by the relative position from the center x, as
done in Ramachandran et al. (2019), α(x, y) = softmaxy (score(f (x), f(y) +β(y - x))). It can also
be added to the neighbors score, after computing the score function, as done in Bello et al. (2019);
Hu et al. (2019), α(x, y) = softmaxy (score(f (x), f(y)) + β(y - x))
Self-attention In practice, self-attention uses three sets of parameters (Parmar et al., 2018; Wang
et al., 2018), WQ, WK, WV , where Q, K, V stands for Query, Key, Value. We turn our attention to
an input function (image) f : Z2 → Rdin, with din input channels and parameters WQ, WK : Z2 →
Rdk ×din and WV : Z2 → Rdout ×din. WQ, WK, WV , which are implemented as 1×1 convolutions,
have the purpose of mapping to three separate embeddings, Q, K, V and not to process spatial
information. These have dk or dout channels. The spatial information is weighted and mixed by the
attention mechanism. In this more general setting, where we denote an arbitrary channel with c, self-
attention is defined with: 1) three linear mappings of the input f (defined analogously for K and
V ): Qc(x) = [f ?Z2 WcQ](x) 2) a normalized score function, which can use positional embeddings:
α(x, y) = softmaxy(score(Q(x), K(y))) and 3) an aggregation of the V embeddings based on the
score function:
Attention[Q, K, V]c(x) = X α(x,y)Vc(y)	(5)
y ∈Z2
It is also common to use the multi head mechanism from Transformer (Vaswani et al., 2017) along-
side attention. This means that Q, K, V are split along the channel dimension and the self-attention
mechanism is evaluated independently for each element of the partition (each head). These are then
concatenated and passed through a linear layer.
3	Method
In the following section we look at the local relative type of attention, self-attention and we formulate
it similarly to convolution. This allows us to merge the two and then develop the roto-translational
3
Under review as a conference paper at ICLR 2020
Figure 3: Simple ASC for an input f and an affine map A with extent 3×3 evaluated at x. As
for Figures 1 and 2, (∙) denotes the neighborhood of x. The neighborhood is first extracted from
the input, then the affine map parameters are centered in the neighborhood of x. For each spatial
position, f is transformed affinely by L(X)[ψ](∙) and L(X)[β](∙), which results in A(X)[f](∙). If
we were to sum now over spatial positions, this would be an affine convolution. Nonetheless, the
affinely transformed input is now passed through the self-attention mechanism. This consists of
evaluating a similarity score between the center of the neighborhood and the neighbors α(x, y)
and then multiplying the input with the score function. As a result, the ASC module can focus on
the parts of the image that contain information relevant to the center. Similarly to both previous
methods, the neighbors’ information is aggregated as the final step. Intuitively, what we get is a data
dependent convolution between for the image around x.
Self-attention
/⑺[力 3)	a3)
^-(æ)[/](ɔ αCM —张)
variant. We also derive the roto-translational variant of the Squeeze and Excite module, which
defines global attention.
3.1	Affine Self Convolution (ASC)
Affine map We have seen how simplified self-attention in Equation 4 is applied to an input image
and that it was further developed using relative positional embeddings β in order to include spatial
information. We note that these are additive terms and extend them by a multiplicative term ψ that
is also spatially dependent. This results in a affine map A, which depends on β, ψ : Z2 → R. We
define the map A relative to a center x: A(X) : (Z2 , R) → R and we apply it using the translation
operator L(X) as A(X) (y, r) = rL(X) [ψ](y) + L(X) [β](y). Furthermore, we can describe the affine
map as acting on an image f : Z2 → R:
A(X)[f](y) := A(X)(y,f(y)) = f(y)l(x)[ψ](y) + L(X)[β](y)	⑹
Simplified form Applying the affine map A, then simplified self-attention from Equation 4 to f :
Attention[A(X) [f]](x) = y α(x, y)A(X) [f](y) is how we define the simplified ASC. We denote
this with Z2. This is applied to two functions, an input and an affine filter, and we index it by the
domain of the two functions, similarly to the convolution operation:
Z2 [f, A](x) := X α(x, y)A(X)[f](y) = X α(x,y)(f(y)L(X)[ψ](y)+L(X)[β](y))	(7)
y	y∈Z2 V"{ }	、----{----} 、-----{----}
score	filter	positional emb
This uses the self-attention score from Equation 4, the convolutional filter from Equation 1 and
also adds positional embeddings. Moreover, we can distribute α and view α(x, y)L(X) [ψ](y) and
α(x, y)L(X) [β](y) as the parameters of a normalized affine map. Intuitively, this not only performs
template matching through ψ , which is independent of the information in the image, but scales
the template relative to what is in the image through α(x, y). By unifying the convolution and
self-attention, these data dependent filters can more efficiently describe the relations in the image
because they are applied differently at each location. We call this an Affine Self Convolution and we
depict it in Figure 3. It is possible to recover the usual convolution by setting the scaling coefficients
α(x, y) to 1 and β to 0. By setting ψ to 1, we recover a simplified self-attention, where positional
embeddings are used for computing the score and for the aggregated term.
4
Under review as a conference paper at ICLR 2020
Translation equivariance We prove that this is translation equivariant in the Appendix 21 and
therefore: Z2 [L(z) [f], A](x) = L(z) [Z2 [f, A]](x). This means that this model can detect objects
regardless of their position in the image, as does the standard convolution.
Affine Self Convolution Similarly to the general form of self-attention in Equation 5, we use three
sets of parameters, (WQ, AQ), (WK, AK), (WV , AV ) for an input f : Z2 → Rdin. This is depicted
in Appendix Figure 5. By contrast to the simple variant, we now also have the affine maps. These
process spatial information and are 0 outside the extent, which is controlled by a hyperparameter:
kernel size. Moreover, each affine map, can be implemented with ψQ, ψK : Z2 → Rdk×dk, mapping
from all the channels in the input to all the channels in the output or ψQ, ψK : Z2 → Rdk, mapping
from one channel in the input to the same channel in the output. The same is true for ψV , if we
replace dk with dout. Our experiments use the latter, due to computational constraints. The additive
term of the map is defined as βQ, βK : Z2 → Rdk, where for βV , dk is replaced with dout. We
denote an arbitrary channel with c and we define ASC as:
1)	three linear mappings of the input f (defined analogously for K and V ):
Qc (x) = [f ?Z2 WcQ](x)	(8)
2)	three affine maps AQ, AK, AV for the Q, K, V terms (defined analogously for K and V ):
A(Qx)[Q]c(y) = Qc(y)L(x) [ψQ]c(y) + L(x)[βQ]c(y)	(9)
3)	a score function between center x and neighbor y, which is then normalized with softmax:
α(x, y) = softmaxy(score(A(Qx)[Q](x), A(Kx)[K](y)))	(10)
4)	an aggregation of the V embeddings based on the score function:
Z2[V,AV]c(x) = X α(x, y)A(Vx)[V]c(y)	(11)
y∈Z2
We also use the multi head mechanism. We note that now we have a separate set of parameters for
AQ, AK, AV , and that AQ is only evaluated at:A(Qx) [Q](x) = Q(x)ψQ + βQ. Therefore, we can
learn ψQ , βQ for only one spatial index 0.
By comparison, the positional embeddings in Ramachandran et al. (2019) are represented by the
term βK. The positional embeddings in Hu et al. (2019) are equivalent to learning the product of the
embeddings βQβK, which arises when multiplying AxQ[Q](x)AxK[K](y). A difference between this
work and their work is that we directly learn these parameters, while Ramachandran et al. (2019);
Hu et al. (2019) use a separate network to learn β .
3.2	Roto-translation Affine Self Convolution
We now use the machinery of this new operation and the group theoretic background to develop the
roto-translation ASC. Similarly to the standard ASC, we first define a simplified form based on an
affine map, then we prove roto-translation equivariance, and finally, we present the general form.
Affine map We now turn to functions on SE(2). We will denote G := SE(2), H := SO(2), R2 =
G/H . Similarly to the relative affine map for functions defined on Z2 in equation 6, we define a
relative affine map A for functions on G. This map uses affine parameters ψ, β : G → R and is
defined as A(P,x) : (G, R) → R. This acts on a function f with domain G as:
A(P,x) [f](R, y) := f(R, y)L(P,x) [ψ](R, y) + L(P,x) [β](R, y)	(12)
This affine map transforms a function f relative to a center (P, x).
Simplified form To define the score function, we notice that we can split the sum over the group G
in Equation 3 into two sums, Py∈g∕h Pr∈h A(p,x) [f](R, y). In this form, for each P ∈ H the
convolution can be seen as a weighted sum of the neighbors y, relative to a center x. We can scale
the affine group convolution based on this intuition. Precisely, we add a score function that is based
on each center (P, x) and each neighbor y:
α((P, x), y) = softmaxy
A(P,x)[f](R, x)
A(P,x)[f](R,y)
(13)
5
Under review as a conference paper at ICLR 2020
We note that it might also be possible to define a score function α((P, x), (R, y)). Nonetheless,
this could be computationally prohibitive and is not required in order to preserve roto-translation
equivariance. Using the score in Equation 13 we define the Simple ASC on G:
G [f, A](P, x) = X α((P, x), y) X A(P,x) [f](R, y)	(14)
y∈G∕H	R∈H
We show in the Appendix 24 that we can replace PR∈H β(R, x) with β(x). Therefore, we can
learn β as a function with domain G/H .
Roto-translation equivariance We verify that ASC on groups is equivariant to actions of the group
G, by checking the equivariance relation in the Appendix 25.
Roto-translation ASC In practice, the input is discrete and we turn to functions on p4, G :=
p4, H := C4 , Z2 = G/H . For the general roto-translation ASC all quantities are defined analo-
gously to the ASC on Z2 in Equation 11, using the score function in Equation 13, the aggregation in
Equation 14 and replacing the domain Z2 with G. The details can be found in Appendix D.
3.3	Group S queeze and Excite
Interactions between filters that are spatially far apart is also tackled in Squeeze and Excitation (SE)
(Hu et al., 2018). The SE module proposes to rescale each feature map based on a global aggregation
of the spatial dimension. An intuition for this is that, by allowing for channel interactions at all the
spatial locations, this effectively enlarges the receptive field maximally. This is also a parameter
efficient method for increasing the receptive field.
For a general group G (with g, h, s ∈ G), the squeeze term takes an average of a function
f : G → Rdin over the group. This is invariant to transformations by actions of the group G,
which we show in the Appendix 28. The average is then passed through a one hidden layer MLP
(Wι ∈ RdinX(din/r),W2 ∈ R(din/r)xdin, where 4口 is the number of channels of the input and r is the
reduction ratio). A sigmoid unit (σ) is then used on the activation.
squeeze(f) = σ
W1 (ReLU (W2 (|G| XGf (h)))))
(15)
These are then broadcasted across the domain with an element-wise multiplication, fc0in (g) =
fcin(g)squeezecin (f). Therefore, multiplying a function f(g) by squeeze(f) preserves the group
structure of f :
L(s) [f0]cin(g) = L(s) [fcin(g)squeezecin(f)] = L(s) [f]cin (g)squeezecin (f)	(16)
This is added as the last operation in any bottleneck ResNet. In our experiments, the group is either
the group of integer translations Z2 (which is the original operation is Hu et al. (2018) and for which
|G| is the height×width of the image) or the discrete roto-translation group p4 (for which |G| is
height×width×4, since there are 4 rotation in p4).
4	Experiments
In this section we describe the dataset used and motivate our baseline architecture. The results are
then divided into models that use convolution only and models that use self-attention, including
ASC. We then present the overall trends. We specify various hyperparameters in the Appendix C.
Dataset In our experiments we test the models’ performance on the CIFAR10 and CIFAR100
datasets (Krizhevsky et al., 2009). These consist of 60k images each, 50k for training and 10k for
testing. We further split the training set into 45k images for training and we leave 5k for validation.
CIFAR10 consists of 10 classes and CIFAR100 consists of 100 classes.
Backbone ResNets (He et al., 2016) are a family of CNNs. They are composed of building blocks
which are either basic blocks, which have 2n layers per feature map size or bottleneck blocks, which
have 3n layers per feature map size. For CIFAR the feature map sizes are (32, 16, 8). Based on the
choice of n He et al. (2016) define the depth of the network. On top of this, they also count the
6
Under review as a conference paper at ICLR 2020
initial and the final layer. As a result we can choose basic block ResNets with 6n + 2 layers or
bottleneck block ResNets with 9n+ 2 layers. In our experiments we use a variant of the ResNet that
is appropriate for CIFAR and also uses bottleneck residual blocks. We take this approach because
the models using self-attention in the literature use it as a replacement for the 3 × 3 layer inside the
bottleneck residual block and we do the same. As a result, from the standard ResNet20, which is an
example of a ResNet with basic residual block (6n + 2 layers, with n = 3), we arrive at ResNet29,
which is an example of a ResNet with bottleneck residual block (9n + 2 layers, with n = 3).
Models We present the results on CIFAR10 in Figure 4. The models are divided into convolution
only models and self-attention models, including ASC. Convolution models include squeeze and
excite models (SE), since these do not change the convolution operation, but adds the SE module at
the end of each bottleneck block. We show the baseline ResNet29, the roto-translational baseline
p4ResNet29, together with these models with SE. We now turn to models that use self-attention, for
which we replace the 3 × 3 convolutions in ResNet29s bottleneck with self-attention. This means
that we still leave a convolution, the convolution in the stem (this is the first layer in all ResNets). We
experiment with several models. We replicate the strategy for positional embeddings in Ramachan-
dran et al. (2019) and we only learn a factorized variant of βK , instead of learning an affine map for
each of the Q, K, V terms. These parameters are factorized over the spatial dimensions. This means
that for each head, half of the positional embeddings βK is invariant to horizontal translations, while
the other half is invariant to vertical translations. Models using these parametrization of self-atten-
tion are denoted with +SASA. Self-attention models includes ASC models. We use SimPle-ASC
based on Equation 7. This does not use three separate pairs of parameters, just one. With +ASC we
denote the general form of ASC as described in equation 11. We also include ResNet29+ASC+SE
as one of the models. This is because ASC and SE are not mutually exclusive and we can add the
SE module as for a standard ResNet. We also train a roto-translation ASC, which we denote with
p4ResNet29+ASC. This uses the general form of roto-translation ASC as described in equation 20.
93 -
Small model
High acc
(％) ijφsijsφl
92 -
91 -
90-
89-
Big model
Low acc
self-attention models
*	p4ResNet29+ASC (OUrS)
*	ReSNet29+ASC (Ours)
*	ReSNet29+SASA
Tlr ReSNet29+Simple_ASC (Ours)
*	ReSNet29+ASC+SE (Ours)
convolution models
p p4ResNet29
R ResNet29
p p4ResNet29 + SE
R ResNet29+SE
*
220	240	260	280	300	320	340
Model size
Figure 4: ComParing the model size (in thousands of Parameters) to accuracy of several variants of
ResNet29 on CIFAR10. Error bars rePresent 1 standard deviation from 8 runs. Precise numbers are
in APPendix Table 2.
Results The overall trade-off between accuracy and Parameter count in Figure 4 shows that all the
self-attention models use fewer Parameters than convolution models, while reaching an accuracy
in the same range. This confirms the intuition that data dePendent filters are more flexible and a
Powerful modeling choice. We see that +SE adds a small imProvement to convolutional models, but
no imProvement to +ASC models. This indicates that local self-attention Provides enough sPatial
context. In terms of the self-attention models, +SASA is the only one which does not manage to
comPete with the baseline. We conclude that a relative affine maP is required, additive Positional
embeddings are not enough. Most insightful, +Simple_ASC drastically decreases the number of
Parameters (≈ 30%) and reaches accuracy within one standard deviation of the baseline. The three
models with the highest accuracy are the roto-translational counterparts to standard models. They
7
Under review as a conference paper at ICLR 2020
Table 1: We show accuracy mean and 1 standard deviation from 8 runs while varying random seed
of various models on CIFAR100. Plot variant in Appendix Figure 4
	Model	Accuracy	#ParameterS
translation	ReSNet29	68.34 ± 0.38	336k
equivariant	ReSNet29+Simple_ASC (ours)	68.40 ± 0.78	240k
	ReSNet29+ASC (ours)	68.68 ± 0.77	291k
roto-translation	p4ResNet29	72.03 ± 0.46	321k
equivariant	p4ResNet29+SE	72.03 ± 0.45	354k
	p4ResNet29+ASC (OUrS)	72.71 ± 0.51	283k
show a clear constant increase in performance with little to no extra parameters. This confirms
that the theory was applied consistently and that the group theoretic approach benefits attention
mechanisms. We ran a subset of the models on Cifar100, results are shown in Table 1. The table
shows that both ASC and roto-translation equivariance are more beneficial on this dataset. This
indicates that these models generalize better when there is less data available.
The experiments show that self-attention is competitive when including the affine map as done in
ASC and that roto-translational equivariance is a robust improvement in all models.
5	Related work
Group equivariant CNNs The theoretically founded approach of group equivariant neural networks
has motivated several advances. These works are presented under a unifying framework of group
equivariant convolutional networks in Cohen et al. (2018a). Closely related to our work are the
developments in planar Euclidean groups in Worrall et al. (2017); Weiler et al. (2018b); Diaconu &
Worrall (2019) and the discrete variants of these in LeCun et al. (1989); Cohen & Welling (2016);
Dieleman et al. (2016); Hoogeboom et al. (2018) and 3D in Kondor (2018); Cohen et al. (2018b);
Esteves et al. (2018a); Worrall & Brostow (2018); Weiler et al. (2018a); Winkels & Cohen (2018);
Thomas et al. (2018). We note that this work would benefit from extensions to semigroups (Worrall
& Welling, 2019) or curved manifolds (Cohen et al., 2019). Other relevant works include Kondor &
Trivedi (2018); Esteves et al. (2019; 2018b); Marcos et al. (2017); Zhou et al. (2017); Bekkers et al.
(2018); Jacobsen et al. (2017).
Self-attention Various forms of self-attention for CNNs have been introduced based on non-local
means (Buades et al., 2005) or on the Transformer (Vaswani et al., 2017). These models are generally
trained for classification/segmentation (Wang et al., 2018; Hu et al., 2019), but have also been used
for generative tasks (Parmar et al., 2018; Zhang et al., 2018). Some works (Hu et al., 2019) show
that locality of the self-attention mechanism together with softmax helps and that relative positional
embeddings are essential. In parallel, Ramachandran et al. (2019) also show improvements using
local self-attention with local relative positional embeddings over Bello et al. (2019) which use
global self-attention with global positional embeddings. We describe in more detail how our model
is related to Ramachandran et al. (2019); Hu et al. (2019) at the end of Section 3.1. It is also worth
mentioning that several of these works compare convolutional models with attention based models
and show that convolutional models require more floating point operations per second (FLOPS).
Self-attention has also been applied to graphs (Velickovic et al., 2017). Regardless, they are faster
than the attention based models.
Data dependent filters Other works which approach the problem of learning to apply filters differ-
ently at each spatial positions are Stanley et al. (2019); Jia et al. (2016); Ha et al. (2016); Jaderberg
et al. (2015); Sabour et al. (2017); Kosiorek et al. (2019).
6	Conclusion
In this work we show that there is a mixture of convolution and self-attention that can be used to
replace spatial convolutions in CNNs. This module can be described as a convolution with data
dependent filters. By retaining all the benefits of self-attention and convolution, what emerges are
filters that are translationally equivariant, while being applied differently for each location in the
8
Under review as a conference paper at ICLR 2020
input. The results show that this method is able to achieve comparable if not better performance
than the convolutional models, while using fewer parameters and a bigger receptive field. Under
simplifying assumptions, we can recover both self-attention and convolution, which allows us to
incorporate the group theoretic approach of Group equivariant CNNs. Therefore, we prove the
translational equivariance of ASC and we also develop the roto-translation equivariant ASC. The
latter, is more robust to transformations of the input while surpassing the other models in accuracy.
We expect the most fruitful directions for future work to be: an efficient implementation (because
self-attention is slower), efficient parametrization (order and shape of Ws and As), merge self-
attention and convolution for NLP/graphs, and equivariant ASC for manifolds (equivariant self-
attention could score transport methods without assuming a predefined geometry).
References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly
learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.
Erik J Bekkers, Maxime W Lafarge, Mitko Veta, Koen AJ Eppenhof, Josien PW Pluim, and Remco
Duits. Roto-translation covariant convolutional networks for medical image analysis. In In-
ternational Conference on Medical Image Computing and Computer-Assisted Intervention, pp.
440-448. Springer, 2018.
Irwan Bello, Barret Zoph, Ashish Vaswani, Jonathon Shlens, and Quoc V Le. Attention augmented
convolutional networks. arXiv preprint arXiv:1904.09925, 2019.
Antoni Buades, Bartomeu Coll, and J-M Morel. A non-local algorithm for image denoising. In 2005
IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’05),
volume 2, pp. 60-65. IEEE, 2005.
Jan K Chorowski, Dzmitry Bahdanau, Dmitriy Serdyuk, Kyunghyun Cho, and Yoshua Bengio.
Attention-based models for speech recognition. In Advances in neural information processing
systems, pp. 577-585, 2015.
Taco Cohen and Max Welling. Group equivariant convolutional networks. In Proceedings of the
33nd International Conference on Machine Learning, ICML 2016, New York City, NY, USA, June
19-24, 2016, pp. 2990-2999, 2016.
Taco Cohen, Mario Geiger, and Maurice Weiler. A general theory of equivariant cnns on homoge-
neous spaces. arXiv preprint arXiv:1811.02017, 2018a.
Taco Cohen, Maurice Weiler, Berkay Kicanaoglu, and Max Welling. Gauge equivariant convolu-
tional networks and the icosahedral cnn. In International Conference on Machine Learning, pp.
1321-1330, 2019.
Taco S. Cohen, Mario Geiger, Jonas Koehler, and Max Welling. Spherical cnns, 2018b.
Nichita Diaconu and Daniel Worrall. Learning to convolve: A generalized weight-tying approach.
In International Conference on Machine Learning, pp. 1586-1595, 2019.
Sander Dieleman, Jeffrey De Fauw, and Koray Kavukcuoglu. Exploiting cyclic symmetry in con-
volutional neural networks. In International Conference on Machine Learning, pp. 1889-1898,
2016.
Carlos Esteves, Christine Allen-Blanchette, Ameesh Makadia, and Kostas Daniilidis. Learning so
(3) equivariant representations with spherical cnns. In Proceedings of the European Conference
on Computer Vision (ECCV), pp. 52-68, 2018a.
Carlos Esteves, Avneesh Sud, Zhengyi Luo, Kostas Daniilidis, and Ameesh Makadia. Cross-domain
3d equivariant image embeddings. arXiv preprint arXiv:1812.02716, 2018b.
Carlos Esteves, Yinshuang Xu, Christine Allen-Blanchette, and Kostas Daniilidis. Equivariant multi-
view networks. arXiv preprint arXiv:1904.00993, 2019.
9
Under review as a conference paper at ICLR 2020
Priya Goyal, Piotr Dollar, Ross Girshick, Pieter Noordhuis, LUkasz Wesolowski, AaPo Kyrola, An-
drew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch sgd: Training imagenet
in 1 hour. arXiv preprint arXiv:1706.02677, 2017.
David Ha, Andrew Dai, and Quoc V Le. HyPernetworks. arXiv preprint arXiv:1609.09106, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Delving deeP into rectifiers: SurPassing
human-level Performance on imagenet classification. In Proceedings of the IEEE international
Conference on computer vision, pp. 1026-1034, 2015.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. DeeP residual learning for image recog-
nition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp.
770-778, 2016.
Kaiming He, Georgia Gkioxari, Piotr Dollar, and Ross Girshick. Mask r-cnn. In Proceedings ofthe
IEEE international conference on computer vision, pp. 2961-2969, 2017.
Emiel Hoogeboom, Jorn WT Peters, Taco S Cohen, and Max Welling. Hexaconv. arXiv preprint
arXiv:1803.02108, 2018.
Han Hu, Zheng Zhang, Zhenda Xie, and Stephen Lin. Local relation networks for image recognition.
arXiv preprint arXiv:1904.11491, 2019.
Jie Hu, Li Shen, and Gang Sun. Squeeze-and-excitation networks. In Proceedings of the IEEE
conference on computer vision and pattern recognition, pp. 7132-7141, 2018.
Yerlan Idelbayev. pytorchresnetcifar10. https://github.com/akamaster/pytorch_
resnet_cifar10.
Jorn-Henrik Jacobsen, Bert De Brabandere, and Arnold WM Smeulders. Dynamic steerable blocks
in deep residual networks. arXiv preprint arXiv:1706.00598, 2017.
Max Jaderberg, Karen Simonyan, Andrew Zisserman, et al. Spatial transformer networks. In Ad-
vances in neural information processing systems, pp. 2017-2025, 2015.
Xu Jia, Bert De Brabandere, Tinne Tuytelaars, and Luc V Gool. Dynamic filter networks. In
Advances in Neural Information Processing Systems, pp. 667-675, 2016.
Risi Kondor. N-body networks: a covariant hierarchical neural network architecture for learning
atomic potentials. arXiv preprint arXiv:1803.01588, 2018.
Risi Kondor and Shubhendu Trivedi. On the generalization of equivariance and convolution in neural
networks to the action of compact groups. In International Conference on Machine Learning, pp.
2747-2755, 2018.
Adam R Kosiorek, Sara Sabour, Yee Whye Teh, and Geoffrey E Hinton. Stacked capsule autoen-
coders. arXiv preprint arXiv:1906.06818, 2019.
Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convo-
lutional neural networks. In Advances in neural information processing systems, pp. 1097-1105,
2012.
Alex Krizhevsky et al. Learning multiple layers of features from tiny images. Technical report,
Citeseer, 2009.
Yann LeCun, Bernhard Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne Hub-
bard, and Lawrence D Jackel. Backpropagation applied to handwritten zip code recognition.
Neural computation, 1(4):541-551, 1989.
Diego Marcos, Michele Volpi, Nikos Komodakis, and Devis Tuia. Rotation equivariant vector field
networks. In Proceedings of the IEEE International Conference on Computer Vision, pp. 5048-
5057, 2017.
10
Under review as a conference paper at ICLR 2020
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wier-
stra, and Martin Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint
arXiv:1312.5602, 2013.
Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, Eukasz Kaiser, Noam Shazeer, Alexander Ku, and
Dustin Tran. Image transformer. arXiv preprint arXiv:1802.05751, 2018.
Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito,
Zeming Lin, Alban Desmaison, Luca Antiga, and Adam Lerer. Automatic differentiation in
PyTorch. In NIPS Autodiff Workshop, 2017.
Prajit Ramachandran, Niki Parmar, Ashish Vaswani, Irwan Bello, Anselm Levskaya, and Jonathon
Shlens. Stand-alone self-attention in vision models. arXiv preprint arXiv:1906.05909, 2019.
Sara Sabour, Nicholas Frosst, and Geoffrey E Hinton. Dynamic routing between capsules. In
Advances in neural information processing systems, pp. 3856-3866, 2017.
Kenneth O Stanley, Jeff Clune, Joel Lehman, and Risto Miikkulainen. Designing neural networks
through neuroevolution. Nature Machine Intelligence, 1(1):24-35, 2019.
Oleg Smery. imgclsmob. https://github.com/osmr/imgclsmob.
Nathaniel Thomas, Tess Smidt, Steven Kearnes, Lusann Yang, Li Li, Kai Kohlhoff, and Patrick
Riley. Tensor field networks: Rotation-and translation-equivariant neural networks for 3d point
clouds. arXiv preprint arXiv:1802.08219, 2018.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,
Eukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information
processing systems, pp. 5998-6008, 2017.
Petar VeliCkovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua
Bengio. Graph attention networks. arXiv preprint arXiv:1710.10903, 2017.
Xiaolong Wang, Ross Girshick, Abhinav Gupta, and Kaiming He. Non-local neural networks. In
Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 7794-
7803, 2018.
Maurice Weiler, Mario Geiger, Max Welling, Wouter Boomsma, and Taco Cohen. 3d steerable cnns:
Learning rotationally equivariant features in volumetric data. In Advances in Neural Information
Processing Systems, pp. 10381-10392, 2018a.
Maurice Weiler, Fred A Hamprecht, and Martin Storath. Learning steerable filters for rotation equiv-
ariant cnns. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,
pp. 849-858, 2018b.
Marysia Winkels and Taco S Cohen. 3d g-cnns for pulmonary nodule detection. arXiv preprint
arXiv:1804.04656, 2018.
Daniel Worrall and Gabriel Brostow. Cubenet: Equivariance to 3d rotation and translation. In
Proceedings of the European Conference on Computer Vision (ECCV), pp. 567-584, 2018.
Daniel E Worrall and Max Welling. Deep scale-spaces: Equivariance over scale. arXiv preprint
arXiv:1905.11697, 2019.
Daniel E Worrall, Stephan J Garbin, Daniyar Turmukhambetov, and Gabriel J Brostow. Harmonic
networks: Deep translation and rotation equivariance. In Proceedings of the IEEE Conference on
Computer Vision and Pattern Recognition, pp. 5028-5037, 2017.
Han Zhang, Ian Goodfellow, Dimitris Metaxas, and Augustus Odena. Self-attention generative
adversarial networks. arXiv preprint arXiv:1805.08318, 2018.
Yanzhao Zhou, Qixiang Ye, Qiang Qiu, and Jianbin Jiao. Oriented response networks. In Proceed-
ings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 519-528, 2017.
11
Under review as a conference paper at ICLR 2020
A QKV ASC picture
⅛4⅛B
©lilIBIMlrs—
Figure 5: Affine Self Convolution with extent 3×3 evaluated at x. Yellow depicts the cropped
region. For clarity, the affine parameters are not depicted, just the output of the affine map. As
opposed to Simple ASC in Figure 3, here we have 3 linear transformations WQ, WK, WV , which
do not process spatial information, just output 3 separate embeddings Q, K, V for the same input
f . Moreover, three local affine maps AQ , AK , AV are applied to each neighborhood relative to a
center x in order to process spatial information. The score α(x, y) is evaluated between the center
taken from Q and the neighbors taken from K . The score is then used to aggregate neighbors taken
from V . This depicts how self-attention is applied in practice.
B Results
Table 2: We show accuracy mean and 1 standard deviation from 8 runs while varying random seed
of various models on CIFAR10. With bold we outline the highest accuracy second highest with
blue. We do the same for the most parameter efficient models. Plot variant in Figure 4.
	Model	Accuracy	#Parameters
	ReSNet29	91.18 ± 0.34	313k
convolution	ResNet29 + SE	91.39 ± 0.15	347k
models	p4ResNet29	93.02 ± 0.16	310k
	p4ResNet29 + SE	93.24 ± 0.17	342k
	ReSNet29+SASA	89.43 ± 0.40	235k
	ReSNet29+Simple_ASC (ours)	91.01 ± 0.24	217k
self-attention	ResNet29+ASC (ours)	91.24 ± 0.32	268k
models	ResNet29+ASC+SE (ours)	91.21 ± 0.11	301k
	p4ResNet29+ASC (ours)	93.03 ± 0.25	272k
We also run preliminary experiments with ResNet83 (bottleneck block 9n + 2, with n = 9), which
are presented in Figure 7. These show a similar trend to the ResNet29 models, but they also indicate
that attention, either as SE or ASC might be more rewarding in bigger models.
12
Under review as a conference paper at ICLR 2020
Small model
High acc
self-attention models
* p4ResNet29+ASC (OUrs)
* ResNet29+ASC (Ours)
Tlr ReSNet29+Simple_ASC (Ours)
I Big model
Low acc
convolution models
p p4ResNet29
R ResNet29
p p4ResNet29 + SE
220	240	260	280	300	320	340
Model size
Figure 6: Comparing the model size (in thousands of parameters) to accuracy of several variants of
ResNet29 on CIFAR100. Error bars represent 1 standard deviation from 8 runs. Precise numbers
are in Table 1.
95.5 -
95.0-
94.5 -
94.0-
93.5 -
93.0-
92.5 -
92.0-
self-attention models
* p4ResNet83+ASC (OUrs)
*	ResNet83+ASC (OUrs)
*	ResNet83 + SASA
convolution models
p p4ResNet83
R ResNet83
p p4ResNet83 + SE
R ResNet83 + SE
650	700	750	800	850	900	950
Model size
Figure 7: Comparing the parameter efficiency (model size) to accuracy of several variants of
ResNet83 on CIFAR10. Model size is divided by 1000. These results are from only 1 run of
each model.
C Hyperparameters, initialization and training schedule
We normalize the images and use the standard data augmentation technique of random horizontal
flips and random crops of 32×32 from the zero padded 36×36 images.
We initialize convolutional layers using He initialization (He et al., 2015) (for the p4 variant, the
number of channels is multiplied by 4 in the He initialization) and we initialize batchnorms scaling
coefficient γ to 1 and shifting coefficient β to 0. The reduction ratio in SE is 16, while inp4 models,
the reduction ratio in SE is 4.
In the self-attention models we replace the spatial convolutions in the bottleneck layers with self-
attention layers. Where the baseline ResNet uses a stride of 2, the self-attention models applies self-
attention then an average pooling layer with kernel size 2×2 and stride 2. The self-attention layers
use the multi head mechanism with 8 heads and a kernel size of 5. We set dk = dout. In all examples
We initialize ψ,β 〜N(0,1). We use the dot product score normalized by /. These models are
13
Under review as a conference paper at ICLR 2020
more unstable in the first couple of epochs. Therefore, we initialize the scaling coefficient γ of the
last batchnorm in each residual block to 0 as done in Goyal et al. (2017). Moreover, we warmup
(per epoch) the learning rate for the first 10 epochs, up to the learning rate of 0.1. The models are
trained using Nesterov accelerated gradient with momentum 0.9 and weight decay of 0.0001. The
ResNet29 models and its variants are trained for 100 epochs, where the learning rate was divided
by 10 at epochs 50 and 75 and each model was trained for 100 epochs. We also include examples
of ResNet83. These bigger models we trained for 200 epochs and divided the learning rate by
10 at epochs 100 and 150. We do this for all the models, for a fair comparison. Throughout our
experiments we used Pytorch (Paszke et al., 2017). We have also taken inspiration from the GitHub
repositories: Smery; Idelbayev.
When We use roto-translation layers instead of standard layers, We divide the number of channels in
each stage of the ResNet by，|p4| = 2. This preserves a similar number of parameters between the
roto-translation models and the standard models.
D Roto-translation ASC
In practice, the input is discrete and We turn to functions on p4, G := p4, H := C4 , Z2 = G/H. For
the general roto-translation ASC all quantities are defined analogously to the ASC on Z2 in Equation
11, using the score function in Equation 13 and replacing the domain Z2 With G. Therefore, We
define roto-translation ASC With:
1)	three linear mappings of the input f (defined analogously for K and V ):
Qc(P, x) =[f?GWcQ](P,x)	(17)
2)	three affine maps AQ, AK, AV for the Q, K, V terms (defined analogously for K and V ):
A(QP,x)[Q]c(R, y) =Qc(R, y)L(P,x)ψcQ(R, y) + L(P,x)βcQ(y)	(18)
3)	a score function betWeen center (P, x) and neighbor y, Which is then normalized With softmax:
α((P, x), y) =softmaxy(score	X A(QP,x)[Q](R, x) , X A(KP,x)[K](R, y)	)
R∈H	R∈H
(19)
4)	an aggregation of the V embeddings based on the score function: The final aggregation step
completely describes the roto-translation ASC operation:
G[V, AV]c(P, x) = X α((P, x), y) X A(VP,x)[V]c(R, y)	(20)
y∈Z2	R∈H
Similarly to ASC, for roto-translation ASC We learn ψQ, βQ for only one spatial index 0.
E Proofs
ASC translation equivariance proof
Claim:
口Z2 [L(z) [f ], A](χ)=L(z) [□Z2 [f, A]](χ)	(21)
Proof:
Expanding from the left hand side:
□z2[L(z)[f], A](x) = E softmaxy(SCOre(A(x)[L(z)[f]](x), A(x)[L(z)[f]](y)))
y∈Z2
A(X) [L(z)[f ]](y)
Using the substitution: y → y + Z
Using: y → y + Z ⇒ A(X) [L(z) [f]](y) = A(-z+χ) [f ](y), which we prove in the Appendix
22.
14
Under review as a conference paper at ICLR 2020
Using: A(x)[L(z)[f ]](x) = A(-z+χ)[f](-z + x), which we prove in the Appendix 23.
=E Softmaxy(SCore(A(-z+χ)[f](-z + x), A(-z+x)[f](y)))
y∈Z2
A(-z+χ)[f ](y)
=□z2 [f, A](-z + x)
=L(z) [□Z2 [f, A]](χ)
Proof
Claim:
y → y + Z ⇒ A(x)[L(z)[fMy) = A(-z+x)[f](y)	(22)
Proof:
A(x)[L(z)[fMy) =L(z)[f](y)ψ(y - * * * * * * * * * X) + β(y - X)
=f(y - z)ψ(y - χ) + β(y - χ)
Using the substitution: y → y + Z
=f (y)ψ(y + z - χ) + β(y + Z - χ)
=A(-z+x)[f ](y)
Proof		
Claim: Proof:	A(x)[L(z)[f ]](x) = A(-z+χ) [f](x - z) A(x)[L(z)[f]](X)=L(Z) [f](x)ψ(x - x) + β(x - x) =f (x — z)ψ((x — z) — (x — z)) + β((x — z) — (x — z)) = A(X-z)[f](X - z)	(23)
Proof β is a function on G/H
Claim:
X A(p,χ)[f](R,y) = X f (R,y)L(P,χ)[ψ](R,y) + L(p,x)[β](y)	(24)
R∈H	R∈H
Proof:
For the ASC on groups, the map A and therefore, α and β, are always used inside Pr∈h.
This leads to a more parameter efficient parametrization for β:
X A(p,x)f](R,y) = X f (R,y)L(p,x)[ψ](R,y) + L(p,x)[e](R,y)
R∈H	R∈H
=X f (R,y)L(p,χ)[ψ](R,y)+ X L(p,x)[e](R,y)
R∈H	R∈H
X L(P,χ)[β](R,y) = X β(P-1R,P-1(y - χ))
R∈H	R∈H
Using the substitution: R → PR
=X β(i,P-1(y - x))
R∈H
15
Under review as a conference paper at ICLR 2020
This is actually a function on G/H, not the whole group G. Therefore, We replace
Pr∈h β(R,x) with β(x).
Roto-translation ASC equivariance proof
Claim:
^G[L(s,z)[f], A](P,χ) = L(s,z)[□G[f, A]](P,X)
(25)
Proof:
Expanding on the left hand side:
□G[L(s,z)[f ], A](P,χ)= E SOftmaxy
y∈G∕H
A(p,x)[L(s,z)[f ]](R,x)
X A(P,x)[L(s,z)[f]](R,y)))
R∈H	))
EA(P,χ)[L(s,z)[f]](R,y)
∖R∈H	)
Using the substitution: R → SR and y → Sy + Z
Using: R→ SR ⇒ A(p,x)[L(s,z)[f ]](R,x) = A(s,z)-ι(p,x)[f ](R, S T(X -z)),whiChWe
prove in the Appendix 26.
Using: R → SR,y → Sy + Z ⇒ A(p,x)[L(s,z)[f]](R,y) = A(s,z)-ι(P,χ)[f](R, y), which
we prove in the Appendix 27.
E softmaxy
y∈G∕H
A(S,z)-i(P,x)[f](R,S-1(χ -Z))
E A(s,z)-1(p,χ)[f](R,y)))
R∈H	))
AS A(S,z)-1(P,x)[f](R,y)
R∈H
=□G[f, A∖(S-1P,S-1(χ -Z))
=L(s,z)[□G[f, A]](P,χ)
By arriving at the right hand side of equation 25, we concolude the proof that roto-translation
ASC is equivariant to actions of the group SE(2).
Proof
Claim:
R → SR ⇒ A(P,x)[L(S,z)[f]](R,x) = A(S,z)-1(P,x)[f](R, S-1(x -Z))
(26)
16
Under review as a conference paper at ICLR 2020
F'	∖ Proof:
A(p,x) [L(S,z) [f ]](R, X)=L(S,z) [f ](R, X)L(P,x) [Ψ](R, x) + L(p,x) [β](x)
=f (S-1R, S-1(x - z))ψ(P-1R, P-1(x - x)) + β(P-1(x - x))
Using the substitution: R → SR
=f (R,S-1(x - z))ψ(P-1SR,P-1(x - x))+
+ β(P-I(X — x))
=f (R,S-1(x - z))ψ(P-1SR,P-1S(S-1(x - z) - S-1(x - z))) +
+ β(P-1S(S-1 (x - z) - S-1(x - z)))
=f (R, S-1(x - z))L(S-ιP,S-i(x-z))[Ψ](R, S-1(x - z))+
+ L(STP,S-1(x-z))[β](ST(X - z)))
=A(S-iP,S-i(x-z))[f](R, S-1(x - z))
=A(S,z)-1(P,x)[f](R, ST(X - z)) 		J
Proof
Claim:
R→ SR,y→ Sy + Z ⇒ A(P,x)[L(s,z)[f]](R,y) = A(s,z)-i(P,x)[f](R,y)
(27)
Proof:
A(p,x) [L(s,z) [f ]](R, y) =L(s,z) [f ](R, y)L(p,x) [Ψ](R, y) + 小[β](y)
=f (S-1R, S-1(y - z))ψ(P-1R, Pry - x)) + β(P-1(y - x))
Using the substitutions: R → SR and y → Sy + Z
=f (R, y)Ψ(P-1SR, P-1(Sy + z - x))+
+ β(P-1(Sy + Z - x))
=f (R, y)Ψ(P-1SR, P-1S(y - ST(X - z)))+
+ β(P-1S(y - ST(X - Z)))
=f (R,U)L(S-1P,ST(x-z)) [ψ](R, y) +
+ L(S-1 P,S-1(x-z)) [β](y))
=A(S-ιP,s-ι(x-z))[f](R, y)
=A(S,z)-i(p,x)[f](R, y)
17
Under review as a conference paper at ICLR 2020
18