Under review as a conference paper at ICLR 2020
Learning Invariants through Soft Unification
Anonymous authors
Paper under double-blind review
Ab stract
Human reasoning involves recognising common underlying principles across
many examples by utilising variables. The by-products of such reasoning are
invariants that capture patterns across examples such as “if someone went some-
where then they are there” without mentioning specific people or places. Humans
learn what variables are and how to use them at a young age, and the question this
paper addresses is whether machines can also learn and use variables solely from
examples without requiring human pre-engineering. We propose Unification Net-
works that incorporate soft unification into neural networks to learn variables and
by doing so lift examples into invariants that can then be used to solve a given task.
We evaluate our approach on four datasets to demonstrate that learning invariants
captures patterns in the data and can improve performance over baselines.
1	Introduction
Humans have the ability to process symbolic knowledge and maintain symbolic thought (Unger
& Deacon, 1998). When reasoning, humans do not require combinatorial enumeration of exam-
ples but instead utilise invariant patterns with placeholders replacing specific entities. Symbolic
cognitive models (Lewis, 1999) embrace this perspective with the human mind seen as an informa-
tion processing system operating on formal symbols such as reading a stream of tokens in natural
language. The language of thought hypothesis (Morton & Fodor, 1978) frames human thought as a
structural construct with varying sub-components such as “X went to Y”. By recognising what varies
across examples, humans are capable of lifting examples into invariant principles that account for
other instances. This symbolic thought with variables is learned at a young age through symbolic
play (Piaget, 2001). For instance a child learns that a sword can be substituted with a stick (Frost
et al., 2004) and engage in pretend play.
Although variables are inherent in models of computation and
symbolic formalisms, as in first-order logic (Russell & Norvig,
2016), they are pre-engineered and used to solve specific tasks
by means of unification or assignments that bound variables to
given values. However, when learning from data only, being
able to recognise when and which symbols should take on dif-
ferent values, i.e. symbols that can act as variables, is crucial
for lifting examples into general principles that are invariant
across multiple instances. Figure 1 shows the invariant learned
by our approach: if someone is the same thing as someone
else then they have the same colour. With this invariant, our
approach can solve all of the training and test examples in task
16 of the bAbI dataset (Weston et al., 2016).
In this paper we address the question of whether a machine can
learn and use the notion of a variable, i.e. a symbol that can take on different values. For instance,
given an example of the form “bernhard is a frog” the machine would learn that the token “bernhard”
could be someone else and the token “frog” could be something else. If we consider unification a
selection of the most appropriate value for a variable given a choice of values, we can reframe it as
a form of attention. Attention models (Bahdanau et al., 2015; Luong et al., 2015; Chaudhari et al.,
2019) allow neural networks to focus, attend to certain parts of the input often for the purpose of
selecting a relevant portion. Since attention mechanisms are also differentiable they are often jointly
X:bernhard is a Y:frog
Z:lily is a Y:frog
Z:lily is A:green
What colour is X:bernhard
A :green
Figure 1: Invariant learned for
bAbI task 16, basic induction,
Where X:bernhard denotes a vari-
able With default symbol bernhard.
This single invariant accounts for
all the training and test examples.
1
Under review as a conference paper at ICLR 2020
learned within a task. This perspective motivates our idea of a unification mechanism that utilises
attention and is therefore fully differentiable which we refer to as soft unification.
Hence, we propose an end-to-end differentiable neural network approach for learning and utilising
the notion of a variable that in return can lift examples into invariants used by the network to perform
reasoning tasks. Specifically, we (i) propose a novel architecture capable of learning and using
variables by lifting a given example through soft unification, (ii) present the empirical results of our
approach on four datasets and (iii) analyse the learned invariants that capture the underlying patterns
present in the tasks. Our implementation using Chainer (Tokui et al., 2015) is publicly available at
[link removed](anonymous link provided with submission).
2	Soft Unification
Reasoning with variables involves identifying what variables are, the setting in which they are used
as well as the process by which they are assigned values. When the varying components, i.e. vari-
ables, of an example are identified, the remaining structure can be lifted into an invariant which then
accounts for multiple other instances.
Definition 1 (Variable). Given a set of symbols S, a variable X is defined as apairX , (x, sd) where
sd ∈ S is the default symbol of the variable and x is a discrete random variable of which the support
is S. The representation of a variable φV (X:sd) is equal to the expected value of the corresponding
random variable x given the default symbol sd :
φv (X:Sd) = Ex 〜P [φ(x)] = X P(X = x∣Sd)φ(x)	(1)
x∈S
where φ : S → Rd is a d-dimensional real-valued feature of a symbol s.
For example, φ could be an embedding and φV (X:sd) would become a weighted sum of symbol
embeddings as in conventional attention models. The default symbol of a variable is intended to
capture the variable’s bound meaning following the idea of referants by Frege (1948). We denote
variables using X, Y, A etc. such as X:bernhard where X is the name of the variable and bernhard
the default symbol as shown in Figure 1.
Definition 2 (Invariant). Given a structure (e.g. list, grid) G over S, an invariant is a pair I , (G, ψ)
where G ∈ G is the invariant example such as a tokenised story with tokens as symbols and ψ : S →
[0, 1] is a function representing the degree to which the symbol is considered a variable. Thus, the
final representation of a symbol s included in G, φI (s) is:
φI (s) = (1 - ψ(s))φ(s) + ψ(s)φV (X:s)	(2)
the linear interpolation between its representation φ(s) and its variable bound value with itself as
the default symbol φV (X:s).
We adhere to the term invariant and refrain from mentioning rules, unground rules, etc. used in logic-
based formalisms, e.g. Muggleton & de Raedt (1994), since neither the invariant structure needs to
be rule-like nor the variables carry logical semantics. This distinction is clarified in Section 6.
Definition 3 (Unification). Given an invariant I and an example K ∈ G , unification binds the
variables in I to symbols in K . Defined as a function g : I × G → G, unification binds variables
by computing the probability mass functions, P in equation 1, and returns the unified representation
using equation 2. The probability mass function of a variable X:sd is:
P(x = x|sd) = softmax(φU (sd)φU (K)T), K = support of x	(3)
where φu : S → Rd is the unifying feature of a symbol and φu(K) ∈ RlKl×d is applied element
wise to symbols in K. If g is differentiable, it is referred to as soft unification.
We distinguish φ from φU to emphasise that the unifying properties of the symbols might be different
from their representations. For example, φ(bernhard) could represent a specific person whereas
φU (bernhard) the notion of someone.
Overall soft unification incorporates 3 learnable components: φ, ψ, φU which denote the base fea-
tures, variableness and unifying features of a symbol respectively. Given an upstream, potentially
2
Under review as a conference paper at ICLR 2020
task specific, network f : G → S, an invariant I ∈ I and an input example K ∈ G with a corre-
sponding desired output a ∈ S, the following holds:
f ◦ g(I, K) = f(K) = a	(4)
where f now predicts based on the unified representation produced by g. In this work, we focus on
g, the invariants it produces together with the interaction of f ◦ g.
3 Unification Networks
Since soft unification is end-to-end differentiable, it can be incorporated into existing task-specific
upstream architectures. We present 3 architectures that model f ◦ g using multi-layer percep-
trons (MLP), convolutional neural networks (CNN) and memory networks (Weston et al., 2015)
to demonstrate the flexibility of our approach. In all cases, the d dimensional representation of sym-
bols are learnable embeddings φ(s) = O[s]TE with E ∈ RlSl×d randomly initialised by N(0,1)
and O[s] the one-hot encoding of the symbol. The variableness of symbols is a learnable weight
ψw(s) = σ(ws) where w ∈ R|S| and σ is the sigmoid function. We consider every symbol indepen-
dently a variable irrespective of its surrounding context and leave further contextualised formulations
as future work. The underlying intuition of this configuration is that a useful symbol for a correct
prediction might need to take on other values for different inputs. This usefulness can be viewed
as the inbound gradient to the corresponding ws parameter and ψw(s) acting as a gate. For further
model details including the size of the embeddings, please refer to Appendix A.
Unification MLP (UMLP) (f : MLP, g: RNN) We combine soft unification into a multi-layer
perceptron to process fixed length inputs. In this case, the structure G is a sequence of symbols
with a fixed length l, e.g. a sequence of digits 4234. Given an embedded input φ(k) ∈ Rl×d,
the upstream MLP computes the output symbol based on the flattened representations f (φ(k)) =
softmax(hET) where h ∈ Rd is the output of the last layer. However, to compute the unifying
features φU, definition 3, g uses a bi-directional GRU (Cho et al., 2014) running over φ(k) such that
φU (k) = WU Φ(k) where Φ(k) ∈ Rd is the hidden state of the GRU at symbol k and WU ∈ Rd×d
is a learnable parameter. This model emphasises the flexibility around the boundary of f ◦ g and that
the unifying features can be computed in any differentiable manner.
—Mem MemOry RNN	unification
Figure 2: Graphical overview of soft unification within a memory network. Each sentence is pro-
cessed by two bi-directional RNNs for memory and unification. At each iteration the context atten-
tion selects which sentences to unify and the invariant produces the same answer as the example.
Unification CNN (UCNN) (f: CNN, g: CNN) Given a grid of embedded symbols φ(K) ∈
Rw×h×d where w is the width and h the height, we use a convolutional neural network such that
the final prediction is f (φ(K)) = softmax((W h + b)ET) where h this time is the result of global
max pooling and W , b are learnable parameters. We also model g using a separate convolutional
network with the same architecture as f and set φU (k) = c2(relu(c1 (k)) where c1, c2 are the con-
volutional layers. The grid is padded with 0s to obtain w × h × d after each convolution such that
every symbol has a unifying feature. This model conveys how soft unification can be adapted to the
specifics of the domain for example by using a convolution in a spatially structured input.
Unification Memory Networks (UMN) (f : MemNN, g: RNN) Soft unification does not need to
happen prior to f in a f ◦ g fashion but can also be incorporated at any intermediate stage multiple
times. To demonstrate this ability, we unify the symbols at different memory locations at each
iteration of a Memory Network (Weston et al., 2015). Memory networks can handle a list of lists
3
Under review as a conference paper at ICLR 2020
Table 1: Sample context, query and answer triples and their training sizes per task. For distribution
of generated number of examples per task on Sequence and Grid data refer to Appendix B.
Dataset	Context	Query	Answer	Training Size
Sequence	8384 003	duPlicate	8	≤ 1k, ≤ 50
Grid	016 857	corner	7	≤ 1k, ≤ 50
bAbI	Mary went to the kitchen. Sandra journeyed to the garden.	Where is Mary?	kitchen	1k, 50
Logic	P(X) J q(X). q(a).	P(a).	True	1k, 10k, 50
structure such as a tokenised story as shown in Figure 2. The memory network f uses the final hidden
state of a bi-directional GRU (outer squares in Figure 2) as the sentence representations to compute
a context attention. At each iteration, we unify the words between the attended sentences using the
same approach in UMLP with another bi-directional GRU (inner diamonds in Figure 2) for unifying
features φU (bernhard) = WU Φ(bernhard). Following equation 2, the new unified representation of
the memory slot is computed and f uses it to perform the next iteration. Concretely, g produces an
unification tensor U ∈ RM ×m×N ×d where M and m is the number of sentences and words in the
invariant respectively, and N is the number of sentences in the example such that after the context
attentions are applied over M and N, we obtain φ(k) ∈ Rm×d as the unified sentence at that
iteration. Note that unlike in the UMLP case, the sentences can be of varying length. The prediction
is then softmax(W hIJ + b) where hIJ is the hidden state of the invariant after J iterations. This
setup, however, requires pre-training f such that the context attentions match the correct sentences.
A task might contain different questions such as “Where is X?” and “Why did X go to Y?”. To let
the models differentiate between questions and potentially learn different invariants, we extend them
with a repository of invariants I ∈ I and aggregate the predictions from each invariant. One simple
approach is to sum the predictions of the invariants PI∈I f ◦ g(I, K) used in UMLP and UCNN.
Another approach could be to use features from the invariants such as memory representations in
the case of UMN. For UMN, we weigh the predictions using a bilinear attention η based on the
hidden states at the first iteration hI0 and h0K such that η = softmax(hI0 W h0KT ). To initially form
the repository of invariants, we use the bag-of-words representation of the questions and find the
most dissimilar ones based on their cosine similarity as a heuristic to obtain varied examples.
4 Datasets
We use 4 datasets consisting of context, query and an answer (C, q, a): fixed length sequences of
symbols, shapes of symbols in a grid, story based natural language reasoning with the bAbI (Weston
et al., 2016) dataset and logical reasoning represented as logic programs, examples shown in Table 1
with further samples in Appendix B. In each case we use an appropriate model: UMLP for fixed
length sequences, UCNN for grid and UMN for iterative reasoning. We use synthetic datasets of
which the data generating distributions are known to evaluate not only the quantitative performance
but also the quality of the invariants learned by our approach.
Fixed Length Sequences We generate sequences of length l = 4 with 8 unique symbols represented
as digits to predict (i) a constant, (ii) the head of the sequence, (iii) the tail and (iv) the duplicate
symbol. We randomly generate 1000 triples and then only take the unique ones to ensure the test
split contains unseen examples. The training is then performed over a 5-fold cross-validation.
Grid To spatially organise symbols, we generate a grid of size 3 ×3 with 8 unique symbols organised
into 2 × 2 box of identical symbol, a vertical, diagonal or horizontal sequence of length 3, a cross
or a plus shape and a triangle. In each task we predict (i) the identical symbol, (ii) the head of the
sequence, (iii) the centre of the cross or plus and (iv) the corner of the triangle respectively. We
follow the same procedure from sequences and randomly generate 1000 discarding duplicate triples.
bAbI The bAbI dataset has become a standard benchmark for evaluating memory based networks.
It consists of 20 synthetically generated natural language reasoning tasks (refer to Weston et al.
4
Under review as a conference paper at ICLR 2020
(2016) for task details). We take the 1k English set and use 0.1 of the training set as validation. Each
token is lower cased and considered a unique symbol. Following previous works (Seo et al., 2017;
Sukhbaatar et al., 2015), we take multiple word answers also to be a unique symbol in S.
Logical Reasoning To demonstrate the flexibility of our approach and distinguish our notion of
a variable from that used in logic based formalisms, we generate logical reasoning tasks in the
form of logic programs using the procedure by Cingillioglu & Russo (2019). The tasks involve
learning f (C, Q) = True - C ' Q over 12 classes of logic programs exhibiting varying paradigms
of logical reasoning including negation by failure (Clark, 1978). We generate 1k and 10k logic
programs per task for training with 0.1 as validation and another 1k for testing. We set the arity of
literals to 1 or 2 using one random character from the English alphabet for predicates and constants,
e.g. p(p) and an upper case character for logical variables, e.g. p(X).
5 Experiments
We probe three aspects of soft unification: the impact of unification on performance over unseen
data, the effect of multiple invariants and data efficiency. To that end, we train UMLP and UCNN
with and without unification, UMN with pre-training using 1 or 3 invariants over either the en-
tire training set or only 50 examples. Every model is trained 3 times via back-propagation using
Adam (Kingma & Ba, 2015) on an Intel Core i7-6700 CPU using the following objective function:
J = λκLnll(f(K), a) + λu	Lnll(f ◦ g(I, K), a) + TE ψw(s)
s∈S
(5)
where Lnll is the negative log-likelihood with sparsity regularisation over ψ at τ = 0.1 to discourage
the models from utilising spurious number of variables. For UMLP and UCNN, we set λK =
0, λU = 1 for training just the unified output and the converse for the non-unifying versions. To
pre-train the UMN, we start with λK = 1, λU = 0 for 40 epochs then set λU = 1 to jointly train
the unified output. For iterative tasks, the mean squared error between hidden states (hjI - hjK)2
at each iteration j and, in the strongly supervised cases, the negative log-likelihood for the context
attentions using provided supporting facts are also added to the objective function. Further details
such as batch size and total number of epochs are available in Appendix C.
Iteration
Iteration
Unification
No
Yes
Training Size
≤ 1000
≤ 50
Figure 3:	Test accuracy over iterations for Unification MLP and Unification CNN models with 1
invariant versus no unification. We observe that with soft unification the models achieve higher
accuracy with fewer iterations than their plain counterparts on both per task training sizes.
Figure 3 portrays how soft unification generalises better to unseen examples in test sets - the same
sequence or grid never appears in both the training and test sets as outlined in Section 4 - over plain
models. Despite f ◦ g having more trainable parameters than f alone, the models with unification
not only maintain higher accuracy in each iteration and solve the tasks in as few as 250 iterations
with ≤ 1000 training examples but also improve accuracy by ≈ 0.3 when trained with only ≤ 50
per task. We believe soft unification architecturally biases the models towards learning structural
patterns which in return achieves better results on recognising common patterns of symbols across
examples. Results with multiple invariants are identical and the models seem to ignore the extra
invariants due to the fact that the tasks can be solved with a single invariant and the regularisation
applied on ψ zeroing out unnecessary invariants; further results in Appendix D. The fluctuations in
accuracy around iterations 750 to 1000 in UCNN are also caused by penalising ψ which forces the
model to relearn the task with less variables half way through training.
5
Under review as a conference paper at ICLR 2020
Table 2: Aggregate error rates (%) on bAbI 1k for UMN and N2N, GN2N, MemNN by Sukhbaatar
et al. (2015), Liu & Perez (2017) and Weston et al. (2015) respectively. Full comparison on individ-
ual tasks are available in Appendix D.
Training Size Supervision # Invs / Model	1k	I				50 3	N2N	1k			Strong MemNN
	Weak I		1	Strong 3			Weak		QRN	
	1	3					GN2N	EntNet		
Mean	19.1	20.5	6.3	6.0	27.6	13.9	12.7	29.6	11.3	6.7
#> 5%	8	10	4	4	17	11	10	15	5	4
Following Tables 2 and 3, we observe a trend of better performance through strong supervision,
more data per task and using only 1 invariant. We believe strong supervision aids with selecting
the correct sentences to unify and in a weak setting the model attempts to unify arbitrary context
sentences often failing to follow the iterative reasoning chain. The increase in performance with
more data and strong supervision is consistent with previous work reflecting how f ◦ g can be
bounded by the efficacy of f modelled as a memory network. As a result, only in the supervised
case do we observe a minor improvement over MemNN by 0.7 in Table 2 and no improvement in the
weak case over comparable memory based networks in Table 3. This dependency on f also limits
the ability of f ◦ g to learn from 50 examples per task failing 17/20 and 12/12 of bAbI and logical
reasoning tasks respectively. The increase in error rate with 3 invariants, we speculate, stems from
having more parameters and more pathways in the model rendering training more difficult.
Table 3: Aggregate task error rates (%) on the logical reasoning dataset for UMN and DMN, IMA by
Cingillioglu & Russo (2019). Strong supervision, more data and only 1 invariant seem to improve
the performance of UMN over plain iterative models. Individual task results are in Appendix D.
Training Size			1k				10k			50	20k	
Supervision	Weak		I Strong		Weak			Strong			Weak	
Arity	1	2	1	2	1	2	1	2	2	2	2	2
# Invs / Model	1	3	1	3	1	3	1	1	3	3	DMN	IMA
Mean	36.4	39.3	14.3	28.9	21.5	31.8	2.4	12.2	16.0	47.1	21.2	9.1
#> 5%	9	11	7	11	7	10	1	5	9	12	11	5
6 Analysis
After training, we can extract the learned invariants by applying a threshold on ∀s ∈ S : ψ(s) > t
indicating whether a symbol is used as a variable or not. We set t = 0.0 for all datasets except
for bAbI, we use t = 0.1. The magnitude of this threshold seems to depend on the amount of
regularisation τ , equation 5, and the number of training steps along with batch size all controlling
how much ψ is pushed towards 0. Sample invariants shown in Figure 4 describe the common patterns
present in the tasks with parts that contribute towards the final answer becoming variables. Extra
symbols such as is or travelled do not emerge as variables, as shown in Figure 4a; we attribute
this behaviour to the fact that changing the token travelled to went does not influence the
prediction but changing the action, the value of Z:left to ‘picked’ does. However, based on random
initialisation, our approach can convert an arbitrary symbol into a variable and let f compensate
for the unifications it produces. For example, the invariant “X:8 5 2 2” could predict the tail of
another example by unifying the head with the tail using φU, equation 3, of those symbols. Further
examples are shown in Appendix D. Pre-training f as done in UMN seems to produce more robust
and consistent invariants compared to immediately training f ◦ g since, we speculate, by equation 4
f might encourage g(I, K) ≈ K.
Interpretability versus Ability A desired property of interpretable models is transparency (Lipton,
2018). A novel outcome of the learned invariants in our approach is that they provide an approx-
imation of the underlying general principle present in the data such as the structure of multi-hop
reasoning shown in Figure 4e. However, certain aspects regarding the ability of the model such as
how it performs temporal reasoning, are still hidden inside f . In Figure 4b, although we observe
Z:morning as a variable, the overall learned invariant captures nothing about how changing the value
of Z:morning alters the behaviour of f . The model might look before or after a certain time point
6
Under review as a conference paper at ICLR 2020
Y:john Z:left the X:football
Y:john travelled to the A:office
where is the X:football
A :offiee
(a) bAbI task 2, two supporting facts. The model also
learns Z:left since people can also drop or pick up ob-
jects potentially affecting the answer.
this Z:morning X:bill went to the Y:school
yesterday X:bill journeyed to the A:park
where was X:bill before the Y:school
A :park
(b) bAbI task 14, time reasoning. X:bill and Y:school
are recognised as variables alongside Z:morning cap-
turing when someone went which is crucial to this task.
5 8 6 4 const	2	0XX	010	001	X:i( T ) J Z:l( T ),
X:8 3 3 1 head	X:8	0XX	6Y8	054	Z:l( U ) J R:x( U ),
8 3 1 Y:5 tail	Y:5	000	070	78X	R:x ( K ) J S:n ( K ),
Z:1 43Z:1 dup	Z:1	box	centre	corner	S:n( Y:o) ' X:i( Y:o)
(c) Successful invariants learned
with UMLP using 50 training ex-
amples only shown as (C, Q, a).
(d) Successful invariants learned
with UCNN. Variable default sym-
bols are omitted for clarity.
(e) Logical reasoning task 5 with
arity 1. The model captures how
S:n could entail X:i in a chain.
Figure 4:	Invariants learned across the four datasets using the three architectures. For iterative
reasoning datasets, bAbI and logical reasoning, they are taken from strongly supervised UMN.
X:bill went somewhere depending what Z:morning binds to. Without the regularising term on ψ(s),
we initially noticed the models using, one might call extra, symbols as variables and binding them to
the same value occasionally producing unifications such as “bathroom bathroom to the bathroom”
and still f predicting, perhaps unsurprisingly, the correct answer as bathroom. Hence, regularising
ψ with the correct amount τ in equation 5 to reduce the capacity of unification seems critical in
extracting not just any invariant but one that represents the common structure.
Soft unification from equation 3 reveals three main patterns: one-to-one, one-to-many or many-to-
one bindings as shown in Figure 5; further examples are in Appendix D. Figure 5a captures what one
might expect unification to look like where variables unify with their corresponding counterparts,
e.g. X:bernhard with brian and Y:frog with lion. However, occasionally the model can optimise to
use less variables and squeeze the required information into a single variable, for example by binding
Y:bathroom to john and kitchen as shown in Figure 5b. We believe this occurs due to the sparsity
constraint on ψ(s) encouraging the model tobe as conservative as possible. Finally, if there are more
variables than needed as in Figure 5c, we observe a many-to-one binding with Y:w and Z:e mapping
to the same constant q. This behaviour begs the question how does the model differentiate between
p(q) and p(q, q). We speculate the model uses the magnitude of ψ(w) = 0.037 and ψ(e) = 0.042
to encode the difference despite both variables unifying with the same constant.
(a) bAbI task 16. A one-to-one
mapping is created between vari-
ables X:bernhard with brian and
Y:frog with lion.
(b) bAbI task 6. Only Y:bathroom
is recognised as variable creating a
one-to-many binding to capture the
same information.
(c) Logical reasoning task 1. An
arity 2 predicate is forced to bind
with arity 1 creating a many-to-one
binding.
Figure 5:	Variable bindings produced from equation 3. Darker cells indicate higher attention values.
7
Under review as a conference paper at ICLR 2020
7	Related Work
Learning an underlying general principle in the form of an invariant is often the means for arguing
generalisation in neural networks. For example, Neural Turing Machines (Graves et al., 2014) are
tested on previously unseen sequences to support the view that the model might have captured the
underlying pattern or algorithm. In fact, Weston et al. (2015) claim “MemNNs can discover simple
linguistic patterns based on verbal forms such as (X, dropped, Y), (X, took, Y) or (X, journeyed
to, Y) and can successfully generalise the meaning of their instantiations.” However, this claim is
based on the output of f and unfortunately it is unknown whether the model has truly learned such a
representation or indeed is utilising it. Our approach sheds light to this ambiguity and presents these
linguistic patterns explicitly as invariants ensuring their utility through g without solely analysing
the output of f on previously unseen symbols. Although we associate these invariants with our exist-
ing understanding of the task to mistakenly anthropomorphise the machine, for example by thinking
it has learned X:mary as someone, it is important to acknowledge that these are just symbolic pat-
terns. In these cases, our interpretations do not necessarily correspond to any understanding of the
machine, relating to the Chinese room argument made by Searle (1980).
Learning invariants by lifting ground examples is related to least common generalisation (Reynolds,
1970) by which inductive inference is performed on facts (Shapiro, 1981) such as generalising
went(mary,kitchen) and went(john,garden) to went(X,Y). Unlike in a predicate logic setting, our
approach allows for soft alignment and therefore generalisation between varying length sequences.
Existing neuro-symbolic systems (Broda et al., 2002) focus on inducing rules that adhere to given
logical semantics of what variables and rules are. For example, δILP (Evans & Grefenstette, 2018)
constructs a network by rigidly following the given semantics of first-order logic. Similarly, Lifted
Relational Neural Networks (Sourek et al., 2015) ground first-order logic rules into a neural network
while Neural Theorem Provers (Rocktschel & Riedel, 2017) build neural networks using backward-
chaining (Russell & Norvig, 2016) on a given background knowledge base with templates. However,
the notion of a variable is pre-defined rather than learned with a focus on presenting a practical ap-
proach to solving certain problems, whereas our motivation stems from a cognitive perspective.
At first it may seem the learned invariants, Section 6, make the model more interpretable; however,
this transparency is not of the model f but of the data. The invariant captures patterns that poten-
tially approximates the data generating distribution but we still do not know how the model f uses
them upstream. Thus, from the perspective of explainable artificial intelligence (XAI) (Adadi &
Berrada, 2018), learning invariants or interpreting them do not constitute an explanation of the rea-
soning model f even though “if someone goes somewhere then they are there” might look like one.
Instead, it can be perceived as causal attribution (Miller, 2019) in which someone being somewhere
is attributed to them going there. This perspective also relates to gradient based model explanation
methods such as Layer-Wise Relevance Propagation (Bach et al., 2015) and Grad-CAM (Selvaraju
et al., 2017; Chattopadhay et al., 2018). Consequently, a possible view on ψ, equation 2, is a gra-
dient based usefulness measure such that a symbol utilised upstream by f to determine the answer
becomes a variable similar to how a group of pixels in an image contribute more to its classification.
Finally, one can argue that our model maintains a form of counterfactual thinking (Roese, 1997)
in which soft unification g creates counterfactuals on the invariant example to alter the output of f
towards the desired answer, equation 4. The question where Mary would have been if Mary had gone
to the garden instead of the kitchen is the process by which an invariant is learned through multiple
examples during training. This view relates to methods of causal inference (Pearl, 2019; Holland,
1986) in which counterfactuals are vital as demonstrated in structured models by Pearl (1999).
8	Conclusion
We presented a new approach for learning variables and lifting examples into invariants through
the usage of soft unification. Evaluating on four datasets, we analysed how Unification Networks
perform comparatively to existing similar architectures while having the benefit of lifting examples
into invariants that capture underlying patterns present in the tasks. Since our approach is end-to-
end differentiable, we plan to apply this technique to multi-modal tasks in order to yield multi-modal
invariants for example in visual question answering.
8
Under review as a conference paper at ICLR 2020
References
Amina Adadi and Mohammed Berrada. Peeking inside the black-box: A survey on explainable
artificial intelligence (XAI). IEEE Access, 6:52138-52160, 2018. doi: 10.1109∕access.2018.
2870052.
Sebastian Bach, Alexander Binder, Gregoire Montavon, Frederick KIaUschen, KIaUs-Robert Mller,
and Wojciech Samek. On pixel-wise explanations for non-linear classifier decisions by layer-
wise relevance propagation. PLOS ONE, 10(7):e0130140, JUly 2015. doi: 10.1371/joUrnal.pone.
0130140.
Dzmitry BahdanaU, KyUnghyUn Cho, and YoshUa Bengio. NeUral machine translation by jointly
learning to align and translate. ICLR, September 2015.
Krysia B. Broda, ArtUr S. D’Avila Garcez, and Dov M. Gabbay. Neural-Symbolic Learning Systems.
Springer London, 2002. ISBN 1852335122.
Aditya Chattopadhay, Anirban Sarkar, Prantik Howlader, and Vineeth N. BalasUbramanian. Grad-
CAM++: Generalized gradient-based visUal explanations for deep convolUtional networks. In
2018 IEEE Winter Conference on Applications of Computer Vision (WACV), pp. 839-847. IEEE,
IEEE, March 2018. doi: 10.1109/wacv.2018.00097.
Sneha ChaUdhari, GUngor Polatkan, Rohan Ramanath, and VarUn Mithal. An attentive sUrvey of
attention models. IJCAI, April 2019.
KyUnghyUn Cho, Bart van Merrienboer, Dzmitry BahdanaU, and YoshUa Bengio. On the properties
of neUral machine translation: Encoder-decoder approaches. In Proceedings of SSST-8, Eighth
Workshop on Syntax, Semantics and Structure in Statistical Translation. Association for CompU-
tational LingUistics, 2014. doi: 10.3115/v1/w14-4012.
NUri CingillioglU and Alessandra RUsso. Deeplogic: Towards end-to-end differentiable logical rea-
soning. AAAI-MAKE, May 2019.
Keith L. Clark. Negation as failUre. In Logic and Data Bases, pp. 293-322. Springer US, 1978. doi:
10.1007/978-1-4684-3384-5」L
Richard Evans and Edward Grefenstette. Learning explanatory rUles from noisy data. Journal of
Artificial Intelligence Research, 61:1-64, JanUary 2018. doi: 10.1613/jair.5714.
Gottlob Frege. Sense and reference. The Philosophical Review, 57(3):209, May 1948. doi: 10.2307/
2181485.
Joe L. Frost, Pei-San Brown, John A. SUtterby, and Candra D. Thornton. The Developmental Benefits
Of Playgrounds. Association for Childhood EdUcation International, 2004. ISBN 0871731649.
Alex Graves, Greg Wayne, and Ivo Danihelka. NeUral tUring machines. arXiv:1410.5401, 2014.
Alex Graves, Greg Wayne, Malcolm Reynolds, Tim Harley, Ivo Danihelka, Agnieszka Grabska-
Barwinska, Sergio Gomez Colmenarejo, Edward Grefenstette, Tiago Ramalho, John Agapiou,
Adria PUigdomeneCh Badia, Karl Moritz Hermann, Yori Zwols, Georg Ostrovski, Adam Cain,
Helen King, Christopher Summerfield, Phil Blunsom, Koray Kavukcuoglu, and Demis Hassabis.
Hybrid computing using a neural network with dynamic external memory. Nature, 538(7626):
471-476, October 2016. doi: 10.1038/nature20101.
Mikael Henaff, Jason Weston, Arthur Szlam, Antoine Bordes, and Yann LeCun. Tracking the world
state with recurrent entity networks. ICLR, 2017.
Paul W. Holland. Statistics and causal inference. Journal of the American Statistical Association,
81(396):945-960, December 1986. doi: 10.1080/01621459.1986.10478354.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. ICLR, 2015.
Ankit Kumar, Ozan Irsoy, Peter Ondruska, Mohit Iyyer, James Bradbury, Ishaan Gulrajani, Victor
Zhong, Romain Paulus, and Richard Socher. Ask me anything: Dynamic memory networks for
natural language processing. In ICML, pp. 1378-1387, 2016.
9
Under review as a conference paper at ICLR 2020
Richard L. Lewis. Cognitive modeling, symbolic. The MIT encyclopedia of the cognitive sciences,
pp. 525-527,1999.
Zachary C. Lipton. The mythos of model interpretability. Communications of the ACM, 61(10):
36-43, September 2018. doi: 10.1145/3233231.
Fei Liu and Julien Perez. Gated end-to-end memory networks. In Proceedings of the 15th Confer-
ence of the European Chapter of the Association for Computational Linguistics: Volume 1, Long
Papers, pp. 1-10. Association for Computational Linguistics, 2017. doi: 10.18653/v1/e17-1001.
Thang Luong, Hieu Pham, and Christopher D. Manning. Effective approaches to attention-based
neural machine translation. In Proceedings of the 2015 Conference on Empirical Methods in
Natural Language Processing. Association for Computational Linguistics, 2015. doi: 10.18653/
v1/d15-1166.
Tim Miller. Explanation in artificial intelligence: Insights from the social sciences. Artificial Intel-
ligence, 267:1-38, February 2019. doi: 10.1016/j.artint.2018.07.007.
Adam Morton and Jerry A. Fodor. The Language of Thought., volume 75. Philosophy Documenta-
tion Center, March 1978. doi: 10.2307/2025426.
Stephen Muggleton and Luc de Raedt. Inductive logic programming: Theory and methods.
The Journal of Logic Programming, 19-20:629-679, May 1994. doi: 10.1016/0743-1066(94)
90035-3.
Judea Pearl. Probabilities of causation: three counterfactual interpretations and their identification.
Synthese, 121(1-2):93-149, 1999.
Judea Pearl. The seven tools of causal inference with reflections on machine learning. Communica-
tions of the ACM, 62(3):54-60, February 2019. doi: 10.1145/3241036.
Jean Piaget. The Psychology of Intelligence. Routledge, August 2001. ISBN 0415254019.
John C. Reynolds. Transformational systems and algebraic structure of atomic formulas. Machine
intelligence, 5:135-151, 1970.
Tim Rocktschel and Sebastian Riedel. End-to-end differentiable proving. NIPS, pp. 3791-3803,
2017.
Neal J. Roese. Counterfactual thinking. Psychological Bulletin, 121(1):133-148, 1997. doi: 10.
1037/0033-2909.121.1.133.
Stuart Russell and Peter Norvig. Artificial Intelligence: A Modern Approach (3rd Edition). Pearson,
November 2016. ISBN 1292153962.
John R. Searle. Minds, brains, and programs. Behavioral and brain sciences, 3(3):417-424, 1980.
doi: 10.1016/b978-1-4832-1446-7.50007-8.
Ramprasaath R. Selvaraju, Michael Cogswell, Abhishek Das, Ramakrishna Vedantam, Devi Parikh,
and Dhruv Batra. Grad-CAM: Visual explanations from deep networks via gradient-based local-
ization. In 2017 IEEE International Conference on Computer Vision (ICCV), pp. 618-626. IEEE,
October 2017. doi: 10.1109/iccv.2017.74.
Minjoon Seo, Sewon Min, Ali Farhadi, and Hannaneh Hajishirzi. Query-reduction networks for
question answering. ICLR, 2017.
Ehud Y. Shapiro. Inductive inference of theories from facts. Yale University, Department of Com-
puter Science, 1981.
Gustav Sourek, Vojtech Aschenbrenner, Filip Zelezny, and Ondrej Kuzelka. Lifted relational neural
networks. arXiv:1508.05128, 2015.
Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, and Rob Fergus. End-to-end memory networks.
In NIPS, pp. 2440-2448, 2015.
10
Under review as a conference paper at ICLR 2020
Seiya Tokui, Kenta Oono, Shohei Hido, and Justin Clayton. Chainer: a next-generation open
source framework for deep learning. In Proceedings of Workshop on Machine Learning Systems
(LearningSys) in The Twenty-ninth Annual Conference on Neural Information Processing Sys-
tems (NIPS), 2015. URL http://learningsys.org/papers/LearningSys_2015_
paper_33.pdf.
J. Marshall Unger and Terrence W. Deacon. The Symbolic Species: The Co-Evolution of Language
and the Brain, volume 82. Wiley, 1998. doi: 10.2307/329984.
Jason Weston, Sumit Chopra, and Antoine Bordes. Memory networks. ICLR, 2015.
Jason Weston, Antoine Bordes, Sumit Chopra, Alexander M. Rush, Bart van Merrinboer, Armand
Joulin, and Tomas Mikolov. Towards ai-complete question answering: A set of prerequisite toy
tasks. ICLR, 2016.
Caiming Xiong, Stephen Merity, and Richard Socher. Dynamic memory networks for visual and
textual question answering. ICML,pp. 2397-2406, 20l6.
11
Under review as a conference paper at ICLR 2020
A Model Details
A.1 Unification MLP & CNN
Unification MLP (UMLP) To model f as a multi-layer perceptron, we take symbol embeddings of
size d = 16 and flatten sequences of length l = 4 into an input vector of size φ(k) ∈ R64. The
MLP consists of 2 hidden layers with tanh non-linearity of sizes 2d and d respectively. To process
the query, we concatenate the one-hot encoding of the task id to φ(k) yielding a final input of size
64 + 4 = 68. For unification features φU, we use a bi-directional GRU with hidden size d and
an initial state of 0. The hidden state at each symbol is taken with a linear transformation to give
φU (s) = WU Φ(s) where Φ(s) is the hidden state of the biGRU. The variable assignment is then
computed as an attention over the according to equation 3.
Unification CNN (UCNN) We take symbols embeddings of size d = 32 to obtain an input grid
φ(K) ∈ R3×3×32. Similar to UMLP, for each symbol we append the task id as a one-hot vector to
get an input of shape 3 × 3 × (32 + 4). Then f consists of 2 convolutional layers with d filters each,
kernel size of 3 and stride 1. We use relu non-linearity in between the layers. We pad the grid with
2 columns and 2 rows to a 5 × 5 such that the output of the convolutions yield again a hidden output
H ∈ R3×3×d of the same shape. As the final hidden output h, we take a global max pool to over H
to obtain h ∈ Rd . Unification function g is modelled identical to f without the max pooling such
that φU (Kij) = H0ij where H0 is the hidden output of the convolutional layers.
A.2 Unification Memory Networks
Unlike previous architectures, with UMN we interleave g into f. We use embedding sizes of d = 32
and model f with an iterative memory network. We take the final hidden state of a bi-directional
GRU, with initial state 0, ΦM to represent the sentences of the context C and query q in a d-
dimensional vector Mi = ΦM (Ci) and the query mq = ΦM (q). The initial state of the memory
network is h0 = mq . At each iteration j :
Aij = tanh(Wρ(Mi,hj) + b)	(6)
βj = softmax(W ΦA (Aj) + b)	(7)
where ΦA is another d-dimensional bi-directional GRU and ρ(x, y) = [x; y; x y; (x - y)2] with
the element-wise multiplication and [; ] the concatenation of vectors. Taking βj as the context
attention, we obtain the next state of the memory network:
hj+1 = Xβijtanh(Wρ(Mi,hj) +b)	(8)
and iterate J many times in advance. The final prediction becomes f(C, q) = softmax(W hJ +b).
All weight matrices W and bias vectors b are independent but are tied across iterations.
12
Under review as a conference paper at ICLR 2020
B Generated Dataset Samples
Table 4: Sample context, query and answer triples from sequences and grid tasks.
Dataset	Task	Context	Query	Answer
Sequence	i	1488	constant	2
Sequence	ii	6157	head	6
Sequence	iii	1837	tail	7
Sequence	iv	3563	duplicate	3
box	2
head	4
centre	7
corner	2
02200102000
02207067306
00840801085
ii
iii
id
Gr
id
Gr
Table 5: Training sizes for randomly generated fixed length sequences and grid tasks with 8 unique
symbols. The reason for Grid task (i) to be smaller is because there are at most 32 combinations of
2 × 2 boxes in a 3 × 3 grid with 8 unique symbols.
Task	Sequences	Grid
i	704.7 ± 12.8	25.6 ± 1.8
ii	709.4 ± 13.8	623.7 ± 14.1
iii	709.7 ± 14.0	768.2 ± 12.5
iv	624.8 ± 12.4	795.2 ± 10.3
13
Under review as a conference paper at ICLR 2020
C	Training Details
C.1 Unification MLP & CNN
Both unification models are trained on a 5-fold cross-validation over the generated datasets for 2000
iterations with a batch size of 64. We don’t use any weight decay and save the training and test
accuracies every 10 iterations, as presented in Figure 3.
C.2 Unification Memory Networks
We again use a batch size of 64 and pre-train f for 40 epochs then f together with g for 260 epochs.
We use epochs for UMN since the dataset sizes are fixed. To learn g alongside f, we combine error
signals from the unification of the invariant and the example. Following equation 4, the objective
function not only incorporates the negative log-likelihood Lnll of the answer but also the mean
squared error between intermediate states hjI and hjK at each iteration as an auxiliary loss:
J = Lnll(f(K), a) + λU
1J
Lniι(f ◦ g(I, K), a) + J £(h，i - hK)2 + Tf Ψw (S)
j=1	s∈S
(9)
We pre-train by setting λU = 0 for 40 epochs and then set λU = 1. For strong supervision we also
compute the negative log-likelihood Lnll for the context attention βj , described in Appendix A, at
each iteration using the supporting facts of the tasks. We apply a dropout of 0.1 for all recurrent
neural networks used and only for the bAbI dataset weight decay with 0.001 as the coefficient.
14
Under review as a conference paper at ICLR 2020
D Further Results
Figure 6:	Results of Unification MLP and CNN on increasing number of invariants. There is no
impact on performance when more invariants per task are given. Upon closer inspection, we noticed
the models ignore the extra invariants and only use 1. We speculate the regularisation ψ encourages
the models to use a single 1 invariant.
Table 6: Individual task error rates on bAbI tasks for Unification Memory Networks.
Supervision # Invs Training Size	Weak I		1 1k	Strong 3 1k	3 50
	1 1k	3 1k			
1	0.0	0.0	0.0	0.0	1.4
2	65.6	63.1	0.3	0.7	30.0
3	67.1	62.6	1.0	2.4	39.8
4	0.0	0.0	0.0	0.0	37.0
5	3.4	4.0	0.8	1.1	26.5
6	0.2	0.6	0.0	0.0	18.4
7	22.0	22.8	10.7	11.3	22.8
8	10.3	8.5	7.4	7.6	24.7
9	0.1	25.7	0.0	0.0	33.8
10	0.1	2.0	0.0	0.3	32.6
11	0.0	0.0	0.0	0.0	11.9
12	0.0	0.1	0.0	0.0	21.3
13	2.1	3.7	0.0	0.1	5.8
14	19.7	13.5	0.5	0.1	54.8
15	0.0	0.7	0.0	0.0	0.0
16	55.2	56.2	0.0	0.0	39.7
17	39.2	49.0	51.1	49.3	48.8
18	4.4	8.0	0.6	0.5	10.4
19	91.8	89.6	53.9	46.7	90.2
20	0.0	0.0	0.0	0.0	2.7
Mean	19.1	20.5	6.3	6.0	27.6
Std	27.9	27.0	15.6	14.3	21.0
#> 5%	8	10	4	4	17
15
Under review as a conference paper at ICLR 2020
Table 7: Comparison of individual task error rates (%) on the bAbI (Weston et al., 2016) dataset
of the best run. We preferred 1k results if a model had experiments published on both 1k and 10k
for data efficiency. References from left to right: (Sukhbaatar et al., 2015) - (Liu & Perez, 2017) -
(Henaff et al., 2017) - (Seo et al., 2017) - Ours - (Xiong et al., 2016) - (Graves et al., 2016) - (Weston
et al., 2015) - Ours - (Kumar et al., 2016)
Support				Weak			I	I	Strong	
Size			1k		I	I	10k	I	I	1k	10k
Model	N2N	GN2N	EntNet	QRN	UMN	DMN+	DNC	MemN	N UMN	DMN
1	0.0	0.0	0.7	0.0	0.0	0.0	0.0	0.0	0.0	0.0
2	8.3	8.1	56.4	0.5	65.6	0.3	0.4	0.0	0.7	1.8
3	40.3	38.8	69.7	1.2	67.1	1.1	1.8	0.0	2.4	4.8
4	2.8	0.4	1.4	0.7	0.0	0.0	0.0	0.0	0.0	0.0
5	13.1	1.0	4.6	1.2	3.4	0.5	0.8	2.0	1.1	0.7
6	7.6	8.4	30.0	1.2	0.2	0.0	0.0	0.0	0.0	0.0
7	17.3	17.8	22.3	9.4	22.0	2.4	0.6	15.0	11.3	3.1
8	10.0	12.5	19.2	3.7	10.3	0.0	0.3	9.0	7.6	3.5
9	13.2	10.7	31.5	0.0	0.1	0.0	0.2	0.0	0.0	0.0
10	15.1	16.5	15.6	0.0	0.1	0.0	0.2	2.0	0.3	2.5
11	0.9	0.0	8.0	0.0	0.0	0.0	0.0	0.0	0.0	0.1
12	0.2	0.0	0.8	0.0	0.0	0.0	0.0	0.0	0.0	0.0
13	0.4	0.0	9.0	0.3	2.1	0.0	0.1	0.0	0.1	0.2
14	1.7	1.2	62.9	3.8	19.7	0.2	0.4	1.0	0.1	0.0
15	0.0	0.0	57.8	0.0	0.0	0.0	0.0	0.0	0.0	0.0
16	1.3	0.1	53.2	53.4	55.2	45.3	55.1	0.0	0.0	0.6
17	51.0	41.7	46.4	51.8	39.2	4.2	12.0	35.0	49.3	40.6
18	11.1	9.2	8.8	8.8	4.4	2.1	0.8	5.0	0.5	4.7
19	82.8	88.5	90.4	90.7	91.8	0.0	3.9	64.0	46.7	65.5
20	0.0	0.0	2.6	0.3	0.0	0.0	0.0	0.0	0.0	0.0
Mean	13.9	12.7	29.6	11.3	19.1	2.8	3.8	6.7	6.0	6.4
#> 5%	11	10	15	5	8	1	2	4	4	2
Table 8: Individual task error rates (%) on the logical reasoning dataset.
Size			1k				10k			50	20k	
Support	Weak		I Strong		Weak			Strong			Weak	
Arity	1	2	1	2	1	2	1	2	2	2	2	2
# Invs / Model	1	3	1	3	1	3	1	1	3	3	DMN	IMA
Facts	1.2	0.9	0.0	0.4	0.0	0.0	0.0	0.0	0.0	33.5	0.0	0.0
Unification	0.0	10.3	0.0	10.8	0.0	0.0	0.0	0.0	0.0	41.3	13.0	10.0
1 Step	50.3	49.8	4.4	20.0	1.2	27.8	0.1	1.3	5.7	50.2	26.0	2.0
2 Steps	47.5	50.0	5.7	35.0	37.2	47.8	0.0	29.7	28.7	49.9	33.0	5.0
3 Steps	47.6	49.2	10.4	38.7	39.6	45.6	0.0	26.0	26.1	48.3	23.0	6.0
AND	31.3	37.4	10.7	16.4	29.8	29.0	0.2	0.4	1.2	50.0	20.0	5.0
OR	25.2	38.1	21.0	35.0	20.5	30.2	4.4	20.6	17.4	47.6	13.0	3.0
Transitivity		50.0		26.6		39.6		5.0	6.0	49.2	50.0	50.0
1 Step NBF	46.4	38.7	3.8	28.8	1.1	21.6	0.1	1.1	8.0	47.6	21.0	2.0
2 Steps NBF	48.5	48.9	7.7	39.6	30.4	48.2	0.1	33.4	28.7	50.3	15.0	4.0
AND NBF	51.0	50.1	43.1	48.6	29.4	44.2	0.1	1.3	40.1	49.5	16.0	8.0
OR NBF	51.4	48.4	50.8	47.3	47.6	47.8	21.3	27.6	30.5	47.3	25.0	14.0
Mean	36.4	39.3	14.3	28.9	21.5	31.8	2.4	12.2	16.0	47.1	21.2	9.1
Std	18.7	15.9	16.4	14.1	17.1	16.7	6.1	13.2	13.6	4.7	12.3	13.4
#> 5%	9	11	7	11	7	10	1	5	9	12	11	5
16
Under review as a conference paper at ICLR 2020
Xsandra went back to the Y:bathroom
is X:sandra in the Y:bathroom
yes
Figure 7:	bAbI task 6, yes or no questions. The invariant does not variablise the answer.
X:m( Y:e)
X:a ( Y:w , Z:e )
X:m ( T )
X:X (A) — not Z:q (A)
' X:m ( Y:e)
` X:a ( Y:w , Z:e )
` X:m ( c )
' X:x ( Y:z )
Figure 8:	Invariants learned on tasks 1, 2 and 11 with arity 1 and 2 from the logical reasoning dataset.
Last invariant on task 11 lifts the example around the negation by failure, denoted as not, capturing
its semantics.
3X7 Y head
74XY head
X3 1X tail
XX 5 Y duplicate
X00	0Y0	64Y
010	1X8	0X8
00Y	020	007
head	centre	corner
(a) Invariants with extra varialbes learned with UMLP. (b) Mismatching invariants learned with UCNN.
Figure 9:	Invariants learned that do not match the data generating distribution from UMLP and
UCNN using ≤ 1000 examples to train. In these instances the unification still bind to the the correct
symbols in order to predict the desired answer; quantitatively we get the same results. Variable
default symbols are omitted for clarity.
(a) bAbI task 2. When a variable
is unused in the next iteration, e.g.
Z:football, it unifies with random
tokens often biased by position.
(b) Logical reasoning task 1. A
one-to-one alignment is created be-
tween predicates and constants.
(c) Logical reasoning task 3. Arity
1 atom forced to bind with arity 2
creates a one-to-many mapping.
Figure 10:	Further attention maps for equation 3, darker cells indicate higher attention values.
17