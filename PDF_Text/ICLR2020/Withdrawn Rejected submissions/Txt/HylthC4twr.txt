Under review as a conference paper at ICLR 2020
Frequency Analysis for Graph Convolution
Network
Anonymous authors
Paper under double-blind review
Ab stract
In this work, we develop quantitative results to the learnability of a two-layers
Graph Convolutional Network (GCN). Instead of analyzing GCN under some
classes of functions, our approach provides a quantitative gap between a two-layers
GCN and a two-layers MLP model. Our analysis is based on the graph signal
processing (GSP) approach, which can provide much more useful insights than
the message-passing computational model. Interestingly, based on our analysis,
we have been able to empirically demonstrate a few cases when GCN and other
state-of-the-art models cannot learn even when true vertex features are extremely
low-dimensional. To demonstrate our theoretical findings and propose a solution
to the aforementioned adversarial cases, we build a proof of concept graph neural
network model with stacked filters named Graph Filters Neural Network (gfNN).
1	Introduction
Graph neural networks (GNN) is a class of neural networks which can learn from graph-structured
data. Recently, graph neural networks for vertex classification and graph isomorphism test have
achieved excellent results on several benchmark datasets and continuously set new state-of-the-art
performance (KiPf and Welling, 2017; Velickovic et al., 2019; Wu et al., 2019; KlicPera et al., 2019).
Many variants of GNN have been proposed to solve problems in social networks (Hamilton et al.,
2017; Zhang et al., 2018a), biology (VeIickOvic et al., 2017; 2019), chemistry (FOut et al., 2017;
Gilmer et al., 2017), natural language Processing (Bastings et al., 2017; Zhang et al., 2018b; Wu
et al., 2019), reasoning for vision (Santoro et al., 2017), and few/zero-shot learning (Garcia and
Bruna, 2017; KamPffmeyer et al., 2019). Due to the rise of GNNs in machine learning aPPlications,
understanding GNNs theoretically has gathered lots of attention in the machine learning community.
While most theoretical results of GNNs are based on the message-Passing model (Xu et al., 2019;
Keriven and Peyre, 2019), there are a limited number of theoretical results for the filtering approach.
However, in Practice, the graPh filtering view have insPired many comPutationally fast and high accu-
racy models such as ChebNet (Defferrard et al., 2016), GCN (Kipf and Welling, 2017), SplineConv
(Fey et al., 2018), LanczosNet (Liao et al., 2019), and label efficient models (Li et al., 2019). In this
work, we theoretically study the GCN model (Kipf and Welling, 2017) and the SGC model (Wu et al.,
2019). Instead of showing which class of function a GCN or GNN model can theoretically learn,
we develop quantitative bounds for the gaps between GCN/SGC and a two-layers fully connected
neural network. Our theoretical results imply a few cases where SGC and GCN would fail to work:
high-frequency labels, noisy features, and complex features. Interestingly, we also find other state-
of-the-art GNN models such as GraphSAGE Hamilton et al. (2017) or DGI Velickovic et al. (2019)
failed to perform in our high-frequency labels experiments.
Recently, Wu et al. (2019) showed that graph convolutional networks (GCN) can be broken down
into two steps: low-pass filtering and feature learning. Such simplification not only improves GCN’s
computational speed and accuracy in a wide range of problems but also allows a better understanding
of the GCN model. To show the low-pass filtering nature of GCN-like models, Wu et al. (2019)
used the Rayleigh quotient to bound the maximum eigenvalue when self-loops are added to the
graph, which means adding self-loops created a stronger low-pass filter (Wu et al., 2019, Lemma 3,
Theorem 1). Similar low-pass observation and results have also been mentioned by other works by Li
et al. (2018), Qiu et al. (2018), and Li et al. (2019). We adopt SGC’s two steps simplification and
1
Under review as a conference paper at ICLR 2020
Figure 1: Accuracy by frequency components
GCN
Figure 2: A simple realization of gfNN
the graph signal processing perspective (Ortega et al., 2018) to our work and further extend their
implications to demonstrate when GCN or SGC does not perform well.
We claim the following contributions:
•	Our first contribution is another proof for (Wu et al., 2019, Theorem 1) using the Courant-
Fisher-Weyl’s min-max principle. Our result (Theorem 3, Section 4) has the advantage of
showing the monotone shrinking of all eigenvalues. In addtion, our proof on generalized
eigenvalues is simpler and shorter.
•	Our second and main contribution is the exploration of cases when SGC or GCN fails to
work and the following performance gap Theorem:
Theorem 1 (Informal, see Theorem 7, 8). Under Assumption 2, the outcomes of SGC, GCN,
and gfNN are similar to those of the corresponding NNs using “true features”.
•	Our third contribution is to empirically verify Assumption 2 since our Theorem 7 and 8 are
based on this assumption (stated below).
Assumption 2. Input features consist of frequency-limited true features and noise. The true features
have sufficient information for the machine learning task.
As a base model for analysis, we build a proof of concept model named gfNN (Figure 2). This model
adopts the two steps simplification from SGC with two major differences: 1. We use a two-layers
MLP as the classifier; and 2. We use two different filters (low-pass and high-pass). Our theorem 7
implies that, under Assumption 2, both gfNN (with appropriate filter) and GCN Kipf and Welling
(2017) have similar high performance. Since gfNN does not require multiplications of the adjacency
matrix during the learning phase, it is much faster than GCN. Besides, gfNN maintains an expected
behavior in the aforementioned cases when other GNN models do not work.
2	Graph Signal Processing
Graph signal processing (GSP) regards data on the vertices as signals and applies signal processing
techniques to understand the signal characteristics. By combining signals (feature vectors) and graph
structure (adjacency matrix or its transformations), GSP has inspired the development of learning
algorithms on graph-structured data Shuman et al. (2012). In a standard signal processing problem,
it is common to assume the observations contain some noise and the underlying “true signal” has
low-frequency Rabiner and Gold (1975). Our Assumption 2 is of similar nature.
Many recent GNNs were built upon results from graph signal processing. The most common practice
is to multiply the (augmented) normalized adjacency matrix I - L with the feature matrix X . The
product (I - L)X is understood as features averaging and propagation. In graph signal processing
literature, such operation filters signals on the graph without explicitly performing eigendecomposition
on the normalized Laplacian matrix, which requires O(n3) time Vaseghi (2008). Here, we refer to
this augmented normalized adjacency matrix and its variants as graph filters and propagation matrices
interchangeably.
In this section, we introduce the basic concepts of graph signal processing. We adopt a recent
formulation Girault et al. (2018) of graph Fourier transform on irregular graphs.
2
Under review as a conference paper at ICLR 2020
Let G = (V, E) be a simple undirected graph, where V = {1, . . . , n} be the set of n ∈ Z
vertices and E be the set of edges.1 Let A = (aij ) ∈ Rn×n be the adjacency matrix of G,
D = diag(d(1), . . . , d(n)) ∈ Rn×n be the degree matrix of G, where d(i) = Pj∈V a(i, j)
is the degree of vertex i ∈ V . L = D - A ∈ Rn×n be the combinatorial Laplacian of G,
L = I - D-1/2AD-1/2 be the normalized Laplacian of G, where I ∈ Rn×n is the identity matrix,
and Lrw = I-D-IA be the random walk Laplacian of G. Also, for Y ∈ R with Y > 0, let A = A+γI
be the augmented adjacency matrix, which is obtained by adding Y self loops to G, D = D + YI
be the corresponding augmented degree matrix, and L = D — A = L, L = I — D-1/2AD-1/2,
Lrw = I - D-1A be the corresponding augmented combinatorial, normalized, and random walk
Laplacian matrices.
A vector x ∈ Rn defined on the vertices of the graph is called a graph signal. To introduce a graph
Fourier transform, we need to define two operations, variation and inner product, on the space of
graph signals. Here, we define the variation ∆ : Rn → R and the D-inner product by
∆(χ) := X (χ(i) — x(j))2 = x>Lx; (x,y)D := X(d(i)+ γ)χ(i)y(i) = x>Dy.	(1)
(i,j)∈E	i∈V
We denote by IlxkD := a∕(x,x)d the norm induced by D. Intuitively, the variation ∆ and the inner
product (∙, ∙)d specify how to measure the smoothness and importance of the signal, respectively. In
particular, our inner product puts more importance on high-degree vertices, where larger Y closes
the importance more uniformly. We then consider the generalized eigenvalue problem (variational
form): Find u1 , . . . , un ∈ Rn such that for each i ∈ {1, . . . , n}, ui is a solution to the following
optimization problem:
minimize ∆(u) subject to (u,u) D = 1, (u,uj )力 =0, j ∈{1,...,n}.	(2)
The solution ui is called an i-th generalized eigenvector and the corresponding objective value
λi := ∆(ui) is called the i-th generalized eigenvalue. The generalized eigenvalues and eigenvectors
are also the solutions to the following generalized eigenvalue problem (equation form):
Lu = λD u.	(3)
Thus, if (λ, u) is a generalized eigenpair then (λ, D1/2u) is an eigenpair of L. A generalized
eigenvector with a smaller generalized eigenvalue is smoother in terms of the variation ∆. Hence, the
generalized eigenvalues are referred to as the frequency of the graph.
The graph Fourier transform is a basis expansion by the generalized eigenvectors. Let U =
[u1, . . . , un] be the matrix whose columns are the generalized eigenvectors. Then, the graph Fourier
transform F: Rn → Rn is defined by Fx = x := U>Dx, and the inverse graph Fourier trans-
form F-1 is defined by F-1X =UX. Note that these are actually the inverse transforms since
FF T = U >D U = I.
The Parseval identity relates the norms of the data and its Fourier transform:
llxkD = ιιχk2.	⑷
Let h : R → R be an analytic function. The graph filter specified by h is a mapping x 7→ y defined
by the relation in the frequency domain: y(λ) = h(λ)x(λ). In the spatial domain, the above equation
is equivalent to y = h(Lrw)x. where h(Lrw) is defined via the Taylor expansion of h; see Higham
(2008) for the detail of matrix functions.
In a machine learning problem on a graph, each vertex i ∈ V has a d-dimensional feature x(i) ∈ Rd.
We regard the features as d graph signals and define the graph Fourier transform of the features by
the graph Fourier transform of each signal. Let X = [x(1); . . . , x(n)]> be the feature matrix. Then,
.1	1	1 ■	∙	Γ∙	♦	.	1 1	-Γ~ ^∖7^	ST	T T^Γ 7^Λ1.1	.	Γ∙	♦
the graph Fourier transform is represented by FX = X =: U>DX and the inverse transform is
F1X = UX. We denote X = [x(λι);...; x(λn)] 1 as the frequency components of X.
1We only consider unweighted edges but it is easily adopted to positively weighted edges.
3
Under review as a conference paper at ICLR 2020
3 Empirical Evidence of Assumption 2
The results of this paper deeply depend on Assumption 2. Thus, we first verify this assumption in
real-world datasets: Cora, Citeseer, and Pubmed Sen et al. (2008). These are citation networks, in
which vertices are scientific papers and edges are citations. We consider the following experimental
setting: 1. Compute the graph Fourier basis U from L; 2. Add Gaussian noise to the input features:
X — X + N(0, σ2) for σ = {0,0.01,0.05}; 3. Compute the first k-frequency component: Xk =
U[: k]>D1/2X; 4. Reconstruct the features: Xk = DD-1/2U[: k]Xk; 5. Train and report test accuracy
of a 2-layers perceptron on the reconstructed features Xk. Figure 1 plots a fine-grained frequency
components experiment on Cora without early stopping.
Noise (。)：	0.0 0.01 0.05
Figure 3: Average performance of 2-layers MLPs on frequency-limited feature vectors with early stop-
ping using the validation data (max_epochs=5 00). The two horizontal lines show the performance
of our model and a 2-layers MLP on original feature.
In Figure 3, we incrementally add normalized Laplacian frequency components to reconstruct feature
vectors and train a 2-layers MLPs. We see that all three datasets exhibit a low-frequency nature.
The classification accuracy of a 2-layers MLP tends to peak within the top 20% of the spectrum
(green boxes). By adding artificial Gaussian noise, we observe that the performance at low-frequency
regions is relatively robust, which implies a considerable denoising effect2.
These experiments have confirmed our assumption that the informative features (to a given set of
labels) lie in a low-frequency region in the three benchmark datasets. Note that such low-frequency
nature, while coincides with low intrinsic dimensionality, has different behavior. For instance, we
will show later that despite having a low intrinsic dimensionality, high-frequency sets of features
and labels lead to a bad performance in both GCN and SGC. Interestingly, we observe the same
performance degradation in other message-passing models like GraphSAGE (Hamilton et al., 2017).
We further confirm the low-frequency nature of the benchmark datasets’ labels by computing the
Rayleigh quotient for each label type in the dataset. Note that our Laplacian is normalized, the
maximum value of Rayleigh quotient (corresponds to the highest eigenvalue) is 2. Figure 4 clearly
shows the low-frequency nature of the labels in Cora, Citeseer, Pubmed, and Reddit datasets.
4	Multiplying Adjacency Matrix is Low Pass Filtering
Computing the low-frequency components is expensive since it requires O(|V |3) time to compute the
eigenvalue decomposition of the Laplacian matrix. Thus, a reasonable alternative is to use a low-pass
filter. Many papers on graph neural networks iteratively multiply the (augmented) adjacency matrix
Arw (or A) to propagate information. In this section, we see that this operation corresponds to a
low-pass filter.
As proven in previous work, multiplying the normalized adjacency matrix corresponds to applying
graph filter h(λ) = 1 - λ (Wu et al., 2019; Li et al., 2018; 2019). Since the eigenvalues of
the normalized Laplacian lie on the interval [0, 2], this operation resembles a band-stop filter that
removes intermediate frequency components. However, since the maximum eigenvalue of the
normalized Laplacian is 2 if and only if the graph contains a non-trivial bipartite graph as a connected
component (Chung, 1997, Lemma 1.7). Therefore, for other graphs, multiplying the normalized
2The standard deviation of clean signal is less than 0.01 for all three datasets. See Table 2 for more detail.
4
Under review as a conference paper at ICLR 2020
tneitouq hgielyaR tneitouq hgielya
reddit
Label id
Figure 4: Rayleigh quotients of one-hot encoded label vectors for Cora, Citeseer, Pubmed, and Reddit
(non-augmented) adjacency matrix acts as a low-pass filter (i.e., high-frequency components must
decrease). We can increase the low-pass filtering effect by adding self-loops (i.e., considering the
augmented adjacency matrix) since it shrinks the eigenvalues toward zero as follows.3
Theorem 3. Let λi (γ) be the i-th smallest generalized eigenvalue of (D, L) = (D + γI). Then,
λi (γ) is a non-negative number, and monotonically non-increasing in γ ≥ 0. Moreover, λi (γ) is
strictly monotonically decreasing if λi(0) 6= 0.
Note that γ cannot be too large. Otherwise, all the eigenvalues would be concentrated around zero,
i.e., all the data would be regarded as “low-frequency”; hence, we cannot extract useful information
from the low-frequency components. In practice, γ is often set at 1 (Kipf and Welling, 2017).
From another point of view, the graph filter h(λ) = 1 - λ can also be derived from a first-order
approximation of a Laplacian regularized least squares Belkin and Niyogi (2004). Let us consider
the problem of estimating a low-frequency true feature {x(i)}i∈v from the observation {x(i)}i∈v.
Then, a natural optimization problem is given by
mxin χ ι∣χ(i) -X⑺kD+δ(X)	⑸
i∈V
where ∆(X) = Pd=I ∆(X(i)p). Note that, since ∆(X) = Pλ∈Λ λ∣X(λ)∣2, it is a maximum a
posteriori estimation with the prior distribution of X(λ)〜N(0,I∕λ). The optimal solution to this
problem is given by X = (I + L 1w)-1X. The corresponding filter is h0(λ) = (1 + λ)-1, and hence
h(λ) = 1 - λ is its first-order Taylor approximation.
5	Bias-Variance Trade- off for Low Pass Filters
In the rest of this paper, we establish theoretical results under Assumption 2. To be concrete, we pose
a more precise assumption as follows.
Assumption 4 (Precise Version of the First Part of Assumption 2). Observed features {X(i)}i∈V
consists of true features {X(i)}i∈v and noise {z(i)}i∈v. The true features X have frequency at
most 0 ≤	1 and the noise follows a white Gaussian noise, i.e., each entry of the graph Fourier
transform of Z independently identically follows a normal distribution N(0, σ2 ).
Using this assumption, we can evaluate the effect of the low-pass filter as follows.
Lemma 5. Suppose Assumption 4. For any 0 < δ < 1/2, with probability at least 1 - δ, we have
kX - AkwXkD ≤ √⅛XkD + O (Plog(1∕δ)R(2k)) E[kZId],	⑹ 3
3The shrinking of the maximum eigenvalue has already been proved in (Wu et al., 2019, Theorem 1). Our
theorem is stronger than theirs since we show the “monotone shrinking” of “all” the eigenvalues. In addition,
our proof is simpler and shorter.
5
Under review as a conference paper at ICLR 2020
where R(2k) is a probability that a random walk with a random initial vertex returns to the initial
vertex after 2k steps.
The first and second terms of the right-hand side of equation 6 are the bias term incurred by applying
the filter and the variance term incurred from the filtered noise, respectively. Under the assumption,
the bias increases a little, say, O(√e). The variance term decreases in O(1∕degk/2) where deg is a
typical degree of the graph since R(2k) typically behaves like O(1/degk) for small k.4 Therefore,
we can obtain a more accurate estimation of the true data from the noisy observation by multiplying
the adjacency matrix if the maximum frequency of X is much smaller than the noise-to-signal ratio
kZ kD/kXkD.
This theorem also suggest a choice of k. By minimizing the right-hand side by k, we obtain:
Corollary 6. Suppose that E[∖∖Z∣∣d] ≤ PkX∣∣d for some P = O(1). Let k be defined by k =
O(log(log(1∕δ)ρ∕e)), andsuppose that there exist constants Cd and d > 1 such that R(2k) ≤ Cd/dk
for k ≤ k. Then, by choosing k = k, the right-hand side ofequatιon 6 is O(√e).5	□
This concludes that we can obtain an estimation of the true features with accuracy O(√e) by
multiplying Arw several times.
6 Graph Filter Neural Network
In the previous section, we see that low-pass filtered features AkWX are accurate estimations of the
true features with high probability. In this section, we analyze the performance of this operation. In
practice, k = 2 is sufficient for most datasets. Therefore, for simplicity, we set k = 2.
Let the multi-layer (two-layer) perceptron be
hMLP(X|W1,W2) = σ2(σ1(XW1)W2),	(7)
where σ1 is the entry-wise ReLU function, and σ2 is the softmax function. Note that both σ1 and σ2
are contraction maps, i.e., kσi(X) - σ(Y )kD ≤ kX - Y kD.
gfNN As a toy model for analysis and experiments, we define our gfNN models. It comes with
two flavors: low-frequency and high-frequency. In this section, we provide the analysis for the
low-frequency version and emprical results (Section 7) for high-frequency version.
hgfNN-low(X,A∣W1,W2) = hMLP(A2wX|Wl,W2)	(8)
hgfNN-high(X,A∣Wι, W2) = hMLP(L2wX|Wl, W2)	(9)
Under the second part of Assumption 2, our goal is to obtain a result similar to h(X | Wι, W2). The
simplest approach is to train a multi-layer perceptron hMLP(X|W1, W2) with the observed feature.
The performance of this approach is evaluated by
Mmlp(XW1,W2)- Amlp(X∣W1,W2)∣∣D ≤ ∖Z∣dP(WI)P(W2),	(10)
where P(W ) is the maximum singular value of W .
Now, we consider applying graph a filter Akw to the features, then learning with a multi-layer
perceptron, i.e., hMLP(h(Lrw)X|W1, W2). Using Lemma 5, we obtain the following result.
Theorem 7.	Suppose Assumption 4 and conditions in Corollary 6. By choosing k as Corollary 6,
with probability at least 1 - δfor δ < 1/2,
khMLP(X∣Wι, W2) - hMLP(.4X∣Wι, W2)kD = O(√1)E[kZ∣∣D]ρ(W1)ρ(W2).	(11)
This means that if the maximum frequency of the true data is small, we obtain a solution similar to
the optimal one.
4This exactly holds for a class of locally tree-like graphs Dembo et al. (2013), which includes Erdos-Renyi
random graphs and the configuration models.
5O(∙) suppresses logarithmic dependencies.
6
Under review as a conference paper at ICLR 2020
Comparison with GCN Under the same assumption, we can analyze the performance of a two-
layers GCN. The GCN is given by
. . . .≈ . ≈ . .
hGCN(X ∣W1,W2) = σ2 (Arw σ1(ArwXW1)W2).	(12)
Theorem 8.	Under the same assumption to Theorem 7, we have
khMLP(X∣W1,W2) - hGCN(X∣W1,W2)kD ≤ O(√)E[∣∣Z∣∣d]ρ(W1)ρ(W2).	(13)
This theorem means that GCN also has a performance similar to MLP for true features. Hence, in the
limit of → 0 and Z → 0, all MLP, GCN, and the gfNN have the same performance.
In practice, gfNN has two advantages over GCN. First, gfNN is faster than GCN since it does not use
the graph during the training. Second, GCN has a risk of overfitting to the noise. When the noise is
so large that it cannot be reduced by the first-order low-pass filter, Arw, the inner weight W1 is trained
using noisy features, which would overfit to the noise leading to low test accuracy.
Comparison with SGC Recall that a degree-2 SGC is given by
hsGc(X∣Wι)= σ2(A2wXW2),	(14)
i.e., it is a gfNN with a one-layer perceptron. Thus, by the same discussion, SGC has a performance
similar to the perceptron (instead of the MLP) applied to the true feature. This clarifies an issue of
SGc: if the true features are non-linearly separable, SGc cannot learn the correct function.
7 Experiments
We first show the advantage of models like gfNN-low and SGc over GcN by injecting Gaussian
noise to the three benchmark citation networks. In accordance with Theorem 8, we see that GcN-like
models have low noise tolerance while gfNN-low and SGc are much more robust. Our experiments
on citation networks are conducted in the same transductive setting used by Kipf and Welling (2017)
and Wu et al. (2019). Training details are provided in Appendix B and c.
Experimental results in Figure 5 confirms our hypothesis for the three benchmark datasets. We see that
when a high level of noise is injected to low-frequency datasets (especially cora), the performance of
GcN can degrade much faster than SGc or gfNN. It is also trivial to see that Logistic Regression
(LG) and MLP on raw features exhibit similar behavior when noise is introduced.
Noise (σ)	Noise (σ)	Noise (σ)
Figure 5: Benchmark test accuracy on cora (left), citeseer (middle), and Pubmed (right) datasets.
The noise level is measured by standard deviation of white noise added to the features.
Next, we experiment on two synthetic datasets: Two circles and BA-High. These datasets are
synthesized to show: 1. SGc cannot learn non-linearly separable features; and 2. SGc, GcN, DGI
(VelickoVic et al., 2019), and GraphSAGE (Hamilton et al., 2017) fail When it comes to high-frequency
labels (even when the features are informative). Two circles dataset is generated by generating 4, 000
points sampled from two nested circles and define a 5-nearest neighbors graph on the data points.
Visualization of this dataset is giVen in Appendix E. We generate BA-High dataset by constructing
a BA-graph with n = 200 and n = 10 (200 nodes, eVery new node are attached to 10 neighbors
7
Under review as a conference paper at ICLR 2020
selected from existing nodes). We then find the maximal independent set for the graph and use this set
as label 1. The rest of the nodes are label 0. For each node with label 1, we generate a 50-dimensions
feature vector from a Gaussian N (+, 1.0). We do the same for all nodes with label 0 but with
Gaussian N (-, 1.0). In Table 1 we report the results at = 0.5.
Unsurprisingly, SGC cannot learn the non-linearly separable feature in the Two Circle experiment
(Table 1) while other more complex models perform as expected (similar performance as an MLP).
More interesting is the results of the BA-High experiment (Table 1, Figure 6). Surprisingly, we find
all popular GNN models cannot quite learn under this simple setting. Although the node features
are informative (a simple LogReg or MLP can have accuracy larger than 90%), most GNN models
reported less than 60% accuracy. In Figure 6, we show a simple solution to this setting: Use high
frequency eigenvectors or high-pass filter (gfNN-High).
Figure 6: Performance on high-frequency labels
For comparison purpose, we present our results on benchmark datasets in Table 1. Model details are
presented in Appendix C. Dataset details are presented in Table 2 (Appendix E).
Table 1: Average test accuracy on original train/val/test splits (50 times)
	Cora	Citeseer Pubmed Reddit	PPI	2Circles BA-High
DGI GCN SGC	83.1 ± 0.2	72.1 ± 0.1	80.1 ± 0.2	94.5 ± 0.3	99.2 ± 0.1	85.2 ± 0.6	54.6 ± 1.8 80.0 ± 1.8	69.6 ± 1.1	79.3 ± 1.3	-	-	84.9 ± 0.8	58.9 ± 2.2 77.6 ± 2.2	65.6 ± 0.1	78.4 ± 1.1	94.9 ± 0.2	89.0 ± 0.1	53.5 ± 1.4	55.5 ± 1.3
gfNN-low gfNN-high	82.3 ± 0.2	71.8 ± 0.1	79.2 ± 0.2	94.8 ± 0.2	89.3 ± 0.5	85.6 ± 0.8	55.4 ± 2.3 24.2 ± 1.9	22.5 ± 2.2	43.6 ± 1.3	10.5 ± 2.6	86.6 ± 0.1	48.3 ± 3.5	96.2 ± 1.0
8 Discussion
Recently, Kampffmeyer et al. (2019) observed that GCN models might have too strong Laplacian
smoothing effect (low-frequency in our terms) for zero-shot learning application. This is an example
of an application where the frequency of data might be band-limited or higher than benchmark
graph datasets. Some other possible scenario in a social network might include more complex and
high-frequency nature that GNN models like GCN cannot learn well. One possible solution to this
scenario is to use both low- and high-pass filters like gfNN and select the model by validation data or
learn from both filters.
Our analysis and experimental results showed that GNN models work well on benchmark datasets
because these datasets have the low-frequency nature in both feature vectors and labels. With high-
frequency labels, popular GNN models will perform badly. While there is not yet any real-world
benchmark dataset which node labels are of high-frequency nature, such setting is not entirely
impossible given the complexity of a network. For instance, a relationship network would be less
likely to have same-gender links. Therefore, gender labels might exhibit high-frequency nature.
8
Under review as a conference paper at ICLR 2020
References
Joost Bastings, Ivan Titov, Wilker Aziz, Diego Marcheggiani, and Khalil Sima’an. Graph convo-
lutional encoders for syntax-aware neural machine translation. Empirical Methods in Natural
Language Processing, 2017.
Mikhail Belkin and Partha Niyogi. Semi-supervised learning on riemannian manifolds. Machine
Learning, 56(1-3):209-239, 2004.
Rajendra Bhatia. Matrix analysis, volume 169. Springer Science & Business Media, 2013.
Jie Chen, Tengfei Ma, and Cao Xiao. Fastgcn: Fast learning with graph convolutional networks via
importance sampling. International Conference on Learning Representations, 2018.
Fan R.K. Chung. Spectral graph theory. American Mathematical Society, 1997.
Michael Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional neural networks on
graphs with fast localized spectral filtering. In Advances in neural information processing systems,
pages 3844-3852, 2016.
Amir Dembo, Andrea Montanari, and Nike Sun. Factor models on locally tree-like graphs. The
Annals of Probability, 41(6):4162-4213, 2013.
Matthias Fey, Jan Eric Lenssen, Frank Weichert, and Heinrich Muller. SplineCNN: Fast geometric
deep learning with continuous B-spline kernels. In IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), 2018.
Alex Fout, Jonathon Byrd, Basir Shariat, and Asa Ben-Hur. Protein interface prediction using graph
convolutional networks. In Advances in Neural Information Processing Systems, pages 6530-6539,
2017.
Victor Garcia and Joan Bruna. Few-shot learning with graph neural networks. International
Conference on Learning Representations, 2017.
Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol Vinyals, and George E. Dahl. Neural
message passing for quantum chemistry. In Proceedings of the 34th International Conference on
Machine Learning, volume 70, pages 1263-1272. JMLR, 2017.
Benjamin Girault, Antonio Ortega, and Shrikanth S. Narayanan. Irregularity-aware graph fourier
transforms. IEEE Transactions on Signal Processing, 66(21):5746-5761, 2018.
Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive representation learning on large graphs. In
Advances in Neural Information Processing Systems, pages 1024-1034, 2017.
Nicholas J. Higham. Functions of matrices: theory and computation, volume 104. SIAM, 2008.
Michael Kampffmeyer, Yinbo Chen, Xiaodan Liang, Hao Wang, Yujia Zhang, and Eric P Xing.
Rethinking knowledge graph propagation for zero-shot learning. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition, pages 11487-11496, 2019.
Nicolas Keriven and Gabriel Peyre. Universal invariant and equivariant graph neural networks. arXiv
preprint arXiv:1905.04943, 2019.
Thomas N. Kipf and Max Welling. Semi-supervised classification with graph convolutional networks.
In International Conference on Learning Representations, 2017.
Johannes Klicpera, Aleksandar Bojchevski, and Stephan Gunnemann. Predict then propagate:
Graph neural networks meet personalized pagerank. International Conference on Learning
Representations, 2019.
Beatrice Laurent and Pascal Massart. Adaptive estimation of a quadratic functional by model selection.
Annals of Statistics, pages 1302-1338, 2000.
Qimai Li, Zhichao Han, and Xiao-Ming Wu. Deeper insights into graph convolutional networks for
semi-supervised learning. In Thirty-Second AAAI Conference on Artificial Intelligence, 2018.
9
Under review as a conference paper at ICLR 2020
Qimai Li, Xiao-Ming Wu, Han Liu, Xiaotong Zhang, and Zhichao Guan. Label efficient semi-
supervised learning via graph filtering. In Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, pages 9582-9591, 2019.
Renjie Liao, Zhizhen Zhao, Raquel Urtasun, and Richard S Zemel. Lanczosnet: Multi-scale deep
graph convolutional networks. arXiv preprint arXiv:1901.01484, 2019.
Antonio Ortega, Pascal Frossard, Jelena KovaCeviC, Jose MF Moura, and Pierre Vandergheynst.
Graph signal processing: Overview, challenges, and applications. Proceedings of the IEEE, 106
(5):808-828, 2018.
Jiezhong Qiu, Yuxiao Dong, Hao Ma, Jian Li, Kuansan Wang, and Jie Tang. Network embedding as
matrix faCtorization: Unifying deepwalk, line, pte, and node2veC. In Proceedings of the Eleventh
ACM International Conference on Web Search and Data Mining, pages 459-467. ACM, 2018.
LawrenCe R. Rabiner and Bernard Gold. Theory and appliCation of digital signal proCessing.
Englewood Cliffs, NJ, Prentice-Hall, Inc., 1975.
Adam Santoro, David Raposo, David G. Barrett, Mateusz Malinowski, Razvan PasCanu, Peter
Battaglia, and Timothy LilliCrap. A simple neural network module for relational reasoning. In
Advances in Neural Information Processing Systems, pages 4967-4976, 2017.
Prithviraj Sen, Galileo Namata, Mustafa BilgiC, Lise Getoor, Brian Galligher, and Tina Eliassi-Rad.
ColleCtive ClassifiCation in network data. AI magazine, 29(3):93-93, 2008.
David I. Shuman, Sunil K. Narang, PasCal Frossard, Antonio Ortega, and Pierre Vandergheynst.
The emerging field of signal proCessing on graphs: Extending high-dimensional data analysis to
networks and other irregular domains. arXiv preprint arXiv:1211.0053, 2012.
Saeed V. Vaseghi. Advanced digital signal processing and noise reduction. John Wiley & Sons, 2008.
Petar VeliCkoviC, GUillem CUCUrUlL Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua
Bengio. Graph attention networks. International Conference on Learning Representations, 2017.
Petar VeliCkoviC, William Fedus, William L. Hamilton, Pietro Lio, Yoshua Bengio, and R. Devon
Hjelm. Deep graph infomax. International Conference on Learning Representations, 2019.
Felix WU, Tianyi Zhang, AmaUri Holanda de SoUza Jr., Christopher Fifty, Tao YU, and Kilian Q.
Weinberger. Simplifying graph ConvolUtional networks. In Proceedings of the 36th International
Conference on International Conference on Machine Learning, volUme 97. JMLR, 2019.
KeyUlU XU, WeihUa HU, JUre LeskoveC, and Stefanie Jegelka. How powerfUl are graph neUral
networks? International Conference on Learning Representations, 2019.
Jiani Zhang, Xingjian Shi, JUnyUan Xie, Hao Ma, Irwin King, and Dit-Yan YeUng. Gaan: Gated
attention networks for learning on large and spatiotemporal graphs. In Proceedings of the Thirty
Fourth Conference on Uncertainty in Artificial Intelligence (UAI), 2018a.
YUhao Zhang, Peng Qi, and Christopher D. Manning. Graph ConvolUtion over prUned dependenCy
trees improves relation extraCtion. Empirical Methods in Natural Language Processing, 2018b.
Marinka Zitnik and JUre LeskoveC. PrediCting mUltiCellUlar fUnCtion throUgh mUlti-layer tissUe
networks. Bioinformatics, 33(14):i190-i198, 2017.
10
Under review as a conference paper at ICLR 2020
Appendix
A Proofs
Proof of Theorem 3. Since the generalized eigenvalues of (D + γI, L) are the eigenvalues of a
positive Semidefinite matrix (D + YI)1/2L(D + YI)1/2, these are non-negative real numbers. To
obtain the shrinking result, We use the Courant-Fisher-Weyl's min-max principle (Bhatia, 2013,
Corollary III. 1.2): For any 0 ≤ Y1 < Y2,
x>Lx
λi(γ2) =	min	max 丁 / C-----------
H:subspace,dim(H)=i x∈H,x6=0 x> (D + Y2I)x
>
xx
≤ min	max 丁 --------------
H:subspace,dim(H)=i x∈H,x6=0 x> (D + Y1I)x
= λi(Y1).
(15)
(16)
(17)
Here, the second inequality folloWs because x>(D + Y1)x < x>(D + Y2)x for all x 6= 0 Hence, the
inequality is strict if x>Lx = 0, i.e., λi(γι) = 0.	□
Lemma 9. If X has a frequency at most then kh(L)X k2D ≤ maxt∈[0,] h(t)kX k2D.
Proof. By the Parseval identity,
∣lx∣D = fh(λ)kx(λ)k2	(18)
λ∈Λ	
≤ tmaχ h(t) X Ilx(λ)k2 λ∈Λ	(19)
=max h⑴IX I∣2 t∈[0,]	2	(20)
=maχ h⑴kXIlD. t∈[0,]	(21)
	□
ProofofLemma 5. By substituting X = X + Z, we obtain
kX - AkVXkD ≤ k(I - AkW)XkD + kAkWZkD.	(22)
By Lemma 9, the first term is bounded by √ki∣∣X∣∣d. By the Parseval identity equation 4, the second
term is evaluated by
kAwZ kD = X(1-λ)2k kZ(λ)k2	(23)
λ∈Λ
E (1- λ)2kZ(λ,p)2
λ∈Λ,p∈{1,...,d}
(24)
By (Laurent and Massart, 2000, Lemma 1), we have
Prob ∣X(1 - λ)2k(Z(λ,p)2∕σ2- 1) ≥ 2^t X(1 - λ)4k +2t} ≤ e-t.	(25)
By substituting t = log(1∕δ) with δ ≤ 1∕2, we obtain
Prob ∖ X(1 - λ)2kz(λ,p)2 ≥ 5σ2ndlog(1∕δ)^λ(I - λ)2k 卜 ≤ 1 - δ. (26)
Note that E[kZk2D = σ2nd, and
P (1 - λ)2k tr(A2k)	,、
^λ-----= =	' rw/ = R(2k)	(27)
nn
since (i,j) entry of A2k is the probability that a random walk starting from i ∈ V is on j ∈ V at 2k
step, we obtain the lemma.	□
11
Under review as a conference paper at ICLR 2020
Proof of Theorem 7. By the Lipschitz continuity of σ, we have
Mmlp(X|W1, W2) - hMLp(AkwX∣Wι, W2)kD ≤ kX — AkwXkDρ(W1)ρ(W2).	(28)
By using Lemma 5, We obtain the result.	□
Lemma 10. If X has a frequency at most E then there exists Y such that Y has afrequency at most
√ and kσ(X) - YkD ≤ √≡∣∣XkD∙
Proof. We choose Y by truncating the frequency components greater than √E. Then,
kσ(X) - YkD = X kσ[)(λ)k2	(29)
λ>√l
≤ √ X λk<[)(λ)k2	(30)
=√∣ X kσ(X(U))- σ(X(V))k2	(31)
(u,v)∈E
≤√ X kx(U)-X(V)k2	(32)
(u,v)∈E
=√ X λkX(λ)k2	(33)
λ
≤√EX kx(λ)k2	(34)
λ
=√EkXkD.	(35)
□
Proof of Theorem 8. From Lemma 10, by taking the square root and absolute values of both sides,
we have kσ(X) - YkD ≤ E1/4kXkD.
By setting Y = σ(ArwX), since σ is an activation function, we have:
一 ,―, ~ , - . .. .. ~ ,―...
kσ(X) - Arwσ(X)kD = kLrwσ(X)kD	(36)
≤ O(e1∕4)kXkD	(37)
Consequently, we consider the D-norm stated in Theorem 8:
,― ~ , ~ ..
kσ(XW1)W2 - Arwσ(ArwXW1)W2kD	(38)
kσ(XWι) - Arwσ(XWι)kD + kArwσ(XWi) - ArWσ(ArwXWι)kp) ρ(W2)	(39)
=(kLrwσ(XWi)kD + kX - ArWXkDρ(Wi)) ρ(W2)	(40)
≤ (0(J∕4)kXkD + R(2)kZkD) ρ(Wi)ρ(W2).	(41)
□
B GFNN Model Details
Our gfNN model is implemented in pytorch. While other number of hidden layers are possible, we
find that 1 hidden layer with 256 units (2 layers MLp) is enough for all benchmark datasets. Other
changes does not significantly influence the experimental results. It worth mentioning that each gfNN
model actually has 2 identical neural networks inside, one to learn from low-pass filter Arw and the
other for high-pass filter Lrw. We use pReLU (0.25) as the activation function since there are a slight
improvement (about 1%) in validation accuracy when training with pReLU compare to ReLU.
To optimize our model, we use the pytorch built-in Adam optimizer. We fix the hyperparameters
accross all datasets:
12
Under review as a conference paper at ICLR 2020
•	Weight decay: 1 × 10-4
•	Learning rate: 0.01
•	Batch size: 32
•	Early stopping: 40 epochs patience (Max. 500 epochs).
All datasets have three sets: train, valdiation, and test. The validation set is used for early stopping
and model selection (high/low). The test accuracy is reported for all experiments.
C Baseline Details
We set GCN (Kipf and Welling, 2017) at two layers with 64 hidden units, ReLU activation, no dropout.
We keep the setting of SGC (Wu et al., 2019) as recommended by the original implementation (200
epochs, lr=0.1, weight decay: 1 X 10-4, ReLU activation). For DGI (VelickoVic et al., 2019),
GraphSAGE Hamilton et al. (2017), and GIN (Xu et al., 2019), we follow the authors’ default
paramter tuning. The result for GraphSAGE is reported as the best result from “small” models (mean,
sum, seq) for 200 epochs training, we also set number of level-1 neighbors at 25 and level-2 at 10.
D Dataset details
We provide an evaluation for the semi-supervised node classification performance of SGC on the
Cora, Citeseer, and Pubmed citation network datasets Sen et al. (2008). We also follow Wu et al.
(2019) to run experiments on Reddit Chen et al. (2018) and Hamilton et al. (2017) on PPI Zitnik and
Leskovec (2017).
Table 2: Real-world benchmark datasets and synthetic datasets for vertex classification
Dataset	Nodes	Edges	Features (X)	(μx ,σχ)	Classes	Train/Val/Test
Cora	2,708	5,278	1,433	(0.0007, 0.0071)	7	140/500/1,000
Citeseer	3,327	4,732	3,703	(0.0003, 0.0029)	6	120/500/1,000
Pubmed	19,717	44,338	500	(0.0019, 0.0087)	3	60/500/1,000
Reddit	231,443	11,606,919	602	-	41	151,708/23,699/55,334
PPI	56,944	818,716	50	-	121	44,906/6,514/5,524
Two Circles	4,000	10,000	2	-	2	80/80/3,840
BA-High	200	2000	50	(0,1)	2	10/10/180
The Two Circle dataset is visually presented in Figure 7 (test accuracies are shown in the corner).
The coordinates of each data point are used as features.
Original data
SGC	GCN	gfNN
Figure 7: Decision boundaries on 500 generated data samples following the two circles pattern
BA-High dataset generation procedure is described in Figure 8.
We have similar experimental results on different type of random graphs: ER, Configuation, and
Block Model. The experimental results on GCN/SGC can be explained simply with Figure 9
In Figure 9, the color blue and orange indicate label 1 and label 0 in a 100 node BA-graph. It is trivial
to see that any simple machine learning model can learn from the original feature. However, after
only one filter, the features become indistinguisable. More low-pass filter applications will lead to a
uniform feature (Theorem 3).
13
Under review as a conference paper at ICLR 2020
Find maximal indep. set
Assign random signal
Figure 8: BA-High generation steps
Signal Shift Phenomenon
Original Filtered (k=1)
0 5 0 5 0 0 2 4 6 8 0
1 一 T 一 一 一 一T
①n_e> ①n_e>
Vertex Index
Figure 9: Plot for 1 dimensional features in BA-High setting. We set = 5.0 for clarity purpose.
14