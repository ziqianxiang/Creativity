Under review as a conference paper at ICLR 2020
Collaborative Filtering with A Synthetic
Feedback Loop
Anonymous authors
Paper under double-blind review
Ab stract
We propose a novel learning framework for recommendation systems, assisting
collaborative filtering with a synthetic feedback loop. The proposed framework
consists of a “recommender” and a “virtual user.” The recommender is formulizd
as a collaborative-filtering method, recommending items according to observed
user behavior. The virtual user estimates rewards from the recommended items
and generates the influence of the rewards on observed user behavior. The recom-
mender connected with the virtual user constructs a closed loop, that recommends
users with items and imitates the unobserved feedback of the users to the recom-
mended items. The synthetic feedback is used to augment observed user behavior
and improve recommendation results. Such a model can be interpreted as the
inverse reinforcement learning, which can be learned effectively via rollout (sim-
ulation). Experimental results show that the proposed framework is able to boost
the performance of existing collaborative filtering methods on multiple datasets.
1	Introduction
Recommendation systems are important modules for abundant online applications, helping users
explore items of potential interest. As one of the most effective approaches, collaborative filter-
ing Sarwar et al. (2001); Koren & Bell (2015); He et al. (2017) and its deep neural networks based
variants He et al. (2017); Wu et al. (2016); Liang et al. (2018); Li & She (2017); Yang et al. (2017);
Wang et al. (2018) have been widely studied. These methods leverage patterns across similar users
and items, predicting user preferences and demonstrating encouraging results in recommendation
tasks Bennett & Lanning (2007); Hu et al. (2008); Schedl (2016). Among these work, beside “user-
item” pairs, side information, e.g., user reviews and scores on items, are involved and have achieved
remarkable success Menon et al. (2011); Fang & Si (2011). Such side information is a kind of user
feedback to the recommended items, which is promising to improve the recommendation systems.
Unfortunately, both the user-item pairs and user feedback are extremely sparse compared with the
search space of items. What is worse, when the recommendation systems are trained on static obser-
vations, the feedback is unavailable until it is deployed in real-world applications — in both training
and validation phases, the target systems have no access to any feedback because no one has ob-
served the recommended items. Therefore, the recommendation systems may suffer overfitting, and
their performance may degrade accordingly, especially in the initial phase of deployment. Although
real-world recommendation systems are usually updated in an online manner with the assist of in-
creasing observed user behavior Rendle & Schmidt-Thieme (2008); Agarwal et al. (2010); He et al.
(2016), introducing a feedback mechanism during their training phases can potentially improve the
efficiency of the initial systems. However, this is neglected by existing learning frameworks.
Motivated by the above observations, we propose a novel framework that achieves collaborative
filtering with a synthetic feedback loop (CF-SFL). As shown in Figure 1, the proposed framework
consists of a “recommender” and a “virtual user.” The recommender is a collaborative filtering (CF)
model, that predicts items from observed user behavior. The observed user behavior reflects in-
trinsic preferences of users, while the recommended items represent the potential user preferences
estimated by the model. Regarding the fusion of the observed user behavior and the recommended
items as inputs, the virtual user, which is the key of our model, imitates real-world scenarios and
synthesizes user feedback. In particular, the virtual user contains a reward estimator and a feed-
back generator: the reward estimator estimates rewards based on the fused inputs (the compatible
1
Under review as a conference paper at ICLR 2020
representation of the user observation and its recommended items), learned with a generative adver-
sarial regularizer. The feedback generator provides feedback embeddings to augment the original
user embeddings, conditioned on the estimated rewards as well as the fused inputs. Such a frame-
work constructs a closed loop between the target CF model and the virtual user, synthesizing user
feedback as side information to improve recommendation results.
The proposed CF-SFL framework can be interpreted
as inverse reinforcement learning (IRL) approach, in
which the recommender learns to recommend user
items (policy) with the estimated guidance (feed-
back) from the proposed virtual user. The proposed
feedback loops can be understood as an effective
rollout procedure for recommendation, jointly up-
dating the recommender (policy) and the virtual user
(the reward estimator and the feedback generator).
Eventually, even if side information (i.e., real-world
user feedback) is unobservable, our algorithm is still
applicable to synthesize feedback in both the train-
ing and inference phases. The proposed framework
Recommended
V Virtual User
Items
Fused Input ι
Figure 1: Illustration of our proposed CF-SFL
framework for collaborative filtering.
is general and compatible with most CF methods. Experimental results show that the performance
of existing approaches can be remarkably improved within the proposed framework.
2	Proposed Framework
In this section, we first describe the problem we are interested in and give a detail description of
each module that is included in the framework.
2.1	Problem Statement
Suppose we have N users with M items in total, we denote the observed user-item matrix as X =
[xi] ∈ {0, 1}N×M, where each vector xi = [xij] ∈ RM, i = 1, ..., N, represents observed user
behaviors. xij = 1 indicates the the j-th item is bought or reviewed via the i-th user and otherwise
the j -th item can either be irrelevant to the i-th user or we have not enough knowledge about their
relationship. The desired recommendation system aims to predict each user’s preference, denoted
as ai = [aij] ∈ RM, whose element aij indicates the preference of the i-th user to the j-th item.
Accordingly, the system recommends each user with the items having large aij ’s.
Ideally, for each user, xi just contains partial (actually, very sparse) information about user prefer-
ence and a practical recommendation system works dynamically with a closed loop — users often
generate feedback to the recommended items while the recommendation system considers these
feedback to revise recommended items in the future. Therefore, we can formulate the whole recom-
mendation process as
ait = π(xi,vit),	vit+1 = f(xi,ait), for i = 1, ..., N,	(1)
where ∏(∙) represents the target recommender while f (∙) represents the coupled feedback mecha-
nism of the system. vi ∈ Rd is the embedding of user feedback to historical recommended items.
At each time t, the recommender predicts preferred items according to observed user behaviors and
previous feedback, and the user generates feedback to the recommender. Note that (1) is different
from existing sequential recommendation models Mishra et al. (2015); Wang et al. (2016) because
those methods ignore the feedback loop as well, which just updates recommender π according to
observed sequential observations, i.e., xit for different time t’s.1
Unfortunately, the feedback information is often unavailable in the training and inference phases.
Accordingly, most of existing collaborative filtering-based recommendation methods ignore the
feedback loop in the system, learning the target system purely from static observation user-item
matrix X Liang et al. (2018); Li & She (2017). Although in some scenarios side information like
user reviewers is associated with the observation matrix, the methods using such information often
treat it as a kind of static knowledge rather than dynamic feedback. They mainly focus on fitting the
1When the static observation xi in (1) is replaced with sequential observation xit, (1) is naturally extended
to a sequential recommendation system with a feedback loop. In this work, we focus on the case with static
observations and train a recommender system accordingly.
2
Under review as a conference paper at ICLR 2020
groundtruth recommended items with the recommender ∏(∙) given fixed Xi's and Vi's, while ignore
the imitation of the whole recommendation-feedback loop in (1). Without the feedback mechanism
f (∙), ∏(∙) tends to over-fit the observed user behavior and static side information, which may degrade
in practical dynamical scene.
To overcome the problems mentioned above, we propose a collaborative filtering framework with a
synthetic feedback loop (CF-SFL), which explains the whole recommendation process from a view-
point of reinforcement learning. As shown in Figure 1, besides traditional recommendation mod-
ule the proposed framework further introduces a virtual user, which imitates the recommendation-
feedback loop even if the real-world feedback are unobservable.
2.2	Recommender
In our framework, the recommender implements the function ∏(∙) in (1), which takes the observed
user behavior xi and his/her previous feedback embedding vit as input and recommends items ac-
cordingly. In principle, the recommender ∏(∙) can be defined with high flexibility, which can be
arbitrary collaborative filtering methods that predicting items from user representations, such as
WMF Hu et al. (2008), CDAE Wu et al. (2016), VAE Liang et al. (2018) etc. In this work, we
formulate the recommender from the viewpoint of reinforcement learning.
In particular, the recommendation-feedback loop generates a sequence of interactions between each
user and the recommender, i.e., (sit, ait)tT=1 fori = 1, ..., N. Here, sit = [xi; vit] is the representation
of user i at time t, which is a sample in the state space S describing user preference. ait indicates
the recommended items provided by the recommender, which is a sample in the action space A
of the recommender. Accordingly, we can model the recommendation-feedback loop as a Markov
Decision Process (MDP) M = hS, A, P, Ri, where P : S × A× S 7→ R is the transition probability
of user preference and R : S × A 7→ R is the reward function used to evaluate recommended items.
The recommender ∏(∙) works as a policy parametrized by θ, i.e., ∏θ (a|s), which corresponds to the
distribution of items conditioned on user preference. The target recommender should be an optimal
T
policy that maximizes the expected reward: J(πθ) = t=1 Eπθ [R(st, at)], where R(st, at)
means the reward over the state-action pair (st, at). For the i-th user, given sit, the recommender
selects potentially-preferred items via
at = arg maXa∈A ∏θ(a∣si).
(2)
Note that different from traditional reinforcement learning tasks, in which both S and A are available
while P and R are with limited accessibility, our recommender just receives partial information
of state — it does not observe users’ feedback embedding vi . In other words, to optimize the
recommender, we need to build a reward model and a feedback generator jointly, which motivates
us to introduce a virtual user into the framework.
2.3	Virtual User
The virtual user module aims to implement the feedback function f (∙) in (1), which not only models
the reward of the items provided by the recommender but also generates feedback to complete the
representations of state. Accordingly, the virtual user contains the following two modules:
Reward Estimator The reward estimator parametrizes the function of reward, which takes the cur-
rent prediction ait and user preference sit as input and evaluate their compatibility. In this work, we
implement the estimator with parameter φ, which is defined as
Rφ(sit,ait) = sigmoid(g(h(xi, ait))).
(3)
In this work, we use the static part of the state st, i.e., the observed user behaviors Xi as input. h(∙, ∙)
is the fusion function which merges xi and ait into a real value vector (the fused input is shown in
Figure 5 and described in Appendix). g(∙) is the single value regression function that translates the
fused input into a single reward value. The sigmoid function is used to restrict the regression value
between 0 and 1.
Feedback Generator The feedback generator connects the reward estimator with the recommender
via generating a feedback embedding, i.e.,
vti+1 = Fψ (h(Xi, ait), R(sit, ait)),
(4)
3
Under review as a conference paper at ICLR 2020
t=0	t=1	t=T-1	t=T
vi0	vi1	viT -1	viT
Figure 2: Unrolling the recurrent CF-SFL framework into an iterative learning process with multiple
time steps T.
where ψ represents the parameters of the generator. Specifically, the a parametric function Fψ(∙, ∙)
considers the fused input and the estimated reward and returns a feedback embedding vti ∈ Rd
to the recommender. R(sit, ait) indicates the compatibility between the recommended items and
user preferences, and h(xi, ait), which is a vector rather than a scalar like reward, further enriches
the information of the reward to generate feedback embeddings. Consequently, the recommender
receives the informative feedback as a complementary component of the static observation xi to
make an improved recommendation via (2).
3	Learning Algorithm
3.1	Learning task
Based on the proposed framework, we need to jointly learn the policy corresponding to the recom-
mender πθ, the reward estimator Rφ and the feedback generator Fψ. Suppose that we have a set of
labeled samples D = {xi, ai}, where Xi ∈ RM is the historical behaviors of user i derived from
the user-item matrix X and ai is the ground truth of the recommended item for the user based on
his/her behavior xi. We formulate the learning task as the following min-max optimization problem.
minπθ,Fψ maxRφ L(πθ, Rφ, Fψ)
where
L(∏θ,Rφ,Fψ) = E.Lsup(ai, &i； ∏θ,Fψ) - E
、---1-------Sz-----------} |
supervised loss
(5)
(6)
a~∏θ[log(Rφ(s, a))] - Ea~d[1 - log(Rφ(s, a))].
___________________________ - ，
Collaboration with adversarial regularizer
In particular, the first term Lsup in (6) can be any supervised loss based on labeled data D, e.g., the
evidence lower bound (ELBO) proposed in VAEs Liang et al. (2018) (and used in our work). This
term ensures the recommender to fit the groundtruth labeled data. The second term considers the
following two types of interactions among these three modules:
•	The collaboration between the recommender policy πθ and the feedback generator Fψ
towards a better predictive recommender.
•	The adversarial game between the recommender policy πθ and the reward estimator Rφ.
Accordingly, given current reward model, we update the recommender policy πθ and the feedback
generator Fψ to maximize the expected reward derived from the generated user preference s and the
recommended item a. On the contrary, given the recommended policy and the feedback generator,
we improve the reward estimator Rφ by sharpening its criterion — the updated reward estimator
maximizes the expected reward derived from the generated user preference and the ground truth of
item while minimize the expected reward based on the recommended item. Therefore, we solve (5)
via alternating optimization. The updating of πθ and Fψ is achieved by minimizing
LC(∏θ,Fψ) = EiLSUPS, ai； ∏θ,Fψ) - Ea~∏θ [log(Rφ(s, a))].	(7)
And the updating of Rφ is achieved by maximizing
La(Rφ) = -Ea~∏θ[log(Rφ(s, a))] - Ea~D[1 - log(Rφ(s, a))]	(8)
Both these two updating steps can be solved effectively via stochastic gradient descent.
4
Under review as a conference paper at ICLR 2020
3.2	Unrolling for learning and inference
Because the proposed framework contains a closed loop among learnable modules, during training
we unroll the loop and let the recommender interact with the virtual user in T steps. Specifically,
at the initial stage, the recommender takes the observed user behaviour xi and an all-zero initial
feedback embedding vi0, to make recommendations. At each step t, the recommender predicts the
items ait given xi and vit to the virtual user, and receives the feedback embedding vit+1 . The loss
is defined according to the output of the last step, i.e., aT and vT , and the modules are updated
accordingly. After the model is learned, in the testing phase we need to infer the recommended item
in the same manner, unrolling the feedback loop and deriving aT as the final recommended item.
The details of unrolling process are illustrated in Figure 2, and the detailed scheme of our learning
algorithm is shown in Algorithm 1 in appendix.
4	CF-SFL as Inverse Reinforcement Learning
Our CF-SFL framework automatically discovers informative user feedback as side information and
gradually improve the training for the recommender. Theoretically, it closely connects with Inverse
Reinforcement Learning (IRL). Specifically, WejointIy learn the reward function R(∙, ∙) and the pol-
icy (recommender) ∏(∙, ∙) from the expert trajectories DE (the observed labeled data). DE typically
consists of state-action pairs generated from an expert policy πE with the corresponding environ-
ment dynamics PE. And the goal of the IRL is to recover the optimal reward function R (∙, ∙) as
well as the corresponding recommender ∏*. Formally, the IRL is defined as:
{R",π*}，IRL(∏e) = arg max	PE(s, a)R(s, a) — [maxH(∏) +	ρ(s, a)R(s, a)] (9)
R∈RS×A	π∈Π
s,a	s,a
= arg max min —H (π) +	ρE (s, a)R(s, a) —	ρ(s, a)R(s, a)	(10)
r∈RS×A π∈Π
s,a	s,a
S--------------------V-------------------}
L(π,R)
Intuitively, the objective enforces the expert policy πE to induce higher rewards (the max part), than
all other policies. This objective is sub-optimal if the expert trajectories are noisy, i.e., the expert is
not perfect and its trajectories are not optimal. This will render the learned policy always performs
worse than the expert one. Besides, the illed-defined IRL objective often induces multiple solutions
due to flexible solution space, i.e., one can assign an arbitrary reward to trajectories not from expert,
as long as these trajectories yields lower rewards than the expert trajectories. To alleviate these
issues, some constraints are placed into the objective functions, e.g., a convex reward functional,
ψ : RS×A → R, which usually works as a regularizer.
{R*,π*} = arg max min L(π,R) — ψ(R).	(11)
R∈RS×A π∈Π
To imitate the expert policy and provide better generalization, we adopt the adversarial regular-
izer Ho & Ermon (2016), which defines ψ with the following form:
ψ(R) ,
EπE [q(R(s, a))]
+∞
if R(s, a) ≥ 0
otherwise
where q(x) = x — log(1 — e-x). This regularizer places low penalty on reward functions R that
assign an amount of positive value to expert state-action pairs; however, if R assigns low value (close
to zero, which is the lower bound) to the expert, then the regularizer will heavily penalize R. With
induced adversarial regularizer, we obtain a new imitation learning algorithm for recommender:
min ψ*(ρ∏ — ρ∏E) — λH (∏θ)	(12)
θ
Intuitively, we want to find a saddle point (Rφ, πθ) of the expression:
Eπθ [log(R(s, a))] +EπE[1 — log(R(s, a))] — λH(πθ) ,	(13)
where R(s, a) ∈ (0, 1). Note equation 11 is derived from the objective of traditional IRL. How-
ever, distinct from the traditional approach, we propose a feedback generator to provide feedbacks
to the recommender. In terms of the reward estimator, it tends to assign lower rewards to the pre-
dicted results by the recommender πθ and higher rewards for the expert policy πE, which aims to
discriminate πθ from πE :
LR =Eπθ[log(R(s,a))] +EπE[1 — log(R(s, a))]
(14)
5
Under review as a conference paper at ICLR 2020
Similar to standard IRL, we update the generator to maximize the expected reward with respect
to log R(s, a), moving towards expert-like regions of user-item space. In practice, we incorporate
feedback embedding to update the user preferences, and the objective of the recommender is:
LF = Eπθ [- log(R([xi, vit], a))] - λH(πθ)	(15)
where vit = Fψ(h(xi, ait), R(sti, ait)).
5	Related Work
Collaborative Filtering. Collaborative filtering (CF) can be roughly categorized into two groups:
CF with implicit feedback Bayer et al. (2017); Hu et al. (2008) and those with explicit feedback Ko-
ren (2008); Liu et al. (2010). In implicit CF, user-item interactions are binary in natural (i.e., 1 if
clicked and 0 otherwise) as oppose to explicit CF where item ratings (e.g., 1-5 stars) are typically the
subject of interests. Implicit CF has been widely studied, examples including factorization of user-
item interactions He et al. (2016); Koren (2008); Liu et al. (2016); Rendle (2010); Rennie & Srebro
(2005) and ranking based approach Rendle et al. (2009). And our CF-SFL is a new framework for
implicit CF.
Currently, neural network based models have achieved state-of-the-art performance for various rec-
ommender systems Cheng et al. (2016); He et al. (2018; 2017); Zhang et al. (2018); Liang et al.
(2018). Among these methods, NCF He et al. (2017) casts the well-established matrix factorization
algorithm into an entire neural framework, combing the shallow inner-product based learner with a
series of stacked nonlinear transformations. This method outperforms various of traditional base-
lines and has motivated many following works such as NFM He et al. (2017), Deep FM Guo et al.
(2017) and Wide and Deep Cheng et al. (2016). Recently, deep generative has achieved remarkable
success. VAEs Liang et al. (2018) uses variational inference to scale up the algorithm for large-scale
dataset and has shown significant success in recommender systems with a usage of multinormial
likelihood. Our CF-SFL is a general framework that can adapt to these models seamlessly.
RL in Collaborative Filtering. For RL-based methods, contextual multi-armed bandits are
firstly utilized to model the interactive nature of recommender systems. Thompson Sampling
(TS) Chapelle & Li (2011); Kveton et al. (2015); Zhang et al. (2017) and Upper Confident Bound
(UCB) Li et al. (2010) are used to balance the trade-off between exploration and exploitation. Zhao
et al. (2013) combine matrix factorization with bandits to include latent vectors of items and users
for better exploration. The MDP-Based CF model can be viewed as a partial observable MDP
(POMDP) with partial observation of user preferences Sunehag et al. (2015). Value function ap-
proximation and policy based optimization can be employed to solve the MDP. Zheng et al. (2018)
and Taghipour & Kardan (2008) modeled web page recommendation as a Q-Learning problem and
learned to make recommendations from web usage data. Sunehag et al. (2015) introduced agents
that successfully address sequential decision problems. Zhao et al. (2018) propose a novel page-
wise recommendation framework based on deep reinforcement learning. In this paper, we consider
the recommending procedure as sequential interactions between virtual users and recommender; and
leverage feedbacks from virtual users to improve the recommendation. Recently, Chen et al. (2019)
proposed an off-policy corrections technique, and successfully applied it in real-world applications.
6	Experiments
Datasets We investigate the effective- Table 1： BasiC information of the Considered datasets.	
ness of the proposed CF-SFL framework	ML-20M Netflix~~MSD-
on three benChmark datasets of reCom-	# of users mendation systems. (i) MovieLens-20M	# of items (ML-20M), a movie reCommendation ser- # of interaCtions viCe Contains tens of millions user-movie # of held-out-users ratings. (ii) Netflix-Prize (Netflix), an-	% of sparsity	136,677	463,435	571,355 20,108	17,769	41,140 10.0M	56.9M	33.6M 10.0K	40.0K	50.0K 0.36%	0.69%	0.14%
other User-UloVie ratings dataset collected 		
by the Netflix Prize Bennett & Lanning (2007). (iii) Million Song Dataset (MSD), a user-song rating
dataset, which is released as part of the Million Song Dataset Bertin-Mahieux et al. (2011). To di-
rectly compare with existing work, we employed the same pre-processing procedure as Liang et al.
(2018). A summary statistics of these datasets are provided in Table 1.
6
Under review as a conference paper at ICLR 2020
Table 3: Performance comparison between our CF-SFL framework and various of baselines. VAE* is the
results based on our own runs and VAEt is the VAE model With our reward estimator.__________
Methods	ML-20M R@20 R@50 NDCG@100			Netflix R@20 R@50 NDCG@100			MSD R@20 R@50 NDCG@100		
SLIM-	0.370	0.495	0.401	0.347	0.428	0.379	-	-	-
WMF	0.360	0.498	0.386	0.316	0.404	0.351	0.211	0.312	0.257
CDAE	0.391	0.523	0.418	0.343	0.428	0.376	0.188	0.283	0.237
aWAE	0.391	0.532	0.424	0.354	0.441	0.381	-	-	-
VAE	0.395	0.537	0.426	0.351	0.444	0.386	0.266	0.364	0.316
VAE*-	0.395	0.535	0.425	0.350	-0.444	0.386	0.260	0.356	0.311
VAEt	0.396	0.536	0.426	0.352	0.445	0.387	0.263	0.360	0.314
CF-SFL	0.404	0.542	0.435	0.355	0.449	0.394	0.273	0.369	0.323
0.4450
0.4425
0.4400
0.4375
0.4350
0.4325
0.43∞
0.4275
0.4250
0.325
0.320
0.315
0.310
0.305
0.300
ML_20M
00	80	100	120	140	1β0	180	200
20	4€	βθ	80	1∞
# of Epochs
MSD
20	4。 βθ BoloO
Figure 3:	Performance (NDCG@100) boosting on the validation sets.
Evaluation Metrics We employ Recall@r2 together with NDCG@r3 as the evaluation metric for
recommendation, which measures the similarity between the recommended items and the ground
truth. Recall@r considers top-r recommended items equally, while NDCG@r ranks the top-r items
and emphasizes the importance of the items that are with high ranks.
Set-up For our CF-SFL frame-
work, the architectures of its recom-
mender, reward estimator and feed-
back generator are shown in Table 2.
To represent the user preference, we
normalize xi and vit (t > 0) indepen-
dently and concatenate the two into
a single vector. To learn the model,
we pre-train the recommender (150
Table 2: ArChiteCtUre of our CF-SFL framework.
Recommender Input RM	Reward Estimator Input R64	Feedback Generator Input R65
M × 600, tanh 600 × 200 (x2) Sample R200 200 × 600, tanh 600 × M softmax	64 × 128, ReLU 128 X 128, ReLU 128 X 128, ReLU 128 X 1, sigmoid	-64 X 128, ReLU 128 X 128, ReLU 128 X 128
epochs for ML-20M and 75 epochs for Netflix and MSD) and optimize the entire framework (50
epochs for ML-20M and 25 epochs for the other two). `2 regularization with a penalty term 0.01 is
applied to the recommender, and Adam optimizer Kingma & Ba (2014) with batch in size of 500 is
employed. The framework is built with Tensorflow and will be publicly available upon publication.
Baselines To demonstrate the superiority of our framework, we consider multiple state-of-the-
art approaches as baselines, which can be categorized into two types: (i) Linear based models:
SLIM Ning & Karypis (2011) and WMF Hu et al. (2008). (ii) Deep neural network based models:
CDAE Wu et al. (2016), VAE Liang et al. (2018) and aWAE Zhong & Zhang (2018). It should be
noted that our CF-SFL is a generalized framework, which is compatible with all these approaches.
In particular, as shown in Table 2, we implement our recommender as the VAE-based model Liang
et al. (2018) for a fair comparison. In the following experiments, we will show that besides such a
setting the recommender can be implemented by other existing models as well.
Performance Analysis All the evaluation metrics are averaged across all the test sets.
(i)	Quantitative results: we test various methods and report their results in Table 3. With the proposed
CF-SFL framework, we significantly improve the performance of the baselines on all the evaluation
metrics. These experimental results demonstrate the power of the proposed CF-SFL framework,
which provides informative feedback as the side information. Particularly, we observed that the per-
formance between the base model (VAE *) is similar to that of its variation with the reward estimator
(VAEt). It implies that simply learning a feedback from the reward estimator via back-propagation
2https://en.wikipedia.org/wiki/Precision_and_recall
3https://en.wikipedia.org/wiki/Discounted_cumulative_gain
7
Under review as a conference paper at ICLR 2020
0.395
ML20M
0.436
0.434
0.432
0.430
0.428
0.426
O 2	4	6 S 10	12
0sQgαN
45 0.394
40
0.392
35
3o 0.390
25
20
0.386
Netflix
0.38S
1400.325
12 即 322
0.319
1∞
0.316
80
0.313
60
0.310
O 2	4	6	8	10	12
Recurrent time-steps T
0.32S
O 2	4	6 S 10	12
lpo8-∕s3E 一4-16u%l
Figure 4:	The blue curve summarizes NDCG@100 and red curves report the computational cost for model
inference in each epoch. In each sub-figure, we vary the time steps from 0 to 12 (T=0 is the base recommender).
is inefficient. Compared with such a naive strategy, the proposed CF-SFL provides more informative
feedback to the recommender, and thus, is able to improve recommendation results more effectively.
(ii) Learning Comparison: In Figure 3, we show the training trajectory of the baselines (VAE,
VAE+reward estimator) and the CF-SFL with multiple time steps. There are several interesting
findings. (a) The performance of the base VAE doesn’t improve after the pre-training steps, e.g., 75
epochs for Netflix. In comparison, the proposed CF-SFL framework can further improve the perfor-
mance once the whole model is triggered. (b) The CF-SFL yields fast convergence once the whole
framework is activated. (C) Coincide with results in Table 3, the trajectory of VAEt m Figure 3, is
similar to that of the base VAEs (VAE*). In contrast, the trajectories of our CF-SFL methods are
more smooth and able to converge to a better local minimum. This phenomenon further verifies that
our CF-SFL learns informative user feedback with better stability. (d) With an increasing of time
steps T in a particular range (T ≤ 8 for ML-20M), CF-SFL achieves faster and better performance.
One possible explanation is the learning with our unrolled structure — parameters are shared across
different time-steps, and a more accurate gradient is found towards the local minimum. (e) We find
ML-20M and MSD are more sensitive to the choice of T when compared with Netflix. Therefore,
the choice of T should adjust to different datasets.
(iii) CF-SFL with dynamic time steps: As shown in Figure 2, the learning of CF-SFL involves a
recurrent structure with T times steps. We investigate the choice ofT and report its influence on the
performance of our method. Specifically, the NDCG@100 with different T’s is shown in Figure 4.
Within 6 time steps, CF-SFL consistently boots the performance on all the three datasets. Even with
a larger time steps, the results remain stable. Additionally, the inference time of CF-SFL is linear on
time steps T. To achieve a trade-off between performance and efficiency, in our experiments we set
T to 8 for ML-20M and Netflix and 6 for MSD.
Generalization Study As afore- mentioned, our CF-SFL is a general- ized framework which is compatible	Table 4: Performance of our CF-SFL with various of rec- ommenders are reported.			
	Recommender	w/o CF-SFL	w CF-SFL Gain (10-3)	
with many existing collaborative fil- tering approaches. We study the use- fulness of our CF-SFL on different recommenders and present the results in Table 4. Specifically, two types of recommenders are being considered:				
	WARP MF	0.31228^^ 0.41587	0.33987 0.41902	+27.59 +3.15
	DAE	0.42056	0.42307	+2.51
	VAE VAE-(Gaussian)	0.42546^^ 0.42019	0.43472 0.42751	+9.26 +7.32
the linear approaches like WARP We- ston et al. (2011) and MF Hu et al.	VAE-(β = 0) VAE-Linear	0.42027 041563	0.42539 0.41597	+5.02 +0.34
(2008), and deep learning methods, e.g., DAE Liang et al. (2018) and the variation of VAE in Liang
et al. (2018). We find that our CF-SFL is capable of generalizing to most of the exisiting collab-
orative filtering approaches and boosts their performance accordingly. The gains achieved by our
CF-SFL may vary depending on the choice of recommender.
7 Conclusion
We propose a CF-SLF framework to simulate user feedback. It constructs a virtual user to provide
informative side information as user feedback. Mathematically we formulate the framework as an
IRL problem and learn the optimal policy by feeding back the action and reward. Specially, a recur-
rent architecture was built to unrolled the framework for efficient learning. Empirically we improve
the performance of state-of-the-art collaborative filtering method with a non-trivial margin. Our
framework serves as a practical solution making IRL feasible over large-scale collaborative filter-
ing. And it will be interesting to investigate the framework in other applications, such as sequential
recomender systems etc.
8
Under review as a conference paper at ICLR 2020
References
Deepak Agarwal, Bee-Chung Chen, and Pradheep Elango. Fast online learning through offline
initialization for time-sensitive recommendation. In KDD, 2010.
Immanuel Bayer, Xiangnan He, Bhargav Kanagal, and Steffen Rendle. A generic coordinate descent
framework for learning from implicit feedback. In WWW, 2017.
James Bennett and Stan Lanning. The netflix prize. In KDD cup and workshop, 2007.
Thierry Bertin-Mahieux, Daniel PW Ellis, Brian Whitman, and Paul Lamere. The million song
dataset. In Ismir, 2011.
Olivier Chapelle and Lihong Li. An empirical evaluation of thompson sampling. In NIPS, 2011.
Minmin Chen, Alex Beutel, Paul Covington, Sagar Jain, Francois Belletti, and Ed H Chi. Top-k
off-policy correction for a reinforce recommender system. In WSDM, 2019.
Xu Chen, Hongteng Xu, Yongfeng Zhang, Jiaxi Tang, Yixin Cao, Zheng Qin, and Hongyuan Zha.
Sequential recommendation with user memory networks. In WSDM, 2018.
Heng-Tze Cheng, Levent Koc, Jeremiah Harmsen, Tal Shaked, Tushar Chandra, Hrishi Aradhye,
Glen Anderson, Greg Corrado, Wei Chai, Mustafa Ispir, et al. Wide & deep learning for rec-
ommender systems. In Proceedings of the 1st Workshop on Deep Learning for Recommender
Systems, 2016.
Yi Fang and Luo Si. Matrix co-factorization for recommendation with rich side information and im-
plicit feedback. In Proceedings of the 2nd International Workshop on Information Heterogeneity
and Fusion in Recommender Systems, 2011.
Huifeng Guo, Ruiming Tang, Yunming Ye, Zhenguo Li, and Xiuqiang He. Deepfm: a factorization-
machine based neural network for ctr prediction. arXiv preprint arXiv:1703.04247, 2017.
Xiangnan He, Hanwang Zhang, Min-Yen Kan, and Tat-Seng Chua. Fast matrix factorization for
online recommendation with implicit feedback. In SIGIR, 2016.
Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu, and Tat-Seng Chua. Neural collab-
orative filtering. In WWW, 2017.
Xiangnan He, Xiaoyu Du, Xiang Wang, Feng Tian, Jinhui Tang, and Tat-Seng Chua. Outer product-
based neural collaborative filtering. arXiv preprint arXiv:1808.03912, 2018.
Jonathan Ho and Stefano Ermon. Generative adversarial imitation learning. In NIPS, 2016.
Yifan Hu, Yehuda Koren, and Chris Volinsky. Collaborative filtering for implicit feedback datasets.
In ICDM, 2008.
Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint
arXiv:1412.6980, 2014.
Yehuda Koren. Factorization meets the neighborhood: a multifaceted collaborative filtering model.
In KDD, 2008.
Yehuda Koren and Robert Bell. Advances in collaborative filtering. In Recommender systems hand-
book. 2015.
Branislav Kveton, Csaba Szepesvari, Zheng Wen, and Azin Ashkan. Cascading bandits: Learning
to rank in the cascade model. In ICML, 2015.
Lihong Li, Wei Chu, John Langford, and Robert E Schapire. A contextual-bandit approach to
personalized news article recommendation. In WWW, 2010.
Xiaopeng Li and James She. Collaborative variational autoencoder for recommender systems. In
KDD, 2017.
9
Under review as a conference paper at ICLR 2020
Dawen Liang, Rahul G Krishnan, Matthew D Hoffman, and Tony Jebara. Variational autoencoders
for collaborative filtering. WWW, 2018.
Nathan N Liu, Evan W Xiang, Min Zhao, and Qiang Yang. Unifying explicit and implicit feedback
for collaborative filtering. In CIKM, 2010.
Yong Liu, Peilin Zhao, Xin Liu, Min Wu, and Xiao-Li Li. Learning optimal social dependency for
recommendation. arXiv preprint arXiv:1603.04522, 2016.
Aditya Krishna Menon, Krishna-Prasad Chitrapura, Sachin Garg, Deepak Agarwal, and Nagaraj
Kota. Response prediction using collaborative filtering with hierarchies and side-information. In
KDD, 2011.
Rajhans Mishra, Pradeep Kumar, and Bharat Bhasker. A web recommendation system considering
sequential information. Decision Support Systems, 2015.
Xia Ning and George Karypis. Slim: Sparse linear methods for top-n recommender systems. In
ICDM, 2011.
Steffen Rendle. Factorization machines. In ICDM, 2010.
Steffen Rendle and Lars Schmidt-Thieme. Online-updating regularized kernel matrix factorization
models for large-scale recommender systems. In Recsys, 2008.
Steffen Rendle, Christoph Freudenthaler, Zeno Gantner, and Lars Schmidt-Thieme. Bpr: Bayesian
personalized ranking from implicit feedback. In UAI, 2009.
Jasson DM Rennie and Nathan Srebro. Fast maximum margin matrix factorization for collaborative
prediction. In ICML, 2005.
Badrul Sarwar, George Karypis, Joseph Konstan, and John Riedl. Item-based collaborative filtering
recommendation algorithms. In WWW, 2001.
Markus Schedl. The lfm-1b dataset for music retrieval and recommendation. In ICMR, 2016.
Peter Sunehag, Richard Evans, Gabriel Dulac-Arnold, Yori Zwols, Daniel Visentin, and Ben Cop-
pin. Deep reinforcement learning with attention for slate markov decision processes with high-
dimensional states and actions. arXiv preprint arXiv:1512.01124, 2015.
Nima Taghipour and Ahmad Kardan. A hybrid web recommender system based on q-learning. In
SAC, 2008.
Jiaxi Tang and Ke Wang. Personalized top-n sequential recommendation via convolutional sequence
embedding. In WSDM, 2018.
Qinyong Wang, Hongzhi Yin, Zhiting Hu, Defu Lian, Hao Wang, and Zi Huang. Neural memory
streaming recommender networks with adversarial training. In KDD, 2018.
Weiqing Wang, Hongzhi Yin, Shazia Sadiq, Ling Chen, Min Xie, and Xiaofang Zhou. Spore: A
sequential personalized spatial item recommender system. In ICDE, 2016.
Jason Weston, Samy Bengio, and Nicolas Usunier. Wsabie: Scaling up to large vocabulary image
annotation. In IJCAI, 2011.
Chao-Yuan Wu, Amr Ahmed, Alex Beutel, Alexander J Smola, and How Jing. Recurrent recom-
mender networks. In WSDM, 2017.
Yao Wu, Christopher DuBois, Alice X Zheng, and Martin Ester. Collaborative denoising auto-
encoders for top-n recommender systems. In ICDM, 2016.
Carl Yang, Lanxiao Bai, Chao Zhang, Quan Yuan, and Jiawei Han. Bridging collaborative filtering
and semi-supervised learning: a neural approach for poi recommendation. In KDD, 2017.
Ruiyi Zhang, Chunyuan Li, Changyou Chen, and Lawrence Carin. Learning structural weight un-
certainty for sequential decision-making. arXiv preprint arXiv:1801.00085, 2017.
10
Under review as a conference paper at ICLR 2020
Shuai Zhang, Lina Yao, Aixin Sun, Sen Wang, Guodong Long, and Manqing Dong. Neurec: On
nonlinear transformation for personalized ranking. arXiv preprint arXiv:1805.03002, 2018.
Xiangyu Zhao, Liang Zhang, Zhuoye Ding, Long Xia, Jiliang Tang, and Dawei Yin. Recom-
mendations with negative feedback via pairwise deep reinforcement learning. arXiv preprint
arXiv:1802.06501, 2018.
Xiaoxue Zhao, Weinan Zhang, and Jun Wang. Interactive collaborative filtering. In CIKM, 2013.
Guanjie Zheng, Fuzheng Zhang, Zihan Zheng, Yang Xiang, Nicholas Jing Yuan, Xing Xie, and
Zhenhui Li. Drn: A deep reinforcement learning framework for news recommendation. In WWW,
2018.
Jingbin Zhong and Xiaofeng Zhang. Wasserstein autoencoders for collaborative filtering. arXiv
preprint arXiv:1809.05662, 2018.
11
Under review as a conference paper at ICLR 2020
A Appendix
Algorithm 1: CF-SFL training with stochastic optimization
1:	Input: A user-item matrix X and labeled pairs D, the unrolling step T, the size of batch b.
2:	Output: Recommender πθ, reward estimator Rφ, and feedback generator Fψ
3:	Initialization: randomly initialize θ, φ and ψ;
/* stage 1: pretrain the recommender */
4:	while not converge do
5:	Sample a batch of {xi, ai}b=ι from D;
6:	Update θ via minimizing Lsup .
7:	end while
/* stage 2: pretrain the reward estimator */
8:	while not converge do
9:	Sample a batch of {xi, ai}b=ι from D and calculate {R(si, ai)}b=ι;
10:	Sample another batch of user {xi}ib=1 and set vi = 0
11:	Infer the recommended items {ai}ib=1 and calculate {R(si, ai)}ib=1;
12:	Update φ via maximizing (8).
13:	end while
/* stage 3: alternative train all the modules */
14:	while not converge do
15:	Sample a batch of {xi, ai}b=ι from D, initialize feedback embedding v0 = 0;
/* update recommender and feedback generator */
16:	Feed {xi}ib=1 and V (0) into the recommender and infer {aiT}ib=1 through a T-step recurrent
structure.
17:	Collect the corresponding reward {R(siT , aiT )}ib=1
18:	Update θ and ψ via minimizing (7).
/* reward estimator update step */
19:	Sample a batch of {xi, ai}b=ι from D, and calculate {R(si, ai)}b=ι;
20:	Sample a batch of {xi}ib=1, infer the recommended items {aiT}ib=1 and calculate
{R(si, aiT)}ib=1;
21:	Update φ via maximizing (8)
22:	end while
A.1 Fusion function
Here we give a detail description of the fused function we have proposed. A straight-forward way
to build the fusion function h(xi, ai) is to concatenate xi and ai, and feed it into a linear layer to
learn a lower dimensional representation. However, in practice this method is infeasible since the
dimension of items, M, is extremely high and the usage of the concatenation will make the problem
even worse. To this end, we introduce a sparse layer. This layer includes a lookup table B ∈ RM×d.
Once we have inferred the the recommended items ai based on the observation xi, we build the the
fused input as
1M
h(Xi, ai) = ∣χ-∣)j 1 δ(Xj)Bj +
(16)
where δ is the Dirac Delta function and takes value 1 if Xij = 1, |Xi| is number of 1 in Xi. The
parameters of the lookup table will be automatically learned during the training phrase. We show an
example to illustrate the working scheme for the proposed fusion function in Figure 5. The benefits
for the proposed approach can be summarized as two folds: 1) it reduce the computational cost of
the standard linear transformation under the general sparse set up and saves number of parameters in
our proposed adversarial learning framework; 2) This lookup table is shared across the observation
and the recommended items, building a unified space for the users existing preference and missing
preference. Empirically such shared knowledge boosts the performance of our CF-SFL framework.
12
Under review as a conference paper at ICLR 2020
Figure 5: An example of the our fused function working scheme. The user behavior xi and the recommended
items ai share the same lookup table B. [-0.04, 0.08] is the fused input for the given example. This method
works efficient if xi and ai are sparse.
13