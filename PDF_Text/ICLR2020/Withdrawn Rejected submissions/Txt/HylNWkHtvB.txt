Under review as a conference paper at ICLR 2020
Domain-independent Dominance of Adaptive
Methods
Anonymous authors
Paper under double-blind review
Ab stract
From a simplified analysis of adaptive methods, we derive AvaGrad, a new opti-
mizer which outperforms SGD on vision tasks when its adaptability is properly
tuned. We observe that the power of our method is partially explained by a decou-
pling of learning rate and adaptability, greatly simplifying hyperparameter search.
In light of this observation, we demonstrate that, against conventional wisdom,
Adam can also outperform SGD on vision tasks, as long as the coupling between its
learning rate and adaptability is taken into account. In practice, AvaGrad matches
the best results, as measured by generalization accuracy, delivered by any existing
optimizer (SGD or adaptive) across image classification (CIFAR, ImageNet) and
character-level language modelling (Penn Treebank) tasks. This later observation,
alongside of AvaGrad’s decoupling of hyperparameters, could make it the preferred
optimizer for deep learning, replacing both SGD and Adam.
1	Introduction
Deep network architectures are becoming increasingly complex, often containing parameters that
can be grouped according to multiple functionalities, such as gating, attention, convolution, and
generation. Such parameter groups should arguably be treated differently during training, as their
gradient statistics might be highly distinct. Adaptive gradient methods designate parameter-wise
learning rates based on gradient histories, treating such parameters groups differently and, in principle,
promise to be better suited for training complex neural network architectures.
Nonetheless, advances in neural architectures have not been matched by progress in adaptive gradient
descent algorithms. SGD is still prevalent, in spite of the development of seemingly more sophisticated
adaptive alternatives, such as RMSProp (Dauphin et al., 2015) and Adam (Kingma & Ba, 2015). Such
adaptive methods have been observed to yield poor generalization compared to SGD in classification
tasks (Wilson et al., 2017), and hence have been mostly adopted for training complex models (Vaswani
et al., 2017; Arjovsky et al., 2017). For relatively simple architectures, such as ResNets (He et al.,
2016a) and DenseNets (Huang et al., 2017), SGD is still the dominant choice.
At a theoretical level, concerns have also emerged about the current crop of adaptive methods.
Recently, Reddi et al. (2018) has identified cases, even in the stochastic convex setting, where Adam
(Kingma & Ba, 2015) fails to converge. Modifications to Adam that provide convergence guarantees
have been formulated, but have shortcomings. AMSGrad (Reddi et al., 2018) requires non-increasing
learning rates, while AdamNC (Reddi et al., 2018) and AdaBound (Luo et al., 2019) require that
adaptivity be gradually eliminated during training. Moreover, while most of the recently proposed
variants do not provide formal guarantees for non-convex problems, the few current convergence rate
analyses in the literature (Zaheer et al., 2018; Chen et al., 2019) do not match SGD’s. Section 3 fully
details the convergence rates of the most popular Adam variants, along with their shortcomings.
Our contribution is marked improvements to adaptive optimizers, from both theoretical and practical
perspectives. At the theoretical level, we focus on convergence guarantees, deriving new algorithms:
•	Delayed Adam. Inspired by Zaheer et al. (2018)'s analysis of Adam, Section 4 proposes a simple
modification for adaptive gradient methods which yields a provable convergence rate of O(1/√T)
in the stochastic non-convex setting - the same as SGD. Our modification can be implemented
by swapping two lines of code and preserves adaptivity without incurring extra memory costs.
To illustrate these results, we present a non-convex problem where Adam fails to converge to
1
Under review as a conference paper at ICLR 2020
a stationary point, while Delayed Adam - Adam with our proposed modification - ProVably
converges with a rate of O (1 / √T).
•	AvaGrad. Inspecting the conVergence rate of Delayed Adam, we show that it would improVe with
an adaptive global learning rate, which self-regulates based on global statistics of the gradient
second moments. Following this insight, Section 5 proposes a new adaptive method, AvaGrad,
whose hyperparameters decouple learning rate and adaptability.
Through extensive experiments, Section 6 demonstrates that AvaGrad is not merely a theoretical
exercise. AvaGrad performs as well as both SGD and Adam in their respectively favored usage
scenarios. Along this experimental journey, we happen to disprove some conventional wisdom,
finding adaptive optimizers, including Adam, to be superior to SGD for training CNNs. The caveat is
that, excepting AvaGrad, these methods are sensitive to hyperparameter values. AvaGrad is a uniquely
attractive adaptive optimizer, yielding near best results over a wide range of hyperparameters.
2	Preliminaries
2.1	Notation
For vectors a = [a1,a2,... ],b = [bi, b2,... ] ∈ Rd, we use the following notation: ɪ for element-
wise division (ɪ =[(,言，...]),√ɑ for element-wise square root (√α = [√ai, √02,... ]), a + b
for element-wise addition (a + b = [a1 + b1, a2 + b2, . . . ]), a b for element-wise multiplication
(a Θ b = [a1b1,a2b2,... ]). Moreover, ∣a∣ is used to denote the '2-norm: other norms will be
specified whenever used (e.g., ∣a∣∞).
For subscripts and vector indexing, we adopt the following convention: the subscript t is used to
denote an object related to the t-th iteration of an algorithm (e.g., Wt ∈ Rd denotes the iterate at time
step t); the subscript i is used for indexing: Wi ∈ R denotes the i-th coordinate of W ∈ Rd. When
used together, t precedes i: Wt,i ∈ R denotes the i-th coordinate ofWt ∈ Rd.
2.2	Stochastic Non-Convex Optimization
In the stochastic non-convex setting, we are concerned with the optimization problem:
min f(w) = Es〜D [fs(w)]
w∈Rd
(1)
where D is a probability distribution over a set S of “data points”. We also assume that f is M -smooth
in w , as is typically done in non-convex optimization:
∀ w, w0 f (w0) ≤ f (w) + Wf(W), w0 - Wi + MM ∣∣w - w0k2
(2)
Methods for stochastic non-convex optimization are evaluated in terms of number of iterations or
gradient evaluations required to achieve small loss gradients. This differs from the stochastic convex
setting where convergence is measured w.r.t. suboptimality f(W) - minw∈Rd f(W). We assume
that the algorithm takes a sequence of data points S = (s1, . . . , sT) from which it deterministically
computes a sequence of parameter settings W1, . . . , WT together with a distribution P over {1, . . . ,T}.
We say an algorithm has a convergence rate of O(g(T)) if E S〜DT ∣^∣Vf (Wt)『] ≤ O(g(T))
t〜P(t∣S) L
where, as defined above, f (W) = Es〜D [fs(w)].
We also assume that the functions fs have bounded gradients: there exists some G∞ such that
∣Vfs(W)∣∞ ≤ G∞ for all s ∈ S and W ∈ Rd. Throughout the paper, we also let G2 denote an
upper bound on ∣Vfs(W)∣.
3	Related Work
Here we present a brief overview of optimization methods commonly used for training neural
networks, along with their convergence rate guarantees for stochastic smooth non-convex problems.
2
Under review as a conference paper at ICLR 2020
We consider methods which, at each iteration t, receive or compute a gradient estimate:
gt := Vfst (Wt), st 〜D	⑶
and perform an update of the form:
Wt+1 = Wt - at ∙ ηt Θ mt
(4)
where αt ∈ R is the global learning rate, ηt ∈ Rd are the parameter-wise learning rates, and
mt ∈ Rd is the update direction, typically defined as:
mt = β1,tmt-1 + (1 - β1,t)gt	and m0 = 0.
(5)
Non-momentum methods such as SGD, AdaGrad, and RMSProp (Dauphin et al., 2015; Duchi et al.,
2011) have mt = gt (i.e., β1,t = 0), while momentum SGD and Adam (Kingma & Ba, 2015) have
β1,t ∈ (0, 1). Note that while αt can always be absorbed into ηt, representing the update in this form
will be convenient throughout the paper.
SGD uses the same learning rate for all parameters, i.e., η = ~. Although SGD is simple and offers
no adaptation, it has a convergence rate of O(1/√T) with either constant, increasing, or decreasing
learning rates (Ghadimi & Lan, 2013), and is widely used when training deep networks, especially
CNNs (He et al., 2016a; Huang et al., 2017). At the heart of its convergence proof is the fact that
Est [at ∙ ηt Θ gt] = at ∙ Vf(Wt).
Popular adaptive methods such as RMSProp (Dauphin et al., 2015), AdaGrad (Duchi et al., 2011),
and Adam (Kingma & Ba, 2015) have η = √^+e, where Vt ∈ Rd is given by:
vt = β2,tvt-1 + (1 - β2,t)gt* 1 2 3 4 5 6 7 8 9 and v0 = 0.	(6)
As vt is an estimate of the second moments of the gradients, the optimizer designates smaller learning
rates for parameters with larger uncertainty in their stochastic gradients. However, in this setting
ηt and st are no longer independent, hence Est [at ∙ ηt Θ gt] = at ∙ Est [ηt] Θ Vf (wt). This “bias”
can cause RMSProp and Adam to present convergence issues, even in the stochastic convex setting
(Reddi et al., 2018).
Recently, Zaheer et al. (2018) showed that, with a constant learning rate, RMSProp and Adam have
a convergence rate of O(σ2 + 1/T), where σ2 = supw∈RdEs〜D [kVfs(W)-Vf(w)k2], hence
their result does not generally guarantee convergence. Chen et al. (2019) showed that AdaGrad and
AMSGrad enjoy a convergence rate of O (log T/ √T) when a decaying learning rate is used. Note
that both methods constrain ηt in some form, the former with β2,t = 1 - 1/t (adaptability diminishes
with t), and the latter explicitly enforces vt ≥ vj for all j < t (ηt is point-wise non-increasing).
In both cases, the method is less adaptive than Adam, and yet analyses so far have not delivered a
convergence rate that matches SGD’s.
4	SGD-like Convergence without Constrained Rates
We first take a step back to note the following: to
show that Adam might not converge in the stochastic
convex setting, Reddi et al. (2018) provide a stochas-
tic linear problem where Adam fails to converge
w.r.t. suboptimality. Since non-convex optimization
is evaluated w.r.t. norm of the gradients, a different
instance is required to characterize Adam’s behavior
in this setting.
The following result shows that even for a quadratic
problem, Adam indeed does not converge to a sta-
tionary point:
Theorem 1.	For any ≥ 0 and constant β2,t =
β2 ∈ [0, 1), there is a stochastic convex optimization
problem for which Adam does not converge to a stationary point.
Algorithm 1 DELAYED ADAM
Input： wι ∈ Rd, at, e > 0, βι,t, β2,t ∈ [0,1)
1: Set m0 = 0, v0 = 0
2: for t = 1 to T do
3:	Draw st 〜D
4:	Compute gt = Vfst (Wt)
5:	mt = β1,tmt-1 + (1 - β1,t)gt
6:	ηt = √vt-1 三
7:	Wt+1 = Wt - at ∙ ηt Θ mt
8:	vt = β2,tvt-1 + (1 - β2,t)gt2
9: end for
3
Under review as a conference paper at ICLR 2020
Proof. The full proof is given in Appendix A. The argument follows closely from Reddi et al. (2018),
where we explicitly present a stochastic optimization problem:
min	f(w)	:=	Es〜D [fs(w)]	fs(w)	=	(C*,WithPrObability	P =	⅛+1	⑺
w∈[0,1]	-w, otherwise
We shOw that, fOr large enOugh C (as a functiOn Of δ, , β2), Adam will mOve tOwards w = 1 where
Vf ⑴ =δ, and that the constraint W ∈ [0,1] does not make W = 1 a stationary point.	□
This result, like the One in Reddi et al. (2018), relies On the fact that ηt and st are cOrrelated: uPOn a
draw of the rare sample CW, the learning rate η decreases significantly and Adam takes a small
step in the correct direction. On the other hand, a sequence of common samples increases ηt and
Adam moves faster towards W = 1.
Instead of enforcing ηt to be point-wise non-increasing in t (Reddi et al., 2018), which forces the
optimizer to take small steps even for a long sequence of common samples, we propose to simply
have ηt be independent of st . As an extra motivation for this approach, note that successful proof
strategies (Zaheer et al., 2018) to analyzing adaptive methods include the following step:
Est [ηt gt] = Est [(ηt-1 + ηt - ηt-1) gt] = ηt-1 Vf(Wt) + Est [(ηt - ηt-1) gt]	(8)
where bounding Est [(ηt - ηt-1) gt], seen as a form of bias, is a key part of recent convergence
analyses. Replacing ηt by ηt-1 in the update equation of Adam removes this bias and can be
implemented by simply swapping lines of code (updating η after W), yielding a simple convergence
analysis without hindering the adaptability of the method in any way. Algorithm 1 provides pseudo-
code when applying this modification, highlighted in red, to Adam, yielding Delayed Adam. The
following Theorem shows that this modification is enough to guarantee a SGD-like convergence rate
of O(1/√T) in the stochastic non-convex setting for general adaptive gradient methods.
Theorem 2.	Consider any optimization method which updates parameters as follows:
Wt+1 = Wt — at ∙ ηt Θ gt	(9)
where gt := Vfst (Wt), St 〜 D, and at, η are independent of St.
Assume that f(wι) — f (w?) ≤ D, f (w) = Es〜D [fs(w)] is M-smooth, and IlVfs(W)k∞ ≤ G∞
for all S ∈ S, W ∈ Rd. Moreover, let Z = PtT=1 at mini ηt,i.
For at = YtJTMG2 , if p(Z|st) = P(Z) forall St ∈ S, then:
∞
E	Se	h∣Vf(Wt)k2i	≤	rMDG∞	∙ ES〜DT	"pP=11 + γ2kηtk2#	(10)
t〜P(t∣s) L	」2	2T	[工t=ι Yt mini ηt,i _
where P assigns probabilities p(t) X at ∙ min ηti.
Proof. The full proof is given in Appendix B, along with analysis for the case with momentum
βι,t ∈ (0,1) in Appendix B.1, and in particular βι,t = βι∕√t, which yields a similar rate. □
The convergence rate depends on Iηt I and mini ηt,i, which are random variables for Adam-like
algorithms. However, if there are constants H and L such that 0 < L ≤ ηt,i ≤ H < ∞ for
all i and t, then a rate of O(1∕√T) is guaranteed. This is the case for Delayed Adam, where
1/(G2 + ) ≤ ηt,i ≤ 1/ for all t and i. Theorem 2 also requires that at and ηt are independent of
St, which can be assured to hold by applying a “delay” to their respective computations, if necessary
(i.e., replacing ηt by ηt-1, as in Delayed Adam).
Additionally, the assumption thatP(Z|St) = P(Z), meaning that a single sample should not affect the
distribution of Z = PtT=1 at mini ηt,i , is required since P is conditioned on the samples S (unlike in
standard analysis, where Z = PtT=1 at and at is deterministic), and is expected to hold as T → ∞.
Practitioners typically use the last iterate WT or perform early-stopping: in this case, whether the
assumption holds or not does not affect the behavior of the algorithm. Nonetheless, we also show
in Appendix B.2 a similar rate that does not require this assumption to hold, which also yields a
O(1∕√T) convergence rate taken that the parameter-wise learning rates are bounded from above and
below.
4
Under review as a conference paper at ICLR 2020
5 AvaGrad: An Adaptive Method with Adaptive Variance
Now, we consider the implications of Theorem 2
for Delayed Adam, where η = √ν 1 十：,and hence
1/(G2 + ) ≤ ηt,i ≤ 1/ for all t and i.
For a fixed γt = γ, chosen a-priori (that is, without
knowledge of the realization of {ηt}tT=1), we can
optimize γ to minimize the worst-case rate using
kηt k2 ≤ d/2 and mini ηt,i ≥ G2 + . This yields
Y* = O(e), and a convergence rate of O(1∕e), SUg-
gesting that, at least in the worst case, should be
chosen to be as large as possible, and the learning
rate α shoUld scale linearly with e (hence, also being
large).
Algorithm 2 AVAGRAD
Input: wι ∈ Rd, αt, e > 0, βι,t, β2,t ∈ [0,1)
1:	Set m0 = 0, v0 = 0
2:	for t = 1 to T do
3:	Draw St 〜D
4:	Compute gt = Vfst (Wt)
5:	mt = β1,tmt-1 + (1 - β1,t)gt
6:	ηt = √V-i+e
7:	wt+ι= Wt- αt ∙ kηt∕√dk- Θ mt
8:	vt = β2,tvt-1 + (1 - β2,t)gt2
9:	end for
What if we allow Yt to vary in each time step?
For example, choosing Yt = √d∕ ∣∣ηtk yields a convergence rate with a linear dependence on
(T PT=1 mtF)-1 ≤ .(T√d PT=1 ma⅛)-： While using 1∕(G2 + e) ≤ %, ≤ 1/e we see
that in the worst-case this is also O(1∕e), this dependence differs from the one with fixed Yt = Y in
a few aspects. Most notably, if we consider different scalings of η = % 1 ,(Z (e.g., small e and
vt-1 +
varying vt-ι), the convergence rate with fixed Y can get arbitrarily worse, while for Yt = √d∕ ∣∣ηt∣ it
remains unchanged. In particular, for the case d = 1, we have (T PT=ι minijt,i)	= 1, while for
fixed Y we get a dependence on PP=T1+γ ηt, which again can be large if η is either large or small.
2,t=ι γηt
Lastly, multiplying the learning rate by √d∕ ∣∣ηt∣ removes its dependence on e in the worst-case
setting, making the two hyperparameters more separable.
The choice of Yt = √d∕ ∣∣ηt∣, motivated by the above facts, yields a method which we name AvaGrad
一 Adaptive VAriance Gradients, presented as pseudo-code in Algorithm 2 with the proposed scaling
highlighted in red. We call it an “adaptive variance” method since, if we scale up or down the variance
of the gradients, and hence also vt and ηt, the convergence guarantee in Theorem 2 does not change,
while for a fixed learning rate (as is not uncommonly done in practice, except for discrete decays
during training (Zagoruyko & Komodakis, 2016; Merity et al., 2018)) it can get arbitrarily bad.
6 Experiments
6.1	Synthetic Data
To illustrate empirically the implications of Theorem 1 and Theorem 2, we set up a synthetic stochastic
optimization problem with the same form as the one used in the proof of Theorem 1:
min f (w) := E [fs(w)]	fs(w) = (999华、WithProbabiIity	0.002	(“)
w∈[0,1]	-W,	otherwise
This function has a stationary point w? = 9；-(O(O02 ≈ 11, and it satisfies Theorem 1 for βι = 0, β2 =
0.99, e = 10-8. We proceed to perform stochastic optimization with Adam, AMSGrad, and Delayed
Adam, with constant learning rate αt = 10-5. For simplicity, we let P be uniform over (1, . . . , T),
since αt is constant.
Figure 1 shows the progress of t Pto = 1 wt0 and 1 Pto=ι ∣Vf(wt，)『 for each iteration t: as
expected, Adam fails to converge to the stationary point W? , while both AMSGrad and Delayed
Adam converge. Note that Delayed Adam converges significantly faster, likely because it has no
constraint on the learning rates.
5
Under review as a conference paper at ICLR 2020
Figure 1: Plots of Adam, AMSGrad, and Delayed Adam trained on the synthetic example in Equation
11, with a stationary point at w? ≈ 0.5. Left: The expected iterate sampled uniformly from
{w1, . . . , wt}, for each iteration t. As predicted by our theoretical results, Adam moves towards
W = 1 with ∣∣Vf (w)k = 1, while Delayed Adam converges to w?. Right: The expected norm
squared of the gradient, for w randomly sampled from {w1, . . . , wt}. Delayed Adam converges
significantly faster than AMSGrad, while Adam fails to converge.
6.2	Image Classification with CNNs
Our theory suggests that, in the worst case, should be chosen as large as possible, at which point
the learning rate α should scale linearly with it. As a first experiment to assess this hypothesis, we
analyze the interaction between α and when training a Wide ResNet 28-4 (Zagoruyko & Komodakis,
2016) on the CIFAR-10 dataset (Krizhevsky, 2009). Our training follows Zagoruyko & Komodakis
(2016): images are channel-wise normalized, randomly cropped, and horizontally flipped during
training. The learning rate is decayed by a factor of 5 at epochs 60, 120 and 160, and the model is
trained for a total of 200 epochs with a weight decay of 0.0005. Appendix C describes additional
experimental details.
We use a validation set of 5,000 images to evaluate the performance of SGD and different adaptive
gradient methods: Adam, AMSGrad, AdaBound (Luo et al., 2019), AdaShift (Zhou et al., 2019), and
our proposed algorithm, AvaGrad. Additionally, we also assess whether performing weight decay as
proposed in Loshchilov & Hutter (2019) instead of standard L2 regularization positively impacts the
performance of adaptive methods: we do this by also evaluating AdamW and AvaGradW.
We run each adaptive method with different powers of 10 for , from its default value = 10-8 up to
= 100, which is large enough such that adaptability should be almost completely removed from the
algorithm. We also vary the learning rate α of each method with different powers of 10, multiplied by
1 and 5 (e.g., 0.05, 0.1, 0.5, 1.0, . . . ). Figure 2 shows the results for Adam and AvaGrad. Our main
findings are twofold:
•	The optimal for every adaptive method is considerably larger than the values typically used
in practice, ranging from 0.1 (Adam, AMSGrad, AvaGradW) to 10.0 (AvaGrad, AdamW). For
Adam and AMSGrad, the optimal learning rate is α = = 0.1, a value 100 times larger than the
default.
•	All adaptive methods, except for AdaBound, outperform SGD in terms of validation performance.
Note that for SGD the optimal learning rate is α = 0.1, matching the value used in work
such as He et al. (2016a); Zagoruyko & Komodakis (2016); Xie et al. (2017), which presented
state-of-the-art results at time of publication.
However, the fact that adaptive methods outperform SGD in this setting is not conclusive, since
they are executed with more hyperparameter settings (varying as well as α). Moreover, the main
motivation for adaptive methods is to be less sensitive to hyperparameter values; performing an
extensive grid search defeats their purpose.
Aiming for a fair comparison between SGD and adaptive methods, we also train a Wide ResNet
28-10 on both CIFAR-10 and CIFAR-100, evaluating the test performance of each adaptive method
with its optimal values for α and found in the previous experiment. For SGD, we confirmed that
6
Under review as a conference paper at ICLR 2020
Adam
ie-o 8 ie-oβ OQoOl o.oι 1.0 ιoo.o
Figure 2: Validation error of a Wide ResNet 28-4 trained on the CIFAR-10 dataset with Adam (left)
and AvaGrad (right), for different values of the learning rate α and parameter , where larger yields
less adaptability. Best performance is achieved with small adaptability ( > 0.001).
Table 1: Test performance of SGD and popular adaptive methods in benchmark tasks. Red indicates
results with the recommended optimizer, following the paper that proposed each model, and any
improved performance is given in blue. The best result for each task is in bold, and numbers in
parentheses present standard deviations of 3 runs for CIFAR.
Method	CIFAR-10 (Test Err %)	CIFAR-100 (Test Err %)	ImageNet (ToP-IVal Err %)	Penn Treebank (Test Bits Per Character)
_ _SGD_ _	J.86(0.O8)_	19.05(0.24)		24.01			 1.238	
Adam	"4(0.MΓ	^18.96(0.21)^	23:45	1.182
AMSGrad	3.90 (0.17)	18.97 (0.09)	23.46	1.187
AdaBound	5.40 (0.24)	22.76 (0.17)	27.99	2.863
AdaShift	4.08 (0.11)	18.88 (0.06)	N/A	1.274
AdamW	4.11 (0.17)	20.13 (0.22)	27.10	1.230
AvaGrad	3.80 (0.02)	18.76 (0.20)	2358	1.179
AvaGradW	3.97 (0.02)	19.04 (0.37)	23.49	1.175
the learning rate α = 0.1 still yielded the best validation performance with the new architecture,
hence the fact that we transfer hyperparameters from the Wide ResNet 28-4 runs does not unfairly
advantage adaptive methods in the comparison with SGD. With a larger network and a different task
(CIFAR-100), this experiment should also capture how hyperparameters of adaptive methods transfer
between tasks and models.
On CIFAR-10, SGD achieves 3.86% test error (reported as 4% in Zagoruyko & Komodakis (2016))
and is outperformed by both Adam (3.64%) and AvaGrad (3.80%). On CIFAR-100, SGD (19.05%)
is outperformed by Adam (18.96%), AMSGrad (18.97%), AdaShift (18.88%), AvaGrad (18.76%),
and AvaGradW (19.04%). We believe these results are surprising, as they show that adaptive methods
can yield state-of-the-art performance when training CNNs as long as their adaptability is correctly
controlled with .
As a final evaluation of the role of adaptability when training convolutional networks, we repeat the
previous experiment on the ImageNet dataset (Russakovsky et al., 2015), training a ResNet 50 (He
et al., 2016b) with SGD and different adaptive methods, transferring the hyperparameters from our
original CIFAR-10 results. Training follows Gross & Wilber (2016): the network is trained for 100
epochs with a batch size of 256, the learning rate is decayed by a factor of 10 at epochs 30, 60 and 90,
and a weight decay of 0.0001 is applied. SGD yields 24.01% top-1 validation error, underperforming
Adam (23.45%), AMSGrad (23.46%), AvaGrad (23.58%) and AvaGradW (23.49%). Again, note
that the hyperparameters used for SGD match the ones in He et al. (2016a), He et al. (2016b) and
Gross & Wilber (2016): an initial learning rate of 0.1 with a momentum of 0.9. Table 1 summarizes.
7
Under review as a conference paper at ICLR 2020
Figure 3: Validation bits-per-character (lower is better) of a 3-layer LSTM with 300 hidden units,
trained on the Penn Treebank dataset with Adam (left) and AvaGrad (right), for different values
of the learning rate α and parameter , where larger yields less adaptability. Best performance is
achieved with high adaptability ( < 0.0001).
6.3	Language Modelling with RNNs
It is perhaps not very surprising that to perform optimally in the image classification tasks studied
previously, adaptive gradient methods required large values of , and hence were barely adaptive.
Here, we consider a task where state-of-the-art results are typically achieved by adaptive methods
with low values for : language modelling with recurrent networks. In particular, we perform
character-level language modelling on Penn Treebank dataset (Marcus et al., 1994; Mikolov et al.,
2010) with LSTMs, following Merity et al. (2018). The model is trained for 500 epochs, and the
learning rate is decayed by 10 at epochs 300 and 400. A batch size of 128, a BPTT length of 150,
and weight decay of 1.2 × 10-6 are used, along with dropout.
We evaluate the validation performance of SGD, Adam, AMSGrad, AdaShift, AdaBound, AdamW,
AvaGrad and AvaGradW with varying learning rate α and adaptability parameter , when training a
3-layer LSTM with 300 hidden units in each layer. Figure 3 shows that, in this task, smaller values
for are indeed optimal: Adam, AMSGrad and AvaGrad performed best with = 10-8. The optimal
learning rates for both Adam and AMSGrad, α = 0.002, agree with the value used in Merity et al.
(2018). Both AvaGrad and AvaGradW performed best with α = 200: the former with = 10-8, the
latter with = 10-5.
Next, we train a 3-layer LSTM with 1000 hidden units per layer (the same model used in Merity et al.
(2018), where it was trained with Adam), choosing values for α, which yielded the best validation
performance in the previous experiment. For SGD, we again confirmed that a learning rate of 20
performed best on the validation set. Table 1 (right column) reports all results.
In this setting, AvaGrad and AvaGradW outperform Adam, achieving bit-per-characters of 1.179 and
1.175 compared to 1.182.
6.4	Hyperparameter Separability and Domain-Independence
One of the main motivations behind AvaGrad is that it removes the dependence between the learning
rate α and the adaptability parameter , at least in the worst-case rate of Theorem 2. Observing the
heatmaps in Figure 2 and 3, we can see that indeed AvaGrad offers more separability between α and ,
when compared to Adam. For example, for ≥ 0.0001, it has little to no interaction with the learning
rate α, as opposed to Adam where the optimal α increases linearly with . For language modelling
on Penn Treebank, the optimal learning rate for AvaGrad was α = 200 for every choice of , while
for image classification on CIFAR-10, we had α = 1.0 for all values of except for ∈ {10-5, 100}.
This suggests that AvaGrad enables a grid search over α and (with quadratic complexity) to be
broken into two line searches over α and separately (linear complexity).
8
Under review as a conference paper at ICLR 2020
7 Conclusion
As neural architectures become more complex, with parameters having highly heterogeneous roles,
parameter-wise learning rates are often necessary for training. However, adaptive methods have both
theoretical and empirical gaps, with SGD outperforming them in some tasks and having stronger
theoretical convergence guarantees. In this paper, we close this gap, by first providing a convergence
rate guarantee that matches SGD’s, and by showing that, with proper hyperparameter tuning, adaptive
methods can dominate in both computer vision and natural language processing tasks. Key to our
finding is AvaGrad, our proposed optimizer whose adaptability is decoupled from its learning rate.
Our experimental results show that proper tuning of the learning rate together with the adaptability of
the method is necessary to achieve optimal results in different domains, where distinct neural network
architectures are used across tasks. By enabling this tuning to be performed in linear time, AvaGrad
takes a leap towards efficient domain-agnostic training of general neural architectures.
References
Martin Arjovsky, SoUmith Chintala, and Leon Bottou. Wasserstein GAN. arXiv e-prints, 2017.
Xiangyi Chen, Sijia Liu, Ruoyu Sun, and Mingyi Hong. On the convergence of a class of adam-type
algorithms for non-convex optimization. ICLR, 2019.
Y. Dauphin, H. de Vries, J. Chung, and Y. Bengio. Rmsprop and equilibrated adaptive learning rates
for non-convex optimization. corrL, 2015.
J. Duchi, E. Hazan, , and Y. Singer. Adaptive subgradient methods for online learning and stochastic
optimization. ICML, 2011.
Saeed Ghadimi and Guanghui Lan. Stochastic First- and Zeroth-order Methods for Nonconvex
Stochastic Programming. SIAM, 2013.
Sam Gross and Martin Wilber. Training and investigating residual nets. https://github.com/
facebook/fb.resnet.torch, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image
recognition. CVPR, 2016a.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual
networks. ECCV, 2016b.
SePP Hochreiter and Jurgen Schmidhuber. Long short-term memory. Neural computation, 1997.
Gao Huang, Zhuang Liu, Laurens van der Maaten, and Kilian Q. Weinberger. Densely connected
convolutional networks. CVPR, 2017.
Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic oPtimization. ICLR, 2015.
Alex Krizhevsky. Learning multiPle layers of features from tiny images. Technical rePort, 2009.
Ilya Loshchilov and Frank Hutter. DecouPled weight decay regularization. 2019.
Liangchen Luo, Xiong, Yuanhao, Liu, Yan, and Xu. Sun. AdaPtive gradient methods with dynamic
bound of learning rate. ICLR, 2019.
Mitchell Marcus, Grace Kim, Mary Ann Marcinkiewicz, Robert MacIntyre, Ann Bies, Mark Ferguson,
Karen Katz, and Britta Schasberger. The Penn treebank: Annotating Predicate argument structure.
In Proceedings of the Workshop on Human Language Technology, 1994.
StePhen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and OPtimizing LSTM
Language Models. arXiv e-prints, 2017.
StePhen Merity, Nitish Shirish Keskar, and Richard Socher. An Analysis of Neural Language
Modeling at MultiPle Scales. arXiv e-prints, 2018.
9
Under review as a conference paper at ICLR 2020
Tomas Mikolov, Martin Karafidt, LUkgs Burget, Jan Honza Cernocky, and Sanjeev KhUdanpur.
Recurrent neural network based language model. INTERSPEECH, 2010.
Sashank J. Reddi, Satyen Kale, and Sanjiv Kumar. On the convergence of adam and beyond. ICLR,
2018.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng
Huang, Andrej Karpathy, Aditya Khosla, Michael S. Bernstein, Alexander C. Berg, and Fei-Fei Li.
Imagenet large scale visual recognition challenge. IJCV, 115(3), 2015.
Nitish Srivastava, Geoffrey E. Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: a simple way to prevent neural networks from overfitting. Journal of Machine Learning
Research, 15(1), 2014.
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. Attention Is All You Need. arXiv e-prints, 2017.
Ashia C. Wilson, Rebecca Roelofs, Mitchell Stern, Nathan Srebro, and Benjamin Recht. The Marginal
Value of Adaptive Gradient Methods in Machine Learning. NIPS, 2017.
Saining Xie, Ross B. Girshick, Piotr Dolldr, Zhuowen Tu, and Kaiming He. Aggregated residual
transformations for deep neural networks. CVPR, 2017.
Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. BMVC, 2016.
Manzil Zaheer, Sashank Reddi, Devendra Sachan, Satyen Kale, and Sanjiv Kumar. Adaptive methods
for nonconvex optimization. NIPS, 2018.
Zhiming Zhou, Qingru Zhang, Guansong Lu, Hongwei Wang, Weinan Zhang, and Yong Yu. Adashift:
Decorrelation and convergence of adaptive learning rate methods. ICLR, 2019.
10
Under review as a conference paper at ICLR 2020
Appendix
A Proof of Theorem 1
Proof. Consider the following stochastic optimization problem:
Wmn"AW)= EgD [fs(w)]	ZS(W)
, with probability P := C⅛+⅜	(12)
otherwise
where C > 1-p > 1 + W v⅞⊂^. Note that V/(w) = pCw - (1 - p), and f is minimized at
w* = 1-P = c-δ	ɪ 2
W = Cp = C(1+δ).
The proof follows closely from Reddi,s linear example for convergence in suboptimality. We assume
w.l.o.g. that βi = 0. Consider:
gt
∆t = wt+i - Wt = -η L 1
Vt + e
9t
-η—,	---
√β2vt-i + (1 - β2')gl + e
(13)
E[∆t]
η
E [wt+i - wt] = -E
gt
√β2vt-i + (1 - β2)g2 + e
=pE
-Cwt
(14)
ββ2vt-1 + (1 - β2)C2w2 + e
'--------------------------Z
{z
Ti
+ (1 - P)E
ββ2vt-i + (1 - β2) + e
`---------------------Z
{z
T2
η
1
where the expectation is over all the randomness in the algorithm UP to time t, as all expectations to
follow in the proof. Note that Ti = 0 for Wt = 0. For Wt > 0 we bound Ti as follows:
Ti ≥
-Cwt
-1
(15)
Hence, T1 ≥ mm(0, √=) = Vi/的 .
As for T2, we have, from Jensen,s inequality:
E [T2] ≥
1
√β2E [vt-1] + 1 - β2 + e
(16)
Now, remember that vt-i = (1 - β2) Pt-1 βt-i-1g2, hence:
t-i
E [vt-i]
= (1-β2)Eβt-i-1E [g2]
i=1
t-i
=(1 - β2) X βt-i-i (1 - P + pC2E [w2])
i=1
t-i
≤ (1 - β2) Xβt-i-i (1 -p + pC2)
i=1
≤ (1 -βt-1)(1-P+pC2) ≤ (1 + δ)c2
(17)
and thus:
E [T2] ≥
1
√β2(l + δ)C +1 - β2 + e
(18)
11
Under review as a conference paper at ICLR 2020
Plugging in the bounds for T1 and T2 in Equation 14:
E[∆t]>1 + δ -1 A 1 + δ
~~Γ≥ - C+1 √1-β2 + - C+1
1
√β2(1 + δ)C +1 - β2 + e
(19)
Hence, for large enough C, and C》δ, w? ≈ ι++δ
while the above quantity becomes non-
negative, and hence E [wt] ≥ w1. In other words, Adam will, in expectation, drift away from the
stationary point, towards W = 1, at which point ∣∣Vf ⑴k2 = δ. For example, δ = 1 implies that
limT →∞ T PT1 E ∣Vf (wt)∣2 = 1. To see that w = 1 is not a stationary point due to the
feasibility constraints, check that Vf (1) = 1 > 0: that is, the negative gradient points towards the
feasible region.
□
B Proof of Theorem 2
Proof. Throughout the proof we use the following notation for clarity:
Ht = max ηti	Lt = min ηti	(20)
ii
We start from the fact that f is M -smooth:
f (Wt+1) ≤ f(wt) + hVf(wt), Wt+1 - Wti + MM I∣wt+1 - Wtk2	(21)
and use the update wt+ι = Wt 一 at ∙ η Θ m√
α2M	2
f (Wt+1) ≤ f (Wt) — at Nf(Wt), mt Θ ηt +———Ilmt Θ ηt∣∣
≤ f(wt) - αt hVf(wt), mt ηti +
αt2M G2∞ kηtk2
2
≤ f(Wt) - αtβ1,t hVf (Wt), mt-1	ηti - αt(1 - β1,t) hVf (Wt), gt ηti +
αt2MG2∞ kηtk2
≤ f(wt) + αtβι,t IlVf(Wt)k ∙ I∣mt-1 Θ ηt∣∣ - at(1 - βι,J Wf(wt),gt Θ ηt +
2
αt2MG2∞ kηtk2
2
≤ f(Wt) + αtβ1,tG22Ht - αt (1 - β1,t) hVf(Wt), gt	ηti +
αt2MG2∞ kηtk2
2
(22)
where in the first step we used the fact that Imt Θ ηtI2 = Pid=1 mt2,iηt2,i ≤ maxj mt2,j Pid=1 ηt2,i ≤
G2∞ IηtI2, in the second we used mt = β1,tmt-1+(1-β1,t)gt, in the third we used Cauchy-Schwarz,
and in the fourth we used IVf(Wt)I ≤ G2, along with kmt-ι θ ηtk = JPd=I m2-ι,iη2,i ≤
maxj ηt,j Pid=1 mt2-1,i ≤ G2Ht.
Now, taking the expectation over st, and using the fact that Est [gt] = Vf(Wt), and that ηt, at are
both independent of st :
Est [f (Wt+1)] ≤ f (Wt) + atβι,tG2Ht - at(1 - βι,t)(Vf(Wt), Vf(Wt) Θ W + α2MG∞ knt『
≤ f (Wt) + atβι,tG2Ht - at(1 - β1) ∣Vf (Wt)∣2 Lt + a2MG∞ kη∙
2	(23)
where in the second step we used β1,t ≤ β1 and hVf(Wt), Vf(Wt) Θ ηti = Pid=1 Vf(W)i2ηt,i ≥
minj ηt,j Pid=1Vf(W)i2 = Lt IVf(W)I2.
Re-arranging, we get:
atLt(1 - β1) IVf (Wt)I2 ≤ f(Wt) - Est [f (Wt+1)] + at β1,t G22 Ht +
a2MG∞kηt/
2
(24)
12
Under review as a conference paper at ICLR 2020
Now, defining p(t) = αtL, where Z = P= αtLt, dividing by Z(1 一 βι) and summing over t:
T
X p(t) kVf (wt)k2 ≤
t=1
Z(11 β ) X (f(wt) 一 Est [f (wt+ι)] + αtβι,tG2Ht + α2MG∞ kηtk2
Z(1 - β1) t=1	2
(25)
Now, taking the conditional expectation over all samples S given Z :
T
ES X p(t) kVf(wt)k2 Z
t=1
1T
≤ Z(1一 员) (X(ES [f (wt)∣Z] - ES $ [f (wt+ι)] ∣Z])
+ XE αtβι,tG2Ht + a2MGjkntk2 ∣z )
t=1
1T
≤ Z(I _ β ) (X (ES [f (wt)∣Z] - Es [f (wt+ι)∣Z])
Z (1 一 β1 ) t=1
+ XE αtβι,tG2Ht + α2MG∞ knt『∣Z )
t=1
=,U 1 a、(f(w1) - ES [f (wT +1)∖Z]
Z(1 一 β1)
+ XE αtβι,tG2Ht + α2MG∞kηtk2 ∣z )
t=1
(26)
where in the second step we used ES [Est [f(wt+1)] ∖Z] = ES [f(wt+1)] which follows from the
assumption thatp(Z∖st) = p(Z), and the third step follows from a telescoping sum, along with the
fact that ES [f (w1)] = f(w1). Now, using f(w1) 一 ES [f(wT+1)∖Z] ≤ f(w1) 一 f(w?) ≤D:
T
ES X p(t) kVf(wt)k2 ∣∣Z
t=1
≤ ZΓ⅛(D + XES 卜ι,tG2Ht + α2MG∞ kηtk2 IZ )
(27)
Then, taking the expectation over Z :
T
ES Xp(t) kVf(wt)k2 ≤E
t=1
1 TD
Z(1-βι) X (T + αtβ1,tG2Ht +
αt2MG2∞kηtk2
))
(28)
2
Now, let αt
YtVZTM⅛:
T
ES Xp(t)kVf(wt)k2
t=1
≤E
T + Ytβι,tG2Ht↑Jtmg2 + Tγ2 kηtk2)]
τ ∙ z(i - βι) X(1+γtβι,tHtr~MDr+γ2 帆『)#
(29)
where We used the fact that G? ≤ G∞ √d.
13
Under review as a conference paper at ICLR 2020
Now, recall that Z = PT=I αtLt =qTMG曾 PT=I YtLt：
T
ES X p(t) lVf (wt)l2 ≤ES
t=1
1	JMDG∞
(1-βι)V	2T
PT=I (1 + ]tBι,tHt J2MG2 + γ2 kηtk2
Pt=ι YtLt
1	JMDG∞ e
(1 — βι) V	2T	S
PT=ι (1 + Ytβι,tHt J2MG2 + γ2 llηtk2
t=1 γtLt
(30)
Setting βι,t = βι = 0 and checking that PT=I p(t) ∣∣Vf (wt)∣2
Et"kVf(Wt)k
MDG∞ ∙ Esr
=Et 〜p(t∣sjkVf(Wt)『]:
PT=I 1+ Y kηtk2
Pt=ι YtLt
(31)
Recalling that Lt = mini ηt,i proves the claim.
□
B.1 The case with first-order momentum
For the case βι,t > 0, assume that βι,t = √ in Equation 30:
T
ES X p(t) IVf (Wt)I2
t=1
≤
二 L ∙ Es
PL (1 + YtHt√ J2MG2 + Y2 kntk2
Pt=ι YtLt
≤
1	JMDG∞ E
(1 — β1) V	2T	S
βιJ2MG2 (maxt YtHt) PT=I √1t + PT=I (1 + Y2 Ilntk2)
t=1 YtLt
≤
1 JMDGlo E
(1 — β1) V	2T	S
where in the last step We used PT=I √1t ≤ 2 √T.
2TβιJ2HF(maxt YtHt) + PT=I (1 + γ2 Ilnt『
Pt=I YtLt
(32)
Similarly to the guarantee in Equation 31, we can show a O(1∕√T) convergence rate if we further
assume that there exist constants H and L such that 0 < L ≤ nt,i ≤ H < ∞ for all i and t (i.e.,
the parameter-wise learning rates are bounded away from zero and also from above), and that Yt is
bounded similarly. For example, having Yt = Y yields:
M X WU1俨 V 1	rMDG∞ M	2THYe1qɪ^2+Pt=(1+Y2dH2)
ES 邑p(t) kVf(Wt)k J ≤ GFVF- ∙Es [--------------------p=iyl--------------
1	IMDG∞ 1 _1	,,c ∣2dGl2	2t9∖
=L(1-βι) ∖∣^Γ~ ∙ (Y	+2Hβ1V MD + YdH)
(33)
where in the first step we used Int I2 ≤ dH2, Ht ≤ H, and Lt ≥ L.
Note that for any constant Y the above is O(1/√T).
14
Under review as a conference paper at ICLR 2020
B.2 The case with unconditional distribution over iterates
To show a similar bound without the assumption thatp(Z|st) = p(Z), we can alternatively bound Lt
and kηt k using the worst case over possible samples S. From (24) we have, with β1,t = 0:
(inf Lt) αt(1 - βι) ∣∣Vf (wt)『≤ f(wj- Est [f (wt+ι)] +
α2LG∞ (SUpS llηtk2)
2
(34)
Now, define p(t) = αt (inf S Lt) /Z with Z = PtT=1 αt (infS Lt) instead. As long as αt does not
depend on S, Z is no longer a random variable. Following the same steps as above leads to the
following:
⅛pdkVf(Wt)k
MDG∞
~2T~
PT=ι1 + γ2 (sups llηtk2
-Pt=I Yt (infS Lt)
(35)
In particular, if there are constants H and L such that 0 < L ≤ ηt,i ≤ H < ∞ for all i and t, can
bound sUpS lηt l2 ≤ dH2 and infS Lt ≥ L, yielding:
ES〜DT
t 〜P(t)
h∣Vf(wt)k2i ≤ ʌ/MDG2∞
PLI 1+ Y dH2
L Pt=ι Yt
(36)
Hence a O(1/√T) follows as long as Yt can be upper and lower bounded accordingly by constants.
C Experimental Details
C.1 CIFAR
The CIFAR-10 and CIFAR-100 datasets (Krizhevsky, 2009) consist of 60,000 RGB images with
32 × 32 pixels, with a standard split of 50,000 and 10,000 training and test images, sampled from
10 and 100 classes, respectively. We pre-process the dataset with channel-wise normalization using
statistics from the training set, and for data-augmentation we flip each image horizontally with 50%
probability, along with a random cropping, achieved by first padding 4 black pixels to each edge of
the image and then extracting a random 32 × 32 crop.
For the hyperparameter exploration with a Wide ResNet 28-4, we measure performance on a validation
set of 5,000 images sampled from the training set, while for the final results with the Wide ResNet
28-10, we report results on the test set.
Each Wide ResNet is trained with a batch size of 128 for a total of 200 epochs on a single GPU, with
the learning rate being decayed by a factor of 5 at epochs 60, 120 and 160. A weight decay of 0.0005
is used with every optimization method. For SGD, we use a momentum of 0.9, while for adaptive
methods, we use β1 = 0.9, β2 = 0.999, as suggested in their respective papers. For AdaBound, we
use the default α* = 0.1 and Y = 10-3. For AdaShift, we use the default n = 10.
C.2 ImageNet
The ILSVRC 2012 datasets (Russakovsky et al., 2015) is composed of 1.2M training and 50,000
validation RGB images, sampled from a total of 1,000 classes. We train a ResNet 50 (He et al.,
2016b), and report results using single-crops of 224 × 224 images for evaluation. We follow Gross
& Wilber (2016) for data-augmentation and training specifics: in particular, we decay the learning
rate by a factor of 10 at epochs 30, 60 and 90, and use a weight decay of 0.0001. We use 4 GPUs for
training, with a total batch size of 256 (64 per GPU).
C.3 Penn Treebank
We follow Merity et al. (2018) for both the model and optimization details for the Penn Treebank
dataset (Marcus et al., 1994) for character-level language modelling (Mikolov et al., 2010). Again,
15
Under review as a conference paper at ICLR 2020
we measure validation performance for the small-scale experiments, and test performance for the
large-scale ones.
More specifically, we train a 3-layer LSTM (Hochreiter & Schmidhuber, 1997) with an embedding
size of 200, and decay the learning rate by a factor of 10 at epochs 300 and 400, while the model is
trained for a total of 500 epochs. We use a batch size of 128 and BPTT length of 150. The model is
regularized with a weight decay of 1.2 × 10-6, a weight dropout (Merity et al., 2017) ofp = 0.5,
and a dropout (Srivastava et al., 2014) ofp = 0.1 for the input and output layers andp = 0.25 for the
hidden-layer.
16