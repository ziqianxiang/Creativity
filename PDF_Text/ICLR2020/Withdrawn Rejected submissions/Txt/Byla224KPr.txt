Under review as a conference paper at ICLR 2020
An Empirical Study on Post-processing
Methods for Word Embeddings
Anonymous authors
Paper under double-blind review
Ab stract
Word embeddings learnt from large corpora have been adopted in various appli-
cations in natural language processing and served as the general input representa-
tions to learning systems. Recently, a series of post-processing methods have been
proposed to boost the performance of word embeddings on similarity comparison
and analogy retrieval tasks, and some have been adapted to compose sentence rep-
resentations. The general hypothesis behind these methods is that by enforcing the
embedding space to be more isotropic, the similarity between words can be better
expressed. We view these methods as an approach to shrink the covariance/gram
matrix, which is estimated by learning word vectors, towards a scaled identity
matrix. By optimising an objective in the semi-Riemannian manifold with Cen-
tralised Kernel Alignment (CKA), we are able to search for the optimal shrinkage
parameter, and provide a post-processing method to smooth the spectrum of learnt
word vectors which yields improved performance on downstream tasks.
1	Introduction
Distributed representations of words have been widely dominating the Natural Language Processing
research area and other related research areas where discrete tokens in text are part of the learning
systems. Fast learning algorithms are being proposed, criticised, and improved. Despite the fact that
there exist various learning algorithms (Mikolov et al., 2013a; Pennington et al., 2014; Bojanowski
et al., 2017) for producing high-quality distributed representations of words, the main objective is
roughly the same, which is drawn from the Distributional Hypothesis (Harris, 1954). The algorithms
assume that there is a smooth transition of meaning at the word-level, thus they learn to assign higher
similarity for adjacent word vectors than those that are not adjacent.
The overwhelming success of distributed word vectors leads to subsequent questions and analyses
on the information encoded in the learnt space. As the learning algorithms directly and only utilise
the co-occurrence provided by large corpora, it is easy to hypothesise that the learnt vectors are
correlated with the frequency of each word, which may not be relevant to the meaning of a word
(Turney & Pantel, 2010) and might hurt the expressiveness of the learnt vectors. One can theorise the
frequency-related components in the learnt vector space, and remove them (Arora et al., 2017; Mu
et al., 2018; Ethayarajh, 2018). These post-processing methods, whilst very effective and appealing,
are derived from heavy assumptions on the representation geometry and the similarity measure.
In this work we re-examine the problem of post-processing word vectors as a shrinkage estimation
of the true/underlying oracle gram matrix of words, which is a rank-deficient matrix due to the
existence of synonyms and antonyms. Constrained from the semi-Riemannian manifold (Benn &
Tucker, 1987; Abraham et al., 1983) where positive semi-definite matrices, including gram matrices,
exist, and Centralised Kernel Alignment (Cortes et al., 2012), we are able to define an objective to
search for the optimal shrinkage parameter, also called mixing parameter, that is used to mix the
estimated gram matrix and a predefined target matrix with the maximum similarity with the oracle
matrix on the semi-Riemannian manifold. Our contribution can be considered as follows:
1.	We define the post-processing on word vectors as a shrinkage estimation, in which the estimated
gram matrix is calculated from the pretrained word embeddings, and the target matrix is a scaled
identity matrix for smoothing the spectrum of the estimated one. The goal is to find the optimal
mixing parameters to combine the estimated gram matrix with the target in the semi-Riemannian
manifold that maximises the similarity between the combined matrix and the oracle one.
1
Under review as a conference paper at ICLR 2020
2.	We choose to work with the CKA, as it is invariant to isotropic scaling and also rotation, which is
a desired property as the angular distance (cosine similarity) between two word vectors is commonly
used in downstream tasks for evaluating the quality of learnt vectors. Instead of directly deriving
formulae from the CKA (Eq. 1), we start with the logarithm of CKA (Eq. 2), and then find an
informative lower bound (Eq. 5). The remaining analysis is done on the lower bound.
3.	A useful objective is derived to search for the optimal mixing parameter, and the performance
on the evaluation tasks shows the effectiveness of our proposed method. Compared with two other
methods, our approach shows that the shrinkage estimation on a sub-Riemannian manifold works
better than that on an Euclidean manifold for word embedding matrices, and it provides an alter-
native way to smooth the spectrum by adjusting the power of each linearly independent component
instead of removing top ones.
2	Related Work
Several post-processing methods have been proposed for readjusting the learnt word vectors (Mu
et al., 2018; Arora et al., 2017; Ethayarajh, 2018) to make the vector cluster more isotropic w.r.t. the
origin such that cosine similarity or dot-product can better express the relationship between word
pairs. A common practice is to remove top principal components of the learnt word embedding
matrix as it has been shown that those directions are highly correlated with the occurrence. Despite
the effectiveness and efficiency of this family of methods, the number of directions to remove and
also the reason to remove are rather derived from empirical observations, and they don’t provide a
principled way to estimate these two factors. In our case, we derive a useful objective that one could
take to search for the optimal mixing parameter on their own pretrained word vectors.
As described above, we view the post-processing method as a shrinkage estimation on the semi-
Riemannian manifold. Recent advances in machine learning research have developed various ways
to learn word vectors in hyperbolic space (Nickel & Kiela, 2017; Dhingra et al., 2018; Gulcehre
et al., 2019). Although the Riemannian manifold is a specific type of hyperbolic geometry, our
data samples on the manifold are gram matrices of words instead of word vectors themselves in
previous work, , which makes our work different from previous ones. The word vectors themselves
are still considered in Euclidean space for the simple computation of similarity between pairs, and
the intensity of the shrinkage estimation is optimised to adjust the word vectors.
Our work is also related to previously proposed shrinkage estimation of covariance matrices (Ledoit
& Wolf, 2004; Schafer & Strimmer, 2005). These methods are practically useful when the number
of variables to be estimated is much more than that of the samples available. However, the mixing
operation between the estimated covariance matrix and the target matrix is a weighted sum, and l2
distance is used to measure the difference between the true/underlying covariance matrix and the
mixed covariance matrix. As known, covariance matrices are positive semi-definite, thus they lie
on a semi-Riemannian manifold with a manifold-observing distance measure. A reasonable choice
is to conduct the shrinkage estimation on the semi-Riemannian manifold, and CKA is applied to
measure the distance as rotations and istropic scaling should be ignored with measuring two sets of
word vectors. The following sections will discuss our approach in details.
3	Shrinkage of Gram Matrix
Learning word vectors can be viewed as estimating the oracle gram matrix where the relationship of
words is expressed, and the post-processing method we propose here aims to best recover the oracle
gram matrix. Suppose there exists an ideal gram matrix K ∈ Rn×n where each entry represents the
similarity of a word pair defined by a kernel function k(wi , wj ). Given the assumption of a gram
matrix and the existence of polysemies, the oracle gram matrix K is positive semi-definite and its
rank is between 0 and n and denoted as k.
A set of pretrained word vectors is provided by a previously proposed algorithm, and for simplicity,
an embedding matrix E ∈ Rn×d is constructed in which each row is a word vector vi. The estimated
gram matrix K0 = EE> ∈ Rn×n has rank d and d ≤ k. It means that overall, the previously
proposed algorithms give us a low-rank approximation of the oracle gram matrix K .
2
Under review as a conference paper at ICLR 2020
The goal of shrinkage is to, after the estimated gram matrix K0 is available, find an optimal post-
processing method to maximise the similarity between the oracle gram matrix K and the estimated
one K0 given simple assumptions about the ideal one without directly finding it. Therefore, a proper
similarity measure that inherits and respects our assumptions is crucial.
3.1	Centralised Kernel Alignment (CKA)
The similarity measure between two sets of word vectors should be invariant to any rotations and
also to isotropic scaling. A reasonable choice is the Centralised Kernel Alignment (CKA) (Cortes
et al., 2012) defined below:
K0	hKc, KciF
ρ( c, c)= ∣∣Kc∣∣F||KC||F	( )
where KC = [I - 111>] K [I - 111>], and hKc, Kc〉f = Tr(KcKcc). For simplicity ofthe deriva-
tions below, we assume that the ideal gram matrix K is centralised, and the estimated one K0 can
be centralised easily by removing the mean of word vectors. In the following section, K and K0 are
used to denote centralised gram matrices.
As shown in Eq. 1, it is clear that ρ(K, K0) is invariant to any rotations and isotropic scaling, and
doesn’t suffer from the issues of K and K0 being low-rank. The centralised kernel alignment has
been recommended recently as a proper measure for comparing the similarity of features learnt by
neural networks (Kornblith et al., 2019). As learning word vectors can be thought ofas a one-layer
neural network with linear activation function, ρ(K, K0) is a reasonable similarity measure between
the ideal gram matrix and our shrunken one provided by learning algorithms. Given the Cauchy-
Schwartz inequality and also the non-negativity of the Frobenius norm, ρ(K, K0) ∈ [0, 1].
Since both K and K0 are positive semi-definite, their eigenvalues are denoted as {λσ1 , λσ2 , ..., λσk }
and {λν1 , λν2 , ..., λνd} respectively, and the eigenvalues of KK0 are denoted as {λ1, λ2, ..., λd} as the
rank is determined by the matrix with lower rank.1 The log-transformation is conducted to simplify
the derivation.
log ρ(K, K0) =logTr(KK0) - 1 logTr(KK>) - 2 logTr(K0K0>)
≥ 1 log (det(K)det(K0)) - 1 logTr(KK>) - 1 logTr(K0K0>)
=1 Pk=1 lθg λσi + ⅛ Pfi=I lθg λVi - 1 log Pk=1 *i - 2 log Pfi=I λVi	(2)
where the lower bound is given by the AM-GM inequality, and the equality holds when all eigen-
values of KK0 are the same λ1 = λ2 = ... = λi.
3.2	Shrinkage of Gram Matrix on semi-Riemannian Manifold
As the goal is to find a post-processing method that maximises the similarity ρ(K, K0), a widely
adopted approach is to shrink the estimated gram matrix K0 towards the target matrix T with a
predefined structure. The target matrix T is usually positive semi-definite and has same or higher
rank than the estimated gram matrix. In our case, we assume T is full rank as it simplifies equations.
Previous methods rely on a linear combination of K0 and T in Euclidean space (Ledoit & Wolf,
2004; Schafer & Strimmer, 2005). However, as gram matrices are positive semi-definite, they nat-
urally lie on the semi-Riemannian manifold. Therefore, a suitable option for shrinkage is to move
the estimated gram matrix K0 towards the target matrix T on a semi-Riemannian manifold (Brenier,
1987), and the resulting matrix Y is given by
Y = T1/2 (T -1/2 K0 T -1/2 )β T1/2
(3)
where β ∈ [0, 1] is the mixing parameter that indicates the strength of the shrinkage, and T1/2 is the
square root of the matrix T. The objective is to find the optimal β that maximises logρ(K, K0).
β? = argmaxβ log ρ(K, Y) = argmaxβ log P (K, T1/2 (T-1∕2K0T-1∕2)βT1/2)	(4)
The objective defined in Eq. 4 is hard to work with, instead, we maximise the lower bound in Eq.
2 to find optimal mixing parameter β? . By plugging Y into Eq. 2 and denoting λyi as the i-th
eigenvalue of Y, we have:
log P(K, Y) ≥ 1 Pk=Ilog λσi + i Pi=Ilog λyi - 1 log Pk=I λ2i - 1 log Pi=I &i	(5)
1 λσk = λνd = 0 due to the centralisation.
3
Under review as a conference paper at ICLR 2020
3.3	Scaled Identity Matrix as Target for Shrinkage
Recent progress in analysing pretrained word vectors (Mu et al., 2018; Arora et al., 2017) recom-
mended to make them isotropic by removing top principal components as they highly correlate with
the frequency information of words, and it results in a more compressed eigenspectrum. In Eu-
Clidean space-based shrinkage methods (Anderson, 2004; Schafer & Strimmer, 2005), the spectrum
is also smoothed by mixing the eigenvalues with ones to balance the overestimated large eigenvalues
and underestimated small eigenvalues. In both cases, the goal is to smooth the spectrum to make it
more isotropic, thus an easy target matrix to start with is the scaled identity matrix, which is noted
as T = αI, where α is the scaling parameter and I is the identity matrix. Thus, the resulting matrix
Y and the lower bound in Eq. 2 become
Y = (αI)1/2 ((αI)-1/2K0(aI)T2y (αI)1/2 = α1-βK0β	(6)
log ρ(K, Y) ≥ L(β) = d Pk=1 log λσi + d Pd=1 log λVi - 1 log Pk=1 λ2 - 2 log Pd=1 λVβ ⑺
It is easy to show that, when β = 0, the resulting matrix Y becomes the target matrix αI, and when
β = 1, no shrinkage is performed as Y = K0. Eq. 7 indicates that the lower bound is only a function
of β with no involvement from the scaling parameter α brought by the target matrix as the CKA is
invariant to isotropic scaling.
3.4	Noiseless Estimation
Starting from the simplest case, we assume that the estimation process from learning word vectors
E to constructing the estimated gram matrix K0 is noiseless, thus the first order and the second order
derivative of L(β) with respect to β are crucial for finding the optimal β?:
∂L(β)
∂β
d	d	λ2β
X dlog λνi- Xp⅛ log λνi
i=1 d	i=1	j=1 λνj
∂2L(β) =_2 X λV? log2 λVi + 2 (Pd=1 λνβlog λνJ
k=- J ɪλr+	(Pd=I λν?)2
(8)
(9)
Since L(β) is invariant to isotropic scaling on {λνi |i ∈ 1, 2, ..., d}, we are able to scale them by the
inverse of their sum, then pνi = λνi / Pid=1 λνi defines a distribution. To avoid losing information
of the estimated gram matrix K0, we redefine the plausible range for β as (0, 1]. Eq. 8 can be
interpreted as
dL(β) = Pd=1 qi logPVi - Pd=1r(β)i logPVi	(qi = d ,r(β)i = PdRe)
∂β	j=1 λνj
=2dβ (H(r(β)) - H(q,r(β))) = 2β (H(r(β)) - H⑷-DKL(q||r(e))) < 0	(IO)
where DKL (q||P) is the Kullback-Leibler divergence and it is non-negative, H(q) is the entropy of
the uniform distribution q, and H (r(β), P) is the cross-entropy for r and P. The inequality derives
from the fact that the uniform distribution has the maximum entropy. Thus, the first order derivative
L0(β) is always less than 0. With the same definition of qi and r(β)i in Eq. 10, the second order
derivative L00 (β) can be rewritten as
ddL(β) = Pd=I r(β)i log PVi (Pd=I r(β)i log PVj - Pk = I qk log PVk
=盅H (r(β),P) (H(r(β)) - H(q,r(β))) <。
(11)
As shown, L0(β) < 0 means that L(β) monotonically decreases in the range of (0, 1] forβ, and the re-
sulting matrix Y = αI completely ignores the estimated gram matrix K0. L0 (β) also monotonically
decreases in the range of (0, 1] for β because L00(β) < 0.
The observation is similar to the finding reported in previous work (Schafer & Strimmer, 2005) on
shrinkage estimation of covariance matrices that any target will increase the similarity between the
oracle covariance matrix and the mixed covariance matrix. In our case, simply reducing β from 1 to
0 increases Eq. 2, and consequently, β → 0+ loses all information estimated which is not ideal.
However, one can rewrite Eq. 11 as L00(β) = H (r(β), P)2 - H(q)H (r(β),P) and q is the uniform
distribution which has maximum entropy, the derivative of L00(β) with respect to H (r(β), P) gives
4
Under review as a conference paper at ICLR 2020
2H (r(β), p)-H(q), and by setting the derivative to 0, it tells us that there exists a β which results in a
specific r that gives H (r(β),p) = 2H(q). Since H (r(β),p) monotonically increases when β moves
from 0+ to 1, and limβ→0+ H (r(β),p) = H (q,p) < 1H(q) and H (r(1),p) > 1H(q), there exists a
single β ∈ (0,1] that gives the smallest value of L0 (β). This indicates that there exists a β that leads
to the slowest change in the function value L⑶.Then, We simply set β? = β. In practice, β should
be larger than 0.5 in order not to make the resulting matrix overpowered by the target matrix, so one
could run a binary search on β ∈ [0.5, 1] that gives smallest value of L00(β).
Intuitively, this method is similar to using an elbow plot to find the optimal number of components
to keep when running Principal Component Analysis (PCA) on observed data. To translate in our
case, a larger value of β leads to flatter spectrum and higher noise level as the scaled identity matrix
represents isotropic noise. The optimal β? gives us a point where the increase ofL(β) is the slowest.
Once optimal mixing parameters β? are found, the resulting matrix Y = K0β? = Eβ? (Eβ? )>, and
α is omitted here. As a post-processing method for word vectors, we propose to transform the word
vectors in the following fashion:
1.	E = E - 1 pn=ι Ei∙
2.	Singular Value Decomposition E = USV >
3.	Optimal Mixing Parameter β? = arg minβ L00
4.	Reconstruct the matrix E? = U(S)β? V >
4	Experiments
Three learning algorithms are applied to derive word vectors, including skipgram (Mikolov et al.,
2013b), CBOW (Mikolov et al., 2013a) and GloVe (Pennington et al., 2014).2 EE> serves as the
estimated gram matrix K 0. Hyperparameters of each algorithm are set to the recommended values.
The training corpus is collected from Wikipedia and it contains around 4600 million tokens. The
unique tokens include ones that occur at least 100 times in the corpus and the resulting dictionary
size is 366990. After learning, the word embedding matrix is centralised and then the optimal mixing
parameter β? is directly estimated from the singular values of the centralised word vectors. After-
wards, the postprocessed word vectors are evaluated on a series of word-level tasks to demonstrate
the effectiveness of our method. Although the range of β is set to [0.5, 1.0] and the optimal value is
found by minimising L00(β), it seldomly hits 0.5, which means that searching is still necessary.
4.1	Comparison Partners
Two comparison partners are chosen to demonstrate the effectiveness of our proposed method. One
is the method (Mu et al., 2018) that removes the top 2 or 3 principal components on the zero-centred
word vectors, and the number of top principal components to remove depends on the training algo-
rithm used for learning word vectors, and possibly the training corpus. Thus, the selection process
is not automatic, while ours is. The hypothesis behind this method is similar to ours, as the goal
is to make the learnt word vectors more isotropic. However, removing top principal components,
which are correlated with the frequency of each word, could also remove relevant information that
indicates the relationship between words. The observation that our method is able to perform on par
with or better than this comparison partner supports our hypothesis.
The other comparison partner is the optimal shrinkage (Ledoit & Wolf, 2004) on the estimated
covariance matrices as the estimation process tends to overestimate the directions with larger power
and underestimate the ones with smaller power, and the optimal shrinkage aims to best recover the
true covariance matrix with minimum assumptions about it, which has the same goal as our method.
The resulting matrix Y is defined to be a linear combination of the estimated covariance matrix and
the target with a predefined structure, and it is denoted as Y = (1 - β)αI + βΣ0, where in our case,
Σ0 = E>E ∈ Rd×d. The optimal shrinkage parameter β is found by minimising the Euclidean
distance between the true covariance matrix Σ and the resulting matrix Y . The issue here is that
Euclidean distance and linear combination may not be the optimal choice for covariance matrices,
and also Euclidean distance is not invariant to isotropic scaling which is a desired property when
measuring the similarity between sets of word vectors.
2https://github.com/facebookresearch/fastText, https://github.com/stanfordnlp/GloVe
5
Under review as a conference paper at ICLR 2020
4.2	Word-level Evaluation Tasks
Three categories of word-level evaluation tasks are considered, including 8 tasks for word similarity,
3 for word analogy and 6 for concept categorisation. The macro-averaged results for each category
of tasks are presented in Table 1. Details about tasks are included in the appendix.
Table 1: Results of three post-processing methods including ours on our pretrained word vec-
tors from three learning algorithms. In each cell, the three numbers refer to word vectors produced
by “Skipgram / CBOW / GloVe”, and the dimension of them is 500. Bold indicates the best macro-
averaged performance of post-processing methods. It shows that overall, our method is effective.
Postprocessing	Il Similarity (8)	I	Analogy (3)	Concept (6)	Il	Overall (17)
None	Il 64.66/57.65/54.81	I 46.23/48.70/46.68	I 68.70/68.34/66.86	Il 62.83/59.84/57.63
Mu et al. (2018)	Il 64.24/60.12/61.57	I 46.87 /49.10/40.09	I 68.86/ 70.46 /65.54	Il 62.81 /61.83/59.18
Ledoit & Wolf (2004)	Il 63.39/59.19/50.81	I 46.64 / 50.38 /45.54	I 69.45/68.83/ 69.55	Il 62.57/61.03/56.50
Ours	Il 63.79/60.90/53.16	I 46.51 /49.84/ 47.25	I 70.83 /69.84/65.97	Il 63.23/62.10/56.54
4.3	Word Translation Tasks
Table 2 presents results on supervised and unsupervised word translation tasks (Lample et al., 2018)
3 given pretrained word vectors from FastText (Bojanowski et al., 2017). The supervised word
translation is formalised as solving a Procrustes problem directly. The unsupervised task first trains
a mapping through adversarial learning and then refines the learnt mapping through the Procrustes
problem with a dictionary constructed from the mapping learnt in the first step. The evaluation is
done by k-NN search and reported in top-1 precision.
Table 2: Performance on word translation. The translation is done through k-NN with two dis-
tances, in which one is the cosine similarity (noted as “NN” in the table), and the other one is the
Cross-domain Similarity Local Scaling (CSLS) (Lample et al., 2018). The Ledoit & Wolf’s method
didn’t converge on unsupervised training so we excluded results from the method in the table.
Post-processing 		en-es		es-en		en-fr		fr-en		en-de		de-en	
	NN	CSLS	NN	CSLS	NN	CSLS	NN	CSLS	NN	CSLS	NN	CSLS
Supervised Procrustes Problem												
None	79.0	81.7	79.2	83.3	78.4	82.1	78.5	81.9	71.1	73.4	69.7	72.7
Mu et al. (2018)	80.0	81.7	80.4	83.0	79.3	82.4	78.5	81.7	72.9	75.4	70.7	73.1
Ledoit & Wolf (2004)	80.1	82.3	79.6	82.9	78.7	81.9	78.9	82.0	72.3	74.1	70.6	72.4
Ours		82.3	80.9	83.0	^9T	82.1	79.2	81.7	ʒɪr	74∙5	ʒzr	72.9
Unsupervised Adversarial Training + Refinement												
None	79.7	82.0	78.8	83.7	78.4	81.8	77.9	82.1	71.7	74.7	69.7	73.1
Mu et al. (2018)	79.7	81.7	80.5	84.3	79.6	82.7	78.9	81.8	72.3	75.0	71.2	72.9
Ours	80.4	82.3	^81T	83.1	ʒ9T	82.0	ʒ9T	82.1	ʒzr	74∙8	ʒzr	73.7
4.4	Sentence-level Evaluation Tasks
The evaluation tasks include five tasks from SemEval Semantic Textual Similarity (STS) in 2012-
2016 (Agirre et al., 2012; 2013; 2014; 2015; 2016). A sentence vector is constructed by simply
averaging word vectors or postprocessed word vectors, and the similarity measure is cosine similar-
ity as well. The performance on each task is reported as the Pearson’s correlation score.
We evaluate our post-processing at two different levels, in which one applies the post-processing
methods on word vectors before averaging them to form sentence vectors (Mu et al., 2018), and the
other one applies methods on averaged word vectors, which are sentence vectors, directly (Arora
3https://github.com/facebookresearch/MUSE
6
Under review as a conference paper at ICLR 2020
et al., 2017). Applying the post-processing to sentence vectors results in better performance and our
method leads to the best performance on each dataset. Results are reported in Table 3.
Table 3: Performance of our post-processing method and the other two comparison partners on
SemEval datasets. The task is to make good predictions of sentence vectors composed of averaging
word vector. The word-level post-processing means that all methods are applied on word vectors
before averaging, and the sentence-level one means that all methods are applied on sentence vectors.
Our method performs better than others at sentence-level and slightly worse than the method that
removes top principal components on the word level. Overall the sentence-level post-processing
results in superior performance. Our method has the best overall performance on each dataset.
Postprocessing ∣ STS12 I STS13 I STS14 ∣ STS15 ∣ STS16 ∣ STS12 ∣ STS13 ∣ STS14 ∣ STS15 ISTS16
I	word-level post-processing (MUetaL, 2018)	∣ sentence-level post-processing (AroraetaL, 2017)
RM Top PCs	59.07	53.30	65.98	69.54	67.22	59.20	57.92	69.31	74.08	72.26
Ledoit & Wolf (2004)	54.75	47.93	60.57	65.36	64.87	54.47	57.92	64.79	70.84	58.53
Ours	57.36	51.80	65.04	68.23	66.31	62.60	62.09	70.99	75.83	74.49
5	Discussion
The results presented in Table 1, 2 and 3 indicate the effectiveness of our methods. In addition,
by comparing to two most related post-processing methods, which are removing top principal com-
ponents (Mu et al., 2018; Arora et al., 2017) and the optimal shrinkage estimation on covariance
matrices in Euclidean space (Ledoit & Wolf, 2004; Schafer & Strimmer, 2005), our method com-
bines the best of the both worlds - the good performance of the first method and the automaticity
property of the second one.
Specifically, our method derives the resulting gram matrix in a semi-Riemannian manifold, and the
shrinkage is done by moving the estimated gram matrix K0 to the scaled identity matrix αI on the
geodesic on the semi-Riemannian manifold defined in Eq. 6. Compared to measuring the Euclidean
distance between two covariance matrices (Ledoit & Wolf, 2004), we chose a distance measure that
respects the structure of the space where positive semi-definite matrices exist. Also, since we are
working with improving the quality of learnt word vectors, given that mostly the angular distance
between a pair of word vectors matters, the similarity measure between two spaces needs to be
invariant to rotation and isotropic scaling, and the Centralised Kernel Alignment is a good fit in our
case. Compared to the post-processing method that removes top principal components, our method
defines an objective function where the unique minimum point in the specific range indicates the
optimal shrinkage parameter β?, and which doesn’t require any human supervision on finding the
parameters (the number of principal components to remove in that method).
The derivations in our work are mostly done on the lower bound in Eq. 2 of the original log of CKA
ρ(K, K0), and the bound is tight when KK0 has a flat spectrum. In this sense, the lower bound
essentially defines the similarity of the resulting matrix Y and a scaled identity matrix where the
scaling factor is the average of the eigenvalues of KK0 . As the isotropic scaling can be ignored in
our case, intuitively, the lower bound (Eq. 2) gives us how to shrink an estimated gram matrix to
an identity matrix. Since the target matrix T = αI is also a scaled identity matrix, the lower bound
keeps increasing as Y travels from K0 to T, and it explains why the first order derivative is negative
and the second order derivative is more informative. Our method is very similar to using an elbow
plot to find the number of eigenvalues to keep in PCA. Future work should focus on finding a tighter
bound that considers the interaction between the true gram matrix K and the estimated one K0 .
Figure 1 shows that our methods give solid and stable improvement against two comparison part-
ners on learnt word vectors provided by skipgram and CBOW with different dimensions, and slightly
worse than removing top PCs on GloVe. However, skipgram and CBOW provide much better per-
formance thus improvement on these algorithms is more meaningful, and our method doesn’t require
manual speculations on the word vectors to determine the number of PCs to remove. An interesting
observation is that there is a limit on the performance improvement from increasing the dimensional-
ity of word vectors, which was hypothesised and analysed in prior work (Yin & Shen, 2018). Figure
2 shows that our method consistently outperforms two comparison partners when limited amount of
7
Under review as a conference paper at ICLR 2020
,	SkiPgram	.
妄X⅛s≡*0
0.6Or
-∙- None
-H- RM Top PCS
-*- Ledoit & Wolf
0∙55^ -■ - Ours
200	300	400	500	600
Figure 1: Performance change of each post-processing method when the dimension of learnt
word vectors increases. Our method is comparable to the method that removes top PCs on skip-
gram, and better than that on CBOW, and slightly worse than that on GloVe. However, generally
Skipgram and CBOW themselves provide better performance, thus boosting performance by post-
processing on those two learning algorithms is more important. In addition, our model doesn’t
require manually picking the dimensions to remove instead the optimal β? is found by optimisation.
training corpus is provided, and the observation is consistent across learnt word vectors with varying
dimensions. From the perspective of shrinkage estimation of covariance matrices, the main goal is
to optimally recover the oracle covariance matrix under a certain assumption about the oracle one
when limited data is provided. The results presented in Figure 2 indicate that our method is better
at recovering the gram matrix of words, where relationships of word pairs are expressed, as it gives
better performance on word-level evaluation tasks on average.
SkiPgram-3 00
/
Figure 2: Averaged score on 17 tasks vs. Percentage of training data. To simulate the situa-
tion where only limited data is available for shrinkage estimation, two algorithms are trained with
subsampled data with different portions, and three postprocessing methods including ours and two
comparison partners are applied afterwards. The observation here is that our method is able to
recover the similarity between words better than others when only small amount of data is available.
6	Conclusion
We define a post-processing method in the view of shrinkage estimation of the gram matrix. Armed
with CKA and geodesic measured on the semi-Riemannian manifold, a meaningful lower bound is
derived and the second order derivative of the lower bound gives the optimal shrinkage parameter
β? to smooth the spectrum of the estimated gram matrix which is directly calculated by pretrained
word vectors. Experiments on the word similarity and sentence similarity tasks demonstrate the
effectiveness of our model. Compared to the two most relevant post-processing methods (Mu et al.,
2018; Ledoit & Wolf, 2004), ours is more general and automatic, and gives solid performance im-
provement. As the derivation in our paper is based on the general shrinkage estimation of positive
semi-definite matrices, it is potentially useful and beneficial for other research fields when Euclidean
measures are not suitable. Future work could expand our work into a more general setting for shrink-
age estimation as currently the target in our case is an isotropic covariance matrix.
8
Under review as a conference paper at ICLR 2020
Acknowledgements
References
Ralph Abraham, Jerrold E. Marsden, TUdor S. Ratiu, and Cecile DeWitt-Morette. Manifolds, tensor
analysis, and applications. 1983.
Eneko Agirre, Enrique Alfonseca, Keith B. Hall, Jana Kravalova, Marius Pasca, and Aitor Soroa. A
study on similarity and relatedness using distributional and wordnet-based approaches. In HLT-
NAACL, 2009.
Eneko Agirre, Daniel M. Cer, Mona T. Diab, and Aitor Gonzalez-Agirre. Semeval-2012 task 6: A
pilot on semantic textual similarity. In SemEval@NAACL-HLT, 2012.
Eneko Agirre, Daniel M. Cer, Mona T. Diab, Aitor Gonzalez-Agirre, and Weiwei Guo. *sem 2013
shared task: Semantic textual similarity. In *SEM@NAACL-HLT, 2013.
Eneko Agirre, Carmen Banea, Claire Cardie, Daniel M. Cer, Mona T. Diab, Aitor Gonzalez-Agirre,
Weiwei Guo, Rada Mihalcea, German Rigau, and Janyce Wiebe. Semeval-2014 task 10: Multi-
lingual semantic textual similarity. In SemEval@COLING, 2014.
Eneko Agirre, Carmen Banea, Claire Cardie, Daniel M. Cer, Mona T. Diab, Aitor Gonzalez-Agirre,
Weiwei Guo, Inigo Lopez-Gazpio, Montse Maritxalar, Rada Mihalcea, German Rigau, Larraitz
Uria, and Janyce Wiebe. Semeval-2015 task 2: Semantic textual similarity, english, spanish and
pilot on interpretability. In SemEval@NAACL-HLT, 2015.
Eneko Agirre, Carmen Banea, Daniel M. Cer, Mona T. Diab, Aitor Gonzalez-Agirre, Rada Mihalcea,
German Rigau, and Janyce Wiebe. Semeval-2016 task 1: Semantic textual similarity, monolingual
and cross-lingual evaluation. In SemEval@NAACL-HLT, 2016.
Abdulrahman Almuhareb. Attributes in lexical acquisition. PhD thesis, University of Essex, 2006.
Olivier Ledoit Anderson. A well-conditioned estimator for large-dimensional covariance matrices.
2004.
Sanjeev Arora, Yingyu Liang, and Tengyu Ma. A simple but tough-to-beat baseline for sentence
embeddings. In International Conference on Learning Representations, 2017.
Marco Baroni, Stefan Evert, and Alessandro Lenci. Esslli workshop on distributional lexical seman-
tics bridging the gap between semantic theory and computational simulations. 2008.
Marco Baroni, Brian Murphy, Eduard Barbu, and Massimo Poesio. Strudel: A corpus-based seman-
tic model based on properties and types. Cognitive science, 34 2:222-54, 2010.
Ian M Benn and Robin W Tucker. An introduction to spinors and geometry with applications in
physics. 1987.
Piotr Bojanowski, Edouard Grave, Armand Joulin, and Tomas Mikolov. Enriching word vectors
with subword information. TACL, 5:135-146, 2017.
Yann Brenier. Decomposition polaire et rearrangement monotone des champs de vecteurs. CR Acad.
Sci. Paris Ser IMath, 305:805-808,1987.
Elia Bruni, Nam-Khanh Tran, and Marco Baroni. Multimodal distributional semantics. J. Artif.
Intell. Res., 49:1-47, 2014.
Corinna Cortes, Masanori Mohri, and Afshin Rostamizadeh. Algorithms for learning kernels based
on centered alignment. Journal of Machine Learning Research, 13:795-828, 2012.
Bhuwan Dhingra, Christopher J. Shallue, Mohammad Norouzi, Andrew M. Dai, and George E.
Dahl. Embedding text in hyperbolic spaces. In TextGraphs@NAACL-HLT, 2018.
Kawin Ethayarajh. Unsupervised random walk sentence embeddings: A strong but simple baseline.
In Rep4NLP@ACL, 2018.
9
Under review as a conference paper at ICLR 2020
Lev Finkelstein, Evgeniy Gabrilovich, Yossi Matias, Ehud Rivlin, Zach Solan, Gadi Wolfman, and
Eytan Ruppin. Placing search in context: the concept revisited. ACM Trans. Inf. Syst, 20:116-
131, 2002.
Caglar Gulcehre, Misha Denil, Mateusz Malinowski, Ali Razavi, Razvan Pascanu, Karl Moritz
Hermann, Peter Battaglia, Victor Bapst, David Raposo, Adam Santoro, and Nando de Freitas.
Hyperbolic attention networks. In International Conference on Learning Representations, 2019.
URL https://openreview.net/forum?id=rJxHsjRqFQ.
Guy Halawi, Gideon Dror, Evgeniy Gabrilovich, and Yehuda Koren. Large-scale learning of word
relatedness with constraints. In KDD, 2012.
Zellig S Harris. Distributional structure. Word, 10(2-3):146-162, 1954.
Felix Hill, Roi Reichart, and Anna Korhonen. Simlex-999: Evaluating semantic models with (gen-
uine) similarity estimation. Computational Linguistics, 41:665-695, 2015.
Stanislaw Jastrzebski, Damian Lesniak, and Wojciech Czarnecki. How to evaluate word embed-
dings? on importance of data efficiency and simple supervised tasks. CoRR, abs/1702.02170,
2017.
David Jurgens, Saif Mohammad, Peter D. Turney, and Keith J. Holyoak. Semeval-2012 task 2:
Measuring degrees of relational similarity. In SemEval@NAACL-HLT, 2012.
Simon Kornblith, Mohammad Norouzi, Honglak Lee, and Geoffrey Hinton. Similarity of neural
network representations revisited. In Kamalika Chaudhuri and Ruslan Salakhutdinov (eds.), Pro-
ceedings of the 36th International Conference on Machine Learning, volume 97 of Proceedings
of Machine Learning Research, pp. 3519-3529, Long Beach, California, USA, 09-15 Jun 2019.
PMLR. URL http://proceedings.mlr.press/v97/kornblith19a.html.
Guillaume Lample, Alexis Conneau, Marc,Aurelio Ranzato, LudoviC Denoyer, and Herve Jegou.
Word translation without parallel data. In International Conference on Learning Representations,
2018. URL https://openreview.net/forum?id=H196sainb.
Olivier Ledoit and Michael Wolf. Honey, i shrunk the sample covariance matrix. 2004.
Omer Levy, Yoav Goldberg, and Ido Dagan. Improving distributional similarity with lessons learned
from word embeddings. TACL, 3:211-225, 2015.
Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient estimation of word represen-
tations in vector space. arXiv preprint arXiv:1301.3781, 2013a.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean. Distributed
representations of words and phrases and their compositionality. In NIPS, 2013b.
Tomas Mikolov, Wen tau Yih, and Geoffrey Zweig. Linguistic regularities in continuous space word
representations. In HLT-NAACL, 2013c.
Jiaqi Mu, Suma Bhat, and Pramod Viswanath. All-but-the-top: Simple and effective postprocessing
for word representations. In International Conference on Learning Representations, 2018.
Maximilian Nickel and Douwe Kiela. PoinCare embeddings for learning hierarchical representa-
tions. In NIPS, 2017.
Jeffrey Pennington, Richard Socher, and Christopher D. Manning. Glove: Global vectors for word
representation. In EMNLP, 2014.
Herbert Rubenstein and John B. Goodenough. Contextual correlates of synonymy. Commun. ACM,
8:627-633, 1965.
Juliane Schafer and Korbinian Strimmer. A shrinkage approach to large-scale covariance matrix
estimation and implications for functional genomics. Statistical applications in genetics and
molecular biology, 4:Article32, 2005.
10
Under review as a conference paper at ICLR 2020
Peter D. Turney and Patrick Pantel. From frequency to meaning: Vector space models of semantics.
J. Artf Intell. Res., 37:141-188, 2010.
Zi Yin and Yuanyuan Shen. On the dimensionality of word embedding. In Advances in Neural
Information Processing Systems, 2018.
Appendix
A Word-level Evaluation Tasks
8 word similarity tasks: MEN(Bruni et al., 2014), SimLex999(Hill et al., 2015), MTurk(Halawi
et al., 2012), WordSim353(Finkelstein et al., 2002), WordSim-353-REL(Agirre et al., 2009),
WordSim-353-SIM(Agirre et al., 2009), RG65(Rubenstein & Goodenough, 1965). On these, the
similarity of a pair of words is calculated by the cosine similarity between two word vectors, and the
performance is reported by computing Spearman’s correlation between human annotations with the
predictions from the learnt vectors.
3 word analogy tasks: Google Analogy(Mikolov et al., 2013a), SemEval-2012(Jurgens et al.,
2012), MSR(Mikolov et al., 2013c). The task here is to answer the questions in the form of “a
is to a? as b is to b?”, where a, a? and b are given and the goal is to find the correct answer b? .
The ”3CosAdd” method (Levy et al., 2015) is applied to retrieve the answer, which is denoted as
arg maxb? ∈Vw \{a?,b,a} = cos(b?, a? - a + b). Accuracy is reported.
6 concept categorisation tasks: BM(Baroni et al., 2010), AP(Almuhareb, 2006),
BLESS(Jastrzebski et al., 2017), ESSLI(Baroni et al., 2008). The task is to measure whether
words with similar meanings are nicely clustered together. An unsupervised clustering algorithm
with predefined number of clusters is performed on each dataset, and the performance is reported
also in accuracy.
B Python Code
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import numpy as np
def beta_PostProCessing (emb):
# embedding size : number of Word vectors X dim of vectors
mean = np.mean(vecs , axis =0 , keepdims=True)
Centred_emb = emb — mean
u , s , vh = np. linalg . svd( centred ,emb )
def objective (b):
l = s ** 2
logl = np.log(l)
l2b = l ** (2*b)
first_term = np . mean (logl *l2b *logl) *np . mean(l2b )
second_term = np .mean(logl*l2b ) **2.
derivative =  1. / (np .mean( l2b ) ** 2.) * ( first_term —
second_term )
return derivative
values = list (map (objective , np . arange (0.5 , 1.0 , 0.001)))
optimal_beta = np . argmin ( values ) / 1000. + 0.5
ProCessed_emb = u @ np . diag ( s ** optimaLbeta) @ Vh
return ProCessed_emb
Listing 1: Python code for searching for the optimal β?
11